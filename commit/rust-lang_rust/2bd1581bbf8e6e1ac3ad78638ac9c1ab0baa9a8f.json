{"sha": "2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "node_id": "C_kwDOAAsO6NoAKDJiZDE1ODFiYmY4ZTZlMWFjM2FkNzg2MzhhYzljMWFiMGJhYTlhOGY", "commit": {"author": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-05-22T19:41:43Z"}, "committer": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-06-21T17:43:47Z"}, "message": "Add `dev deprecate`", "tree": {"sha": "a6ecd3652391f5459685cfa329f5da3a92e18dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6ecd3652391f5459685cfa329f5da3a92e18dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "html_url": "https://github.com/rust-lang/rust/commit/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/comments", "author": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c6f9ebed65eb4d77a5cf1ccf670cef3b1fca9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c6f9ebed65eb4d77a5cf1ccf670cef3b1fca9e", "html_url": "https://github.com/rust-lang/rust/commit/93c6f9ebed65eb4d77a5cf1ccf670cef3b1fca9e"}], "stats": {"total": 543, "additions": 474, "deletions": 69}, "files": [{"sha": "2ac3b4fe2ed4f456f91188385e6e4aa3638ccc2b", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n aho-corasick = \"0.7\"\n-clap = \"3.1\"\n+clap = \"3.2\"\n indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\""}, {"sha": "243a901503f160f617718e30e16b2242ab99ace6", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -5,6 +5,7 @@\n use clap::{Arg, ArgAction, ArgMatches, Command, PossibleValue};\n use clippy_dev::{bless, fmt, lint, new_lint, serve, setup, update_lints};\n use indoc::indoc;\n+\n fn main() {\n     let matches = get_clap_config();\n \n@@ -85,6 +86,11 @@ fn main() {\n             let uplift = matches.contains_id(\"uplift\");\n             update_lints::rename(old_name, new_name, uplift);\n         },\n+        Some((\"deprecate\", matches)) => {\n+            let name = matches.get_one::<String>(\"name\").unwrap();\n+            let reason = matches.get_one(\"reason\");\n+            update_lints::deprecate(name, reason);\n+        },\n         _ => {},\n     }\n }\n@@ -266,6 +272,18 @@ fn get_clap_config() -> ArgMatches {\n                     .long(\"uplift\")\n                     .help(\"This lint will be uplifted into rustc\"),\n             ]),\n+            Command::new(\"deprecate\").about(\"Deprecates the given lint\").args([\n+                Arg::new(\"name\")\n+                    .index(1)\n+                    .required(true)\n+                    .help(\"The name of the lint to deprecate\"),\n+                Arg::new(\"reason\")\n+                    .long(\"reason\")\n+                    .short('r')\n+                    .required(false)\n+                    .takes_value(true)\n+                    .help(\"The reason for deprecation\"),\n+            ]),\n         ])\n         .get_matches()\n }"}, {"sha": "7d7e760ef446c3b925b3f1eb47b1e1aaf9a50d71", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -138,7 +138,7 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n-fn get_stabilization_version() -> String {\n+pub(crate) fn get_stabilization_version() -> String {\n     fn parse_manifest(contents: &str) -> Option<String> {\n         let version = contents\n             .lines()"}, {"sha": "31deb499b2efc17ff80bf9c4ae5d5b17b72258b8", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 352, "deletions": 41, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -1,16 +1,17 @@\n+use crate::clippy_project_root;\n use aho_corasick::AhoCorasickBuilder;\n-use core::fmt::Write as _;\n+use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n-use std::fs;\n-use std::io::{self, Read as _, Seek as _, Write as _};\n+use std::fmt::Write;\n+use std::fs::{self, OpenOptions};\n+use std::io::{self, Read, Seek, SeekFrom, Write as _};\n+use std::ops::Range;\n use std::path::{Path, PathBuf};\n use walkdir::{DirEntry, WalkDir};\n \n-use crate::clippy_project_root;\n-\n const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n      // Use that command to update this file and do not edit by hand.\\n\\\n      // Manual edits will be overwritten.\\n\\n\";\n@@ -326,6 +327,198 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n     println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n }\n \n+const DEFAULT_DEPRECATION_REASON: &str = \"default deprecation note\";\n+/// Runs the `deprecate` command\n+///\n+/// This does the following:\n+/// * Adds an entry to `deprecated_lints.rs`.\n+/// * Removes the lint declaration (and the entire file if applicable)\n+///\n+/// # Panics\n+///\n+/// If a file path could not read from or written to\n+pub fn deprecate(name: &str, reason: Option<&String>) {\n+    fn finish(\n+        (lints, mut deprecated_lints, renamed_lints): (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>),\n+        name: &str,\n+        reason: &str,\n+    ) {\n+        deprecated_lints.push(DeprecatedLint {\n+            name: name.to_string(),\n+            reason: reason.to_string(),\n+            declaration_range: Range::default(),\n+        });\n+\n+        generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n+        println!(\"info: `{}` has successfully been deprecated\", name);\n+\n+        if reason == DEFAULT_DEPRECATION_REASON {\n+            println!(\"note: the deprecation reason must be updated in `clippy_lints/src/deprecated_lints.rs`\");\n+        }\n+        println!(\"note: you must run `cargo uitest` to update the test results\");\n+    }\n+\n+    let reason = reason.map_or(DEFAULT_DEPRECATION_REASON, String::as_str);\n+    let name_lower = name.to_lowercase();\n+    let name_upper = name.to_uppercase();\n+\n+    let (mut lints, deprecated_lints, renamed_lints) = gather_all();\n+    let Some(lint) = lints.iter().find(|l| l.name == name_lower) else { panic!(\"failed to find lint `{}`\", name) };\n+\n+    let mod_path = {\n+        let mut mod_path = PathBuf::from(format!(\"clippy_lints/src/{}\", lint.module));\n+        if mod_path.is_dir() {\n+            mod_path = mod_path.join(name);\n+        }\n+\n+        mod_path.set_extension(\"rs\");\n+        mod_path\n+    };\n+\n+    let deprecated_lints_path = &*clippy_project_root().join(\"clippy_lints/src/deprecated_lints.rs\");\n+\n+    if remove_lint_declaration(&name_lower, &mod_path, &mut lints).unwrap_or(false) {\n+        declare_deprecated(&name_upper, deprecated_lints_path, reason).unwrap();\n+        finish((lints, deprecated_lints, renamed_lints), name, reason);\n+        return;\n+    }\n+\n+    eprintln!(\"error: lint not found\");\n+}\n+\n+fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io::Result<bool> {\n+    fn remove_lint(name: &str, lints: &mut Vec<Lint>) {\n+        lints.iter().position(|l| l.name == name).map(|pos| lints.remove(pos));\n+    }\n+\n+    fn remove_test_assets(name: &str) {\n+        let test_file_stem = format!(\"tests/ui/{}\", name);\n+        let path = Path::new(&test_file_stem);\n+\n+        // Some lints have their own directories, delete them\n+        if path.is_dir() {\n+            fs::remove_dir_all(path).ok();\n+            return;\n+        }\n+\n+        // Remove all related test files\n+        fs::remove_file(path.with_extension(\"rs\")).ok();\n+        fs::remove_file(path.with_extension(\"stderr\")).ok();\n+        fs::remove_file(path.with_extension(\"fixed\")).ok();\n+    }\n+\n+    fn remove_impl_lint_pass(lint_name_upper: &str, content: &mut String) {\n+        let impl_lint_pass_start = content.find(\"impl_lint_pass!\").unwrap_or_else(|| {\n+            content\n+                .find(\"declare_lint_pass!\")\n+                .unwrap_or_else(|| panic!(\"failed to find `impl_lint_pass`\"))\n+        });\n+        let mut impl_lint_pass_end = (&content[impl_lint_pass_start..])\n+            .find(']')\n+            .expect(\"failed to find `impl_lint_pass` terminator\");\n+\n+        impl_lint_pass_end += impl_lint_pass_start;\n+        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(&lint_name_upper) {\n+            let mut lint_name_end = impl_lint_pass_start + (lint_name_pos + lint_name_upper.len());\n+            for c in content[lint_name_end..impl_lint_pass_end].chars() {\n+                // Remove trailing whitespace\n+                if c.is_whitespace() {\n+                    lint_name_end += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            content.replace_range(impl_lint_pass_start + lint_name_pos..lint_name_end, \"\");\n+        }\n+    }\n+\n+    if path.exists() {\n+        if let Some(lint) = lints.iter().find(|l| l.name == name) {\n+            if lint.module == name {\n+                // The lint name is the same as the file, we can just delete the entire file\n+                fs::remove_file(path)?;\n+            } else {\n+                // We can't delete the entire file, just remove the declaration\n+                if lint.module != name {\n+                    let mut mod_decl_path = path.to_path_buf();\n+                    if mod_decl_path.is_dir() {\n+                        mod_decl_path = Path::new(\"clippy_lints/src\").join(&lint.module).join(\"mod.rs\");\n+                    }\n+\n+                    let mut content = fs::read_to_string(&mod_decl_path)\n+                        .unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n+\n+                    eprintln!(\n+                        \"warn: you will have to manually remove any code related to `{}` from `{}`\",\n+                        name,\n+                        &mod_decl_path.to_string_lossy()\n+                    );\n+\n+                    assert!(\n+                        content[lint.declaration_range.clone()].contains(&name.to_uppercase()),\n+                        \"error: `{}` does not contain lint `{}`'s declaration\",\n+                        mod_decl_path.display(),\n+                        lint.name\n+                    );\n+\n+                    // Remove lint declaration (declare_clippy_lint!)\n+                    content.replace_range(lint.declaration_range.clone(), \"\");\n+\n+                    // Remove the module declaration (mod xyz;)\n+                    let mod_decl = format!(\"\\nmod {};\", name);\n+                    content = content.replacen(&mod_decl, \"\", 1);\n+\n+                    remove_impl_lint_pass(&lint.name.to_uppercase(), &mut content);\n+                    fs::write(mod_decl_path, content)\n+                        .unwrap_or_else(|_| panic!(\"failed to write to `{}`\", path.to_string_lossy()));\n+                }\n+            }\n+\n+            remove_test_assets(name);\n+            remove_lint(name, lints);\n+            return Ok(true);\n+        }\n+    }\n+\n+    Ok(false)\n+}\n+\n+fn declare_deprecated(name: &str, path: &Path, reason: &str) -> io::Result<()> {\n+    let mut file = OpenOptions::new().write(true).open(path)?;\n+\n+    file.seek(SeekFrom::End(0))?;\n+\n+    let version = crate::new_lint::get_stabilization_version();\n+    let deprecation_reason = if reason == DEFAULT_DEPRECATION_REASON {\n+        \"TODO\"\n+    } else {\n+        reason\n+    };\n+\n+    writedoc!(\n+        file,\n+        \"\n+\n+        declare_deprecated_lint! {{\n+            /// ### What it does\n+            /// Nothing. This lint has been deprecated.\n+            ///\n+            /// ### Deprecation reason\n+            /// {}\n+            #[clippy::version = \\\"{}\\\"]\n+            pub {},\n+            \\\"{}\\\"\n+        }}\n+\n+        \",\n+        deprecation_reason,\n+        version,\n+        name,\n+        reason,\n+    )\n+}\n+\n /// Replace substrings if they aren't bordered by identifier characters. Returns `None` if there\n /// were no replacements.\n fn replace_ident_like(contents: &str, replacements: &[(&str, &str)]) -> Option<String> {\n@@ -393,16 +586,18 @@ struct Lint {\n     group: String,\n     desc: String,\n     module: String,\n+    declaration_range: Range<usize>,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, module: &str) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n+            declaration_range,\n         }\n     }\n \n@@ -433,12 +628,14 @@ impl Lint {\n struct DeprecatedLint {\n     name: String,\n     reason: String,\n+    declaration_range: Range<usize>,\n }\n impl DeprecatedLint {\n-    fn new(name: &str, reason: &str) -> Self {\n+    fn new(name: &str, reason: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             reason: remove_line_splices(reason),\n+            declaration_range,\n         }\n     }\n }\n@@ -610,7 +807,11 @@ fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n macro_rules! match_tokens {\n     ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n          {\n-            $($(let $capture =)? if let Some((TokenKind::$token $({$($fields)*})?, _x)) = $iter.next() {\n+            $($(let $capture =)? if let Some(LintDeclSearchResult {\n+                    token_kind: TokenKind::$token $({$($fields)*})?,\n+                    content: _x,\n+                    ..\n+            }) = $iter.next() {\n                 _x\n             } else {\n                 continue;\n@@ -621,40 +822,72 @@ macro_rules! match_tokens {\n     }\n }\n \n+struct LintDeclSearchResult<'a> {\n+    token_kind: TokenKind,\n+    content: &'a str,\n+    range: Range<usize>,\n+}\n+\n /// Parse a source file looking for `declare_clippy_lint` macro invocations.\n fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n     let mut offset = 0usize;\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n \n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_clippy_lint\") {\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n+    ) {\n+        let start = range.start;\n+\n         let mut iter = iter\n             .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n         match iter.next() {\n             // #[clippy::version = \"version\"] pub\n-            Some((TokenKind::Pound, _)) => {\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Pound,\n+                ..\n+            }) => {\n                 match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n             },\n             // pub\n-            Some((TokenKind::Ident, _)) => (),\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Ident,\n+                ..\n+            }) => (),\n             _ => continue,\n         }\n+\n         let (name, group, desc) = match_tokens!(\n             iter,\n             // LINT_NAME\n             Ident(name) Comma\n             // group,\n             Ident(group) Comma\n-            // \"description\" }\n-            Literal{..}(desc) CloseBrace\n+            // \"description\"\n+            Literal{..}(desc)\n         );\n-        lints.push(Lint::new(name, group, desc, module));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(Lint::new(name, group, desc, module, start..range.end));\n+        }\n     }\n }\n \n@@ -664,12 +897,24 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_deprecated_lint\") {\n-        let mut iter = iter\n-            .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_deprecated_lint\",\n+    ) {\n+        let start = range.start;\n+\n+        let mut iter = iter.by_ref().filter(|LintDeclSearchResult { ref token_kind, .. }| {\n+            !matches!(token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. })\n+        });\n         let (name, reason) = match_tokens!(\n             iter,\n             // !{\n@@ -680,10 +925,16 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n             Ident Ident(name) Comma\n             // \"description\"\n             Literal{kind: LiteralKind::Str{..},..}(reason)\n-            // }\n-            CloseBrace\n         );\n-        lints.push(DeprecatedLint::new(name, reason));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(DeprecatedLint::new(name, reason, start..range.end));\n+        }\n     }\n }\n \n@@ -693,8 +944,14 @@ fn parse_renamed_contents(contents: &str, lints: &mut Vec<RenamedLint>) {\n         let mut iter = tokenize(line).map(|t| {\n             let range = offset..offset + t.len;\n             offset = range.end;\n-            (t.kind, &line[range])\n+\n+            LintDeclSearchResult {\n+                token_kind: t.kind,\n+                content: &line[range.clone()],\n+                range,\n+            }\n         });\n+\n         let (old_name, new_name) = match_tokens!(\n             iter,\n             // (\"old_name\",\n@@ -844,10 +1101,25 @@ mod tests {\n         \"#;\n         let mut result = Vec::new();\n         parse_contents(CONTENTS, \"module_name\", &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![\n-            Lint::new(\"ptr_arg\", \"style\", \"\\\"really long text\\\"\", \"module_name\"),\n-            Lint::new(\"doc_markdown\", \"pedantic\", \"\\\"single line\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"ptr_arg\",\n+                \"style\",\n+                \"\\\"really long text\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"doc_markdown\",\n+                \"pedantic\",\n+                \"\\\"single line\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         assert_eq!(expected, result);\n     }\n@@ -865,57 +1137,96 @@ mod tests {\n \n         let mut result = Vec::new();\n         parse_deprecated_contents(DEPRECATED_CONTENTS, &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![DeprecatedLint::new(\n             \"should_assert_eq\",\n             \"\\\"`assert!()` will be more flexible with RFC 2011\\\"\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n     fn test_usable_lints() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"Not Deprecated\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal_style\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         let expected = vec![Lint::new(\n             \"should_assert_eq2\",\n             \"Not Deprecated\",\n             \"\\\"abc\\\"\",\n             \"module_name\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n             ],\n         );\n         expected.insert(\n             \"group2\".to_string(),\n-            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\")],\n+            vec![Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n     }\n \n     #[test]\n     fn test_gen_deprecated() {\n         let lints = vec![\n-            DeprecatedLint::new(\"should_assert_eq\", \"\\\"has been superseded by should_assert_eq2\\\"\"),\n-            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\"),\n+            DeprecatedLint::new(\n+                \"should_assert_eq\",\n+                \"\\\"has been superseded by should_assert_eq2\\\"\",\n+                Range::default(),\n+            ),\n+            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\", Range::default()),\n         ];\n \n         let expected = GENERATED_FILE_COMMENT.to_string()\n@@ -940,9 +1251,9 @@ mod tests {\n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "d7a4b6f5c883f9bbfd18b38cbc50e11218a9cd86", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -1,16 +1,22 @@\n-// NOTE: if you add a deprecated lint in this file, please add a corresponding test in\n-// tests/ui/deprecated.rs\n+// NOTE: Entries should be created with `cargo dev deprecate`\n \n /// This struct fakes the `Lint` declaration that is usually created by `declare_lint!`. This\n /// enables the simple extraction of the metadata without changing the current deprecation\n /// declaration.\n-pub struct ClippyDeprecatedLint;\n+pub struct ClippyDeprecatedLint {\n+    #[cfg(feature = \"internal\")]\n+    #[allow(dead_code)]\n+    desc: &'static str,\n+}\n \n macro_rules! declare_deprecated_lint {\n-    { $(#[$attr:meta])* pub $name: ident, $_reason: expr} => {\n+    { $(#[$attr:meta])* pub $name: ident, $reason: literal} => {\n         $(#[$attr])*\n         #[allow(dead_code)]\n-        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {};\n+        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {\n+            #[cfg(feature = \"internal\")]\n+            desc: $reason\n+        };\n     }\n }\n "}, {"sha": "be63646a12f51dca756146bb026884dea50b4cc8", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -6,6 +6,7 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n     LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n     LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n     LintId::of(utils::internal_lints::DEFAULT_LINT),\n     LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n     LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),"}, {"sha": "faa63b3036c562c382291b244a094b5f7806256d", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -10,6 +10,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::IF_CHAIN_STYLE,"}, {"sha": "c53806625664282cdf9721042ee477170687dece", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -1,3 +1,4 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n@@ -338,6 +339,47 @@ declare_clippy_lint! {\n     \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -375,42 +417,67 @@ pub struct LintWithoutLintPass {\n     registered_lints: FxHashSet<Symbol>,\n }\n \n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE]);\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id()) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n             return;\n         }\n \n         if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            if is_lint_ref_type(cx, ty) {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n                 check_invalid_clippy_version_attribute(cx, item);\n \n                 let expr = &cx.tcx.hir().body(body_id).value;\n-                if_chain! {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n-                    if let ExprKind::Struct(_, fields, _) = inner_exp.kind;\n-                    let field = fields\n-                        .iter()\n-                        .find(|f| f.ident.as_str() == \"desc\")\n-                        .expect(\"lints must have a description field\");\n-                    if let ExprKind::Lit(Spanned {\n-                        node: LitKind::Str(ref sym, _),\n-                        ..\n-                    }) = field.expr.kind;\n-                    if sym.as_str() == \"default lint description\";\n-\n-                    then {\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n                         span_lint(\n                             cx,\n-                            DEFAULT_LINT,\n+                            DEFAULT_DEPRECATION_REASON,\n                             item.span,\n-                            &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n                         );\n                     }\n                 }\n-                self.declared_lints.insert(item.ident.name, item.span);\n             }\n         } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n             if !matches!("}, {"sha": "025ad87f72ddb7fc242c126b1025e41075d80c58", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=2bd1581bbf8e6e1ac3ad78638ac9c1ab0baa9a8f", "patch": "@@ -842,7 +842,7 @@ fn get_lint_level_from_group(lint_group: &str) -> Option<&'static str> {\n         .find_map(|(group_name, group_level)| (*group_name == lint_group).then(|| *group_level))\n }\n \n-fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+pub(super) fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     if let hir::TyKind::Path(ref path) = ty.kind {\n         if let hir::def::Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, ty.hir_id) {\n             return match_def_path(cx, def_id, &DEPRECATED_LINT_TYPE);"}]}