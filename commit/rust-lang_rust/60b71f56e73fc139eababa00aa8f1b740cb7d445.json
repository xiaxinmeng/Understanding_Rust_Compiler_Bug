{"sha": "60b71f56e73fc139eababa00aa8f1b740cb7d445", "node_id": "C_kwDOAAsO6NoAKDYwYjcxZjU2ZTczZmMxMzllYWJhYmEwMGFhOGYxYjc0MGNiN2Q0NDU", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-09T22:05:44Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T23:58:21Z"}, "message": "Remove support for JSON deserialization to Rust\n\nThis is no longer used by the compiler itself, and removing this support opens\nthe door to massively simplifying the Decodable/Decoder API by dropping the\nself-describing deserialization support (necessary for JSON).", "tree": {"sha": "497c5e5168d7d22c777471fbc199da6cc5c575ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/497c5e5168d7d22c777471fbc199da6cc5c575ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60b71f56e73fc139eababa00aa8f1b740cb7d445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60b71f56e73fc139eababa00aa8f1b740cb7d445", "html_url": "https://github.com/rust-lang/rust/commit/60b71f56e73fc139eababa00aa8f1b740cb7d445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60b71f56e73fc139eababa00aa8f1b740cb7d445/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45e2c2881d11324d610815bfff097e25c412199e", "url": "https://api.github.com/repos/rust-lang/rust/commits/45e2c2881d11324d610815bfff097e25c412199e", "html_url": "https://github.com/rust-lang/rust/commit/45e2c2881d11324d610815bfff097e25c412199e"}], "stats": {"total": 764, "additions": 46, "deletions": 718}, "files": [{"sha": "ed01afe6e303d90ba94489bd092d20dd3e4633f0", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -5,17 +5,12 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{ColorConfig, HumanReadableErrorType};\n use crate::Handler;\n-use rustc_serialize::json::decode;\n+use rustc_serialize::json;\n use rustc_span::{BytePos, Span};\n \n use std::str;\n \n-#[derive(Decodable, Debug, PartialEq, Eq)]\n-struct TestData {\n-    spans: Vec<SpanTestData>,\n-}\n-\n-#[derive(Decodable, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n struct SpanTestData {\n     pub byte_start: u32,\n     pub byte_end: u32,\n@@ -41,8 +36,6 @@ impl<T: Write> Write for Shared<T> {\n \n /// Test the span yields correct positions in JSON.\n fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n-    let expected_output = TestData { spans: vec![expected_output] };\n-\n     rustc_span::create_default_session_globals_then(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n@@ -64,9 +57,19 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n \n         let bytes = output.lock().unwrap();\n         let actual_output = str::from_utf8(&bytes).unwrap();\n-        let actual_output: TestData = decode(actual_output);\n-\n-        assert_eq!(expected_output, actual_output)\n+        let actual_output = json::from_str(&actual_output).unwrap();\n+        let spans = actual_output[\"spans\"].as_array().unwrap();\n+        assert_eq!(spans.len(), 1);\n+        let obj = &spans[0];\n+        let actual_output = SpanTestData {\n+            byte_start: obj[\"byte_start\"].as_u64().unwrap() as u32,\n+            byte_end: obj[\"byte_end\"].as_u64().unwrap() as u32,\n+            line_start: obj[\"line_start\"].as_u64().unwrap() as u32,\n+            line_end: obj[\"line_end\"].as_u64().unwrap() as u32,\n+            column_start: obj[\"column_start\"].as_u64().unwrap() as u32,\n+            column_end: obj[\"column_end\"].as_u64().unwrap() as u32,\n+        };\n+        assert_eq!(expected_output, actual_output);\n     })\n }\n "}, {"sha": "0cbea3a07a8d450864ab5af35118f1a89348f97e", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 7, "deletions": 314, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -45,12 +45,9 @@\n //!\n //! # Rust Type-based Encoding and Decoding\n //!\n-//! Rust provides a mechanism for low boilerplate encoding & decoding of values to and from JSON via\n-//! the serialization API.\n-//! To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n-//! To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n-//! The Rust compiler provides an annotation to automatically generate the code for these traits:\n-//! `#[derive(Decodable, Encodable)]`\n+//! To be able to encode a piece of data, it must implement the\n+//! `serialize::Encodable` trait.  The `rustc_macros` crate provides an\n+//! annotation to automatically generate the code for this trait: `#[derive(Encodable)]`.\n //!\n //! The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n //! The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n@@ -68,11 +65,11 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n-//! use rustc_macros::{Decodable, Encodable};\n+//! use rustc_macros::{Encodable};\n //! use rustc_serialize::json;\n //!\n-//! // Automatically generate `Decodable` and `Encodable` trait implementations\n-//! #[derive(Decodable, Encodable)]\n+//! // Automatically generate `Encodable` trait implementations\n+//! #[derive(Encodable)]\n //! pub struct TestStruct  {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -87,9 +84,6 @@\n //!\n //! // Serialize using `json::encode`\n //! let encoded = json::encode(&object).unwrap();\n-//!\n-//! // Deserialize using `json::decode`\n-//! let decoded: TestStruct = json::decode(&encoded[..]);\n //! ```\n //!\n //! ## Using the `ToJson` trait\n@@ -139,12 +133,9 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n-//! use rustc_macros::Decodable;\n //! use std::collections::BTreeMap;\n-//! use rustc_serialize::json::{self, Json, ToJson};\n+//! use rustc_serialize::json::{Json, ToJson};\n //!\n-//! // Only generate `Decodable` trait implementation\n-//! #[derive(Decodable)]\n //! pub struct TestStruct {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -171,19 +162,14 @@\n //! };\n //! let json_obj: Json = input_data.to_json();\n //! let json_str: String = json_obj.to_string();\n-//!\n-//! // Deserialize like before\n-//! let decoded: TestStruct = json::decode(&json_str);\n //! ```\n \n-use self::DecoderError::*;\n use self::ErrorCode::*;\n use self::InternalStackElement::*;\n use self::JsonEvent::*;\n use self::ParserError::*;\n use self::ParserState::*;\n \n-use std::borrow::Cow;\n use std::collections::{BTreeMap, HashMap};\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n@@ -253,21 +239,6 @@ pub enum ParserError {\n // Builder and Parser have the same errors.\n pub type BuilderError = ParserError;\n \n-#[derive(Clone, PartialEq, Debug)]\n-pub enum DecoderError {\n-    ParseError(ParserError),\n-    ExpectedError(string::String, string::String),\n-    MissingFieldError(string::String),\n-    UnknownVariantError(string::String),\n-    ApplicationError(string::String),\n-}\n-\n-macro_rules! bad {\n-    ($e:expr) => {{\n-        panic!(\"json decode error: {:?}\", $e);\n-    }};\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum EncoderError {\n     FmtError(fmt::Error),\n@@ -297,17 +268,6 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n     }\n }\n \n-/// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> T {\n-    let json = match from_str(s) {\n-        Ok(x) => x,\n-        Err(e) => bad!(ParseError(e)),\n-    };\n-\n-    let mut decoder = Decoder::new(json);\n-    crate::Decodable::decode(&mut decoder)\n-}\n-\n /// Shortcut function to encode a `T` into a JSON `String`\n pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n     object: &T,\n@@ -352,7 +312,6 @@ impl From<fmt::Error> for EncoderError {\n }\n \n pub type EncodeResult = Result<(), EncoderError>;\n-pub type DecodeResult<T> = Result<T, DecoderError>;\n \n fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> EncodeResult {\n     wr.write_str(\"\\\"\")?;\n@@ -2162,272 +2121,6 @@ pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n     builder.build()\n }\n \n-/// A structure to decode JSON to values in rust.\n-pub struct Decoder {\n-    stack: Vec<Json>,\n-}\n-\n-impl Decoder {\n-    /// Creates a new decoder instance for decoding the specified JSON value.\n-    pub fn new(json: Json) -> Decoder {\n-        Decoder { stack: vec![json] }\n-    }\n-\n-    fn pop(&mut self) -> Json {\n-        self.stack.pop().unwrap()\n-    }\n-}\n-\n-macro_rules! expect {\n-    ($e:expr, Null) => {{\n-        match $e {\n-            Json::Null => (),\n-            other => bad!(ExpectedError(\"Null\".to_owned(), other.to_string())),\n-        }\n-    }};\n-    ($e:expr, $t:ident) => {{\n-        match $e {\n-            Json::$t(v) => v,\n-            other => bad!(ExpectedError(stringify!($t).to_owned(), other.to_string())),\n-        }\n-    }};\n-}\n-\n-macro_rules! read_primitive {\n-    ($name:ident, $ty:ty) => {\n-        fn $name(&mut self) -> $ty {\n-            match self.pop() {\n-                Json::I64(f) => f as $ty,\n-                Json::U64(f) => f as $ty,\n-                Json::F64(f) => bad!(ExpectedError(\"Integer\".to_owned(), f.to_string())),\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n-                // is going to have a string here, as per JSON spec.\n-                Json::String(s) => match s.parse().ok() {\n-                    Some(f) => f,\n-                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n-                },\n-                value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n-            }\n-        }\n-    };\n-}\n-\n-impl crate::Decoder for Decoder {\n-    fn read_unit(&mut self) -> () {\n-        expect!(self.pop(), Null)\n-    }\n-\n-    read_primitive! { read_usize, usize }\n-    read_primitive! { read_u8, u8 }\n-    read_primitive! { read_u16, u16 }\n-    read_primitive! { read_u32, u32 }\n-    read_primitive! { read_u64, u64 }\n-    read_primitive! { read_u128, u128 }\n-    read_primitive! { read_isize, isize }\n-    read_primitive! { read_i8, i8 }\n-    read_primitive! { read_i16, i16 }\n-    read_primitive! { read_i32, i32 }\n-    read_primitive! { read_i64, i64 }\n-    read_primitive! { read_i128, i128 }\n-\n-    fn read_f32(&mut self) -> f32 {\n-        self.read_f64() as f32\n-    }\n-\n-    fn read_f64(&mut self) -> f64 {\n-        match self.pop() {\n-            Json::I64(f) => f as f64,\n-            Json::U64(f) => f as f64,\n-            Json::F64(f) => f,\n-            Json::String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n-                // is going to have a string here, as per JSON spec.\n-                match s.parse().ok() {\n-                    Some(f) => f,\n-                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n-                }\n-            }\n-            Json::Null => f64::NAN,\n-            value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n-        }\n-    }\n-\n-    fn read_bool(&mut self) -> bool {\n-        expect!(self.pop(), Boolean)\n-    }\n-\n-    fn read_char(&mut self) -> char {\n-        let s = self.read_str();\n-        let mut it = s.chars();\n-        if let (Some(c), None) = (it.next(), it.next()) {\n-            // exactly one character\n-            return c;\n-        }\n-        bad!(ExpectedError(\"single character string\".to_owned(), s.to_string()));\n-    }\n-\n-    fn read_str(&mut self) -> Cow<'_, str> {\n-        Cow::Owned(expect!(self.pop(), String))\n-    }\n-\n-    fn read_raw_bytes_into(&mut self, s: &mut [u8]) {\n-        for c in s.iter_mut() {\n-            *c = self.read_u8();\n-        }\n-    }\n-\n-    fn read_enum<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], mut f: F) -> T\n-    where\n-        F: FnMut(&mut Decoder, usize) -> T,\n-    {\n-        let name = match self.pop() {\n-            Json::String(s) => s,\n-            Json::Object(mut o) => {\n-                let n = match o.remove(\"variant\") {\n-                    Some(Json::String(s)) => s,\n-                    Some(val) => bad!(ExpectedError(\"String\".to_owned(), val.to_string())),\n-                    None => bad!(MissingFieldError(\"variant\".to_owned())),\n-                };\n-                match o.remove(\"fields\") {\n-                    Some(Json::Array(l)) => {\n-                        self.stack.extend(l.into_iter().rev());\n-                    }\n-                    Some(val) => bad!(ExpectedError(\"Array\".to_owned(), val.to_string())),\n-                    None => bad!(MissingFieldError(\"fields\".to_owned())),\n-                }\n-                n\n-            }\n-            json => bad!(ExpectedError(\"String or Object\".to_owned(), json.to_string())),\n-        };\n-        let Some(idx) = names.iter().position(|n| *n == &name[..]) else {\n-            bad!(UnknownVariantError(name));\n-        };\n-        f(self, idx)\n-    }\n-\n-    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        let value = f(self);\n-        self.pop();\n-        value\n-    }\n-\n-    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        let mut obj = expect!(self.pop(), Object);\n-\n-        let value = match obj.remove(name) {\n-            None => {\n-                // Add a Null and try to parse it as an Option<_>\n-                // to get None as a default value.\n-                self.stack.push(Json::Null);\n-                f(self)\n-            }\n-            Some(json) => {\n-                self.stack.push(json);\n-                f(self)\n-            }\n-        };\n-        self.stack.push(Json::Object(obj));\n-        value\n-    }\n-\n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        self.read_seq(move |d, len| {\n-            if len == tuple_len {\n-                f(d)\n-            } else {\n-                bad!(ExpectedError(format!(\"Tuple{}\", tuple_len), format!(\"Tuple{}\", len)));\n-            }\n-        })\n-    }\n-\n-    fn read_tuple_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        self.read_seq_elt(f)\n-    }\n-\n-    fn read_option<T, F>(&mut self, mut f: F) -> T\n-    where\n-        F: FnMut(&mut Decoder, bool) -> T,\n-    {\n-        match self.pop() {\n-            Json::Null => f(self, false),\n-            value => {\n-                self.stack.push(value);\n-                f(self, true)\n-            }\n-        }\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder, usize) -> T,\n-    {\n-        let array = expect!(self.pop(), Array);\n-        let len = array.len();\n-        self.stack.extend(array.into_iter().rev());\n-        f(self, len)\n-    }\n-\n-    fn read_seq_elt<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder, usize) -> T,\n-    {\n-        let obj = expect!(self.pop(), Object);\n-        let len = obj.len();\n-        for (key, value) in obj {\n-            self.stack.push(value);\n-            self.stack.push(Json::String(key));\n-        }\n-        f(self, len)\n-    }\n-\n-    fn read_map_elt_key<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map_elt_val<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-}\n-\n /// A trait for converting values to JSON\n pub trait ToJson {\n     /// Converts the value of `self` to an instance of JSON"}, {"sha": "944fe460632199db4a9cd1108a08a5a89e2e9118", "filename": "compiler/rustc_serialize/tests/json.rs", "status": "modified", "additions": 8, "deletions": 303, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fjson.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -4,61 +4,35 @@ use json::ErrorCode::*;\n use json::Json::*;\n use json::JsonEvent::*;\n use json::ParserError::*;\n-use json::{from_str, Decoder, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n-use rustc_macros::{Decodable, Encodable};\n+use json::{from_str, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n+use rustc_macros::Encodable;\n use rustc_serialize::json;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::Encodable;\n \n use std::collections::BTreeMap;\n use std::io::prelude::*;\n use std::string;\n use Animal::*;\n \n-#[derive(Decodable, Eq, PartialEq, Debug)]\n+#[derive(Eq, PartialEq, Debug)]\n struct OptionData {\n     opt: Option<usize>,\n }\n \n-#[test]\n-fn test_decode_option_none() {\n-    let s = \"{}\";\n-    let obj: OptionData = json::decode(s);\n-    assert_eq!(obj, OptionData { opt: None });\n-}\n-\n-#[test]\n-fn test_decode_option_some() {\n-    let s = \"{ \\\"opt\\\": 10 }\";\n-    let obj: OptionData = json::decode(s);\n-    assert_eq!(obj, OptionData { opt: Some(10) });\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"[]\")\"#)]\n-fn test_decode_option_malformed1() {\n-    check_err::<OptionData>(r#\"{ \"opt\": [] }\"#);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"false\")\"#)]\n-fn test_decode_option_malformed2() {\n-    check_err::<OptionData>(r#\"{ \"opt\": false }\"#);\n-}\n-\n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n enum Animal {\n     Dog,\n     Frog(string::String, isize),\n }\n \n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n struct Inner {\n     a: (),\n     b: usize,\n     c: Vec<string::String>,\n }\n \n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n struct Outer {\n     inner: Vec<Inner>,\n }\n@@ -323,18 +297,6 @@ fn test_read_identifiers() {\n     assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n }\n \n-#[test]\n-fn test_decode_identifiers() {\n-    let v: () = json::decode(\"null\");\n-    assert_eq!(v, ());\n-\n-    let v: bool = json::decode(\"true\");\n-    assert_eq!(v, true);\n-\n-    let v: bool = json::decode(\"false\");\n-    assert_eq!(v, false);\n-}\n-\n #[test]\n fn test_read_number() {\n     assert_eq!(from_str(\"+\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n@@ -363,45 +325,6 @@ fn test_read_number() {\n     assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n }\n \n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Integer\", \"765.25\")\"#)]\n-fn test_decode_numbers() {\n-    let v: f64 = json::decode(\"3\");\n-    assert_eq!(v, 3.0);\n-\n-    let v: f64 = json::decode(\"3.1\");\n-    assert_eq!(v, 3.1);\n-\n-    let v: f64 = json::decode(\"-1.2\");\n-    assert_eq!(v, -1.2);\n-\n-    let v: f64 = json::decode(\"0.4\");\n-    assert_eq!(v, 0.4);\n-\n-    let v: f64 = json::decode(\"0.4e5\");\n-    assert_eq!(v, 0.4e5);\n-\n-    let v: f64 = json::decode(\"0.4e15\");\n-    assert_eq!(v, 0.4e15);\n-\n-    let v: f64 = json::decode(\"0.4e-01\");\n-    assert_eq!(v, 0.4e-01);\n-\n-    let v: u64 = json::decode(\"0\");\n-    assert_eq!(v, 0);\n-\n-    let v: u64 = json::decode(\"18446744073709551615\");\n-    assert_eq!(v, u64::MAX);\n-\n-    let v: i64 = json::decode(\"-9223372036854775808\");\n-    assert_eq!(v, i64::MIN);\n-\n-    let v: i64 = json::decode(\"9223372036854775807\");\n-    assert_eq!(v, i64::MAX);\n-\n-    json::decode::<i64>(\"765.25\");\n-}\n-\n #[test]\n fn test_read_str() {\n     assert_eq!(from_str(\"\\\"\"), Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n@@ -419,26 +342,6 @@ fn test_read_str() {\n     assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n }\n \n-#[test]\n-fn test_decode_str() {\n-    let s = [\n-        (\"\\\"\\\"\", \"\"),\n-        (\"\\\"foo\\\"\", \"foo\"),\n-        (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n-        (\"\\\"\\\\b\\\"\", \"\\x08\"),\n-        (\"\\\"\\\\n\\\"\", \"\\n\"),\n-        (\"\\\"\\\\r\\\"\", \"\\r\"),\n-        (\"\\\"\\\\t\\\"\", \"\\t\"),\n-        (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n-        (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\"),\n-    ];\n-\n-    for (i, o) in s {\n-        let v: string::String = json::decode(i);\n-        assert_eq!(v, o);\n-    }\n-}\n-\n #[test]\n fn test_read_array() {\n     assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n@@ -457,45 +360,6 @@ fn test_read_array() {\n     assert_eq!(from_str(\"[2, [4, 1]]\"), Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n }\n \n-#[test]\n-fn test_decode_array() {\n-    let v: Vec<()> = json::decode(\"[]\");\n-    assert_eq!(v, []);\n-\n-    let v: Vec<()> = json::decode(\"[null]\");\n-    assert_eq!(v, [()]);\n-\n-    let v: Vec<bool> = json::decode(\"[true]\");\n-    assert_eq!(v, [true]);\n-\n-    let v: Vec<isize> = json::decode(\"[3, 1]\");\n-    assert_eq!(v, [3, 1]);\n-\n-    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\");\n-    assert_eq!(v, [vec![3], vec![1, 2]]);\n-}\n-\n-#[test]\n-fn test_decode_tuple() {\n-    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\");\n-    assert_eq!(t, (1, 2, 3));\n-\n-    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\");\n-    assert_eq!(t, (1, \"two\".to_string()));\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_decode_tuple_malformed_types() {\n-    json::decode::<(usize, string::String)>(\"[1, 2]\");\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_decode_tuple_malformed_length() {\n-    json::decode::<(usize, usize)>(\"[1, 2, 3]\");\n-}\n-\n #[test]\n fn test_read_object() {\n     assert_eq!(from_str(\"{\"), Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n@@ -552,143 +416,11 @@ fn test_read_object() {\n     );\n }\n \n-#[test]\n-fn test_decode_struct() {\n-    let s = \"{\n-        \\\"inner\\\": [\n-            { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n-        ]\n-    }\";\n-\n-    let v: Outer = json::decode(s);\n-    assert_eq!(\n-        v,\n-        Outer { inner: vec![Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }] }\n-    );\n-}\n-\n-#[derive(Decodable)]\n-struct FloatStruct {\n-    f: f64,\n-    a: Vec<f64>,\n-}\n-#[test]\n-fn test_decode_struct_with_nan() {\n-    let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-    let obj: FloatStruct = json::decode(s);\n-    assert!(obj.f.is_nan());\n-    assert!(obj.a[0].is_nan());\n-    assert_eq!(obj.a[1], 123f64);\n-}\n-\n-#[test]\n-fn test_decode_option() {\n-    let value: Option<string::String> = json::decode(\"null\");\n-    assert_eq!(value, None);\n-\n-    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\");\n-    assert_eq!(value, Some(\"jodhpurs\".to_string()));\n-}\n-\n-#[test]\n-fn test_decode_enum() {\n-    let value: Animal = json::decode(\"\\\"Dog\\\"\");\n-    assert_eq!(value, Dog);\n-\n-    let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-    let value: Animal = json::decode(s);\n-    assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n-}\n-\n-#[test]\n-fn test_decode_map() {\n-    let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-              \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-    let mut map: BTreeMap<string::String, Animal> = json::decode(s);\n-\n-    assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-    assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n-}\n-\n #[test]\n fn test_multiline_errors() {\n     assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n }\n \n-#[derive(Decodable)]\n-#[allow(dead_code)]\n-struct DecodeStruct {\n-    x: f64,\n-    y: bool,\n-    z: string::String,\n-    w: Vec<DecodeStruct>,\n-}\n-#[derive(Decodable)]\n-enum DecodeEnum {\n-    A(f64),\n-    B(string::String),\n-}\n-fn check_err<T: Decodable<Decoder>>(to_parse: &str) {\n-    let json = from_str(to_parse).unwrap();\n-    let _: T = Decodable::decode(&mut Decoder::new(json));\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Object\", \"[]\")\"#)]\n-fn test_decode_errors_struct1() {\n-    check_err::<DecodeStruct>(\"[]\");\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"true\")\"#)]\n-fn test_decode_errors_struct2() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": true, \"y\": true, \"z\": \"\", \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Boolean\", \"[]\")\"#)]\n-fn test_decode_errors_struct3() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": [], \"z\": \"\", \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"String\", \"{}\")\"#)]\n-fn test_decode_errors_struct4() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": {}, \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_struct5() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\", \"w\": null}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_struct6() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\"}\"#);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"MissingFieldError(\"variant\")\"#)]\n-fn test_decode_errors_enum1() {\n-    check_err::<DecodeEnum>(r#\"{}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"String\", \"1\")\"#)]\n-fn test_decode_errors_enum2() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": 1}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"MissingFieldError(\"fields\")\"#)]\n-fn test_decode_errors_enum3() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\"}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_enum4() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\", \"fields\": null}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"UnknownVariantError(\"C\")\"#)]\n-fn test_decode_errors_enum5() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"C\", \"fields\": []}\"#);\n-}\n-\n #[test]\n fn test_find() {\n     let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n@@ -938,7 +670,7 @@ fn test_prettyencoder_indent_level_param() {\n #[test]\n fn test_hashmap_with_enum_key() {\n     use std::collections::HashMap;\n-    #[derive(Encodable, Eq, Hash, PartialEq, Decodable, Debug)]\n+    #[derive(Encodable, Eq, Hash, PartialEq, Debug)]\n     enum Enum {\n         Foo,\n         #[allow(dead_code)]\n@@ -948,33 +680,6 @@ fn test_hashmap_with_enum_key() {\n     map.insert(Enum::Foo, 0);\n     let result = json::encode(&map).unwrap();\n     assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-    let decoded: HashMap<Enum, _> = json::decode(&result);\n-    assert_eq!(map, decoded);\n-}\n-\n-#[test]\n-fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n-    use std::collections::HashMap;\n-    let json_str = \"{\\\"1\\\":true}\";\n-    let json_obj = match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        Ok(o) => o,\n-    };\n-    let mut decoder = Decoder::new(json_obj);\n-    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"a\")\"#)]\n-fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n-    use std::collections::HashMap;\n-    let json_str = \"{\\\"a\\\":true}\";\n-    let json_obj = match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        Ok(o) => o,\n-    };\n-    let mut decoder = Decoder::new(json_obj);\n-    let _: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n }\n \n fn assert_stream_equal(src: &str, expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {"}, {"sha": "678ba18bf045d2879da89967bea531eebf943fa0", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -7,7 +7,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n \n #[derive(Encodable, Decodable)]\n@@ -17,7 +17,9 @@ struct A {\n \n fn main() {\n     let obj = A { foo: Box::new([true, false]) };\n-    let s = json::encode(&obj).unwrap();\n-    let obj2: A = json::decode(&s);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = A::decode(&mut decoder);\n     assert_eq!(obj.foo, obj2.foo);\n }"}, {"sha": "5cc5c41364a66a1e31f1e43db5a9274bcbfec841", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -9,7 +9,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n use std::cell::{Cell, RefCell};\n \n@@ -26,8 +26,10 @@ struct B {\n \n fn main() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n-    let s = json::encode(&obj).unwrap();\n-    let obj2: B = json::decode(&s);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = B::decode(&mut decoder);\n     assert_eq!(obj.foo.get(), obj2.foo.get());\n     assert_eq!(obj.bar.borrow().baz, obj2.bar.borrow().baz);\n }"}, {"sha": "f7e0043f52168ff689cc8704b95f8cfc44524e24", "filename": "src/test/ui-fulldeps/issue-14021.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b71f56e73fc139eababa00aa8f1b740cb7d445/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs?ref=60b71f56e73fc139eababa00aa8f1b740cb7d445", "patch": "@@ -8,19 +8,17 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n \n #[derive(Encodable, Decodable, PartialEq, Debug)]\n struct UnitLikeStruct;\n \n pub fn main() {\n     let obj = UnitLikeStruct;\n-    let json_str: String = json::encode(&obj).unwrap();\n-\n-    let json_object = json::from_str(&json_str);\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let mut decoded_obj: UnitLikeStruct = Decodable::decode(&mut decoder);\n-\n-    assert_eq!(obj, decoded_obj);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = UnitLikeStruct::decode(&mut decoder);\n+    assert_eq!(obj, obj2);\n }"}, {"sha": "044a0c5000e31a80308eb120cdf82861e9880742", "filename": "src/test/ui-fulldeps/issue-24972.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs?ref=45e2c2881d11324d610815bfff097e25c412199e", "patch": "@@ -1,39 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable, Encodable};\n-use std::fmt::Display;\n-\n-pub trait Entity: Decodable<json::Decoder> + for<'a> Encodable<json::Encoder<'a>> + Sized {\n-    type Key: Clone\n-        + Decodable<json::Decoder>\n-        + for<'a> Encodable<json::Encoder<'a>>\n-        + ToString\n-        + Display\n-        + Eq\n-        + Ord\n-        + Sized;\n-\n-    fn id(&self) -> Self::Key;\n-\n-    fn find_by_id(id: Self::Key) -> Option<Self>;\n-}\n-\n-pub struct DbRef<E: Entity> {\n-    pub id: E::Key,\n-}\n-\n-impl<E> DbRef<E>\n-where\n-    E: Entity,\n-{\n-    fn get(self) -> Option<E> {\n-        E::find_by_id(self.id)\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "65dab8d7704766f70c9e6ee9e981d65cabbc35df", "filename": "src/test/ui-fulldeps/issue-4016.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs?ref=45e2c2881d11324d610815bfff097e25c412199e", "patch": "@@ -1,19 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable};\n-\n-trait JD: Decodable<json::Decoder> {}\n-\n-fn exec<T: JD>() {\n-    let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder::new(doc);\n-    let _v: T = Decodable::decode(&mut decoder);\n-    panic!()\n-}\n-\n-pub fn main() {}"}, {"sha": "702bb2d6ef6cb3b5ae20bd438a9a6f0ca33151d4", "filename": "src/test/ui-fulldeps/issue-4036.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e2c2881d11324d610815bfff097e25c412199e/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs?ref=45e2c2881d11324d610815bfff097e25c412199e", "patch": "@@ -1,17 +0,0 @@\n-// run-pass\n-// Issue #4036: Test for an issue that arose around fixing up type inference\n-// byproducts in vtable records.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable};\n-\n-pub fn main() {\n-    let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder::new(json);\n-    let _x: Vec<isize> = Decodable::decode(&mut decoder);\n-}"}]}