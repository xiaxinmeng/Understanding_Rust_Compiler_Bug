{"sha": "212507413a2768ec4b6a072dde73d60527c2beee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMjUwNzQxM2EyNzY4ZWM0YjZhMDcyZGRlNzNkNjA1MjdjMmJlZWU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T15:53:54Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T15:59:04Z"}, "message": "rustc: update docs & propagate @[]/@str removal more.\n\nVarious functions can now be made specific to ~[], or just non-managed\nvectors.", "tree": {"sha": "29f84fa7272b8002cc1ae0dedc67fcaf6d730244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29f84fa7272b8002cc1ae0dedc67fcaf6d730244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212507413a2768ec4b6a072dde73d60527c2beee", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212507413a2768ec4b6a072dde73d60527c2beee", "html_url": "https://github.com/rust-lang/rust/commit/212507413a2768ec4b6a072dde73d60527c2beee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212507413a2768ec4b6a072dde73d60527c2beee/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8947c14c301acedfa2aad4c3daf3b8040c04804", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8947c14c301acedfa2aad4c3daf3b8040c04804", "html_url": "https://github.com/rust-lang/rust/commit/c8947c14c301acedfa2aad4c3daf3b8040c04804"}], "stats": {"total": 185, "additions": 57, "deletions": 128}, "files": [{"sha": "0b817539b2988755d91072216b928c4fb1462b53", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -3115,7 +3115,7 @@ Such a definite-sized vector type is a first-class type, since its size is known\n A vector without such a size is said to be of _indefinite_ size,\n and is therefore not a _first-class_ type.\n An indefinite-size vector can only be instantiated through a pointer type,\n-such as `&[T]`, `@[T]` or `~[T]`.\n+such as `&[T]` or `~[T]`.\n The kind of a vector type depends on the kind of its element type,\n as with other simple structural types.\n "}, {"sha": "8f6d4de476b13866f6490a0076a53d1bf57acff0", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -194,16 +194,6 @@ pub struct BorrowStats {\n //\n // Note that there is no entry with derefs:3---the type of that expression\n // is T, which is not a box.\n-//\n-// Note that implicit dereferences also occur with indexing of `@[]`,\n-// `@str`, etc.  The same rules apply. So, for example, given a\n-// variable `x` of type `@[@[...]]`, if I have an instance of the\n-// expression `x[0]` which is then auto-slice'd, there would be two\n-// potential entries in the root map, both with the id of the `x[0]`\n-// expression. The entry with `derefs==0` refers to the deref of `x`\n-// used as part of evaluating `x[0]`. The entry with `derefs==1`\n-// refers to the deref of the `x[0]` that occurs as part of the\n-// auto-slice.\n #[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::NodeId,"}, {"sha": "135b16b22abd238bdf5a0a8de76e1c3bb2c7a030", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -1032,7 +1032,6 @@ fn match_datum(bcx: &Block,\n \n fn extract_vec_elems<'a>(\n                      bcx: &'a Block<'a>,\n-                     pat_span: Span,\n                      pat_id: ast::NodeId,\n                      elem_count: uint,\n                      slice: Option<uint>,\n@@ -1041,7 +1040,7 @@ fn extract_vec_elems<'a>(\n                      -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n-    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n+    let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n     let mut elems = vec::from_fn(elem_count, |i| {\n@@ -1512,13 +1511,11 @@ fn compile_submatch_continue<'r,\n                                 vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    let mut pat_span = DUMMY_SP;\n     for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n             pat_id = br.pats[col].id;\n-            pat_span = br.pats[col].span;\n         }\n     }\n \n@@ -1767,7 +1764,7 @@ fn compile_submatch_continue<'r,\n                     vec_len_ge(i) => (n + 1u, Some(i)),\n                     vec_len_eq => (n, None)\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n,\n+                let args = extract_vec_elems(opt_cx, pat_id, n,\n                                              slice, val, test_val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();"}, {"sha": "7bd2653f86990d871f433a3a213a23880b48207a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -360,7 +360,7 @@ pub fn malloc_raw_dyn<'a>(\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty_value.ptr_to()))\n     } else {\n-        // we treat ~fn, @fn and @[] as @ here, which isn't ideal\n+        // we treat ~fn as @ here, which isn't ideal\n         let langcall = match heap {\n             heap_managed => {\n                 require_alloc_fn(bcx, t, MallocFnLangItem)"}, {"sha": "d361c36fbdacd3a8142af145318fdae2b17fe6f2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -334,7 +334,7 @@ pub fn trans_fail_expr<'a>(\n                 unpack_datum!(bcx, expr::trans_to_lvalue(bcx, arg_expr, \"fail\"));\n \n             if ty::type_is_str(arg_datum.ty) {\n-                let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n+                let (lldata, _) = arg_datum.get_vec_base_and_len(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n             } else if bcx.unreachable.get() || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;"}, {"sha": "2a2421077a8c6d66c8b26576f19ff6bef122f15c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -528,49 +528,8 @@ impl Datum<Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_byte_len<'a>(\n-                                     &self,\n-                                     mut bcx: &'a Block<'a>,\n-                                     span: Span,\n-                                     expr_id: ast::NodeId,\n-                                     derefs: uint)\n-                                     -> (&'a Block<'a>, ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Performs rooting\n-        //! and write guards checks.\n-\n-        // only imp't for @[] and @str, but harmless\n-        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n-        let (base, len) = self.get_vec_base_and_byte_len_no_root(bcx);\n-        (bcx, base, len)\n-    }\n-\n-    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: &Block)\n-                                             -> (ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Des not root\n-        //! nor perform write guard checks.\n-\n-        tvec::get_base_and_byte_len(bcx, self.val, self.ty)\n-    }\n-\n-    pub fn get_vec_base_and_len<'a>(&self,\n-                                    mut bcx: &'a Block<'a>,\n-                                    span: Span,\n-                                    expr_id: ast::NodeId,\n-                                    derefs: uint)\n-                                    -> (&'a Block<'a>, ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Performs rooting\n-        //! and write guards checks.\n-\n-        // only imp't for @[] and @str, but harmless\n-        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n-        let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n-        (bcx, base, len)\n-    }\n-\n-    pub fn get_vec_base_and_len_no_root<'a>(&self, bcx: &'a Block<'a>)\n-                                            -> (ValueRef, ValueRef) {\n-        //! Converts a vector into the slice pair. Des not root\n-        //! nor perform write guard checks.\n+    pub fn get_vec_base_and_len<'a>(&self, bcx: &'a Block<'a>) -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)\n     }"}, {"sha": "517f9e1a31d81c7ff643ed25b6b7419859edfc88", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -202,12 +202,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                     unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n                 }\n                 Some(AutoBorrowVec(..)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, adj.autoderefs,\n-                                                  expr, datum))\n+                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowVecRef(..)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, adj.autoderefs,\n-                                                          expr, datum))\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n                 }\n                 Some(AutoBorrowFn(..)) => {\n                     let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n@@ -271,7 +269,6 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n     fn auto_slice<'a>(\n                   bcx: &'a Block<'a>,\n-                  autoderefs: uint,\n                   expr: &ast::Expr,\n                   datum: Datum<Expr>)\n                   -> DatumBlock<'a, Expr> {\n@@ -290,8 +287,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let datum = unpack_datum!(\n             bcx, datum.to_lvalue_datum(bcx, \"auto_slice\", expr.id));\n \n-        let (bcx, base, len) =\n-            datum.get_vec_base_and_len(bcx, expr.span, expr.id, autoderefs+1);\n+        let (base, len) = datum.get_vec_base_and_len(bcx);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -323,11 +319,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n     fn auto_slice_and_ref<'a>(\n                           bcx: &'a Block<'a>,\n-                          autoderefs: uint,\n                           expr: &ast::Expr,\n                           datum: Datum<Expr>)\n                           -> DatumBlock<'a, Expr> {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n         auto_ref(bcx, datum, expr)\n     }\n \n@@ -522,8 +517,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprVstore(contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n             let datum = unpack_datum!(\n-                bcx, tvec::trans_uniq_or_managed_vstore(bcx, heap_exchange,\n-                                                        expr, contents));\n+                bcx, tvec::trans_uniq_vstore(bcx, expr, contents));\n             bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n             DatumBlock(bcx, datum)\n         }\n@@ -626,8 +620,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     let vt = tvec::vec_types(bcx, base_datum.ty);\n     base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n \n-    let (bcx, base, len) =\n-        base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n+    let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n     debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n     debug!(\"trans_index: len {}\", bcx.val_to_str(len));"}, {"sha": "a0a1ff20a9a9c5d9e75b4983971b173f8444c584", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -110,11 +110,10 @@ pub fn alloc_uniq_raw<'a>(\n     alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n }\n \n-pub fn alloc_vec<'a>(\n+pub fn alloc_uniq_vec<'a>(\n                  bcx: &'a Block<'a>,\n                  unit_ty: ty::t,\n-                 elts: uint,\n-                 heap: heap)\n+                 elts: uint)\n                  -> Result<'a> {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n@@ -125,7 +124,7 @@ pub fn alloc_vec<'a>(\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n     let Result {bcx: bcx, val: vptr} =\n-        alloc_raw(bcx, unit_ty, fill, alloc, heap);\n+        alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange);\n     return rslt(bcx, vptr);\n }\n \n@@ -302,70 +301,62 @@ pub fn trans_lit_str<'a>(\n }\n \n \n-pub fn trans_uniq_or_managed_vstore<'a>(bcx: &'a Block<'a>,\n-                                        heap: heap,\n-                                        vstore_expr: &ast::Expr,\n-                                        content_expr: &ast::Expr)\n-                                        -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n+                             vstore_expr: &ast::Expr,\n+                             content_expr: &ast::Expr)\n+                             -> DatumBlock<'a, Expr> {\n     /*!\n-     * @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n-     * appropriate heap and write the array elements into them.\n+     * ~[...] and ~\"...\" allocate boxes in the exchange heap and write\n+     * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n-           bcx.expr_to_str(vstore_expr), heap);\n+    debug!(\"trans_uniq_vstore(vstore_expr={})\", bcx.expr_to_str(vstore_expr));\n     let fcx = bcx.fcx;\n \n     // Handle ~\"\".\n-    match heap {\n-        heap_exchange => {\n-            match content_expr.node {\n-                ast::ExprLit(lit) => {\n-                    match lit.node {\n-                        ast::LitStr(ref s, _) => {\n-                            let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n-                            let llptrval = PointerCast(bcx,\n-                                                       llptrval,\n-                                                       Type::i8p());\n-                            let llsizeval = C_uint(bcx.ccx(), s.get().len());\n-                            let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n-                            let lldestval = rvalue_scratch_datum(bcx,\n-                                                                 typ,\n-                                                                 \"\");\n-                            let alloc_fn = langcall(bcx,\n-                                                    Some(lit.span),\n-                                                    \"\",\n-                                                    StrDupUniqFnLangItem);\n-                            let bcx = callee::trans_lang_call(\n-                                bcx,\n-                                alloc_fn,\n-                                [ llptrval, llsizeval ],\n-                                Some(expr::SaveIn(lldestval.val))).bcx;\n-                            return DatumBlock(bcx, lldestval).to_expr_datumblock();\n-                        }\n-                        _ => {}\n-                    }\n+    match content_expr.node {\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(ref s, _) => {\n+                    let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n+                    let llptrval = PointerCast(bcx,\n+                                               llptrval,\n+                                               Type::i8p());\n+                    let llsizeval = C_uint(bcx.ccx(), s.get().len());\n+                    let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n+                    let lldestval = rvalue_scratch_datum(bcx,\n+                                                         typ,\n+                                                         \"\");\n+                    let alloc_fn = langcall(bcx,\n+                                            Some(lit.span),\n+                                            \"\",\n+                                            StrDupUniqFnLangItem);\n+                    let bcx = callee::trans_lang_call(\n+                        bcx,\n+                        alloc_fn,\n+                        [ llptrval, llsizeval ],\n+                        Some(expr::SaveIn(lldestval.val))).bcx;\n+                    return DatumBlock(bcx, lldestval).to_expr_datumblock();\n                 }\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n-        heap_managed => {}\n+        _ => {}\n     }\n \n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n \n-    let Result {bcx, val} = alloc_vec(bcx, vt.unit_ty, count, heap);\n+    let Result {bcx, val} = alloc_uniq_vec(bcx, vt.unit_ty, count);\n \n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap);\n+    fcx.schedule_free_value(cleanup::CustomScope(temp_scope), val, heap_exchange);\n \n     let dataptr = get_dataptr(bcx, val);\n \n-    debug!(\"alloc_vec() returned val={}, dataptr={}\",\n+    debug!(\"alloc_uniq_vec() returned val={}, dataptr={}\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,"}, {"sha": "0f4b11bde707b81b9240b0e1f59480c87dd6d7b2", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -46,10 +46,10 @@ fn root<'a, K:KindOps>(datum: &Datum<K>,\n                        _span: Span,\n                        root_key: root_map_key,\n                        root_info: RootInfo) -> &'a Block<'a> {\n-    //! In some cases, borrowck will decide that an @T/@[]/@str\n-    //! value must be rooted for the program to be safe.  In that\n-    //! case, we will call this function, which will stash a copy\n-    //! away until we exit the scope `scope_id`.\n+    //! In some cases, borrowck will decide that an @T value must be\n+    //! rooted for the program to be safe.  In that case, we will call\n+    //! this function, which will stash a copy away until we exit the\n+    //! scope `scope_id`.\n \n     debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n@@ -62,4 +62,3 @@ fn root<'a, K:KindOps>(datum: &Datum<K>,\n         cleanup::AstScope(root_info.scope), (),\n         |(), bcx, llval| datum.shallow_copy_and_take(bcx, llval)).bcx\n }\n-"}, {"sha": "003a10eb48258967753a84b73c66fd3b19851db9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -226,10 +226,10 @@ pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::Mutability),\n \n-    /// Convert from @[]/~[]/&[] to &[] (or str)\n+    /// Convert from ~[]/&[] to &[] (or str)\n     AutoBorrowVec(Region, ast::Mutability),\n \n-    /// Convert from @[]/~[]/&[] to &&[] (or str)\n+    /// Convert from ~[]/&[] to &&[] (or str)\n     AutoBorrowVecRef(Region, ast::Mutability),\n \n     /// Convert from @fn()/~fn()/|| to ||"}, {"sha": "dd7cc3a2314359aa8006c6e94fa2fa763c449133", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212507413a2768ec4b6a072dde73d60527c2beee/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=212507413a2768ec4b6a072dde73d60527c2beee", "patch": "@@ -1291,7 +1291,7 @@ impl Parser {\n         }\n \n         // other things are parsed as @/~ + a type.  Note that constructs like\n-        // @[] and @str will be resolved during typeck to slices and so forth,\n+        // ~[] and ~str will be resolved during typeck to slices and so forth,\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         if sigil == OwnedSigil {"}]}