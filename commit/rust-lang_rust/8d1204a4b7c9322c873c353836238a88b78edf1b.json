{"sha": "8d1204a4b7c9322c873c353836238a88b78edf1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMTIwNGE0YjdjOTMyMmM4NzNjMzUzODM2MjM4YTg4Yjc4ZWRmMWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-05T12:55:13Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-08T02:53:21Z"}, "message": "std::fmt: convert the formatting traits to a proper self.\n\nPoly and String have polymorphic `impl`s and so require different method\nnames.", "tree": {"sha": "669a22f8cfc1133bf4f499324d1eee47a183db0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669a22f8cfc1133bf4f499324d1eee47a183db0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d1204a4b7c9322c873c353836238a88b78edf1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d1204a4b7c9322c873c353836238a88b78edf1b", "html_url": "https://github.com/rust-lang/rust/commit/8d1204a4b7c9322c873c353836238a88b78edf1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d1204a4b7c9322c873c353836238a88b78edf1b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "html_url": "https://github.com/rust-lang/rust/commit/1fd2d7786013f98c59f099a2a0413b61a6e82d9d"}], "stats": {"total": 356, "additions": 178, "deletions": 178}, "files": [{"sha": "153de66363bdb8fba32be01f47c76ce097faf846", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -20,10 +20,10 @@ use std::fmt;\n pub struct Escape<'a>(&'a str);\n \n impl<'a> fmt::Show for Escape<'a> {\n-    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n-        let Escape(s) = *s;\n+        let Escape(s) = *self;\n         let pile_o_bits = s.as_slice();\n         let mut last = 0;\n         for (i, ch) in s.bytes().enumerate() {"}, {"sha": "024d010f0b927c9195f1c172e64087be9a7d3b9b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -48,23 +48,23 @@ impl PuritySpace {\n }\n \n impl fmt::Show for clean::Generics {\n-    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) -> fmt::Result {\n-        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return Ok(()) }\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n         if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n \n-        for (i, life) in g.lifetimes.iter().enumerate() {\n+        for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n                 if_ok!(f.buf.write(\", \".as_bytes()));\n             }\n             if_ok!(write!(f.buf, \"{}\", *life));\n         }\n \n-        if g.type_params.len() > 0 {\n-            if g.lifetimes.len() > 0 {\n+        if self.type_params.len() > 0 {\n+            if self.lifetimes.len() > 0 {\n                 if_ok!(f.buf.write(\", \".as_bytes()));\n             }\n \n-            for (i, tp) in g.type_params.iter().enumerate() {\n+            for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n                     if_ok!(f.buf.write(\", \".as_bytes()))\n                 }\n@@ -87,16 +87,16 @@ impl fmt::Show for clean::Generics {\n }\n \n impl fmt::Show for clean::Lifetime {\n-    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if_ok!(f.buf.write(\"'\".as_bytes()));\n-        if_ok!(f.buf.write(l.get_ref().as_bytes()));\n+        if_ok!(f.buf.write(self.get_ref().as_bytes()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::TyParamBound {\n-    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *bound {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::RegionBound => {\n                 f.buf.write(\"'static\".as_bytes())\n             }\n@@ -108,11 +108,11 @@ impl fmt::Show for clean::TyParamBound {\n }\n \n impl fmt::Show for clean::Path {\n-    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) -> fmt::Result {\n-        if path.global {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.global {\n             if_ok!(f.buf.write(\"::\".as_bytes()))\n         }\n-        for (i, seg) in path.segments.iter().enumerate() {\n+        for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n                 if_ok!(f.buf.write(\"::\".as_bytes()))\n             }\n@@ -297,8 +297,8 @@ fn typarams(w: &mut io::Writer,\n }\n \n impl fmt::Show for clean::Type {\n-    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *g {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n                     let m = cache.unwrap().get();\n@@ -405,18 +405,18 @@ impl fmt::Show for clean::Type {\n }\n \n impl fmt::Show for clean::FnDecl {\n-    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n-               args = d.inputs,\n-               arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output)\n+               args = self.inputs,\n+               arrow = match self.output { clean::Unit => \"no\", _ => \"yes\" },\n+               ret = self.output)\n     }\n }\n \n impl fmt::Show for ~[clean::Argument] {\n-    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut args = ~\"\";\n-        for (i, input) in inputs.iter().enumerate() {\n+        for (i, input) in self.iter().enumerate() {\n             if i > 0 { args.push_str(\", \"); }\n             if input.name.len() > 0 {\n                 args.push_str(format!(\"{}: \", input.name));\n@@ -428,8 +428,8 @@ impl fmt::Show for ~[clean::Argument] {\n }\n \n impl<'a> fmt::Show for Method<'a> {\n-    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Method(selfty, d) = *m;\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let Method(selfty, d) = *self;\n         let mut args = ~\"\";\n         match *selfty {\n             clean::SelfStatic => {},\n@@ -463,8 +463,8 @@ impl<'a> fmt::Show for Method<'a> {\n }\n \n impl fmt::Show for VisSpace {\n-    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.get() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n             Some(ast::Public) => write!(f.buf, \"pub \"),\n             Some(ast::Private) => write!(f.buf, \"priv \"),\n             Some(ast::Inherited) | None => Ok(())\n@@ -473,8 +473,8 @@ impl fmt::Show for VisSpace {\n }\n \n impl fmt::Show for PuritySpace {\n-    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) -> fmt::Result {\n-        match p.get() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n             ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n             ast::ExternFn => write!(f.buf, \"extern \"),\n             ast::ImpureFn => Ok(())\n@@ -483,8 +483,8 @@ impl fmt::Show for PuritySpace {\n }\n \n impl fmt::Show for clean::ViewPath {\n-    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *v {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n                     write!(f.buf, \"use {};\", *src)\n@@ -510,14 +510,14 @@ impl fmt::Show for clean::ViewPath {\n }\n \n impl fmt::Show for clean::ImportSource {\n-    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.did {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.did {\n             // FIXME: shouldn't be restricted to just local imports\n             Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true)\n+                resolved_path(f.buf, did.node, &self.path, true)\n             }\n             _ => {\n-                for (i, seg) in v.path.segments.iter().enumerate() {\n+                for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n                         if_ok!(write!(f.buf, \"::\"))\n                     }\n@@ -530,21 +530,21 @@ impl fmt::Show for clean::ImportSource {\n }\n \n impl fmt::Show for clean::ViewListIdent {\n-    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) -> fmt::Result {\n-        match v.source {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.source {\n             // FIXME: shouldn't be limited to just local imports\n             Some(did) if ast_util::is_local(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n-                        name: v.name.clone(),\n+                        name: self.name.clone(),\n                         lifetimes: ~[],\n                         types: ~[],\n                     }]\n                 };\n                 resolved_path(f.buf, did.node, &path, false)\n             }\n-            _ => write!(f.buf, \"{}\", v.name),\n+            _ => write!(f.buf, \"{}\", self.name),\n         }\n     }\n }"}, {"sha": "63748203a1ab102ff1cece5376f4846a1ae4cada", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -211,8 +211,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n }\n \n impl<'a> fmt::Show for Markdown<'a> {\n-    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *md;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n         render(fmt.buf, md.as_slice())"}, {"sha": "5bd970834a64d59d0eada046a83847525334d5e1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -801,8 +801,8 @@ impl<'a> Item<'a> {\n }\n \n impl<'a> fmt::Show for Item<'a> {\n-    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match attr::find_stability(it.item.attrs.iter()) {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match attr::find_stability(self.item.attrs.iter()) {\n             Some(ref stability) => {\n                 if_ok!(write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n@@ -815,38 +815,38 @@ impl<'a> fmt::Show for Item<'a> {\n             None => {}\n         }\n \n-        if it.cx.include_sources {\n+        if self.cx.include_sources {\n             let mut path = ~[];\n-            clean_srcpath(it.item.source.filename.as_bytes(), |component| {\n+            clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_owned());\n             });\n-            let href = if it.item.source.loline == it.item.source.hiline {\n-                format!(\"{}\", it.item.source.loline)\n+            let href = if self.item.source.loline == self.item.source.hiline {\n+                format!(\"{}\", self.item.source.loline)\n             } else {\n-                format!(\"{}-{}\", it.item.source.loline, it.item.source.hiline)\n+                format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n             };\n             if_ok!(write!(fmt.buf,\n                           \"<a class='source'\n                               href='{root}src/{crate}/{path}.html\\\\#{href}'>\\\n                               [src]</a>\",\n-                          root = it.cx.root_path,\n-                          crate = it.cx.layout.crate,\n+                          root = self.cx.root_path,\n+                          crate = self.cx.layout.crate,\n                           path = path.connect(\"/\"),\n                           href = href));\n         }\n \n         // Write the breadcrumb trail header for the top\n         if_ok!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n-        match it.item.inner {\n+        match self.item.inner {\n             clean::ModuleItem(..) => if_ok!(write!(fmt.buf, \"Module \")),\n             clean::FunctionItem(..) => if_ok!(write!(fmt.buf, \"Function \")),\n             clean::TraitItem(..) => if_ok!(write!(fmt.buf, \"Trait \")),\n             clean::StructItem(..) => if_ok!(write!(fmt.buf, \"Struct \")),\n             clean::EnumItem(..) => if_ok!(write!(fmt.buf, \"Enum \")),\n             _ => {}\n         }\n-        let cur = it.cx.current.as_slice();\n-        let amt = if it.ismodule() { cur.len() - 1 } else { cur.len() };\n+        let cur = self.cx.current.as_slice();\n+        let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n         for (i, component) in cur.iter().enumerate().take(amt) {\n             let mut trail = ~\"\";\n             for _ in range(0, cur.len() - i - 1) {\n@@ -856,17 +856,17 @@ impl<'a> fmt::Show for Item<'a> {\n                           trail, component.as_slice()));\n         }\n         if_ok!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n-                      shortty(it.item), it.item.name.get_ref().as_slice()));\n+                      shortty(self.item), self.item.name.get_ref().as_slice()));\n \n-        match it.item.inner {\n-            clean::ModuleItem(ref m) => item_module(fmt.buf, it.cx,\n-                                                    it.item, m.items),\n+        match self.item.inner {\n+            clean::ModuleItem(ref m) => item_module(fmt.buf, self.cx,\n+                                                    self.item, m.items),\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt.buf, it.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt.buf, it.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n-            clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n+                item_function(fmt.buf, self.item, f),\n+            clean::TraitItem(ref t) => item_trait(fmt.buf, self.item, t),\n+            clean::StructItem(ref s) => item_struct(fmt.buf, self.item, s),\n+            clean::EnumItem(ref e) => item_enum(fmt.buf, self.item, e),\n+            clean::TypedefItem(ref t) => item_typedef(fmt.buf, self.item, t),\n             _ => Ok(())\n         }\n     }\n@@ -992,9 +992,8 @@ fn item_module(w: &mut Writer, cx: &Context,\n             clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n                 struct Initializer<'a>(&'a str);\n                 impl<'a> fmt::Show for Initializer<'a> {\n-                    fn fmt(s: &Initializer<'a>,\n-                           f: &mut fmt::Formatter) -> fmt::Result {\n-                        let Initializer(s) = *s;\n+                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                        let Initializer(s) = *self;\n                         if s.len() == 0 { return Ok(()); }\n                         if_ok!(write!(f.buf, \"<code> = </code>\"));\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n@@ -1518,9 +1517,9 @@ fn item_typedef(w: &mut Writer, it: &clean::Item,\n }\n \n impl<'a> fmt::Show for Sidebar<'a> {\n-    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let cx = s.cx;\n-        let it = s.item;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let cx = self.cx;\n+        let it = self.item;\n         if_ok!(write!(fmt.buf, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n@@ -1588,8 +1587,8 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n }\n \n impl<'a> fmt::Show for Source<'a> {\n-    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Source(s) = *s;\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Source(s) = *self;\n         let lines = s.lines().len();\n         let mut cols = 0;\n         let mut tmp = lines;"}, {"sha": "7d50cf551a0cea99ac52e06f50b07cf2ce525191", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -36,6 +36,7 @@\n use std::char;\n use std::cmp;\n use std::fmt;\n+use std::fmt::Show;\n use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n \n@@ -62,10 +63,10 @@ impl cmp::Ord for Identifier {\n \n impl fmt::Show for Identifier {\n     #[inline]\n-    fn fmt(version: &Identifier, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *version {\n-            Numeric(ref n) => fmt::Show::fmt(n, f),\n-            AlphaNumeric(ref s) => fmt::Show::fmt(s, f)\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Numeric(ref n) => n.fmt(f),\n+            AlphaNumeric(ref s) => s.fmt(f)\n         }\n     }\n }\n@@ -97,20 +98,20 @@ pub struct Version {\n \n impl fmt::Show for Version {\n     #[inline]\n-    fn fmt(version: &Version, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}.{}.{}\", version.major, version.minor, version.patch))\n-        if !version.pre.is_empty() {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n+        if !self.pre.is_empty() {\n             if_ok!(write!(f.buf, \"-\"));\n-            for (i, x) in version.pre.iter().enumerate() {\n+            for (i, x) in self.pre.iter().enumerate() {\n                 if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(fmt::Show::fmt(x, f));\n+                if_ok!(x.fmt(f));\n             }\n         }\n-        if !version.build.is_empty() {\n+        if !self.build.is_empty() {\n             if_ok!(write!(f.buf, \"+\"));\n-            for (i, x) in version.build.iter().enumerate() {\n+            for (i, x) in self.build.iter().enumerate() {\n                 if i != 0 { if_ok!(write!(f.buf, \".\")) };\n-                if_ok!(fmt::Show::fmt(x, f));\n+                if_ok!(x.fmt(f));\n             }\n         }\n         Ok(())"}, {"sha": "d2e9fe040f7eddebad15b223733dfc4f2694f7be", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -166,11 +166,11 @@ method of the signature:\n # mod fmt { pub type Result = (); }\n # struct T;\n # trait SomeName<T> {\n-fn fmt(value: &T, f: &mut std::fmt::Formatter) -> fmt::Result;\n+fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result;\n # }\n ```\n \n-Your type will be passed by-reference in `value`, and then the function should\n+Your type will be passed as `self` by-reference, and then the function should\n emit output into the `f.buf` stream. It is up to each format trait\n implementation to correctly adhere to the requested formatting parameters. The\n values of these parameters will be listed in the fields of the `Formatter`\n@@ -195,19 +195,19 @@ struct Vector2D {\n }\n \n impl fmt::Show for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // The `f.buf` value is of the type `&mut io::Writer`, which is what th\n         // write! macro is expecting. Note that this formatting ignores the\n         // various flags provided to format strings.\n-        write!(f.buf, \"({}, {})\", obj.x, obj.y)\n+        write!(f.buf, \"({}, {})\", self.x, self.y)\n     }\n }\n \n // Different traits allow different forms of output of a type. The meaning of\n // this format is to print the magnitude of a vector.\n impl fmt::Binary for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n-        let magnitude = (obj.x * obj.x + obj.y * obj.y) as f64;\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n         let magnitude = magnitude.sqrt();\n \n         // Respect the formatting flags by using the helper method\n@@ -558,50 +558,50 @@ pub struct Arguments<'a> {\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n #[allow(missing_doc)]\n-pub trait Show { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Show { fn fmt(&self, &mut Formatter) -> Result; }\n \n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Bool { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Bool { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `c` character\n #[allow(missing_doc)]\n-pub trait Char { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Char { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `i` and `d` characters\n #[allow(missing_doc)]\n-pub trait Signed { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Signed { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `u` character\n #[allow(missing_doc)]\n-pub trait Unsigned { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Unsigned { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `o` character\n #[allow(missing_doc)]\n-pub trait Octal { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Octal { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Binary { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Binary { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `x` character\n #[allow(missing_doc)]\n-pub trait LowerHex { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait LowerHex { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `X` character\n #[allow(missing_doc)]\n-pub trait UpperHex { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait UpperHex { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `s` character\n #[allow(missing_doc)]\n-pub trait String { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait String { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `?` character\n #[allow(missing_doc)]\n-pub trait Poly { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Poly { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `p` character\n #[allow(missing_doc)]\n-pub trait Pointer { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Pointer { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `f` character\n #[allow(missing_doc)]\n-pub trait Float { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait Float { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `e` character\n #[allow(missing_doc)]\n-pub trait LowerExp { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait LowerExp { fn fmt(&self, &mut Formatter) -> Result; }\n /// Format trait for the `E` character\n #[allow(missing_doc)]\n-pub trait UpperExp { fn fmt(&Self, &mut Formatter) -> Result; }\n+pub trait UpperExp { fn fmt(&self, &mut Formatter) -> Result; }\n \n // FIXME #11938 - UFCS would make us able call the above methods\n // directly Show::show(x, fmt).\n@@ -615,7 +615,7 @@ macro_rules! uniform_fn_call_workaround {\n         $(\n             #[doc(hidden)]\n             pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n-                $trait_::fmt(x, fmt)\n+                x.fmt(fmt)\n             }\n             )*\n     }\n@@ -1042,53 +1042,53 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n /// (such as for select), then it invokes this method.\n #[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(String::fmt, s)\n+    argument(secret_string, s)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n #[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Unsigned::fmt, s)\n+    argument(secret_unsigned, s)\n }\n \n // Implementations of the core formatting traits\n \n impl Bool for bool {\n-    fn fmt(b: &bool, f: &mut Formatter) -> Result {\n-        String::fmt(&(if *b {\"true\"} else {\"false\"}), f)\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n     }\n }\n \n impl<'a, T: str::Str> String for T {\n-    fn fmt(s: &T, f: &mut Formatter) -> Result {\n-        f.pad(s.as_slice())\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(self.as_slice())\n     }\n }\n \n impl Char for char {\n-    fn fmt(c: &char, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n-        let amt = c.encode_utf8(utf8);\n+        let amt = self.encode_utf8(utf8);\n         let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n-        String::fmt(&s, f)\n+        secret_string(&s, f)\n     }\n }\n \n macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*c as $into, $base, |buf| {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$into::to_str_bytes(*self as $into, $base, |buf| {\n                 f.pad_integral(buf, $prefix, true)\n             })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*c as $into, 16, |buf| {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$into::to_str_bytes(*self as $into, 16, |buf| {\n                 upperhex(buf, f)\n             })\n         }\n@@ -1112,9 +1112,9 @@ macro_rules! integer(($signed:ident, $unsigned:ident) => {\n     // Signed is special because it actuall emits the negative sign,\n     // nothing else should do that, however.\n     impl Signed for $signed {\n-        fn fmt(c: &$signed, f: &mut Formatter) -> Result {\n-            ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *c >= 0)\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            ::$unsigned::to_str_bytes(self.abs() as $unsigned, 10, |buf| {\n+                f.pad_integral(buf, \"\", *self >= 0)\n             })\n         }\n     }\n@@ -1138,103 +1138,103 @@ integer!(i64, u64)\n \n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exact(f.abs(), i),\n-                None => ::$ty::to_str_digits(f.abs(), 6)\n+                Some(i) => ::$ty::to_str_exact(self.abs(), i),\n+                None => ::$ty::to_str_digits(self.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n \n     impl LowerExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, false),\n-                None => ::$ty::to_str_exp_digits(f.abs(), 6, false)\n+                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n+                None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n \n     impl UpperExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n+        fn fmt(&self, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, true),\n-                None => ::$ty::to_str_exp_digits(f.abs(), 6, true)\n+                Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n+                None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n+            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n         }\n     }\n })\n floating!(f32)\n floating!(f64)\n \n impl<T> Poly for T {\n-    fn fmt(t: &T, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         match (f.width, f.precision) {\n             (None, None) => {\n-                repr::write_repr(f.buf, t)\n+                repr::write_repr(f.buf, self)\n             }\n \n             // If we have a specified width for formatting, then we have to make\n             // this allocation of a new string\n             _ => {\n-                let s = repr::repr_to_str(t);\n+                let s = repr::repr_to_str(self);\n                 f.pad(s)\n             }\n         }\n     }\n }\n \n impl<T> Pointer for *T {\n-    fn fmt(t: &*T, f: &mut Formatter) -> Result {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        ::uint::to_str_bytes(*t as uint, 16, |buf| {\n+        ::uint::to_str_bytes(*self as uint, 16, |buf| {\n             f.pad_integral(buf, \"0x\", true)\n         })\n     }\n }\n impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) -> Result {\n-        Pointer::fmt(&(*t as *T), f)\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_pointer(&(*self as *T), f)\n     }\n }\n \n // Implementation of Show for various core types\n \n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl<'a> Show for $ty {\n-        fn fmt(me: &$ty, f: &mut Formatter) -> Result {\n-            $other::fmt(me, f)\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            (concat_idents!(secret_, $other)(self, f))\n         }\n     }\n })\n-delegate!(int to Signed)\n-delegate!( i8 to Signed)\n-delegate!(i16 to Signed)\n-delegate!(i32 to Signed)\n-delegate!(i64 to Signed)\n-delegate!(uint to Unsigned)\n-delegate!(  u8 to Unsigned)\n-delegate!( u16 to Unsigned)\n-delegate!( u32 to Unsigned)\n-delegate!( u64 to Unsigned)\n-delegate!(~str to String)\n-delegate!(&'a str to String)\n-delegate!(bool to Bool)\n-delegate!(char to Char)\n-delegate!(f32 to Float)\n-delegate!(f64 to Float)\n+delegate!(int to signed)\n+delegate!( i8 to signed)\n+delegate!(i16 to signed)\n+delegate!(i32 to signed)\n+delegate!(i64 to signed)\n+delegate!(uint to unsigned)\n+delegate!(  u8 to unsigned)\n+delegate!( u16 to unsigned)\n+delegate!( u32 to unsigned)\n+delegate!( u64 to unsigned)\n+delegate!(~str to string)\n+delegate!(&'a str to string)\n+delegate!(bool to bool)\n+delegate!(char to char)\n+delegate!(f32 to float)\n+delegate!(f64 to float)\n \n impl<T> Show for *T {\n-    fn fmt(me: &*T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n impl<T> Show for *mut T {\n-    fn fmt(me: &*mut T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "4d28143c75ab65d1e8ba6e5bd482cb615edae805", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -364,9 +364,9 @@ pub struct IoError {\n }\n \n impl fmt::Show for IoError {\n-    fn fmt(err: &IoError, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(fmt.buf.write_str(err.desc));\n-        match err.detail {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(fmt.buf.write_str(self.desc));\n+        match self.detail {\n             Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n             None => Ok(())\n         }"}, {"sha": "b515cd9d31c0eb5048e22a46d112b8104f531daa", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -93,8 +93,8 @@ pub enum ProcessExit {\n \n impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *obj {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n             ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n         }"}, {"sha": "5d986a73ca14d1d46326a81db98aaf32d371e233", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -382,8 +382,8 @@ impl<T: Default> Option<T> {\n \n impl<T: fmt::Show> fmt::Show for Option<T> {\n     #[inline]\n-    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *s {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             Some(ref t) => write!(f.buf, \"Some({})\", *t),\n             None        => write!(f.buf, \"None\")\n         }"}, {"sha": "78cae2964570c995ab965af89e55ad728a175acf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -942,8 +942,8 @@ pub enum MapError {\n }\n \n impl fmt::Show for MapError {\n-    fn fmt(val: &MapError, out: &mut fmt::Formatter) -> fmt::Result {\n-        let str = match *val {\n+    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n+        let str = match *self {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n             ErrInvalidFd => \"Invalid fd\",\n             ErrUnaligned => {"}, {"sha": "18f28994cba9697835114365f2c755d2862ded95", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -494,8 +494,8 @@ pub struct Display<'a, P> {\n }\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n-    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Result {\n-        d.with_str(|s| f.pad(s))\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.with_str(|s| f.pad(s))\n     }\n }\n "}, {"sha": "39e8b6ad6c1d2608f0634bf6aa0dc217d13ab5cc", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -208,8 +208,8 @@ impl<T, E> Result<T, E> {\n \n impl<T: fmt::Show, E: fmt::Show> fmt::Show for Result<T, E> {\n     #[inline]\n-    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *s {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n             Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n             Err(ref e) => write!(f.buf, \"Err({})\", *e)\n         }"}, {"sha": "d32411b4f050ae1f10aa28000c99706db59c4f32", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -588,8 +588,8 @@ impl BytesContainer for InternedString {\n }\n \n impl fmt::Show for InternedString {\n-    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", obj.string.as_slice())\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, \"{}\", self.string.as_slice())\n     }\n }\n "}, {"sha": "4a82007f0600462a846913179ec1e72b634d5ab8", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -23,12 +23,12 @@ struct A;\n struct B;\n \n impl fmt::Signed for A {\n-    fn fmt(_: &A, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.buf.write(\"aloha\".as_bytes())\n     }\n }\n impl fmt::Signed for B {\n-    fn fmt(_: &B, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.buf.write(\"adios\".as_bytes())\n     }\n }"}, {"sha": "8c6a366220cec522ee66a91e991ce45f0591d356", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d1204a4b7c9322c873c353836238a88b78edf1b/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=8d1204a4b7c9322c873c353836238a88b78edf1b", "patch": "@@ -17,8 +17,8 @@ use std::fmt;\n struct Foo(Cell<int>);\n \n impl fmt::Show for Foo {\n-    fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Foo(ref f) = *f;\n+    fn fmt(&self, _fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let Foo(ref f) = *self;\n         assert!(f.get() == 0);\n         f.set(1);\n         Ok(())"}]}