{"sha": "0e8ad4d8a2f23206c723137d765027a7acd97837", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOGFkNGQ4YTJmMjMyMDZjNzIzMTM3ZDc2NTAyN2E3YWNkOTc4Mzc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-02T05:40:06Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-05T20:59:06Z"}, "message": "extra: fix BigInt on 32bit machines", "tree": {"sha": "145a051ffe5c97bf40e4a5a7f6ff3b367605ee17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/145a051ffe5c97bf40e4a5a7f6ff3b367605ee17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e8ad4d8a2f23206c723137d765027a7acd97837", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8ad4d8a2f23206c723137d765027a7acd97837", "html_url": "https://github.com/rust-lang/rust/commit/0e8ad4d8a2f23206c723137d765027a7acd97837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e8ad4d8a2f23206c723137d765027a7acd97837/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efae73d95a2accdd712f2b2a7573655a0cf88f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/efae73d95a2accdd712f2b2a7573655a0cf88f3e", "html_url": "https://github.com/rust-lang/rust/commit/efae73d95a2accdd712f2b2a7573655a0cf88f3e"}], "stats": {"total": 266, "additions": 139, "deletions": 127}, "files": [{"sha": "8604674ea12204c15bfb30253ed2be6b31802d68", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 139, "deletions": 127, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/0e8ad4d8a2f23206c723137d765027a7acd97837/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8ad4d8a2f23206c723137d765027a7acd97837/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=0e8ad4d8a2f23206c723137d765027a7acd97837", "patch": "@@ -506,10 +506,10 @@ impl ToPrimitive for BigUint {\n     fn to_i64(&self) -> Option<i64> {\n         do self.to_u64().and_then |n| {\n             // If top bit of u64 is set, it's too large to convert to i64.\n-            if (n >> (2*BigDigit::bits - 1) != 0) {\n-                None\n-            } else {\n+            if n >> 63 == 0 {\n                 Some(n as i64)\n+            } else {\n+                None\n             }\n         }\n     }\n@@ -562,10 +562,12 @@ impl ToPrimitive for BigUint {\n impl FromPrimitive for BigUint {\n     #[inline]\n     fn from_i64(n: i64) -> Option<BigUint> {\n-        if (n < 0) {\n+        if (n > 0) {\n+            FromPrimitive::from_u64(n as u64)\n+        } else if (n == 0) {\n             Some(Zero::zero())\n         } else {\n-            FromPrimitive::from_u64(n as u64)\n+            None\n         }\n     }\n \n@@ -802,30 +804,6 @@ impl BigUint {\n     }\n }\n \n-#[cfg(target_word_size = \"64\")]\n-#[inline]\n-fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert!(1 < radix && radix <= 16);\n-    match radix {\n-        2  => (4294967296, 32),\n-        3  => (3486784401, 20),\n-        4  => (4294967296, 16),\n-        5  => (1220703125, 13),\n-        6  => (2176782336, 12),\n-        7  => (1977326743, 11),\n-        8  => (1073741824, 10),\n-        9  => (3486784401, 10),\n-        10 => (1000000000, 9),\n-        11 => (2357947691, 9),\n-        12 => (429981696,  8),\n-        13 => (815730721,  8),\n-        14 => (1475789056, 8),\n-        15 => (2562890625, 8),\n-        16 => (4294967296, 8),\n-        _  => fail2!()\n-    }\n-}\n-\n #[cfg(target_word_size = \"32\")]\n #[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n@@ -850,6 +828,30 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n     }\n }\n \n+#[cfg(target_word_size = \"64\")]\n+#[inline]\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n+    assert!(1 < radix && radix <= 16);\n+    match radix {\n+        2  => (4294967296, 32),\n+        3  => (3486784401, 20),\n+        4  => (4294967296, 16),\n+        5  => (1220703125, 13),\n+        6  => (2176782336, 12),\n+        7  => (1977326743, 11),\n+        8  => (1073741824, 10),\n+        9  => (3486784401, 10),\n+        10 => (1000000000, 9),\n+        11 => (2357947691, 9),\n+        12 => (429981696,  8),\n+        13 => (815730721,  8),\n+        14 => (1475789056, 8),\n+        15 => (2562890625, 8),\n+        16 => (4294967296, 8),\n+        _  => fail2!()\n+    }\n+}\n+\n /// A Sign is a `BigInt`'s composing element.\n #[deriving(Eq, Clone)]\n pub enum Sign { Minus, Zero, Plus }\n@@ -1181,13 +1183,13 @@ impl ToPrimitive for BigInt {\n             Zero  => Some(0),\n             Minus => {\n                 do self.data.to_u64().and_then |n| {\n-                    let m: u64 = 1 << (2*BigDigit::bits-1);\n-                    if (n > m) {\n-                        None\n-                    } else if (n == m) {\n+                    let m: u64 = 1 << 63;\n+                    if n < m {\n+                        Some(-(n as i64))\n+                    } else if n == m {\n                         Some(i64::min_value)\n                     } else {\n-                        Some(-(n as i64))\n+                        None\n                     }\n                 }\n             }\n@@ -1431,16 +1433,15 @@ impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n-\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n-    use std::int;\n+    use std::i64;\n     use std::num::{Zero, One, FromStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n     use std::str;\n-    use std::uint;\n+    use std::u64;\n     use std::vec;\n \n     #[test]\n@@ -1612,44 +1613,110 @@ mod biguint_tests {\n               \"88887777666655554444333322221111\");\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n+    #[test]\n+    fn test_convert_i64() {\n+        fn check(b1: BigUint, i: i64) {\n+            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n+\n+        check(BigUint::new(~[                   ]), 0);\n+        check(BigUint::new(~[ 1                 ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1                 ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1             ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1             ]), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  1         ]), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1         ]), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  0,  1     ]), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1, -1 >> 1]), i64::max_value);\n+\n+        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1    ]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_i64(), None);\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n     #[test]\n-    fn test_convert_int() {\n-        fn check(v: ~[BigDigit], i: int) {\n-            let b1 = BigUint::new(v);\n-            let b2: BigUint = FromPrimitive::from_int(i).unwrap();\n+    fn test_convert_i64() {\n+        fn check(b1: BigUint, i: i64) {\n+            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n+\n+        check(BigUint::new(~[           ]), 0);\n+        check(BigUint::new(~[ 1         ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1         ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1     ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1 >> 1]), i64::max_value);\n+\n+        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(BigUint::new(~[-1, -1    ]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1]).to_i64(), None);\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    #[test]\n+    fn test_convert_u64() {\n+        fn check(b1: BigUint, u: u64) {\n+            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n             assert!(b1 == b2);\n-            assert!(b1.to_int().unwrap() == i);\n+            assert!(b1.to_u64().unwrap() == u);\n         }\n \n-        check(~[], 0);\n-        check(~[1], 1);\n-        check(~[-1], (uint::max_value >> BigDigit::bits) as int);\n-        check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n-        check(~[-1, -1 >> 1], int::max_value);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n+        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+\n+        check(BigUint::new(~[              ]), 0);\n+        check(BigUint::new(~[ 1            ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1            ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1        ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1        ]), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  1    ]), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1    ]), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  0,  1]), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1, -1]), u64::max_value);\n \n-        assert_eq!(BigUint::new(~[0, -1]).to_int(), None);\n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_int(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_int(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_u64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_u64(), None);\n     }\n \n+    #[cfg(target_word_size = \"64\")]\n     #[test]\n-    fn test_convert_uint() {\n-        fn check(v: ~[BigDigit], u: uint) {\n-            let b1 = BigUint::new(v);\n-            let b2: BigUint = FromPrimitive::from_uint(u).unwrap();\n+    fn test_convert_u64() {\n+        fn check(b1: BigUint, u: u64) {\n+            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n             assert!(b1 == b2);\n-            assert!(b1.to_uint().unwrap() == u);\n+            assert!(b1.to_u64().unwrap() == u);\n         }\n \n-        check(~[], 0);\n-        check(~[ 1], 1);\n-        check(~[-1], uint::max_value >> BigDigit::bits);\n-        check(~[ 0,  1], (uint::max_value >> BigDigit::bits) + 1);\n-        check(~[ 0, -1], uint::max_value << BigDigit::bits);\n-        check(~[-1, -1], uint::max_value);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n+        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+\n+        check(BigUint::new(~[      ]), 0);\n+        check(BigUint::new(~[ 1    ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1    ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1]), u64::max_value);\n \n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_u64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1]).to_u64(), None);\n     }\n \n     #[test]\n@@ -2025,10 +2092,11 @@ mod bigint_tests {\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n-    use std::{int, i64, uint, u64};\n+    use std::i64;\n     use std::num::{Zero, One, FromStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n+    use std::u64;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -2086,59 +2154,6 @@ mod bigint_tests {\n         }\n     }\n \n-    #[test]\n-    fn test_convert_int() {\n-        fn check(b1: BigInt, i: int) {\n-            let b2: BigInt = FromPrimitive::from_int(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_int().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(BigInt::from_biguint(\n-            Plus, FromPrimitive::from_uint(int::max_value as uint).unwrap()\n-        ), int::max_value);\n-\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, FromPrimitive::from_uint(int::max_value as uint + 1).unwrap()\n-        ).to_int(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int(), None);\n-\n-        check(BigInt::from_biguint(\n-            Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])\n-        ), int::min_value);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])\n-        ).to_int(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])).to_int(), None);\n-    }\n-\n-    #[test]\n-    fn test_convert_uint() {\n-        fn check(b1: BigInt, u: uint) {\n-            let b2: BigInt = FromPrimitive::from_uint(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_uint().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-\n-        check(\n-            BigInt::from_biguint(Plus, FromPrimitive::from_uint(uint::max_value).unwrap()),\n-            uint::max_value);\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])).to_uint(), None);\n-\n-        let max_value: BigUint = FromPrimitive::from_uint(uint::max_value).unwrap();\n-        assert_eq!(BigInt::from_biguint(Minus, max_value).to_uint(), None);\n-        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3])).to_uint(), None);\n-    }\n-\n     #[test]\n     fn test_convert_i64() {\n         fn check(b1: BigInt, i: i64) {\n@@ -2153,19 +2168,15 @@ mod bigint_tests {\n         check(i64::max_value.to_bigint().unwrap(), i64::max_value);\n \n         assert_eq!(\n-            (i64::max_value as uint + 1).to_bigint().unwrap().to_i64(),\n+            (i64::max_value as u64 + 1).to_bigint().unwrap().to_i64(),\n             None);\n \n         assert_eq!(\n-            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            BigInt::from_biguint(Plus,  BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n             None);\n \n-        check(\n-            BigInt::from_biguint(Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])),\n-            i64::min_value);\n-\n         assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])).to_i64(),\n+            BigInt::from_biguint(Minus, BigUint::new(~[1, 0, 0, 1<<(BigDigit::bits-1)])).to_i64(),\n             None);\n \n         assert_eq!(\n@@ -2183,15 +2194,16 @@ mod bigint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n+        check(u64::min_value.to_bigint().unwrap(), u64::min_value);\n         check(u64::max_value.to_bigint().unwrap(), u64::max_value);\n \n         assert_eq!(\n-            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_uint(),\n+            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(),\n             None);\n \n-        let max_value: BigUint = FromPrimitive::from_uint(uint::max_value).unwrap();\n+        let max_value: BigUint = FromPrimitive::from_u64(u64::max_value).unwrap();\n         assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n-        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3])).to_u64(), None);\n+        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(), None);\n     }\n \n     #[test]"}]}