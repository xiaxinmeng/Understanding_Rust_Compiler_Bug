{"sha": "0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhM2ViNWM1MDhiY2U1MDg3MzQwMWNhOTQyZTNjYjFkNGEwY2UyMWY=", "commit": {"author": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-03-27T14:27:02Z"}, "committer": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-04-03T13:19:26Z"}, "message": "Simplify code around expected argument types.", "tree": {"sha": "6ffa260bf52c79a1d4d9cac5958dc64207eab807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ffa260bf52c79a1d4d9cac5958dc64207eab807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "html_url": "https://github.com/rust-lang/rust/commit/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f/comments", "author": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba5a5cf2199ab55e9b47820c32e11a27d93df519", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5a5cf2199ab55e9b47820c32e11a27d93df519", "html_url": "https://github.com/rust-lang/rust/commit/ba5a5cf2199ab55e9b47820c32e11a27d93df519"}], "stats": {"total": 99, "additions": 50, "deletions": 49}, "files": [{"sha": "5ca8d1b06e1273795a828d66661fac4b9dd88c77", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3eb5c508bce50873401ca942e3cb1d4a0ce21f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0a3eb5c508bce50873401ca942e3cb1d4a0ce21f", "patch": "@@ -2507,7 +2507,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             sp: Span,\n                             expr_sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n-                            expected_arg_tys: &[Ty<'tcx>],\n+                            mut expected_arg_tys: &[Ty<'tcx>],\n                             args: &'gcx [hir::Expr],\n                             variadic: bool,\n                             tuple_arguments: TupleArgumentsFlag,\n@@ -2528,7 +2528,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.register_wf_obligation(fn_input_ty, sp, traits::MiscObligation);\n         }\n \n-        let mut expected_arg_tys = expected_arg_tys;\n         let expected_arg_count = fn_inputs.len();\n \n         let param_count_error = |expected_count: usize,\n@@ -2615,6 +2614,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected_arg_tys = &[];\n             self.err_args(supplied_arg_count)\n         };\n+        // If there is no expectation, expect formal_tys.\n+        let expected_arg_tys = if !expected_arg_tys.is_empty() {\n+            expected_arg_tys\n+        } else {\n+            &formal_tys\n+        };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n                formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n@@ -2666,28 +2671,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // The special-cased logic below has three functions:\n                 // 1. Provide as good of an expected type as possible.\n-                let expected = expected_arg_tys.get(i).map(|&ty| {\n-                    Expectation::rvalue_hint(self, ty)\n-                });\n+                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n \n-                let checked_ty = self.check_expr_with_expectation(\n-                    &arg,\n-                    expected.unwrap_or(ExpectHasType(formal_ty)));\n+                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n \n                 // 2. Coerce to the most detailed type that could be coerced\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n+                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg,\n-                                   checked_ty,\n-                                   coerce_ty.unwrap_or(formal_ty),\n-                                   AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty,  AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n-                coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n+                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n             }\n         }\n \n@@ -2834,6 +2832,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n+        // checks don't need two phase\n         self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n@@ -2882,45 +2881,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            formal_args: &[Ty<'tcx>])\n                                            -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_type_vars_with_obligations(formal_ret);\n-        let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n-                // Attempt to apply a subtyping relationship between the formal\n-                // return type (likely containing type variables if the function\n-                // is polymorphic) and the expected return type.\n-                // No argument expectations are produced if unification fails.\n-                let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = TraitEngine::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        }).map_err(|_| ())?;\n-                    }\n-                    Err(_) => return Err(()),\n+        let ret_ty = match expected_ret.only_has_type(self) {\n+            Some(ret) => ret,\n+            None => return Vec::new()\n+        };\n+        let expect_args = self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n+            // Attempt to apply a subtyping relationship between the formal\n+            // return type (likely containing type variables if the function\n+            // is polymorphic) and the expected return type.\n+            // No argument expectations are produced if unification fails.\n+            let origin = self.misc(call_span);\n+            let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n+\n+            // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n+            // to identity so the resulting type is not constrained.\n+            match ures {\n+                Ok(ok) => {\n+                    // Process any obligations locally as much as\n+                    // we can.  We don't care if some things turn\n+                    // out unconstrained or ambiguous, as we're\n+                    // just trying to get hints here.\n+                    self.save_and_restore_in_snapshot_flag(|_| {\n+                        let mut fulfill = TraitEngine::new(self.tcx);\n+                        for obligation in ok.obligations {\n+                            fulfill.register_predicate_obligation(self, obligation);\n+                        }\n+                        fulfill.select_where_possible(self)\n+                    }).map_err(|_| ())?;\n                 }\n+                Err(_) => return Err(()),\n+            }\n \n-                // Record all the argument types, with the substitutions\n-                // produced from the above subtyping unification.\n-                Ok(formal_args.iter().map(|ty| {\n-                    self.resolve_type_vars_if_possible(ty)\n-                }).collect())\n-            }).ok()\n-        }).unwrap_or(vec![]);\n+            // Record all the argument types, with the substitutions\n+            // produced from the above subtyping unification.\n+            Ok(formal_args.iter().map(|ty| {\n+                self.resolve_type_vars_if_possible(ty)\n+            }).collect())\n+        }).unwrap_or(Vec::new());\n         debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n-               expected_args, expected_ret);\n-        expected_args\n+               expect_args, expected_ret);\n+        expect_args\n     }\n \n     // Checks a method call."}]}