{"sha": "765961438d0a3f8f37f1e38160f6dca04870ae10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTk2MTQzOGQwYTNmOGYzN2YxZTM4MTYwZjZkY2EwNDg3MGFlMTA=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-07T00:20:41Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-02-09T21:37:04Z"}, "message": "fix typos in sample code, add enum to json encoder, add test case", "tree": {"sha": "1cf41ba7a5fd2df4e63cca3b85c9c2277fc019d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cf41ba7a5fd2df4e63cca3b85c9c2277fc019d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/765961438d0a3f8f37f1e38160f6dca04870ae10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/765961438d0a3f8f37f1e38160f6dca04870ae10", "html_url": "https://github.com/rust-lang/rust/commit/765961438d0a3f8f37f1e38160f6dca04870ae10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/765961438d0a3f8f37f1e38160f6dca04870ae10/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19dfec2aaf746535de1521f68421f9980dbf25de", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dfec2aaf746535de1521f68421f9980dbf25de", "html_url": "https://github.com/rust-lang/rust/commit/19dfec2aaf746535de1521f68421f9980dbf25de"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "2ad18fbced27a8695eed23d27fe13b232598d1bb", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/765961438d0a3f8f37f1e38160f6dca04870ae10/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765961438d0a3f8f37f1e38160f6dca04870ae10/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=765961438d0a3f8f37f1e38160f6dca04870ae10", "patch": "@@ -122,9 +122,15 @@ pub impl Encoder: serialize::Encoder {\n     fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n-        if name != \"option\" { die!(~\"only supports option enum\") }\n-        f()\n+        // emitting enums as arrays where the first\n+        // element provides the enum variant name\n+        self.wr.write_char('[');\n+        self.wr.write_str(name);\n+        self.wr.write_char(',');\n+        f();\n+        self.wr.write_char(']');\n     }\n+    \n     fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n         if id == 0 {\n             self.emit_nil();"}, {"sha": "d8c15d09d98eab83d5a161764394a3999cf2257c", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/765961438d0a3f8f37f1e38160f6dca04870ae10/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765961438d0a3f8f37f1e38160f6dca04870ae10/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=765961438d0a3f8f37f1e38160f6dca04870ae10", "patch": "@@ -23,23 +23,23 @@ For example, a type like:\n \n would generate two implementations like:\n \n-    impl<S: Encoder> node_id: Encodable<S> {\n-        fn encode(s: &S) {\n-            do s.emit_struct(\"Node\", 1) {\n-                s.emit_field(\"id\", 0, || s.emit_uint(self))\n-            }\n+impl<S: std::serialize::Encoder> Node: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_struct(\"Node\", 1) {\n+            s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n         }\n     }\n+}\n \n-    impl<D: Decoder> node_id: Decodable {\n-        static fn decode(d: &D) -> Node {\n-            do d.read_struct(\"Node\", 1) {\n-                Node {\n-                    id: d.read_field(~\"x\", 0, || decode(d))\n-                }\n+impl<D: Decoder> node_id: Decodable {\n+    static fn decode(d: &D) -> Node {\n+        do d.read_struct(\"Node\", 1) {\n+            Node {\n+                id: d.read_field(~\"x\", 0, || decode(d))\n             }\n         }\n     }\n+}\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n@@ -1150,3 +1150,42 @@ fn mk_enum_deser_body(\n         ]\n     )\n }\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::serialize::Encodable;\n+    use core::dvec::*;\n+    use util::testing::*;\n+    use core::io;\n+    use core::str;\n+    use std;\n+    \n+    \n+    #[auto_decode]\n+    #[auto_encode]\n+    struct Node {id: uint}\n+\n+    fn to_json_str (val: Encodable<std::json::Encoder>) -> ~str{\n+        let bw = @io::BytesWriter {bytes: DVec(), pos: 0};\n+        val.encode(~std::json::Encoder(bw as io::Writer));\n+        str::from_bytes(bw.bytes.data)\n+    }\n+    \n+    #[test] fn encode_test () {\n+        check_equal (to_json_str(Node{id:34} as Encodable::<std::json::Encoder>),~\"{\\\"id\\\":34}\");\n+    }\n+\n+    #[auto_encode]\n+    enum written {\n+        Book(int),\n+        Magazine(~str)\n+    }\n+\n+    #[test] fn json_enum_encode_test () {\n+        check_equal (to_json_str(Book(9) as Encodable::<std::json::Encoder>),\n+                     ~\"[\\\"Book\\\",9]\");\n+        check_equal (to_json_str(Magazine(~\"Paris Match\") as Encodable::<std::json::Encoder>),\n+                     ~\"[\\\"Magazine\\\",\\\"Paris Match\\\"]\");\n+    }\n+}"}]}