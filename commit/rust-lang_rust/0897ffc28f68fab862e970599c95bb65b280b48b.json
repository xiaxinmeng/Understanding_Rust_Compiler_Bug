{"sha": "0897ffc28f68fab862e970599c95bb65b280b48b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4OTdmZmMyOGY2OGZhYjg2MmU5NzA1OTljOTViYjY1YjI4MGI0OGI=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-01-25T21:03:27Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-01-27T04:07:55Z"}, "message": "remove `_with_applicability` from suggestion fns", "tree": {"sha": "7a1b107f558b9fc90815eadae7b004129b509f8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a1b107f558b9fc90815eadae7b004129b509f8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0897ffc28f68fab862e970599c95bb65b280b48b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlxNLpsWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdBweCACm4sftSHLn2uWb+FG/IRFt+0rI\nFY/HyRE4f6P8qTRaDPel3OjnCtjl3+22o83jThRYmsf0qFQ+J4gDUQHOBNVlqsDG\naQzF5o6GnMWeB952ysnTKHABGpFxnk2dWJQ6oFb9rITzhtFvE8ioVLBDaACnfzz4\nDuJwAL/bhVrXNtJ5WfANmXb1TLjOVbKyptsWaBOf2KTzrOM+uzJ4zBrB1CO2H1do\n7RDDAAh37ygEgTjP00jLHCYUZmeIsC7aoCU+uqK7o9lYQKiBSZY+Lm81QRgZ+jyx\nFvGXUpRNl6NbxawrLTUk0J41GeXwNLnQXEy/HL9TKfnP7jqgQvivrc0KAiO+\n=JsR+\n-----END PGP SIGNATURE-----", "payload": "tree 7a1b107f558b9fc90815eadae7b004129b509f8f\nparent 8eaa84c79f5491735dc616d8591318e954e57a68\nauthor Andy Russell <arussell123@gmail.com> 1548450207 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1548562075 -0500\n\nremove `_with_applicability` from suggestion fns\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0897ffc28f68fab862e970599c95bb65b280b48b", "html_url": "https://github.com/rust-lang/rust/commit/0897ffc28f68fab862e970599c95bb65b280b48b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0897ffc28f68fab862e970599c95bb65b280b48b/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eaa84c79f5491735dc616d8591318e954e57a68", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eaa84c79f5491735dc616d8591318e954e57a68", "html_url": "https://github.com/rust-lang/rust/commit/8eaa84c79f5491735dc616d8591318e954e57a68"}], "stats": {"total": 733, "additions": 315, "deletions": 418}, "files": [{"sha": "51dbad92225e1bc906f07632ed77adbdead749f5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1829,7 +1829,7 @@ impl<'a> LoweringContext<'a> {\n                         if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n                             // Do not suggest going from `Trait()` to `Trait<>`\n                             if data.inputs.len() > 0 {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     data.span,\n                                     \"use angle brackets instead\",\n                                     format!(\"<{}>\", &snippet[1..snippet.len() - 1]),"}, {"sha": "66e4cd49c807f6d4d1fcc35d12dcc945ca39ea90", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(ty::error::ExpectedFound { found, .. }) = exp_found {\n                     if ty.is_box() && ty.boxed_ty() == found {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span,\n                                 \"consider dereferencing the boxed value\",\n                                 format!(\"*{}\", snippet),\n@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(then, \"expected because of this\");\n                 outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n                 if let Some(sp) = semicolon {\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         sp,\n                         \"consider removing this semicolon\",\n                         String::new(),\n@@ -1084,7 +1084,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 self.tcx.sess.source_map().span_to_snippet(span),\n                                 show_suggestion,\n                             ) {\n-                                diag.span_suggestion_with_applicability(\n+                                diag.span_suggestion(\n                                     span,\n                                     msg,\n                                     format!(\"{}.as_ref()\", snippet),\n@@ -1273,7 +1273,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let tail = if has_lifetimes { \" + \" } else { \"\" };\n                     format!(\"{}: {}{}\", bound_kind, sub, tail)\n                 };\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     sp,\n                     &consider,\n                     suggestion,"}, {"sha": "918a46aacd04113f0012152a20929b584e9ffa8f", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             E0621,\n             \"explicit lifetime required in {}\",\n             error_var\n-        ).span_suggestion_with_applicability(\n+        ).span_suggestion(\n             new_ty_span,\n             &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n             new_ty.to_string(),"}, {"sha": "7501e2f2108880a8b6912996d5e7fbd7f7c3c74e", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                         _ => \"'_\".to_owned(),\n                     };\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             return_sp,\n                             &format!(\n                                 \"you can add a constraint to the return type to make it last \\"}, {"sha": "35a038235957208f2d672be7536205495791e998", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -473,7 +473,7 @@ impl BuiltinLintDiagnostics {\n                     Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n                     Err(_) => (\"dyn <type>\".to_string(), Applicability::HasPlaceholders)\n                 };\n-                db.span_suggestion_with_applicability(span, \"use `dyn`\", sugg, app);\n+                db.span_suggestion(span, \"use `dyn`\", sugg, app);\n             }\n             BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n                 let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n@@ -490,7 +490,7 @@ impl BuiltinLintDiagnostics {\n                     }\n                     Err(_) => (\"crate::<path>\".to_string(), Applicability::HasPlaceholders)\n                 };\n-                db.span_suggestion_with_applicability(span, \"use `crate`\", sugg, app);\n+                db.span_suggestion(span, \"use `crate`\", sugg, app);\n             }\n             BuiltinLintDiagnostics::DuplicatedMacroExports(ident, earlier_span, later_span) => {\n                 db.span_label(later_span, format!(\"`{}` already exported\", ident));\n@@ -531,20 +531,15 @@ impl BuiltinLintDiagnostics {\n                         (insertion_span, anon_lts)\n                     }\n                 };\n-                db.span_suggestion_with_applicability(\n+                db.span_suggestion(\n                     replace_span,\n                     &format!(\"indicate the anonymous lifetime{}\", if n >= 2 { \"s\" } else { \"\" }),\n                     suggestion,\n                     Applicability::MachineApplicable\n                 );\n             }\n             BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n-                db.span_suggestion_with_applicability(\n-                    span,\n-                    &note,\n-                    sugg,\n-                    Applicability::MaybeIncorrect\n-                );\n+                db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n             }\n         }\n     }"}, {"sha": "616915769435d37abddead5eeec9ba19a9d49c9b", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -324,7 +324,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                     Some(li.span.into()),\n                                     &msg,\n                                 );\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     li.span,\n                                     \"change it to\",\n                                     new_lint_name.to_string(),\n@@ -362,7 +362,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                               Some(li.span.into()),\n                                                               &msg);\n                         if let Some(new_name) = renamed {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 li.span,\n                                 \"use the new name\",\n                                 new_name,\n@@ -386,7 +386,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 &msg);\n \n                         if let Some(suggestion) = suggestion {\n-                            db.span_suggestion_with_applicability(\n+                            db.span_suggestion(\n                                 li.span,\n                                 \"did you mean\",\n                                 suggestion.to_string(),"}, {"sha": "cc0dd71738fcecc6a93ede8032fa679a810fcccb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1600,12 +1600,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let mut err = self.ir.tcx\n                         .struct_span_lint_hir(lint::builtin::UNUSED_VARIABLES, hir_id, sp, &msg);\n                     if self.ir.variable_is_shorthand(var) {\n-                        err.span_suggestion_with_applicability(sp, \"try ignoring the field\",\n-                                                               format!(\"{}: _\", name),\n-                                                               Applicability::MachineApplicable);\n+                        err.span_suggestion(\n+                            sp,\n+                            \"try ignoring the field\",\n+                            format!(\"{}: _\", name),\n+                            Applicability::MachineApplicable,\n+                        );\n                     } else {\n-                        err.span_suggestion_short_with_applicability(\n-                            sp, &suggest_underscore_msg,\n+                        err.span_suggestion_short(\n+                            sp,\n+                            &suggest_underscore_msg,\n                             format!(\"_{}\", name),\n                             Applicability::MachineApplicable,\n                         );"}, {"sha": "34db30a1706b905b65832d9fff04e360af7e650f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1526,14 +1526,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // place (\"start at\" because the latter includes trailing\n             // whitespace), then this is an in-band lifetime\n             if decl_span.shrink_to_lo() == use_span.shrink_to_lo() {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     use_span,\n                     \"elide the single-use lifetime\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n             } else {\n-                err.multipart_suggestion_with_applicability(\n+                err.multipart_suggestion(\n                     \"elide the single-use lifetime\",\n                     vec![(decl_span, String::new()), (use_span, String::new())],\n                     Applicability::MachineApplicable,\n@@ -1644,7 +1644,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n                                 let unused_lt_span = self.lifetime_deletion_span(name, generics);\n                                 if let Some(span) = unused_lt_span {\n-                                    err.span_suggestion_with_applicability(\n+                                    err.span_suggestion(\n                                         span,\n                                         \"elide the unused lifetime\",\n                                         String::new(),\n@@ -2350,7 +2350,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } else {\n                     (format!(\"{} + 'static\", snippet), Applicability::MaybeIncorrect)\n                 };\n-                db.span_suggestion_with_applicability(span, msg, sugg, applicability);\n+                db.span_suggestion(span, msg, sugg, applicability);\n                 false\n             }\n             Err(_) => {"}, {"sha": "875021e20d42041b263aee13a82c474a519597ec", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -435,7 +435,7 @@ impl Session {\n                 }\n                 DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n                     let span = span_maybe.expect(\"span_suggestion_* needs a span\");\n-                    diag_builder.span_suggestion_with_applicability(\n+                    diag_builder.span_suggestion(\n                         span,\n                         message,\n                         suggestion,"}, {"sha": "5debb119029885dcf8a18cc8dc82f6304bbc32b6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -904,7 +904,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 expr.span,\n                                 \"consider borrowing here\",\n                                 format!(\"&{}\", snippet),\n@@ -952,7 +952,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let format_str = format!(\"consider removing {} leading `&`-references\",\n                                                  remove_refs);\n \n-                        err.span_suggestion_short_with_applicability(\n+                        err.span_suggestion_short(\n                             sp, &format_str, String::new(), Applicability::MachineApplicable\n                         );\n                         break;\n@@ -1109,7 +1109,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n             if found_args.is_empty() && is_closure {\n                 let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     pipe_span,\n                     &format!(\n                         \"consider changing the closure to take and ignore the expected argument{}\",\n@@ -1130,11 +1130,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         .map(|(name, _)| name.to_owned())\n                         .collect::<Vec<String>>()\n                         .join(\", \");\n-                    err.span_suggestion_with_applicability(found_span,\n-                                                           \"change the closure to take multiple \\\n-                                                            arguments instead of a single tuple\",\n-                                                           format!(\"|{}|\", sugg),\n-                                                           Applicability::MachineApplicable);\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n             }\n             if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n@@ -1162,12 +1163,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             String::new()\n                         },\n                     );\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         found_span,\n-                        \"change the closure to accept a tuple instead of \\\n-                         individual arguments\",\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n                         sugg,\n-                        Applicability::MachineApplicable\n+                        Applicability::MachineApplicable,\n                     );\n                 }\n             }"}, {"sha": "f444013e2a3bdca9b48f6afeb37373b56601b7d6", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 {\n                     if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n                         if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            db.span_suggestion_with_applicability(\n+                            db.span_suggestion(\n                                 sp,\n                                 \"use a float literal\",\n                                 format!(\"{}.0\", snippet),"}, {"sha": "00cbc250bd686cf19fe2235cd9fd321f68f5c455", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -70,7 +70,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n                 let initializer =\n                     e.init.as_ref().expect(\"should have an initializer to get an error\");\n                 if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         initializer.span,\n                         \"consider using a reference instead\",\n                         format!(\"&{}\", snippet),"}, {"sha": "5c11d622d0a8acb55e1e7c260870c97afece7d06", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -850,15 +850,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                         }) = cmt.cat {\n                                             db.note(fn_closure_msg);\n                                         } else {\n-                                            db.span_suggestion_with_applicability(\n+                                            db.span_suggestion(\n                                                 sp,\n                                                 msg,\n                                                 suggestion,\n                                                 Applicability::Unspecified,\n                                             );\n                                         }\n                                     } else {\n-                                        db.span_suggestion_with_applicability(\n+                                        db.span_suggestion(\n                                             sp,\n                                             msg,\n                                             suggestion,\n@@ -1229,7 +1229,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         let let_span = self.tcx.hir().span(node_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n-                            db.span_suggestion_with_applicability(\n+                            db.span_suggestion(\n                                 let_span,\n                                 \"use a mutable reference instead\",\n                                 replace_str,\n@@ -1291,15 +1291,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 )) = ty.map(|t| &t.node)\n                 {\n                     let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n-                    db.span_suggestion_with_applicability(\n+                    db.span_suggestion(\n                         self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    db.span_suggestion_with_applicability(\n+                    db.span_suggestion(\n                         let_span,\n                         \"make this binding mutable\",\n                         format!(\"mut {}\", snippet),\n@@ -1326,7 +1326,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                   &cmt_path_or_string,\n                                                   capture_span,\n                                                   Origin::Ast)\n-            .span_suggestion_with_applicability(\n+            .span_suggestion(\n                  err.span,\n                  &format!(\"to force the closure to take ownership of {} \\\n                            (and any other referenced variables), \\"}, {"sha": "5db98f0e223e484eba3a9198f7ac93cc9f28dd54", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -78,11 +78,12 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n                                      hir_id,\n                                      span,\n                                      \"variable does not need to be mutable\")\n-                .span_suggestion_short_with_applicability(\n+                .span_suggestion_short(\n                     mut_span,\n                     \"remove this `mut`\",\n                     String::new(),\n-                    Applicability::MachineApplicable)\n+                    Applicability::MachineApplicable,\n+                )\n                 .emit();\n         }\n     }"}, {"sha": "06a1761a1e76fb270163f8482437aa319dbdb0b3", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 26, "deletions": 88, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -229,59 +229,7 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Prints out a message with a suggested edit of the code. If the suggestion is presented\n-    /// inline it will only show the text message and not the text.\n-    ///\n-    /// See `CodeSuggestion` for more information.\n-    #[deprecated(note = \"Use `span_suggestion_short_with_applicability`\")]\n-    pub fn span_suggestion_short(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet: suggestion,\n-                    span: sp,\n-                }],\n-            }],\n-            msg: msg.to_owned(),\n-            show_code_when_inline: false,\n-            applicability: Applicability::Unspecified,\n-        });\n-        self\n-    }\n-\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// In case of short messages and a simple suggestion,\n-    /// rustc displays it as a label like\n-    ///\n-    /// \"try adding parentheses: `(tup.0).1`\"\n-    ///\n-    /// The message\n-    ///\n-    /// * should not end in any punctuation (a `:` is added automatically)\n-    /// * should not be a question\n-    /// * should not contain any parts like \"the following\", \"as shown\"\n-    /// * may look like \"to do xyz, use\" or \"to do xyz, use abc\"\n-    /// * may contain a name of a function, variable or type, but not whole expressions\n-    ///\n-    /// See `CodeSuggestion` for more information.\n-    #[deprecated(note = \"Use `span_suggestion_with_applicability`\")]\n-    pub fn span_suggestion(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet: suggestion,\n-                    span: sp,\n-                }],\n-            }],\n-            msg: msg.to_owned(),\n-            show_code_when_inline: true,\n-            applicability: Applicability::Unspecified,\n-        });\n-        self\n-    }\n-\n-    pub fn multipart_suggestion_with_applicability(\n+    pub fn multipart_suggestion(\n         &mut self,\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n@@ -301,39 +249,24 @@ impl Diagnostic {\n         self\n     }\n \n-    #[deprecated(note = \"Use `multipart_suggestion_with_applicability`\")]\n-    pub fn multipart_suggestion(\n-        &mut self,\n-        msg: &str,\n-        suggestion: Vec<(Span, String)>,\n-    ) -> &mut Self {\n-        self.multipart_suggestion_with_applicability(\n-            msg,\n-            suggestion,\n-            Applicability::Unspecified,\n-        )\n-    }\n-\n-    /// Prints out a message with multiple suggested edits of the code.\n-    #[deprecated(note = \"Use `span_suggestions_with_applicability`\")]\n-    pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: suggestions.into_iter().map(|snippet| Substitution {\n-                parts: vec![SubstitutionPart {\n-                    snippet,\n-                    span: sp,\n-                }],\n-            }).collect(),\n-            msg: msg.to_owned(),\n-            show_code_when_inline: true,\n-            applicability: Applicability::Unspecified,\n-        });\n-        self\n-    }\n-\n-    /// This is a suggestion that may contain mistakes or fillers and should\n-    /// be read and understood by a human.\n-    pub fn span_suggestion_with_applicability(&mut self, sp: Span, msg: &str,\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// In case of short messages and a simple suggestion, rustc displays it as a label:\n+    ///\n+    /// ```text\n+    /// try adding parentheses: `(tup.0).1`\n+    /// ```\n+    ///\n+    /// The message\n+    ///\n+    /// * should not end in any punctuation (a `:` is added automatically)\n+    /// * should not be a question (avoid language like \"did you mean\")\n+    /// * should not contain any phrases like \"the following\", \"as shown\", etc.\n+    /// * may look like \"to do xyz, use\" or \"to do xyz, use abc\"\n+    /// * may contain a name of a function, variable, or type, but not whole expressions\n+    ///\n+    /// See `CodeSuggestion` for more information.\n+    pub fn span_suggestion(&mut self, sp: Span, msg: &str,\n                                        suggestion: String,\n                                        applicability: Applicability) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n@@ -350,7 +283,8 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn span_suggestions_with_applicability(&mut self, sp: Span, msg: &str,\n+    /// Prints out a message with multiple suggested edits of the code.\n+    pub fn span_suggestions(&mut self, sp: Span, msg: &str,\n         suggestions: impl Iterator<Item = String>, applicability: Applicability) -> &mut Self\n     {\n         self.suggestions.push(CodeSuggestion {\n@@ -367,7 +301,11 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn span_suggestion_short_with_applicability(\n+    /// Prints out a message with a suggested edit of the code. If the suggestion is presented\n+    /// inline, it will only show the message and not the suggestion.\n+    ///\n+    /// See `CodeSuggestion` for more information.\n+    pub fn span_suggestion_short(\n         &mut self, sp: Span, msg: &str, suggestion: String, applicability: Applicability\n     ) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {"}, {"sha": "f423a4cd1a7bfcd3a1a419152c3a09a2ef67f39e", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 31, "deletions": 68, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -39,7 +39,6 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n-            #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n             self\n         }\n@@ -52,7 +51,6 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n-            #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n             self\n         }\n@@ -70,7 +68,6 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n-            #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n             self\n         }\n@@ -190,70 +187,34 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                   msg: &str,\n                                                   ) -> &mut Self);\n \n-    forward!(\n-        #[deprecated(note = \"Use `span_suggestion_short_with_applicability`\")]\n-        pub fn span_suggestion_short(\n-            &mut self,\n-            sp: Span,\n-            msg: &str,\n-            suggestion: String,\n-        ) -> &mut Self\n-    );\n-\n-    forward!(\n-        #[deprecated(note = \"Use `multipart_suggestion_with_applicability`\")]\n-        pub fn multipart_suggestion(\n-            &mut self,\n-            msg: &str,\n-            suggestion: Vec<(Span, String)>,\n-        ) -> &mut Self\n-    );\n-\n-    forward!(\n-        #[deprecated(note = \"Use `span_suggestion_with_applicability`\")]\n-        pub fn span_suggestion(\n-            &mut self,\n-            sp: Span,\n-            msg: &str,\n-            suggestion: String,\n-        ) -> &mut Self\n-    );\n-\n-    forward!(\n-        #[deprecated(note = \"Use `span_suggestions_with_applicability`\")]\n-        pub fn span_suggestions(&mut self,\n-            sp: Span,\n-            msg: &str,\n-            suggestions: Vec<String>,\n-        ) -> &mut Self\n-    );\n-\n-    pub fn multipart_suggestion_with_applicability(&mut self,\n-                                              msg: &str,\n-                                              suggestion: Vec<(Span, String)>,\n-                                              applicability: Applicability,\n-                                              ) -> &mut Self {\n+    pub fn multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n         if !self.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.multipart_suggestion_with_applicability(\n+        self.diagnostic.multipart_suggestion(\n             msg,\n             suggestion,\n             applicability,\n         );\n         self\n     }\n \n-    pub fn span_suggestion_with_applicability(&mut self,\n-                                              sp: Span,\n-                                              msg: &str,\n-                                              suggestion: String,\n-                                              applicability: Applicability)\n-                                              -> &mut Self {\n+    pub fn span_suggestion(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n         if !self.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_with_applicability(\n+        self.diagnostic.span_suggestion(\n             sp,\n             msg,\n             suggestion,\n@@ -262,16 +223,17 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n-    pub fn span_suggestions_with_applicability(&mut self,\n-                                               sp: Span,\n-                                               msg: &str,\n-                                               suggestions: impl Iterator<Item = String>,\n-                                               applicability: Applicability)\n-                                               -> &mut Self {\n+    pub fn span_suggestions(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestions: impl Iterator<Item = String>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n         if !self.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestions_with_applicability(\n+        self.diagnostic.span_suggestions(\n             sp,\n             msg,\n             suggestions,\n@@ -280,16 +242,17 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n-    pub fn span_suggestion_short_with_applicability(&mut self,\n-                                                    sp: Span,\n-                                                    msg: &str,\n-                                                    suggestion: String,\n-                                                    applicability: Applicability)\n-                                                    -> &mut Self {\n+    pub fn span_suggestion_short(\n+        &mut self,\n+        sp: Span,\n+        msg: &str,\n+        suggestion: String,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n         if !self.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_short_with_applicability(\n+        self.diagnostic.span_suggestion_short(\n             sp,\n             msg,\n             suggestion,"}, {"sha": "46e784c4099c8c87b4383dfe3b10b8c71e40a2c9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.tcx.sess.source_map().def_span(e.span);\n                         let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);\n-                        err.span_suggestion_short_with_applicability(\n+                        err.span_suggestion_short(\n                             condition_span,\n                             \"use `loop`\",\n                             \"loop\".to_owned(),\n@@ -199,7 +199,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n                         let subspan = cx.tcx.sess.source_map().span_through_char(fieldpat.span,\n                                                                                  ':');\n-                        err.span_suggestion_short_with_applicability(\n+                        err.span_suggestion_short(\n                             subspan,\n                             \"remove this\",\n                             ident.to_string(),\n@@ -704,7 +704,7 @@ impl EarlyLintPass for AnonymousParameters {\n                                     arg.pat.span,\n                                     \"anonymous parameters are deprecated and will be \\\n                                      removed in the next edition.\"\n-                                ).span_suggestion_with_applicability(\n+                                ).span_suggestion(\n                                     arg.pat.span,\n                                     \"Try naming the parameter or explicitly \\\n                                     ignoring it\",\n@@ -759,7 +759,7 @@ impl EarlyLintPass for DeprecatedAttr {\n                     let msg = format!(\"use of deprecated attribute `{}`: {}. See {}\",\n                                       name, reason, link);\n                     let mut err = cx.struct_span_lint(DEPRECATED, attr.span, &msg);\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         attr.span,\n                         suggestion.unwrap_or(\"remove this attribute\"),\n                         String::new(),\n@@ -906,7 +906,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                                                                   it.span,\n                                                                   \"functions generic over \\\n                                                                    types must be mangled\");\n-                                err.span_suggestion_short_with_applicability(\n+                                err.span_suggestion_short(\n                                     no_mangle_attr.span,\n                                     \"remove this attribute\",\n                                     String::new(),\n@@ -934,7 +934,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         .unwrap_or(0) as u32;\n                     // `const` is 5 chars\n                     let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         const_span,\n                         \"try a static value\",\n                         \"pub static\".to_owned(),\n@@ -1116,10 +1116,12 @@ impl UnreachablePub {\n                     \"pub(crate)\"\n                 }.to_owned();\n \n-                err.span_suggestion_with_applicability(vis.span,\n-                                                       \"consider restricting its visibility\",\n-                                                       replacement,\n-                                                       applicability);\n+                err.span_suggestion(\n+                    vis.span,\n+                    \"consider restricting its visibility\",\n+                    replacement,\n+                    applicability,\n+                );\n                 if exportable {\n                     err.help(\"or consider exporting it for use by other crates\");\n                 }\n@@ -1452,7 +1454,7 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             if parenthesise {\n                 *visit_subpats = false;\n                 let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg);\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     pat.span,\n                     suggestion,\n                     format!(\"&({}..={})\", expr_to_string(&start), expr_to_string(&end)),\n@@ -1461,7 +1463,7 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                 err.emit();\n             } else {\n                 let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg);\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     join,\n                     suggestion,\n                     \"..=\".to_owned(),\n@@ -1613,7 +1615,7 @@ impl EarlyLintPass for KeywordIdents {\n                         E0721,\n                         \"`await` is a keyword in the {} edition\", cur_edition,\n                     );\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         ident.span,\n                         \"you can use a raw identifier to stay compatible\",\n                         \"r#await\".to_string(),\n@@ -1637,7 +1639,7 @@ impl EarlyLintPass for KeywordIdents {\n                      ident.as_str(),\n                      next_edition),\n         );\n-        lint.span_suggestion_with_applicability(\n+        lint.span_suggestion(\n             ident.span,\n             \"you can use a raw identifier to stay compatible\",\n             format!(\"r#{}\", ident.as_str()),\n@@ -1865,7 +1867,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                     lint_spans.clone(),\n                     \"outlives requirements can be inferred\"\n                 );\n-                err.multipart_suggestion_with_applicability(\n+                err.multipart_suggestion(\n                     if bound_count == 1 {\n                         \"remove this bound\"\n                     } else {"}, {"sha": "bbf0edc6efb758c42c75e4b46068737d79d24b33", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -93,7 +93,7 @@ impl NonCamelCaseTypes {\n \n             let msg = format!(\"{} `{}` should have a camel case name\", sort, name);\n             cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, &msg)\n-                .span_suggestion_with_applicability(\n+                .span_suggestion(\n                     ident.span,\n                     \"convert the identifier to camel case\",\n                     c,\n@@ -223,7 +223,7 @@ impl NonSnakeCase {\n             // We have a valid span in almost all cases, but we don't have one when linting a crate\n             // name provided via the command line.\n             if !ident.span.is_dummy() {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     ident.span,\n                     \"convert the identifier to snake case\",\n                     sc,\n@@ -377,7 +377,7 @@ impl NonUpperCaseGlobals {\n \n             let msg = format!(\"{} `{}` should have an upper case name\", sort, name);\n             cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, &msg)\n-                .span_suggestion_with_applicability(\n+                .span_suggestion(\n                     ident.span,\n                     \"convert the identifier to upper case\",\n                     uc,"}, {"sha": "4abd55b7e31f7d3cda737e4f41e935f08cd7e373", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              OVERFLOWING_LITERALS,\n                                                              parent_expr.span,\n                                                              \"only u8 can be cast into char\");\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             parent_expr.span,\n                                             &\"use a char literal instead\",\n                                             format!(\"'\\\\u{{{:X}}}'\", lit_val),\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             {\n                 if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                     let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         expr.span,\n                         &format!(\"consider using `{}` instead\", sugg_ty),\n                         format!(\"{}{}\", sans_suffix, sugg_ty),"}, {"sha": "acf5da1e1886aa8820e241b78e0a1e7d86718808", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -366,12 +366,12 @@ impl UnusedParens {\n                     _ => false,\n                 }\n             }).to_owned();\n-        err.span_suggestion_short_with_applicability(\n-                span,\n-                \"remove these parentheses\",\n-                parens_removed,\n-                Applicability::MachineApplicable\n-            );\n+        err.span_suggestion_short(\n+            span,\n+            \"remove these parentheses\",\n+            parens_removed,\n+            Applicability::MachineApplicable,\n+        );\n         err.emit();\n     }\n }"}, {"sha": "b070031756798b228a9e42198035cab53c4238bf", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1139,7 +1139,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Err(_) => \"move |<args>| <body>\".to_string()\n         };\n \n-        err.span_suggestion_with_applicability(\n+        err.span_suggestion(\n             args_span,\n             &format!(\"to force the closure to take ownership of {} (and any \\\n                       other referenced variables), use the `move` keyword\",\n@@ -1428,7 +1428,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(decl) = local_decl {\n             if let Some(name) = decl.name {\n                 if decl.can_be_made_mutable() {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         decl.source_info.span,\n                         \"make this binding mutable\",\n                         format!(\"mut {}\", name),"}, {"sha": "5597e4a6c597e587531e28f82c2843e5b96bb57c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -307,7 +307,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n                 span,\n                 \"variable does not need to be mutable\",\n             )\n-            .span_suggestion_short_with_applicability(\n+            .span_suggestion_short(\n                 mut_span,\n                 \"remove this `mut`\",\n                 String::new(),"}, {"sha": "8539b5c26cee88e5f8a8f4b3b3de187e430eb94a", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -368,14 +368,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     // expressions `a[b]`, which roughly desugar to\n                     // `*Index::index(&a, b)` or\n                     // `*IndexMut::index_mut(&mut a, b)`.\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"consider removing the `*`\",\n                         snippet[1..].to_owned(),\n                         Applicability::Unspecified,\n                     );\n                 } else {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"consider borrowing here\",\n                         format!(\"&{}\", snippet),\n@@ -439,7 +439,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         suggestions.sort_unstable_by_key(|&(span, _, _)| span);\n         suggestions.dedup_by_key(|&mut (span, _, _)| span);\n         for (span, to_remove, suggestion) in suggestions {\n-            err.span_suggestion_with_applicability(\n+            err.span_suggestion(\n                 span,\n                 &format!(\"consider removing the `{}`\", to_remove),\n                 suggestion,"}, {"sha": "4755c6daf0a773b41b37bdbd9034584fc51695f5", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx),\n                     field,\n                 ) {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"consider changing this to be mutable\",\n                         message,\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     local_decl.source_info.span,\n                     \"consider changing this to be mutable\",\n                     format!(\"mut {}\", local_decl.name.unwrap()),\n@@ -316,7 +316,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         _,\n                     ) = pat.node\n                     {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             upvar_ident.span,\n                             \"consider changing this to be mutable\",\n                             format!(\"mut {}\", upvar_ident.name),\n@@ -410,7 +410,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 if let Some((err_help_span, suggested_code)) = suggestion {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         err_help_span,\n                         &format!(\"consider changing this to be a mutable {}\", pointer_desc),\n                         suggested_code,"}, {"sha": "f07880075c100c79ddf5cbfde287f2e3825e57b5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -626,7 +626,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             \"'_\".to_string()\n                         };\n \n-                        diag.span_suggestion_with_applicability(\n+                        diag.span_suggestion(\n                             span,\n                             &format!(\n                                 \"to allow this impl Trait to capture borrowed data with lifetime \\"}, {"sha": "10a4575d8122066ac1e6fb3045c9e3b342a9a839", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -313,7 +313,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n                             \"pattern binding `{}` is named the same as one \\\n                             of the variants of the type `{}`\",\n                             ident, ty_path);\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             p.span,\n                             \"to match on the variant, qualify the path\",\n                             format!(\"{}::{}\", ty_path, ident),"}, {"sha": "3b6328f320f78c96468b272fe63f0ac510e97366", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -237,7 +237,7 @@ impl<'a> AstValidator<'a> {\n             );\n \n             if let Ok(snippet) = self.session.source_map().span_to_snippet(span) {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     span, \"consider adding parentheses\", format!(\"({})\", snippet),\n                     Applicability::MachineApplicable,\n                 );\n@@ -290,7 +290,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 );\n                 match val.node {\n                     ExprKind::Lit(ref v) if v.node.is_numeric() => {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             place.span.between(val.span),\n                             \"if you meant to write a comparison against a negative value, add a \\\n                              space in between `<` and `-`\","}, {"sha": "0dcfc72d10bc053c6c98d447d8a658187d252aaa", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                                 .span_label(e.span,\n                                             \"can only break with a value inside \\\n                                             `loop` or breakable block\")\n-                                .span_suggestion_with_applicability(\n+                                .span_suggestion(\n                                     e.span,\n                                     &format!(\n                                         \"instead, use `break` on its own \\"}, {"sha": "3752d953f8afa8bd3e2cbc83e9da6bdba3e3ab44", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -347,7 +347,7 @@ impl<'a> Resolver<'a> {\n                 let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n-                        .span_suggestion_with_applicability(\n+                        .span_suggestion(\n                             item.span,\n                             \"try\",\n                             \"extern crate self as name;\".into(),"}, {"sha": "55d5cdedd6ddd7156f561f3b4da31666746e3981", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -247,7 +247,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             let sugg_msg = \"try using a local type parameter instead\";\n             if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n                 // Suggest the modification to the user\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     sugg_span,\n                     sugg_msg,\n                     new_snippet,\n@@ -3175,7 +3175,7 @@ impl<'a> Resolver<'a> {\n             // Emit help message for fake-self from other languages like `this`(javascript)\n             if [\"this\", \"my\"].contains(&&*item_str.as_str())\n                 && this.self_value_is_available(path[0].ident.span, span) {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     span,\n                     \"did you mean\",\n                     \"self\".to_string(),\n@@ -3239,7 +3239,7 @@ impl<'a> Resolver<'a> {\n                     };\n                     let msg = format!(\"{}try using the variant's enum\", preamble);\n \n-                    err.span_suggestions_with_applicability(\n+                    err.span_suggestions(\n                         span,\n                         &msg,\n                         enum_candidates.into_iter()\n@@ -3262,7 +3262,7 @@ impl<'a> Resolver<'a> {\n                     let self_is_available = this.self_value_is_available(path[0].ident.span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span,\n                                 \"try\",\n                                 format!(\"self.{}\", path_str),\n@@ -3275,15 +3275,15 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                         AssocSuggestion::MethodWithSelf if self_is_available => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span,\n                                 \"try\",\n                                 format!(\"self.{}\", path_str),\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n                         AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span,\n                                 \"try\",\n                                 format!(\"Self::{}\", path_str),\n@@ -3304,7 +3304,7 @@ impl<'a> Resolver<'a> {\n                     \"{} {} with a similar name exists\",\n                     suggestion.article, suggestion.kind\n                 );\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     ident_span,\n                     &msg,\n                     suggestion.candidate.to_string(),\n@@ -3318,7 +3318,7 @@ impl<'a> Resolver<'a> {\n             if let Some(def) = def {\n                 match (def, source) {\n                     (Def::Macro(..), _) => {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             span,\n                             \"use `!` to invoke the macro\",\n                             format!(\"{}!\", path_str),\n@@ -3335,7 +3335,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 parent.span,\n                                 \"use the path separator to refer to an item\",\n                                 format!(\"{}::{}\", path_str, ident),\n@@ -3345,7 +3345,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         ExprKind::MethodCall(ref segment, ..) => {\n                             let span = parent.span.with_hi(segment.ident.span.hi());\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span,\n                                 \"use the path separator to refer to an item\",\n                                 format!(\"{}::{}\", path_str, segment.ident),\n@@ -3428,7 +3428,7 @@ impl<'a> Resolver<'a> {\n                                 PathSource::Expr(Some(parent)) => {\n                                     match parent.node {\n                                         ExprKind::MethodCall(ref path_assignment, _)  => {\n-                                            err.span_suggestion_with_applicability(\n+                                            err.span_suggestion(\n                                                 sm.start_point(parent.span)\n                                                   .to(path_assignment.ident.span),\n                                                 \"use `::` to access an associated function\",\n@@ -3451,7 +3451,7 @@ impl<'a> Resolver<'a> {\n                                 },\n                                 PathSource::Expr(None) if followed_by_brace == true => {\n                                     if let Some((sp, snippet)) = closing_brace {\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             sp,\n                                             \"surround the struct literal with parenthesis\",\n                                             format!(\"({})\", snippet),\n@@ -3589,7 +3589,7 @@ impl<'a> Resolver<'a> {\n                         err.span_label(base_span,\n                                        \"expecting a type here because of type ascription\");\n                         if line_sp != line_base_sp {\n-                            err.span_suggestion_short_with_applicability(\n+                            err.span_suggestion_short(\n                                 sp,\n                                 \"did you mean to use `;` here instead?\",\n                                 \";\".to_string(),\n@@ -4866,7 +4866,7 @@ impl<'a> Resolver<'a> {\n                 } else if ident.span.rust_2018() {\n                     let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n                     self.session.struct_span_err(ident.span, msg)\n-                        .span_suggestion_with_applicability(\n+                        .span_suggestion(\n                             path.span,\n                             \"try\",\n                             format!(\"crate::{}\", path),\n@@ -5179,7 +5179,7 @@ impl<'a> Resolver<'a> {\n \n             let rename_msg = \"you can use `as` to change the binding name of the import\";\n             if let Some(suggestion) = suggestion {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     binding_span,\n                     rename_msg,\n                     suggestion,\n@@ -5302,7 +5302,7 @@ fn show_candidates(err: &mut DiagnosticBuilder,\n             *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n         }\n \n-        err.span_suggestions_with_applicability(\n+        err.span_suggestions(\n             span,\n             &msg,\n             path_strings.into_iter(),"}, {"sha": "fb5b6c97689d0d391e6470d86697cfb9c6846793", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1021,14 +1021,14 @@ impl<'a> Resolver<'a> {\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"you could try the macro\",\n                         suggestion.to_string(),\n                         Applicability::MaybeIncorrect\n                     );\n                 } else {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"try\",\n                         suggestion.to_string(),"}, {"sha": "61674070fbcb23930ea95ebfc7b2f41961350e14", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1096,7 +1096,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             if !suggestions.is_empty() {\n                 let msg = format!(\"if you meant to specify the associated {}, write\",\n                     if suggestions.len() == 1 { \"type\" } else { \"types\" });\n-                err.multipart_suggestion_with_applicability(\n+                err.multipart_suggestion(\n                     &msg,\n                     suggestions,\n                     Applicability::MaybeIncorrect,\n@@ -1172,7 +1172,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                         trait_str: &str,\n                                         name: &str) {\n         struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\")\n-            .span_suggestion_with_applicability(\n+            .span_suggestion(\n                 span,\n                 \"use fully-qualified syntax\",\n                 format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n@@ -1353,7 +1353,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                         &assoc_ident.as_str(),\n                         None,\n                     ) {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             span,\n                             \"did you mean\",\n                             format!(\"{}::{}\", qself_ty, suggested_name),\n@@ -1407,7 +1407,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             could_refer_to(variant_def, \"\");\n             could_refer_to(def, \" also\");\n \n-            err.span_suggestion_with_applicability(\n+            err.span_suggestion(\n                 span,\n                 \"use fully-qualified syntax\",\n                 format!(\"<{} as {}>::{}\", qself_ty, \"Trait\", assoc_ident),"}, {"sha": "141b8222b1f33807a4e55b373569656f88564651", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -990,7 +990,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     let suggested_name =\n                         find_best_match_for_name(input, &ident.as_str(), None);\n                     if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             *span,\n                             \"did you mean\",\n                             suggested_name.to_string(),"}, {"sha": "0afc1697d316ec54638ea32976ab139cbc8ba598", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     );\n \n                     if let Some(ref path) = unit_variant {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             call_expr.span,\n                             &format!(\n                                 \"`{}` is a unit variant, you need to write it \\\n@@ -294,7 +294,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.tcx.sess.source_map().is_multiline(call_expr.span);\n                             if call_is_multiline {\n                                 let span = self.tcx.sess.source_map().next_point(callee.span);\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     span,\n                                     \"try adding a semicolon\",\n                                     \";\".to_owned(),"}, {"sha": "85cae17fd85244a1baa8ba0905cc5d7ecc340696", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                        fcx.ty_to_string(self.expr_ty),\n                                        cast_ty));\n                 if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         self.expr.span,\n                         \"dereference the expression\",\n                         format!(\"*{}\", snippet),\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 if self.expr_ty.is_numeric() {\n                     match fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n                         Ok(snippet) => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 self.span,\n                                 \"compare with zero instead\",\n                                 format!(\"{} != 0\", snippet),\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 err.note(\"The type information given here is insufficient to check whether \\\n                           the pointer cast is valid\");\n                 if unknown_cast_to {\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         self.cast_span,\n                         \"consider giving more type information\",\n                         String::new(),\n@@ -345,7 +345,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 if self.cast_ty.is_trait() {\n                     match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 self.cast_span,\n                                 \"try casting to a reference instead\",\n                                 format!(\"&{}{}\", mtstr, s),\n@@ -367,7 +367,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             ty::Adt(def, ..) if def.is_box() => {\n                 match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             self.cast_span,\n                             \"try casting to a `Box` instead\",\n                             format!(\"Box<{}>\", s),"}, {"sha": "0eb8d7d06b1f68a072c32496e3ee1a6e03001b11", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -316,7 +316,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if let Some(trait_err_span) = trait_err_span {\n                     if let Ok(trait_err_str) = tcx.sess.source_map()\n                                                        .span_to_snippet(trait_err_span) {\n-                        diag.span_suggestion_with_applicability(\n+                        diag.span_suggestion(\n                             impl_err_span,\n                             \"consider change the type to match the mutability in trait\",\n                             trait_err_str,\n@@ -784,7 +784,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             .span_to_snippet(trait_m.generics.span)\n                             .ok()?;\n \n-                        err.multipart_suggestion_with_applicability(\n+                        err.multipart_suggestion(\n                             \"try changing the `impl Trait` argument to a generic parameter\",\n                             vec![\n                                 // replace `impl Trait` with `T`\n@@ -855,7 +855,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             .span_to_snippet(bounds)\n                             .ok()?;\n \n-                        err.multipart_suggestion_with_applicability(\n+                        err.multipart_suggestion(\n                             \"try removing the generic parameter and using `impl Trait` instead\",\n                             vec![\n                                 // delete generic parameters"}, {"sha": "0d4690c83170ace3b1f8892226b673fe1a2b70d7", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n                     let suggestions = compatible_variants\n                         .map(|v| format!(\"{}({})\", v, expr_text));\n-                    err.span_suggestions_with_applicability(\n+                    err.span_suggestions(\n                         expr.span,\n                         \"try using a variant of the expected type\",\n                         suggestions,\n@@ -558,7 +558,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if needs_paren { \")\" } else { \"\" },\n                 );\n \n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     expr.span,\n                     &suggest_msg,\n                     if literal_is_ty_suffixed(expr) {\n@@ -575,7 +575,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_truncate),\n                                     cast_suggestion,\n@@ -585,7 +585,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_isize),\n                                     cast_suggestion,\n@@ -606,7 +606,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_truncate),\n                                     cast_suggestion,\n@@ -616,7 +616,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_usize),\n                                     cast_suggestion,\n@@ -637,39 +637,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found > exp - 1 => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_truncate),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_truncate),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_isize),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_usize),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             _ => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_zero_extend),\n                                     cast_suggestion,\n@@ -684,39 +684,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found - 1 > exp => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_truncate),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_sign_extend),\n                                     cast_suggestion,\n                                     Applicability::MachineApplicable  // lossy conversion\n                                 );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_usize),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, depending_on_isize),\n                                     cast_suggestion,\n                                     Applicability::MaybeIncorrect  // lossy conversion\n                                 );\n                             }\n                             _ => {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     expr.span,\n                                     &format!(\"{}, which {}\", msg, will_sign_extend),\n                                     cast_suggestion,\n@@ -734,7 +734,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            None,\n                        );\n                     } else if can_cast {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"{}, producing the closest possible value\", msg),\n                             cast_suggestion,\n@@ -745,7 +745,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 (&ty::Uint(_), &ty::Float(_)) | (&ty::Int(_), &ty::Float(_)) => {\n                     if can_cast {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"{}, rounding the float towards zero\", msg),\n                             cast_suggestion,\n@@ -760,7 +760,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n                     // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n@@ -769,7 +769,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             Applicability::MachineApplicable\n                         );\n                     } else if can_cast {\n-                        err.span_suggestion_with_applicability(expr.span,\n+                        err.span_suggestion(\n+                            expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\",\n                                      msg),\n@@ -782,7 +783,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::Float(ref exp), &ty::Int(ref found)) => {\n                     // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n@@ -791,7 +792,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             Applicability::MachineApplicable\n                         );\n                     } else if can_cast {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\","}, {"sha": "b7d015729b42dab984b17c9f808ac1b3d6f783cd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (format!(\"{}()\", method_name), Applicability::MaybeIncorrect)\n         };\n \n-        err.span_suggestion_with_applicability(method_name.span, msg, suggestion, applicability);\n+        err.span_suggestion(method_name.span, msg, suggestion, applicability);\n     }\n \n     /// Performs method lookup. If lookup is successful, it will return the callee"}, {"sha": "623677482db34300c855531b7f53ea88aa69ab7a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -1144,7 +1144,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             \"a method with this name may be added to the standard library in the future\",\n         );\n \n-        // FIXME: This should be a `span_suggestion_with_applicability` instead of `help`\n+        // FIXME: This should be a `span_suggestion` instead of `help`\n         // However `self.span` only\n         // highlights the method name, so we can't use it. Also consider reusing the code from\n         // `report_method_error()`."}, {"sha": "55b6e8f099ea96e53b76a11548ff4d87ecb1dfa6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -237,15 +237,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n \n-                                err.span_suggestion_with_applicability(\n-                                                    lit.span,\n-                                                    &format!(\"you must specify a concrete type for \\\n-                                                              this numeric value, like `{}`\",\n-                                                             concrete_type),\n-                                                    format!(\"{}_{}\",\n-                                                            snippet,\n-                                                            concrete_type),\n-                                                    Applicability::MaybeIncorrect,\n+                                err.span_suggestion(\n+                                    lit.span,\n+                                    &format!(\"you must specify a concrete type for \\\n+                                              this numeric value, like `{}`\", concrete_type),\n+                                    format!(\"{}_{}\", snippet, concrete_type),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                             ExprKind::Path(ref qpath) => {\n@@ -271,7 +268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 ty,\n                                                 ..\n                                             })) => {\n-                                                err.span_suggestion_with_applicability(\n+                                                err.span_suggestion(\n                                                     // account for `let x: _ = 42;`\n                                                     //                  ^^^^\n                                                     span.to(ty.as_ref().map(|ty| ty.span)\n@@ -304,7 +301,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         );\n                         if let Some(suggestion) = suggestion {\n                             // enum variant\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 item_name.span,\n                                 \"did you mean\",\n                                 suggestion.to_string(),\n@@ -404,7 +401,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 if static_sources.len() == 1 {\n                     if let SelfSource::MethodCall(expr) = source {\n-                        err.span_suggestion_with_applicability(expr.span.to(span),\n+                        err.span_suggestion(expr.span.to(span),\n                                             \"use associated function syntax instead\",\n                                             format!(\"{}::{}\",\n                                                     self.ty_to_string(actual),\n@@ -445,7 +442,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"did you mean\",\n                         lev_candidate.ident.to_string(),\n@@ -522,12 +519,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 )\n             });\n \n-            err.span_suggestions_with_applicability(\n-                                                    span,\n-                                                    &msg,\n-                                                    path_strings,\n-                                                    Applicability::MaybeIncorrect,\n-            );\n+            err.span_suggestions(span, &msg, path_strings, Applicability::MaybeIncorrect);\n         } else {\n             let limit = if candidates.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {"}, {"sha": "c94713980d8c06e3a97ed6e46c5934a64d845efa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -2903,7 +2903,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let sugg_span = tcx.sess.source_map().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     sugg_span,\n                     \"expected the unit value `()`; create it with empty parentheses\",\n                     String::from(\"()\"),\n@@ -3170,7 +3170,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.tcx.sess.source_map().span_to_snippet(lhs.span),\n                     self.tcx.sess.source_map().span_to_snippet(rhs.span))\n                 {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         expr.span,\n                         msg,\n                         format!(\"{} == {}\", left, right),\n@@ -3587,7 +3587,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(suggested_field_name) =\n                             Self::suggest_field_name(def.non_enum_variant(),\n                                                      &field.as_str(), vec![]) {\n-                                err.span_suggestion_with_applicability(\n+                                err.span_suggestion(\n                                     field.span,\n                                     \"a field with a similar name exists\",\n                                     suggested_field_name.to_string(),\n@@ -3618,7 +3618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             } else {\n                                 Applicability::MaybeIncorrect\n                             };\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 expr.span, help, suggestion, applicability\n                             );\n                         }\n@@ -3629,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n                         let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &msg,\n                             suggestion,\n@@ -3719,12 +3719,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(field_name) = Self::suggest_field_name(variant,\n                                                            &field.ident.as_str(),\n                                                            skip_fields.collect()) {\n-            err.span_suggestion_with_applicability(\n-                    field.ident.span,\n-                    \"a field with a similar name exists\",\n-                    field_name.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+            err.span_suggestion(\n+                field.ident.span,\n+                \"a field with a similar name exists\",\n+                field_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n         } else {\n             match ty.sty {\n                 ty::Adt(adt, ..) => {\n@@ -4670,11 +4670,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.source_map().span_to_snippet(base.span);\n                                         if let Ok(snip) = snip {\n-                                            err.span_suggestion_with_applicability(\n+                                            err.span_suggestion(\n                                                 expr.span,\n                                                 \"to access tuple elements, use\",\n                                                 format!(\"{}.{}\", snip, i),\n-                                                Applicability::MachineApplicable);\n+                                                Applicability::MachineApplicable,\n+                                            );\n                                             needs_note = false;\n                                         }\n                                     }\n@@ -5106,7 +5107,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         found: Ty<'tcx>,\n     ) {\n         if let Some((sp, msg, suggestion)) = self.check_ref(expr, found, expected) {\n-            err.span_suggestion_with_applicability(\n+            err.span_suggestion(\n                 sp,\n                 msg,\n                 suggestion,\n@@ -5133,7 +5134,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }).peekable();\n                 if suggestions.peek().is_some() {\n-                    err.span_suggestions_with_applicability(\n+                    err.span_suggestions(\n                         expr.span,\n                         \"try using a conversion method\",\n                         suggestions,\n@@ -5172,7 +5173,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ExprKind::Match(..) |\n                 ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.source_map().next_point(cause_span);\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         sp,\n                         \"try adding a semicolon\",\n                         \";\".to_string(),\n@@ -5206,7 +5207,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n             (&hir::FunctionRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     span,\n                     \"try adding a return type\",\n                     format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n@@ -5260,7 +5261,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder,\n     ) {\n         if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n-            err.span_suggestion_with_applicability(\n+            err.span_suggestion(\n                 span_semi,\n                 \"consider removing this semicolon\",\n                 String::new(),\n@@ -5436,7 +5437,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 },\n                                 AdtKind::Struct |\n                                 AdtKind::Union => {\n-                                    err.span_suggestion_with_applicability(\n+                                    err.span_suggestion(\n                                         span,\n                                         \"use curly brackets\",\n                                         String::from(\"Self { /* fields */ }\"),"}, {"sha": "5efa9f08404d91fa38203c0cf569a1c734d0bed2", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             rty,\n                                             lstring,\n                                         );\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             lhs_expr.span,\n                                             msg,\n                                             format!(\"*{}\", lstring),\n@@ -434,7 +434,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_label(expr.span,\n                                    \"`+` can't be used to concatenate two `&str` strings\");\n                     match source_map.span_to_snippet(lhs_expr.span) {\n-                        Ok(lstring) => err.span_suggestion_with_applicability(\n+                        Ok(lstring) => err.span_suggestion(\n                             lhs_expr.span,\n                             msg,\n                             format!(\"{}.to_owned()\", lstring),\n@@ -455,7 +455,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), false) => {\n-                        err.multipart_suggestion_with_applicability(\n+                        err.multipart_suggestion(\n                             msg,\n                             vec![\n                                 (lhs_expr.span, format!(\"{}.to_owned()\", l)),"}, {"sha": "a7e19fc4237ccf00474b79dd4fb0f86ce29952e9", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -136,7 +136,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n                     .fold(span, |acc, attr_span| acc.to(attr_span));\n \n                 tcx.struct_span_lint_node(lint, id, span, msg)\n-                    .span_suggestion_short_with_applicability(\n+                    .span_suggestion_short(\n                         span_with_attrs,\n                         \"remove it\",\n                         String::new(),\n@@ -178,7 +178,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n         };\n         let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_node(lint, id, extern_crate.span, msg)\n-            .span_suggestion_short_with_applicability(\n+            .span_suggestion_short(\n                 extern_crate.span,\n                 &help,\n                 replacement,"}, {"sha": "f75ab47e1ab70d14599d6f4653f9c10ecddb9205", "filename": "src/librustc_typeck/structured_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustc_typeck%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fstructured_errors.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> StructuredDiagnostic<'tcx> for VariadicError<'tcx> {\n             )\n         };\n         if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n-            err.span_suggestion_with_applicability(\n+            err.span_suggestion(\n                 self.span,\n                 &format!(\"cast the value to `{}`\", self.cast_ty),\n                 format!(\"{} as {}\", snippet, self.cast_ty),"}, {"sha": "8ccd55c17d060d19e69665eb7dff39173b333843", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx, 'rcx> SyntaxChecker<'a, 'tcx, 'rcx> {\n \n                 if code_block.syntax.is_none() && code_block.is_fenced {\n                     let sp = sp.from_inner_byte_pos(0, 3);\n-                    diag.span_suggestion_with_applicability(\n+                    diag.span_suggestion(\n                         sp,\n                         \"mark blocks that do not contain Rust code as text\",\n                         String::from(\"```text\"),"}, {"sha": "08c7c617a7bef15725226ef9272e7d5afc164ad9", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -42,7 +42,7 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n             let mut err = struct_span_err!(diag, span, E0565, \"{}\", msg);\n             if is_bytestr {\n                 if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"consider removing the prefix\",\n                         format!(\"{}\", &lint_str[1..]),\n@@ -794,15 +794,15 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                                     \"incorrect `repr(align)` attribute format\");\n                                 match value.node {\n                                     ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             item.span,\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", int),\n                                             Applicability::MachineApplicable\n                                         );\n                                     }\n                                     ast::LitKind::Str(s, _) => {\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             item.span,\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", s),"}, {"sha": "2930ce079c848a58a58dc31da9686164e185f949", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -155,7 +155,7 @@ impl<'a> StripUnconfigured<'a> {\n             let error = |span, msg, suggestion: &str| {\n                 let mut err = self.sess.span_diagnostic.struct_span_err(span, msg);\n                 if !suggestion.is_empty() {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"expected syntax is\",\n                         suggestion.into(),"}, {"sha": "d1f7b4df9bea42bbecfa63dc5d1f944f444e2809", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -361,7 +361,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             let trait_list = traits.iter()\n                                 .map(|t| t.to_string()).collect::<Vec<_>>();\n                             let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 span, \"try an outer attribute\", suggestion,\n                                 // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n                                 Applicability::MaybeIncorrect\n@@ -1043,7 +1043,7 @@ impl<'a> Parser<'a> {\n             let semi_full_span = semi_span.to(self.sess.source_map().next_point(semi_span));\n             match self.sess.source_map().span_to_snippet(semi_full_span) {\n                 Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         semi_span,\n                         \"you might be missing a semicolon here\",\n                         \";\".to_owned(),\n@@ -1574,7 +1574,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         _ => (String::from(\"<path>\"), Applicability::HasPlaceholders),\n                     };\n \n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         it.span,\n                         \"provide a file path with `=`\",\n                         format!(\"include = \\\"{}\\\"\", path),"}, {"sha": "176575b67ea92f1530a1b301deaa645b73bdbcfb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -221,7 +221,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n                     } else {\n-                        err.span_suggestion_short_with_applicability(\n+                        err.span_suggestion_short(\n                             comma_span,\n                             \"missing comma here\",\n                             \", \".to_string(),"}, {"sha": "06f9162a400f66f3794e4c18f56ba4eb1998bb0a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -949,7 +949,7 @@ impl<'a> StringReader<'a> {\n                                     }\n                                     if i != 0 {\n                                         suggestion.push('}');\n-                                        err.span_suggestion_with_applicability(\n+                                        err.span_suggestion(\n                                             self.mk_sp(start, self.pos),\n                                             \"format of unicode escape sequences uses braces\",\n                                             suggestion,\n@@ -1427,7 +1427,7 @@ impl<'a> StringReader<'a> {\n                             self.sess.span_diagnostic\n                                 .struct_span_err(span,\n                                                  \"character literal may only contain one codepoint\")\n-                                .span_suggestion_with_applicability(\n+                                .span_suggestion(\n                                     span,\n                                     \"if you meant to write a `str` literal, use double quotes\",\n                                     format!(\"\\\"{}\\\"\", &self.src[start..end]),"}, {"sha": "7da4284c0e4aac4c33ad8bedbcd4a809d0db14b9", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -336,7 +336,7 @@ crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n                 let msg =\n                     format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n                             ch, u_name, ascii_char, ascii_name);\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     span,\n                     &msg,\n                     ascii_char.to_string(),"}, {"sha": "65572102c5981f11b93369fc7da9043b9fb62682", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -736,15 +736,15 @@ impl<'a> Parser<'a> {\n             };\n             let mut err = self.fatal(&msg_exp);\n             if self.token.is_ident_named(\"and\") {\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     self.span,\n                     \"use `&&` instead of `and` for the boolean operator\",\n                     \"&&\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n             if self.token.is_ident_named(\"or\") {\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     self.span,\n                     \"use `||` instead of `or` for the boolean operator\",\n                     \"||\".to_string(),\n@@ -810,7 +810,7 @@ impl<'a> Parser<'a> {\n             if ident.is_reserved() && !ident.is_path_segment_keyword() &&\n                 ident.name != keywords::Underscore.name()\n             {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     self.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n                     format!(\"r#{}\", ident),\n@@ -823,7 +823,7 @@ impl<'a> Parser<'a> {\n         } else {\n             err.span_label(self.span, \"expected identifier\");\n             if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     self.span,\n                     \"remove this comma\",\n                     String::new(),\n@@ -1696,7 +1696,7 @@ impl<'a> Parser<'a> {\n         if !allow_plus && impl_dyn_multi {\n             let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n             self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n-                .span_suggestion_with_applicability(\n+                .span_suggestion(\n                     ty.span,\n                     \"use parentheses to disambiguate\",\n                     sum_with_parens,\n@@ -1731,7 +1731,7 @@ impl<'a> Parser<'a> {\n                     s.print_type_bounds(\" +\", &bounds)?;\n                     s.pclose()\n                 });\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     sum_span,\n                     \"try adding parentheses\",\n                     sum_with_parens,\n@@ -1774,7 +1774,7 @@ impl<'a> Parser<'a> {\n \n         self.diagnostic()\n             .struct_span_err(span, \"missing angle brackets in associated item path\")\n-            .span_suggestion_with_applicability( // this is a best-effort recovery\n+            .span_suggestion( // this is a best-effort recovery\n                 span, \"try\", recovered.to_string(), Applicability::MaybeIncorrect\n             ).emit();\n \n@@ -1878,15 +1878,15 @@ impl<'a> Parser<'a> {\n                     let ident = self.parse_ident().unwrap();\n                     let span = pat.span.with_hi(ident.span.hi());\n \n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         span,\n                         \"declare the type after the parameter binding\",\n                         String::from(\"<identifier>: <type>\"),\n                         Applicability::HasPlaceholders,\n                     );\n                 } else if require_name && is_trait_item {\n                     if let PatKind::Ident(_, ident, _) = pat.node {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             pat.span,\n                             \"explicitly ignore parameter\",\n                             format!(\"_: {}\", ident),\n@@ -1937,7 +1937,7 @@ impl<'a> Parser<'a> {\n                         \"patterns aren't allowed in methods without bodies\",\n                         DiagnosticId::Error(\"E0642\".into()),\n                     );\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         pat.span,\n                         \"give this argument a name or use an underscore to ignore it\",\n                         \"_\".to_owned(),\n@@ -2034,7 +2034,7 @@ impl<'a> Parser<'a> {\n                     let sp = lo.to(self.prev_span);\n                     let mut err = self.diagnostic()\n                         .struct_span_err(sp, \"float literals must have an integer part\");\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         sp,\n                         \"must have an integer part\",\n                         format!(\"0.{}{}\", val, suffix),\n@@ -2365,7 +2365,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::Eq {\n                 self.diagnostic()\n                     .struct_span_err(self.span, \"expected `:`, found `=`\")\n-                    .span_suggestion_with_applicability(\n+                    .span_suggestion(\n                         fieldname.span.shrink_to_hi().to(self.span),\n                         \"replace equals symbol with a colon\",\n                         \":\".to_string(),\n@@ -2751,7 +2751,7 @@ impl<'a> Parser<'a> {\n                         exp_span.to(self.prev_span),\n                         \"cannot use a comma after the base struct\",\n                     );\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         self.span,\n                         \"remove this comma\",\n                         String::new(),\n@@ -3019,7 +3019,7 @@ impl<'a> Parser<'a> {\n                     span,\n                     &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n                 )\n-                .span_suggestion_with_applicability(\n+                .span_suggestion(\n                     span,\n                     &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n                     String::new(),\n@@ -3072,7 +3072,7 @@ impl<'a> Parser<'a> {\n                             s.s.word(\".\")?;\n                             s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n                         });\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             lo.to(self.prev_span),\n                             \"try parenthesizing the first index\",\n                             sugg,\n@@ -3219,7 +3219,7 @@ impl<'a> Parser<'a> {\n                 let span_of_tilde = lo;\n                 let mut err = self.diagnostic()\n                     .struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\");\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     span_of_tilde,\n                     \"use `!` to perform bitwise negation\",\n                     \"!\".to_owned(),\n@@ -3292,7 +3292,7 @@ impl<'a> Parser<'a> {\n                     // trailing whitespace after the `!` in our suggestion\n                     let to_replace = self.sess.source_map()\n                         .span_until_non_whitespace(lo.to(self.span));\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         to_replace,\n                         \"use `!` to perform logical negation\",\n                         \"!\".to_owned(),\n@@ -3393,7 +3393,7 @@ impl<'a> Parser<'a> {\n                         let cur_pos = cm.lookup_char_pos(self.span.lo());\n                         let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n                         if cur_pos.line != op_pos.line {\n-                            err.span_suggestion_with_applicability(\n+                            err.span_suggestion(\n                                 cur_op_span,\n                                 \"try using a semicolon\",\n                                 \";\".to_string(),\n@@ -3552,7 +3552,7 @@ impl<'a> Parser<'a> {\n \n                         let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n                                                 .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             expr.span,\n                             &format!(\"try {} the cast value\", op_verb),\n                             format!(\"({})\", expr_str),\n@@ -3768,7 +3768,7 @@ impl<'a> Parser<'a> {\n             let in_span = self.prev_span.between(self.span);\n             let mut err = self.sess.span_diagnostic\n                 .struct_span_err(in_span, \"missing `in` in `for` loop\");\n-            err.span_suggestion_short_with_applicability(\n+            err.span_suggestion_short(\n                 in_span, \"try adding `in` here\", \" in \".into(),\n                 // has been misleading, at least in the past (closed Issue #48492)\n                 Applicability::MaybeIncorrect\n@@ -3782,7 +3782,7 @@ impl<'a> Parser<'a> {\n                 self.prev_span,\n                 \"expected iterable, found keyword `in`\",\n             );\n-            err.span_suggestion_short_with_applicability(\n+            err.span_suggestion_short(\n                 in_span.until(self.prev_span),\n                 \"remove the duplicated `in`\",\n                 String::new(),\n@@ -3874,7 +3874,7 @@ impl<'a> Parser<'a> {\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n-                e.span_suggestion_short_with_applicability(\n+                e.span_suggestion_short(\n                     match_span,\n                     \"try removing this `match`\",\n                     String::new(),\n@@ -3949,7 +3949,7 @@ impl<'a> Parser<'a> {\n                             //   |      - ^^ self.span\n                             //   |      |\n                             //   |      parsed until here as `\"y\" & X`\n-                            err.span_suggestion_short_with_applicability(\n+                            err.span_suggestion_short(\n                                 cm.next_point(arm_start_span),\n                                 \"missing a comma here to end this `match` arm\",\n                                 \",\".to_owned(),\n@@ -4026,7 +4026,7 @@ impl<'a> Parser<'a> {\n             if self.token == token::OrOr {\n                 let mut err = self.struct_span_err(self.span,\n                                                    \"unexpected token `||` after pattern\");\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     self.span,\n                     \"use a single `|` to specify multiple patterns\",\n                     \"|\".to_owned(),\n@@ -4234,7 +4234,7 @@ impl<'a> Parser<'a> {\n                     // Accept `...` as if it were `..` to avoid further errors\n                     let mut err = self.struct_span_err(self.span,\n                                                        \"expected field pattern, found `...`\");\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         self.span,\n                         \"to omit remaining fields, use one fewer `.`\",\n                         \"..\".to_owned(),\n@@ -4266,7 +4266,7 @@ impl<'a> Parser<'a> {\n                 if self.token == token::CloseDelim(token::Brace) {\n                     // If the struct looks otherwise well formed, recover and continue.\n                     if let Some(sp) = comma_sp {\n-                        err.span_suggestion_short_with_applicability(\n+                        err.span_suggestion_short(\n                             sp,\n                             \"remove this comma\",\n                             String::new(),\n@@ -4308,7 +4308,7 @@ impl<'a> Parser<'a> {\n \n         if let Some(mut err) = delayed_err {\n             if let Some(etc_span) = etc_span {\n-                err.multipart_suggestion_with_applicability(\n+                err.multipart_suggestion(\n                     \"move the `..` to the end of the field list\",\n                     vec![\n                         (etc_span, String::new()),\n@@ -4379,7 +4379,7 @@ impl<'a> Parser<'a> {\n             let mut err = self.struct_span_err(comma_span,\n                                                \"unexpected `,` in pattern\");\n             if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     seq_span,\n                     \"try adding parentheses\",\n                     format!(\"({})\", seq_snippet),\n@@ -4447,7 +4447,7 @@ impl<'a> Parser<'a> {\n                 let binding_mode = if self.eat_keyword(keywords::Ref) {\n                     self.diagnostic()\n                         .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion_with_applicability(\n+                        .span_suggestion(\n                             mutref_span,\n                             \"try switching the order\",\n                             \"ref mut\".into(),\n@@ -4591,7 +4591,7 @@ impl<'a> Parser<'a> {\n                         pat.span,\n                         \"the range pattern here has ambiguous interpretation\",\n                     );\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         pat.span,\n                         \"add parentheses to clarify the precedence\",\n                         format!(\"({})\", pprust::pat_to_string(&pat)),\n@@ -4667,7 +4667,7 @@ impl<'a> Parser<'a> {\n             (Ok(init), Some((_, colon_sp, mut err))) => {  // init parsed, ty error\n                 // Could parse the type as if it were the initializer, it is likely there was a\n                 // typo in the code: `:` instead of `=`. Add suggestion and emit the error.\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     colon_sp,\n                     \"use `=` if you meant to assign\",\n                     \"=\".to_string(),\n@@ -5170,15 +5170,15 @@ impl<'a> Parser<'a> {\n                 self.token.is_keyword(keywords::In) || self.token == token::Colon;\n \n             if self.token.is_ident_named(\"and\") {\n-                e.span_suggestion_short_with_applicability(\n+                e.span_suggestion_short(\n                     self.span,\n                     \"use `&&` instead of `and` for the boolean operator\",\n                     \"&&\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n             if self.token.is_ident_named(\"or\") {\n-                e.span_suggestion_short_with_applicability(\n+                e.span_suggestion_short(\n                     self.span,\n                     \"use `||` instead of `or` for the boolean operator\",\n                     \"||\".to_string(),\n@@ -5213,7 +5213,7 @@ impl<'a> Parser<'a> {\n                         s.print_stmt(&stmt)?;\n                         s.bclose_maybe_open(stmt.span, INDENT_UNIT, false)\n                     });\n-                    e.span_suggestion_with_applicability(\n+                    e.span_suggestion(\n                         stmt_span,\n                         \"try placing this code inside a block\",\n                         sugg,\n@@ -5331,10 +5331,10 @@ impl<'a> Parser<'a> {\n     fn err_dotdotdot_syntax(&self, span: Span) {\n         self.diagnostic().struct_span_err(span, {\n             \"unexpected token: `...`\"\n-        }).span_suggestion_with_applicability(\n+        }).span_suggestion(\n             span, \"use `..` for an exclusive range\", \"..\".to_owned(),\n             Applicability::MaybeIncorrect\n-        ).span_suggestion_with_applicability(\n+        ).span_suggestion(\n             span, \"or `..=` for an inclusive range\", \"..=\".to_owned(),\n             Applicability::MaybeIncorrect\n         ).emit();\n@@ -5534,7 +5534,7 @@ impl<'a> Parser<'a> {\n                 \"lifetime parameters must be declared prior to type parameters\",\n             );\n             if !suggestions.is_empty() {\n-                err.multipart_suggestion_with_applicability(\n+                err.multipart_suggestion(\n                     \"move the lifetime parameter prior to the first type parameter\",\n                     suggestions,\n                     Applicability::MachineApplicable,\n@@ -5702,7 +5702,7 @@ impl<'a> Parser<'a> {\n                             if plural { \"s\" } else { \"\" }\n                         ),\n                     )\n-                    .span_suggestion_with_applicability(\n+                    .span_suggestion(\n                         span,\n                         &format!(\n                             \"remove extra angle bracket{}\",\n@@ -5863,7 +5863,7 @@ impl<'a> Parser<'a> {\n             suggestions.extend_from_slice(&type_suggestions);\n \n             let plural = bad_lifetime_pos.len() + bad_type_pos.len() > 1;\n-            err.multipart_suggestion_with_applicability(\n+            err.multipart_suggestion(\n                 &format!(\n                     \"move the parameter{}\",\n                     if plural { \"s\" } else { \"\" },\n@@ -5872,7 +5872,7 @@ impl<'a> Parser<'a> {\n                 Applicability::MachineApplicable,\n             );\n         } else if !lifetime_suggestions.is_empty() {\n-            err.multipart_suggestion_with_applicability(\n+            err.multipart_suggestion(\n                 &format!(\n                     \"move the lifetime parameter{} prior to the first type parameter\",\n                     if bad_lifetime_pos.len() > 1 { \"s\" } else { \"\" },\n@@ -5881,7 +5881,7 @@ impl<'a> Parser<'a> {\n                 Applicability::MachineApplicable,\n             );\n         } else if !type_suggestions.is_empty() {\n-            err.multipart_suggestion_with_applicability(\n+            err.multipart_suggestion(\n                 &format!(\n                     \"move the type parameter{} prior to the first associated type binding\",\n                     if bad_type_pos.len() > 1 { \"s\" } else { \"\" },\n@@ -6385,7 +6385,7 @@ impl<'a> Parser<'a> {\n                 let mut err = if is_macro_rules {\n                     let mut err = self.diagnostic()\n                         .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         sp,\n                         \"try exporting the macro\",\n                         \"#[macro_export]\".to_owned(),\n@@ -6593,7 +6593,7 @@ impl<'a> Parser<'a> {\n                 // impl Trait for Type\n                 if !has_for {\n                     self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n-                        .span_suggestion_short_with_applicability(\n+                        .span_suggestion_short(\n                             missing_for_span,\n                             \"add `for` here\",\n                             \" for \".to_string(),\n@@ -6817,7 +6817,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     if seen_comma == false {\n                         let sp = self.sess.source_map().next_point(previous_span);\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             sp,\n                             \"missing comma here\",\n                             \",\".into(),\n@@ -6833,7 +6833,7 @@ impl<'a> Parser<'a> {\n                                                                 self.this_token_descr()));\n                 if self.token.is_ident() {\n                     // This is likely another field; emit the diagnostic and keep going\n-                    err.span_suggestion_with_applicability(\n+                    err.span_suggestion(\n                         sp,\n                         \"try adding a comma\",\n                         \",\".into(),\n@@ -6931,7 +6931,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n                 let mut err = struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg);\n                 err.help(suggestion);\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     sp, &help_msg, format!(\"in {}\", path), Applicability::MachineApplicable\n                 );\n                 err.emit();  // emit diagnostic, but continue with public visibility\n@@ -6962,7 +6962,7 @@ impl<'a> Parser<'a> {\n     fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n         if self.eat(&token::Semi) {\n             let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n-            err.span_suggestion_short_with_applicability(\n+            err.span_suggestion_short(\n                 self.prev_span,\n                 \"remove this semicolon\",\n                 String::new(),\n@@ -7390,7 +7390,7 @@ impl<'a> Parser<'a> {\n \n             let mut err = self.struct_span_err(fixed_name_sp, error_msg);\n             err.span_label(fixed_name_sp, \"dash-separated idents are not valid\");\n-            err.multipart_suggestion_with_applicability(\n+            err.multipart_suggestion(\n                 suggestion_msg,\n                 replacement,\n                 Applicability::MachineApplicable,\n@@ -7759,7 +7759,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.diagnostic()\n                     .struct_span_err(prev_span, \"const globals cannot be mutable\");\n                 err.span_label(prev_span, \"cannot be mutable\");\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     const_span,\n                     \"you might want to declare a static instead\",\n                     \"static\".to_owned(),\n@@ -7996,7 +7996,7 @@ impl<'a> Parser<'a> {\n                                   ident);\n                 let mut err = self.diagnostic()\n                     .struct_span_err(sp, \"missing `struct` for struct definition\");\n-                err.span_suggestion_short_with_applicability(\n+                err.span_suggestion_short(\n                     sp, &msg, \" struct \".into(), Applicability::MaybeIncorrect // speculative\n                 );\n                 return Err(err);\n@@ -8031,12 +8031,12 @@ impl<'a> Parser<'a> {\n                                              kw,\n                                              ident,\n                                              kw_name);\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n                     );\n                 } else {\n                     if let Ok(snippet) = self.sess.source_map().span_to_snippet(ident_sp) {\n-                        err.span_suggestion_with_applicability(\n+                        err.span_suggestion(\n                             full_sp,\n                             \"if you meant to call a macro, try\",\n                             format!(\"{}!\", snippet),\n@@ -8067,7 +8067,7 @@ impl<'a> Parser<'a> {\n                 let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n                 let mut err = self.diagnostic().struct_span_err(sp, &msg);\n                 if !ambiguous {\n-                    err.span_suggestion_short_with_applicability(\n+                    err.span_suggestion_short(\n                         sp,\n                         &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n                         format!(\" {} \", kw),\n@@ -8094,7 +8094,7 @@ impl<'a> Parser<'a> {\n             if self.token.is_keyword(keywords::Const) {\n                 self.diagnostic()\n                     .struct_span_err(self.span, \"extern items cannot be `const`\")\n-                    .span_suggestion_with_applicability(\n+                    .span_suggestion(\n                         self.span,\n                         \"try using a static value\",\n                         \"static\".to_owned(),"}, {"sha": "4c473fe7612af4acf7bfecd5e4f4e2f9cb736b77", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0897ffc28f68fab862e970599c95bb65b280b48b/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=0897ffc28f68fab862e970599c95bb65b280b48b", "patch": "@@ -763,7 +763,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                     0 => \"{}\".to_string(),\n                     _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n                 };\n-                err.span_suggestion_with_applicability(\n+                err.span_suggestion(\n                     fmt_sp.shrink_to_lo(),\n                     \"you might be missing a string literal to format with\",\n                     format!(\"\\\"{}\\\", \", sugg_fmt),\n@@ -1080,7 +1080,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                         ));\n                     }\n                     if suggestions.len() > 0 {\n-                        diag.multipart_suggestion_with_applicability(\n+                        diag.multipart_suggestion(\n                             \"format specifiers use curly braces\",\n                             suggestions,\n                             Applicability::MachineApplicable,"}]}