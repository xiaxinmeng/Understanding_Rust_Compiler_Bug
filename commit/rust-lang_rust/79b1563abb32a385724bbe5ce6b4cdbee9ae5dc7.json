{"sha": "79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YjE1NjNhYmIzMmEzODU3MjRiYmU1Y2U2YjRjZGJlZTlhZTVkYzc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-09T09:13:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-10T03:00:16Z"}, "message": "rt: Use rust_task_thread's C-stack pool for native calls", "tree": {"sha": "baa648a32c783bc950299bc9d8e33201132366ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baa648a32c783bc950299bc9d8e33201132366ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "html_url": "https://github.com/rust-lang/rust/commit/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfb80064d2dd37bd1e7009d98aa585253f5a2812", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb80064d2dd37bd1e7009d98aa585253f5a2812", "html_url": "https://github.com/rust-lang/rust/commit/bfb80064d2dd37bd1e7009d98aa585253f5a2812"}], "stats": {"total": 124, "additions": 96, "deletions": 28}, "files": [{"sha": "ae65cdb581354d987309f3b8b5c18099a59316a3", "filename": "src/rt/arch/i386/context.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Farch%2Fi386%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Farch%2Fi386%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.h?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -29,8 +29,6 @@ struct registers_t {\n   uint32_t eip;\n } __attribute__((aligned(16)));\n \n-extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n-\n class context {\n public:\n   registers_t regs;\n@@ -41,10 +39,6 @@ class context {\n \n   void swap(context &out);\n   void call(void *f, void *arg, void *sp);\n-\n-  void call_and_change_stacks(void *args, void *fn_ptr) {\n-      __morestack(args, fn_ptr, regs.esp);\n-  }\n };\n \n #endif"}, {"sha": "412d968599f5bafa9673d87db0e3d04cdd76797c", "filename": "src/rt/arch/x86_64/context.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.h?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -28,8 +28,6 @@ struct registers_t {\n     uint64_t data[RUSTRT_MAX];\n } __attribute__((aligned(16)));\n \n-extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n-\n class context {\n public:\n     registers_t regs;\n@@ -40,10 +38,6 @@ class context {\n     \n     void swap(context &out);\n     void call(void *f, void *arg, void *sp);\n-\n-    void call_and_change_stacks(void *args, void *fn_ptr) {\n-        __morestack(args, fn_ptr, regs.data[RUSTRT_RSP]);\n-    }\n };\n \n #endif"}, {"sha": "a025800e4ae10c86d78bd817ef851a88a904e4c6", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -88,7 +88,9 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n     propagate_failure(true),\n     dynastack(this),\n     cc_counter(0),\n-    total_stack_sz(0)\n+    total_stack_sz(0),\n+    c_stack(NULL),\n+    next_c_sp(0)\n {\n     LOGPTR(thread, \"new task\", (uintptr_t)this);\n     DLOG(thread, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n@@ -166,7 +168,6 @@ cleanup_task(cleanup_args *args) {\n }\n \n // This runs on the Rust stack\n-extern \"C\" CDECL\n void task_start_wrapper(spawn_args *a)\n {\n     rust_task *task = a->task;\n@@ -180,8 +181,15 @@ void task_start_wrapper(spawn_args *a)\n         A(task->thread, ex == task,\n           \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n+\n+        if (task->c_stack) {\n+            task->return_c_stack();\n+        }\n     }\n \n+    // We should have returned any C stack by now\n+    I(task->thread, task->c_stack == NULL);\n+\n     rust_opaque_box* env = a->envptr;\n     if(env) {\n         // free the environment (which should be a unique closure).\n@@ -722,10 +730,35 @@ rust_task::config_notify(chan_handle chan) {\n     notify_chan = chan;\n }\n \n+extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n+\n void\n rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n     I(thread, on_rust_stack());\n-    thread->c_context.call_and_change_stacks(args, fn_ptr);\n+\n+    bool borrowed_a_c_stack = false;\n+    if (c_stack == NULL) {\n+        c_stack = thread->borrow_c_stack();\n+        next_c_sp = align_down(c_stack->end);\n+        borrowed_a_c_stack = true;\n+    }\n+\n+    __morestack(args, fn_ptr, next_c_sp);\n+\n+    // Note that we may not actually get here if we threw an exception,\n+    // in which case we will return the c stack when the exception is caught.\n+    if (borrowed_a_c_stack) {\n+        return_c_stack();\n+    }\n+}\n+\n+void\n+rust_task::return_c_stack() {\n+    I(thread, on_rust_stack());\n+    I(thread, c_stack != NULL);\n+    thread->return_c_stack(c_stack);\n+    c_stack = NULL;\n+    next_c_sp = 0;\n }\n \n //"}, {"sha": "5ac2d7a212ead91d8982406cbc0b29feeaf5eef0", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -36,6 +36,8 @@ typedef unsigned long task_result;\n #define tr_success 0\n #define tr_failure 1\n \n+struct spawn_args;\n+\n // std::lib::task::task_notification\n //\n // since it's currently a unary tag, we only add the fields.\n@@ -104,6 +106,11 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     size_t total_stack_sz;\n \n private:\n+\n+    // The stack used for running C code, borrowed from the scheduler thread\n+    stk_seg *c_stack;\n+    uintptr_t next_c_sp;\n+\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n@@ -112,6 +119,10 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void free_stack(stk_seg *stk);\n     size_t get_next_stack_size(size_t min, size_t current, size_t requested);\n \n+    void return_c_stack();\n+\n+    friend void task_start_wrapper(spawn_args *a);\n+\n public:\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task."}, {"sha": "48bd7f16bdf98f8c317eb754c5fd66bb7f919ecd", "filename": "src/rt/rust_task_thread.cpp", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -61,18 +61,16 @@ rust_task_thread::~rust_task_thread() {\n #ifndef __WIN32__\n     pthread_attr_destroy(&attr);\n #endif\n-\n-    if (cached_c_stack) {\n-        destroy_stack(kernel, cached_c_stack);\n-    }\n }\n \n void\n rust_task_thread::activate(rust_task *task) {\n     task->ctx.next = &c_context;\n     DLOG(this, task, \"descheduling...\");\n     lock.unlock();\n+    prepare_c_stack();\n     task->ctx.swap(c_context);\n+    unprepare_c_stack();\n     lock.lock();\n     DLOG(this, task, \"task has returned\");\n }\n@@ -287,6 +285,13 @@ rust_task_thread::start_main_loop() {\n     DLOG(this, dom, \"finished main-loop %d\", id);\n \n     lock.unlock();\n+\n+    I(this, !extra_c_stack);\n+    if (cached_c_stack) {\n+        unconfig_valgrind_stack(cached_c_stack);\n+        destroy_stack(kernel, cached_c_stack);\n+        cached_c_stack = NULL;\n+    }\n }\n \n rust_crate_cache *\n@@ -374,24 +379,51 @@ rust_task_thread::exit() {\n     lock.signal();\n }\n \n+// Before activating each task, make sure we have a C stack available.\n+// It needs to be allocated ahead of time (while we're on our own\n+// stack), because once we're on the Rust stack we won't have enough\n+// room to do the allocation\n+void\n+rust_task_thread::prepare_c_stack() {\n+    I(this, !extra_c_stack);\n+    if (!cached_c_stack) {\n+        cached_c_stack = create_stack(kernel, C_STACK_SIZE);\n+    }\n+}\n+\n+void\n+rust_task_thread::unprepare_c_stack() {\n+    if (extra_c_stack) {\n+        destroy_stack(kernel, extra_c_stack);\n+        extra_c_stack = NULL;\n+    }\n+}\n+\n+// NB: Runs on the Rust stack\n stk_seg *\n rust_task_thread::borrow_c_stack() {\n-\n-    if (cached_c_stack) {\n-        stk_seg *your_stack = cached_c_stack;\n-        cached_c_stack = NULL;\n-        return your_stack;\n+    I(this, cached_c_stack);\n+    stk_seg *your_stack;\n+    if (extra_c_stack) {\n+        your_stack = extra_c_stack;\n+        extra_c_stack = NULL;\n     } else {\n-        return create_stack(kernel, C_STACK_SIZE);\n+        your_stack = cached_c_stack;\n+        cached_c_stack = NULL;\n     }\n+    config_valgrind_stack(your_stack);\n+    return your_stack;\n }\n \n+// NB: Runs on the Rust stack\n void\n rust_task_thread::return_c_stack(stk_seg *stack) {\n-    if (cached_c_stack) {\n-        destroy_stack(kernel, stack);\n-    } else {\n+    I(this, !extra_c_stack);\n+    unconfig_valgrind_stack(stack);\n+    if (!cached_c_stack) {\n         cached_c_stack = stack;\n+    } else {\n+        extra_c_stack = stack;\n     }\n }\n "}, {"sha": "82609bc887a4d4dd321709104b285016d4485e9f", "filename": "src/rt/rust_task_thread.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7/src%2Frt%2Frust_task_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.h?ref=79b1563abb32a385724bbe5ce6b4cdbee9ae5dc7", "patch": "@@ -95,6 +95,10 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n private:\n \n     stk_seg *cached_c_stack;\n+    stk_seg *extra_c_stack;\n+\n+    void prepare_c_stack();\n+    void unprepare_c_stack();\n \n public:\n "}]}