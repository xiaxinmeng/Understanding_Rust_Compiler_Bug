{"sha": "6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNmZmYjRjNzY0MjdhNWMzZmY0ODcwYWE4ZmI1YWQzYWViN2Q3MGQ=", "commit": {"author": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2013-06-14T22:37:29Z"}, "committer": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2013-06-16T18:02:52Z"}, "message": "Do not strip leading whitespace when parsing doc comments.\n\nThis change prevents the indentation in code blocks inside the /// doc comments\nfrom being eaten. The indentation that is the same across the consecutive doc\ncomments is removed by the uindent_pass in librustdoc.", "tree": {"sha": "66aa084c3389d72c6a509d18347fb8f6d9567ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66aa084c3389d72c6a509d18347fb8f6d9567ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "html_url": "https://github.com/rust-lang/rust/commit/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d/comments", "author": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "html_url": "https://github.com/rust-lang/rust/commit/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8"}], "stats": {"total": 92, "additions": 67, "deletions": 25}, "files": [{"sha": "1abdae113c597bb751e95e2df1dd5488191f0dd3", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -152,6 +152,6 @@ mod test {\n     fn should_concatenate_multiple_doc_comments() {\n         let source = @\"/// foo\\n/// bar\";\n         let desc = parse_desc(parse_attributes(source));\n-        assert!(desc == Some(~\"foo\\nbar\"));\n+        assert!(desc == Some(~\" foo\\n bar\"));\n     }\n }"}, {"sha": "472f807cd8b682a6b8f0241a73d07039d23f4358", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=6a6ffb4c76427a5c3ff4870aa8fb5ad3aeb7d70d", "patch": "@@ -69,50 +69,59 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         return lines.slice(i, j).to_owned();\n     }\n \n-    // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: ~[~str], chars: ~str, max: Option<uint>) -> ~[~str] {\n-\n-        let mut i = max.get_or_default(uint::max_value);\n-        for lines.each |line| {\n-            if line.trim().is_empty() {\n-                loop;\n-            }\n+    /// remove a \"[ \\t]*\\*\" block from each line, if possible\n+    fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n+        let mut i = uint::max_value;\n+        let mut can_trim = true;\n+        let mut first = true;\n+        for lines.iter().advance |line| {\n             for line.iter().enumerate().advance |(j, c)| {\n-                if j >= i {\n+                if j > i || !\"* \\t\".contains_char(c) {\n+                    can_trim = false;\n                     break;\n                 }\n-                if !chars.contains_char(c) {\n-                    i = j;\n+                if c == '*' {\n+                    if first {\n+                        i = j;\n+                        first = false;\n+                    } else if i != j {\n+                        can_trim = false;\n+                    }\n                     break;\n                 }\n             }\n+            if i > line.len() {\n+                can_trim = false;\n+            }\n+            if !can_trim {\n+                break;\n+            }\n         }\n \n-        return do lines.map |line| {\n-            let chars = line.iter().collect::<~[char]>();\n-            if i > chars.len() {\n-                ~\"\"\n-            } else {\n-                str::from_chars(chars.slice(i, chars.len()))\n+        if can_trim {\n+            do lines.map |line| {\n+                line.slice(i + 1, line.len()).to_owned()\n             }\n-        };\n+        } else {\n+            lines\n+        }\n     }\n \n     if comment.starts_with(\"//\") {\n         // FIXME #5475:\n-        // return comment.slice(3u, comment.len()).trim().to_owned();\n-        let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n+        // return comment.slice(3u, comment.len()).to_owned();\n+        let r = comment.slice(3u, comment.len()); return r.to_owned();\n     }\n \n     if comment.starts_with(\"/*\") {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .any_line_iter()\n             .transform(|s| s.to_owned())\n             .collect::<~[~str]>();\n+\n         let lines = vertical_trim(lines);\n-        let lines = block_trim(lines, ~\"\\t \", None);\n-        let lines = block_trim(lines, ~\"*\", Some(1u));\n-        let lines = block_trim(lines, ~\"\\t \", None);\n+        let lines = horizontal_trim(lines);\n+\n         return lines.connect(\"\\n\");\n     }\n \n@@ -370,3 +379,36 @@ pub fn gather_comments_and_literals(span_diagnostic:\n \n     (comments, literals)\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test] fn test_block_doc_comment_1() {\n+        let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n+        let correct_stripped = \" Test \\n*  Test\\n   Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_2() {\n+        let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n+        let correct_stripped = \" Test\\n  Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_block_doc_comment_3() {\n+        let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n+        let correct_stripped = \" let a: *int;\\n *a = 5;\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+\n+    #[test] fn test_line_doc_comment() {\n+        let comment = \"/// Test\";\n+        let correct_stripped = \" Test\";\n+        let stripped = strip_doc_comment_decoration(comment);\n+        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+    }\n+}"}]}