{"sha": "2592b20347ad49b99dd1eda58260e73ac553ed83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1OTJiMjAzNDdhZDQ5Yjk5ZGQxZWRhNTgyNjBlNzNhYzU1M2VkODM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-23T17:27:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "without all those copies of constants, we can finally make eval_operand take &self", "tree": {"sha": "7bb2710ef89b50d766b64a09169ef8582c8d8ba9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bb2710ef89b50d766b64a09169ef8582c8d8ba9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2592b20347ad49b99dd1eda58260e73ac553ed83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2592b20347ad49b99dd1eda58260e73ac553ed83", "html_url": "https://github.com/rust-lang/rust/commit/2592b20347ad49b99dd1eda58260e73ac553ed83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2592b20347ad49b99dd1eda58260e73ac553ed83/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c141ccf158d8c660ef20a51104b701b4eb37822b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c141ccf158d8c660ef20a51104b701b4eb37822b", "html_url": "https://github.com/rust-lang/rust/commit/c141ccf158d8c660ef20a51104b701b4eb37822b"}], "stats": {"total": 112, "additions": 53, "deletions": 59}, "files": [{"sha": "1e45215238c3f7563a1d2fe8bf773907e8d4c40c", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2592b20347ad49b99dd1eda58260e73ac553ed83", "patch": "@@ -427,12 +427,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     // avoid allocations.  If you already know the layout, you can pass it in\n     // to avoid looking it up again.\n     fn eval_place_to_op(\n-        &mut self,\n+        &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx>> {\n         use rustc::mir::Place::*;\n-        Ok(match *mir_place {\n+        let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n             Local(local) => {\n                 let op = *self.frame().locals[local].access()?;\n@@ -446,21 +446,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.operand_projection(op, &proj.elem)?\n             }\n \n-            // Everything else is an mplace, so we just call `eval_place`.\n-            // Note that getting an mplace for a static aways requires `&mut`,\n-            // so this does not \"cost\" us anything in terms if mutability.\n-            Promoted(_) | Static(_) => {\n-                let place = self.eval_place(mir_place)?;\n-                place.to_mem_place().into()\n-            }\n-        })\n+            _ => self.eval_place_to_mplace(mir_place)?.into(),\n+        };\n+\n+        trace!(\"eval_place_to_op: got {:?}\", *op);\n+        Ok(op)\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data.\n     /// if you already know the layout, you can save two some table lookups\n     /// by passing it in here.\n     pub fn eval_operand(\n-        &mut self,\n+        &self,\n         mir_op: &mir::Operand<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx>> {\n@@ -486,7 +483,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     /// Evaluate a bunch of operands at once\n     pub(crate) fn eval_operands(\n-        &mut self,\n+        &self,\n         ops: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, Vec<OpTy<'tcx>>> {\n         ops.into_iter()\n@@ -495,8 +492,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     // Also used e.g. when miri runs into a constant.\n-    // Unfortunately, this needs an `&mut` to be able to allocate a copy of a `ByRef`\n-    // constant.  This bleeds up to `eval_operand` needing `&mut`.\n     pub fn const_value_to_op(\n         &self,\n         val: ConstValue<'tcx>,\n@@ -527,18 +522,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.const_value_to_op(cv.val)\n     }\n \n-    /// We cannot do self.read_value(self.eval_operand) due to eval_operand taking &mut self,\n-    /// so this helps avoid unnecessary let.\n-    #[inline]\n-    pub fn eval_operand_and_read_value(\n-        &mut self,\n-        op: &mir::Operand<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        let op = self.eval_operand(op, layout)?;\n-        self.read_value(op)\n-    }\n-\n     /// reads a tag and produces the corresponding variant index\n     pub fn read_discriminant_as_variant_index(\n         &self,"}, {"sha": "de458b570f0d0015f2276e3032c4214cfd7400ce", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2592b20347ad49b99dd1eda58260e73ac553ed83", "patch": "@@ -494,33 +494,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         })\n     }\n \n-    /// Compute a place.  You should only use this if you intend to write into this\n-    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n-    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    /// Evaluate statics and promoteds to an `MPlace`.  Used to share some code between\n+    /// `eval_place` and `eval_place_to_op`.\n+    pub(super) fn eval_place_to_mplace(\n+        &self,\n+        mir_place: &mir::Place<'tcx>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         use rustc::mir::Place::*;\n-        let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => PlaceTy {\n-                place: self.frame().return_place,\n-                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n-            },\n-            Local(local) => PlaceTy {\n-                place: Place::Local {\n-                    frame: self.cur_frame(),\n-                    local,\n-                },\n-                layout: self.layout_of_local(self.cur_frame(), local)?,\n-            },\n-\n+        Ok(match *mir_place {\n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n                 let op = self.global_to_op(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n                 })?;\n-                let mplace = op.to_mem_place();\n+                let mplace = op.to_mem_place(); // these are always in memory\n                 let ty = self.monomorphize(promoted.1, self.substs());\n-                PlaceTy {\n-                    place: Place::Ptr(mplace),\n+                MPlaceTy {\n+                    mplace,\n                     layout: self.layout_of(ty)?,\n                 }\n             }\n@@ -539,17 +530,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // global table but not in its local memory.\n                 let alloc = self.tcx.alloc_map.lock()\n                     .intern_static(cid.instance.def_id());\n-                MPlaceTy::from_aligned_ptr(alloc.into(), layout).into()\n+                MPlaceTy::from_aligned_ptr(alloc.into(), layout)\n             }\n \n+            _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),\n+        })\n+    }\n+\n+    /// Compute a place.  You should only use this if you intend to write into this\n+    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        use rustc::mir::Place::*;\n+        let place = match *mir_place {\n+            Local(mir::RETURN_PLACE) => PlaceTy {\n+                place: self.frame().return_place,\n+                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            },\n+            Local(local) => PlaceTy {\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local,\n+                },\n+                layout: self.layout_of_local(self.cur_frame(), local)?,\n+            },\n+\n             Projection(ref proj) => {\n                 let place = self.eval_place(&proj.base)?;\n                 self.place_projection(place, &proj.elem)?\n             }\n+\n+            _ => self.eval_place_to_mplace(mir_place)?.into(),\n         };\n \n         self.dump_place(place.place);\n-\n         Ok(place)\n     }\n "}, {"sha": "54fdf8e0d4b8adfde7e8bf97d131dc2ad7baf960", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2592b20347ad49b99dd1eda58260e73ac553ed83", "patch": "@@ -188,9 +188,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = if binop_left_homogeneous(bin_op) { Some(dest.layout) } else { None };\n-                let left = self.eval_operand_and_read_value(left, layout)?;\n+                let left = self.read_value(self.eval_operand(left, layout)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.eval_operand_and_read_value(right, layout)?;\n+                let right = self.read_value(self.eval_operand(right, layout)?)?;\n                 self.binop_ignore_overflow(\n                     bin_op,\n                     left,\n@@ -201,9 +201,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n-                let left = self.eval_operand_and_read_value(left, None)?;\n+                let left = self.read_value(self.eval_operand(left, None)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.eval_operand_and_read_value(right, layout)?;\n+                let right = self.read_value(self.eval_operand(right, layout)?)?;\n                 self.binop_with_overflow(\n                     bin_op,\n                     left,\n@@ -214,7 +214,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n-                let val = self.eval_operand_and_read_value(operand, Some(dest.layout))?;\n+                let val = self.read_value(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "6ffee096a074d3f7714f5e8a1e7832dd769707c1", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2592b20347ad49b99dd1eda58260e73ac553ed83/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=2592b20347ad49b99dd1eda58260e73ac553ed83", "patch": "@@ -52,8 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ref targets,\n                 ..\n             } => {\n-                let discr_val = self.eval_operand(discr, None)?;\n-                let discr = self.read_value(discr_val)?;\n+                let discr = self.read_value(self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -164,19 +163,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_and_read_value(cond, None)?\n-                    .to_scalar()?\n-                    .to_bool()?;\n+                let cond_val = self.read_value(self.eval_operand(cond, None)?)?\n+                    .to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(Some(target))?;\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand_and_read_value(len, None)\n+                            let len = self.read_value(self.eval_operand(len, None)?)\n                                 .expect(\"can't eval len\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.eval_operand_and_read_value(index, None)\n+                            let index = self.read_value(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })"}]}