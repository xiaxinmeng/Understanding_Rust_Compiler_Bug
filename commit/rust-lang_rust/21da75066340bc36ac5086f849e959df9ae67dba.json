{"sha": "21da75066340bc36ac5086f849e959df9ae67dba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZGE3NTA2NjM0MGJjMzZhYzUwODZmODQ5ZTk1OWRmOWFlNjdkYmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-13T17:10:34Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-11-19T04:24:34Z"}, "message": "rustc: avoid `use`-ing `syntax::ast::*`.", "tree": {"sha": "09672e7410eaf00414f2cb800cede79749c33f5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09672e7410eaf00414f2cb800cede79749c33f5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21da75066340bc36ac5086f849e959df9ae67dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21da75066340bc36ac5086f849e959df9ae67dba", "html_url": "https://github.com/rust-lang/rust/commit/21da75066340bc36ac5086f849e959df9ae67dba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21da75066340bc36ac5086f849e959df9ae67dba/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09d98603e608c9e47d4c89f7b4dca87a4b56da3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09d98603e608c9e47d4c89f7b4dca87a4b56da3", "html_url": "https://github.com/rust-lang/rust/commit/e09d98603e608c9e47d4c89f7b4dca87a4b56da3"}], "stats": {"total": 909, "additions": 459, "deletions": 450}, "files": [{"sha": "f4df55fa5caf37fade33d2f2061d0d437dd0a903", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 77, "deletions": 76, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -32,8 +32,7 @@ use std::cell::RefCell;\n use std::hash::Hash;\n use std::hash;\n use syntax::abi;\n-use syntax::ast::*;\n-use syntax::ast;\n+use syntax::ast::{mod, DefId, NodeId};\n use syntax::ast_map::{PathElem, PathElems};\n use syntax::ast_map;\n use syntax::ast_util::*;\n@@ -53,8 +52,8 @@ use rbml::io::SeekableMemWriter;\n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n-    IITraitItemRef(ast::DefId, &'a ast::TraitItem),\n-    IIImplItemRef(ast::DefId, &'a ast::ImplItem),\n+    IITraitItemRef(DefId, &'a ast::TraitItem),\n+    IIImplItemRef(DefId, &'a ast::ImplItem),\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n@@ -87,11 +86,11 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-fn encode_name(rbml_w: &mut Encoder, name: Name) {\n+fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n }\n \n-fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Ident) {\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n@@ -134,7 +133,7 @@ pub fn def_to_string(did: DefId) -> String {\n \n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n-                         id: ast::NodeId) {\n+                         id: NodeId) {\n     let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n@@ -310,14 +309,14 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n-                            variants: &[P<Variant>],\n+                            variants: &[P<ast::Variant>],\n                             index: &mut Vec<entry<i64>>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n-                               ast::DefId { krate: LOCAL_CRATE, node: id });\n+                               DefId { krate: ast::LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n@@ -382,7 +381,7 @@ fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n-                                   method_name: Name) {\n+                                   method_name: ast::Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n@@ -504,18 +503,18 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: &ast::Item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n-        ItemEnum(ref enum_def, _) => {\n+        ast::ItemEnum(ref enum_def, _) => {\n             for variant in enum_def.variants.iter() {\n                 continue_ = callback(variant.node.id);\n                 if !continue_ {\n                     break\n                 }\n             }\n         }\n-        ItemStruct(ref struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n@@ -566,12 +565,12 @@ fn encode_reexports(ecx: &EncodeContext,\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n                        rbml_w: &mut Encoder,\n-                       md: &Mod,\n-                       attrs: &[Attribute],\n+                       md: &ast::Mod,\n+                       attrs: &[ast::Attribute],\n                        id: NodeId,\n                        path: PathElems,\n-                       name: Ident,\n-                       vis: Visibility) {\n+                       name: ast::Ident,\n+                       vis: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, local_def(id));\n     encode_family(rbml_w, 'm');\n@@ -593,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         match item.node {\n-            ItemImpl(..) => {\n+            ast::ItemImpl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({}/{})\",\n@@ -615,7 +614,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == Public {\n+    if vis == ast::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id, path);\n     }\n@@ -625,18 +624,18 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: Visibility) {\n+                              visibility: ast::Visibility) {\n     encode_family(rbml_w, match visibility {\n-        Public => 'g',\n-        Inherited => 'N'\n+        ast::Public => 'g',\n+        ast::Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: Visibility) {\n+fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n-        Public => 'y',\n-        Inherited => 'i',\n+        ast::Public => 'y',\n+        ast::Inherited => 'i',\n     };\n     rbml_w.wr_str(ch.to_string().as_slice());\n     rbml_w.end_tag();\n@@ -681,8 +680,8 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n-            MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n+            ast::MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n@@ -854,7 +853,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_item_opt: Option<&ImplItem>) {\n+                          ast_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {} {}\", m.def_id,\n            token::get_name(m.name));\n@@ -948,7 +947,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n \n fn encode_repr_attrs(rbml_w: &mut Encoder,\n                      ecx: &EncodeContext,\n-                     attrs: &[Attribute]) {\n+                     attrs: &[ast::Attribute]) {\n     let mut repr_attrs = Vec::new();\n     for attr in attrs.iter() {\n         repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n@@ -971,7 +970,7 @@ const FN_FAMILY: char = 'f';\n const STATIC_METHOD_FAMILY: char = 'F';\n const METHOD_FAMILY: char = 'h';\n \n-fn should_inline(attrs: &[Attribute]) -> bool {\n+fn should_inline(attrs: &[ast::Attribute]) -> bool {\n     use syntax::attr::*;\n     match find_inline_attr(attrs) {\n         InlineNone | InlineNever  => false,\n@@ -1021,13 +1020,13 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n \n fn encode_info_for_item(ecx: &EncodeContext,\n                         rbml_w: &mut Encoder,\n-                        item: &Item,\n+                        item: &ast::Item,\n                         index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &Item, rbml_w: &Encoder,\n+    fn add_to_index(item: &ast::Item, rbml_w: &Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n@@ -1042,7 +1041,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n \n     match item.node {\n-      ItemStatic(_, m, _) => {\n+      ast::ItemStatic(_, m, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1060,7 +1059,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, item.attrs.as_slice());\n         rbml_w.end_tag();\n       }\n-      ItemConst(_, _) => {\n+      ast::ItemConst(_, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1073,7 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemFn(ref decl, _, _, ref generics, _) => {\n+      ast::ItemFn(ref decl, _, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1094,7 +1093,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_method_argument_names(rbml_w, &**decl);\n         rbml_w.end_tag();\n       }\n-      ItemMod(ref m) => {\n+      ast::ItemMod(ref m) => {\n         add_to_index(item, rbml_w, index);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n@@ -1105,7 +1104,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.ident,\n                             item.vis);\n       }\n-      ItemForeignMod(ref fm) => {\n+      ast::ItemForeignMod(ref fm) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1123,7 +1122,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemTy(..) => {\n+      ast::ItemTy(..) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1135,7 +1134,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemEnum(ref enum_definition, _) => {\n+      ast::ItemEnum(ref enum_definition, _) => {\n         add_to_index(item, rbml_w, index);\n \n         rbml_w.start_tag(tag_items_data_item);\n@@ -1165,7 +1164,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n       }\n-      ItemStruct(ref struct_def, _) => {\n+      ast::ItemStruct(ref struct_def, _) => {\n         let fields = ty::lookup_struct_fields(tcx, def_id);\n \n         /* First, encode the fields\n@@ -1217,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n+      ast::ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1321,7 +1320,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n       }\n-      ItemTrait(_, _, _, ref ms) => {\n+      ast::ItemTrait(_, _, _, ref ms) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1433,22 +1432,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n             };\n             match trait_item {\n-                &RequiredMethod(ref m) => {\n+                &ast::RequiredMethod(ref m) => {\n                     encode_attributes(rbml_w, m.attrs.as_slice());\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n-                &ProvidedMethod(ref m) => {\n+                &ast::ProvidedMethod(ref m) => {\n                     encode_attributes(rbml_w, m.attrs.as_slice());\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n                     encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n \n-                &TypeTraitItem(ref associated_type) => {\n+                &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n                                       associated_type.attrs.as_slice());\n                     encode_item_sort(rbml_w, 't');\n@@ -1461,15 +1460,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n       }\n-      ItemMac(..) => {\n+      ast::ItemMac(..) => {\n         // macros are encoded separately\n       }\n     }\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 rbml_w: &mut Encoder,\n-                                nitem: &ForeignItem,\n+                                nitem: &ast::ForeignItem,\n                                 index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n@@ -1482,7 +1481,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     encode_def_id(rbml_w, local_def(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n-      ForeignItemFn(..) => {\n+      ast::ForeignItemFn(..) => {\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n@@ -1492,7 +1491,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_symbol(ecx, rbml_w, nitem.id);\n       }\n-      ForeignItemStatic(_, mutbl) => {\n+      ast::ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n             encode_family(rbml_w, 'b');\n         } else {\n@@ -1508,9 +1507,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn my_visit_expr(_e: &Expr) { }\n+fn my_visit_expr(_e: &ast::Expr) { }\n \n-fn my_visit_item(i: &Item,\n+fn my_visit_item(i: &ast::Item,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n                  index: &mut Vec<entry<i64>>) {\n@@ -1519,7 +1518,7 @@ fn my_visit_item(i: &Item,\n     });\n }\n \n-fn my_visit_foreign_item(ni: &ForeignItem,\n+fn my_visit_foreign_item(ni: &ast::ForeignItem,\n                          rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          index: &mut Vec<entry<i64>>) {\n@@ -1542,18 +1541,18 @@ struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n                       self.ecx,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, ni: &ast::ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n@@ -1564,22 +1563,22 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n \n fn encode_info_for_items(ecx: &EncodeContext,\n                          rbml_w: &mut Encoder,\n-                         krate: &Crate)\n+                         krate: &ast::Crate)\n                          -> Vec<entry<i64>> {\n     let mut index = Vec::new();\n     rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n-        val: CRATE_NODE_ID as i64,\n+        val: ast::CRATE_NODE_ID as i64,\n         pos: rbml_w.writer.tell().unwrap(),\n     });\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n                         &[],\n-                        CRATE_NODE_ID,\n+                        ast::CRATE_NODE_ID,\n                         ast_map::Values([].iter()).chain(None),\n                         syntax::parse::token::special_idents::invalid,\n-                        Public);\n+                        ast::Public);\n \n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n@@ -1637,18 +1636,18 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n     match mi.node {\n-      MetaWord(ref name) => {\n+      ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write(name.get().as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n       }\n-      MetaNameValue(ref name, ref value) => {\n+      ast::MetaNameValue(ref name, ref value) => {\n         match value.node {\n-          LitStr(ref value, _) => {\n+          ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.start_tag(tag_meta_item_name);\n             rbml_w.writer.write(name.get().as_bytes());\n@@ -1661,7 +1660,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      MetaList(ref name, ref items) => {\n+      ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write(name.get().as_bytes());\n@@ -1674,7 +1673,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n     }\n }\n \n-fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n+fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n     for attr in attrs.iter() {\n         rbml_w.start_tag(tag_attribute);\n@@ -1728,7 +1727,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n         for id in def_id.iter() {\n-            if id.krate == LOCAL_CRATE {\n+            if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n \n                 rbml_w.start_tag(tag_lang_items_item_id);\n@@ -1804,7 +1803,7 @@ fn encode_macro_def(ecx: &EncodeContext,\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &Crate,\n+                     krate: &ast::Crate,\n                      rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_exported_macros);\n     for item in krate.exported_macros.iter() {\n@@ -1821,7 +1820,7 @@ fn encode_unboxed_closures<'a>(\n                                                     .unboxed_closures\n                                                     .borrow()\n                                                     .iter() {\n-        if unboxed_closure_id.krate != LOCAL_CRATE {\n+        if unboxed_closure_id.krate != ast::LOCAL_CRATE {\n             continue\n         }\n \n@@ -1836,7 +1835,7 @@ fn encode_unboxed_closures<'a>(\n     rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n+fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n     struct StructFieldVisitor<'a, 'b:'a> {\n         rbml_w: &'a mut Encoder<'b>,\n     }\n@@ -1865,17 +1864,17 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         match item.node {\n-            ItemImpl(_, Some(ref trait_ref), _, _) => {\n+            ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n                 let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate.\n                 if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                        def_id.krate != LOCAL_CRATE {\n+                        def_id.krate != ast::LOCAL_CRATE {\n                     self.rbml_w.start_tag(tag_impls_impl);\n                     encode_def_id(self.rbml_w, local_def(item.id));\n                     self.rbml_w.end_tag();\n@@ -1898,7 +1897,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n ///\n /// * Implementations of traits not defined in this crate.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n-                    krate: &Crate,\n+                    krate: &ast::Crate,\n                     rbml_w: &'a mut Encoder) {\n     rbml_w.start_tag(tag_impls);\n \n@@ -1914,7 +1913,7 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n-                    krate: &Crate,\n+                    krate: &ast::Crate,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n@@ -2011,13 +2010,15 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n+pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n     wr.unwrap().into_iter().collect()\n }\n \n-fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate: &Crate) {\n+fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n+                         parms: EncodeParams,\n+                         krate: &ast::Crate) {\n     struct Stats {\n         attr_bytes: u64,\n         dep_bytes: u64,"}, {"sha": "a3be480bf9278e8473f18fd7eaf820339e0f17e0", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -27,7 +27,6 @@ use std::str;\n use std::string::String;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast::*;\n use syntax::parse::token;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -525,10 +524,10 @@ fn parse_hex(st: &mut PState) -> uint {\n     };\n }\n \n-fn parse_fn_style(c: char) -> FnStyle {\n+fn parse_fn_style(c: char) -> ast::FnStyle {\n     match c {\n-        'u' => UnsafeFn,\n-        'n' => NormalFn,\n+        'u' => ast::UnsafeFn,\n+        'n' => ast::NormalFn,\n         _ => panic!(\"parse_fn_style: bad fn_style {}\", c)\n     }\n }"}, {"sha": "ebc953a56afe6a781316e01a33690e06d31dc5c6", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -23,7 +23,6 @@ use util::nodemap::FnvHashMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n@@ -34,7 +33,7 @@ macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    pub ds: fn(DefId) -> String,\n+    pub ds: fn(ast::DefId) -> String,\n     // The type context.\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub abbrevs: &'a abbrev_map\n@@ -75,8 +74,8 @@ pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n \n fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n     match mt {\n-        MutImmutable => (),\n-        MutMutable => mywrite!(w, \"m\"),\n+        ast::MutImmutable => (),\n+        ast::MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n@@ -203,26 +202,26 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                TyI => mywrite!(w, \"i\"),\n-                TyI8 => mywrite!(w, \"MB\"),\n-                TyI16 => mywrite!(w, \"MW\"),\n-                TyI32 => mywrite!(w, \"ML\"),\n-                TyI64 => mywrite!(w, \"MD\")\n+                ast::TyI => mywrite!(w, \"i\"),\n+                ast::TyI8 => mywrite!(w, \"MB\"),\n+                ast::TyI16 => mywrite!(w, \"MW\"),\n+                ast::TyI32 => mywrite!(w, \"ML\"),\n+                ast::TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                TyU => mywrite!(w, \"u\"),\n-                TyU8 => mywrite!(w, \"Mb\"),\n-                TyU16 => mywrite!(w, \"Mw\"),\n-                TyU32 => mywrite!(w, \"Ml\"),\n-                TyU64 => mywrite!(w, \"Md\")\n+                ast::TyU => mywrite!(w, \"u\"),\n+                ast::TyU8 => mywrite!(w, \"Mb\"),\n+                ast::TyU16 => mywrite!(w, \"Mw\"),\n+                ast::TyU32 => mywrite!(w, \"Ml\"),\n+                ast::TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n         ty::ty_float(t) => {\n             match t {\n-                TyF32 => mywrite!(w, \"Mf\"),\n-                TyF64 => mywrite!(w, \"MF\"),\n+                ast::TyF32 => mywrite!(w, \"Mf\"),\n+                ast::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n         ty::ty_enum(def, ref substs) => {\n@@ -295,10 +294,10 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_fn_style(w: &mut SeekableMemWriter, p: FnStyle) {\n+fn enc_fn_style(w: &mut SeekableMemWriter, p: ast::FnStyle) {\n     match p {\n-        NormalFn => mywrite!(w, \"n\"),\n-        UnsafeFn => mywrite!(w, \"u\"),\n+        ast::NormalFn => mywrite!(w, \"n\"),\n+        ast::UnsafeFn => mywrite!(w, \"u\"),\n     }\n }\n \n@@ -308,10 +307,10 @@ fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: &mut SeekableMemWriter, o: Onceness) {\n+fn enc_onceness(w: &mut SeekableMemWriter, o: ast::Onceness) {\n     match o {\n-        Once => mywrite!(w, \"o\"),\n-        Many => mywrite!(w, \"m\")\n+        ast::Once => mywrite!(w, \"o\"),\n+        ast::Many => mywrite!(w, \"m\")\n     }\n }\n "}, {"sha": "8cb63fcd82741ad1a9d84141145ac8943c7a3508", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -14,7 +14,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_util;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -40,13 +40,13 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item(self, i);\n     }\n-    fn visit_pat(&mut self, p: &Pat) {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n         check_pat(self, p);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         if check_expr(self, ex) {\n             visit::walk_expr(self, ex);\n         }\n@@ -59,13 +59,13 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) |\n-        ItemConst(_, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             v.inside_const(|v| v.visit_expr(&**ex));\n         }\n-        ItemEnum(ref enum_definition, _) => {\n+        ast::ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n                 for ex in var.node.disr_expr.iter() {\n                     v.inside_const(|v| v.visit_expr(&**ex));\n@@ -76,12 +76,12 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     }\n }\n \n-fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n-    fn is_str(e: &Expr) -> bool {\n+fn check_pat(v: &mut CheckCrateVisitor, p: &ast::Pat) {\n+    fn is_str(e: &ast::Expr) -> bool {\n         match e.node {\n-            ExprBox(_, ref expr) => {\n+            ast::ExprBox(_, ref expr) => {\n                 match expr.node {\n-                    ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n+                    ast::ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n                     _ => false,\n                 }\n             }\n@@ -90,36 +90,36 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     }\n     match p.node {\n         // Let through plain ~-string literals here\n-        PatLit(ref a) => if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); },\n-        PatRange(ref a, ref b) => {\n+        ast::PatLit(ref a) => if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); },\n+        ast::PatRange(ref a, ref b) => {\n             if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); }\n             if !is_str(&**b) { v.inside_const(|v| v.visit_expr(&**b)); }\n         }\n         _ => v.outside_const(|v| visit::walk_pat(v, p))\n     }\n }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n     if !v.in_const { return true }\n \n     match e.node {\n-        ExprUnary(UnDeref, _) => {}\n-        ExprUnary(UnUniq, _) => {\n+        ast::ExprUnary(ast::UnDeref, _) => {}\n+        ast::ExprUnary(ast::UnUniq, _) => {\n             span_err!(v.tcx.sess, e.span, E0010,\n                       \"cannot do allocations in constant expressions\");\n             return false;\n         }\n-        ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n-        ExprBinary(..) | ExprUnary(..) => {\n+        ast::ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n+        ast::ExprBinary(..) | ast::ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                           \"user-defined operators are not allowed in constant \\\n                            expressions\");\n             }\n         }\n-        ExprLit(_) => (),\n-        ExprCast(ref from, _) => {\n+        ast::ExprLit(_) => (),\n+        ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n             if !ty::type_is_numeric(toty) && !ty::type_is_unsafe_ptr(toty) {\n@@ -133,7 +133,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                            expression\");\n             }\n         }\n-        ExprPath(ref pth) => {\n+        ast::ExprPath(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n@@ -161,7 +161,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 }\n             }\n         }\n-        ExprCall(ref callee, _) => {\n+        ast::ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().get(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n@@ -173,25 +173,25 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 }\n             }\n         }\n-        ExprBlock(ref block) => {\n+        ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n                 let block_span_err = |span|\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in constants are limited to items and \\\n                                tail expressions\");\n                 match stmt.node {\n-                    StmtDecl(ref span, _) => {\n+                    ast::StmtDecl(ref span, _) => {\n                         match span.node {\n-                            DeclLocal(_) => block_span_err(span.span),\n+                            ast::DeclLocal(_) => block_span_err(span.span),\n \n                             // Item statements are allowed\n-                            DeclItem(_) => {}\n+                            ast::DeclItem(_) => {}\n                         }\n                     }\n-                    StmtExpr(ref expr, _) => block_span_err(expr.span),\n-                    StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    StmtMac(..) => {\n+                    ast::StmtExpr(ref expr, _) => block_span_err(expr.span),\n+                    ast::StmtSemi(ref semi, _) => block_span_err(semi.span),\n+                    ast::StmtMac(..) => {\n                         v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n                                                      macro in const?!\")\n                     }\n@@ -202,20 +202,20 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 None => {}\n             }\n         }\n-        ExprVec(_) |\n-        ExprAddrOf(MutImmutable, _) |\n-        ExprParen(..) |\n-        ExprField(..) |\n-        ExprTupField(..) |\n-        ExprIndex(..) |\n-        ExprTup(..) |\n-        ExprRepeat(..) |\n-        ExprStruct(..) => {}\n-\n-        ExprAddrOf(_, ref inner) => {\n+        ast::ExprVec(_) |\n+        ast::ExprAddrOf(ast::MutImmutable, _) |\n+        ast::ExprParen(..) |\n+        ast::ExprField(..) |\n+        ast::ExprTupField(..) |\n+        ast::ExprIndex(..) |\n+        ast::ExprTup(..) |\n+        ast::ExprRepeat(..) |\n+        ast::ExprStruct(..) => {}\n+\n+        ast::ExprAddrOf(_, ref inner) => {\n             match inner.node {\n                 // Mutable slices are allowed.\n-                ExprVec(_) => {}\n+                ast::ExprVec(_) => {}\n                 _ => span_err!(v.tcx.sess, e.span, E0017,\n                                \"references in constants may only refer \\\n                                 to immutable values\")"}, {"sha": "d8618430db45572df07cafc0e3f4a39a37a4b883", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -27,7 +27,7 @@ use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n use std::num::Float;\n use std::slice;\n-use syntax::ast::*;\n+use syntax::ast::{mod, DUMMY_NODE_ID, NodeId, Pat};\n use syntax::ast_util::walk_pat;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n@@ -39,7 +39,7 @@ use util::ppaux::ty_to_string;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n-    node: PatWild(PatWildSingle),\n+    node: ast::PatWild(ast::PatWildSingle),\n     span: DUMMY_SP\n };\n \n@@ -108,7 +108,7 @@ pub enum Constructor {\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n-    Variant(DefId),\n+    Variant(ast::DefId),\n     /// Literal values.\n     ConstantValue(const_val),\n     /// Ranges of literal values (2..5).\n@@ -132,14 +132,14 @@ enum WitnessPreference {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         check_local(self, l);\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -149,10 +149,10 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n+fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ExprMatch(ref scrut, ref arms, source) => {\n+        ast::ExprMatch(ref scrut, ref arms, source) => {\n             // First, check legality of move bindings.\n             for arm in arms.iter() {\n                 check_legality_of_move_bindings(cx,\n@@ -177,7 +177,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n                 }).collect(), arm.guard.as_ref().map(|e| &**e))\n-            }).collect::<Vec<(Vec<P<Pat>>, Option<&Expr>)>>();\n+            }).collect::<Vec<(Vec<P<Pat>>, Option<&ast::Expr>)>>();\n \n             if static_inliner.failed {\n                 return;\n@@ -214,7 +214,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n-        ExprForLoop(ref pat, _, _, _) => {\n+        ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n                 cx.tcx.sess.span_err(\n@@ -232,7 +232,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     }\n }\n \n-fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n+fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n     match eval_const_expr(tcx, expr) {\n         const_float(f) => f.is_nan(),\n         _ => false\n@@ -244,7 +244,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n     for pat in pats.iter() {\n         walk_pat(&**pat, |p| {\n             match p.node {\n-                PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                         \"unmatchable NaN in pattern, \\\n                             use the is_nan method in a guard instead\");\n@@ -257,7 +257,9 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source: MatchSource) {\n+fn check_arms(cx: &MatchCheckCtxt,\n+              arms: &[(Vec<P<Pat>>, Option<&ast::Expr>)],\n+              source: ast::MatchSource) {\n     let mut seen = Matrix(vec![]);\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms.iter() {\n@@ -267,7 +269,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        MatchIfLetDesugar => {\n+                        ast::MatchIfLetDesugar => {\n                             if printed_if_let_err {\n                                 // we already printed an irrefutable if-let pattern error.\n                                 // We don't want two, that's just confusing.\n@@ -281,15 +283,15 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                             }\n                         },\n \n-                        MatchWhileLetDesugar => {\n+                        ast::MatchWhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n-                        MatchNormal => {\n+                        ast::MatchNormal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n                     }\n@@ -308,7 +310,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        ast::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n         _ => p\n     }\n }\n@@ -333,14 +335,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     }\n }\n \n-fn const_val_to_expr(value: &const_val) -> P<Expr> {\n+fn const_val_to_expr(value: &const_val) -> P<ast::Expr> {\n     let node = match value {\n-        &const_bool(b) => LitBool(b),\n+        &const_bool(b) => ast::LitBool(b),\n         _ => unreachable!()\n     };\n-    P(Expr {\n+    P(ast::Expr {\n         id: 0,\n-        node: ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n+        node: ast::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP\n     })\n }\n@@ -362,7 +364,7 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n-            PatIdent(..) | PatEnum(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n@@ -405,7 +407,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(_) => PatTup(pats.collect()),\n+        ty::ty_tup(_) => ast::PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -417,21 +419,21 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n-                let field_pats: Vec<Spanned<FieldPat>> = fields.into_iter()\n+                let field_pats: Vec<_> = fields.into_iter()\n                     .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != PatWild(PatWildSingle))\n+                    .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n                     .map(|(field, pat)| Spanned {\n                         span: DUMMY_SP,\n-                        node: FieldPat {\n-                            ident: Ident::new(field.name),\n+                        node: ast::FieldPat {\n+                            ident: ast::Ident::new(field.name),\n                             pat: pat,\n                             is_shorthand: false,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n+                ast::PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n             } else {\n-                PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n+                ast::PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n             }\n         }\n \n@@ -440,40 +442,40 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        PatVec(pats.collect(), None, vec!())\n+                        ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_vec(_, None) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        PatVec(pats.collect(), None, vec!())\n+                        ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::ty_str => PatWild(PatWildSingle),\n+                ty::ty_str => ast::PatWild(ast::PatWildSingle),\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    PatRegion(pats.nth(0).unwrap())\n+                    ast::PatRegion(pats.nth(0).unwrap())\n                 }\n             }\n         }\n \n         ty::ty_vec(_, Some(len)) => {\n             assert_eq!(pats_len, len);\n-            PatVec(pats.collect(), None, vec![])\n+            ast::PatVec(pats.collect(), None, vec![])\n         }\n \n         _ => {\n             match *ctor {\n-                ConstantValue(ref v) => PatLit(const_val_to_expr(v)),\n-                _ => PatWild(PatWildSingle),\n+                ConstantValue(ref v) => ast::PatLit(const_val_to_expr(v)),\n+                _ => ast::PatWild(ast::PatWildSingle),\n             }\n         }\n     };\n \n-    P(Pat {\n+    P(ast::Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n@@ -558,7 +560,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     };\n \n     let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n-        PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        ast::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n@@ -639,7 +641,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatIdent(..) =>\n+        ast::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n@@ -648,27 +650,27 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n-        PatEnum(..) =>\n+        ast::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatStruct(..) =>\n+        ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatLit(ref expr) =>\n+        ast::PatLit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n-        PatRange(ref lo, ref hi) =>\n+        ast::PatRange(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n-        PatVec(ref before, ref slice, ref after) =>\n+        ast::PatVec(ref before, ref slice, ref after) =>\n             match ty::get(left_ty).sty {\n                 ty::ty_vec(_, Some(_)) => vec!(Single),\n                 _                      => if slice.is_some() {\n@@ -679,11 +681,11 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        PatBox(_) | PatTup(_) | PatRegion(..) =>\n+        ast::PatBox(_) | ast::PatTup(_) | ast::PatRegion(..) =>\n             vec!(Single),\n-        PatWild(_) =>\n+        ast::PatWild(_) =>\n             vec!(),\n-        PatMac(_) =>\n+        ast::PatMac(_) =>\n             cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n }\n@@ -747,12 +749,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n-    let head: Option<Vec<&Pat>> = match node {\n-\n-        &PatWild(_) =>\n+    let head: Option<Vec<&Pat>> = match *node {\n+        ast::PatWild(_) =>\n             Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n-        &PatIdent(_, _, _) => {\n+        ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n             match opt_def {\n                 Some(DefConst(..)) =>\n@@ -767,7 +768,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatEnum(_, ref args) => {\n+        ast::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             match def {\n                 DefConst(..) =>\n@@ -784,7 +785,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatStruct(_, ref pattern_fields, _) => {\n+        ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             let class_id = match def {\n@@ -820,13 +821,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             })\n         }\n \n-        &PatTup(ref args) =>\n+        ast::PatTup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        &PatBox(ref inner) | &PatRegion(ref inner) =>\n+        ast::PatBox(ref inner) | ast::PatRegion(ref inner) =>\n             Some(vec![&**inner]),\n \n-        &PatLit(ref expr) => {\n+        ast::PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n@@ -838,7 +839,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatRange(ref from, ref to) => {\n+        ast::PatRange(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n@@ -851,7 +852,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatVec(ref before, ref slice, ref after) => {\n+        ast::PatVec(ref before, ref slice, ref after) => {\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n@@ -883,7 +884,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatMac(_) => {\n+        ast::PatMac(_) => {\n             cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n             None\n         }\n@@ -895,12 +896,12 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     })\n }\n \n-fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n+fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n     visit::walk_local(cx, loc);\n \n     let name = match loc.source {\n-        LocalLet => \"local\",\n-        LocalFor => \"`for` loop\"\n+        ast::LocalLet => \"local\",\n+        ast::LocalFor => \"`for` loop\"\n     };\n \n     let mut static_inliner = StaticInliner::new(cx.tcx);\n@@ -918,8 +919,8 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n             kind: FnKind,\n-            decl: &FnDecl,\n-            body: &Block,\n+            decl: &ast::FnDecl,\n+            body: &ast::Block,\n             sp: Span,\n             _: NodeId) {\n     visit::walk_fn(cx, kind, decl, body, sp);\n@@ -957,10 +958,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     for pat in pats.iter() {\n         pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n-                BindByRef(_) => {\n+                ast::BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                BindByValue(_) => {\n+                ast::BindByValue(_) => {\n                 }\n             }\n         })\n@@ -985,13 +986,13 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n-                    PatIdent(BindByValue(_), _, ref sub) => {\n+                    ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n                         if ty::type_moves_by_default(tcx, pat_ty) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n-                    PatIdent(BindByRef(_), _, _) => {\n+                    ast::PatIdent(ast::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n@@ -1010,7 +1011,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>, guard: &Expr) {\n+fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n+                                         guard: &ast::Expr) {\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n@@ -1078,7 +1080,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(_)) => {\n+            ast::PatIdent(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 visit::walk_pat(self, pat);"}, {"sha": "c06044073ed680977f5642f233b8d4ff35b6fdbb", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 102, "deletions": 102, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -23,12 +23,12 @@ use middle::typeck::astconv;\n use middle::typeck::check;\n use util::nodemap::{DefIdMap};\n \n-use syntax::ast::*;\n+use syntax::ast::{mod, Expr};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n-use syntax::{ast, ast_map, ast_util, codemap};\n+use syntax::{ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n use std::collections::hash_map::Vacant;\n@@ -118,7 +118,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         match tcx.map.find(enum_def.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     variant_expr(variants.as_slice(), variant_def.node)\n                 }\n                 _ => None\n@@ -136,7 +136,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n@@ -158,7 +158,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemConst(_, ref const_expr) => {\n+                ast::ItemConst(_, ref const_expr) => {\n                     Some(&**const_expr)\n                 }\n                 _ => None\n@@ -176,7 +176,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemConst(_, ref const_expr) => Some(const_expr.id),\n+                ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None\n@@ -280,9 +280,9 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: &Ty) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            TyFixedLengthVec(_, ref expr) => {\n+            ast::TyFixedLengthVec(_, ref expr) => {\n                 check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n             }\n             _ => {}\n@@ -317,12 +317,12 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n     let pat = match expr.node {\n-        ExprTup(ref exprs) =>\n-            PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n+        ast::ExprTup(ref exprs) =>\n+            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n-        ExprCall(ref callee, ref args) => {\n+        ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n             match tcx.def_map.borrow_mut().entry(expr.id) {\n               Vacant(entry) => { entry.set(def); }\n@@ -334,33 +334,33 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n-            PatEnum(path, Some(pats))\n+            ast::PatEnum(path, Some(pats))\n         }\n \n-        ExprStruct(ref path, ref fields, None) => {\n+        ast::ExprStruct(ref path, ref fields, None) => {\n             let field_pats = fields.iter().map(|field| codemap::Spanned {\n                 span: codemap::DUMMY_SP,\n-                node: FieldPat {\n+                node: ast::FieldPat {\n                     ident: field.ident.node,\n                     pat: const_expr_to_pat(tcx, &*field.expr),\n                     is_shorthand: false,\n                 },\n             }).collect();\n-            PatStruct(path.clone(), field_pats, false)\n+            ast::PatStruct(path.clone(), field_pats, false)\n         }\n \n-        ExprVec(ref exprs) => {\n+        ast::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n-            PatVec(pats, None, vec![])\n+            ast::PatVec(pats, None, vec![])\n         }\n \n-        ExprPath(ref path) => {\n+        ast::ExprPath(ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    PatStruct(path.clone(), vec![], false),\n+                    ast::PatStruct(path.clone(), vec![], false),\n                 Some(def::DefVariant(..)) =>\n-                    PatEnum(path.clone(), None),\n+                    ast::PatEnum(path.clone(), None),\n                 _ => {\n                     match lookup_const(tcx, expr) {\n                         Some(actual) => return const_expr_to_pat(tcx, actual),\n@@ -370,9 +370,9 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n             }\n         }\n \n-        _ => PatLit(P(expr.clone()))\n+        _ => ast::PatLit(P(expr.clone()))\n     };\n-    P(Pat { id: expr.id, node: pat, span: expr.span })\n+    P(ast::Pat { id: expr.id, node: pat, span: expr.span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n@@ -385,7 +385,7 @@ pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n-      ExprUnary(UnNeg, ref inner) => {\n+      ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -395,118 +395,118 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n           ref err => ((*err).clone())\n         }\n       }\n-      ExprUnary(UnNot, ref inner) => {\n+      ast::ExprUnary(ast::UnNot, ref inner) => {\n         match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n-      ExprBinary(op, ref a, ref b) => {\n+      ast::ExprBinary(op, ref a, ref b) => {\n         match (eval_const_expr_partial(tcx, &**a),\n                eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n-              BiAdd => Ok(const_float(a + b)),\n-              BiSub => Ok(const_float(a - b)),\n-              BiMul => Ok(const_float(a * b)),\n-              BiDiv => Ok(const_float(a / b)),\n-              BiRem => Ok(const_float(a % b)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b),\n+              ast::BiAdd => Ok(const_float(a + b)),\n+              ast::BiSub => Ok(const_float(a - b)),\n+              ast::BiMul => Ok(const_float(a * b)),\n+              ast::BiDiv => Ok(const_float(a / b)),\n+              ast::BiRem => Ok(const_float(a % b)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b),\n               _ => Err(\"can't do this op on floats\".to_string())\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n-              BiAdd => Ok(const_int(a + b)),\n-              BiSub => Ok(const_int(a - b)),\n-              BiMul => Ok(const_int(a * b)),\n-              BiDiv if b == 0 => {\n+              ast::BiAdd => Ok(const_int(a + b)),\n+              ast::BiSub => Ok(const_int(a - b)),\n+              ast::BiMul => Ok(const_int(a * b)),\n+              ast::BiDiv if b == 0 => {\n                   Err(\"attempted to divide by zero\".to_string())\n               }\n-              BiDiv => Ok(const_int(a / b)),\n-              BiRem if b == 0 => {\n+              ast::BiDiv => Ok(const_int(a / b)),\n+              ast::BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n                        zero\".to_string())\n               }\n-              BiRem => Ok(const_int(a % b)),\n-              BiAnd | BiBitAnd => Ok(const_int(a & b)),\n-              BiOr | BiBitOr => Ok(const_int(a | b)),\n-              BiBitXor => Ok(const_int(a ^ b)),\n-              BiShl => Ok(const_int(a << b as uint)),\n-              BiShr => Ok(const_int(a >> b as uint)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b)\n+              ast::BiRem => Ok(const_int(a % b)),\n+              ast::BiAnd | ast::BiBitAnd => Ok(const_int(a & b)),\n+              ast::BiOr | ast::BiBitOr => Ok(const_int(a | b)),\n+              ast::BiBitXor => Ok(const_int(a ^ b)),\n+              ast::BiShl => Ok(const_int(a << b as uint)),\n+              ast::BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b)\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n             match op {\n-              BiAdd => Ok(const_uint(a + b)),\n-              BiSub => Ok(const_uint(a - b)),\n-              BiMul => Ok(const_uint(a * b)),\n-              BiDiv if b == 0 => {\n+              ast::BiAdd => Ok(const_uint(a + b)),\n+              ast::BiSub => Ok(const_uint(a - b)),\n+              ast::BiMul => Ok(const_uint(a * b)),\n+              ast::BiDiv if b == 0 => {\n                   Err(\"attempted to divide by zero\".to_string())\n               }\n-              BiDiv => Ok(const_uint(a / b)),\n-              BiRem if b == 0 => {\n+              ast::BiDiv => Ok(const_uint(a / b)),\n+              ast::BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n                        zero\".to_string())\n               }\n-              BiRem => Ok(const_uint(a % b)),\n-              BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n-              BiOr | BiBitOr => Ok(const_uint(a | b)),\n-              BiBitXor => Ok(const_uint(a ^ b)),\n-              BiShl => Ok(const_uint(a << b as uint)),\n-              BiShr => Ok(const_uint(a >> b as uint)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b),\n+              ast::BiRem => Ok(const_uint(a % b)),\n+              ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n+              ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n+              ast::BiBitXor => Ok(const_uint(a ^ b)),\n+              ast::BiShl => Ok(const_uint(a << b as uint)),\n+              ast::BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b),\n             }\n           }\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n             match op {\n-              BiShl => Ok(const_int(a << b as uint)),\n-              BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiShl => Ok(const_int(a << b as uint)),\n+              ast::BiShr => Ok(const_int(a >> b as uint)),\n               _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n-              BiShl => Ok(const_uint(a << b as uint)),\n-              BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiShl => Ok(const_uint(a << b as uint)),\n+              ast::BiShr => Ok(const_uint(a >> b as uint)),\n               _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n             Ok(const_bool(match op {\n-              BiAnd => a && b,\n-              BiOr => a || b,\n-              BiBitXor => a ^ b,\n-              BiBitAnd => a & b,\n-              BiBitOr => a | b,\n-              BiEq => a == b,\n-              BiNe => a != b,\n+              ast::BiAnd => a && b,\n+              ast::BiOr => a || b,\n+              ast::BiBitXor => a ^ b,\n+              ast::BiBitAnd => a & b,\n+              ast::BiBitOr => a | b,\n+              ast::BiEq => a == b,\n+              ast::BiNe => a != b,\n               _ => return Err(\"can't do this op on bools\".to_string())\n              }))\n           }\n           _ => Err(\"bad operands for binary\".to_string())\n         }\n       }\n-      ExprCast(ref base, ref target_ty) => {\n+      ast::ExprCast(ref base, ref target_ty) => {\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n@@ -556,15 +556,15 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n             }))\n       }\n-      ExprPath(_) => {\n+      ast::ExprPath(_) => {\n           match lookup_const(tcx, e) {\n               Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }\n-      ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n-      ExprBlock(ref block) => {\n+      ast::ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n+      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n+      ast::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &**expr),\n             None => Ok(const_int(0i64))\n@@ -574,24 +574,24 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n     }\n }\n \n-pub fn lit_to_const(lit: &Lit) -> const_val {\n+pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n     match lit.node {\n-        LitStr(ref s, _) => const_str((*s).clone()),\n-        LitBinary(ref data) => {\n+        ast::LitStr(ref s, _) => const_str((*s).clone()),\n+        ast::LitBinary(ref data) => {\n             const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n         }\n-        LitByte(n) => const_uint(n as u64),\n-        LitChar(n) => const_uint(n as u64),\n-        LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n-        LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n-        LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n-        LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n-        LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n-        LitFloat(ref n, _) |\n-        LitFloatUnsuffixed(ref n) => {\n+        ast::LitByte(n) => const_uint(n as u64),\n+        ast::LitChar(n) => const_uint(n as u64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n+        ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n+        ast::LitFloat(ref n, _) |\n+        ast::LitFloatUnsuffixed(ref n) => {\n             const_float(from_str::<f64>(n.get()).unwrap() as f64)\n         }\n-        LitBool(b) => const_bool(b)\n+        ast::LitBool(b) => const_bool(b)\n     }\n }\n "}, {"sha": "5f416fc98c902b0a06737e2d42050be58cdeaef5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 110, "deletions": 106, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -123,8 +123,7 @@ use std::fmt;\n use std::io;\n use std::rc::Rc;\n use std::uint;\n-use syntax::ast;\n-use syntax::ast::*;\n+use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n@@ -140,7 +139,7 @@ enum LoopKind<'a> {\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n     /// A `for` loop, with the given pattern to bind.\n-    ForLoop(&'a Pat),\n+    ForLoop(&'a ast::Pat),\n }\n \n #[deriving(PartialEq)]\n@@ -187,12 +186,13 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n+    fn visit_arm(&mut self, a: &ast::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n@@ -250,12 +250,12 @@ struct CaptureInfo {\n #[deriving(Show)]\n struct LocalInfo {\n     id: NodeId,\n-    ident: Ident\n+    ident: ast::Ident\n }\n \n #[deriving(Show)]\n enum VarKind {\n-    Arg(NodeId, Ident),\n+    Arg(NodeId, ast::Ident),\n     Local(LocalInfo),\n     ImplicitRet,\n     CleanExit\n@@ -354,7 +354,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_local(&mut self, l: &ast::Local) {\n@@ -363,15 +364,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &Arm) {\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n         check_arm(self, a);\n     }\n }\n \n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n-            decl: &FnDecl,\n-            body: &Block,\n+            decl: &ast::FnDecl,\n+            body: &ast::Block,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -429,7 +430,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     visit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n+fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {}\",\n@@ -448,7 +449,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ExprPath(_) => {\n+      ast::ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].clone();\n         debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n@@ -457,7 +458,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         }\n         visit::walk_expr(ir, expr);\n       }\n-      ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) => {\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -485,17 +486,17 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n+      ast::ExprIf(..) | ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ExprIfLet(..) => {\n+      ast::ExprIfLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n-      ExprWhileLet(..) => {\n+      ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ExprForLoop(ref pat, _, _, _) => {\n+      ast::ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from for loop with bm {}\",\n                    p_id, bm);\n@@ -509,20 +510,21 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n+      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n-      ExprIndex(..) | ExprField(..) | ExprTupField(..) | ExprVec(..) |\n-      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprSlice(..) |\n-      ExprBinary(..) | ExprAddrOf(..) |\n-      ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n-      ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n-      ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n-      ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n-      ExprInlineAsm(..) | ExprBox(..) => {\n+      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n+      ast::ExprVec(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) |\n+      ast::ExprTup(..) | ast::ExprBinary(..) | ast::ExprAddrOf(..) |\n+      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprBreak(_) |\n+      ast::ExprAgain(_) | ast::ExprLit(_) | ast::ExprRet(..) |\n+      ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n+      ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n+      ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n+      ast::ExprSlice(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -611,7 +613,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn pat_bindings(&mut self,\n-                    pat: &Pat,\n+                    pat: &ast::Pat,\n                     f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -621,7 +623,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pat: Option<&Pat>,\n+                         pat: Option<&ast::Pat>,\n                          f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         match pat {\n             Some(pat) => {\n@@ -631,12 +633,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: &Pat, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: &ast::Pat, succ: LiveNode)\n                               -> LiveNode {\n         self.define_bindings_in_arm_pats(Some(pat), succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&Pat>, succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pat: Option<&ast::Pat>, succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n         self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n@@ -711,7 +713,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<Ident>,\n+                       opt_label: Option<ast::Ident>,\n                        id: NodeId,\n                        sp: Span)\n                        -> NodeId {\n@@ -846,7 +848,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &FnDecl, body: &Block) -> LiveNode {\n+    fn compute(&mut self, decl: &ast::FnDecl, body: &ast::Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -871,7 +873,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &FnDecl, blk: &Block)\n+    fn propagate_through_fn_block(&mut self, _: &ast::FnDecl, blk: &ast::Block)\n                                   -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -885,38 +887,38 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n+    fn propagate_through_block(&mut self, blk: &ast::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(&**stmt, succ)\n         })\n     }\n \n-    fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n+    fn propagate_through_stmt(&mut self, stmt: &ast::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            StmtDecl(ref decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 self.propagate_through_decl(&**decl, succ)\n             }\n \n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n                 self.propagate_through_expr(&**expr, succ)\n             }\n \n-            StmtMac(..) => {\n+            ast::StmtMac(..) => {\n                 self.ir.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n     }\n \n-    fn propagate_through_decl(&mut self, decl: &Decl, succ: LiveNode)\n+    fn propagate_through_decl(&mut self, decl: &ast::Decl, succ: LiveNode)\n                               -> LiveNode {\n         match decl.node {\n-            DeclLocal(ref local) => {\n+            ast::DeclLocal(ref local) => {\n                 self.propagate_through_local(&**local, succ)\n             }\n-            DeclItem(_) => succ,\n+            ast::DeclItem(_) => succ,\n         }\n     }\n \n@@ -961,21 +963,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ExprPath(_) => {\n+          ast::ExprPath(_) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ExprField(ref e, _, _) => {\n+          ast::ExprField(ref e, _, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprTupField(ref e, _, _) => {\n+          ast::ExprTupField(ref e, _, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, _, ref blk) |\n-          ExprProc(_, ref blk) |\n-          ExprUnboxedFn(_, _, _, ref blk) => {\n+          ast::ExprFnBlock(_, _, ref blk) |\n+          ast::ExprProc(_, ref blk) |\n+          ast::ExprUnboxedFn(_, _, _, ref blk) => {\n               debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n                      expr_to_string(expr));\n \n@@ -1003,7 +1005,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               })\n           }\n \n-          ExprIf(ref cond, ref then, ref els) => {\n+          ast::ExprIf(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1025,30 +1027,30 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**cond, ln)\n           }\n \n-          ExprIfLet(..) => {\n+          ast::ExprIfLet(..) => {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n           }\n \n-          ExprWhile(ref cond, ref blk, _) => {\n+          ast::ExprWhile(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n-          ExprWhileLet(..) => {\n+          ast::ExprWhileLet(..) => {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n \n-          ExprForLoop(ref pat, ref head, ref blk, _) => {\n+          ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n             let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n             self.propagate_through_expr(&**head, ln)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ExprLoop(ref blk, _) => {\n+          ast::ExprLoop(ref blk, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n           }\n \n-          ExprMatch(ref e, ref arms, _) => {\n+          ast::ExprMatch(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1083,13 +1085,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e, ln)\n           }\n \n-          ExprRet(ref o_e) => {\n+          ast::ExprRet(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          ExprBreak(opt_label) => {\n+          ast::ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1103,7 +1105,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ExprAgain(opt_label) => {\n+          ast::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1117,15 +1119,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ExprAssign(ref l, ref r) => {\n+          ast::ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n             let succ = self.propagate_through_lvalue_components(&**l, succ);\n             self.propagate_through_expr(&**r, succ)\n           }\n \n-          ExprAssignOp(_, ref l, ref r) => {\n+          ast::ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n@@ -1135,23 +1137,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVec(ref exprs) => {\n+          ast::ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprRepeat(ref element, ref count) => {\n+          ast::ExprRepeat(ref element, ref count) => {\n             let succ = self.propagate_through_expr(&**count, succ);\n             self.propagate_through_expr(&**element, succ)\n           }\n \n-          ExprStruct(_, ref fields, ref with_expr) => {\n+          ast::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&*field.expr, succ)\n             })\n           }\n \n-          ExprCall(ref f, ref args) => {\n+          ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n                 let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n                 t_ret == ty::FnDiverging\n@@ -1165,7 +1167,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**f, succ)\n           }\n \n-          ExprMethodCall(_, _, ref args) => {\n+          ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = typeck::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n             let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n@@ -1177,11 +1179,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(args.as_slice(), succ)\n           }\n \n-          ExprTup(ref exprs) => {\n+          ast::ExprTup(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1191,27 +1193,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, ln)\n           }\n \n-          ExprIndex(ref l, ref r) |\n-          ExprBinary(_, ref l, ref r) |\n-          ExprBox(ref l, ref r) => {\n+          ast::ExprIndex(ref l, ref r) |\n+          ast::ExprBinary(_, ref l, ref r) |\n+          ast::ExprBox(ref l, ref r) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n-          ExprSlice(ref e1, ref e2, ref e3, _) => {\n+          ast::ExprSlice(ref e1, ref e2, ref e3, _) => {\n             let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             self.propagate_through_expr(&**e1, succ)\n           }\n \n-          ExprAddrOf(_, ref e) |\n-          ExprCast(ref e, _) |\n-          ExprUnary(_, ref e) |\n-          ExprParen(ref e) => {\n+          ast::ExprAddrOf(_, ref e) |\n+          ast::ExprCast(ref e, _) |\n+          ast::ExprUnary(_, ref e) |\n+          ast::ExprParen(ref e) => {\n             self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprInlineAsm(ref ia) => {\n+          ast::ExprInlineAsm(ref ia) => {\n \n             let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr, _)| {\n                 // see comment on lvalues\n@@ -1225,15 +1227,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             })\n           }\n \n-          ExprLit(..) => {\n+          ast::ExprLit(..) => {\n             succ\n           }\n \n-          ExprBlock(ref blk) => {\n+          ast::ExprBlock(ref blk) => {\n             self.propagate_through_block(&**blk, succ)\n           }\n \n-          ExprMac(..) => {\n+          ast::ExprMac(..) => {\n             self.ir.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n@@ -1293,9 +1295,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            ExprPath(_) => succ,\n-            ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n-            ExprTupField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprPath(_) => succ,\n+            ast::ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprTupField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1304,7 +1306,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                     -> LiveNode {\n         match expr.node {\n-          ExprPath(_) => self.access_path(expr, succ, acc),\n+          ast::ExprPath(_) => self.access_path(expr, succ, acc),\n \n           // We do not track other lvalues, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n@@ -1333,7 +1335,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n                               kind: LoopKind,\n-                              body: &Block,\n+                              body: &ast::Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n \n@@ -1437,7 +1439,7 @@ fn check_local(this: &mut Liveness, local: &ast::Local) {\n     visit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &Arm) {\n+fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1449,20 +1451,20 @@ fn check_arm(this: &mut Liveness, arm: &Arm) {\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n-      ExprAssign(ref l, ref r) => {\n+      ast::ExprAssign(ref l, ref r) => {\n         this.check_lvalue(&**l);\n         this.visit_expr(&**r);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ExprAssignOp(_, ref l, _) => {\n+      ast::ExprAssignOp(_, ref l, _) => {\n         this.check_lvalue(&**l);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ExprInlineAsm(ref ia) => {\n+      ast::ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in ia.inputs.iter() {\n           this.visit_expr(&**input);\n         }\n@@ -1476,7 +1478,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n-      ExprForLoop(ref pat, _, _, _) => {\n+      ast::ExprForLoop(ref pat, _, _, _) => {\n         this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n             this.warn_about_unused(sp, id, ln, var);\n         });\n@@ -1485,29 +1487,31 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n-      ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n-      ExprTupField(..) | ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n-      ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n-      ExprAgain(..) | ExprLit(_) | ExprBlock(..) | ExprSlice(..) |\n-      ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n-      ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n-      ExprPath(..) | ExprBox(..) => {\n+      ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n+      ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n+      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n+      ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprBinary(..) |\n+      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprRet(..) |\n+      ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n+      ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n+      ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) |\n+      ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n         visit::walk_expr(this, expr);\n       }\n-      ExprIfLet(..) => {\n+      ast::ExprIfLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n-      ExprWhileLet(..) => {\n+      ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n     }\n }\n \n fn check_fn(_v: &Liveness,\n             _fk: FnKind,\n-            _decl: &FnDecl,\n-            _body: &Block,\n+            _decl: &ast::FnDecl,\n+            _body: &ast::Block,\n             _sp: Span,\n             _id: NodeId) {\n     // do not check contents of nested fns\n@@ -1534,7 +1538,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &Block) {\n+                 body: &ast::Block) {\n         match self.fn_ret(id) {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n@@ -1545,7 +1549,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let ends_with_stmt = match body.expr {\n                         None if body.stmts.len() > 0 =>\n                             match body.stmts.last().unwrap().node {\n-                                StmtSemi(ref e, _) => {\n+                                ast::StmtSemi(ref e, _) => {\n                                     let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n                                     ty::get(t_stmt).sty == ty::get(t_ret).sty\n                                 },\n@@ -1581,7 +1585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-          ExprPath(_) => {\n+          ast::ExprPath(_) => {\n             match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n               DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n@@ -1613,7 +1617,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &ast::FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n@@ -1628,7 +1632,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &Pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &ast::Pat) {\n         self.pat_bindings(pat, |this, ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 this.warn_about_dead_assign(sp, id, ln, var);"}, {"sha": "a51956797cad063be9f3592af784f62a505df790", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21da75066340bc36ac5086f849e959df9ae67dba/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=21da75066340bc36ac5086f849e959df9ae67dba", "patch": "@@ -13,39 +13,43 @@ use middle::resolve;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n \n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-pub type PatIdMap = FnvHashMap<Ident, NodeId>;\n+pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &resolve::DefMap, pat: &ast::Pat) -> PatIdMap {\n     let mut map = FnvHashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n }\n \n-pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatLit(_) | PatRange(_, _) => true,\n-        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n+        ast::PatLit(_) | ast::PatRange(_, _) => true,\n+        ast::PatEnum(_, _) |\n+        ast::PatIdent(_, _, None) |\n+        ast::PatStruct(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) => true,\n                 _ => false\n             }\n         }\n-        PatVec(_, _, _) => true,\n+        ast::PatVec(_, _, _) => true,\n         _ => false\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n+        ast::PatEnum(_, _) |\n+        ast::PatIdent(_, _, None) |\n+        ast::PatStruct(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n@@ -55,9 +59,9 @@ pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_const(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(_, _, None) | PatEnum(..) => {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) => true,\n                 _ => false\n@@ -67,32 +71,32 @@ pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(..) => {\n+        ast::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(..) => pat_is_binding(dm, pat),\n-        PatWild(_) => true,\n+        ast::PatIdent(..) => pat_is_binding(dm, pat),\n+        ast::PatWild(_) => true,\n         _ => false\n     }\n }\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings(dm: &resolve::DefMap,\n-                    pat: &Pat,\n-                    it: |BindingMode, NodeId, Span, &SpannedIdent|) {\n+                    pat: &ast::Pat,\n+                    it: |ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent|) {\n     walk_pat(pat, |p| {\n         match p.node {\n-          PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          ast::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n@@ -103,7 +107,7 @@ pub fn pat_bindings(dm: &resolve::DefMap,\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n@@ -116,9 +120,9 @@ pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n+pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n-        PatIdent(BindByValue(_), ref path1, None) => {\n+        ast::PatIdent(ast::BindByValue(_), ref path1, None) => {\n             Some(&path1.node)\n         }\n         _ => {\n@@ -127,12 +131,12 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     }\n }\n \n-pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |mut path| Path {\n+pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n+    ty::with_path(tcx, id, |mut path| ast::Path {\n         global: false,\n-        segments: path.last().map(|elem| PathSegment {\n-            identifier: Ident::new(elem.name()),\n-            parameters: PathParameters::none(),\n+        segments: path.last().map(|elem| ast::PathSegment {\n+            identifier: ast::Ident::new(elem.name()),\n+            parameters: ast::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })"}]}