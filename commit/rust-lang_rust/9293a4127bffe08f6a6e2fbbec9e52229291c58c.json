{"sha": "9293a4127bffe08f6a6e2fbbec9e52229291c58c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOTNhNDEyN2JmZmUwOGY2YTZlMmZiYmVjOWU1MjIyOTI5MWM1OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T04:36:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T04:36:31Z"}, "message": "auto merge of #9744 : DaGenix/rust/remove-crypto, r=alexcrichton\n\nRemove the Sha1, Sha2, MD5, and MD4 algorithms. SipHash is also cryptographically secure hash function and IsaacRng is a cryptographically secure RNG - I left those alone but removed comments that implied they were suitable for cryptographic use. I thought that MD4 was used for something by the compiler, but everything still seems to work with it removed, so, I guess not.\r\n\r\nOne thing that I'm not sure about - workcache.rs and workcache_support.rs (in librustpkg) both depend on Sha1. Without Sha1, the only hash function left is SipHash, so I switched that code over to use SipHash. The output size of SipHash is only 64-bits, however - much less than 160 for Sha1. I'm not sure this is a problem. Without other cryptographic hashes in the tree, I'm not sure what else to do. I considered moved Sha1 into librustpkg, but I don't know if that makes sense.\r\n\r\nIf merged, this closes #9300.", "tree": {"sha": "d98502523443d61b9b97731e7fef61cf2c1a179f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d98502523443d61b9b97731e7fef61cf2c1a179f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9293a4127bffe08f6a6e2fbbec9e52229291c58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9293a4127bffe08f6a6e2fbbec9e52229291c58c", "html_url": "https://github.com/rust-lang/rust/commit/9293a4127bffe08f6a6e2fbbec9e52229291c58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9293a4127bffe08f6a6e2fbbec9e52229291c58c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d664ca26357fad84b4bc48f903f4795d491ccfd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d664ca26357fad84b4bc48f903f4795d491ccfd1", "html_url": "https://github.com/rust-lang/rust/commit/d664ca26357fad84b4bc48f903f4795d491ccfd1"}, {"sha": "2d5cb5d99a68d9b603675b1c4284dbe37333332c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5cb5d99a68d9b603675b1c4284dbe37333332c", "html_url": "https://github.com/rust-lang/rust/commit/2d5cb5d99a68d9b603675b1c4284dbe37333332c"}], "stats": {"total": 3041, "additions": 655, "deletions": 2386}, "files": [{"sha": "bb3524a7d490263f0c138e02266886f91505deed", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "removed", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,428 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::num::{One, Zero, CheckedAdd};\n-use std::vec::bytes::{MutableByteVector, copy_memory};\n-\n-\n-/// Write a u64 into a vector, which must be 8 bytes long. The value is written in big-endian\n-/// format.\n-pub fn write_u64_be(dst: &mut[u8], input: u64) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be64;\n-    assert!(dst.len() == 8);\n-    unsafe {\n-        let x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be64(input as i64);\n-    }\n-}\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n-/// format.\n-pub fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be32(input as i32);\n-    }\n-}\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in little-endian\n-/// format.\n-pub fn write_u32_le(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_le32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_le32(input as i32);\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u64s. The values are read in big-endian format.\n-pub fn read_u64v_be(dst: &mut[u64], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be64;\n-    assert!(dst.len() * 8 == input.len());\n-    unsafe {\n-        let mut x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i64 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_be64(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n-pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_be32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in little-endian format.\n-pub fn read_u32v_le(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_le32;\n-    assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_le32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n-\n-trait ToBits {\n-    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n-    /// high-order value and the 2nd item is the low order value.\n-    fn to_bits(self) -> (Self, Self);\n-}\n-\n-impl ToBits for u64 {\n-    fn to_bits(self) -> (u64, u64) {\n-        return (self >> 61, self << 3);\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n-/// overflow.\n-pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-\n-    if new_high_bits > Zero::zero() {\n-        fail!(\"Numeric overflow occured.\")\n-    }\n-\n-    match bits.checked_add(&new_low_bits) {\n-        Some(x) => return x,\n-        None => fail!(\"Numeric overflow occured.\")\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n-/// the high order value. fail!() if this would cause numeric overflow.\n-pub fn add_bytes_to_bits_tuple\n-        <T: Int + Unsigned + CheckedAdd + ToBits>\n-        (bits: (T, T), bytes: T) -> (T, T) {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-    let (hi, low) = bits;\n-\n-    // Add the low order value - if there is no overflow, then add the high order values\n-    // If the addition of the low order values causes overflow, add one to the high order values\n-    // before adding them.\n-    match low.checked_add(&new_low_bits) {\n-        Some(x) => {\n-            if new_high_bits == Zero::zero() {\n-                // This is the fast path - every other alternative will rarely occur in practice\n-                // considering how large an input would need to be for those paths to be used.\n-                return (hi, x);\n-            } else {\n-                match hi.checked_add(&new_high_bits) {\n-                    Some(y) => return (y, x),\n-                    None => fail!(\"Numeric overflow occured.\")\n-                }\n-            }\n-        },\n-        None => {\n-            let one: T = One::one();\n-            let z = match new_high_bits.checked_add(&one) {\n-                Some(w) => w,\n-                None => fail!(\"Numeric overflow occured.\")\n-            };\n-            match hi.checked_add(&z) {\n-                // This re-executes the addition that was already performed earlier when overflow\n-                // occured, this time allowing the overflow to happen. Technically, this could be\n-                // avoided by using the checked add intrinsic directly, but that involves using\n-                // unsafe code and is not really worthwhile considering how infrequently code will\n-                // run in practice. This is the reason that this function requires that the type T\n-                // be Unsigned - overflow is not defined for Signed types. This function could be\n-                // implemented for signed types as well if that were needed.\n-                Some(y) => return (y, low + new_low_bits),\n-                None => fail!(\"Numeric overflow occured.\")\n-            }\n-        }\n-    }\n-}\n-\n-\n-/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n-/// must be processed. The input() method takes care of processing and then clearing the buffer\n-/// automatically. However, other methods do not and require the caller to process the buffer. Any\n-/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n-/// results in those bytes being marked as used by the buffer.\n-pub trait FixedBuffer {\n-    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n-    /// function and then clear the buffer.\n-    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n-\n-    /// Reset the buffer.\n-    fn reset(&mut self);\n-\n-    /// Zero the buffer up until the specified index. The buffer position currently must not be\n-    /// greater than that index.\n-    fn zero_until(&mut self, idx: uint);\n-\n-    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n-    /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n-\n-    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n-\n-    /// Get the current position of the buffer.\n-    fn position(&self) -> uint;\n-\n-    /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> uint;\n-\n-    /// Get the size of the buffer\n-    fn size(&self) -> uint;\n-}\n-\n-macro_rules! impl_fixed_buffer( ($name:ident, $size:expr) => (\n-    impl FixedBuffer for $name {\n-        fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n-            let mut i = 0;\n-\n-            // FIXME: #6304 - This local variable shouldn't be necessary.\n-            let size = $size;\n-\n-            // If there is already data in the buffer, copy as much as we can into it and process\n-            // the data if the buffer becomes full.\n-            if self.buffer_idx != 0 {\n-                let buffer_remaining = size - self.buffer_idx;\n-                if input.len() >= buffer_remaining {\n-                        copy_memory(\n-                            self.buffer.mut_slice(self.buffer_idx, size),\n-                            input.slice_to(buffer_remaining),\n-                            buffer_remaining);\n-                    self.buffer_idx = 0;\n-                    func(self.buffer);\n-                    i += buffer_remaining;\n-                } else {\n-                    copy_memory(\n-                        self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                        input,\n-                        input.len());\n-                    self.buffer_idx += input.len();\n-                    return;\n-                }\n-            }\n-\n-            // While we have at least a full buffer size chunks's worth of data, process that data\n-            // without copying it into the buffer\n-            while input.len() - i >= size {\n-                func(input.slice(i, i + size));\n-                i += size;\n-            }\n-\n-            // Copy any input data into the buffer. At this point in the method, the ammount of\n-            // data left in the input vector will be less than the buffer size and the buffer will\n-            // be empty.\n-            let input_remaining = input.len() - i;\n-            copy_memory(\n-                self.buffer.mut_slice(0, input_remaining),\n-                input.slice_from(i),\n-                input.len() - i);\n-            self.buffer_idx += input_remaining;\n-        }\n-\n-        fn reset(&mut self) {\n-            self.buffer_idx = 0;\n-        }\n-\n-        fn zero_until(&mut self, idx: uint) {\n-            assert!(idx >= self.buffer_idx);\n-            self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n-            self.buffer_idx = idx;\n-        }\n-\n-        fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n-            self.buffer_idx += len;\n-            return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n-        }\n-\n-        fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-            assert!(self.buffer_idx == $size);\n-            self.buffer_idx = 0;\n-            return self.buffer.slice_to($size);\n-        }\n-\n-        fn position(&self) -> uint { self.buffer_idx }\n-\n-        fn remaining(&self) -> uint { $size - self.buffer_idx }\n-\n-        fn size(&self) -> uint { $size }\n-    }\n-))\n-\n-\n-/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n-pub struct FixedBuffer64 {\n-    priv buffer: [u8, ..64],\n-    priv buffer_idx: uint,\n-}\n-\n-impl FixedBuffer64 {\n-    /// Create a new buffer\n-    pub fn new() -> FixedBuffer64 {\n-        return FixedBuffer64 {\n-            buffer: [0u8, ..64],\n-            buffer_idx: 0\n-        };\n-    }\n-}\n-\n-impl_fixed_buffer!(FixedBuffer64, 64)\n-\n-/// A fixed size buffer of 128 bytes useful for cryptographic operations.\n-pub struct FixedBuffer128 {\n-    priv buffer: [u8, ..128],\n-    priv buffer_idx: uint,\n-}\n-\n-impl FixedBuffer128 {\n-    /// Create a new buffer\n-    pub fn new() -> FixedBuffer128 {\n-        return FixedBuffer128 {\n-            buffer: [0u8, ..128],\n-            buffer_idx: 0\n-        };\n-    }\n-}\n-\n-impl_fixed_buffer!(FixedBuffer128, 128)\n-\n-\n-/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n-/// struct.\n-pub trait StandardPadding {\n-    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n-    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n-    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n-    /// filled with zeros again until only rem bytes are remaining.\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n-}\n-\n-impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n-        let size = self.size();\n-\n-        self.next(1)[0] = 128;\n-\n-        if self.remaining() < rem {\n-            self.zero_until(size);\n-            func(self.full_buffer());\n-        }\n-\n-        self.zero_until(size - rem);\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-pub mod test {\n-    use std::rand::{IsaacRng, Rng};\n-    use std::vec;\n-\n-    use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n-    use digest::Digest;\n-    use hex::FromHex;\n-\n-    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n-    /// correct.\n-    pub fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n-        let total_size = 1000000;\n-        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n-        let mut rng = IsaacRng::new_unseeded();\n-        let mut count = 0;\n-\n-        digest.reset();\n-\n-        while count < total_size {\n-            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n-            let remaining = total_size - count;\n-            let size = if next > remaining { remaining } else { next };\n-            digest.input(buffer.slice_to(size));\n-            count += size;\n-        }\n-\n-        let result_str = digest.result_str();\n-        let result_bytes = digest.result_bytes();\n-\n-        assert_eq!(expected, result_str.as_slice());\n-        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n-    }\n-\n-    // A normal addition - no overflow occurs\n-    #[test]\n-    fn test_add_bytes_to_bits_ok() {\n-        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_overflow() {\n-        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n-    }\n-\n-    // A normal addition - no overflow occurs (fast path)\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, 100), 10) == (5, 180));\n-    }\n-\n-    // The low order value overflows into the high order value\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok2() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, Bounded::max_value()), 1) == (6, 7));\n-    }\n-\n-    // The value to add is too large to be converted into bits without overflowing its type\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok3() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, 0), 0x4000000000000001) == (7, 8));\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_tuple_overflow() {\n-        add_bytes_to_bits_tuple::<u64>((Bounded::max_value(), Bounded::max_value()), 1);\n-    }\n-\n-    // The value to add is too large to convert to bytes without overflowing its type, but the high\n-    // order value from this conversion overflows when added to the existing high order value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_tuple_overflow2() {\n-        let value: u64 = Bounded::max_value();\n-        add_bytes_to_bits_tuple::<u64>((value - 1, 0), 0x8000000000000000);\n-    }\n-}"}, {"sha": "372e2313de7b22aa4cd5e7828448678c6ee587d1", "filename": "src/libextra/crypto/digest.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Common functionality related to cryptographic digest functions\n-\n-use std::vec;\n-\n-use hex::ToHex;\n-\n-\n-/**\n- * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n- * family of digest functions.\n- */\n-pub trait Digest {\n-    /**\n-     * Provide message data.\n-     *\n-     * # Arguments\n-     *\n-     * * input - A vector of message data\n-     */\n-    fn input(&mut self, input: &[u8]);\n-\n-    /**\n-     * Retrieve the digest result. This method may be called multiple times.\n-     *\n-     * # Arguments\n-     *\n-     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n-     */\n-    fn result(&mut self, out: &mut [u8]);\n-\n-    /**\n-     * Reset the digest. This method must be called after result() and before supplying more\n-     * data.\n-     */\n-    fn reset(&mut self);\n-\n-    /**\n-     * Get the output size in bits.\n-     */\n-    fn output_bits(&self) -> uint;\n-\n-    /**\n-     * Convenience function that feeds a string into a digest.\n-     *\n-     * # Arguments\n-     *\n-     * * `input` The string to feed into the digest\n-     */\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * newly allocated vec of bytes.\n-     */\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n-        self.result(buf);\n-        buf\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * ~str in hexadecimal format.\n-     */\n-    fn result_str(&mut self) -> ~str {\n-        self.result_bytes().to_hex()\n-    }\n-}\n-"}, {"sha": "864fc64f82bec9af50535848e15389f0d777f387", "filename": "src/libextra/crypto/md5.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,327 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::iter::range_step;\n-\n-use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};\n-use digest::Digest;\n-\n-\n-// A structure that represents that state of a digest computation for the MD5 digest function\n-struct Md5State {\n-    s0: u32,\n-    s1: u32,\n-    s2: u32,\n-    s3: u32\n-}\n-\n-impl Md5State {\n-    fn new() -> Md5State {\n-        return Md5State {\n-            s0: 0x67452301,\n-            s1: 0xefcdab89,\n-            s2: 0x98badcfe,\n-            s3: 0x10325476\n-        };\n-    }\n-\n-    fn reset(&mut self) {\n-        self.s0 = 0x67452301;\n-        self.s1 = 0xefcdab89;\n-        self.s2 = 0x98badcfe;\n-        self.s3 = 0x10325476;\n-    }\n-\n-    fn process_block(&mut self, input: &[u8]) {\n-        fn f(u: u32, v: u32, w: u32) -> u32 {\n-            return (u & v) | (!u & w);\n-        }\n-\n-        fn g(u: u32, v: u32, w: u32) -> u32 {\n-            return (u & w) | (v & !w);\n-        }\n-\n-        fn h(u: u32, v: u32, w: u32) -> u32 {\n-            return u ^ v ^ w;\n-        }\n-\n-        fn i(u: u32, v: u32, w: u32) -> u32 {\n-            return v ^ (u | !w);\n-        }\n-\n-        fn rotate_left(x: u32, n: u32) -> u32 {\n-            return (x << n) | (x >> (32 - n));\n-        }\n-\n-        fn op_f(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + f(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_g(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + g(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_h(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + h(x, y, z) + m, s) + x;\n-        }\n-\n-        fn op_i(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n-            return rotate_left(w + i(x, y, z) + m, s) + x;\n-        }\n-\n-        let mut a = self.s0;\n-        let mut b = self.s1;\n-        let mut c = self.s2;\n-        let mut d = self.s3;\n-\n-        let mut data = [0u32, ..16];\n-\n-        read_u32v_le(data, input);\n-\n-        // round 1\n-        for i in range_step(0u, 16, 4) {\n-            a = op_f(a, b, c, d, data[i] + C1[i], 7);\n-            d = op_f(d, a, b, c, data[i + 1] + C1[i + 1], 12);\n-            c = op_f(c, d, a, b, data[i + 2] + C1[i + 2], 17);\n-            b = op_f(b, c, d, a, data[i + 3] + C1[i + 3], 22);\n-        }\n-\n-        // round 2\n-        let mut t = 1;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_g(a, b, c, d, data[t & 0x0f] + C2[i], 5);\n-            d = op_g(d, a, b, c, data[(t + 5) & 0x0f] + C2[i + 1], 9);\n-            c = op_g(c, d, a, b, data[(t + 10) & 0x0f] + C2[i + 2], 14);\n-            b = op_g(b, c, d, a, data[(t + 15) & 0x0f] + C2[i + 3], 20);\n-            t += 20;\n-        }\n-\n-        // round 3\n-        t = 5;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_h(a, b, c, d, data[t & 0x0f] + C3[i], 4);\n-            d = op_h(d, a, b, c, data[(t + 3) & 0x0f] + C3[i + 1], 11);\n-            c = op_h(c, d, a, b, data[(t + 6) & 0x0f] + C3[i + 2], 16);\n-            b = op_h(b, c, d, a, data[(t + 9) & 0x0f] + C3[i + 3], 23);\n-            t += 12;\n-        }\n-\n-        // round 4\n-        t = 0;\n-        for i in range_step(0u, 16, 4) {\n-            a = op_i(a, b, c, d, data[t & 0x0f] + C4[i], 6);\n-            d = op_i(d, a, b, c, data[(t + 7) & 0x0f] + C4[i + 1], 10);\n-            c = op_i(c, d, a, b, data[(t + 14) & 0x0f] + C4[i + 2], 15);\n-            b = op_i(b, c, d, a, data[(t + 21) & 0x0f] + C4[i + 3], 21);\n-            t += 28;\n-        }\n-\n-        self.s0 += a;\n-        self.s1 += b;\n-        self.s2 += c;\n-        self.s3 += d;\n-    }\n-}\n-\n-// Round 1 constants\n-static C1: [u32, ..16] = [\n-    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n-    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821\n-];\n-\n-// Round 2 constants\n-static C2: [u32, ..16] = [\n-    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n-    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a\n-];\n-\n-// Round 3 constants\n-static C3: [u32, ..16] = [\n-    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n-    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665\n-];\n-\n-// Round 4 constants\n-static C4: [u32, ..16] = [\n-    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n-    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n-];\n-\n-\n-/// The MD5 Digest algorithm\n-pub struct Md5 {\n-    priv length_bytes: u64,\n-    priv buffer: FixedBuffer64,\n-    priv state: Md5State,\n-    priv finished: bool,\n-}\n-\n-impl Md5 {\n-    /// Construct a new instance of the MD5 Digest.\n-    pub fn new() -> Md5 {\n-        return Md5 {\n-            length_bytes: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Md5State::new(),\n-            finished: false\n-        }\n-    }\n-}\n-\n-impl Digest for Md5 {\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished);\n-        // Unlike Sha1 and Sha2, the length value in MD5 is defined as the length of the message mod\n-        // 2^64 - ie: integer overflow is OK.\n-        self.length_bytes += input.len() as u64;\n-        self.buffer.input(input, |d: &[u8]| { self.state.process_block(d); });\n-    }\n-\n-    fn reset(&mut self) {\n-        self.length_bytes = 0;\n-        self.buffer.reset();\n-        self.state.reset();\n-        self.finished = false;\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        if !self.finished {\n-            self.buffer.standard_padding(8, |d: &[u8]| { self.state.process_block(d); });\n-            write_u32_le(self.buffer.next(4), (self.length_bytes << 3) as u32);\n-            write_u32_le(self.buffer.next(4), (self.length_bytes >> 29) as u32);\n-            self.state.process_block(self.buffer.full_buffer());\n-            self.finished = true;\n-        }\n-\n-        write_u32_le(out.mut_slice(0, 4), self.state.s0);\n-        write_u32_le(out.mut_slice(4, 8), self.state.s1);\n-        write_u32_le(out.mut_slice(8, 12), self.state.s2);\n-        write_u32_le(out.mut_slice(12, 16), self.state.s3);\n-    }\n-\n-    fn output_bits(&self) -> uint { 128 }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use md5::Md5;\n-\n-\n-    struct Test {\n-        input: ~str,\n-        output_str: ~str,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n-            sh.input_str(t.input);\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_md5() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"d41d8cd98f00b204e9800998ecf8427e\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"9e107d9d372bb6826bd81d3542a419d6\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"e4d909c290d0fb1ca068ffaddf22cbd0\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = Md5::new();\n-\n-        test_hash(&mut sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_md5() {\n-        let mut sh = Md5::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"7707d6ae4e027c70eea2a935c2296f21\");\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod bench {\n-    use extra::test::BenchHarness;\n-\n-    use md5::Md5;\n-\n-\n-    #[bench]\n-    pub fn md5_10(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn md5_1k(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn md5_64k(bh: & mut BenchHarness) {\n-        let mut sh = Md5::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-}"}, {"sha": "4d4d47feee817c0bb07f4136215d88c327ad027f", "filename": "src/libextra/crypto/sha1.rs", "status": "removed", "additions": 0, "deletions": 332, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,332 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * An implementation of the SHA-1 cryptographic hash.\n- *\n- * First create a `sha1` object using the `sha1` constructor, then\n- * feed it input using the `input` or `input_str` methods, which may be\n- * called any number of times.\n- *\n- * After the entire input has been fed to the hash read the result using\n- * the `result` or `result_str` methods.\n- *\n- * The `sha1` object may be reused to create multiple hashes by calling\n- * the `reset` method.\n- */\n-\n-\n-use cryptoutil::{write_u32_be, read_u32v_be, add_bytes_to_bits, FixedBuffer, FixedBuffer64,\n-    StandardPadding};\n-use digest::Digest;\n-\n-/*\n- * A SHA-1 implementation derived from Paul E. Jones's reference\n- * implementation, which is written for clarity, not speed. At some\n- * point this will want to be rewritten.\n- */\n-\n-// Some unexported constants\n-static DIGEST_BUF_LEN: uint = 5u;\n-static WORK_BUF_LEN: uint = 80u;\n-static K0: u32 = 0x5A827999u32;\n-static K1: u32 = 0x6ED9EBA1u32;\n-static K2: u32 = 0x8F1BBCDCu32;\n-static K3: u32 = 0xCA62C1D6u32;\n-\n-/// Structure representing the state of a Sha1 computation\n-pub struct Sha1 {\n-    priv h: [u32, ..DIGEST_BUF_LEN],\n-    priv length_bits: u64,\n-    priv buffer: FixedBuffer64,\n-    priv computed: bool,\n-}\n-\n-fn add_input(st: &mut Sha1, msg: &[u8]) {\n-    assert!((!st.computed));\n-    // Assumes that msg.len() can be converted to u64 without overflow\n-    st.length_bits = add_bytes_to_bits(st.length_bits, msg.len() as u64);\n-    st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n-}\n-\n-fn process_msg_block(data: &[u8], h: &mut [u32, ..DIGEST_BUF_LEN]) {\n-    let mut t: int; // Loop counter\n-\n-    let mut w = [0u32, ..WORK_BUF_LEN];\n-\n-    // Initialize the first 16 words of the vector w\n-    read_u32v_be(w.mut_slice(0, 16), data);\n-\n-    // Initialize the rest of vector w\n-    t = 16;\n-    while t < 80 {\n-        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n-        w[t] = circular_shift(1, val);\n-        t += 1;\n-    }\n-    let mut a = h[0];\n-    let mut b = h[1];\n-    let mut c = h[2];\n-    let mut d = h[3];\n-    let mut e = h[4];\n-    let mut temp: u32;\n-    t = 0;\n-    while t < 20 {\n-        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 40 {\n-        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 60 {\n-        temp =\n-            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n-                K2;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    while t < 80 {\n-        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n-        e = d;\n-        d = c;\n-        c = circular_shift(30, b);\n-        b = a;\n-        a = temp;\n-        t += 1;\n-    }\n-    h[0] += a;\n-    h[1] += b;\n-    h[2] += c;\n-    h[3] += d;\n-    h[4] += e;\n-}\n-\n-fn circular_shift(bits: u32, word: u32) -> u32 {\n-    return word << bits | word >> 32u32 - bits;\n-}\n-\n-fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n-    if !st.computed {\n-        st.buffer.standard_padding(8, |d: &[u8]| { process_msg_block(d, &mut st.h) });\n-        write_u32_be(st.buffer.next(4), (st.length_bits >> 32) as u32 );\n-        write_u32_be(st.buffer.next(4), st.length_bits as u32);\n-        process_msg_block(st.buffer.full_buffer(), &mut st.h);\n-\n-        st.computed = true;\n-    }\n-\n-    write_u32_be(rs.mut_slice(0, 4), st.h[0]);\n-    write_u32_be(rs.mut_slice(4, 8), st.h[1]);\n-    write_u32_be(rs.mut_slice(8, 12), st.h[2]);\n-    write_u32_be(rs.mut_slice(12, 16), st.h[3]);\n-    write_u32_be(rs.mut_slice(16, 20), st.h[4]);\n-}\n-\n-impl Sha1 {\n-    /// Construct a `sha` object\n-    pub fn new() -> Sha1 {\n-        let mut st = Sha1 {\n-            h: [0u32, ..DIGEST_BUF_LEN],\n-            length_bits: 0u64,\n-            buffer: FixedBuffer64::new(),\n-            computed: false,\n-        };\n-        st.reset();\n-        return st;\n-    }\n-}\n-\n-impl Digest for Sha1 {\n-    fn reset(&mut self) {\n-        self.length_bits = 0;\n-        self.h[0] = 0x67452301u32;\n-        self.h[1] = 0xEFCDAB89u32;\n-        self.h[2] = 0x98BADCFEu32;\n-        self.h[3] = 0x10325476u32;\n-        self.h[4] = 0xC3D2E1F0u32;\n-        self.buffer.reset();\n-        self.computed = false;\n-    }\n-    fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n-    fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n-    fn output_bits(&self) -> uint { 160 }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use sha1::Sha1;\n-\n-    #[deriving(Clone)]\n-    struct Test {\n-        input: ~str,\n-        output: ~[u8],\n-        output_str: ~str,\n-    }\n-\n-    #[test]\n-    fn test() {\n-        // Test messages from FIPS 180-1\n-\n-        let fips_180_1_tests = ~[\n-            Test {\n-                input: ~\"abc\",\n-                output: ~[\n-                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                ],\n-                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-            },\n-            Test {\n-                input:\n-                     ~\"abcdbcdecdefdefgefghfghighij\" +\n-                     \"hijkijkljklmklmnlmnomnopnopq\",\n-                output: ~[\n-                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                ],\n-                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-            },\n-        ];\n-        // Examples from wikipedia\n-\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output: ~[\n-                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                ],\n-                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy cog\",\n-                output: ~[\n-                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                ],\n-                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-            },\n-        ];\n-        let tests = fips_180_1_tests + wikipedia_tests;\n-\n-        // Test that it works when accepting the message all at once\n-\n-        let mut out = [0u8, ..20];\n-\n-        let mut sh = ~Sha1::new();\n-        for t in tests.iter() {\n-            (*sh).input_str(t.input);\n-            sh.result(out);\n-            assert!(t.output.as_slice() == out);\n-\n-            let out_str = (*sh).result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                (*sh).input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-            sh.result(out);\n-            assert!(t.output.as_slice() == out);\n-\n-            let out_str = (*sh).result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha1() {\n-        let mut sh = Sha1::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-\n-    use sha1::Sha1;\n-    use test::BenchHarness;\n-\n-    #[bench]\n-    pub fn sha1_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha1_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha1_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha1::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-}"}, {"sha": "fb9a6df50e48c21df37b6f4e3b46ba8c2184e52c", "filename": "src/libextra/crypto/sha2.rs", "status": "removed", "additions": 0, "deletions": 1033, "changes": 1033, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,1033 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::iter::range_step;\n-\n-use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,\n-    add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n-use digest::Digest;\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family\n-// of digest functions\n-struct Engine512State {\n-    H0: u64,\n-    H1: u64,\n-    H2: u64,\n-    H3: u64,\n-    H4: u64,\n-    H5: u64,\n-    H6: u64,\n-    H7: u64,\n-}\n-\n-impl Engine512State {\n-    fn new(h: &[u64, ..8]) -> Engine512State {\n-        return Engine512State {\n-            H0: h[0],\n-            H1: h[1],\n-            H2: h[2],\n-            H3: h[3],\n-            H4: h[4],\n-            H5: h[5],\n-            H6: h[6],\n-            H7: h[7]\n-        };\n-    }\n-\n-    fn reset(&mut self, h: &[u64, ..8]) {\n-        self.H0 = h[0];\n-        self.H1 = h[1];\n-        self.H2 = h[2];\n-        self.H3 = h[3];\n-        self.H4 = h[4];\n-        self.H5 = h[5];\n-        self.H6 = h[6];\n-        self.H7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u64, y: u64, z: u64) -> u64 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u64, y: u64, z: u64) -> u64 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u64) -> u64 {\n-            ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39))\n-        }\n-\n-        fn sum1(x: u64) -> u64 {\n-            ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41))\n-        }\n-\n-        fn sigma0(x: u64) -> u64 {\n-            ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n-        }\n-\n-        fn sigma1(x: u64) -> u64 {\n-            ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n-        }\n-\n-        let mut a = self.H0;\n-        let mut b = self.H1;\n-        let mut c = self.H2;\n-        let mut d = self.H3;\n-        let mut e = self.H4;\n-        let mut f = self.H5;\n-        let mut g = self.H6;\n-        let mut h = self.H7;\n-\n-        let mut W = [0u64, ..80];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented by\n-        // these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n-                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n-                )\n-        )\n-\n-        macro_rules! sha2_round(\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n-                }\n-             )\n-        )\n-\n-\n-        read_u64v_be(W.mut_slice(0, 16), data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in range_step(0u, 64, 8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n-\n-        for t in range_step(64u, 80, 8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n-        }\n-\n-        self.H0 += a;\n-        self.H1 += b;\n-        self.H2 += c;\n-        self.H3 += d;\n-        self.H4 += e;\n-        self.H5 += f;\n-        self.H6 += g;\n-        self.H7 += h;\n-    }\n-}\n-\n-// Constants necessary for SHA-2 512 family of digests.\n-static K64: [u64, ..80] = [\n-    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n-    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n-    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n-    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n-    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n-    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n-    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n-    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n-    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n-    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n-    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n-    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n-    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n-    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n-    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n-    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n-    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n-    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n-    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n-    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n-];\n-\n-\n-// A structure that keeps track of the state of the Sha-512 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine512 {\n-    length_bits: (u64, u64),\n-    buffer: FixedBuffer128,\n-    state: Engine512State,\n-    finished: bool,\n-}\n-\n-impl Engine512 {\n-    fn new(h: &[u64, ..8]) -> Engine512 {\n-        return Engine512 {\n-            length_bits: (0, 0),\n-            buffer: FixedBuffer128::new(),\n-            state: Engine512State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u64, ..8]) {\n-        self.length_bits = (0, 0);\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits_tuple(self.length_bits, input.len() as u64);\n-        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if self.finished {\n-            return;\n-        }\n-\n-        self.buffer.standard_padding(16, |input: &[u8]| { self.state.process_block(input) });\n-        match self.length_bits {\n-            (hi, low) => {\n-                write_u64_be(self.buffer.next(8), hi);\n-                write_u64_be(self.buffer.next(8), low);\n-            }\n-        }\n-        self.state.process_block(self.buffer.full_buffer());\n-\n-        self.finished = true;\n-    }\n-}\n-\n-\n-/// The SHA-512 hash algorithm\n-pub struct Sha512 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512 {\n-    /**\n-     * Construct an new instance of a SHA-512 digest.\n-     */\n-    pub fn new() -> Sha512 {\n-        return Sha512 {\n-            engine: Engine512::new(&H512)\n-        };\n-    }\n-}\n-\n-impl Digest for Sha512 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n-        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n-        write_u64_be(out.mut_slice(48, 56), self.engine.state.H6);\n-        write_u64_be(out.mut_slice(56, 64), self.engine.state.H7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512);\n-    }\n-\n-    fn output_bits(&self) -> uint { 512 }\n-}\n-\n-static H512: [u64, ..8] = [\n-    0x6a09e667f3bcc908,\n-    0xbb67ae8584caa73b,\n-    0x3c6ef372fe94f82b,\n-    0xa54ff53a5f1d36f1,\n-    0x510e527fade682d1,\n-    0x9b05688c2b3e6c1f,\n-    0x1f83d9abfb41bd6b,\n-    0x5be0cd19137e2179\n-];\n-\n-\n-/// The SHA-384 hash algorithm\n-pub struct Sha384 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha384 {\n-    /**\n-     * Construct an new instance of a SHA-384 digest.\n-     */\n-    pub fn new() -> Sha384 {\n-        Sha384 {\n-            engine: Engine512::new(&H384)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha384 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n-        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H384);\n-    }\n-\n-    fn output_bits(&self) -> uint { 384 }\n-}\n-\n-static H384: [u64, ..8] = [\n-    0xcbbb9d5dc1059ed8,\n-    0x629a292a367cd507,\n-    0x9159015a3070dd17,\n-    0x152fecd8f70e5939,\n-    0x67332667ffc00b31,\n-    0x8eb44a8768581511,\n-    0xdb0c2e0d64f98fa7,\n-    0x47b5481dbefa4fa4\n-];\n-\n-\n-/// The SHA-512 hash algorithm with digest truncated to 256 bits\n-pub struct Sha512Trunc256 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512Trunc256 {\n-    /**\n-     * Construct an new instance of a SHA-512/256 digest.\n-     */\n-    pub fn new() -> Sha512Trunc256 {\n-        Sha512Trunc256 {\n-            engine: Engine512::new(&H512_TRUNC_256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha512Trunc256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512_TRUNC_256);\n-    }\n-\n-    fn output_bits(&self) -> uint { 256 }\n-}\n-\n-static H512_TRUNC_256: [u64, ..8] = [\n-    0x22312194fc2bf72c,\n-    0x9f555fa3c84c64c2,\n-    0x2393b86b6f53b151,\n-    0x963877195940eabd,\n-    0x96283ee2a88effe3,\n-    0xbe5e1e2553863992,\n-    0x2b0199fc2c85b8aa,\n-    0x0eb72ddc81c52ca2\n-];\n-\n-\n-/// The SHA-512 hash algorithm with digest truncated to 224 bits\n-pub struct Sha512Trunc224 {\n-    priv engine: Engine512\n-}\n-\n-impl Sha512Trunc224 {\n-    /**\n-     * Construct an new instance of a SHA-512/224 digest.\n-     */\n-    pub fn new() -> Sha512Trunc224 {\n-        Sha512Trunc224 {\n-            engine: Engine512::new(&H512_TRUNC_224)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha512Trunc224 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n-        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n-        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(24, 28), (self.engine.state.H3 >> 32) as u32);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H512_TRUNC_224);\n-    }\n-\n-    fn output_bits(&self) -> uint { 224 }\n-}\n-\n-static H512_TRUNC_224: [u64, ..8] = [\n-    0x8c3d37c819544da2,\n-    0x73e1996689dcd4d6,\n-    0x1dfab7ae32ff9c82,\n-    0x679dd514582f9fcf,\n-    0x0f6d2b697bd44da8,\n-    0x77e36f7304c48942,\n-    0x3f9d85a86a1d36c8,\n-    0x1112e6ad91d692a1,\n-];\n-\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n-// functions\n-struct Engine256State {\n-    H0: u32,\n-    H1: u32,\n-    H2: u32,\n-    H3: u32,\n-    H4: u32,\n-    H5: u32,\n-    H6: u32,\n-    H7: u32,\n-}\n-\n-impl Engine256State {\n-    fn new(h: &[u32, ..8]) -> Engine256State {\n-        return Engine256State {\n-            H0: h[0],\n-            H1: h[1],\n-            H2: h[2],\n-            H3: h[3],\n-            H4: h[4],\n-            H5: h[5],\n-            H6: h[6],\n-            H7: h[7]\n-        };\n-    }\n-\n-    fn reset(&mut self, h: &[u32, ..8]) {\n-        self.H0 = h[0];\n-        self.H1 = h[1];\n-        self.H2 = h[2];\n-        self.H3 = h[3];\n-        self.H4 = h[4];\n-        self.H5 = h[5];\n-        self.H6 = h[6];\n-        self.H7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u32) -> u32 {\n-            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n-        }\n-\n-        fn sum1(x: u32) -> u32 {\n-            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n-        }\n-\n-        fn sigma0(x: u32) -> u32 {\n-            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n-        }\n-\n-        fn sigma1(x: u32) -> u32 {\n-            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n-        }\n-\n-        let mut a = self.H0;\n-        let mut b = self.H1;\n-        let mut c = self.H2;\n-        let mut d = self.H3;\n-        let mut e = self.H4;\n-        let mut f = self.H5;\n-        let mut g = self.H6;\n-        let mut h = self.H7;\n-\n-        let mut W = [0u32, ..64];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n-        // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n-                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n-                )\n-        )\n-\n-        macro_rules! sha2_round(\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n-                }\n-             )\n-        )\n-\n-\n-        read_u32v_be(W.mut_slice(0, 16), data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in range_step(0u, 48, 8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        for t in range_step(48u, 64, 8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        self.H0 += a;\n-        self.H1 += b;\n-        self.H2 += c;\n-        self.H3 += d;\n-        self.H4 += e;\n-        self.H5 += f;\n-        self.H6 += g;\n-        self.H7 += h;\n-    }\n-}\n-\n-static K32: [u32, ..64] = [\n-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n-];\n-\n-\n-// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine256 {\n-    length_bits: u64,\n-    buffer: FixedBuffer64,\n-    state: Engine256State,\n-    finished: bool,\n-}\n-\n-impl Engine256 {\n-    fn new(h: &[u32, ..8]) -> Engine256 {\n-        return Engine256 {\n-            length_bits: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Engine256State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32, ..8]) {\n-        self.length_bits = 0;\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n-        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if self.finished {\n-            return;\n-        }\n-\n-        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n-        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n-        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-        self.state.process_block(self.buffer.full_buffer());\n-\n-        self.finished = true;\n-    }\n-}\n-\n-\n-/// The SHA-256 hash algorithm\n-pub struct Sha256 {\n-    priv engine: Engine256\n-}\n-\n-impl Sha256 {\n-    /**\n-     * Construct an new instance of a SHA-256 digest.\n-     */\n-    pub fn new() -> Sha256 {\n-        Sha256 {\n-            engine: Engine256::new(&H256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n-        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H256);\n-    }\n-\n-    fn output_bits(&self) -> uint { 256 }\n-}\n-\n-static H256: [u32, ..8] = [\n-    0x6a09e667,\n-    0xbb67ae85,\n-    0x3c6ef372,\n-    0xa54ff53a,\n-    0x510e527f,\n-    0x9b05688c,\n-    0x1f83d9ab,\n-    0x5be0cd19\n-];\n-\n-\n-/// The SHA-224 hash algorithm\n-pub struct Sha224 {\n-    priv engine: Engine256\n-}\n-\n-impl Sha224 {\n-    /**\n-     * Construct an new instance of a SHA-224 digest.\n-     */\n-    pub fn new() -> Sha224 {\n-        Sha224 {\n-            engine: Engine256::new(&H224)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha224 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H224);\n-    }\n-\n-    fn output_bits(&self) -> uint { 224 }\n-}\n-\n-static H224: [u32, ..8] = [\n-    0xc1059ed8,\n-    0x367cd507,\n-    0x3070dd17,\n-    0xf70e5939,\n-    0xffc00b31,\n-    0x68581511,\n-    0x64f98fa7,\n-    0xbefa4fa4\n-];\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n-\n-    struct Test {\n-        input: ~str,\n-        output_str: ~str,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests.iter() {\n-            sh.input_str(t.input);\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests.iter() {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sha512() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\" +\n-                             \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb64\" +\n-                             \"2e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bb\" +\n-                             \"c6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha384() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be0743\" +\n-                             \"4c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c49\" +\n-                             \"4011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6\" +\n-                             \"c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha384::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha512_256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"1546741840f8a492b959d9b8b2344b9b0eb51b004bba35c0aebaac86d45264c3\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512Trunc256::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha512_224() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"6d6a9279495ec4061769752e7ff9c68b6b0b3c5a281b7917ce0572de\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha512Trunc224::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha256::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_sha224() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"\",\n-                output_str: ~\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output_str: ~\"730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525\"\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog.\",\n-                output_str: ~\"619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c\"\n-            },\n-        ];\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh = ~Sha224::new();\n-\n-        test_hash(sh, tests);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha512() {\n-        let mut sh = Sha512::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            128,\n-            \"e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb\" +\n-            \"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b\");\n-        }\n-\n-    #[test]\n-    fn test_1million_random_sha256() {\n-        let mut sh = Sha256::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n-    }\n-}\n-\n-\n-\n-#[cfg(test)]\n-mod bench {\n-\n-    use sha2::{Sha256,Sha512};\n-    use test::BenchHarness;\n-\n-    #[bench]\n-    pub fn sha256_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-\n-\n-    #[bench]\n-    pub fn sha512_10(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha512_1k(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha512_64k(bh: & mut BenchHarness) {\n-        let mut sh = Sha512::new();\n-        let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n-        bh.bytes = bytes.len() as u64;\n-    }\n-\n-}"}, {"sha": "90434cf0d4912ad0569ecb6d10c890d89d6801eb", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -68,25 +68,12 @@ pub mod sort;\n pub mod dlist;\n pub mod treemap;\n \n-// Crypto\n-#[path=\"crypto/cryptoutil.rs\"]\n-mod cryptoutil;\n-#[path=\"crypto/digest.rs\"]\n-pub mod digest;\n-#[path=\"crypto/md5.rs\"]\n-pub mod md5;\n-#[path=\"crypto/sha1.rs\"]\n-pub mod sha1;\n-#[path=\"crypto/sha2.rs\"]\n-pub mod sha2;\n-\n // And ... other stuff\n \n pub mod url;\n pub mod ebml;\n pub mod getopts;\n pub mod json;\n-pub mod md4;\n pub mod tempfile;\n pub mod glob;\n pub mod term;"}, {"sha": "96238986bf1c8ef81c376d3455999c33cfefc9fd", "filename": "src/libextra/md4.rs", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -1,150 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::vec;\n-\n-struct Quad {\n-    a: u32,\n-    b: u32,\n-    c: u32,\n-    d: u32\n-}\n-\n-/// Calculates the md4 hash of the given slice of bytes, returning the 128-bit\n-/// result as a quad of u32's\n-pub fn md4(msg: &[u8]) -> Quad {\n-    // subtle: if orig_len is merely uint, then the code below\n-    // which performs shifts by 32 bits or more has undefined\n-    // results.\n-    let orig_len: u64 = (msg.len() * 8u) as u64;\n-\n-    // pad message\n-    let mut msg = vec::append(msg.to_owned(), [0x80u8]);\n-    let mut bitlen = orig_len + 8u64;\n-    while (bitlen + 64u64) % 512u64 > 0u64 {\n-        msg.push(0u8);\n-        bitlen += 8u64;\n-    }\n-\n-    // append length\n-    let mut i = 0u64;\n-    while i < 8u64 {\n-        msg.push((orig_len >> (i * 8u64)) as u8);\n-        i += 1u64;\n-    }\n-\n-    let mut a = 0x67452301u32;\n-    let mut b = 0xefcdab89u32;\n-    let mut c = 0x98badcfeu32;\n-    let mut d = 0x10325476u32;\n-\n-    fn rot(r: int, x: u32) -> u32 {\n-        let r = r as u32;\n-        (x << r) | (x >> (32u32 - r))\n-    }\n-\n-    let mut i = 0u;\n-    let e = msg.len();\n-    let mut x = vec::from_elem(16u, 0u32);\n-    while i < e {\n-        let (aa, bb, cc, dd) = (a, b, c, d);\n-\n-        let mut j = 0u;\n-        let mut base = i;\n-        while j < 16u {\n-            x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n-                (msg[base + 2u] as u32 << 16u32) +\n-                (msg[base + 3u] as u32 << 24u32);\n-            j += 1u; base += 4u;\n-        }\n-\n-        let mut j = 0u;\n-        while j < 16u {\n-            a = rot(3, a + ((b & c) | (!b & d)) + x[j]);\n-            j += 1u;\n-            d = rot(7, d + ((a & b) | (!a & c)) + x[j]);\n-            j += 1u;\n-            c = rot(11, c + ((d & a) | (!d & b)) + x[j]);\n-            j += 1u;\n-            b = rot(19, b + ((c & d) | (!c & a)) + x[j]);\n-            j += 1u;\n-        }\n-\n-        let mut j = 0u;\n-        let q = 0x5a827999u32;\n-        while j < 4u {\n-            a = rot(3, a + ((b & c) | ((b & d) | (c & d))) + x[j] + q);\n-            d = rot(5, d + ((a & b) | ((a & c) | (b & c))) + x[j + 4u] + q);\n-            c = rot(9, c + ((d & a) | ((d & b) | (a & b))) + x[j + 8u] + q);\n-            b = rot(13, b + ((c & d) | ((c & a) | (d & a))) + x[j + 12u] + q);\n-            j += 1u;\n-        }\n-\n-        let mut j = 0u;\n-        let q = 0x6ed9eba1u32;\n-        while j < 8u {\n-            let jj = if j > 2u { j - 3u } else { j };\n-            a = rot(3, a + (b ^ c ^ d) + x[jj] + q);\n-            d = rot(9, d + (a ^ b ^ c) + x[jj + 8u] + q);\n-            c = rot(11, c + (d ^ a ^ b) + x[jj + 4u] + q);\n-            b = rot(15, b + (c ^ d ^ a) + x[jj + 12u] + q);\n-            j += 2u;\n-        }\n-\n-        a += aa; b += bb; c += cc; d += dd;\n-        i += 64u;\n-    }\n-    return Quad {a: a, b: b, c: c, d: d};\n-}\n-\n-/// Calculates the md4 hash of a slice of bytes, returning the hex-encoded\n-/// version of the hash\n-pub fn md4_str(msg: &[u8]) -> ~str {\n-    let Quad {a, b, c, d} = md4(msg);\n-    fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n-        f(a); f(b); f(c); f(d);\n-    }\n-    let mut result = ~\"\";\n-    do app(a, b, c, d) |u| {\n-        let mut i = 0u32;\n-        while i < 4u32 {\n-            let byte = (u >> (i * 8u32)) as u8;\n-            if byte <= 16u8 {\n-                result.push_char('0')\n-            }\n-            result.push_str((byte as uint).to_str_radix(16u));\n-            i += 1u32;\n-        }\n-    }\n-    result\n-}\n-\n-/// Calculates the md4 hash of a string, returning the hex-encoded version of\n-/// the hash\n-pub fn md4_text(msg: &str) -> ~str { md4_str(msg.as_bytes()) }\n-\n-#[test]\n-fn test_md4() {\n-    assert_eq!(md4_text(\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    assert_eq!(md4_text(\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    assert_eq!(md4_text(\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n-    assert!(md4_text(\"message digest\") ==\n-        ~\"d9130a8164549fe818874806e1c7014b\");\n-    assert!(md4_text(\"abcdefghijklmnopqrstuvwxyz\") ==\n-        ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n-    assert!(md4_text(\n-        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n-        0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n-    assert!(md4_text(\"1234567890123456789012345678901234567890123456789\\\n-                     0123456789012345678901234567890\") ==\n-        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n-}"}, {"sha": "bdc8b95ad411d2838272bb7a5548560a9a57fe57", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -10,10 +10,8 @@\n \n #[allow(missing_doc)];\n \n-use digest::Digest;\n use json;\n use json::ToJson;\n-use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n@@ -23,7 +21,6 @@ use std::{os, str, task};\n use std::rt::io;\n use std::rt::io::Writer;\n use std::rt::io::Decorator;\n-use std::rt::io::extensions::ReaderUtil;\n use std::rt::io::mem::MemWriter;\n use std::rt::io::file::FileInfo;\n \n@@ -276,19 +273,6 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     Decodable::decode(&mut decoder)\n }\n \n-fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let mut sha = ~Sha1::new();\n-    (*sha).input_str(json_encode(t));\n-    (*sha).result_str()\n-}\n-\n-fn digest_file(path: &Path) -> ~str {\n-    let mut sha = ~Sha1::new();\n-    let s = path.open_reader(io::Open).read_to_end();\n-    (*sha).input(s);\n-    (*sha).result_str()\n-}\n-\n impl Context {\n \n     pub fn new(db: RWArc<Database>,\n@@ -497,6 +481,8 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n+    use std::rt::io::ReaderUtil;\n+    use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n@@ -524,8 +510,10 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n+        let file_content = from_utf8_owned(pth.open_reader(io::Open).read_to_end());\n+\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prep.declare_input(\"file\", pth.as_str().unwrap(), digest_file(&pth));\n+        prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n         do prep.exec |_exe| {\n             let out = make_path(~\"foo.o\");\n             // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "95a2c5b170231b172383e934b06d4eecfdee81ff", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -62,6 +62,7 @@ mod package_id;\n mod package_source;\n mod path_util;\n mod search;\n+mod sha1;\n mod source_control;\n mod target;\n #[cfg(test)]"}, {"sha": "d955fd1aa97d04426df99241f59dfa6cf7bf8ada", "filename": "src/librustpkg/sha1.rs", "status": "added", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -0,0 +1,641 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * An implementation of the SHA-1 cryptographic hash.\n+ *\n+ * First create a `sha1` object using the `sha1` constructor, then\n+ * feed it input using the `input` or `input_str` methods, which may be\n+ * called any number of times.\n+ *\n+ * After the entire input has been fed to the hash read the result using\n+ * the `result` or `result_str` methods.\n+ *\n+ * The `sha1` object may be reused to create multiple hashes by calling\n+ * the `reset` method.\n+ *\n+ * This implementation has not been reviewed for cryptographic uses.\n+ * As such, all cryptographic uses of this implementation are strongly\n+ * discouraged.\n+ */\n+\n+use std::num::Zero;\n+use std::vec;\n+use std::vec::bytes::{MutableByteVector, copy_memory};\n+use extra::hex::ToHex;\n+\n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n+/// format.\n+fn write_u32_be(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be32(input as i32);\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n+fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+trait ToBits {\n+    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n+    /// high-order value and the 2nd item is the low order value.\n+    fn to_bits(self) -> (Self, Self);\n+}\n+\n+impl ToBits for u64 {\n+    fn to_bits(self) -> (u64, u64) {\n+        return (self >> 61, self << 3);\n+    }\n+}\n+\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// overflow.\n+fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n+\n+    if new_high_bits > Zero::zero() {\n+        fail!(\"Numeric overflow occured.\")\n+    }\n+\n+    match bits.checked_add(&new_low_bits) {\n+        Some(x) => return x,\n+        None => fail!(\"Numeric overflow occured.\")\n+    }\n+}\n+\n+/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n+/// must be processed. The input() method takes care of processing and then clearing the buffer\n+/// automatically. However, other methods do not and require the caller to process the buffer. Any\n+/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n+/// results in those bytes being marked as used by the buffer.\n+trait FixedBuffer {\n+    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n+    /// function and then clear the buffer.\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n+\n+    /// Reset the buffer.\n+    fn reset(&mut self);\n+\n+    /// Zero the buffer up until the specified index. The buffer position currently must not be\n+    /// greater than that index.\n+    fn zero_until(&mut self, idx: uint);\n+\n+    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n+    /// remaining in the buffer.\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+\n+    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n+\n+    /// Get the current position of the buffer.\n+    fn position(&self) -> uint;\n+\n+    /// Get the number of bytes remaining in the buffer until it is full.\n+    fn remaining(&self) -> uint;\n+\n+    /// Get the size of the buffer\n+    fn size(&self) -> uint;\n+}\n+\n+/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n+struct FixedBuffer64 {\n+    priv buffer: [u8, ..64],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer64 {\n+    /// Create a new buffer\n+    fn new() -> FixedBuffer64 {\n+        return FixedBuffer64 {\n+            buffer: [0u8, ..64],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl FixedBuffer for FixedBuffer64 {\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+        let mut i = 0;\n+\n+        let size = 64;\n+\n+        // If there is already data in the buffer, copy as much as we can into it and process\n+        // the data if the buffer becomes full.\n+        if self.buffer_idx != 0 {\n+            let buffer_remaining = size - self.buffer_idx;\n+            if input.len() >= buffer_remaining {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining),\n+                        buffer_remaining);\n+                self.buffer_idx = 0;\n+                func(self.buffer);\n+                i += buffer_remaining;\n+            } else {\n+                copy_memory(\n+                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                    input,\n+                    input.len());\n+                self.buffer_idx += input.len();\n+                return;\n+            }\n+        }\n+\n+        // While we have at least a full buffer size chunks's worth of data, process that data\n+        // without copying it into the buffer\n+        while input.len() - i >= size {\n+            func(input.slice(i, i + size));\n+            i += size;\n+        }\n+\n+        // Copy any input data into the buffer. At this point in the method, the ammount of\n+        // data left in the input vector will be less than the buffer size and the buffer will\n+        // be empty.\n+        let input_remaining = input.len() - i;\n+        copy_memory(\n+            self.buffer.mut_slice(0, input_remaining),\n+            input.slice_from(i),\n+            input.len() - i);\n+        self.buffer_idx += input_remaining;\n+    }\n+\n+    fn reset(&mut self) {\n+        self.buffer_idx = 0;\n+    }\n+\n+    fn zero_until(&mut self, idx: uint) {\n+        assert!(idx >= self.buffer_idx);\n+        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+        self.buffer_idx = idx;\n+    }\n+\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+        self.buffer_idx += len;\n+        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+    }\n+\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+        assert!(self.buffer_idx == 64);\n+        self.buffer_idx = 0;\n+        return self.buffer.slice_to(64);\n+    }\n+\n+    fn position(&self) -> uint { self.buffer_idx }\n+\n+    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+\n+    fn size(&self) -> uint { 64 }\n+}\n+\n+/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n+/// struct.\n+trait StandardPadding {\n+    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n+    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n+    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n+    /// filled with zeros again until only rem bytes are remaining.\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n+}\n+\n+impl <T: FixedBuffer> StandardPadding for T {\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n+        let size = self.size();\n+\n+        self.next(1)[0] = 128;\n+\n+        if self.remaining() < rem {\n+            self.zero_until(size);\n+            func(self.full_buffer());\n+        }\n+\n+        self.zero_until(size - rem);\n+    }\n+}\n+\n+/**\n+ * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+ * family of digest functions.\n+ */\n+pub trait Digest {\n+    /**\n+     * Provide message data.\n+     *\n+     * # Arguments\n+     *\n+     * * input - A vector of message data\n+     */\n+    fn input(&mut self, input: &[u8]);\n+\n+    /**\n+     * Retrieve the digest result. This method may be called multiple times.\n+     *\n+     * # Arguments\n+     *\n+     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n+     */\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /**\n+     * Reset the digest. This method must be called after result() and before supplying more\n+     * data.\n+     */\n+    fn reset(&mut self);\n+\n+    /**\n+     * Get the output size in bits.\n+     */\n+    fn output_bits(&self) -> uint;\n+\n+    /**\n+     * Convenience function that feeds a string into a digest.\n+     *\n+     * # Arguments\n+     *\n+     * * `input` The string to feed into the digest\n+     */\n+    fn input_str(&mut self, input: &str) {\n+        self.input(input.as_bytes());\n+    }\n+\n+    /**\n+     * Convenience function that retrieves the result of a digest as a\n+     * newly allocated vec of bytes.\n+     */\n+    fn result_bytes(&mut self) -> ~[u8] {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        buf\n+    }\n+\n+    /**\n+     * Convenience function that retrieves the result of a digest as a\n+     * ~str in hexadecimal format.\n+     */\n+    fn result_str(&mut self) -> ~str {\n+        self.result_bytes().to_hex()\n+    }\n+}\n+\n+/*\n+ * A SHA-1 implementation derived from Paul E. Jones's reference\n+ * implementation, which is written for clarity, not speed. At some\n+ * point this will want to be rewritten.\n+ */\n+\n+// Some unexported constants\n+static DIGEST_BUF_LEN: uint = 5u;\n+static WORK_BUF_LEN: uint = 80u;\n+static K0: u32 = 0x5A827999u32;\n+static K1: u32 = 0x6ED9EBA1u32;\n+static K2: u32 = 0x8F1BBCDCu32;\n+static K3: u32 = 0xCA62C1D6u32;\n+\n+/// Structure representing the state of a Sha1 computation\n+pub struct Sha1 {\n+    priv h: [u32, ..DIGEST_BUF_LEN],\n+    priv length_bits: u64,\n+    priv buffer: FixedBuffer64,\n+    priv computed: bool,\n+}\n+\n+fn add_input(st: &mut Sha1, msg: &[u8]) {\n+    assert!((!st.computed));\n+    // Assumes that msg.len() can be converted to u64 without overflow\n+    st.length_bits = add_bytes_to_bits(st.length_bits, msg.len() as u64);\n+    st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n+}\n+\n+fn process_msg_block(data: &[u8], h: &mut [u32, ..DIGEST_BUF_LEN]) {\n+    let mut t: int; // Loop counter\n+\n+    let mut w = [0u32, ..WORK_BUF_LEN];\n+\n+    // Initialize the first 16 words of the vector w\n+    read_u32v_be(w.mut_slice(0, 16), data);\n+\n+    // Initialize the rest of vector w\n+    t = 16;\n+    while t < 80 {\n+        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n+        w[t] = circular_shift(1, val);\n+        t += 1;\n+    }\n+    let mut a = h[0];\n+    let mut b = h[1];\n+    let mut c = h[2];\n+    let mut d = h[3];\n+    let mut e = h[4];\n+    let mut temp: u32;\n+    t = 0;\n+    while t < 20 {\n+        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 40 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 60 {\n+        temp =\n+            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n+                K2;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 80 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    h[0] += a;\n+    h[1] += b;\n+    h[2] += c;\n+    h[3] += d;\n+    h[4] += e;\n+}\n+\n+fn circular_shift(bits: u32, word: u32) -> u32 {\n+    return word << bits | word >> 32u32 - bits;\n+}\n+\n+fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n+    if !st.computed {\n+        st.buffer.standard_padding(8, |d: &[u8]| { process_msg_block(d, &mut st.h) });\n+        write_u32_be(st.buffer.next(4), (st.length_bits >> 32) as u32 );\n+        write_u32_be(st.buffer.next(4), st.length_bits as u32);\n+        process_msg_block(st.buffer.full_buffer(), &mut st.h);\n+\n+        st.computed = true;\n+    }\n+\n+    write_u32_be(rs.mut_slice(0, 4), st.h[0]);\n+    write_u32_be(rs.mut_slice(4, 8), st.h[1]);\n+    write_u32_be(rs.mut_slice(8, 12), st.h[2]);\n+    write_u32_be(rs.mut_slice(12, 16), st.h[3]);\n+    write_u32_be(rs.mut_slice(16, 20), st.h[4]);\n+}\n+\n+impl Sha1 {\n+    /// Construct a `sha` object\n+    pub fn new() -> Sha1 {\n+        let mut st = Sha1 {\n+            h: [0u32, ..DIGEST_BUF_LEN],\n+            length_bits: 0u64,\n+            buffer: FixedBuffer64::new(),\n+            computed: false,\n+        };\n+        st.reset();\n+        return st;\n+    }\n+}\n+\n+impl Digest for Sha1 {\n+    fn reset(&mut self) {\n+        self.length_bits = 0;\n+        self.h[0] = 0x67452301u32;\n+        self.h[1] = 0xEFCDAB89u32;\n+        self.h[2] = 0x98BADCFEu32;\n+        self.h[3] = 0x10325476u32;\n+        self.h[4] = 0xC3D2E1F0u32;\n+        self.buffer.reset();\n+        self.computed = false;\n+    }\n+    fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n+    fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n+    fn output_bits(&self) -> uint { 160 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::rand::{IsaacRng, Rng};\n+    use std::vec;\n+    use extra::hex::FromHex;\n+    use super::{Digest, Sha1, add_bytes_to_bits};\n+\n+    #[deriving(Clone)]\n+    struct Test {\n+        input: ~str,\n+        output: ~[u8],\n+        output_str: ~str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        // Test messages from FIPS 180-1\n+\n+        let fips_180_1_tests = ~[\n+            Test {\n+                input: ~\"abc\",\n+                output: ~[\n+                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                ],\n+                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n+            },\n+            Test {\n+                input:\n+                     ~\"abcdbcdecdefdefgefghfghighij\" +\n+                     \"hijkijkljklmklmnlmnomnopnopq\",\n+                output: ~[\n+                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                ],\n+                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n+            },\n+        ];\n+        // Examples from wikipedia\n+\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output: ~[\n+                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                ],\n+                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy cog\",\n+                output: ~[\n+                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                ],\n+                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+\n+        // Test that it works when accepting the message all at once\n+\n+        let mut out = [0u8, ..20];\n+\n+        let mut sh = ~Sha1::new();\n+        for t in tests.iter() {\n+            (*sh).input_str(t.input);\n+            sh.result(out);\n+            assert!(t.output.as_slice() == out);\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+\n+        // Test that it works when accepting the message in pieces\n+        for t in tests.iter() {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                (*sh).input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+            sh.result(out);\n+            assert!(t.output.as_slice() == out);\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n+    /// correct.\n+    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+        let total_size = 1000000;\n+        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n+        let mut rng = IsaacRng::new_unseeded();\n+        let mut count = 0;\n+\n+        digest.reset();\n+\n+        while count < total_size {\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n+            let remaining = total_size - count;\n+            let size = if next > remaining { remaining } else { next };\n+            digest.input(buffer.slice_to(size));\n+            count += size;\n+        }\n+\n+        let result_str = digest.result_str();\n+        let result_bytes = digest.result_bytes();\n+\n+        assert_eq!(expected, result_str.as_slice());\n+        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n+    }\n+\n+    #[test]\n+    fn test_1million_random_sha1() {\n+        let mut sh = Sha1::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n+    }\n+\n+    // A normal addition - no overflow occurs\n+    #[test]\n+    fn test_add_bytes_to_bits_ok() {\n+        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_overflow() {\n+        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use super::Sha1;\n+\n+    #[bench]\n+    pub fn sha1_10(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_1k(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_64k(bh: & mut BenchHarness) {\n+        let mut sh = Sha1::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"}, {"sha": "3adb33ec2f45580b04fcc17e57904c1be0f8fda0", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -11,10 +11,8 @@\n use std::rt::io;\n use std::rt::io::extensions::ReaderUtil;\n use std::rt::io::file::FileInfo;\n-\n-use extra::sha1::Sha1;\n-use extra::digest::Digest;\n use extra::workcache;\n+use sha1::{Digest, Sha1};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {"}, {"sha": "6f6e847f569b69fbfde27b470252ac6141fa9054", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9293a4127bffe08f6a6e2fbbec9e52229291c58c/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=9293a4127bffe08f6a6e2fbbec9e52229291c58c", "patch": "@@ -15,8 +15,13 @@\n  *\n  * Consider this as a main \"general-purpose\" hash for all hashtables: it\n  * runs at good speed (competitive with spooky and city) and permits\n- * cryptographically strong _keyed_ hashing. Key your hashtables from a\n- * CPRNG like rand::rng.\n+ * strong _keyed_ hashing. Key your hashtables from a strong RNG,\n+ * such as rand::rng.\n+ *\n+ * Although the SipHash algorithm is considered to be cryptographically\n+ * strong, this implementation has not been reviewed for such purposes.\n+ * As such, all cryptographic uses of this implementation are strongly\n+ * discouraged.\n  */\n \n #[allow(missing_doc)];"}]}