{"sha": "0a1fcadc907341b1993b109c72384ab16b512d06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMWZjYWRjOTA3MzQxYjE5OTNiMTA5YzcyMzg0YWIxNmI1MTJkMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T18:06:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T18:06:12Z"}, "message": "auto merge of #4958 : cpeterso/rust/reseed-rng, r=graydon\n\nFor Issue #4709:\r\n\r\n**c531506 rt: rand.rs expects `rust_next()` to return `uint32_t`, not `size_t`**\r\n\r\nrand.rs expects `rustrt::rand_next()` to return `u32`, but the `rand_next()` C function returns `size_t`: https://github.com/mozilla/rust/blob/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039/src/libcore/rand.rs#L34\r\n\r\n**f4320b6 move isaac RNG utility functions to new rust_rng.cpp file**\r\n**665e900 encapsulate isaac RNG in `rust_rng` struct**\r\n\r\nMove isaac's `randctx` into a `rust_rng` struct to make names similar to `rand::Rng` function names and prepare for auto-reseeding in the next commit.\r\n\r\n**9a78dc9 reseed `rust_rng` after generating 32KB**\r\n\r\nPrecedents from other languages:\r\n* Haskell's `GenAutoReseed` generator reseeds itself after generating 32KB: http://hackage.haskell.org/packages/archive/DRBG/0.1.2/doc/html/Crypto-Random-DRBG.html#t:GenAutoReseed\r\n\r\n* Go's RNG reseeds itself after generating 1MB: https://code.google.com/p/go/source/browse/src/pkg/crypto/rand/rand_unix.go?name=go1.0.3#94\r\n\r\n**9a76d71 don't deplete RNG entropy when there is only one runnable task**\r\n\r\n`rust_sched_loop::schedule_task()` unnecessarily calls `isaac_rand()` for the common case when there is only 1 runnable task, thus depleting RNG entropy and incurring unnecessary overhead.", "tree": {"sha": "2dba6c3da13c97e4906145930436f10e9651d6aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dba6c3da13c97e4906145930436f10e9651d6aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a1fcadc907341b1993b109c72384ab16b512d06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fcadc907341b1993b109c72384ab16b512d06", "html_url": "https://github.com/rust-lang/rust/commit/0a1fcadc907341b1993b109c72384ab16b512d06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fcadc907341b1993b109c72384ab16b512d06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9727008ed0772fc325e0822e74b429e4e7c09af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9727008ed0772fc325e0822e74b429e4e7c09af0", "html_url": "https://github.com/rust-lang/rust/commit/9727008ed0772fc325e0822e74b429e4e7c09af0"}, {"sha": "9a76d718c709da7d69d3533e1b2019a768343af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a76d718c709da7d69d3533e1b2019a768343af5", "html_url": "https://github.com/rust-lang/rust/commit/9a76d718c709da7d69d3533e1b2019a768343af5"}], "stats": {"total": 281, "additions": 189, "deletions": 92}, "files": [{"sha": "e6e0f1e0cd759314486abf5f3d3133eb2fdce309", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -50,6 +50,7 @@ RUNTIME_CXXS_$(1) := \\\n               rt/rust_builtin.cpp \\\n               rt/rust_run_program.cpp \\\n               rt/rust_env.cpp \\\n+              rt/rust_rng.cpp \\\n               rt/rust_sched_loop.cpp \\\n               rt/rust_sched_launcher.cpp \\\n               rt/rust_sched_driver.cpp \\"}, {"sha": "db7021f189ac81ce205a5aefd34d7130895b958f", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -116,15 +116,15 @@ impl<T: Rand> Rand for Option<T> {\n }\n \n #[allow(non_camel_case_types)] // runtime type\n-enum rctx {}\n+enum rust_rng {}\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n     unsafe fn rand_seed() -> ~[u8];\n-    unsafe fn rand_new() -> *rctx;\n-    unsafe fn rand_new_seeded2(&&seed: ~[u8]) -> *rctx;\n-    unsafe fn rand_next(c: *rctx) -> u32;\n-    unsafe fn rand_free(c: *rctx);\n+    unsafe fn rand_new() -> *rust_rng;\n+    unsafe fn rand_new_seeded2(&&seed: ~[u8]) -> *rust_rng;\n+    unsafe fn rand_next(rng: *rust_rng) -> u32;\n+    unsafe fn rand_free(rng: *rust_rng);\n }\n \n /// A random number generator\n@@ -363,24 +363,24 @@ impl Rng {\n }\n \n struct RandRes {\n-    c: *rctx,\n+    rng: *rust_rng,\n     drop {\n         unsafe {\n-            rustrt::rand_free(self.c);\n+            rustrt::rand_free(self.rng);\n         }\n     }\n }\n \n-fn RandRes(c: *rctx) -> RandRes {\n+fn RandRes(rng: *rust_rng) -> RandRes {\n     RandRes {\n-        c: c\n+        rng: rng\n     }\n }\n \n impl Rng for @RandRes {\n     fn next() -> u32 {\n         unsafe {\n-            return rustrt::rand_next((*self).c);\n+            return rustrt::rand_next((*self).rng);\n         }\n     }\n }"}, {"sha": "85caf7b2e5381ba48ad76fb655e62829ea969e35", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -135,51 +135,52 @@ rand_seed() {\n     rust_vec *v = (rust_vec *) task->kernel->malloc(vec_size<uint8_t>(size),\n                                             \"rand_seed\");\n     v->fill = v->alloc = size;\n-    isaac_seed(task->kernel, (uint8_t*) &v->data, size);\n+    rng_gen_seed(task->kernel, (uint8_t*) &v->data, size);\n     return v;\n }\n \n extern \"C\" CDECL void *\n rand_new() {\n     rust_task *task = rust_get_current_task();\n     rust_sched_loop *thread = task->sched_loop;\n-    randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"rand_new\");\n-    if (!rctx) {\n+    rust_rng *rng = (rust_rng *) task->malloc(sizeof(rust_rng), \"rand_new\");\n+    if (!rng) {\n         task->fail();\n         return NULL;\n     }\n-    isaac_init(thread->kernel, rctx, NULL);\n-    return rctx;\n+    rng_init(thread->kernel, rng, NULL);\n+    return rng;\n }\n \n extern \"C\" CDECL void *\n rand_new_seeded(rust_vec_box* seed) {\n     rust_task *task = rust_get_current_task();\n     rust_sched_loop *thread = task->sched_loop;\n-    randctx *rctx = (randctx *) task->malloc(sizeof(randctx),\n-                                             \"rand_new_seeded\");\n-    if (!rctx) {\n+    rust_rng *rng = (rust_rng *) task->malloc(sizeof(rust_rng),\n+                                              \"rand_new_seeded\");\n+    if (!rng) {\n         task->fail();\n         return NULL;\n     }\n-    isaac_init(thread->kernel, rctx, seed);\n-    return rctx;\n+    rng_init(thread->kernel, rng, seed);\n+    return rng;\n }\n \n extern \"C\" CDECL void *\n rand_new_seeded2(rust_vec_box** seed) {\n     return rand_new_seeded(*seed);\n }\n \n-extern \"C\" CDECL size_t\n-rand_next(randctx *rctx) {\n-    return isaac_rand(rctx);\n+extern \"C\" CDECL uint32_t\n+rand_next(rust_rng *rng) {\n+    rust_task *task = rust_get_current_task();\n+    return rng_gen_u32(task->kernel, rng);\n }\n \n extern \"C\" CDECL void\n-rand_free(randctx *rctx) {\n+rand_free(rust_rng *rng) {\n     rust_task *task = rust_get_current_task();\n-    task->free(rctx);\n+    task->free(rng);\n }\n \n "}, {"sha": "3cc8550104a614d2240760caaf25112c876b8c02", "filename": "src/rt/rust_globals.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_globals.h", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_globals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_globals.h?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -37,7 +37,6 @@\n #include <math.h>\n #include <assert.h>\n \n-#include \"rand.h\"\n #include \"uthash.h\"\n \n #if defined(__WIN32__)"}, {"sha": "3d6bfdf7dbb1f06c5ecb0bae45c0ae7438aaea27", "filename": "src/rt/rust_rng.cpp", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_rng.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_rng.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.cpp?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"rust_globals.h\"\n+#include \"rust_rng.h\"\n+#include \"rust_util.h\"\n+\n+// Initialization helpers for ISAAC RNG\n+\n+void\n+rng_gen_seed(rust_kernel* kernel, uint8_t* dest, size_t size) {\n+#ifdef __WIN32__\n+    HCRYPTPROV hProv;\n+    kernel->win32_require\n+        (_T(\"CryptAcquireContext\"),\n+         CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n+                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n+    kernel->win32_require\n+        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, size, (BYTE*) dest));\n+    kernel->win32_require\n+        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n+#else\n+    int fd = open(\"/dev/urandom\", O_RDONLY);\n+    if (fd == -1)\n+        kernel->fatal(\"error opening /dev/urandom: %s\", strerror(errno));\n+    size_t amount = 0;\n+    do {\n+        ssize_t ret = read(fd, dest+amount, size-amount);\n+        if (ret < 0)\n+            kernel->fatal(\"error reading /dev/urandom: %s\", strerror(errno));\n+        else if (ret == 0)\n+            kernel->fatal(\"somehow hit eof reading from /dev/urandom\");\n+        amount += (size_t)ret;\n+    } while (amount < size);\n+    int ret = close(fd);\n+    // FIXME #3697: Why does this fail sometimes?\n+    if (ret != 0)\n+        kernel->log(log_warn, \"error closing /dev/urandom: %s\",\n+            strerror(errno));\n+#endif\n+}\n+\n+static void\n+isaac_init(rust_kernel *kernel, randctx *rctx, rust_vec_box* user_seed) {\n+    memset(rctx, 0, sizeof(randctx));\n+\n+    char *env_seed = kernel->env->rust_seed;\n+    if (user_seed != NULL) {\n+        // ignore bytes after the required length\n+        size_t seed_len = user_seed->body.fill < sizeof(rctx->randrsl)\n+            ? user_seed->body.fill : sizeof(rctx->randrsl);\n+        memcpy(&rctx->randrsl, user_seed->body.data, seed_len);\n+    } else if (env_seed != NULL) {\n+        ub4 seed = (ub4) atoi(env_seed);\n+        for (size_t i = 0; i < RANDSIZ; i ++) {\n+            memcpy(&rctx->randrsl[i], &seed, sizeof(ub4));\n+            seed = (seed + 0x7ed55d16) + (seed << 12);\n+        }\n+    } else {\n+        rng_gen_seed(kernel, (uint8_t*)&rctx->randrsl, sizeof(rctx->randrsl));\n+    }\n+\n+    randinit(rctx, 1);\n+}\n+\n+void\n+rng_init(rust_kernel* kernel, rust_rng* rng, rust_vec_box* user_seed) {\n+    isaac_init(kernel, &rng->rctx, user_seed);\n+    rng->reseedable = !user_seed && !kernel->env->rust_seed;\n+}\n+\n+static void\n+rng_maybe_reseed(rust_kernel* kernel, rust_rng* rng) {\n+    // If this RNG has generated more than 32KB of random data and was not\n+    // seeded by the user or RUST_SEED, then we should reseed now.\n+    const size_t RESEED_THRESHOLD = 32 * 1024;\n+    size_t bytes_generated = rng->rctx.randc * sizeof(ub4);\n+    if (bytes_generated < RESEED_THRESHOLD || !rng->reseedable) {\n+        return;\n+    }\n+\n+    uint32_t new_seed[RANDSIZ];\n+    rng_gen_seed(kernel, (uint8_t*) new_seed, RANDSIZ * sizeof(uint32_t));\n+\n+    // Stir new seed into PRNG's entropy pool.\n+    for (size_t i = 0; i < RANDSIZ; i++) {\n+        rng->rctx.randrsl[i] ^= new_seed[i];\n+    }\n+\n+    randinit(&rng->rctx, 1);\n+}\n+\n+uint32_t\n+rng_gen_u32(rust_kernel* kernel, rust_rng* rng) {\n+    uint32_t x = isaac_rand(&rng->rctx);\n+    rng_maybe_reseed(kernel, rng);\n+    return x;\n+}\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "2f1e680623febd56784d018f06bf2ceded768bad", "filename": "src/rt/rust_rng.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_rng.h", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_rng.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_rng.h?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#ifndef RUST_RNG_H\n+#define RUST_RNG_H\n+\n+#include \"rand.h\"\n+\n+class rust_kernel;\n+struct rust_vec_box;\n+\n+// Initialization helpers for ISAAC RNG\n+\n+struct rust_rng {\n+    randctx rctx;\n+    bool reseedable;\n+};\n+\n+void rng_gen_seed(rust_kernel* kernel, uint8_t* dest, size_t size);\n+void rng_init(rust_kernel *kernel, rust_rng *rng, rust_vec_box* user_seed);\n+uint32_t rng_gen_u32(rust_kernel *kernel, rust_rng *rng);\n+\n+//\n+// Local Variables:\n+// mode: C++\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//\n+\n+#endif"}, {"sha": "7143bf88d46bd2b06d60354a8f4ef39271d76bd4", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -41,7 +41,7 @@ rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n     name(\"main\")\n {\n     LOGPTR(this, \"new dom\", (uintptr_t)this);\n-    isaac_init(kernel, &rctx, NULL);\n+    rng_init(kernel, &rng, NULL);\n \n     if (!tls_initialized)\n         init_tls();\n@@ -150,10 +150,10 @@ rust_sched_loop::release_task(rust_task *task) {\n rust_task *\n rust_sched_loop::schedule_task() {\n     lock.must_have_lock();\n-    if (running_tasks.length() > 0) {\n-        size_t k = isaac_rand(&rctx);\n-        size_t i = k % running_tasks.length();\n-        return (rust_task *)running_tasks[i];\n+    size_t tasks = running_tasks.length();\n+    if (tasks > 0) {\n+        size_t i = (tasks > 1) ? (rng_gen_u32(kernel, &rng) % tasks) : 0;\n+        return running_tasks[i];\n     }\n     return NULL;\n }"}, {"sha": "736c09ee920cadb628d1529e7584ebff715b4aa5", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -13,6 +13,7 @@\n \n #include \"rust_globals.h\"\n #include \"rust_log.h\"\n+#include \"rust_rng.h\"\n #include \"rust_stack.h\"\n #include \"rust_signal.h\"\n #include \"context.h\"\n@@ -61,7 +62,7 @@ struct rust_sched_loop\n #endif\n \n     context c_context;\n-\n+    rust_rng rng;\n     bool should_exit;\n \n     stk_seg *cached_c_stack;\n@@ -102,7 +103,6 @@ struct rust_sched_loop\n     size_t min_stack_size;\n     memory_region local_region;\n \n-    randctx rctx;\n     const char *const name; // Used for debugging\n \n     // Only a pointer to 'name' is kept, so it must live as long as this"}, {"sha": "b5827e0724b7ecb6f5e907e7542ad76229cd43be", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcadc907341b1993b109c72384ab16b512d06/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=0a1fcadc907341b1993b109c72384ab16b512d06", "patch": "@@ -136,65 +136,6 @@ inline size_t get_box_size(size_t body_size, size_t body_align) {\n     return total_size;\n }\n \n-// Initialization helpers for ISAAC RNG\n-\n-inline void isaac_seed(rust_kernel* kernel, uint8_t* dest, size_t size)\n-{\n-#ifdef __WIN32__\n-    HCRYPTPROV hProv;\n-    kernel->win32_require\n-        (_T(\"CryptAcquireContext\"),\n-         CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n-                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-    kernel->win32_require\n-        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, size, (BYTE*) dest));\n-    kernel->win32_require\n-        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n-#else\n-    int fd = open(\"/dev/urandom\", O_RDONLY);\n-    if (fd == -1)\n-        kernel->fatal(\"error opening /dev/urandom: %s\", strerror(errno));\n-    size_t amount = 0;\n-    do {\n-        ssize_t ret = read(fd, dest+amount, size-amount);\n-        if (ret < 0)\n-            kernel->fatal(\"error reading /dev/urandom: %s\", strerror(errno));\n-        else if (ret == 0)\n-            kernel->fatal(\"somehow hit eof reading from /dev/urandom\");\n-        amount += (size_t)ret;\n-    } while (amount < size);\n-    int ret = close(fd);\n-    // FIXME #3697: Why does this fail sometimes?\n-    if (ret != 0)\n-        kernel->log(log_warn, \"error closing /dev/urandom: %s\",\n-            strerror(errno));\n-#endif\n-}\n-\n-inline void\n-isaac_init(rust_kernel *kernel, randctx *rctx, rust_vec_box* user_seed)\n-{\n-    memset(rctx, 0, sizeof(randctx));\n-\n-    char *env_seed = kernel->env->rust_seed;\n-    if (user_seed != NULL) {\n-        // ignore bytes after the required length\n-        size_t seed_len = user_seed->body.fill < sizeof(rctx->randrsl)\n-            ? user_seed->body.fill : sizeof(rctx->randrsl);\n-        memcpy(&rctx->randrsl, user_seed->body.data, seed_len);\n-    } else if (env_seed != NULL) {\n-        ub4 seed = (ub4) atoi(env_seed);\n-        for (size_t i = 0; i < RANDSIZ; i ++) {\n-            memcpy(&rctx->randrsl[i], &seed, sizeof(ub4));\n-            seed = (seed + 0x7ed55d16) + (seed << 12);\n-        }\n-    } else {\n-        isaac_seed(kernel, (uint8_t*) &rctx->randrsl, sizeof(rctx->randrsl));\n-    }\n-\n-    randinit(rctx, 1);\n-}\n-\n //\n // Local Variables:\n // mode: C++"}]}