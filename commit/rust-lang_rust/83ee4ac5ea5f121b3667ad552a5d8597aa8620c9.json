{"sha": "83ee4ac5ea5f121b3667ad552a5d8597aa8620c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZWU0YWM1ZWE1ZjEyMWIzNjY3YWQ1NTJhNWQ4NTk3YWE4NjIwYzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-22T17:02:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-22T17:02:34Z"}, "message": "impl-ify map", "tree": {"sha": "d48afc6ba0b8f8736e03ad2dc05f6f0e95790eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48afc6ba0b8f8736e03ad2dc05f6f0e95790eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9", "html_url": "https://github.com/rust-lang/rust/commit/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "073f90cdc493d1ea9bf715f5cf8234ea320a5d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/073f90cdc493d1ea9bf715f5cf8234ea320a5d4a", "html_url": "https://github.com/rust-lang/rust/commit/073f90cdc493d1ea9bf715f5cf8234ea320a5d4a"}], "stats": {"total": 280, "additions": 134, "deletions": 146}, "files": [{"sha": "998fc55afe8b346cce94e6753925391daffd5270", "filename": "src/libstd/map.rs", "status": "modified", "additions": 134, "deletions": 146, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ee4ac5ea5f121b3667ad552a5d8597aa8620c9/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=83ee4ac5ea5f121b3667ad552a5d8597aa8620c9", "patch": "@@ -69,6 +69,8 @@ iface map<K: copy, V: copy> {\n // FIXME: package this up and export it as a datatype usable for\n // external code that doesn't want to pay the cost of a box. (#2344)\n mod chained {\n+    export t, mk, hashmap;\n+\n     type entry<K, V> = {\n         hash: uint,\n         key: K,\n@@ -94,186 +96,172 @@ mod chained {\n         found_after(@entry<K,V>, @entry<K,V>)\n     }\n \n-    fn search_rem<K: copy, V: copy>(\n-        tbl: t<K,V>, k: K, h: uint, idx: uint,\n-        e_root: @entry<K,V>) -> search_result<K,V> {\n-        let mut e0 = e_root;\n-        let mut comp = 1u;   // for logging\n-        loop {\n-            alt e0.next {\n+    impl private_methods<K: copy, V: copy> for t<K, V> {\n+        fn search_rem(k: K, h: uint, idx: uint,\n+                      e_root: @entry<K,V>) -> search_result<K,V> {\n+            let mut e0 = e_root;\n+            let mut comp = 1u;   // for logging\n+            loop {\n+                alt e0.next {\n+                  absent {\n+                    #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+                           comp, h, idx);\n+                    ret not_found;\n+                  }\n+                  present(e1) {\n+                    comp += 1u;\n+                    let e1_key = e1.key; // Satisfy alias checker.\n+                    if e1.hash == h && self.eqer(e1_key, k) {\n+                        #debug(\"search_tbl: present, comp %u, \\\n+                                hash %u, idx %u\",\n+                               comp, h, idx);\n+                        ret found_after(e0, e1);\n+                    } else {\n+                        e0 = e1;\n+                    }\n+                  }\n+                }\n+            };\n+        }\n+\n+        fn search_tbl(k: K, h: uint) -> search_result<K,V> {\n+            let idx = h % vec::len(self.chains);\n+            alt self.chains[idx] {\n               absent {\n                 #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                       comp, h, idx);\n+                       0u, h, idx);\n                 ret not_found;\n               }\n-              present(e1) {\n-                comp += 1u;\n-                let e1_key = e1.key; // Satisfy alias checker.\n-                if e1.hash == h && tbl.eqer(e1_key, k) {\n+              present(e) {\n+                // FIXME: This copy of the key is not good for perf\n+                if e.hash == h && self.eqer(copy e.key, k) {\n                     #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                           comp, h, idx);\n-                    ret found_after(e0, e1);\n+                           1u, h, idx);\n+                    ret found_first(idx, e);\n                 } else {\n-                    e0 = e1;\n+                    ret self.search_rem(k, h, idx, e);\n                 }\n               }\n             }\n-        };\n-    }\n-\n-    fn search_tbl<K: copy, V: copy>(\n-        tbl: t<K,V>, k: K, h: uint) -> search_result<K,V> {\n-        let idx = h % vec::len(tbl.chains);\n-        alt tbl.chains[idx] {\n-          absent {\n-            #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                   0u, h, idx);\n-            ret not_found;\n-          }\n-          present(e) {\n-            // FIXME: This copy of the key is not good for perf\n-            if e.hash == h && tbl.eqer(copy e.key, k) {\n-                #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                       1u, h, idx);\n-                ret found_first(idx, e);\n-            } else {\n-                ret search_rem(tbl, k, h, idx, e);\n-            }\n-          }\n         }\n-    }\n \n-    fn insert<K: copy, V: copy>(tbl: t<K,V>, k: K, v: V) -> bool {\n-        let hash = tbl.hasher(k);\n-        alt search_tbl(tbl, k, hash) {\n-          not_found {\n-            tbl.count += 1u;\n-            let idx = hash % vec::len(tbl.chains);\n-            let old_chain = tbl.chains[idx];\n-            tbl.chains[idx] = present(@{\n-                hash: hash,\n-                key: k,\n-                mut value: v,\n-                mut next: old_chain});\n-            ret true;\n-          }\n-          found_first(_, entry) {\n-            entry.value = v;\n-            ret false;\n-          }\n-          found_after(_, entry) {\n-            entry.value = v;\n-            ret false\n-          }\n-        }\n-    }\n-\n-    fn get<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n-        alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found {\n-            ret core::option::none;\n-          }\n-\n-          found_first(_, entry) {\n-            ret core::option::some(entry.value);\n-          }\n-\n-          found_after(_, entry) {\n-            ret core::option::some(entry.value);\n-          }\n-        }\n-    }\n-\n-    fn remove<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n-        alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found {\n-            ret core::option::none;\n-          }\n-\n-          found_first(idx, entry) {\n-            tbl.count -= 1u;\n-            tbl.chains[idx] = entry.next;\n-            ret core::option::some(entry.value);\n-          }\n-\n-          found_after(eprev, entry) {\n-            tbl.count -= 1u;\n-            eprev.next = entry.next;\n-            ret core::option::some(entry.value);\n-          }\n+        fn rehash() {\n+            let n_old_chains = vec::len(self.chains);\n+            let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n+            let new_chains = chains(n_new_chains);\n+            for self.each_entry {|entry|\n+                let idx = entry.hash % n_new_chains;\n+                entry.next = new_chains[idx];\n+                new_chains[idx] = present(entry);\n+            }\n+            self.chains = new_chains;\n         }\n-    }\n-\n-    fn chains<K: copy, V: copy>(nchains: uint) -> [mut chain<K,V>] {\n-        ret vec::to_mut(vec::from_elem(nchains, absent));\n-    }\n \n-    fn each_entry<K: copy, V: copy>(tbl: t<K, V>,\n-                                    blk: fn(@entry<K,V>) -> bool) {\n-        let mut i = 0u, n = vec::len(tbl.chains);\n-        while i < n {\n-            let mut chain = tbl.chains[i];\n-            loop {\n-                chain = alt chain {\n-                  absent { break; }\n-                  present(entry) {\n-                    let next = entry.next;\n-                    if !blk(entry) { ret; }\n-                    next\n-                  }\n+        fn each_entry(blk: fn(@entry<K,V>) -> bool) {\n+            let mut i = 0u, n = vec::len(self.chains);\n+            while i < n {\n+                let mut chain = self.chains[i];\n+                loop {\n+                    chain = alt chain {\n+                      absent { break; }\n+                      present(entry) {\n+                        let next = entry.next;\n+                        if !blk(entry) { ret; }\n+                        next\n+                      }\n+                    }\n                 }\n+                i += 1u;\n             }\n-            i += 1u;\n-        }\n-    }\n-\n-    fn rehash<K: copy, V: copy>(tbl: t<K,V>) {\n-        let n_old_chains = vec::len(tbl.chains);\n-        let n_new_chains: uint = uint::next_power_of_two(n_old_chains + 1u);\n-        let new_chains = chains(n_new_chains);\n-        for each_entry(tbl) {|entry|\n-            let idx = entry.hash % n_new_chains;\n-            entry.next = new_chains[idx];\n-            new_chains[idx] = present(entry);\n-        }\n-        tbl.chains = new_chains;\n-    }\n-\n-    fn each<K: copy, V: copy>(tbl: t<K,V>, blk: fn(K,V) -> bool) {\n-        for each_entry(tbl) {|entry|\n-            if !blk(copy entry.key, copy entry.value) { break; }\n         }\n     }\n \n     impl hashmap<K: copy, V: copy> of map<K, V> for t<K, V> {\n         fn size() -> uint { self.count }\n \n+        fn contains_key(k: K) -> bool {\n+            let hash = self.hasher(k);\n+            alt self.search_tbl(k, hash) {\n+              not_found {false}\n+              found_first(*) | found_after(*) {true}\n+            }\n+        }\n+\n         fn insert(k: K, v: V) -> bool {\n-            let grew = insert(self, k, v);\n-            if grew {\n+            let hash = self.hasher(k);\n+            alt self.search_tbl(k, hash) {\n+              not_found {\n+                self.count += 1u;\n+                let idx = hash % vec::len(self.chains);\n+                let old_chain = self.chains[idx];\n+                self.chains[idx] = present(@{\n+                    hash: hash,\n+                    key: k,\n+                    mut value: v,\n+                    mut next: old_chain});\n+\n+                // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n                 let load = {num: (self.count + 1u) as int,\n                             den: nchains as int};\n-                // Structural consts would be nice. This is a const 3/4\n-                // load factor that we compare against.\n-                if !util::rational_leq(load, {num:3, den:4}) { rehash(self); }\n+                if !util::rational_leq(load, {num:3, den:4}) {\n+                    self.rehash();\n+                }\n+\n+                ret true;\n+              }\n+              found_first(_, entry) {\n+                entry.value = v;\n+                ret false;\n+              }\n+              found_after(_, entry) {\n+                entry.value = v;\n+                ret false\n+              }\n             }\n-            grew\n         }\n \n-        fn contains_key(k: K) -> bool { option::is_some(get(self, k)) }\n+        fn find(k: K) -> option<V> {\n+            alt self.search_tbl(k, self.hasher(k)) {\n+              not_found {none}\n+              found_first(_, entry) {some(entry.value)}\n+              found_after(_, entry) {some(entry.value)}\n+            }\n+        }\n \n-        fn get(k: K) -> V { option::get(get(self, k)) }\n+        fn get(k: K) -> V {\n+            option::get(self.find(k))\n+        }\n \n-        fn find(k: K) -> option<V> { get(self, k) }\n+        fn remove(k: K) -> option<V> {\n+            alt self.search_tbl(k, self.hasher(k)) {\n+              not_found {none}\n+              found_first(idx, entry) {\n+                self.count -= 1u;\n+                self.chains[idx] = entry.next;\n+                some(entry.value)\n+              }\n+              found_after(eprev, entry) {\n+                self.count -= 1u;\n+                eprev.next = entry.next;\n+                some(entry.value)\n+              }\n+            }\n+        }\n \n-        fn remove(k: K) -> option<V> { remove(self, k) }\n+        fn each(blk: fn(K,V) -> bool) {\n+            for self.each_entry { |entry|\n+                if !blk(copy entry.key, copy entry.value) { break; }\n+            }\n+        }\n \n-        fn each(blk: fn(K, V) -> bool) { each(self, blk); }\n+        fn each_key(blk: fn(K) -> bool) { self.each { |k, _v| blk(k)} }\n \n-        fn each_key(blk: fn(K) -> bool) { each(self) { |k, _v| blk(k)} }\n+        fn each_value(blk: fn(V) -> bool) { self.each { |_k, v| blk(v)} }\n+    }\n \n-        fn each_value(blk: fn(V) -> bool) { each(self) { |_k, v| blk(v)} }\n+    fn chains<K,V>(nchains: uint) -> [mut chain<K,V>] {\n+        ret vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n     fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {"}]}