{"sha": "6a9b5e4c51e995120c9739cacb305826a35ac496", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOWI1ZTRjNTFlOTk1MTIwYzk3MzljYWNiMzA1ODI2YTM1YWM0OTY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-09-27T05:46:29Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-09-29T10:38:35Z"}, "message": "Clarify HashMap's capacity handling.\n\nThis commit does the following.\n\n- Changes the terminology for capacities used within HashMap's code.\n  \"Internal capacity\" is now consistently \"raw capacity\", and \"usable\n  capacity\" is now consistently just \"capacity\". This makes the code\n  easier to understand.\n\n- Reworks capacity and raw capacity computations. Raw capacity\n  computations are now handled in a single place:\n  `DefaultResizePolicy::raw_capacity()`. This function correctly returns\n  zero when given zero, which means that the following cases now result\n  in a capacity of zero when they previously did not.\n\n  * `Hash{Map,Set}::with_capacity(0)`\n  * `Hash{Map,Set}::with_capacity_and_hasher(0)`\n  * `Hash{Map,Set}::shrink_to_fit()`, when used with a hash map/set whose\n    elements have all been removed\n\n- Strengthens the language used in the comments describing the above\n  functions, to make it clearer when they will result in a map/set with\n  a capacity of zero. The new language is based on the language used for\n  the corresponding functions in `Vec`.\n\n- Adds tests for the above zero-capacity cases.\n\n- Removes `test_resize_policy` because it is no longer useful.", "tree": {"sha": "761352b47e9495f4aab2b6ee77330e323b4c1517", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761352b47e9495f4aab2b6ee77330e323b4c1517"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a9b5e4c51e995120c9739cacb305826a35ac496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9b5e4c51e995120c9739cacb305826a35ac496", "html_url": "https://github.com/rust-lang/rust/commit/6a9b5e4c51e995120c9739cacb305826a35ac496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a9b5e4c51e995120c9739cacb305826a35ac496/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ccfc695b56c102a2e7e95719b398bfa0a5e8af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ccfc695b56c102a2e7e95719b398bfa0a5e8af1", "html_url": "https://github.com/rust-lang/rust/commit/8ccfc695b56c102a2e7e95719b398bfa0a5e8af1"}], "stats": {"total": 211, "additions": 121, "deletions": 90}, "files": [{"sha": "5fdc6056c68f632f35aae72bffe9031821237a1c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 93, "deletions": 85, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/6a9b5e4c51e995120c9739cacb305826a35ac496/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9b5e4c51e995120c9739cacb305826a35ac496/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6a9b5e4c51e995120c9739cacb305826a35ac496", "patch": "@@ -34,13 +34,9 @@ use super::table::BucketState::{\n     Full,\n };\n \n-const INITIAL_LOG2_CAP: usize = 5;\n-const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n+const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n \n-/// The default behavior of HashMap implements a load factor of 90.9%.\n-/// This behavior is characterized by the following condition:\n-///\n-/// - if size > 0.909 * capacity: grow the map\n+/// The default behavior of HashMap implements a maximum load factor of 90.9%.\n #[derive(Clone)]\n struct DefaultResizePolicy;\n \n@@ -49,40 +45,35 @@ impl DefaultResizePolicy {\n         DefaultResizePolicy\n     }\n \n+    /// A hash map's \"capacity\" is the number of elements it can hold without\n+    /// being resized. Its \"raw capacity\" is the number of slots required to\n+    /// provide that capacity, accounting for maximum loading. The raw capacity\n+    /// is always zero or a power of two.\n     #[inline]\n-    fn min_capacity(&self, usable_size: usize) -> usize {\n-        // Here, we are rephrasing the logic by specifying the lower limit\n-        // on capacity:\n-        //\n-        // - if `cap < size * 1.1`: grow the map\n-        usable_size * 11 / 10\n+    fn raw_capacity(&self, len: usize) -> usize {\n+        if len == 0 {\n+            0\n+        } else {\n+            // 1. Account for loading: `raw_capacity >= len * 1.1`.\n+            // 2. Ensure it is a power of two.\n+            // 3. Ensure it is at least the minimum size.\n+            let mut raw_cap = len * 11 / 10;\n+            assert!(raw_cap >= len, \"raw_cap overflow\");\n+            raw_cap = raw_cap.checked_next_power_of_two().expect(\"raw_capacity overflow\");\n+            raw_cap = max(MIN_NONZERO_RAW_CAPACITY, raw_cap);\n+            raw_cap\n+        }\n     }\n \n-    /// An inverse of `min_capacity`, approximately.\n+    /// The capacity of the given raw capacity.\n     #[inline]\n-    fn usable_capacity(&self, cap: usize) -> usize {\n-        // As the number of entries approaches usable capacity,\n-        // min_capacity(size) must be smaller than the internal capacity,\n-        // so that the map is not resized:\n-        // `min_capacity(usable_capacity(x)) <= x`.\n-        // The left-hand side can only be smaller due to flooring by integer\n-        // division.\n-        //\n+    fn capacity(&self, raw_cap: usize) -> usize {\n         // This doesn't have to be checked for overflow since allocation size\n         // in bytes will overflow earlier than multiplication by 10.\n         //\n         // As per https://github.com/rust-lang/rust/pull/30991 this is updated\n-        // to be: (cap * den + den - 1) / num\n-        (cap * 10 + 10 - 1) / 11\n-    }\n-}\n-\n-#[test]\n-fn test_resize_policy() {\n-    let rp = DefaultResizePolicy;\n-    for n in 0..1000 {\n-        assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n-        assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n+        // to be: (raw_cap * den + den - 1) / num\n+        (raw_cap * 10 + 10 - 1) / 11\n     }\n }\n \n@@ -510,11 +501,11 @@ impl<K, V, S> HashMap<K, V, S>\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let cap = self.table.capacity();\n+        let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n         let ib = buckets.index();\n \n-        while buckets.index() != ib + cap {\n+        while buckets.index() != ib + raw_cap {\n             // We don't need to compare hashes for value swap.\n             // Not even DIBs for Robin Hood.\n             buckets = match buckets.peek() {\n@@ -545,7 +536,10 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty `HashMap` with the given initial capacity.\n+    /// Creates an empty `HashMap` with the specified capacity.\n+    ///\n+    /// The hash map will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -593,9 +587,11 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Creates an empty `HashMap` with space for at least `capacity`\n-    /// elements, using `hasher` to hash the keys.\n+    /// Creates an empty `HashMap` with the specified capacity, using `hasher`\n+    /// to hash the keys.\n     ///\n+    /// The hash map will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n     /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n@@ -616,13 +612,11 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)\n                                     -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n-        let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n-        let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n-        assert!(internal_cap >= capacity, \"capacity overflow\");\n+        let raw_cap = resize_policy.raw_capacity(capacity);\n         HashMap {\n             hash_builder: hash_builder,\n             resize_policy: resize_policy,\n-            table: RawTable::new(internal_cap),\n+            table: RawTable::new(raw_cap),\n         }\n     }\n \n@@ -647,7 +641,13 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.resize_policy.usable_capacity(self.table.capacity())\n+        self.resize_policy.capacity(self.raw_capacity())\n+    }\n+\n+    /// Returns the hash map's raw capacity.\n+    #[inline]\n+    fn raw_capacity(&self) -> usize {\n+        self.table.capacity()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -667,28 +667,23 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let min_cap = self.resize_policy.min_capacity(new_size);\n-\n-        // An invalid value shouldn't make us run out of space. This includes\n-        // an overflow check.\n-        assert!(new_size <= min_cap);\n-\n-        if self.table.capacity() < min_cap {\n-            let new_capacity = max(min_cap.next_power_of_two(), INITIAL_CAPACITY);\n-            self.resize(new_capacity);\n+        let min_cap = self.len().checked_add(additional).expect(\"reserve overflow\");\n+        if self.capacity() < min_cap {\n+            let raw_cap = self.resize_policy.raw_capacity(min_cap);\n+            self.resize(raw_cap);\n         }\n     }\n \n-    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n-    ///   1) Make sure the new capacity is enough for all the elements, accounting\n+    /// Resizes the internal vectors to a new capacity. It's your\n+    /// responsibility to:\n+    ///   1) Ensure `new_raw_cap` is enough for all the elements, accounting\n     ///      for the load factor.\n-    ///   2) Ensure `new_capacity` is a power of two or zero.\n-    fn resize(&mut self, new_capacity: usize) {\n-        assert!(self.table.size() <= new_capacity);\n-        assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n+    ///   2) Ensure `new_raw_cap` is a power of two or zero.\n+    fn resize(&mut self, new_raw_cap: usize) {\n+        assert!(self.table.size() <= new_raw_cap);\n+        assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n+        let mut old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n         let old_size = old_table.size();\n \n         if old_table.capacity() == 0 || old_table.size() == 0 {\n@@ -778,14 +773,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let min_capacity = self.resize_policy.min_capacity(self.len());\n-        let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n-\n-        // An invalid value shouldn't make us run out of space.\n-        debug_assert!(self.len() <= min_capacity);\n-\n-        if self.table.capacity() != min_capacity {\n-            let old_table = replace(&mut self.table, RawTable::new(min_capacity));\n+        let new_raw_cap = self.resize_policy.raw_capacity(self.len());\n+        if self.raw_capacity() != new_raw_cap {\n+            let old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n             let old_size = old_table.size();\n \n             // Shrink the table. Naive algorithm for resizing:\n@@ -2092,7 +2082,7 @@ mod test_map {\n     use rand::{thread_rng, Rng};\n \n     #[test]\n-    fn test_create_capacities() {\n+    fn test_zero_capacities() {\n         type HM = HashMap<i32, i32>;\n \n         let m = HM::new();\n@@ -2103,6 +2093,24 @@ mod test_map {\n \n         let m = HM::with_hasher(RandomState::new());\n         assert_eq!(m.capacity(), 0);\n+\n+        let m = HM::with_capacity(0);\n+        assert_eq!(m.capacity(), 0);\n+\n+        let m = HM::with_capacity_and_hasher(0, RandomState::new());\n+        assert_eq!(m.capacity(), 0);\n+\n+        let mut m = HM::new();\n+        m.insert(1, 1);\n+        m.insert(2, 2);\n+        m.remove(&1);\n+        m.remove(&2);\n+        m.shrink_to_fit();\n+        assert_eq!(m.capacity(), 0);\n+\n+        let mut m = HM::new();\n+        m.reserve(0);\n+        assert_eq!(m.capacity(), 0);\n     }\n \n     #[test]\n@@ -2562,8 +2570,8 @@ mod test_map {\n         assert!(m.is_empty());\n \n         let mut i = 0;\n-        let old_cap = m.table.capacity();\n-        while old_cap == m.table.capacity() {\n+        let old_raw_cap = m.raw_capacity();\n+        while old_raw_cap == m.raw_capacity() {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -2577,55 +2585,55 @@ mod test_map {\n         let mut m = HashMap::new();\n \n         assert_eq!(m.len(), 0);\n-        assert_eq!(m.table.capacity(), 0);\n+        assert_eq!(m.raw_capacity(), 0);\n         assert!(m.is_empty());\n \n         m.insert(0, 0);\n         m.remove(&0);\n         assert!(m.is_empty());\n-        let initial_cap = m.table.capacity();\n-        m.reserve(initial_cap);\n-        let cap = m.table.capacity();\n+        let initial_raw_cap = m.raw_capacity();\n+        m.reserve(initial_raw_cap);\n+        let raw_cap = m.raw_capacity();\n \n-        assert_eq!(cap, initial_cap * 2);\n+        assert_eq!(raw_cap, initial_raw_cap * 2);\n \n         let mut i = 0;\n-        for _ in 0..cap * 3 / 4 {\n+        for _ in 0..raw_cap * 3 / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n         // three quarters full\n \n         assert_eq!(m.len(), i);\n-        assert_eq!(m.table.capacity(), cap);\n+        assert_eq!(m.raw_capacity(), raw_cap);\n \n-        for _ in 0..cap / 4 {\n+        for _ in 0..raw_cap / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n         // half full\n \n-        let new_cap = m.table.capacity();\n-        assert_eq!(new_cap, cap * 2);\n+        let new_raw_cap = m.raw_capacity();\n+        assert_eq!(new_raw_cap, raw_cap * 2);\n \n-        for _ in 0..cap / 2 - 1 {\n+        for _ in 0..raw_cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n-            assert_eq!(m.table.capacity(), new_cap);\n+            assert_eq!(m.raw_capacity(), new_raw_cap);\n         }\n         // A little more than one quarter full.\n         m.shrink_to_fit();\n-        assert_eq!(m.table.capacity(), cap);\n+        assert_eq!(m.raw_capacity(), raw_cap);\n         // again, a little more than half full\n-        for _ in 0..cap / 2 - 1 {\n+        for _ in 0..raw_cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n         }\n         m.shrink_to_fit();\n \n         assert_eq!(m.len(), i);\n         assert!(!m.is_empty());\n-        assert_eq!(m.table.capacity(), initial_cap);\n+        assert_eq!(m.raw_capacity(), initial_raw_cap);\n     }\n \n     #[test]"}, {"sha": "dc2603dea03a88fd89ec831b5a574c94907b9774", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a9b5e4c51e995120c9739cacb305826a35ac496/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9b5e4c51e995120c9739cacb305826a35ac496/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=6a9b5e4c51e995120c9739cacb305826a35ac496", "patch": "@@ -119,8 +119,10 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n         HashSet { map: HashMap::new() }\n     }\n \n-    /// Creates an empty HashSet with space for at least `n` elements in\n-    /// the hash table.\n+    /// Creates an empty `HashSet` with the specified capacity.\n+    ///\n+    /// The hash set will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// # Examples\n     ///\n@@ -164,8 +166,11 @@ impl<T, S> HashSet<T, S>\n         HashSet { map: HashMap::with_hasher(hasher) }\n     }\n \n-    /// Creates an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `hasher` to hash the keys.\n+    /// Creates an empty HashSet with with the specified capacity, using\n+    /// `hasher` to hash the keys.\n+    ///\n+    /// The hash set will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n@@ -1068,7 +1073,7 @@ mod test_set {\n     use super::super::map::RandomState;\n \n     #[test]\n-    fn test_create_capacities() {\n+    fn test_zero_capacities() {\n         type HS = HashSet<i32>;\n \n         let s = HS::new();\n@@ -1079,6 +1084,24 @@ mod test_set {\n \n         let s = HS::with_hasher(RandomState::new());\n         assert_eq!(s.capacity(), 0);\n+\n+        let s = HS::with_capacity(0);\n+        assert_eq!(s.capacity(), 0);\n+\n+        let s = HS::with_capacity_and_hasher(0, RandomState::new());\n+        assert_eq!(s.capacity(), 0);\n+\n+        let mut s = HS::new();\n+        s.insert(1);\n+        s.insert(2);\n+        s.remove(&1);\n+        s.remove(&2);\n+        s.shrink_to_fit();\n+        assert_eq!(s.capacity(), 0);\n+\n+        let mut s = HS::new();\n+        s.reserve(0);\n+        assert_eq!(s.capacity(), 0);\n     }\n \n     #[test]"}]}