{"sha": "d901079ca1176f87c8baaed0662db117c805c9e1", "node_id": "C_kwDOAAsO6NoAKGQ5MDEwNzljYTExNzZmODdjOGJhYWVkMDY2MmRiMTE3YzgwNWM5ZTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T05:46:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T05:46:00Z"}, "message": "Auto merge of #8814 - yonip23:add-suggestion-to-rc-clone-in-vec-init, r=xFrednet\n\nadd suggestions to rc_clone_in_vec_init\n\nA followup to https://github.com/rust-lang/rust-clippy/pull/8769\nI also switch the order of the 2 suggestions, since the loop initialization one is probably the common case.\n\n`@xFrednet` I'm not letting you guys rest for a minute \ud83d\ude05\nchangelog: add suggestions to [`rc_clone_in_vec_init`]", "tree": {"sha": "9578f7ad02b17e9c75759f313c95f1b2f0c2c6a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9578f7ad02b17e9c75759f313c95f1b2f0c2c6a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d901079ca1176f87c8baaed0662db117c805c9e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d901079ca1176f87c8baaed0662db117c805c9e1", "html_url": "https://github.com/rust-lang/rust/commit/d901079ca1176f87c8baaed0662db117c805c9e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d901079ca1176f87c8baaed0662db117c805c9e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "219d702258703b78375d1ce86f6ed122cfc686fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/219d702258703b78375d1ce86f6ed122cfc686fb", "html_url": "https://github.com/rust-lang/rust/commit/219d702258703b78375d1ce86f6ed122cfc686fb"}, {"sha": "ed3744b957d318f7b22b1a2d53b867f7da42746d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3744b957d318f7b22b1a2d53b867f7da42746d", "html_url": "https://github.com/rust-lang/rust/commit/ed3744b957d318f7b22b1a2d53b867f7da42746d"}], "stats": {"total": 291, "additions": 269, "deletions": 22}, "files": [{"sha": "110f58f3734dfc348e9d00f72cd7dfce3cf4d464", "filename": "clippy_lints/src/rc_clone_in_vec_init.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d901079ca1176f87c8baaed0662db117c805c9e1/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d901079ca1176f87c8baaed0662db117c805c9e1/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs?ref=d901079ca1176f87c8baaed0662db117c805c9e1", "patch": "@@ -1,11 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::VecArgs;\n use clippy_utils::last_path_segment;\n-use clippy_utils::macros::{root_macro_call_first_node, MacroCall};\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::source::{indent_of, snippet};\n+use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -47,27 +49,76 @@ declare_lint_pass!(RcCloneInVecInit => [RC_CLONE_IN_VEC_INIT]);\n impl LateLintPass<'_> for RcCloneInVecInit {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return; };\n-        let Some(VecArgs::Repeat(elem, _)) = VecArgs::hir(cx, expr) else { return; };\n+        let Some(VecArgs::Repeat(elem, len)) = VecArgs::hir(cx, expr) else { return; };\n         let Some(symbol) = new_reference_call(cx, elem) else { return; };\n \n-        emit_lint(cx, symbol, &macro_call);\n+        emit_lint(cx, symbol, macro_call.span, elem, len);\n     }\n }\n \n-fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, macro_call: &MacroCall) {\n+fn elem_snippet(cx: &LateContext<'_>, elem: &Expr<'_>, symbol_name: &str) -> String {\n+    let elem_snippet = snippet(cx, elem.span, \"..\").to_string();\n+    if elem_snippet.contains('\\n') {\n+        // This string must be found in `elem_snippet`, otherwise we won't be constructing\n+        // the snippet in the first place.\n+        let reference_creation = format!(\"{symbol_name}::new\");\n+        let (code_until_reference_creation, _right) = elem_snippet.split_once(&reference_creation).unwrap();\n+\n+        return format!(\"{code_until_reference_creation}{reference_creation}(..)\");\n+    }\n+\n+    elem_snippet\n+}\n+\n+fn loop_init_suggestion(elem: &str, len: &str, indent: &str) -> String {\n+    format!(\n+        r#\"{{\n+{indent}    let mut v = Vec::with_capacity({len});\n+{indent}    (0..{len}).for_each(|_| v.push({elem}));\n+{indent}    v\n+{indent}}}\"#\n+    )\n+}\n+\n+fn extract_suggestion(elem: &str, len: &str, indent: &str) -> String {\n+    format!(\n+        \"{{\n+{indent}    let data = {elem};\n+{indent}    vec![data; {len}]\n+{indent}}}\"\n+    )\n+}\n+\n+fn emit_lint(cx: &LateContext<'_>, symbol: Symbol, lint_span: Span, elem: &Expr<'_>, len: &Expr<'_>) {\n     let symbol_name = symbol.as_str();\n \n     span_lint_and_then(\n         cx,\n         RC_CLONE_IN_VEC_INIT,\n-        macro_call.span,\n+        lint_span,\n         &format!(\"calling `{symbol_name}::new` in `vec![elem; len]`\"),\n         |diag| {\n+            let len_snippet = snippet(cx, len.span, \"..\");\n+            let elem_snippet = elem_snippet(cx, elem, symbol_name);\n+            let indentation = \" \".repeat(indent_of(cx, lint_span).unwrap_or(0));\n+            let loop_init_suggestion = loop_init_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n+            let extract_suggestion = extract_suggestion(&elem_snippet, len_snippet.as_ref(), &indentation);\n+\n             diag.note(format!(\"each element will point to the same `{symbol_name}` instance\"));\n-            diag.help(format!(\n-                \"if this is intentional, consider extracting the `{symbol_name}` initialization to a variable\"\n-            ));\n-            diag.help(\"or if not, initialize each element individually\");\n+            diag.span_suggestion(\n+                lint_span,\n+                format!(\"consider initializing each `{symbol_name}` element individually\"),\n+                loop_init_suggestion,\n+                Applicability::Unspecified,\n+            );\n+            diag.span_suggestion(\n+                lint_span,\n+                format!(\n+                    \"or if this is intentional, consider extracting the `{symbol_name}` initialization to a variable\"\n+                ),\n+                extract_suggestion,\n+                Applicability::Unspecified,\n+            );\n         },\n     );\n }"}, {"sha": "384060e6eae5033ef82d1998734e5aa1da557d57", "filename": "tests/ui/rc_clone_in_vec_init/arc.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Farc.rs?ref=d901079ca1176f87c8baaed0662db117c805c9e1", "patch": "@@ -7,6 +7,16 @@ fn should_warn_simple_case() {\n     let v = vec![Arc::new(\"x\".to_string()); 2];\n }\n \n+fn should_warn_simple_case_with_big_indentation() {\n+    if true {\n+        let k = 1;\n+        dbg!(k);\n+        if true {\n+            let v = vec![Arc::new(\"x\".to_string()); 2];\n+        }\n+    }\n+}\n+\n fn should_warn_complex_case() {\n     let v = vec![\n         std::sync::Arc::new(Mutex::new({\n@@ -16,6 +26,15 @@ fn should_warn_complex_case() {\n         }));\n         2\n     ];\n+\n+    let v1 = vec![\n+        Arc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        }));\n+        2\n+    ];\n }\n \n fn should_not_warn_custom_arc() {"}, {"sha": "ce84186c8e300e15c988d76870740f40e13673db", "filename": "tests/ui/rc_clone_in_vec_init/arc.stderr", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Farc.stderr?ref=d901079ca1176f87c8baaed0662db117c805c9e1", "patch": "@@ -6,11 +6,47 @@ LL |     let v = vec![Arc::new(\"x\".to_string()); 2];\n    |\n    = note: `-D clippy::rc-clone-in-vec-init` implied by `-D warnings`\n    = note: each element will point to the same `Arc` instance\n-   = help: if this is intentional, consider extracting the `Arc` initialization to a variable\n-   = help: or if not, initialize each element individually\n+help: consider initializing each `Arc` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Arc::new(\"x\".to_string())));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = Arc::new(\"x\".to_string());\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: calling `Arc::new` in `vec![elem; len]`\n+  --> $DIR/arc.rs:15:21\n+   |\n+LL |             let v = vec![Arc::new(\"x\".to_string()); 2];\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Arc` instance\n+help: consider initializing each `Arc` element individually\n+   |\n+LL ~             let v = {\n+LL +                 let mut v = Vec::with_capacity(2);\n+LL +                 (0..2).for_each(|_| v.push(Arc::new(\"x\".to_string())));\n+LL +                 v\n+LL ~             };\n+   |\n+help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n+   |\n+LL ~             let v = {\n+LL +                 let data = Arc::new(\"x\".to_string());\n+LL +                 vec![data; 2]\n+LL ~             };\n+   |\n \n error: calling `Arc::new` in `vec![elem; len]`\n-  --> $DIR/arc.rs:11:13\n+  --> $DIR/arc.rs:21:13\n    |\n LL |       let v = vec![\n    |  _____________^\n@@ -23,8 +59,51 @@ LL | |     ];\n    | |_____^\n    |\n    = note: each element will point to the same `Arc` instance\n-   = help: if this is intentional, consider extracting the `Arc` initialization to a variable\n-   = help: or if not, initialize each element individually\n+help: consider initializing each `Arc` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(std::sync::Arc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = std::sync::Arc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: calling `Arc::new` in `vec![elem; len]`\n+  --> $DIR/arc.rs:30:14\n+   |\n+LL |       let v1 = vec![\n+   |  ______________^\n+LL | |         Arc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Arc` instance\n+help: consider initializing each `Arc` element individually\n+   |\n+LL ~     let v1 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Arc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Arc` initialization to a variable\n+   |\n+LL ~     let v1 = {\n+LL +         let data = Arc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "0394457fe1708274e2e4e7987b2615dcff68f298", "filename": "tests/ui/rc_clone_in_vec_init/rc.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Frc.rs?ref=d901079ca1176f87c8baaed0662db117c805c9e1", "patch": "@@ -8,6 +8,16 @@ fn should_warn_simple_case() {\n     let v = vec![Rc::new(\"x\".to_string()); 2];\n }\n \n+fn should_warn_simple_case_with_big_indentation() {\n+    if true {\n+        let k = 1;\n+        dbg!(k);\n+        if true {\n+            let v = vec![Rc::new(\"x\".to_string()); 2];\n+        }\n+    }\n+}\n+\n fn should_warn_complex_case() {\n     let v = vec![\n         std::rc::Rc::new(Mutex::new({\n@@ -17,6 +27,15 @@ fn should_warn_complex_case() {\n         }));\n         2\n     ];\n+\n+    let v1 = vec![\n+        Rc::new(Mutex::new({\n+            let x = 1;\n+            dbg!(x);\n+            x\n+        }));\n+        2\n+    ];\n }\n \n fn should_not_warn_custom_arc() {"}, {"sha": "0f5cc0cf98feaa415efc44841647f1847b7d9bfc", "filename": "tests/ui/rc_clone_in_vec_init/rc.stderr", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d901079ca1176f87c8baaed0662db117c805c9e1/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_clone_in_vec_init%2Frc.stderr?ref=d901079ca1176f87c8baaed0662db117c805c9e1", "patch": "@@ -6,11 +6,47 @@ LL |     let v = vec![Rc::new(\"x\".to_string()); 2];\n    |\n    = note: `-D clippy::rc-clone-in-vec-init` implied by `-D warnings`\n    = note: each element will point to the same `Rc` instance\n-   = help: if this is intentional, consider extracting the `Rc` initialization to a variable\n-   = help: or if not, initialize each element individually\n+help: consider initializing each `Rc` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Rc::new(\"x\".to_string())));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = Rc::new(\"x\".to_string());\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: calling `Rc::new` in `vec![elem; len]`\n+  --> $DIR/rc.rs:16:21\n+   |\n+LL |             let v = vec![Rc::new(\"x\".to_string()); 2];\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each element will point to the same `Rc` instance\n+help: consider initializing each `Rc` element individually\n+   |\n+LL ~             let v = {\n+LL +                 let mut v = Vec::with_capacity(2);\n+LL +                 (0..2).for_each(|_| v.push(Rc::new(\"x\".to_string())));\n+LL +                 v\n+LL ~             };\n+   |\n+help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n+   |\n+LL ~             let v = {\n+LL +                 let data = Rc::new(\"x\".to_string());\n+LL +                 vec![data; 2]\n+LL ~             };\n+   |\n \n error: calling `Rc::new` in `vec![elem; len]`\n-  --> $DIR/rc.rs:12:13\n+  --> $DIR/rc.rs:22:13\n    |\n LL |       let v = vec![\n    |  _____________^\n@@ -23,8 +59,51 @@ LL | |     ];\n    | |_____^\n    |\n    = note: each element will point to the same `Rc` instance\n-   = help: if this is intentional, consider extracting the `Rc` initialization to a variable\n-   = help: or if not, initialize each element individually\n+help: consider initializing each `Rc` element individually\n+   |\n+LL ~     let v = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(std::rc::Rc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n+   |\n+LL ~     let v = {\n+LL +         let data = std::rc::Rc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n+\n+error: calling `Rc::new` in `vec![elem; len]`\n+  --> $DIR/rc.rs:31:14\n+   |\n+LL |       let v1 = vec![\n+   |  ______________^\n+LL | |         Rc::new(Mutex::new({\n+LL | |             let x = 1;\n+LL | |             dbg!(x);\n+...  |\n+LL | |         2\n+LL | |     ];\n+   | |_____^\n+   |\n+   = note: each element will point to the same `Rc` instance\n+help: consider initializing each `Rc` element individually\n+   |\n+LL ~     let v1 = {\n+LL +         let mut v = Vec::with_capacity(2);\n+LL +         (0..2).for_each(|_| v.push(Rc::new(..)));\n+LL +         v\n+LL ~     };\n+   |\n+help: or if this is intentional, consider extracting the `Rc` initialization to a variable\n+   |\n+LL ~     let v1 = {\n+LL +         let data = Rc::new(..);\n+LL +         vec![data; 2]\n+LL ~     };\n+   |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}]}