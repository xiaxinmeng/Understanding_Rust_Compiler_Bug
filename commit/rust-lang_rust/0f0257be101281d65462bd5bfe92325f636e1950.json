{"sha": "0f0257be101281d65462bd5bfe92325f636e1950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMDI1N2JlMTAxMjgxZDY1NDYyYmQ1YmZlOTIzMjVmNjM2ZTE5NTA=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T18:38:25Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:22:05Z"}, "message": "Take some of sys/vxworks/process/* from sys/unix instead.", "tree": {"sha": "b68c5f9df58359294cc0b98768bb9799f4e7b839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b68c5f9df58359294cc0b98768bb9799f4e7b839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f0257be101281d65462bd5bfe92325f636e1950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0257be101281d65462bd5bfe92325f636e1950", "html_url": "https://github.com/rust-lang/rust/commit/0f0257be101281d65462bd5bfe92325f636e1950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f0257be101281d65462bd5bfe92325f636e1950/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "408db0da85943bde9b83d128f997bf4ad4df5d42", "url": "https://api.github.com/repos/rust-lang/rust/commits/408db0da85943bde9b83d128f997bf4ad4df5d42", "html_url": "https://github.com/rust-lang/rust/commit/408db0da85943bde9b83d128f997bf4ad4df5d42"}], "stats": {"total": 484, "additions": 77, "deletions": 407}, "files": [{"sha": "3615a8a5ee8b0432be4e369993d1cd360cb57a00", "filename": "library/std/src/sys/unix/ext/process.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=0f0257be101281d65462bd5bfe92325f636e1950", "patch": "@@ -16,12 +16,20 @@ pub trait CommandExt {\n     /// `setuid` call in the child process. Failure in the `setuid`\n     /// call will cause the spawn to fail.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u32) -> &mut process::Command;\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Similar to `uid`, but sets the group ID of the child process. This has\n     /// the same semantics as the `uid` field.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u32) -> &mut process::Command;\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -115,12 +123,20 @@ pub trait CommandExt {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u32) -> &mut process::Command {\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().uid(id);\n         self\n     }\n \n-    fn gid(&mut self, id: u32) -> &mut process::Command {\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().gid(id);\n         self\n     }"}, {"sha": "4b29b7020eb8547e30ab1d55b91f84d177ed235e", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=0f0257be101281d65462bd5bfe92325f636e1950", "patch": "@@ -24,6 +24,8 @@ cfg_if::cfg_if! {\n         // fuchsia doesn't have /dev/null\n     } else if #[cfg(target_os = \"redox\")] {\n         const DEV_NULL: &str = \"null:\\0\";\n+    } else if #[cfg(target_os = \"vxworks\")] {\n+        const DEV_NULL: &str = \"/null\\0\";\n     } else {\n         const DEV_NULL: &str = \"/dev/null\\0\";\n     }\n@@ -48,7 +50,7 @@ cfg_if::cfg_if! {\n             raw[bit / 8] |= 1 << (bit % 8);\n             return 0;\n         }\n-    } else {\n+    } else if #[cfg(not(target_os = \"vxworks\"))] {\n         pub use libc::{sigemptyset, sigaddset};\n     }\n }"}, {"sha": "b5be92e3eae006ebb4faf8370e6128cfcd14bb04", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=0f0257be101281d65462bd5bfe92325f636e1950", "patch": "@@ -6,6 +6,10 @@ use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n \n+#[cfg(target_os = \"vxworks\")]\n+use libc::RTP_ID as pid_t;\n+\n+#[cfg(not(target_os = \"vxworks\"))]\n use libc::{c_int, gid_t, pid_t, uid_t};\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "dc6130eaa24a8ad5b3dabae4191089544990cf14", "filename": "library/std/src/sys/vxworks/process/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=0f0257be101281d65462bd5bfe92325f636e1950", "patch": "@@ -1,7 +1,9 @@\n-pub use self::process_common::{Command, ExitCode, ExitStatus, Stdio, StdioPipes};\n-pub use self::process_inner::Process;\n+pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\n+pub use self::process_inner::{ExitStatus, Process};\n pub use crate::ffi::OsString as EnvKey;\n+pub use crate::sys_common::process::CommandEnvs;\n \n+#[path = \"../../unix/process/process_common.rs\"]\n mod process_common;\n #[path = \"process_vxworks.rs\"]\n mod process_inner;"}, {"sha": "6473a0c3cec41aa764d824f02a81f1765773b781", "filename": "library/std/src/sys/vxworks/process/process_common.rs", "status": "removed", "additions": 0, "deletions": 399, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408db0da85943bde9b83d128f997bf4ad4df5d42/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=408db0da85943bde9b83d128f997bf4ad4df5d42", "patch": "@@ -1,399 +0,0 @@\n-use crate::os::unix::prelude::*;\n-\n-use crate::collections::BTreeMap;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io;\n-use crate::ptr;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::fs::{File, OpenOptions};\n-use crate::sys::pipe::{self, AnonPipe};\n-use crate::sys_common::process::CommandEnv;\n-\n-use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    // Currently we try hard to ensure that the call to `.exec()` doesn't\n-    // actually allocate any memory. While many platforms try to ensure that\n-    // memory allocation works after a fork in a multithreaded process, it's\n-    // been observed to be buggy and somewhat unreliable, so we do our best to\n-    // just not do it at all!\n-    //\n-    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n-    // what's gonna get passed to `execvp`. The `argv` array starts with the\n-    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n-    // also null-terminated.\n-    //\n-    // Right now we don't support removing arguments, so there's no much fancy\n-    // support there, but we support adding and removing environment variables,\n-    // so a side table is used to track where in the `envp` array each key is\n-    // located. Whenever we add a key we update it in place if it's already\n-    // present, and whenever we remove a key we update the locations of all\n-    // other keys.\n-    program: CString,\n-    args: Vec<CString>,\n-    argv: Argv,\n-    env: CommandEnv,\n-\n-    cwd: Option<CString>,\n-    uid: Option<uid_t>,\n-    gid: Option<gid_t>,\n-    saw_nul: bool,\n-    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n-}\n-\n-// Create a new type for `Argv`, so that we can make it `Send` and `Sync`\n-struct Argv(Vec<*const c_char>);\n-\n-// It is safe to make `Argv` `Send` and `Sync`, because it contains\n-// pointers to memory owned by `Command.args`\n-unsafe impl Send for Argv {}\n-unsafe impl Sync for Argv {}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-// passed to do_exec() with configuration of what the child stdio should look\n-// like\n-pub struct ChildPipes {\n-    pub stdin: ChildStdio,\n-    pub stdout: ChildStdio,\n-    pub stderr: ChildStdio,\n-}\n-\n-pub enum ChildStdio {\n-    Inherit,\n-    Explicit(c_int),\n-    Owned(FileDesc),\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-    Fd(FileDesc),\n-}\n-\n-impl Command {\n-    pub fn new(program: &OsStr) -> Command {\n-        let mut saw_nul = false;\n-        let program = os2c(program, &mut saw_nul);\n-        Command {\n-            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n-            args: vec![program.clone()],\n-            program,\n-            env: Default::default(),\n-            cwd: None,\n-            uid: None,\n-            gid: None,\n-            saw_nul,\n-            closures: Vec::new(),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n-    }\n-\n-    pub fn set_arg_0(&mut self, arg: &OsStr) {\n-        // Set a new arg0\n-        let arg = os2c(arg, &mut self.saw_nul);\n-        debug_assert!(self.argv.0.len() > 1);\n-        self.argv.0[0] = arg.as_ptr();\n-        self.args[0] = arg;\n-    }\n-\n-    pub fn arg(&mut self, arg: &OsStr) {\n-        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n-        // pointer.\n-        let arg = os2c(arg, &mut self.saw_nul);\n-        self.argv.0[self.args.len()] = arg.as_ptr();\n-        self.argv.0.push(ptr::null());\n-\n-        // Also make sure we keep track of the owned value to schedule a\n-        // destructor for this memory.\n-        self.args.push(arg);\n-    }\n-\n-    pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n-    }\n-    pub fn uid(&mut self, id: uid_t) {\n-        self.uid = Some(id);\n-    }\n-    pub fn gid(&mut self, id: gid_t) {\n-        self.gid = Some(id);\n-    }\n-\n-    pub fn saw_nul(&self) -> bool {\n-        self.saw_nul\n-    }\n-    pub fn get_argv(&self) -> &Vec<*const c_char> {\n-        &self.argv.0\n-    }\n-\n-    pub fn get_program(&self) -> &CStr {\n-        &*self.program\n-    }\n-\n-    #[allow(dead_code)]\n-    pub fn get_cwd(&self) -> &Option<CString> {\n-        &self.cwd\n-    }\n-    #[allow(dead_code)]\n-    pub fn get_uid(&self) -> Option<uid_t> {\n-        self.uid\n-    }\n-    #[allow(dead_code)]\n-    pub fn get_gid(&self) -> Option<gid_t> {\n-        self.gid\n-    }\n-\n-    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {\n-        &mut self.closures\n-    }\n-\n-    pub unsafe fn pre_exec(&mut self, _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n-        // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n-        unimplemented!();\n-    }\n-\n-    pub fn stdin(&mut self, stdin: Stdio) {\n-        self.stdin = Some(stdin);\n-    }\n-\n-    pub fn stdout(&mut self, stdout: Stdio) {\n-        self.stdout = Some(stdout);\n-    }\n-\n-    pub fn stderr(&mut self, stderr: Stdio) {\n-        self.stderr = Some(stderr);\n-    }\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn capture_env(&mut self) -> Option<CStringArray> {\n-        let maybe_env = self.env.capture_if_changed();\n-        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n-    }\n-    #[allow(dead_code)]\n-    pub fn env_saw_path(&self) -> bool {\n-        self.env.have_changed_path()\n-    }\n-\n-    pub fn setup_io(\n-        &self,\n-        default: Stdio,\n-        needs_stdin: bool,\n-    ) -> io::Result<(StdioPipes, ChildPipes)> {\n-        let null = Stdio::Null;\n-        let default_stdin = if needs_stdin { &default } else { &null };\n-        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n-        let stdout = self.stdout.as_ref().unwrap_or(&default);\n-        let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n-        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n-        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n-        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n-        Ok((ours, theirs))\n-    }\n-}\n-\n-fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n-    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"<string-with-nul>\").unwrap()\n-    })\n-}\n-\n-// Helper type to manage ownership of the strings within a C-style array.\n-pub struct CStringArray {\n-    items: Vec<CString>,\n-    ptrs: Vec<*const c_char>,\n-}\n-\n-impl CStringArray {\n-    pub fn with_capacity(capacity: usize) -> Self {\n-        let mut result = CStringArray {\n-            items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity + 1),\n-        };\n-        result.ptrs.push(ptr::null());\n-        result\n-    }\n-    pub fn push(&mut self, item: CString) {\n-        let l = self.ptrs.len();\n-        self.ptrs[l - 1] = item.as_ptr();\n-        self.ptrs.push(ptr::null());\n-        self.items.push(item);\n-    }\n-    pub fn as_ptr(&self) -> *const *const c_char {\n-        self.ptrs.as_ptr()\n-    }\n-}\n-\n-fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n-    let mut result = CStringArray::with_capacity(env.len());\n-    for (k, v) in env {\n-        let mut k: OsString = k.into();\n-\n-        // Reserve additional space for '=' and null terminator\n-        k.reserve_exact(v.len() + 2);\n-        k.push(\"=\");\n-        k.push(&v);\n-\n-        // Add the new entry into the array\n-        if let Ok(item) = CString::new(k.into_vec()) {\n-            result.push(item);\n-        } else {\n-            *saw_nul = true;\n-        }\n-    }\n-\n-    result\n-}\n-\n-impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n-        match *self {\n-            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n-\n-            // Make sure that the source descriptors are not an stdio\n-            // descriptor, otherwise the order which we set the child's\n-            // descriptors may blow away a descriptor which we are hoping to\n-            // save. For example, suppose we want the child's stderr to be the\n-            // parent's stdout, and the child's stdout to be the parent's\n-            // stderr. No matter which we dup first, the second will get\n-            // overwritten prematurely.\n-            Stdio::Fd(ref fd) => {\n-                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n-                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n-                } else {\n-                    Ok((ChildStdio::Explicit(fd.raw()), None))\n-                }\n-            }\n-\n-            Stdio::MakePipe => {\n-                let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n-                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n-            }\n-\n-            Stdio::Null => {\n-                let mut opts = OpenOptions::new();\n-                opts.read(readable);\n-                opts.write(!readable);\n-                let path = unsafe { CStr::from_ptr(\"/null\\0\".as_ptr() as *const _) };\n-                let fd = File::open_c(&path, &opts)?;\n-                Ok((ChildStdio::Owned(fd.into_fd()), None))\n-            }\n-        }\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Fd(pipe.into_fd())\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        Stdio::Fd(file.into_fd())\n-    }\n-}\n-\n-impl ChildStdio {\n-    pub fn fd(&self) -> Option<c_int> {\n-        match *self {\n-            ChildStdio::Inherit => None,\n-            ChildStdio::Explicit(fd) => Some(fd),\n-            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.program != self.args[0] {\n-            write!(f, \"[{:?}] \", self.program)?;\n-        }\n-        write!(f, \"{:?}\", self.args[0])?;\n-\n-        for arg in &self.args[1..] {\n-            write!(f, \" {:?}\", arg)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n-\n-impl ExitStatus {\n-    pub fn new(status: c_int) -> ExitStatus {\n-        ExitStatus(status)\n-    }\n-\n-    fn exited(&self) -> bool {\n-        libc::WIFEXITED(self.0)\n-    }\n-\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n-    }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n-    }\n-}\n-\n-/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n-impl From<c_int> for ExitStatus {\n-    fn from(a: c_int) -> ExitStatus {\n-        ExitStatus(a)\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(u8);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n-    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n-\n-    #[inline]\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}"}, {"sha": "69adbcdddc971eb5582b14ae09ab4825dff7a9f0", "filename": "library/std/src/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f0257be101281d65462bd5bfe92325f636e1950/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=0f0257be101281d65462bd5bfe92325f636e1950", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::sys;\n use crate::sys::cvt;\n@@ -67,7 +68,7 @@ impl Command {\n             let _lock = sys::os::env_lock();\n \n             let ret = libc::rtpSpawn(\n-                self.get_program().as_ptr(),\n+                self.get_program_cstr().as_ptr(),\n                 self.get_argv().as_ptr() as *mut *const c_char, // argv\n                 c_envp as *mut *const c_char,\n                 100 as c_int, // initial priority\n@@ -167,3 +168,47 @@ impl Process {\n         }\n     }\n }\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn new(status: c_int) -> ExitStatus {\n+        ExitStatus(status)\n+    }\n+\n+    fn exited(&self) -> bool {\n+        libc::WIFEXITED(self.0)\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n+    }\n+}\n+\n+/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}"}]}