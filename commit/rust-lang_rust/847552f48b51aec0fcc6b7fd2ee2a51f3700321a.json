{"sha": "847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NzU1MmY0OGI1MWFlYzBmY2M2YjdmZDJlZTJhNTFmMzcwMDMyMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T23:18:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-07T23:18:37Z"}, "message": "auto merge of #6301 : bjz/rust/numeric-traits, r=pcwalton\n\nThis is part of the redesign of the numeric traits tracked in issue #4819.\r\n\r\nRenamed:\r\n\r\n- `Exponential::expm1` -> `Float::exp_m1` - for consistency with underscore usage elsewhere\r\n- `Exponential::log` -> `Exponential::ln` - a less ambiguous name for the natural logarithm\r\n- `{float, f64, f32}::logarithm` -> `Exponential::log` - for arbitrary base logarithms\r\n- `Real::log_2` -> `Real::ln_2`  - for consistency with `ln`\r\n- `Real::log_10` -> `Real::ln_10` - for consistency with `ln`\r\n\r\nAdded:\r\n\r\n- `Signed::abs_sub` - wraps libm's `fdim` function\r\n- `Float::is_normal` - returns `true` if the number is neither zero, infinite, subnormal or NaN\r\n- `Float::classify` - returns the floating point category of the number\r\n- `Float::ln_1p` - returns the natural logarithm of the number plus one", "tree": {"sha": "591d59854d9ea4edfa1777406d1ec12efff7f25e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/591d59854d9ea4edfa1777406d1ec12efff7f25e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "html_url": "https://github.com/rust-lang/rust/commit/847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a34e93651cb84536a23f9cdb6290bdee6446264", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a34e93651cb84536a23f9cdb6290bdee6446264", "html_url": "https://github.com/rust-lang/rust/commit/3a34e93651cb84536a23f9cdb6290bdee6446264"}, {"sha": "cc51186be0c68897042a72bd52147e345ad2a2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc51186be0c68897042a72bd52147e345ad2a2cd", "html_url": "https://github.com/rust-lang/rust/commit/cc51186be0c68897042a72bd52147e345ad2a2cd"}], "stats": {"total": 498, "additions": 422, "deletions": 76}, "files": [{"sha": "a80703fafa3d22918b3f7cb49c71a25dee5a0164", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -33,7 +33,8 @@ pub mod c_double_utils {\n         unsafe fn erf(n: c_double) -> c_double;\n         unsafe fn erfc(n: c_double) -> c_double;\n         unsafe fn exp(n: c_double) -> c_double;\n-        unsafe fn expm1(n: c_double) -> c_double;\n+        // rename: for consistency with underscore usage elsewhere\n+        #[link_name=\"expm1\"] unsafe fn exp_m1(n: c_double) -> c_double;\n         unsafe fn exp2(n: c_double) -> c_double;\n         #[link_name=\"fabs\"] unsafe fn abs(n: c_double) -> c_double;\n         // rename: for clarity and consistency with add/sub/mul/div\n@@ -63,7 +64,7 @@ pub mod c_double_utils {\n         // renamed: \"logb\" /often/ is confused for log2 by beginners\n         #[link_name=\"logb\"] unsafe fn log_radix(n: c_double) -> c_double;\n         // renamed: to be consitent with log as ln\n-        #[link_name=\"log1p\"] unsafe fn ln1p(n: c_double) -> c_double;\n+        #[link_name=\"log1p\"] unsafe fn ln_1p(n: c_double) -> c_double;\n         unsafe fn log10(n: c_double) -> c_double;\n         unsafe fn log2(n: c_double) -> c_double;\n         #[link_name=\"ilogb\"] unsafe fn ilog_radix(n: c_double) -> c_int;\n@@ -117,7 +118,7 @@ pub mod c_float_utils {\n         #[link_name=\"erff\"] unsafe fn erf(n: c_float) -> c_float;\n         #[link_name=\"erfcf\"] unsafe fn erfc(n: c_float) -> c_float;\n         #[link_name=\"expf\"] unsafe fn exp(n: c_float) -> c_float;\n-        #[link_name=\"expm1f\"]unsafe fn expm1(n: c_float) -> c_float;\n+        #[link_name=\"expm1f\"]unsafe fn exp_m1(n: c_float) -> c_float;\n         #[link_name=\"exp2f\"] unsafe fn exp2(n: c_float) -> c_float;\n         #[link_name=\"fabsf\"] unsafe fn abs(n: c_float) -> c_float;\n         #[link_name=\"fdimf\"]\n@@ -148,7 +149,7 @@ pub mod c_float_utils {\n \n         #[link_name=\"logf\"] unsafe fn ln(n: c_float) -> c_float;\n         #[link_name=\"logbf\"] unsafe fn log_radix(n: c_float) -> c_float;\n-        #[link_name=\"log1pf\"] unsafe fn ln1p(n: c_float) -> c_float;\n+        #[link_name=\"log1pf\"] unsafe fn ln_1p(n: c_float) -> c_float;\n         #[link_name=\"log2f\"] unsafe fn log2(n: c_float) -> c_float;\n         #[link_name=\"log10f\"] unsafe fn log10(n: c_float) -> c_float;\n         #[link_name=\"ilogbf\"] unsafe fn ilog_radix(n: c_float) -> c_int;"}, {"sha": "3c4faa95dd190ec9e6d17a5e3ff6911fbe52fd76", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 123, "deletions": 24, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -11,6 +11,7 @@\n //! Operations and constants for `f32`\n \n use num::{Zero, One, strconv};\n+use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use prelude::*;\n \n pub use cmath::c_float_targ_consts::*;\n@@ -82,7 +83,7 @@ delegate!(\n     fn cosh(n: c_float) -> c_float = c_float_utils::cosh,\n     fn erf(n: c_float) -> c_float = c_float_utils::erf,\n     fn erfc(n: c_float) -> c_float = c_float_utils::erfc,\n-    fn expm1(n: c_float) -> c_float = c_float_utils::expm1,\n+    fn exp_m1(n: c_float) -> c_float = c_float_utils::exp_m1,\n     fn abs_sub(a: c_float, b: c_float) -> c_float = c_float_utils::abs_sub,\n     fn fmax(a: c_float, b: c_float) -> c_float = c_float_utils::fmax,\n     fn fmin(a: c_float, b: c_float) -> c_float = c_float_utils::fmin,\n@@ -92,7 +93,7 @@ delegate!(\n     fn ldexp(x: c_float, n: c_int) -> c_float = c_float_utils::ldexp,\n     fn lgamma(n: c_float, sign: &mut c_int) -> c_float = c_float_utils::lgamma,\n     fn log_radix(n: c_float) -> c_float = c_float_utils::log_radix,\n-    fn ln1p(n: c_float) -> c_float = c_float_utils::ln1p,\n+    fn ln_1p(n: c_float) -> c_float = c_float_utils::ln_1p,\n     fn ilog_radix(n: c_float) -> c_int = c_float_utils::ilog_radix,\n     fn modf(n: c_float, iptr: &mut c_float) -> c_float = c_float_utils::modf,\n     fn round(n: c_float) -> c_float = c_float_utils::round,\n@@ -195,11 +196,6 @@ pub mod consts {\n     pub static ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[inline(always)]\n-pub fn logarithm(n: f32, b: f32) -> f32 {\n-    return log2(n) / log2(b);\n-}\n-\n impl Num for f32 {}\n \n #[cfg(notest)]\n@@ -317,6 +313,13 @@ impl Signed for f32 {\n     #[inline(always)]\n     fn abs(&self) -> f32 { abs(*self) }\n \n+    ///\n+    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline(always)]\n+    fn abs_sub(&self, other: &f32) -> f32 { abs_sub(*self, *other) }\n+\n     ///\n     /// # Returns\n     ///\n@@ -413,21 +416,27 @@ impl Trigonometric for f32 {\n }\n \n impl Exponential for f32 {\n+    /// Returns the exponential of the number\n     #[inline(always)]\n     fn exp(&self) -> f32 { exp(*self) }\n \n+    /// Returns 2 raised to the power of the number\n     #[inline(always)]\n     fn exp2(&self) -> f32 { exp2(*self) }\n \n+    /// Returns the natural logarithm of the number\n     #[inline(always)]\n-    fn expm1(&self) -> f32 { expm1(*self) }\n+    fn ln(&self) -> f32 { ln(*self) }\n \n+    /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self) -> f32 { ln(*self) }\n+    fn log(&self, base: f32) -> f32 { self.ln() / base.ln() }\n \n+    /// Returns the base 2 logarithm of the number\n     #[inline(always)]\n     fn log2(&self) -> f32 { log2(*self) }\n \n+    /// Returns the base 10 logarithm of the number\n     #[inline(always)]\n     fn log10(&self) -> f32 { log10(*self) }\n }\n@@ -504,13 +513,13 @@ impl Real for f32 {\n     #[inline(always)]\n     fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n \n-    /// log(2.0)\n+    /// ln(2.0)\n     #[inline(always)]\n-    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n \n-    /// log(10.0)\n+    /// ln(10.0)\n     #[inline(always)]\n-    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n@@ -550,9 +559,49 @@ impl Float for f32 {\n     #[inline(always)]\n     fn neg_zero() -> f32 { -0.0 }\n \n+    /// Returns `true` if the number is NaN\n     #[inline(always)]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool {\n+        match self.classify() {\n+            FPNormal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u32 = 0x7f800000;\n+        static MAN_MASK: u32 = 0x007fffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & EXP_MASK,\n+            unsafe { ::cast::transmute::<f32,u32>(*self) } & MAN_MASK\n+        ) {\n+            (EXP_MASK, 0)        => FPInfinite,\n+            (EXP_MASK, _)        => FPNaN,\n+            (exp, _) if exp != 0 => FPNormal,\n+            _ if self.is_zero()  => FPZero,\n+            _                    => FPSubnormal,\n+        }\n+    }\n+\n     #[inline(always)]\n     fn mantissa_digits() -> uint { 24 }\n \n@@ -574,17 +623,19 @@ impl Float for f32 {\n     #[inline(always)]\n     fn max_10_exp() -> int { 38 }\n \n-    /// Returns `true` if the number is infinite\n+    ///\n+    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n+    /// even if the number is close to zero\n+    ///\n     #[inline(always)]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n-    }\n+    fn exp_m1(&self) -> f32 { exp_m1(*self) }\n \n-    /// Returns `true` if the number is finite\n+    ///\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n+    /// than if the operations were performed separately\n+    ///\n     #[inline(always)]\n-    fn is_finite(&self) -> bool {\n-        !(self.is_NaN() || self.is_infinite())\n-    }\n+    fn ln_1p(&self) -> f32 { ln_1p(*self) }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n@@ -823,6 +874,7 @@ impl num::FromStrRadix for f32 {\n #[cfg(test)]\n mod tests {\n     use f32::*;\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -938,12 +990,12 @@ mod tests {\n         assert_approx_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n         assert_approx_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n         assert_approx_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n-        assert_approx_eq!(Real::log_2::<f32>(), 2f32.log());\n-        assert_approx_eq!(Real::log_10::<f32>(), 10f32.log());\n+        assert_approx_eq!(Real::ln_2::<f32>(), 2f32.ln());\n+        assert_approx_eq!(Real::ln_10::<f32>(), 10f32.ln());\n     }\n \n     #[test]\n-    pub fn test_signed() {\n+    pub fn test_abs() {\n         assert_eq!(infinity.abs(), infinity);\n         assert_eq!(1f32.abs(), 1f32);\n         assert_eq!(0f32.abs(), 0f32);\n@@ -952,7 +1004,24 @@ mod tests {\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f32/neg_infinity).abs(), 0f32);\n         assert!(NaN.abs().is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f32).abs_sub(&1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(&1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(&0f32), 1f32);\n+        assert_eq!(1f32.abs_sub(&-1f32), 2f32);\n+        assert_eq!(neg_infinity.abs_sub(&0f32), 0f32);\n+        assert_eq!(infinity.abs_sub(&1f32), infinity);\n+        assert_eq!(0f32.abs_sub(&neg_infinity), infinity);\n+        assert_eq!(0f32.abs_sub(&infinity), 0f32);\n+        assert!(NaN.abs_sub(&-1f32).is_NaN());\n+        assert!(1f32.abs_sub(&NaN).is_NaN());\n+    }\n \n+    #[test]\n+    fn test_signum() {\n         assert_eq!(infinity.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n         assert_eq!(0f32.signum(), 1f32);\n@@ -961,7 +1030,10 @@ mod tests {\n         assert_eq!(neg_infinity.signum(), -1f32);\n         assert_eq!((1f32/neg_infinity).signum(), -1f32);\n         assert!(NaN.signum().is_NaN());\n+    }\n \n+    #[test]\n+    fn test_is_positive() {\n         assert!(infinity.is_positive());\n         assert!(1f32.is_positive());\n         assert!(0f32.is_positive());\n@@ -970,7 +1042,10 @@ mod tests {\n         assert!(!neg_infinity.is_positive());\n         assert!(!(1f32/neg_infinity).is_positive());\n         assert!(!NaN.is_positive());\n+    }\n \n+    #[test]\n+    fn test_is_negative() {\n         assert!(!infinity.is_negative());\n         assert!(!1f32.is_negative());\n         assert!(!0f32.is_negative());\n@@ -995,4 +1070,28 @@ mod tests {\n         assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);\n         assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n     }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<f32>().is_normal());\n+        assert!(!Float::infinity::<f32>().is_normal());\n+        assert!(!Float::neg_infinity::<f32>().is_normal());\n+        assert!(!Zero::zero::<f32>().is_normal());\n+        assert!(!Float::neg_zero::<f32>().is_normal());\n+        assert!(1f32.is_normal());\n+        assert!(1e-37f32.is_normal());\n+        assert!(!1e-38f32.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<f32>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<f32>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<f32>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<f32>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<f32>().classify(), FPZero);\n+        assert_eq!(1f32.classify(), FPNormal);\n+        assert_eq!(1e-37f32.classify(), FPNormal);\n+        assert_eq!(1e-38f32.classify(), FPSubnormal);\n+    }\n }"}, {"sha": "30c101fe8a9c6ed9de35c92f6c0267f9137b6742", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 115, "deletions": 17, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -12,6 +12,7 @@\n \n use libc::c_int;\n use num::{Zero, One, strconv};\n+use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n use prelude::*;\n \n pub use cmath::c_double_targ_consts::*;\n@@ -84,7 +85,7 @@ delegate!(\n     fn cosh(n: c_double) -> c_double = c_double_utils::cosh,\n     fn erf(n: c_double) -> c_double = c_double_utils::erf,\n     fn erfc(n: c_double) -> c_double = c_double_utils::erfc,\n-    fn expm1(n: c_double) -> c_double = c_double_utils::expm1,\n+    fn exp_m1(n: c_double) -> c_double = c_double_utils::exp_m1,\n     fn abs_sub(a: c_double, b: c_double) -> c_double = c_double_utils::abs_sub,\n     fn fmax(a: c_double, b: c_double) -> c_double = c_double_utils::fmax,\n     fn fmin(a: c_double, b: c_double) -> c_double = c_double_utils::fmin,\n@@ -94,7 +95,7 @@ delegate!(\n     fn ldexp(x: c_double, n: c_int) -> c_double = c_double_utils::ldexp,\n     fn lgamma(n: c_double, sign: &mut c_int) -> c_double = c_double_utils::lgamma,\n     fn log_radix(n: c_double) -> c_double = c_double_utils::log_radix,\n-    fn ln1p(n: c_double) -> c_double = c_double_utils::ln1p,\n+    fn ln_1p(n: c_double) -> c_double = c_double_utils::ln_1p,\n     fn ilog_radix(n: c_double) -> c_int = c_double_utils::ilog_radix,\n     fn modf(n: c_double, iptr: &mut c_double) -> c_double = c_double_utils::modf,\n     fn round(n: c_double) -> c_double = c_double_utils::round,\n@@ -218,11 +219,6 @@ pub mod consts {\n     pub static ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[inline(always)]\n-pub fn logarithm(n: f64, b: f64) -> f64 {\n-    return log2(n) / log2(b);\n-}\n-\n impl Num for f64 {}\n \n #[cfg(notest)]\n@@ -330,6 +326,13 @@ impl Signed for f64 {\n     #[inline(always)]\n     fn abs(&self) -> f64 { abs(*self) }\n \n+    ///\n+    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline(always)]\n+    fn abs_sub(&self, other: &f64) -> f64 { abs_sub(*self, *other) }\n+\n     ///\n     /// # Returns\n     ///\n@@ -426,21 +429,27 @@ impl Trigonometric for f64 {\n }\n \n impl Exponential for f64 {\n+    /// Returns the exponential of the number\n     #[inline(always)]\n     fn exp(&self) -> f64 { exp(*self) }\n \n+    /// Returns 2 raised to the power of the number\n     #[inline(always)]\n     fn exp2(&self) -> f64 { exp2(*self) }\n \n+    /// Returns the natural logarithm of the number\n     #[inline(always)]\n-    fn expm1(&self) -> f64 { expm1(*self) }\n+    fn ln(&self) -> f64 { ln(*self) }\n \n+    /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self) -> f64 { ln(*self) }\n+    fn log(&self, base: f64) -> f64 { self.ln() / base.ln() }\n \n+    /// Returns the base 2 logarithm of the number\n     #[inline(always)]\n     fn log2(&self) -> f64 { log2(*self) }\n \n+    /// Returns the base 10 logarithm of the number\n     #[inline(always)]\n     fn log10(&self) -> f64 { log10(*self) }\n }\n@@ -517,13 +526,13 @@ impl Real for f64 {\n     #[inline(always)]\n     fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n \n-    /// log(2.0)\n+    /// ln(2.0)\n     #[inline(always)]\n-    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n \n-    /// log(10.0)\n+    /// ln(10.0)\n     #[inline(always)]\n-    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n@@ -593,6 +602,7 @@ impl Float for f64 {\n     #[inline(always)]\n     fn neg_zero() -> f64 { -0.0 }\n \n+    /// Returns `true` if the number is NaN\n     #[inline(always)]\n     fn is_NaN(&self) -> bool { *self != *self }\n \n@@ -602,12 +612,39 @@ impl Float for f64 {\n         *self == Float::infinity() || *self == Float::neg_infinity()\n     }\n \n-    /// Returns `true` if the number is finite\n+    /// Returns `true` if the number is neither infinite or NaN\n     #[inline(always)]\n     fn is_finite(&self) -> bool {\n         !(self.is_NaN() || self.is_infinite())\n     }\n \n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool {\n+        match self.classify() {\n+            FPNormal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    fn classify(&self) -> FPCategory {\n+        static EXP_MASK: u64 = 0x7ff0000000000000;\n+        static MAN_MASK: u64 = 0x000fffffffffffff;\n+\n+        match (\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & EXP_MASK,\n+            unsafe { ::cast::transmute::<f64,u64>(*self) } & MAN_MASK\n+        ) {\n+            (EXP_MASK, 0)        => FPInfinite,\n+            (EXP_MASK, _)        => FPNaN,\n+            (exp, _) if exp != 0 => FPNormal,\n+            _ if self.is_zero()  => FPZero,\n+            _                    => FPSubnormal,\n+        }\n+    }\n+\n     #[inline(always)]\n     fn mantissa_digits() -> uint { 53 }\n \n@@ -629,6 +666,20 @@ impl Float for f64 {\n     #[inline(always)]\n     fn max_10_exp() -> int { 308 }\n \n+    ///\n+    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n+    /// even if the number is close to zero\n+    ///\n+    #[inline(always)]\n+    fn exp_m1(&self) -> f64 { exp_m1(*self) }\n+\n+    ///\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n+    /// than if the operations were performed separately\n+    ///\n+    #[inline(always)]\n+    fn ln_1p(&self) -> f64 { ln_1p(*self) }\n+\n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n     /// produces a more accurate result with better performance than a separate multiplication\n@@ -866,6 +917,7 @@ impl num::FromStrRadix for f64 {\n #[cfg(test)]\n mod tests {\n     use f64::*;\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -985,12 +1037,12 @@ mod tests {\n         assert_approx_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n         assert_approx_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n         assert_approx_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n-        assert_approx_eq!(Real::log_2::<f64>(), 2f64.log());\n-        assert_approx_eq!(Real::log_10::<f64>(), 10f64.log());\n+        assert_approx_eq!(Real::ln_2::<f64>(), 2f64.ln());\n+        assert_approx_eq!(Real::ln_10::<f64>(), 10f64.ln());\n     }\n \n     #[test]\n-    pub fn test_signed() {\n+    pub fn test_abs() {\n         assert_eq!(infinity.abs(), infinity);\n         assert_eq!(1f64.abs(), 1f64);\n         assert_eq!(0f64.abs(), 0f64);\n@@ -999,7 +1051,24 @@ mod tests {\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f64/neg_infinity).abs(), 0f64);\n         assert!(NaN.abs().is_NaN());\n+    }\n \n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f64).abs_sub(&1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(&1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(&0f64), 1f64);\n+        assert_eq!(1f64.abs_sub(&-1f64), 2f64);\n+        assert_eq!(neg_infinity.abs_sub(&0f64), 0f64);\n+        assert_eq!(infinity.abs_sub(&1f64), infinity);\n+        assert_eq!(0f64.abs_sub(&neg_infinity), infinity);\n+        assert_eq!(0f64.abs_sub(&infinity), 0f64);\n+        assert!(NaN.abs_sub(&-1f64).is_NaN());\n+        assert!(1f64.abs_sub(&NaN).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n         assert_eq!(infinity.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n         assert_eq!(0f64.signum(), 1f64);\n@@ -1008,7 +1077,10 @@ mod tests {\n         assert_eq!(neg_infinity.signum(), -1f64);\n         assert_eq!((1f64/neg_infinity).signum(), -1f64);\n         assert!(NaN.signum().is_NaN());\n+    }\n \n+    #[test]\n+    fn test_is_positive() {\n         assert!(infinity.is_positive());\n         assert!(1f64.is_positive());\n         assert!(0f64.is_positive());\n@@ -1017,7 +1089,10 @@ mod tests {\n         assert!(!neg_infinity.is_positive());\n         assert!(!(1f64/neg_infinity).is_positive());\n         assert!(!NaN.is_positive());\n+    }\n \n+    #[test]\n+    fn test_is_negative() {\n         assert!(!infinity.is_negative());\n         assert!(!1f64.is_negative());\n         assert!(!0f64.is_negative());\n@@ -1042,4 +1117,27 @@ mod tests {\n         assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);\n         assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n     }\n+\n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<f64>().is_normal());\n+        assert!(!Float::infinity::<f64>().is_normal());\n+        assert!(!Float::neg_infinity::<f64>().is_normal());\n+        assert!(!Zero::zero::<f64>().is_normal());\n+        assert!(!Float::neg_zero::<f64>().is_normal());\n+        assert!(1f64.is_normal());\n+        assert!(1e-307f64.is_normal());\n+        assert!(!1e-308f64.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<f64>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<f64>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<f64>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<f64>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<f64>().classify(), FPZero);\n+        assert_eq!(1e-307f64.classify(), FPNormal);\n+        assert_eq!(1e-308f64.classify(), FPSubnormal);\n+    }\n }"}, {"sha": "9c3d30be0d499718994379ad47c4ce60f1ed8ae3", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 111, "deletions": 26, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -22,14 +22,14 @@\n \n use libc::c_int;\n use num::{Zero, One, strconv};\n+use num::FPCategory;\n use prelude::*;\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n-pub use f64::logarithm;\n pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n-pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n+pub use f64::{erf, erfc, exp, exp_m1, exp2, abs_sub};\n pub use f64::{mul_add, fmax, fmin, next_after, frexp, hypot, ldexp};\n-pub use f64::{lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix};\n+pub use f64::{lgamma, ln, log_radix, ln_1p, log10, log2, ilog_radix};\n pub use f64::{modf, pow, powi, round, sinh, tanh, tgamma, trunc};\n pub use f64::{j0, j1, jn, y0, y1, yn};\n \n@@ -533,31 +533,37 @@ impl Trigonometric for float {\n }\n \n impl Exponential for float {\n+    /// Returns the exponential of the number\n     #[inline(always)]\n     fn exp(&self) -> float {\n         (*self as f64).exp() as float\n     }\n \n+    /// Returns 2 raised to the power of the number\n     #[inline(always)]\n     fn exp2(&self) -> float {\n         (*self as f64).exp2() as float\n     }\n \n+    /// Returns the natural logarithm of the number\n     #[inline(always)]\n-    fn expm1(&self) -> float {\n-        (*self as f64).expm1() as float\n+    fn ln(&self) -> float {\n+        (*self as f64).ln() as float\n     }\n \n+    /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline(always)]\n-    fn log(&self) -> float {\n-        (*self as f64).log() as float\n+    fn log(&self, base: float) -> float {\n+        (*self as f64).log(base as f64) as float\n     }\n \n+    /// Returns the base 2 logarithm of the number\n     #[inline(always)]\n     fn log2(&self) -> float {\n         (*self as f64).log2() as float\n     }\n \n+    /// Returns the base 10 logarithm of the number\n     #[inline(always)]\n     fn log10(&self) -> float {\n         (*self as f64).log10() as float\n@@ -642,13 +648,13 @@ impl Real for float {\n     #[inline(always)]\n     fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n \n-    /// log(2.0)\n+    /// ln(2.0)\n     #[inline(always)]\n-    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n+    fn ln_2() -> float { 0.693147180559945309417232121458176568 }\n \n-    /// log(10.0)\n+    /// ln(10.0)\n     #[inline(always)]\n-    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n+    fn ln_10() -> float { 2.30258509299404568401799145468436421 }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n@@ -729,6 +735,15 @@ impl Signed for float {\n     #[inline(always)]\n     fn abs(&self) -> float { abs(*self) }\n \n+    ///\n+    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline(always)]\n+    fn abs_sub(&self, other: &float) -> float {\n+        (*self as f64).abs_sub(&(*other as f64)) as float\n+    }\n+\n     ///\n     /// # Returns\n     ///\n@@ -768,19 +783,37 @@ impl Primitive for float {\n \n impl Float for float {\n     #[inline(always)]\n-    fn NaN() -> float { 0.0 / 0.0 }\n+    fn NaN() -> float { Float::NaN::<f64>() as float }\n \n     #[inline(always)]\n-    fn infinity() -> float { 1.0 / 0.0 }\n+    fn infinity() -> float { Float::infinity::<f64>() as float }\n \n     #[inline(always)]\n-    fn neg_infinity() -> float { -1.0 / 0.0 }\n+    fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n \n     #[inline(always)]\n-    fn neg_zero() -> float { -0.0 }\n+    fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n \n+    /// Returns `true` if the number is NaN\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { (*self as f64).is_NaN() }\n+\n+    /// Returns `true` if the number is infinite\n     #[inline(always)]\n-    fn is_NaN(&self) -> bool { *self != *self }\n+    fn is_infinite(&self) -> bool { (*self as f64).is_infinite() }\n+\n+    /// Returns `true` if the number is neither infinite or NaN\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool { (*self as f64).is_finite() }\n+\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    #[inline(always)]\n+    fn is_normal(&self) -> bool { (*self as f64).is_normal() }\n+\n+    /// Returns the floating point category of the number. If only one property is going to\n+    /// be tested, it is generally faster to use the specific predicate instead.\n+    #[inline(always)]\n+    fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n     #[inline(always)]\n     fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n@@ -803,17 +836,21 @@ impl Float for float {\n     #[inline(always)]\n     fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n \n-    /// Returns `true` if the number is infinite\n+    ///\n+    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n+    /// even if the number is close to zero\n+    ///\n     #[inline(always)]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n+    fn exp_m1(&self) -> float {\n+        (*self as f64).exp_m1() as float\n     }\n \n-    /// Returns `true` if the number is finite\n+    ///\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n+    /// than if the operations were performed separately\n+    ///\n     #[inline(always)]\n-    fn is_finite(&self) -> bool {\n-        !(self.is_NaN() || self.is_infinite())\n-    }\n+    fn ln_1p(&self) -> float { (*self as f64).ln_1p() as float }\n \n     ///\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n@@ -834,6 +871,7 @@ impl Float for float {\n \n #[cfg(test)]\n mod tests {\n+    use num::*;\n     use super::*;\n     use prelude::*;\n \n@@ -949,12 +987,12 @@ mod tests {\n         assert_approx_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n         assert_approx_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n         assert_approx_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n-        assert_approx_eq!(Real::log_2::<float>(), 2f.log());\n-        assert_approx_eq!(Real::log_10::<float>(), 10f.log());\n+        assert_approx_eq!(Real::ln_2::<float>(), 2f.ln());\n+        assert_approx_eq!(Real::ln_10::<float>(), 10f.ln());\n     }\n \n     #[test]\n-    fn test_signed() {\n+    fn test_abs() {\n         assert_eq!(infinity.abs(), infinity);\n         assert_eq!(1f.abs(), 1f);\n         assert_eq!(0f.abs(), 0f);\n@@ -963,7 +1001,24 @@ mod tests {\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f/neg_infinity).abs(), 0f);\n         assert!(NaN.abs().is_NaN());\n+    }\n \n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f).abs_sub(&1f), 0f);\n+        assert_eq!(1f.abs_sub(&1f), 0f);\n+        assert_eq!(1f.abs_sub(&0f), 1f);\n+        assert_eq!(1f.abs_sub(&-1f), 2f);\n+        assert_eq!(neg_infinity.abs_sub(&0f), 0f);\n+        assert_eq!(infinity.abs_sub(&1f), infinity);\n+        assert_eq!(0f.abs_sub(&neg_infinity), infinity);\n+        assert_eq!(0f.abs_sub(&infinity), 0f);\n+        assert!(NaN.abs_sub(&-1f).is_NaN());\n+        assert!(1f.abs_sub(&NaN).is_NaN());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n         assert_eq!(infinity.signum(), 1f);\n         assert_eq!(1f.signum(), 1f);\n         assert_eq!(0f.signum(), 1f);\n@@ -972,7 +1027,10 @@ mod tests {\n         assert_eq!(neg_infinity.signum(), -1f);\n         assert_eq!((1f/neg_infinity).signum(), -1f);\n         assert!(NaN.signum().is_NaN());\n+    }\n \n+    #[test]\n+    fn test_is_positive() {\n         assert!(infinity.is_positive());\n         assert!(1f.is_positive());\n         assert!(0f.is_positive());\n@@ -981,7 +1039,10 @@ mod tests {\n         assert!(!neg_infinity.is_positive());\n         assert!(!(1f/neg_infinity).is_positive());\n         assert!(!NaN.is_positive());\n+    }\n \n+    #[test]\n+    fn test_is_negative() {\n         assert!(!infinity.is_negative());\n         assert!(!1f.is_negative());\n         assert!(!0f.is_negative());\n@@ -1007,6 +1068,30 @@ mod tests {\n         assert_eq!(Primitive::bytes::<float>(), sys::size_of::<float>());\n     }\n \n+    #[test]\n+    fn test_is_normal() {\n+        assert!(!Float::NaN::<float>().is_normal());\n+        assert!(!Float::infinity::<float>().is_normal());\n+        assert!(!Float::neg_infinity::<float>().is_normal());\n+        assert!(!Zero::zero::<float>().is_normal());\n+        assert!(!Float::neg_zero::<float>().is_normal());\n+        assert!(1f.is_normal());\n+        assert!(1e-307f.is_normal());\n+        assert!(!1e-308f.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        assert_eq!(Float::NaN::<float>().classify(), FPNaN);\n+        assert_eq!(Float::infinity::<float>().classify(), FPInfinite);\n+        assert_eq!(Float::neg_infinity::<float>().classify(), FPInfinite);\n+        assert_eq!(Zero::zero::<float>().classify(), FPZero);\n+        assert_eq!(Float::neg_zero::<float>().classify(), FPZero);\n+        assert_eq!(1f.classify(), FPNormal);\n+        assert_eq!(1e-307f.classify(), FPNormal);\n+        assert_eq!(1e-308f.classify(), FPSubnormal);\n+    }\n+\n     #[test]\n     pub fn test_to_str_exact_do_decimal() {\n         let s = to_str_exact(5.0, 4u);"}, {"sha": "06a9a0b45627db56bdd067fc584866e1f65c238e", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -264,6 +264,15 @@ impl Signed for T {\n         if self.is_negative() { -*self } else { *self }\n     }\n \n+    ///\n+    /// The positive difference of two numbers. Returns `0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline(always)]\n+    fn abs_sub(&self, other: &T) -> T {\n+        if *self <= *other { 0 } else { *self - *other }\n+    }\n+\n     ///\n     /// # Returns\n     ///\n@@ -554,21 +563,38 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_signed() {\n+    pub fn test_abs() {\n         assert_eq!((1 as T).abs(), 1 as T);\n         assert_eq!((0 as T).abs(), 0 as T);\n         assert_eq!((-1 as T).abs(), 1 as T);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1 as T).abs_sub(&(1 as T)), 0 as T);\n+        assert_eq!((1 as T).abs_sub(&(1 as T)), 0 as T);\n+        assert_eq!((1 as T).abs_sub(&(0 as T)), 1 as T);\n+        assert_eq!((1 as T).abs_sub(&(-1 as T)), 2 as T);\n+    }\n \n+    #[test]\n+    fn test_signum() {\n         assert_eq!((1 as T).signum(), 1 as T);\n         assert_eq!((0 as T).signum(), 0 as T);\n         assert_eq!((-0 as T).signum(), 0 as T);\n         assert_eq!((-1 as T).signum(), -1 as T);\n+    }\n \n+    #[test]\n+    fn test_is_positive() {\n         assert!((1 as T).is_positive());\n         assert!(!(0 as T).is_positive());\n         assert!(!(-0 as T).is_positive());\n         assert!(!(-1 as T).is_positive());\n+    }\n \n+    #[test]\n+    fn test_is_negative() {\n         assert!(!(1 as T).is_negative());\n         assert!(!(0 as T).is_negative());\n         assert!(!(-0 as T).is_negative());"}, {"sha": "50ba55039d4089da4dd0623dbc3e30083327c86e", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -55,7 +55,9 @@ pub trait One {\n pub trait Signed: Num\n                 + Neg<Self> {\n     fn abs(&self) -> Self;\n+    fn abs_sub(&self, other: &Self) -> Self;\n     fn signum(&self) -> Self;\n+\n     fn is_positive(&self) -> bool;\n     fn is_negative(&self) -> bool;\n }\n@@ -121,8 +123,8 @@ pub trait Trigonometric {\n pub trait Exponential {\n     fn exp(&self) -> Self;\n     fn exp2(&self) -> Self;\n-    fn expm1(&self) -> Self;\n-    fn log(&self) -> Self;\n+    fn ln(&self) -> Self;\n+    fn log(&self, base: Self) -> Self;\n     fn log2(&self) -> Self;\n     fn log10(&self) -> Self;\n }\n@@ -158,8 +160,8 @@ pub trait Real: Signed\n     fn e() -> Self;\n     fn log2_e() -> Self;\n     fn log10_e() -> Self;\n-    fn log_2() -> Self;\n-    fn log_10() -> Self;\n+    fn ln_2() -> Self;\n+    fn ln_10() -> Self;\n \n     // Angular conversions\n     fn to_degrees(&self) -> Self;\n@@ -235,6 +237,23 @@ pub trait Int: Integer\n              + Bitwise\n              + BitCount {}\n \n+///\n+/// Used for representing the classification of floating point numbers\n+///\n+#[deriving(Eq)]\n+pub enum FPCategory {\n+    /// \"Not a Number\", often obtained by dividing by zero\n+    FPNaN,\n+    /// Positive or negative infinity\n+    FPInfinite ,\n+    /// Positive or negative zero\n+    FPZero,\n+    /// De-normalized floating point representation (less precise than `FPNormal`)\n+    FPSubnormal,\n+    /// A regular floating point number\n+    FPNormal,\n+}\n+\n ///\n /// Primitive floating point numbers\n ///\n@@ -251,6 +270,8 @@ pub trait Float: Real\n     fn is_NaN(&self) -> bool;\n     fn is_infinite(&self) -> bool;\n     fn is_finite(&self) -> bool;\n+    fn is_normal(&self) -> bool;\n+    fn classify(&self) -> FPCategory;\n \n     fn mantissa_digits() -> uint;\n     fn digits() -> uint;\n@@ -260,6 +281,8 @@ pub trait Float: Real\n     fn min_10_exp() -> int;\n     fn max_10_exp() -> int;\n \n+    fn exp_m1(&self) -> Self;\n+    fn ln_1p(&self) -> Self;\n     fn mul_add(&self, a: Self, b: Self) -> Self;\n     fn next_after(&self, other: Self) -> Self;\n }"}, {"sha": "a5cf929ed93a20cc2fd06f26dbadc1aaf2a1954e", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847552f48b51aec0fcc6b7fd2ee2a51f3700321a/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=847552f48b51aec0fcc6b7fd2ee2a51f3700321a", "patch": "@@ -831,6 +831,11 @@ impl Signed for BigInt {\n         }\n     }\n \n+    #[inline(always)]\n+    fn abs_sub(&self, other: &BigInt) -> BigInt {\n+        if *self <= *other { Zero::zero() } else { *self - *other }\n+    }\n+\n     #[inline(always)]\n     fn signum(&self) -> BigInt {\n         match self.sign {\n@@ -1920,6 +1925,15 @@ mod bigint_tests {\n         check(11, 5, 55);\n     }\n \n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-One::one::<BigInt>()).abs_sub(&One::one()), Zero::zero());\n+        assert_eq!(One::one::<BigInt>().abs_sub(&One::one()), Zero::zero());\n+        assert_eq!(One::one::<BigInt>().abs_sub(&Zero::zero()), One::one());\n+        assert_eq!(One::one::<BigInt>().abs_sub(&-One::one::<BigInt>()),\n+                   IntConvertible::from_int(2));\n+    }\n+\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {"}]}