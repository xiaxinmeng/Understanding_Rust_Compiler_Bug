{"sha": "73dac7e4e61aa88cfc98433b61ba131b38af978d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZGFjN2U0ZTYxYWE4OGNmYzk4NDMzYjYxYmExMzFiMzhhZjk3OGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-28T02:31:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-28T02:31:46Z"}, "message": "auto merge of #14387 : alan-andrade/rust/remove_managed_boxes_and_gc, r=brson\n\nMy main goals were:\r\n- be clear when we talk about \"references\" and \"pointers\"\r\n- remove Managed boxes completely and the concept of GC.\r\n\r\nhttps://github.com/mozilla/rust/issues/13987", "tree": {"sha": "3ec3b38b9e7929169b43469e8c1a60bcf9a502d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ec3b38b9e7929169b43469e8c1a60bcf9a502d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73dac7e4e61aa88cfc98433b61ba131b38af978d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73dac7e4e61aa88cfc98433b61ba131b38af978d", "html_url": "https://github.com/rust-lang/rust/commit/73dac7e4e61aa88cfc98433b61ba131b38af978d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73dac7e4e61aa88cfc98433b61ba131b38af978d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "url": "https://api.github.com/repos/rust-lang/rust/commits/911cc9c35234ab12a4b9a6fc1cb35b52556f242d", "html_url": "https://github.com/rust-lang/rust/commit/911cc9c35234ab12a4b9a6fc1cb35b52556f242d"}, {"sha": "0cae84959568859f946dffb1e9d9e1d43e05ae6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cae84959568859f946dffb1e9d9e1d43e05ae6b", "html_url": "https://github.com/rust-lang/rust/commit/0cae84959568859f946dffb1e9d9e1d43e05ae6b"}], "stats": {"total": 369, "additions": 98, "deletions": 271}, "files": [{"sha": "40070c4dd4bba792a3ab172f2f1c956a3ba580bd", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 77, "deletions": 168, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/73dac7e4e61aa88cfc98433b61ba131b38af978d/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/73dac7e4e61aa88cfc98433b61ba131b38af978d/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=73dac7e4e61aa88cfc98433b61ba131b38af978d", "patch": "@@ -3,60 +3,52 @@\n # Introduction\n \n References are one of the more flexible and powerful tools available in\n-Rust. A reference can point anywhere: into the managed or exchange\n-heap, into the stack, and even into the interior of another data structure. A\n-reference is as flexible as a C pointer or C++ reference. However,\n-unlike C and C++ compilers, the Rust compiler includes special static checks\n-that ensure that programs use references safely. Another advantage of\n-references is that they are invisible to the garbage collector, so\n-working with references helps reduce the overhead of automatic memory\n-management.\n+Rust. They can point anywhere: into the heap, stack, and even into the\n+interior of another data structure. A reference is as flexible as a C pointer\n+or C++ reference.\n+\n+Unlike C and C++ compilers, the Rust compiler includes special static\n+checks that ensure that programs use references safely.\n \n Despite their complete safety, a reference's representation at runtime\n is the same as that of an ordinary pointer in a C program. They introduce zero\n overhead. The compiler does all safety checks at compile time.\n \n-Although references have rather elaborate theoretical\n-underpinnings (region pointers), the core concepts will be familiar to\n-anyone who has worked with C or C++. Therefore, the best way to explain\n-how they are used\u2014and their limitations\u2014is probably just to work\n-through several examples.\n+Although references have rather elaborate theoretical underpinnings usually\n+introduced as (e.g. region pointers), the core concepts will be familiar to\n+anyone who has worked with C or C++. The best way to explain how they are\n+used\u2014and their limitations\u2014is probably just to work through several examples.\n \n # By example\n \n References, sometimes known as *borrowed pointers*, are only valid for\n a limited duration. References never claim any kind of ownership\n-over the data that they point to: instead, they are used for cases\n+over the data that they point to. Instead, they are used for cases\n where you would like to use data for a short time.\n \n-As an example, consider a simple struct type `Point`:\n+Consider a simple struct type `Point`:\n \n ~~~\n struct Point {x: f64, y: f64}\n ~~~\n \n We can use this simple definition to allocate points in many different ways. For\n-example, in this code, each of these three local variables contains a\n-point, but allocated in a different place:\n+example, in this code, each of these local variables contains a point,\n+but allocated in a different place:\n \n ~~~\n # struct Point {x: f64, y: f64}\n-let on_the_stack :  Point     =     Point {x: 3.0, y: 4.0};\n-let managed_box  : @Point     =    @Point {x: 5.0, y: 1.0};\n-let owned_box    : Box<Point> = box Point {x: 7.0, y: 9.0};\n+let on_the_stack : Point      =     Point {x: 3.0, y: 4.0};\n+let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance between any\n-two points, no matter where they were stored. For example, we might like to\n-compute the distance between `on_the_stack` and `managed_box`, or between\n-`managed_box` and `owned_box`. One option is to define a function that takes\n-two arguments of type `Point`\u2014that is, it takes the points by value. But if we\n-define it this way, calling the function will cause the points to be\n+two points, no matter where they were stored. One option is to define a function\n+that takes two arguments of type `Point`\u2014that is, it takes the points by value.\n+But if we define it this way, calling the function will cause the points to be\n copied. For points, this is probably not so bad, but often copies are\n-expensive. Worse, if the data type contains mutable fields, copying can change\n-the semantics of your program in unexpected ways. So we'd like to define a\n-function that takes the points by pointer. We can use references to do\n-this:\n+expensive. So we'd like to define a function that takes the points just as\n+a reference.\n \n ~~~\n # struct Point {x: f64, y: f64}\n@@ -68,16 +60,14 @@ fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n }\n ~~~\n \n-Now we can call `compute_distance()` in various ways:\n+Now we can call `compute_distance()`:\n \n ~~~\n # struct Point {x: f64, y: f64}\n # let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n-# let managed_box  :    @Point  =    @Point{x: 5.0, y: 1.0};\n-# let owned_box    : Box<Point> = box Point{x: 7.0, y: 9.0};\n+# let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, managed_box);\n-compute_distance(managed_box, owned_box);\n+compute_distance(&on_the_stack, &*on_the_heap);\n ~~~\n \n Here, the `&` operator takes the address of the variable\n@@ -87,11 +77,9 @@ value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we have created an alias: that is, another\n name for the same data.\n \n-In contrast, we can pass the boxes `managed_box` and `owned_box` to\n-`compute_distance` directly. The compiler automatically converts a box like\n-`@Point` or `~Point` to a reference like `&Point`. This is another form\n-of borrowing: in this case, the caller lends the contents of the managed or\n-owned box to the callee.\n+For the second argument, we need to extract the contents of `on_the_heap`\n+by derefercing with the `*` symbol. Now that we have the data, we need\n+to create a reference with the `&` symbol.\n \n Whenever a caller lends data to a callee, there are some limitations on what\n the caller can do with the original. For example, if the contents of a\n@@ -134,10 +122,10 @@ let on_the_stack2 : &Point = &tmp;\n \n # Taking the address of fields\n \n-As in C, the `&` operator is not limited to taking the address of\n+The `&` operator is not limited to taking the address of\n local variables. It can also take the address of fields or\n individual array elements. For example, consider this type definition\n-for `rectangle`:\n+for `Rectangle`:\n \n ~~~\n struct Point {x: f64, y: f64} // as before\n@@ -153,9 +141,7 @@ Now, as before, we can define rectangles in a few different ways:\n # struct Rectangle {origin: Point, size: Size}\n let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n                                   size: Size {w: 3.0, h: 4.0}};\n-let rect_managed =    @Rectangle {origin: Point {x: 3.0, y: 4.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-let rect_owned   = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n+let rect_heap    = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n                                   size: Size {w: 3.0, h: 4.0}};\n ~~~\n \n@@ -167,109 +153,29 @@ operator. For example, I could write:\n # struct Size {w: f64, h: f64} // as before\n # struct Rectangle {origin: Point, size: Size}\n # let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_owned = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n+# let rect_heap   = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&rect_stack.origin, &rect_managed.origin);\n+compute_distance(&rect_stack.origin, &rect_heap.origin);\n ~~~\n \n which would borrow the field `origin` from the rectangle on the stack\n-as well as from the managed box, and then compute the distance between them.\n+as well as from the owned box, and then compute the distance between them.\n \n-# Borrowing managed boxes and rooting\n+# Lifetimes\n \n-We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n-and owned. Up till this point, we\u2019ve glossed over issues of\n-safety. As stated in the introduction, at runtime a reference\n-is simply a pointer, nothing more. Therefore, avoiding C's problems\n-with dangling pointers requires a compile-time safety check.\n+We\u2019ve seen a few examples of borrowing data. To this point, we\u2019ve glossed\n+over issues of safety. As stated in the introduction, at runtime a reference\n+is simply a pointer, nothing more. Therefore, avoiding C's problems with\n+dangling pointers requires a compile-time safety check.\n \n The basis for the check is the notion of _lifetimes_. A lifetime is a\n static approximation of the span of execution during which the pointer\n is valid: it always corresponds to some expression or block within the\n-program. Code inside that expression can use the pointer without\n-restrictions. But if the pointer escapes from that expression (for\n-example, if the expression contains an assignment expression that\n-assigns the pointer to a mutable field of a data structure with a\n-broader scope than the pointer itself), the compiler reports an\n-error. We'll be discussing lifetimes more in the examples to come, and\n-a more thorough introduction is also available.\n-\n-When the `&` operator creates a reference, the compiler must\n-ensure that the pointer remains valid for its entire\n-lifetime. Sometimes this is relatively easy, such as when taking the\n-address of a local variable or a field that is stored on the stack:\n-\n-~~~\n-struct X { f: int }\n-fn example1() {\n-    let mut x = X { f: 3 };\n-    let y = &mut x.f;  // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-Here, the lifetime of the reference `y` is simply L, the\n-remainder of the function body. The compiler need not do any other\n-work to prove that code will not free `x.f`. This is true even if the\n-code mutates `x`.\n-\n-The situation gets more complex when borrowing data inside heap boxes:\n-\n-~~~\n-# struct X { f: int }\n-fn example2() {\n-    let mut x = @X { f: 3 };\n-    let y = &x.f;      // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-In this example, the value `x` is a heap box, and `y` is therefore a\n-pointer into that heap box. Again the lifetime of `y` is L, the\n-remainder of the function body. But there is a crucial difference:\n-suppose `x` were to be reassigned during the lifetime L? If the\n-compiler isn't careful, the managed box could become *unrooted*, and\n-would therefore be subject to garbage collection. A heap box that is\n-unrooted is one such that no pointer values in the heap point to\n-it. It would violate memory safety for the box that was originally\n-assigned to `x` to be garbage-collected, since a non-heap\n-pointer *`y`* still points into it.\n-\n-> *Note:* Our current implementation implements the garbage collector\n-> using reference counting and cycle detection.\n-\n-For this reason, whenever an `&` expression borrows the interior of a\n-managed box stored in a mutable location, the compiler inserts a\n-temporary that ensures that the managed box remains live for the\n-entire lifetime. So, the above example would be compiled as if it were\n-written\n-\n-~~~\n-# struct X { f: int }\n-fn example2() {\n-    let mut x = @X {f: 3};\n-    let x1 = x;\n-    let y = &x1.f;     // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-Now if `x` is reassigned, the pointer `y` will still remain valid. This\n-process is called *rooting*.\n-\n-# Borrowing owned boxes\n-\n-The previous example demonstrated *rooting*, the process by which the\n-compiler ensures that managed boxes remain live for the duration of a\n-borrow. Unfortunately, rooting does not work for borrows of owned\n-boxes, because it is not possible to have two references to an owned\n-box.\n-\n-For owned boxes, therefore, the compiler will only allow a borrow *if\n-the compiler can guarantee that the owned box will not be reassigned\n-or moved for the lifetime of the pointer*. This does not necessarily\n-mean that the owned box is stored in immutable memory. For example,\n+program.\n+\n+The compiler will only allow a borrow *if it can guarantee that the data will\n+not be reassigned or moved for the lifetime of the pointer*. This does not\n+necessarily mean that the data is stored in immutable memory. For example,\n the following function is legal:\n \n ~~~\n@@ -287,14 +193,14 @@ fn example3() -> int {\n }\n ~~~\n \n-Here, as before, the interior of the variable `x` is being borrowed\n+Here, the interior of the variable `x` is being borrowed\n and `x` is declared as mutable. However, the compiler can prove that\n `x` is not assigned anywhere in the lifetime L of the variable\n `y`. Therefore, it accepts the function, even though `x` is mutable\n and in fact is mutated later in the function.\n \n It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any owned box\n+variable. The reason is that the runtime system frees any box\n _as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n@@ -337,31 +243,34 @@ Once the reassignment occurs, the memory will look like this:\n                              +---------+\n ~~~\n \n-Here you can see that the variable `y` still points at the old box,\n-which has been freed.\n+Here you can see that the variable `y` still points at the old `f`\n+property of Foo, which has been freed.\n \n In fact, the compiler can apply the same kind of reasoning to any\n-memory that is _(uniquely) owned by the stack frame_. So we could\n+memory that is (uniquely) owned by the stack frame. So we could\n modify the previous example to introduce additional owned pointers\n and structs, and the compiler will still be able to detect possible\n-mutations:\n+mutations. This time, we'll use an analogy to illustrate the concept.\n \n ~~~ {.ignore}\n fn example3() -> int {\n-    struct R { g: int }\n-    struct S { f: Box<R> }\n+    struct House { owner: Box<Person> }\n+    struct Person { age: int }\n \n-    let mut x = box S {f: box R {g: 3}};\n-    let y = &x.f.g;\n-    x = box S {f: box R {g: 4}};  // Error reported here.\n-    x.f = box R {g: 5};           // Error reported here.\n-    *y\n+    let mut house = box House {\n+        owner: box Person {age: 30}\n+    };\n+\n+    let owner_age = &house.owner.age;\n+    house = box House {owner: box Person {age: 40}};  // Error reported here.\n+    house.owner = box Person {age: 50};               // Error reported here.\n+    *owner_age\n }\n ~~~\n \n-In this case, two errors are reported, one when the variable `x` is\n-modified and another when `x.f` is modified. Either modification would\n-invalidate the pointer `y`.\n+In this case, two errors are reported, one when the variable `house` is\n+modified and another when `house.owner` is modified. Either modification would\n+invalidate the pointer `owner_age`.\n \n # Borrowing and enums\n \n@@ -371,8 +280,8 @@ prevents pointers from pointing into freed memory. There is one other\n case where the compiler must be very careful to ensure that pointers\n remain valid: pointers into the interior of an `enum`.\n \n-As an example, let\u2019s look at the following `shape` type that can\n-represent both rectangles and circles:\n+Let\u2019s look at the following `shape` type that can represent both rectangles\n+and circles:\n \n ~~~\n struct Point {x: f64, y: f64}; // as before\n@@ -481,7 +390,7 @@ reference, then uses it within the same scope. It is also\n possible to return references as the result of a function, but\n as we'll see, doing so requires some explicit annotation.\n \n-For example, we could write a subroutine like this:\n+We could write a subroutine like this:\n \n ~~~\n struct Point {x: f64, y: f64}\n@@ -502,11 +411,10 @@ pointer result will always have the same lifetime as one of the\n parameters; named lifetimes indicate which parameter that\n is.\n \n-In the previous examples, function parameter types did not include a\n-lifetime name. In those examples, the compiler simply creates a fresh\n-name for the lifetime automatically: that is, the lifetime name is\n-guaranteed to refer to a distinct lifetime from the lifetimes of all\n-other parameters.\n+In the previous code samples, function parameter types did not include a\n+lifetime name. The compiler simply creates a fresh name for the lifetime\n+automatically: that is, the lifetime name is guaranteed to refer to a distinct\n+lifetime from the lifetimes of all other parameters.\n \n Named lifetimes that appear in function signatures are conceptually\n the same as the other lifetimes we have seen before, but they are a bit\n@@ -526,12 +434,12 @@ time one that does not compile:\n \n ~~~ {.ignore}\n struct Point {x: f64, y: f64}\n-fn get_x_sh(p: @Point) -> &f64 {\n+fn get_x_sh(p: &Point) -> &f64 {\n     &p.x // Error reported here\n }\n ~~~\n \n-Here, the function `get_x_sh()` takes a managed box as input and\n+Here, the function `get_x_sh()` takes a reference as input and\n returns a reference. As before, the lifetime of the reference\n that will be returned is a parameter (specified by the\n caller). That means that `get_x_sh()` promises to return a reference\n@@ -540,17 +448,18 @@ subtly different from the first example, which promised to return a\n pointer that was valid for as long as its pointer argument was valid.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a managed box. The presence of this expression\n-implies that the compiler must guarantee that, so long as the\n-resulting pointer is valid, the managed box will not be reclaimed by\n-the garbage collector. But recall that `get_x_sh()` also promised to\n+address of a field of a Point. The presence of this expression\n+implies that the compiler must guarantee that , so long as the\n+resulting pointer is valid, the original Point won't be moved or changed.\n+\n+But recall that `get_x_sh()` also promised to\n return a pointer that was valid for as long as the caller wanted it to\n be. Clearly, `get_x_sh()` is not in a position to make both of these\n guarantees; in fact, it cannot guarantee that the pointer will remain\n valid at all once it returns, as the parameter `p` may or may not be\n live in the caller. Therefore, the compiler will report an error here.\n \n-In general, if you borrow a managed (or owned) box to create a\n+In general, if you borrow a struct or box to create a\n reference, it will only be valid within the function\n and cannot be returned. This is why the typical way to return references\n is to take references as input (the only other case in"}, {"sha": "248142851b70915c043150cfe9f24efa7a1f2967", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 21, "deletions": 103, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/73dac7e4e61aa88cfc98433b61ba131b38af978d/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/73dac7e4e61aa88cfc98433b61ba131b38af978d/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=73dac7e4e61aa88cfc98433b61ba131b38af978d", "patch": "@@ -5,7 +5,7 @@ are also one of the more confusing topics for newcomers to Rust. They can also\n be confusing for people coming from other languages that support pointers, such\n as C++. This guide will help you understand this important topic.\n \n-# You don't actually need pointers\n+# You don't actually need pointers, use references\n \n I have good news for you: you probably don't need to care about pointers,\n especially as you're getting started. Think of it this way: Rust is a language\n@@ -75,20 +75,22 @@ pointer that satisfies that use-case:\n \n 1. Owned: `Box<Trait>` must be a pointer, because you don't know the size of the\n object, so indirection is mandatory.\n+\n 2. Owned: You need a recursive data structure. These can be infinite sized, so\n indirection is mandatory.\n+\n 3. Owned: A very, very, very rare situation in which you have a *huge* chunk of\n data that you wish to pass to many methods. Passing a pointer will make this\n more efficient. If you're coming from another language where this technique is\n common, such as C++, please read \"A note...\" below.\n-4. Managed: Having only a single owner to a piece of data would be inconvenient\n-or impossible. This is only often useful when a program is very large or very\n-complicated. Using a managed pointer will activate Rust's garbage collection\n-mechanism.\n-5. Reference: You're writing a function, and you need a pointer, but you don't\n+\n+4. Reference: You're writing a function, and you need a pointer, but you don't\n care about its ownership. If you make the argument a reference, callers\n can send in whatever kind they want.\n \n+5. Shared: You need to share data among tasks. You can achieve that via the\n+`Rc` and `Arc` types.\n+\n Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n of pointers in Rust: use them for a deliberate purpose, not just to make the\n compiler happy.\n@@ -165,6 +167,7 @@ approximation of owned pointers follows:\n \n 1. Only one owned pointer may exist to a particular place in memory. It may be\n borrowed from that owner, however.\n+\n 2. The Rust compiler uses static analysis to determine where the pointer is in\n scope, and handles allocating and de-allocating that memory. Owned pointers are\n not garbage collected.\n@@ -248,81 +251,6 @@ fn main() {\n Now it'll be copying a pointer-sized chunk of memory rather than the whole\n struct.\n \n-# Managed Pointers\n-\n-> **Note**: the `@` form of managed pointers is deprecated and behind a\n-> feature gate (it requires a `#![feature(managed_pointers)]` attribute on\n-> the crate root). There are replacements, currently\n-> there is `std::rc::Rc` and `std::gc::Gc` for shared ownership via reference\n-> counting and garbage collection respectively.\n-\n-Managed pointers, notated by an `@`, are used when having a single owner for\n-some data isn't convenient or possible. This generally happens when your\n-program is very large and complicated.\n-\n-For example, let's say you're using an owned pointer, and you want to do this:\n-\n-~~~rust{.ignore}\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n-\n-fn main() {\n-    let a = box Point { x: 10, y: 20 };\n-    let b = a;\n-    println!(\"{}\", b.x);\n-    println!(\"{}\", a.x);\n-}\n-~~~\n-\n-You'll get this error:\n-\n-~~~ {.notrust}\n-test.rs:10:20: 10:21 error: use of moved value: `a`\n-test.rs:10     println!(\"{}\", a.x);\n-                              ^\n-note: in expansion of format_args!\n-<std-macros>:158:27: 158:81 note: expansion site\n-<std-macros>:157:5: 159:6 note: in expansion of println!\n-test.rs:10:5: 10:25 note: expansion site\n-test.rs:8:9: 8:10 note: `a` moved here because it has type `Box<Point>`, which is moved by default (use `ref` to override)\n-test.rs:8     let b = a;\n-                  ^\n-~~~\n-\n-As the message says, owned pointers only allow for one owner at a time. When you assign `a` to `b`, `a` becomes invalid. Change your code to this, however:\n-\n-~~~rust\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n-\n-fn main() {\n-    let a = @Point { x: 10, y: 20 };\n-    let b = a;\n-    println!(\"{}\", b.x);\n-    println!(\"{}\", a.x);\n-}\n-~~~\n-\n-And it works:\n-\n-~~~ {.notrust}\n-10\n-10\n-~~~\n-\n-So why not just use managed pointers everywhere? There are two big drawbacks to\n-managed pointers:\n-\n-1. They activate Rust's garbage collector. Other pointer types don't share this\n-drawback.\n-2. You cannot pass this data to another task. Shared ownership across\n-concurrency boundaries is the source of endless pain in other languages, so\n-Rust does not let you do this.\n-\n # References\n \n References are the third major kind of pointer Rust supports. They are\n@@ -346,16 +274,17 @@ fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n }\n \n fn main() {\n-    let origin =    @Point { x: 0.0, y: 0.0 };\n+    let origin =    &Point { x: 0.0, y: 0.0 };\n     let p1     = box Point { x: 5.0, y: 3.0 };\n \n     println!(\"{:?}\", compute_distance(origin, p1));\n }\n ~~~\n \n This prints `5.83095189`. You can see that the `compute_distance` function\n-takes in two references, but we give it a managed and unique pointer. Of\n-course, if this were a real program, we wouldn't have any of these pointers,\n+takes in two references, a reference to a value on the stack, and a reference\n+to a value in a box.\n+Of course, if this were a real program, we wouldn't have any of these pointers,\n they're just there to demonstrate the concepts.\n \n So how is this hard? Well, because we're ignoring ownership, the compiler needs\n@@ -364,9 +293,11 @@ safety, a reference's representation at runtime is the same as that of\n an ordinary pointer in a C program. They introduce zero overhead. The compiler\n does all safety checks at compile time.\n \n-This theory is called 'region pointers,' and involve a concept called\n-'lifetimes'. Here's the simple explanation: would you expect this code to\n-compile?\n+This theory is called 'region pointers' and you can read more about it\n+[here](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n+Region pointers evolved into what we know today as 'lifetimes'.\n+\n+Here's the simple explanation: would you expect this code to compile?\n \n ~~~rust{.ignore}\n fn main() {\n@@ -461,32 +392,19 @@ fn main() {\n }\n ~~~\n \n-This gives you flexibility, without sacrificing performance. For example, this will\n-also work:\n-\n-~~~rust\n-fn foo(x: Box<int>) -> int {\n-    return *x;\n-}\n-\n-fn main() {\n-    let x = box 5;\n-    let y = @foo(x);\n-}\n-~~~\n+This gives you flexibility, without sacrificing performance.\n \n You may think that this gives us terrible performance: return a value and then\n-immediately box it up?!?! Isn't that the worst of both worlds? Rust is smarter\n+immediately box it up ?! Isn't that the worst of both worlds? Rust is smarter\n than that. There is no copy in this code. `main` allocates enough room for the\n-`@int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n+`box int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n the value straight into that pointer. This writes the return value directly into\n the allocated box.\n \n This is important enough that it bears repeating: pointers are not for optimizing\n returning values from your code. Allow the caller to choose how they want to\n use your output.\n \n-\n # Related Resources\n \n * [Lifetimes guide](guide-lifetimes.html)"}]}