{"sha": "b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjhlYzM2ZmI2ZDFiNmVmNWI0MWQ4MzY2Mjg3ZTBiMzhiNGRhMmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T18:56:45Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T18:56:45Z"}, "message": "rustc: Factor the type parameter and type lookup out of instantiate_path(), as patterns need different logic", "tree": {"sha": "ffb0d16ddd9e8a7b24f55a08dbef34fd6a8dadb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffb0d16ddd9e8a7b24f55a08dbef34fd6a8dadb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e", "html_url": "https://github.com/rust-lang/rust/commit/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c200f3e14ff618431ea12c52031da43ee651984", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c200f3e14ff618431ea12c52031da43ee651984", "html_url": "https://github.com/rust-lang/rust/commit/3c200f3e14ff618431ea12c52031da43ee651984"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "0fc99204f8b9cd6b384cc2a4e45b4ec1afc00a06", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b828ec36fb6d1b6ef5b41d8366287e0b38b4da2e", "patch": "@@ -128,74 +128,77 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     ret ty.fold_ty(substituter, typ);\n }\n \n-// Instantiates the given path, which must refer to an item with the given\n-// definition.\n-fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ast.def defn, &span sp)\n-        -> ast.ann {\n-    auto t;\n-    auto ty_params;\n+type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n+\n+// Returns the type parameters and the type for the given definition.\n+fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n+        -> ty_params_opt_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n             check (fcx.locals.contains_key(id));\n-            t = fcx.locals.get(id);\n-            ty_params = none[vec[ast.def_id]];\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_local(?id)) {\n+            auto t;\n             alt (fcx.locals.find(id)) {\n                 case (some[@ty.t](?t1)) { t = t1; }\n                 case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n             }\n-            ty_params = none[vec[ast.def_id]];\n+            ret tup(none[vec[ast.def_id]], t);\n         }\n         case (ast.def_obj_field(?id)) {\n             check (fcx.locals.contains_key(id));\n-            t = fcx.locals.get(id);\n-            ty_params = none[vec[ast.def_id]];\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n             check (fcx.ccx.item_types.contains_key(id));\n-            t = fcx.ccx.item_types.get(id);\n-            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_native_fn(?id)) {\n             check (fcx.ccx.item_types.contains_key(id));\n-            t = fcx.ccx.item_types.get(id);\n-            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_const(?id)) {\n             check (fcx.ccx.item_types.contains_key(id));\n-            t = fcx.ccx.item_types.get(id);\n-            ty_params = none[vec[ast.def_id]];\n+            ret tup(none[vec[ast.def_id]], fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_variant(?tag_id, ?variant_id)) {\n             check (fcx.ccx.item_types.contains_key(variant_id));\n-            t = fcx.ccx.item_types.get(variant_id);\n-            ty_params = some(fcx.ccx.item_ty_params.get(tag_id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(tag_id)),\n+                    fcx.ccx.item_types.get(variant_id));\n         }\n         case (ast.def_binding(?id)) {\n             check (fcx.locals.contains_key(id));\n-            t = fcx.locals.get(id);\n-            ty_params = none[vec[ast.def_id]];\n+            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n             check (fcx.ccx.item_types.contains_key(id));\n-            t = fcx.ccx.item_types.get(id);\n-            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+            ret tup(some(fcx.ccx.item_ty_params.get(id)),\n+                    fcx.ccx.item_types.get(id));\n         }\n \n         case (ast.def_mod(_)) {\n             // Hopefully part of a path.\n-            t = plain_ty(ty.ty_nil);    // TODO: something more poisonous?\n-            ty_params = none[vec[ast.def_id]];\n+            // TODO: return a type that's more poisonous, perhaps?\n+            ret tup(none[vec[ast.def_id]], plain_ty(ty.ty_nil));\n         }\n \n         case (_) {\n             // FIXME: handle other names.\n-            fcx.ccx.sess.unimpl(\"definition variant for: \"\n-                                + _str.connect(pth.node.idents, \".\"));\n+            fcx.ccx.sess.unimpl(\"definition variant\");\n             fail;\n         }\n     }\n+}\n+\n+// Instantiates the given path, which must refer to an item with the given\n+// type parameters and type.\n+fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n+        &span sp) -> ast.ann {\n+    auto ty_params = tpt._0;\n+    auto t = tpt._1;\n \n     auto ty_substs_opt;\n     auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n@@ -1669,7 +1672,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n-            auto ann = instantiate_path(fcx, pth, defn, expr.span);\n+            auto tpt = ty_params_and_ty_for_def(fcx, defn);\n+            auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_path(pth, defopt, ann));\n         }"}]}