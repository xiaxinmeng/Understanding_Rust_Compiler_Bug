{"sha": "e37b6c58378355347898cbdf1eef278137f6b461", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzN2I2YzU4Mzc4MzU1MzQ3ODk4Y2JkZjFlZWYyNzgxMzdmNmI0NjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-26T18:12:41Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-08-26T19:44:50Z"}, "message": "Make infer_block not unify; add back calculate_least_upper_bound", "tree": {"sha": "f6390e1488d486133addff8f51b9b2ecd4b042af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6390e1488d486133addff8f51b9b2ecd4b042af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e37b6c58378355347898cbdf1eef278137f6b461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e37b6c58378355347898cbdf1eef278137f6b461", "html_url": "https://github.com/rust-lang/rust/commit/e37b6c58378355347898cbdf1eef278137f6b461", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e37b6c58378355347898cbdf1eef278137f6b461/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44386d5373114ffc88ef6bd182fb3b58a7c27e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/44386d5373114ffc88ef6bd182fb3b58a7c27e69", "html_url": "https://github.com/rust-lang/rust/commit/44386d5373114ffc88ef6bd182fb3b58a7c27e69"}], "stats": {"total": 96, "additions": 66, "deletions": 30}, "files": [{"sha": "0aa99306737d64e937654d0f55dc3991f36c4aa9", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e37b6c58378355347898cbdf1eef278137f6b461/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37b6c58378355347898cbdf1eef278137f6b461/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=e37b6c58378355347898cbdf1eef278137f6b461", "patch": "@@ -975,48 +975,44 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ret_ty\n     }\n \n-    fn coerce(&mut self, tgt_expr: ExprId, ty1: Ty, ty2: Ty) -> Ty {\n-        if is_never(&ty1) {\n-            ty2\n+    /// This is similar to unify, but it makes the first type coerce to the\n+    /// second one.\n+    fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        if is_never(from_ty) {\n+            // ! coerces to any type\n+            true\n         } else {\n-            self.unify(&ty1, &ty2);\n-            // TODO Fugly and looks like we need more, `infer_adt_pattern` and other fails\n-            let ty = self.resolve_ty_as_possible(&mut vec![], ty1);\n-            self.write_expr_ty(tgt_expr, ty.clone());\n-            ty\n+            self.unify(from_ty, to_ty)\n         }\n     }\n \n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n         let could_unify = self.unify(&ty, &expected.ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_expr_ty(tgt_expr, ty.clone());\n         if !could_unify {\n             self.result.type_mismatches.insert(\n                 tgt_expr,\n                 TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n             );\n         }\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         ty\n     }\n \n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        match &body[tgt_expr] {\n+        let ty = match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n-                self.coerce(*then_branch, then_ty.clone(), expected.ty.clone());\n+                self.coerce(&then_ty, &expected.ty);\n                 match else_branch {\n                     Some(else_branch) => {\n                         let else_ty = self.infer_expr_inner(*else_branch, &expected);\n-                        self.coerce(*else_branch, else_ty, expected.ty.clone());\n+                        self.coerce(&else_ty, &expected.ty);\n                     }\n                     None => {\n                         // no else branch -> unit\n@@ -1111,6 +1107,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     expected.clone()\n                 };\n \n+                let mut arm_tys = Vec::with_capacity(arms.len());\n+\n                 for arm in arms {\n                     for &pat in &arm.pats {\n                         let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n@@ -1121,11 +1119,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    let match_arm_ty = self.infer_expr_inner(arm.expr, &expected);\n-                    self.coerce(arm.expr, match_arm_ty, expected.ty.clone());\n+                    arm_tys.push(self.infer_expr_inner(arm.expr, &expected));\n                 }\n \n-                expected.ty\n+                let lub_ty = calculate_least_upper_bound(expected.ty.clone(), &arm_tys);\n+\n+                for arm_ty in &arm_tys {\n+                    self.coerce(arm_ty, &lub_ty);\n+                }\n+\n+                lub_ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1385,7 +1388,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n                 Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n             },\n-        }\n+        };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_expr_ty(tgt_expr, ty.clone());\n+        ty\n     }\n \n     fn infer_block(\n@@ -1414,7 +1422,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n         }\n-        let ty = if let Some(expr) = tail { self.infer_expr(expr, expected) } else { Ty::unit() };\n+        let ty = if let Some(expr) = tail { self.infer_expr_inner(expr, expected) } else { Ty::unit() };\n         ty\n     }\n \n@@ -1644,3 +1652,29 @@ fn is_never(ty: &Ty) -> bool {\n         false\n     }\n }\n+\n+fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: &[Ty]) -> Ty {\n+    let mut all_never = true;\n+    let mut last_never_ty = None;\n+    let mut least_upper_bound = expected_ty;\n+\n+    for actual_ty in actual_tys {\n+        if is_never(actual_ty) {\n+            last_never_ty = Some(actual_ty.clone());\n+        } else {\n+            all_never = false;\n+            least_upper_bound = match (actual_ty, &least_upper_bound) {\n+                (_, Ty::Unknown)\n+                    | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n+                    | (Ty::Apply(_), _) => actual_ty.clone(),\n+                _ => least_upper_bound,\n+            }\n+        }\n+    }\n+\n+    if all_never && last_never_ty.is_some() {\n+        last_never_ty.unwrap()\n+    } else {\n+        least_upper_bound\n+    }\n+}"}, {"sha": "7fc9fbb63ed80c808be8f66b5b9747491532342f", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e37b6c58378355347898cbdf1eef278137f6b461/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37b6c58378355347898cbdf1eef278137f6b461/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=e37b6c58378355347898cbdf1eef278137f6b461", "patch": "@@ -718,16 +718,18 @@ fn main(foo: Foo) {\n }\n \"#),\n         @r###\"\n-[35; 38) 'foo': Foo\n-[45; 109) '{     ...   } }': ()\n-[51; 107) 'if tru...     }': ()\n-[54; 58) 'true': bool\n-[59; 67) '{      }': ()\n-[73; 107) 'if fal...     }': i32\n-[76; 81) 'false': bool\n-[82; 107) '{     ...     }': i32\n-[92; 95) 'foo': Foo\n-[92; 101) 'foo.field': i32\"###\n+   \u22ee\n+   \u22ee[35; 38) 'foo': Foo\n+   \u22ee[45; 109) '{     ...   } }': ()\n+   \u22ee[51; 107) 'if tru...     }': ()\n+   \u22ee[54; 58) 'true': bool\n+   \u22ee[59; 67) '{      }': ()\n+   \u22ee[73; 107) 'if fal...     }': ()\n+   \u22ee[76; 81) 'false': bool\n+   \u22ee[82; 107) '{     ...     }': i32\n+   \u22ee[92; 95) 'foo': Foo\n+   \u22ee[92; 101) 'foo.field': i32\n+    \"###\n     )\n }\n "}]}