{"sha": "065e121fc2675631e27b761d2ad5df3ee0c95976", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NWUxMjFmYzI2NzU2MzFlMjdiNzYxZDJhZDVkZjNlZTBjOTU5NzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-13T04:51:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-13T20:54:01Z"}, "message": "Relax an assertion in start_selection()\n\nIt asserted that the previous count was always nonnegative, but DISCONNECTED is\na valid value for it to see. In order to continue to remember to store\nDISCONNECTED after DISCONNECTED was seen, I also added a helper method.\n\nCloses #12226", "tree": {"sha": "6f4f6630e669dd08ed7ac6bbf5f9d4f5078b189f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f4f6630e669dd08ed7ac6bbf5f9d4f5078b189f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/065e121fc2675631e27b761d2ad5df3ee0c95976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/065e121fc2675631e27b761d2ad5df3ee0c95976", "html_url": "https://github.com/rust-lang/rust/commit/065e121fc2675631e27b761d2ad5df3ee0c95976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/065e121fc2675631e27b761d2ad5df3ee0c95976/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "411a01feb302dd64b669658562f2052decc80f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/411a01feb302dd64b669658562f2052decc80f19", "html_url": "https://github.com/rust-lang/rust/commit/411a01feb302dd64b669658562f2052decc80f19"}], "stats": {"total": 132, "additions": 122, "deletions": 10}, "files": [{"sha": "3efd72be7b1c5f1145296ed2f4d29970d5b2e2d4", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=065e121fc2675631e27b761d2ad5df3ee0c95976", "patch": "@@ -151,6 +151,11 @@ impl Select {\n     /// event could either be that data is available or the corresponding\n     /// channel has been closed.\n     pub fn wait(&self) -> uint {\n+        self.wait2(false)\n+    }\n+\n+    /// Helper method for skipping the preflight checks during testing\n+    fn wait2(&self, do_preflight_checks: bool) -> uint {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all ports in the set ahead of time, so\n         // this method shouldn't really have to iterate over all of them yet\n@@ -175,7 +180,7 @@ impl Select {\n             let mut amt = 0;\n             for p in self.iter() {\n                 amt += 1;\n-                if (*p).packet.can_recv() {\n+                if do_preflight_checks && (*p).packet.can_recv() {\n                     return (*p).id;\n                 }\n             }\n@@ -507,7 +512,7 @@ mod test {\n         let (p2, c2) = Chan::<()>::new();\n         let (p, c) = Chan::new();\n         spawn(proc() {\n-            let mut s = Select::new();\n+            let s = Select::new();\n             let mut h1 = s.handle(&p1);\n             let mut h2 = s.handle(&p2);\n             unsafe { h2.add(); }\n@@ -521,4 +526,91 @@ mod test {\n         c2.send(());\n         p.recv();\n     })\n+\n+    test!(fn preflight1() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        select!(\n+            () = p.recv() => {},\n+        )\n+    })\n+\n+    test!(fn preflight2() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        c.send(());\n+        select!(\n+            () = p.recv() => {},\n+        )\n+    })\n+\n+    test!(fn preflight3() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        select!(\n+            () = p.recv() => {},\n+        )\n+    })\n+\n+    test!(fn preflight4() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight5() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight6() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight7() {\n+        let (p, c) = Chan::<()>::new();\n+        drop(c);\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight8() {\n+        let (p, c) = Chan::new();\n+        c.send(());\n+        drop(c);\n+        p.recv();\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n+\n+    test!(fn preflight9() {\n+        let (p, c) = Chan::new();\n+        drop(c.clone());\n+        c.send(());\n+        drop(c);\n+        p.recv();\n+        let s = Select::new();\n+        let mut h = s.handle(&p);\n+        unsafe { h.add(); }\n+        assert_eq!(s.wait2(false), h.id);\n+    })\n }"}, {"sha": "77bf2d7a68d36be4c5f6734656043fa68f7f1c1a", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=065e121fc2675631e27b761d2ad5df3ee0c95976", "patch": "@@ -398,6 +398,17 @@ impl<T: Send> Packet<T> {\n         cnt == DISCONNECTED || cnt - self.steals > 0\n     }\n \n+    // increment the count on the channel (used for selection)\n+    fn bump(&mut self, amt: int) -> int {\n+        match self.cnt.fetch_add(amt, atomics::SeqCst) {\n+            DISCONNECTED => {\n+                self.cnt.store(DISCONNECTED, atomics::SeqCst);\n+                DISCONNECTED\n+            }\n+            n => n\n+        }\n+    }\n+\n     // Inserts the blocked task for selection on this port, returning it back if\n     // the port already has data on it.\n     //\n@@ -408,8 +419,8 @@ impl<T: Send> Packet<T> {\n         match self.decrement(task) {\n             Ok(()) => Ok(()),\n             Err(task) => {\n-                let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n-                assert!(prev >= 0);\n+                let prev = self.bump(1);\n+                assert!(prev == DISCONNECTED || prev >= 0);\n                 return Err(task);\n             }\n         }\n@@ -440,11 +451,10 @@ impl<T: Send> Packet<T> {\n             let cnt = self.cnt.load(atomics::SeqCst);\n             if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n         };\n-        let prev = self.cnt.fetch_add(steals + 1, atomics::SeqCst);\n+        let prev = self.bump(steals + 1);\n \n         if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(atomics::SeqCst), 0);\n-            self.cnt.store(DISCONNECTED, atomics::SeqCst);\n             true\n         } else {\n             let cur = prev + steals + 1;"}, {"sha": "9c972a3771c1af9c5d9bdef3586acc5a2f20f311", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065e121fc2675631e27b761d2ad5df3ee0c95976/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=065e121fc2675631e27b761d2ad5df3ee0c95976", "patch": "@@ -333,6 +333,17 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n+    // increment the count on the channel (used for selection)\n+    fn bump(&mut self, amt: int) -> int {\n+        match self.cnt.fetch_add(amt, atomics::SeqCst) {\n+            DISCONNECTED => {\n+                self.cnt.store(DISCONNECTED, atomics::SeqCst);\n+                DISCONNECTED\n+            }\n+            n => n\n+        }\n+    }\n+\n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n     pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n@@ -351,8 +362,8 @@ impl<T: Send> Packet<T> {\n                 };\n                 // Undo our decrement above, and we should be guaranteed that the\n                 // previous value is positive because we're not going to sleep\n-                let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n-                assert!(prev >= 0);\n+                let prev = self.bump(1);\n+                assert!(prev == DISCONNECTED || prev >= 0);\n                 return ret;\n             }\n         }\n@@ -384,13 +395,12 @@ impl<T: Send> Packet<T> {\n         // and in the stream case we can have at most one steal, so just assume\n         // that we had one steal.\n         let steals = 1;\n-        let prev = self.cnt.fetch_add(steals + 1, atomics::SeqCst);\n+        let prev = self.bump(steals + 1);\n \n         // If we were previously disconnected, then we know for sure that there\n         // is no task in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(atomics::SeqCst), 0);\n-            self.cnt.store(DISCONNECTED, atomics::SeqCst);\n             true // there is data, that data is that we're disconnected\n         } else {\n             let cur = prev + steals + 1;"}]}