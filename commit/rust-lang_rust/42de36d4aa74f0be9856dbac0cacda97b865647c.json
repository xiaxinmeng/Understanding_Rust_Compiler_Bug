{"sha": "42de36d4aa74f0be9856dbac0cacda97b865647c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZGUzNmQ0YWE3NGYwYmU5ODU2ZGJhYzBjYWNkYTk3Yjg2NTY0N2M=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-27T08:47:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-27T08:47:44Z"}, "message": "Rollup merge of #48639 - varkor:sort_by_key-cached, r=bluss\n\nAdd slice::sort_by_cached_key as a memoised sort_by_key\n\nAt present, `slice::sort_by_key` calls its key function twice for each comparison that is made. When the key function is expensive (which can often be the case when `sort_by_key` is chosen over `sort_by`), this can lead to very suboptimal behaviour.\n\nTo address this, I've introduced a new slice method, `sort_by_cached_key`, which has identical semantic behaviour to `sort_by_key`, except that it guarantees the key function will only be called once per element.\n\nWhere there are `n` elements and the key function is `O(m)`:\n- `slice::sort_by_cached_key` time complexity is `O(m n log m n)`, compared to `slice::sort_by_key`'s `O(m n + n log n)`.\n- `slice::sort_by_cached_key` space complexity remains at `O(n + m)`. (Technically, it now reserves a slice of size `n`, whereas before it reserved a slice of size `n/2`.)\n\n`slice::sort_unstable_by_key` has not been given an analogue, as it is important that unstable sorts are in-place, which is not a property that is guaranteed here. However, this also means that `slice::sort_unstable_by_key` is likely to be slower than `slice::sort_by_cached_key` when the key function does not have negligible complexity. We might want to explore this trade-off further in the future.\n\nBenchmarks (for a vector of 100 `i32`s):\n```\n# Lexicographic: `|x| x.to_string()`\ntest bench_sort_by_key ... bench:      112,638 ns/iter (+/- 19,563)\ntest bench_sort_by_cached_key ... bench:       15,038 ns/iter (+/- 4,814)\n\n# Identity: `|x| *x`\ntest bench_sort_by_key ... bench:        1,346 ns/iter (+/- 238)\ntest bench_sort_by_cached_key ... bench:        1,839 ns/iter (+/- 765)\n\n# Power: `|x| x.pow(31)`\ntest bench_sort_by_key ... bench:        3,624 ns/iter (+/- 738)\ntest bench_sort_by_cached_key ... bench:        1,997 ns/iter (+/- 311)\n\n# Abs: `|x| x.abs()`\ntest bench_sort_by_key ... bench:        1,546 ns/iter (+/- 174)\ntest bench_sort_by_cached_key ... bench:        1,668 ns/iter (+/- 790)\n```\n(So it seems functions that are single operations do perform slightly worse with this method, but for pretty much any more complex key, you're better off with this optimisation.)\n\nI've definitely found myself using expensive keys in the past and wishing this optimisation was made (e.g. for https://github.com/rust-lang/rust/pull/47415). This feels like both desirable and expected behaviour, at the small cost of slightly more stack allocation and minute degradation in performance for extremely trivial keys.\n\nResolves #34447.", "tree": {"sha": "f4550b0f6a52394f1e5364055a24d37482dc9057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4550b0f6a52394f1e5364055a24d37482dc9057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42de36d4aa74f0be9856dbac0cacda97b865647c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaugUwCRBK7hj4Ov3rIwAAdHIIAD+KA2KfvD7Iw0vU3O2+Qu03\nNS41jKvXBHZUiV0/vODK4giMVZl09dv1SUhmlhHQvOT6ZaOZvB+rTYZvt0Sr4o7D\nwt5DqQC5/2XQK4utRhchrrjTOhUi20WvBILo+kuV3rbqM16OECqD/DDktlF+vSJC\nuqQjjRc4aT6VfJaRMPh01EOjpsG8O21FYj4EsXqkVWBoM3Qbm+Jca+fuYT4IEQgT\nBluFe1xRGLJPQlwY8Q4b7bnxlBnDcEcFZLSoTeoGGk5YceEVhKu/LZybT0C9YMf+\nLGP+Mo4B2rV0PMWC97N7iOlMErXrn7dBDM0SvU2Wf1t3a6aYULMVATcJ7ZOlH2A=\n=zDiz\n-----END PGP SIGNATURE-----\n", "payload": "tree f4550b0f6a52394f1e5364055a24d37482dc9057\nparent 31ae4f9fde9b23100c26e5642030128a7e1444ef\nparent 9c7b69e17909ceb090a1c4b8882a4e0924a2a755\nauthor kennytm <kennytm@gmail.com> 1522140464 +0200\ncommitter GitHub <noreply@github.com> 1522140464 +0200\n\nRollup merge of #48639 - varkor:sort_by_key-cached, r=bluss\n\nAdd slice::sort_by_cached_key as a memoised sort_by_key\n\nAt present, `slice::sort_by_key` calls its key function twice for each comparison that is made. When the key function is expensive (which can often be the case when `sort_by_key` is chosen over `sort_by`), this can lead to very suboptimal behaviour.\n\nTo address this, I've introduced a new slice method, `sort_by_cached_key`, which has identical semantic behaviour to `sort_by_key`, except that it guarantees the key function will only be called once per element.\n\nWhere there are `n` elements and the key function is `O(m)`:\n- `slice::sort_by_cached_key` time complexity is `O(m n log m n)`, compared to `slice::sort_by_key`'s `O(m n + n log n)`.\n- `slice::sort_by_cached_key` space complexity remains at `O(n + m)`. (Technically, it now reserves a slice of size `n`, whereas before it reserved a slice of size `n/2`.)\n\n`slice::sort_unstable_by_key` has not been given an analogue, as it is important that unstable sorts are in-place, which is not a property that is guaranteed here. However, this also means that `slice::sort_unstable_by_key` is likely to be slower than `slice::sort_by_cached_key` when the key function does not have negligible complexity. We might want to explore this trade-off further in the future.\n\nBenchmarks (for a vector of 100 `i32`s):\n```\n# Lexicographic: `|x| x.to_string()`\ntest bench_sort_by_key ... bench:      112,638 ns/iter (+/- 19,563)\ntest bench_sort_by_cached_key ... bench:       15,038 ns/iter (+/- 4,814)\n\n# Identity: `|x| *x`\ntest bench_sort_by_key ... bench:        1,346 ns/iter (+/- 238)\ntest bench_sort_by_cached_key ... bench:        1,839 ns/iter (+/- 765)\n\n# Power: `|x| x.pow(31)`\ntest bench_sort_by_key ... bench:        3,624 ns/iter (+/- 738)\ntest bench_sort_by_cached_key ... bench:        1,997 ns/iter (+/- 311)\n\n# Abs: `|x| x.abs()`\ntest bench_sort_by_key ... bench:        1,546 ns/iter (+/- 174)\ntest bench_sort_by_cached_key ... bench:        1,668 ns/iter (+/- 790)\n```\n(So it seems functions that are single operations do perform slightly worse with this method, but for pretty much any more complex key, you're better off with this optimisation.)\n\nI've definitely found myself using expensive keys in the past and wishing this optimisation was made (e.g. for https://github.com/rust-lang/rust/pull/47415). This feels like both desirable and expected behaviour, at the small cost of slightly more stack allocation and minute degradation in performance for extremely trivial keys.\n\nResolves #34447.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42de36d4aa74f0be9856dbac0cacda97b865647c", "html_url": "https://github.com/rust-lang/rust/commit/42de36d4aa74f0be9856dbac0cacda97b865647c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42de36d4aa74f0be9856dbac0cacda97b865647c/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31ae4f9fde9b23100c26e5642030128a7e1444ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/31ae4f9fde9b23100c26e5642030128a7e1444ef", "html_url": "https://github.com/rust-lang/rust/commit/31ae4f9fde9b23100c26e5642030128a7e1444ef"}, {"sha": "9c7b69e17909ceb090a1c4b8882a4e0924a2a755", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7b69e17909ceb090a1c4b8882a4e0924a2a755", "html_url": "https://github.com/rust-lang/rust/commit/9c7b69e17909ceb090a1c4b8882a4e0924a2a755"}], "stats": {"total": 124, "additions": 111, "deletions": 13}, "files": [{"sha": "a43aadfe9a23a72c42b511a8c5a5a3f8add8c015", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=42de36d4aa74f0be9856dbac0cacda97b865647c", "patch": "@@ -13,6 +13,7 @@\n #![cfg_attr(stage0, feature(i128_type))]\n #![feature(rand)]\n #![feature(repr_simd)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "a699ff9c0a76ec61d0a427ab58bfe10c23c09d72", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=42de36d4aa74f0be9856dbac0cacda97b865647c", "patch": "@@ -284,6 +284,17 @@ macro_rules! sort_expensive {\n     }\n }\n \n+macro_rules! sort_lexicographic {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f(|x| x.to_string()));\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+        }\n+    }\n+}\n+\n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n@@ -312,6 +323,10 @@ sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n+sort_lexicographic!(sort_by_key, sort_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_unstable_by_key, sort_unstable_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_by_cached_key, sort_by_cached_key_lexicographic, gen_random, 10000);\n+\n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {\n         #[bench]"}, {"sha": "68f2313843c313e0982ad607d9885d7b3cb4b0a5", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=42de36d4aa74f0be9856dbac0cacda97b865647c", "patch": "@@ -102,6 +102,7 @@ use core::mem::size_of;\n use core::mem;\n use core::ptr;\n use core::slice as core_slice;\n+use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n use boxed::Box;\n@@ -1302,7 +1303,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log(m n))`\n+    /// worst-case, where the key function is `O(m)`.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -1328,12 +1330,82 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n-    pub fn sort_by_key<B, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> B, B: Ord\n+    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Sorts the slice with a key extraction function.\n+    ///\n+    /// During sorting, the key function is called only once per element.\n+    ///\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n+    /// worst-case, where the key function is `O(m)`.\n+    ///\n+    /// For simple key functions (e.g. functions that are property accesses or\n+    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// faster.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n+    /// length of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_sort_by_cached_key)]\n+    /// let mut v = [-5i32, 4, 32, -3, 2];\n+    ///\n+    /// v.sort_by_cached_key(|k| k.to_string());\n+    /// assert!(v == [-3, -5, 2, 32, 4]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[unstable(feature = \"slice_sort_by_cached_key\", issue = \"34447\")]\n+    #[inline]\n+    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n+        macro_rules! sort_by_key {\n+            ($t:ty, $slice:ident, $f:ident) => ({\n+                let mut indices: Vec<_> =\n+                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n+                // The elements of `indices` are unique, as they are indexed, so any sort will be\n+                // stable with respect to the original slice. We use `sort_unstable` here because\n+                // it requires less memory allocation.\n+                indices.sort_unstable();\n+                for i in 0..$slice.len() {\n+                    let mut index = indices[i].1;\n+                    while (index as usize) < i {\n+                        index = indices[index as usize].1;\n+                    }\n+                    indices[i].1 = index;\n+                    $slice.swap(i, index as usize);\n+                }\n+            })\n+        }\n+\n+        let sz_u8    = mem::size_of::<(K, u8)>();\n+        let sz_u16   = mem::size_of::<(K, u16)>();\n+        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_usize = mem::size_of::<(K, usize)>();\n+\n+        let len = self.len();\n+        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n+        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        sort_by_key!(usize, self, f)\n+    }\n+\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n@@ -1410,7 +1482,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n     ///\n     /// # Current implementation\n     ///\n@@ -1420,9 +1492,6 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1435,9 +1504,8 @@ impl<T> [T] {\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> B,\n-              B: Ord\n+    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         core_slice::SliceExt::sort_unstable_by_key(self, f);\n     }"}, {"sha": "0a7e9a8be94f91551560df82a74bda6826360167", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=42de36d4aa74f0be9856dbac0cacda97b865647c", "patch": "@@ -23,6 +23,7 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]"}, {"sha": "99d9c51efc75790c2e552c89d6490423445a2292", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42de36d4aa74f0be9856dbac0cacda97b865647c/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=42de36d4aa74f0be9856dbac0cacda97b865647c", "patch": "@@ -425,6 +425,14 @@ fn test_sort() {\n                 v.sort_by(|a, b| b.cmp(a));\n                 assert!(v.windows(2).all(|w| w[0] >= w[1]));\n \n+                // Sort in lexicographic order.\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n+\n                 // Sort with many pre-sorted runs.\n                 let mut v = orig.clone();\n                 v.sort();\n@@ -477,24 +485,29 @@ fn test_sort_stability() {\n             // the second item represents which occurrence of that\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n-            let mut v: Vec<_> = (0..len)\n+            let mut orig: Vec<_> = (0..len)\n                 .map(|_| {\n                     let n = thread_rng().gen::<usize>() % 10;\n                     counts[n] += 1;\n                     (n, counts[n])\n                 })\n                 .collect();\n \n-            // only sort on the first element, so an unstable sort\n+            let mut v = orig.clone();\n+            // Only sort on the first element, so an unstable sort\n             // may mix up the counts.\n             v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n-            // this comparison includes the count (the second item\n+            // This comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n             // will need to be ordered with increasing\n             // counts... i.e. exactly asserting that this sort is\n             // stable.\n             assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            let mut v = orig.clone();\n+            v.sort_by_cached_key(|&(x, _)| x);\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n         }\n     }\n }"}]}