{"sha": "e772818294fb19622b403358db27dc6e0f11f728", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NzI4MTgyOTRmYjE5NjIyYjQwMzM1OGRiMjdkYzZlMGYxMWY3Mjg=", "commit": {"author": {"name": "Markus Westerlind", "email": "marwes91@gmail.com", "date": "2015-06-08T20:18:13Z"}, "committer": {"name": "Markus Westerlind", "email": "marwes91@gmail.com", "date": "2015-06-08T20:18:13Z"}, "message": "Reordered the methods on str to improve doc sorting", "tree": {"sha": "cb939e57f8337e45a0ae268bf7c800eb8076ceed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb939e57f8337e45a0ae268bf7c800eb8076ceed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e772818294fb19622b403358db27dc6e0f11f728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e772818294fb19622b403358db27dc6e0f11f728", "html_url": "https://github.com/rust-lang/rust/commit/e772818294fb19622b403358db27dc6e0f11f728", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e772818294fb19622b403358db27dc6e0f11f728/comments", "author": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ade076f62c9e8188c4fb5c888277a1673ac82cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ade076f62c9e8188c4fb5c888277a1673ac82cd", "html_url": "https://github.com/rust-lang/rust/commit/1ade076f62c9e8188c4fb5c888277a1673ac82cd"}], "stats": {"total": 1837, "additions": 919, "deletions": 918}, "files": [{"sha": "a9725214c1953de45dc28abea8086427798c1469", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 919, "deletions": 918, "changes": 1837, "blob_url": "https://github.com/rust-lang/rust/blob/e772818294fb19622b403358db27dc6e0f11f728/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e772818294fb19622b403358db27dc6e0f11f728/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e772818294fb19622b403358db27dc6e0f11f728", "patch": "@@ -428,719 +428,637 @@ Section: Trait implementations\n #[cfg(not(test))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl str {\n-    /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"return type may change to be an iterator\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable(feature = \"collections\",\n-               reason = \"return type may change to be an iterator\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n-    /// Replaces all occurrences of one string with another.\n-    ///\n-    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a\n-    /// second `&str` to\n-    /// replace it with. If the original `&str` isn't found, no change occurs.\n+    /// Returns the length of `self` in bytes.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let s = \"this is old\";\n-    ///\n-    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n-    /// ```\n-    ///\n-    /// When a `&str` isn't found:\n-    ///\n-    /// ```\n-    /// let s = \"this is old\";\n-    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// assert_eq!(\"foo\".len(), 3);\n+    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn replace(&self, from: &str, to: &str) -> String {\n-        let mut result = String::new();\n-        let mut last_end = 0;\n-        for (start, end) in self.match_indices(from) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n-            result.push_str(to);\n-            last_end = end;\n-        }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n-        result\n-    }\n-\n-    /// Returns an iterator over the string in Unicode Normalization Form D\n-    /// (canonical decomposition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Canonical\n-        }\n-    }\n-\n-    /// Returns an iterator over the string in Unicode Normalization Form KD\n-    /// (compatibility decomposition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n     #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfkd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Compatible\n-        }\n+    pub fn len(&self) -> usize {\n+        core_str::StrExt::len(&self[..])\n     }\n \n-    /// An Iterator over the string in Unicode Normalization Form C\n-    /// (canonical decomposition followed by canonical composition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n+    /// Returns true if this slice has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"\".is_empty());\n+    /// ```\n     #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(&self[..])\n     }\n \n-    /// An Iterator over the string in Unicode Normalization Form KC\n-    /// (compatibility decomposition followed by canonical composition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n+    /// Returns a string's displayed width in columns.\n+    ///\n+    /// Control characters have zero width.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be\n+    /// `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these\n+    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the\n+    /// locale is unknown.\n+    #[deprecated(reason = \"use the crates.io `unicode-width` library instead\",\n+                 since = \"1.0.0\")]\n     #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfkc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfkd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn width(&self, is_cjk: bool) -> usize {\n+        UnicodeStr::width(&self[..], is_cjk)\n     }\n \n-    /// Returns `true` if `self` contains another `&str`.\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n+    /// boundaries.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than `self.len()`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// assert!(\"bananas\".contains(\"nana\"));\n+    /// # #![feature(str_char)]\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n     ///\n-    /// assert!(!\"bananas\".contains(\"foobar\"));\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains(&self[..], pat)\n+    #[unstable(feature = \"str_char\",\n+               reason = \"it is unclear whether this method pulls its weight \\\n+                         with the existence of the char_indices iterator or \\\n+                         this method may want to be replaced with checked \\\n+                         slicing\")]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n \n-    /// An iterator over the codepoints of `self`.\n+    /// Converts `self` to a byte slice.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    ///\n-    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(&self[..])\n+    #[inline(always)]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(&self[..])\n     }\n \n-    /// An iterator over the bytes of `self`.\n+    /// Returns an unsafe pointer to the `&str`'s buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer, and\n+    /// that it is not\n+    /// reallocated (e.g. by pushing to the string).\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<u8> = \"bors\".bytes().collect();\n-    ///\n-    /// assert_eq!(v, b\"bors\".to_vec());\n+    /// let s = \"Hello\";\n+    /// let p = s.as_ptr();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(&self[..])\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(&self[..])\n     }\n \n-    /// An iterator over the characters of `self` and their byte offsets.\n+    /// Takes a bytewise slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries\n+    /// of the entire slice as\n+    /// well.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n-    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n-    /// assert_eq!(v, b);\n+    /// unsafe {\n+    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(&self[..])\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n+    /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// That is, start at the `begin`-th code point of the string and continue\n+    /// to the `end`-th code point. This does not detect or handle edge cases\n+    /// such as leaving a combining character as the first code point of the\n+    /// string.\n     ///\n-    /// # Iterator behavior\n+    /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n+    /// syntax if you want to use byte indices rather than codepoint indices.\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search and forward/reverse search yields the same elements.\n-    /// This is true for, eg, `char` but not\n-    /// for `&str`.\n+    /// # Panics\n     ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rsplit()` can be used.\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n+    /// last character of the string.\n     ///\n     /// # Examples\n     ///\n-    /// Simple patterns:\n-    ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// # #![feature(collections)]\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n-    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    ///\n-    /// A more complex pattern, using a closure:\n-    ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        core_str::StrExt::split(&self[..], pat)\n+    #[unstable(feature = \"collections\",\n+               reason = \"may have yet to prove its worth\")]\n+    pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_chars(&self[..], begin, end)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// Given a byte position, return the next char and its index.\n     ///\n-    /// # Iterator behavior\n+    /// This can be used to iterate over the Unicode characters of a string.\n     ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search,\n-    /// and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n+    /// # Panics\n     ///\n-    /// For iterating from the front, `split()` can be used.\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     ///\n     /// # Examples\n     ///\n-    /// Simple patterns:\n-    ///\n-    /// ```rust\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"\"]);\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n+    /// done by `.chars()` or `.char_indices()`.\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    /// # #![feature(str_char, core)]\n+    /// use std::str::CharRange;\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n     /// ```\n     ///\n-    /// A more complex pattern, using a closure:\n+    /// This outputs:\n     ///\n+    /// ```text\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n     /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit(&self[..], pat)\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n+    pub fn char_range_at(&self, start: usize) -> CharRange {\n+        core_str::StrExt::char_range_at(&self[..], start)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n+    /// Given a byte position, return the previous `char` and its position.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns\n-    /// like regular expressions.\n+    /// This function can be used to iterate over a Unicode string in reverse.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty.\n+    /// Returns 0 for next index if called on start index 0.\n     ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n+    /// # Panics\n     ///\n-    /// # Iterator behavior\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search\n-    /// and forward/reverse search yields the same elements. This is true\n-    /// for, eg, `char` but not for `&str`.\n+    /// # Examples\n     ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rsplit_terminator()` can be used.\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n+    /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n-    /// # Examples\n+    /// ```\n+    /// # #![feature(str_char, core)]\n+    /// use std::str::CharRange;\n     ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = s.len();\n+    /// while i > 0 {\n+    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n     /// ```\n-    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 16: m\n+    /// 15: a\n+    /// 14: N\n+    /// 13:\n+    /// 12: t\n+    /// 11: \u1ec7\n+    /// 8: i\n+    /// 7: V\n+    /// 6: \u534e\n+    /// 3: \u4e2d\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        core_str::StrExt::split_terminator(&self[..], pat)\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at_reverse() or \\\n+                         eventually removed altogether\")]\n+    pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n+        core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n+    /// Given a byte position, return the `char` at that position.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// # Panics\n     ///\n-    /// Equivalent to `split`, except that the trailing substring is\n-    /// skipped if empty.\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     ///\n-    /// This method can be used for string data that is _terminated_,\n-    /// rather than _separated_ by a pattern.\n+    /// # Examples\n     ///\n-    /// # Iterator behavior\n+    /// ```\n+    /// # #![feature(str_char)]\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at(1), 'b');\n+    /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// ```\n+    #[unstable(feature = \"str_char\",\n+               reason = \"frequently replaced by the chars() iterator, this \\\n+                         method may be removed or possibly renamed in the \\\n+                         future; it is normally replaced by chars/char_indices \\\n+                         iterators or by getting the first char from a \\\n+                         subslice\")]\n+    pub fn char_at(&self, i: usize) -> char {\n+        core_str::StrExt::char_at(&self[..], i)\n+    }\n+\n+    /// Given a byte position, return the `char` at that position, counting\n+    /// from the end.\n     ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search, and it will be double ended if a forward/reverse\n-    /// search yields the same elements.\n+    /// # Panics\n     ///\n-    /// For iterating from the front, `split_terminator()` can be used.\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n-    /// assert_eq!(v, [\"B\", \"A\"]);\n-    ///\n-    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n-    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n+    /// # #![feature(str_char)]\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at_reverse(1), 'a');\n+    /// assert_eq!(s.char_at_reverse(2), 'b');\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplit_terminator(&self[..], pat)\n+    #[unstable(feature = \"str_char\",\n+               reason = \"see char_at for more details, but reverse semantics \\\n+                         are also somewhat unclear, especially with which \\\n+                         cases generate panics\")]\n+    pub fn char_at_reverse(&self, i: usize) -> char {\n+        core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// restricted to returning\n-    /// at most `count` items.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// # Iterator behavior\n+    /// Retrieves the first character from a `&str` and returns it.\n     ///\n-    /// The returned iterator will not be double ended, because it is\n-    /// not efficient to support.\n+    /// This does not allocate a new string; instead, it returns a slice that\n+    /// points one character\n+    /// beyond the character that was shifted.\n     ///\n-    /// If the pattern allows a reverse search, `rsplitn()` can be used.\n+    /// If the slice does not contain any characters, None is returned instead.\n     ///\n     /// # Examples\n     ///\n-    /// Simple patterns:\n-    ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    /// # #![feature(str_char)]\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    /// assert_eq!(c, 'L');\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n     ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"\"]);\n-    /// ```\n+    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    #[unstable(feature = \"str_char\",\n+               reason = \"awaiting conventions about shifting and slices and \\\n+                         may not be warranted with the existence of the chars \\\n+                         and/or char_indices iterators\")]\n+    pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n+        core_str::StrExt::slice_shift_char(&self[..])\n+    }\n+\n+    /// An iterator over the codepoints of `self`.\n     ///\n-    /// A more complex pattern, using a closure:\n+    /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    ///\n+    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(&self[..], count, pat)\n+    pub fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(&self[..])\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string, restricted to returning\n-    /// at most `count` items.\n-    ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n-    ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will not be double ended, because it is not\n-    /// efficient to support.\n-    ///\n-    /// `splitn()` can be used for splitting from the front.\n+    /// An iterator over the characters of `self` and their byte offsets.\n     ///\n     /// # Examples\n     ///\n-    /// Simple patterns:\n-    ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n+    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n+    /// assert_eq!(v, b);\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(&self[..])\n+    }\n+\n+    /// An iterator over the bytes of `self`.\n     ///\n-    /// A more complex pattern, using a closure:\n+    /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n-    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    ///\n+    /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rsplitn(&self[..], count, pat)\n+    pub fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(&self[..])\n     }\n \n-    /// An iterator over the matches of a pattern within `self`.\n-    ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator will be double ended if the pattern allows\n-    /// a reverse search\n-    /// and forward/reverse search yields the same elements. This is true\n-    /// for, eg, `char` but not\n-    /// for `&str`.\n-    ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rmatches()` can be used.\n+    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n+    /// and which are separated by any amount of whitespace.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.split_whitespace().collect();\n     ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"method got recently added\")]\n-    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n-        core_str::StrExt::matches(&self[..], pat)\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        UnicodeStr::split_whitespace(&self[..])\n     }\n \n-    /// An iterator over the matches of a pattern within `self`, yielded in\n-    /// reverse order.\n-    ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n-    ///\n-    /// # Iterator behavior\n-    ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search,\n-    /// and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n-    ///\n-    /// For iterating from the front, `matches()` can be used.\n+    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n+    /// and which are separated by any amount of whitespace.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n-    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    /// # #![feature(str_words)]\n+    /// # #![allow(deprecated)]\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.words().collect();\n     ///\n-    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n-    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"method got recently added\")]\n-    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatches(&self[..], pat)\n+    #[deprecated(reason = \"words() will be removed. Use split_whitespace() instead\",\n+                 since = \"1.1.0\")]\n+    #[unstable(feature = \"str_words\",\n+               reason = \"the precise algorithm to use is unclear\")]\n+    #[allow(deprecated)]\n+    pub fn words(&self) -> Words {\n+        UnicodeStr::words(&self[..])\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches\n-    /// of a pattern within `self`.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the first\n-    /// match are returned.\n+    /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// This does not include the empty string after a trailing `\\n`.\n     ///\n-    /// # Iterator behavior\n+    /// # Examples\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search\n-    /// and forward/reverse search yields the same elements. This is true for,\n-    /// eg, `char` but not\n-    /// for `&str`.\n+    /// ```\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rmatch_indices()` can be used.\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n     ///\n-    /// # Examples\n+    /// Leaving off the trailing character:\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0, 3), (6, 9), (12, 15)]);\n-    ///\n-    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1, 4), (4, 7)]);\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might have its iterator type changed\")]\n-    // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n-    // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n-    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        core_str::StrExt::match_indices(&self[..], pat)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(&self[..])\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches of\n-    /// a pattern within\n-    /// `self`, yielded in reverse order.\n-    ///\n-    /// For matches of `pat` within `self` that overlap, only the indices\n-    /// corresponding to the last\n-    /// match are returned.\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// As with `.lines()`, this does not include an empty trailing line.\n     ///\n-    /// # Iterator behavior\n+    /// # Examples\n     ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search,\n-    /// and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n+    /// ```\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// For iterating from the front, `match_indices()` can be used.\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n     ///\n-    /// # Examples\n+    /// Leaving off the trailing character:\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12, 15), (6, 9), (0, 3)]);\n-    ///\n-    /// let v: Vec<(usize, usize)> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4, 7), (1, 4)]);\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n-    /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might have its iterator type changed\")]\n-    // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n-    // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n-    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rmatch_indices(&self[..], pat)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(&self[..])\n+    }\n+\n+    /// Returns an iterator over the string in Unicode Normalization Form D\n+    /// (canonical decomposition).\n+    #[allow(deprecated)]\n+    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n+             since = \"1.0.0\")]\n+    #[inline]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n+    pub fn nfd_chars(&self) -> Decompositions {\n+        Decompositions {\n+            iter: self[..].chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: Canonical\n+        }\n+    }\n+\n+    /// Returns an iterator over the string in Unicode Normalization Form KD\n+    /// (compatibility decomposition).\n+    #[allow(deprecated)]\n+    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n+             since = \"1.0.0\")]\n+    #[inline]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n+    pub fn nfkd_chars(&self) -> Decompositions {\n+        Decompositions {\n+            iter: self[..].chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: Compatible\n+        }\n+    }\n+\n+    /// An Iterator over the string in Unicode Normalization Form C\n+    /// (canonical decomposition followed by canonical composition).\n+    #[allow(deprecated)]\n+    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n+             since = \"1.0.0\")]\n+    #[inline]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n+    pub fn nfc_chars(&self) -> Recompositions {\n+        Recompositions {\n+            iter: self.nfd_chars(),\n+            state: Composing,\n+            buffer: VecDeque::new(),\n+            composee: None,\n+            last_ccc: None\n+        }\n     }\n \n-    /// An iterator over the lines of a string, separated by `\\n`.\n-    ///\n-    /// This does not include the empty string after a trailing `\\n`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    ///\n-    /// Leaving off the trailing character:\n-    ///\n-    /// ```\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(&self[..])\n+    /// An Iterator over the string in Unicode Normalization Form KC\n+    /// (compatibility decomposition followed by canonical composition).\n+    #[allow(deprecated)]\n+    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n+             since = \"1.0.0\")]\n+    #[inline]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n+    pub fn nfkc_chars(&self) -> Recompositions {\n+        Recompositions {\n+            iter: self.nfkd_chars(),\n+            state: Composing,\n+            buffer: VecDeque::new(),\n+            composee: None,\n+            last_ccc: None\n+        }\n     }\n \n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`.\n+    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n     ///\n-    /// As with `.lines()`, this does not include an empty trailing line.\n+    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n     ///\n-    /// # Examples\n+    /// If `is_extended` is true, the iterator is over the\n+    /// *extended grapheme clusters*;\n+    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n+    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// recommends extended grapheme cluster boundaries for general processing.\n     ///\n-    /// ```\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// # Examples\n     ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n+    /// # #![feature(unicode, core)]\n+    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n     ///\n-    /// Leaving off the trailing character:\n+    /// assert_eq!(&gr1[..], b);\n     ///\n-    /// ```\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(&gr2[..], b);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(&self[..])\n+    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n+             since = \"1.0.0\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n+        UnicodeStr::graphemes(&self[..], is_extended)\n     }\n-    /// Returns a slice of the string from the character range [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and continue\n-    /// to the `end`-th code point. This does not detect or handle edge cases\n-    /// such as leaving a combining character as the first code point of the\n-    /// string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n-    /// syntax if you want to use byte indices rather than codepoint indices.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n-    /// last character of the string.\n+\n+    /// Returns an iterator over the grapheme clusters of `self` and their\n+    /// byte offsets. See\n+    /// `graphemes()` for more information.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(collections)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// # #![feature(unicode, core)]\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     ///\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// assert_eq!(&gr_inds[..], b);\n     /// ```\n+    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n+             since = \"1.0.0\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n+        UnicodeStr::grapheme_indices(&self[..], is_extended)\n+    }\n+\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"collections\",\n-               reason = \"may have yet to prove its worth\")]\n-    pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_chars(&self[..], begin, end)\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn utf16_units(&self) -> Utf16Units {\n+        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n \n-    /// Takes a bytewise slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries\n-    /// of the entire slice as\n-    /// well.\n+    /// Returns `true` if `self` contains another `&str`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(\"bananas\".contains(\"nana\"));\n     ///\n-    /// unsafe {\n-    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n-    /// }\n+    /// assert!(!\"bananas\".contains(\"foobar\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::contains(&self[..], pat)\n     }\n \n     /// Returns `true` if the given `&str` is a prefix of the string.\n@@ -1169,404 +1087,524 @@ impl str {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match a pattern\n-    /// repeatedly removed.\n+    /// Returns the byte index of the first character of `self` that matches\n+    /// the pattern, if it\n+    /// exists.\n     ///\n-    /// The pattern can be a simple `char`, or a closure that determines\n-    /// the split.\n+    /// Returns `None` if it doesn't exist.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the\n+    /// split.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n     ///\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    ///\n+    /// assert_eq!(s.find(x), None);\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        core_str::StrExt::find(&self[..], pat)\n+    }\n+\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches the pattern, if it\n+    /// exists.\n     ///\n-    /// A more complex pattern, using a closure:\n+    /// Returns `None` if it doesn't exist.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`,\n+    /// or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n     ///\n     /// ```\n-    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n-        where P::Searcher: DoubleEndedSearcher<'a>\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::trim_matches(&self[..], pat)\n+        core_str::StrExt::rfind(&self[..], pat)\n     }\n \n-    /// Returns a string with all prefixes that match a pattern\n-    /// repeatedly removed.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern.\n     ///\n     /// The pattern can be a simple `&str`, `char`, or a closure that\n     /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search and forward/reverse search yields the same elements.\n+    /// This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit()` can be used.\n     ///\n     /// # Examples\n     ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n     ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n-        core_str::StrExt::trim_left_matches(&self[..], pat)\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// Returns a string with all suffixes that match a pattern\n-    /// repeatedly removed.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n     ///\n     /// The pattern can be a simple `&str`, `char`, or a closure that\n     /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n+    ///\n+    /// For iterating from the front, `split()` can be used.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n-    /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     ///\n     /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::trim_right_matches(&self[..], pat)\n+        core_str::StrExt::rsplit(&self[..], pat)\n     }\n \n-    /// Checks that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`) are\n-    /// considered to be\n-    /// boundaries.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `index` is greater than `self.len()`.\n-    ///\n-    /// # Examples\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern.\n     ///\n-    /// ```\n-    /// # #![feature(str_char)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns\n+    /// like regular expressions.\n     ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty.\n     ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"it is unclear whether this method pulls its weight \\\n-                         with the existence of the char_indices iterator or \\\n-                         this method may want to be replaced with checked \\\n-                         slicing\")]\n-    pub fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(&self[..], index)\n-    }\n-\n-    /// Given a byte position, return the next char and its index.\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n     ///\n-    /// This can be used to iterate over the Unicode characters of a string.\n+    /// # Iterator behavior\n     ///\n-    /// # Panics\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not for `&str`.\n     ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit_terminator()` can be used.\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string;\n-    /// this should normally be\n-    /// done by `.chars()` or `.char_indices()`.\n-    ///\n-    /// ```\n-    /// # #![feature(str_char, core)]\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n     /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at() or eventually \\\n-                         removed altogether\")]\n-    pub fn char_range_at(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at(&self[..], start)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// Given a byte position, return the previous `char` and its position.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// Returns 0 for next index if called on start index 0.\n+    /// Equivalent to `split`, except that the trailing substring is\n+    /// skipped if empty.\n     ///\n-    /// # Panics\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _separated_ by a pattern.\n     ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// # Iterator behavior\n     ///\n-    /// # Examples\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n     ///\n-    /// This example manually iterates through the characters of a string;\n-    /// this should normally be\n-    /// done by `.chars().rev()` or `.char_indices()`.\n+    /// For iterating from the front, `split_terminator()` can be used.\n     ///\n-    /// ```\n-    /// # #![feature(str_char, core)]\n-    /// use std::str::CharRange;\n+    /// # Examples\n     ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = s.len();\n-    /// while i > 0 {\n-    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n     /// ```\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n     ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 16: m\n-    /// 15: a\n-    /// 14: N\n-    /// 13:\n-    /// 12: t\n-    /// 11: \u1ec7\n-    /// 8: i\n-    /// 7: V\n-    /// 6: \u534e\n-    /// 3: \u4e2d\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n     /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at_reverse() or \\\n-                         eventually removed altogether\")]\n-    pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(&self[..], start)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit_terminator(&self[..], pat)\n     }\n \n-    /// Given a byte position, return the `char` at that position.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// restricted to returning\n+    /// at most `count` items.\n     ///\n-    /// # Examples\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// ```\n-    /// # #![feature(str_char)]\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at(1), 'b');\n-    /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"frequently replaced by the chars() iterator, this \\\n-                         method may be removed or possibly renamed in the \\\n-                         future; it is normally replaced by chars/char_indices \\\n-                         iterators or by getting the first char from a \\\n-                         subslice\")]\n-    pub fn char_at(&self, i: usize) -> char {\n-        core_str::StrExt::char_at(&self[..], i)\n-    }\n-\n-    /// Given a byte position, return the `char` at that position, counting\n-    /// from the end.\n+    /// # Iterator behavior\n     ///\n-    /// # Panics\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n     ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// If the pattern allows a reverse search, `rsplitn()` can be used.\n     ///\n     /// # Examples\n     ///\n+    /// Simple patterns:\n+    ///\n     /// ```\n-    /// # #![feature(str_char)]\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at_reverse(1), 'a');\n-    /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n     /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"see char_at for more details, but reverse semantics \\\n-                         are also somewhat unclear, especially with which \\\n-                         cases generate panics\")]\n-    pub fn char_at_reverse(&self, i: usize) -> char {\n-        core_str::StrExt::char_at_reverse(&self[..], i)\n-    }\n-\n-    /// Converts `self` to a byte slice.\n     ///\n-    /// # Examples\n+    /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n+    /// let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline(always)]\n-    pub fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(&self[..])\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n-    /// Returns the byte index of the first character of `self` that matches\n-    /// the pattern, if it\n-    /// exists.\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// starting from the end of the string, restricted to returning\n+    /// at most `count` items.\n     ///\n-    /// Returns `None` if it doesn't exist.\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n     ///\n     /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the\n-    /// split.\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// `splitn()` can be used for splitting from the front.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n     ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n-    /// More complex patterns with closures:\n+    /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find(char::is_whitespace), Some(5));\n-    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n+    /// let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplitn(&self[..], count, pat)\n+    }\n+\n+    /// An iterator over the matches of a pattern within `self`.\n     ///\n-    /// Not finding the pattern:\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows\n+    /// a reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatches()` can be used.\n+    ///\n+    /// # Examples\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n     ///\n-    /// assert_eq!(s.find(x), None);\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(&self[..], pat)\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        core_str::StrExt::matches(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that\n-    /// matches the pattern, if it\n-    /// exists.\n+    /// An iterator over the matches of a pattern within `self`, yielded in\n+    /// reverse order.\n     ///\n-    /// Returns `None` if it doesn't exist.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// The pattern can be a simple `&str`, `char`,\n-    /// or a closure that determines the split.\n+    /// # Iterator behavior\n     ///\n-    /// # Examples\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n     ///\n-    /// Simple patterns:\n+    /// For iterating from the front, `matches()` can be used.\n+    ///\n+    /// # Examples\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n     ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n     /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatches(&self[..], pat)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint matches\n+    /// of a pattern within `self`.\n     ///\n-    /// More complex patterns with closures:\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first\n+    /// match are returned.\n     ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// assert_eq!(s.rfind(char::is_whitespace), Some(12));\n-    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n-    /// ```\n+    /// # Iterator behavior\n     ///\n-    /// Not finding the pattern:\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true for,\n+    /// eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatch_indices()` can be used.\n+    ///\n+    /// # Examples\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let x: &[_] = &['1', '2'];\n+    /// # #![feature(collections)]\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0, 3), (6, 9), (12, 15)]);\n     ///\n-    /// assert_eq!(s.rfind(x), None);\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1, 4), (4, 7)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n-        where P::Searcher: ReverseSearcher<'a>\n-    {\n-        core_str::StrExt::rfind(&self[..], pat)\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n+    // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n-    /// Retrieves the first character from a `&str` and returns it.\n+    /// An iterator over the start and end indices of the disjoint matches of\n+    /// a pattern within\n+    /// `self`, yielded in reverse order.\n     ///\n-    /// This does not allocate a new string; instead, it returns a slice that\n-    /// points one character\n-    /// beyond the character that was shifted.\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last\n+    /// match are returned.\n     ///\n-    /// If the slice does not contain any characters, None is returned instead.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n+    ///\n+    /// For iterating from the front, `match_indices()` can be used.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(str_char)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char().unwrap();\n-    ///\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// # #![feature(collections)]\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, 15), (6, 9), (0, 3)]);\n     ///\n-    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, 7), (1, 4)]);\n     ///\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n     /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"awaiting conventions about shifting and slices and \\\n-                         may not be warranted with the existence of the chars \\\n-                         and/or char_indices iterators\")]\n-    pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(&self[..])\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n+    // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatch_indices(&self[..], pat)\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing\n@@ -1593,230 +1631,179 @@ impl str {\n         core_str::StrExt::subslice_offset(&self[..], inner)\n     }\n \n-    /// Returns an unsafe pointer to the `&str`'s buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer, and\n-    /// that it is not\n-    /// reallocated (e.g. by pushing to the string).\n+    /// Returns a `&str` with leading and trailing whitespace removed.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let s = \"Hello\";\n-    /// let p = s.as_ptr();\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(&self[..])\n-    }\n-\n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n+    pub fn trim(&self) -> &str {\n+        UnicodeStr::trim(&self[..])\n     }\n \n-    /// Returns the length of `self` in bytes.\n+    /// Returns a `&str` with leading whitespace removed.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        core_str::StrExt::len(&self[..])\n+    pub fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(&self[..])\n     }\n \n-    /// Returns true if this slice has a length of zero bytes.\n+    /// Returns a `&str` with trailing whitespace removed.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// assert!(\"\".is_empty());\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n     /// ```\n-    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(&self[..])\n+    pub fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(&self[..])\n     }\n \n-    /// Parses `self` into the specified type.\n+    /// Returns a string with all pre- and suffixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// # Failure\n+    /// The pattern can be a simple `char`, or a closure that determines\n+    /// the split.\n     ///\n-    /// Will return `Err` if it's not possible to parse `self` into the type.\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple patterns:\n     ///\n     /// ```\n-    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// ```\n     ///\n-    /// Failing:\n+    /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// assert!(\"j\".parse::<u32>().is_err());\n+    /// assert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n     /// ```\n-    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(&self[..])\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n-    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n-    ///\n-    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n+    /// Returns a string with all prefixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// If `is_extended` is true, the iterator is over the\n-    /// *extended grapheme clusters*;\n-    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n-    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// recommends extended grapheme cluster boundaries for general processing.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(unicode, core)]\n-    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n-    ///\n-    /// assert_eq!(&gr1[..], b);\n-    ///\n-    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n     ///\n-    /// assert_eq!(&gr2[..], b);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// ```\n-    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n-             since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(&self[..], is_extended)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n-    /// Returns an iterator over the grapheme clusters of `self` and their\n-    /// byte offsets. See\n-    /// `graphemes()` for more information.\n+    /// Returns a string with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n+    /// Simple patterns:\n+    ///\n     /// ```\n-    /// # #![feature(unicode, core)]\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n-    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n     ///\n-    /// assert_eq!(&gr_inds[..], b);\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// ```\n-    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n-             since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(&self[..], is_extended)\n-    }\n-\n-    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n-    /// and which are separated by any amount of whitespace.\n     ///\n-    /// # Examples\n+    /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// # #![feature(str_words)]\n-    /// # #![allow(deprecated)]\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.words().collect();\n-    ///\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(\"1fooX\".trim_left_matches(|c| c == '1' || c == 'X'), \"fooX\");\n     /// ```\n-    #[deprecated(reason = \"words() will be removed. Use split_whitespace() instead\",\n-                 since = \"1.1.0\")]\n-    #[unstable(feature = \"str_words\",\n-               reason = \"the precise algorithm to use is unclear\")]\n-    #[allow(deprecated)]\n-    pub fn words(&self) -> Words {\n-        UnicodeStr::words(&self[..])\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n-    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n-    /// and which are separated by any amount of whitespace.\n-    ///\n-    /// # Examples\n+    /// Parses `self` into the specified type.\n     ///\n-    /// ```\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.split_whitespace().collect();\n+    /// # Failure\n     ///\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-    pub fn split_whitespace(&self) -> SplitWhitespace {\n-        UnicodeStr::split_whitespace(&self[..])\n-    }\n-\n-    /// Returns a string's displayed width in columns.\n+    /// Will return `Err` if it's not possible to parse `self` into the type.\n     ///\n-    /// Control characters have zero width.\n+    /// # Example\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be\n-    /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the\n-    /// locale is unknown.\n-    #[deprecated(reason = \"use the crates.io `unicode-width` library instead\",\n-                 since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn width(&self, is_cjk: bool) -> usize {\n-        UnicodeStr::width(&self[..], is_cjk)\n-    }\n-\n-    /// Returns a `&str` with leading and trailing whitespace removed.\n+    /// ```\n+    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// ```\n     ///\n-    /// # Examples\n+    /// Failing:\n     ///\n     /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n+    /// assert!(\"j\".parse::<u32>().is_err());\n     /// ```\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim(&self) -> &str {\n-        UnicodeStr::trim(&self[..])\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        core_str::StrExt::parse(&self[..])\n     }\n \n-    /// Returns a `&str` with leading whitespace removed.\n+    /// Replaces all occurrences of one string with another.\n+    ///\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a\n+    /// second `&str` to\n+    /// replace it with. If the original `&str` isn't found, no change occurs.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n+    /// let s = \"this is old\";\n+    ///\n+    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(&self[..])\n-    }\n-\n-    /// Returns a `&str` with trailing whitespace removed.\n     ///\n-    /// # Examples\n+    /// When a `&str` isn't found:\n     ///\n     /// ```\n-    /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(&self[..])\n+    pub fn replace(&self, from: &str, to: &str) -> String {\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, end) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = end;\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n     }\n \n     /// Returns the lowercase equivalent of this string.\n@@ -1852,4 +1839,18 @@ impl str {\n         s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));\n         return s;\n     }\n+\n+    /// Escapes each char in `s` with `char::escape_default`.\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n+    pub fn escape_default(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with `char::escape_unicode`.\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n+    pub fn escape_unicode(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n+    }\n }"}]}