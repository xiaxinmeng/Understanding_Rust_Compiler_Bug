{"sha": "f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NDM5Y2U4ZmUxYTlmNDY1MjVkOTFmYjRjN2IxMWI4YTFmODA5ZmM=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-05-06T06:22:17Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-05-06T06:22:17Z"}, "message": "Put operands on its own line when each fits in a single line", "tree": {"sha": "43d7c422881aea8ffe46408531de53e1b21eb0ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43d7c422881aea8ffe46408531de53e1b21eb0ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc", "html_url": "https://github.com/rust-lang/rust/commit/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84e5634a1bc542d5cb0b18b9266b3fd5522bfd3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e5634a1bc542d5cb0b18b9266b3fd5522bfd3a", "html_url": "https://github.com/rust-lang/rust/commit/84e5634a1bc542d5cb0b18b9266b3fd5522bfd3a"}], "stats": {"total": 94, "additions": 85, "deletions": 9}, "files": [{"sha": "2116ef03fd2dddf63a83af8607760bbda0e2d5ed", "filename": "src/expr.rs", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=f8439ce8fe1a9f46525d91fb4c7b11b8a1f809fc", "patch": "@@ -86,16 +86,18 @@ pub fn format_expr(\n             rewrite_call(context, &callee_str, args, inner_span, shape)\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape, expr.span),\n-        ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n+        ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n-            rewrite_pair(\n-                &**lhs,\n-                &**rhs,\n-                PairParts::new(\"\", &format!(\" {} \", context.snippet(op.span)), \"\"),\n-                context,\n-                shape,\n-                context.config.binop_separator(),\n-            )\n+            rewrite_simple_binaries(context, expr, shape, op).or_else(|| {\n+                rewrite_pair(\n+                    &**lhs,\n+                    &**rhs,\n+                    PairParts::new(\"\", &format!(\" {} \", context.snippet(op.span)), \"\"),\n+                    context,\n+                    shape,\n+                    context.config.binop_separator(),\n+                )\n+            })\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n         ast::ExprKind::Struct(ref path, ref fields, ref base) => rewrite_struct_lit(\n@@ -352,6 +354,80 @@ pub fn format_expr(\n         })\n }\n \n+/// Collect operands that appears in the given binary operator in the opposite order.\n+/// e.g. `collect_binary_items(e, ||)` for `a && b || c || d` returns `[d, c, a && b]`.\n+fn collect_binary_items<'a>(mut expr: &'a ast::Expr, binop: ast::BinOp) -> Vec<&'a ast::Expr> {\n+    let mut result = vec![];\n+    let mut prev_lhs = None;\n+    loop {\n+        match expr.node {\n+            ast::ExprKind::Binary(inner_binop, ref lhs, ref rhs)\n+                if inner_binop.node == binop.node =>\n+            {\n+                result.push(&**rhs);\n+                expr = lhs;\n+                prev_lhs = Some(lhs);\n+            }\n+            _ => {\n+                if let Some(lhs) = prev_lhs {\n+                    result.push(lhs);\n+                }\n+                break;\n+            }\n+        }\n+    }\n+    result\n+}\n+\n+/// Rewrites a binary expression whose operands fits within a single line.\n+fn rewrite_simple_binaries(\n+    context: &RewriteContext,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+    op: ast::BinOp,\n+) -> Option<String> {\n+    let op_str = context.snippet(op.span);\n+\n+    // 2 = spaces around a binary operator.\n+    let sep_overhead = op_str.len() + 2;\n+    let nested_overhead = sep_overhead - 1;\n+\n+    let nested_shape = (match context.config.indent_style() {\n+        IndentStyle::Visual => shape.visual_indent(0),\n+        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n+    }).with_max_width(context.config);\n+    let nested_shape = match context.config.binop_separator() {\n+        SeparatorPlace::Back => nested_shape.sub_width(nested_overhead)?,\n+        SeparatorPlace::Front => nested_shape.offset_left(nested_overhead)?,\n+    };\n+\n+    let opt_rewrites: Option<Vec<_>> = collect_binary_items(expr, op)\n+        .iter()\n+        .rev()\n+        .map(|e| e.rewrite(context, nested_shape))\n+        .collect();\n+    if let Some(rewrites) = opt_rewrites {\n+        if rewrites.iter().all(|e| ::utils::is_single_line(e)) {\n+            let total_width = rewrites.iter().map(|s| s.len()).sum::<usize>()\n+                + sep_overhead * (rewrites.len() - 1);\n+\n+            let sep_str = if total_width <= shape.width {\n+                format!(\" {} \", op_str)\n+            } else {\n+                let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+                match context.config.binop_separator() {\n+                    SeparatorPlace::Back => format!(\" {}{}\", op_str.trim_right(), indent_str),\n+                    SeparatorPlace::Front => format!(\"{}{} \", indent_str, op_str.trim_left()),\n+                }\n+            };\n+\n+            return wrap_str(rewrites.join(&sep_str), context.config.max_width(), shape);\n+        }\n+    }\n+\n+    None\n+}\n+\n #[derive(new, Clone, Copy)]\n pub struct PairParts<'a> {\n     prefix: &'a str,"}]}