{"sha": "a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "node_id": "C_kwDOAAsO6NoAKGE5N2MzNmRkMmU2ZjcxMTk0OWZjOWI3OTA0NzZlOTNiZDllNmQxZjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-07T17:38:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-07T17:38:57Z"}, "message": "Auto merge of #109005 - Nilstrieb:dont-forgor-too-much-from-cfg, r=petrochenkov\n\nRemember names of `cfg`-ed out items to mention them in diagnostics\n\n# Examples\n\n## `serde::Deserialize` without the `derive` feature (a classic beginner mistake)\n\nI had to slightly modify serde so that it uses explicit re-exports instead of a glob re-export. (Update: a serde PR was merged that adds the manual re-exports)\n\n```\nerror[E0433]: failed to resolve: could not find `Serialize` in `serde`\n   --> src/main.rs:1:17\n    |\n1   | #[derive(serde::Serialize)]\n    |                 ^^^^^^^^^ could not find `Serialize` in `serde`\n    |\nnote: crate `serde` has an item named `Serialize` but it is inactive because its cfg predicate evaluated to false\n   --> /home/gh-Nilstrieb/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.160/src/lib.rs:343:1\n    |\n343 | #[cfg(feature = \"serde_derive\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n344 | pub use serde_derive::{Deserialize, Serialize};\n    |                                     ^^^^^^^^^\n    = note: the item is gated behind the `serde_derive` feature\n    = note: see https://doc.rust-lang.org/cargo/reference/features.html for how to activate a crate's feature\n```\n(the suggestion is not ideal but that's serde's fault)\n\nI already tested the metadata size impact locally by compiling the `windows` crate without any features. `800k`  -> `809k`\n\nr? `@ghost`", "tree": {"sha": "396855263c5ba620f0e10489717dbfd2f09febb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/396855263c5ba620f0e10489717dbfd2f09febb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "html_url": "https://github.com/rust-lang/rust/commit/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79", "html_url": "https://github.com/rust-lang/rust/commit/b2807b2bf3be9fbed9a0aadc97841c20a1ab5f79"}, {"sha": "a647ba250a65b44574830cb71aab5c0403adf31b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a647ba250a65b44574830cb71aab5c0403adf31b", "html_url": "https://github.com/rust-lang/rust/commit/a647ba250a65b44574830cb71aab5c0403adf31b"}], "stats": {"total": 683, "additions": 599, "deletions": 84}, "files": [{"sha": "942347383ce312c775f68e2097882ce850c56afa", "filename": "compiler/rustc_ast/src/expand/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -1,3 +1,20 @@\n //! Definitions shared by macros / syntax extensions and e.g. `rustc_middle`.\n \n+use rustc_span::{def_id::DefId, symbol::Ident};\n+\n+use crate::MetaItem;\n+\n pub mod allocator;\n+\n+#[derive(Debug, Clone, Encodable, Decodable, HashStable_Generic)]\n+pub struct StrippedCfgItem<ModId = DefId> {\n+    pub parent_module: ModId,\n+    pub name: Ident,\n+    pub cfg: MetaItem,\n+}\n+\n+impl<ModId> StrippedCfgItem<ModId> {\n+    pub fn map_mod_id<New>(self, f: impl FnOnce(ModId) -> New) -> StrippedCfgItem<New> {\n+        StrippedCfgItem { parent_module: f(self.parent_module), name: self.name, cfg: self.cfg }\n+    }\n+}"}, {"sha": "b7c30841983d702bc50e5bfb96c240a397b3a4a6", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -947,6 +947,8 @@ pub trait ResolverExpand {\n     /// HIR proc macros items back to their harness items.\n     fn declare_proc_macro(&mut self, id: NodeId);\n \n+    fn append_stripped_cfg_item(&mut self, parent_node: NodeId, name: Ident, cfg: ast::MetaItem);\n+\n     /// Tools registered with `#![register_tool]` and used by tool attributes and lints.\n     fn registered_tools(&self) -> &RegisteredTools;\n }\n@@ -965,7 +967,7 @@ pub trait LintStoreExpand {\n \n type LintStoreExpandDyn<'a> = Option<&'a (dyn LintStoreExpand + 'a)>;\n \n-#[derive(Clone, Default)]\n+#[derive(Debug, Clone, Default)]\n pub struct ModuleData {\n     /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n     pub mod_path: Vec<Ident>,"}, {"sha": "690f80f6876e46a51bab35b2b7cb41af195149c4", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -416,20 +416,28 @@ impl<'a> StripUnconfigured<'a> {\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n     fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n-        attrs.iter().all(|attr| !is_cfg(attr) || self.cfg_true(attr))\n+        attrs.iter().all(|attr| !is_cfg(attr) || self.cfg_true(attr).0)\n     }\n \n-    pub(crate) fn cfg_true(&self, attr: &Attribute) -> bool {\n+    pub(crate) fn cfg_true(&self, attr: &Attribute) -> (bool, Option<MetaItem>) {\n         let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n             Ok(meta_item) => meta_item,\n             Err(mut err) => {\n                 err.emit();\n-                return true;\n+                return (true, None);\n             }\n         };\n-        parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n-            attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.lint_node_id, self.features)\n-        })\n+        (\n+            parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n+                attr::cfg_matches(\n+                    &meta_item,\n+                    &self.sess.parse_sess,\n+                    self.lint_node_id,\n+                    self.features,\n+                )\n+            }),\n+            Some(meta_item),\n+        )\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`"}, {"sha": "dd8863df1953c2a0098bcd508ade263f72777b5e", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -1042,6 +1042,12 @@ trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     fn expand_cfg_false(&mut self, collector: &mut InvocationCollector<'_, '_>, span: Span) {\n         collector.cx.emit_err(RemoveNodeNotSupported { span, descr: Self::descr() });\n     }\n+\n+    /// All of the names (items) declared by this node.\n+    /// This is an approximation and should only be used for diagnostics.\n+    fn declared_names(&self) -> Vec<Ident> {\n+        vec![]\n+    }\n }\n \n impl InvocationCollectorNode for P<ast::Item> {\n@@ -1148,6 +1154,27 @@ impl InvocationCollectorNode for P<ast::Item> {\n         collector.cx.current_expansion.module = orig_module;\n         res\n     }\n+    fn declared_names(&self) -> Vec<Ident> {\n+        if let ItemKind::Use(ut) = &self.kind {\n+            fn collect_use_tree_leaves(ut: &ast::UseTree, idents: &mut Vec<Ident>) {\n+                match &ut.kind {\n+                    ast::UseTreeKind::Glob => {}\n+                    ast::UseTreeKind::Simple(_) => idents.push(ut.ident()),\n+                    ast::UseTreeKind::Nested(nested) => {\n+                        for (ut, _) in nested {\n+                            collect_use_tree_leaves(&ut, idents);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let mut idents = Vec::new();\n+            collect_use_tree_leaves(&ut, &mut idents);\n+            return idents;\n+        }\n+\n+        vec![self.ident]\n+    }\n }\n \n struct TraitItemTag;\n@@ -1685,16 +1712,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         node: &mut impl HasAttrs,\n         attr: ast::Attribute,\n         pos: usize,\n-    ) -> bool {\n-        let res = self.cfg().cfg_true(&attr);\n+    ) -> (bool, Option<ast::MetaItem>) {\n+        let (res, meta_item) = self.cfg().cfg_true(&attr);\n         if res {\n             // FIXME: `cfg(TRUE)` attributes do not currently remove themselves during expansion,\n             // and some tools like rustdoc and clippy rely on that. Find a way to remove them\n             // while keeping the tools working.\n             self.cx.expanded_inert_attrs.mark(&attr);\n             node.visit_attrs(|attrs| attrs.insert(pos, attr));\n         }\n-        res\n+\n+        (res, meta_item)\n     }\n \n     fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: &ast::Attribute, pos: usize) {\n@@ -1715,9 +1743,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             return match self.take_first_attr(&mut node) {\n                 Some((attr, pos, derives)) => match attr.name_or_empty() {\n                     sym::cfg => {\n-                        if self.expand_cfg_true(&mut node, attr, pos) {\n+                        let (res, meta_item) = self.expand_cfg_true(&mut node, attr, pos);\n+                        if res {\n                             continue;\n                         }\n+\n+                        if let Some(meta_item) = meta_item {\n+                            for name in node.declared_names() {\n+                                self.cx.resolver.append_stripped_cfg_item(\n+                                    self.cx.current_expansion.lint_node_id,\n+                                    name,\n+                                    meta_item.clone(),\n+                                )\n+                            }\n+                        }\n                         Default::default()\n                     }\n                     sym::cfg_attr => {\n@@ -1761,7 +1800,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 Some((attr, pos, derives)) => match attr.name_or_empty() {\n                     sym::cfg => {\n                         let span = attr.span;\n-                        if self.expand_cfg_true(node, attr, pos) {\n+                        if self.expand_cfg_true(node, attr, pos).0 {\n                             continue;\n                         }\n "}, {"sha": "21cbab542933c8c5284f244057c28299e45b55ed", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -995,6 +995,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n+    fn get_stripped_cfg_items(self, cnum: CrateNum, tcx: TyCtxt<'tcx>) -> &'tcx [StrippedCfgItem] {\n+        let item_names = self\n+            .root\n+            .stripped_cfg_items\n+            .decode((self, tcx))\n+            .map(|item| item.map_mod_id(|index| DefId { krate: cnum, index }));\n+        tcx.arena.alloc_from_iter(item_names)\n+    }\n+\n     /// Iterates over the diagnostic items in the given crate.\n     fn get_diagnostic_items(self) -> DiagnosticItems {\n         let mut id_to_name = FxHashMap::default();"}, {"sha": "77f9fcfc5e6b446c9c509ce520ffa927030825da", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -345,6 +345,7 @@ provide! { tcx, def_id, other, cdata,\n     stability_implications => {\n         cdata.get_stability_implications(tcx).iter().copied().collect()\n     }\n+    stripped_cfg_items => { cdata.get_stripped_cfg_items(cdata.cnum, tcx) }\n     is_intrinsic => { cdata.get_is_intrinsic(def_id.index) }\n     defined_lang_items => { cdata.get_lang_items(tcx) }\n     diagnostic_items => { cdata.get_diagnostic_items() }"}, {"sha": "9c3b8780d97aafc6c4d529f0ace72e41fc9b9ab0", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::expand::StrippedCfgItem;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -584,6 +585,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             (self.encode_lang_items(), self.encode_lang_items_missing())\n         });\n \n+        let stripped_cfg_items = stat!(\"stripped-cfg-items\", || self.encode_stripped_cfg_items());\n+\n         let diagnostic_items = stat!(\"diagnostic-items\", || self.encode_diagnostic_items());\n \n         let native_libraries = stat!(\"native-libs\", || self.encode_native_libraries());\n@@ -694,6 +697,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 lang_items,\n                 diagnostic_items,\n                 lang_items_missing,\n+                stripped_cfg_items,\n                 native_libraries,\n                 foreign_modules,\n                 source_map,\n@@ -1939,6 +1943,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_array(&tcx.lang_items().missing)\n     }\n \n+    fn encode_stripped_cfg_items(&mut self) -> LazyArray<StrippedCfgItem<DefIndex>> {\n+        self.lazy_array(\n+            self.tcx\n+                .stripped_cfg_items(LOCAL_CRATE)\n+                .into_iter()\n+                .map(|item| item.clone().map_mod_id(|def_id| def_id.index)),\n+        )\n+    }\n+\n     fn encode_traits(&mut self) -> LazyArray<DefIndex> {\n         empty_proc_macro!(self);\n         self.lazy_array(self.tcx.traits(LOCAL_CRATE).iter().map(|def_id| def_id.index))"}, {"sha": "66048f3ece747e77f845bcb07362a38a49ecf1fe", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::middle::debugger_visualizer::DebuggerVisualizerFile;\n use table::TableBuilder;\n \n use rustc_ast as ast;\n+use rustc_ast::expand::StrippedCfgItem;\n use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n@@ -256,6 +257,7 @@ pub(crate) struct CrateRoot {\n     stability_implications: LazyArray<(Symbol, Symbol)>,\n     lang_items: LazyArray<(DefIndex, LangItem)>,\n     lang_items_missing: LazyArray<LangItem>,\n+    stripped_cfg_items: LazyArray<StrippedCfgItem<DefIndex>>,\n     diagnostic_items: LazyArray<(Symbol, DefIndex)>,\n     native_libraries: LazyArray<NativeLib>,\n     foreign_modules: LazyArray<ForeignModule>,"}, {"sha": "6c404fbb7c684af49947ad71717b9130b86cafe4", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -124,6 +124,7 @@ macro_rules! arena_types {\n             [] predefined_opaques_in_body: rustc_middle::traits::solve::PredefinedOpaquesData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n+            [] stripped_cfg_items: rustc_ast::expand::StrippedCfgItem,\n             [] mod_child: rustc_middle::metadata::ModChild,\n         ]);\n     )"}, {"sha": "a6c8d41e925f15772772269112ac6e874064fbad", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -54,7 +54,7 @@ use crate::ty::{\n };\n use rustc_arena::TypedArena;\n use rustc_ast as ast;\n-use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_ast::expand::{allocator::AllocatorKind, StrippedCfgItem};\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap, FxIndexSet};\n@@ -2174,6 +2174,15 @@ rustc_queries! {\n     query check_tys_might_be_eq(arg: Canonical<'tcx, (ty::ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>) -> Result<(), NoSolution> {\n         desc { \"check whether two const param are definitely not equal to eachother\"}\n     }\n+\n+    /// Get all item paths that were stripped by a `#[cfg]` in a particular crate.\n+    /// Should not be called for the local crate before the resolver outputs are created, as it\n+    /// is only fed there.\n+    query stripped_cfg_items(cnum: CrateNum) -> &'tcx [StrippedCfgItem] {\n+        feedable\n+        desc { \"getting cfg-ed out item names\" }\n+        separate_provide_extern\n+    }\n }\n \n rustc_query_append! { define_callbacks! }"}, {"sha": "13be15269f4c201143a874a7355e67d28c830677", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -73,6 +73,7 @@ trivially_parameterized_over_tcx! {\n     ty::fast_reject::SimplifiedType,\n     rustc_ast::Attribute,\n     rustc_ast::DelimArgs,\n+    rustc_ast::expand::StrippedCfgItem<rustc_hir::def_id::DefIndex>,\n     rustc_attr::ConstStability,\n     rustc_attr::DefaultBodyStability,\n     rustc_attr::Deprecation,"}, {"sha": "15c8a690530e7f995cd286e29fa7742c6a39a1d9", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -1,8 +1,10 @@\n use std::ptr;\n \n+use rustc_ast::expand::StrippedCfgItem;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_ID};\n+use rustc_ast::{MetaItemKind, NestedMetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n@@ -776,7 +778,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 .tcx\n                 .sess\n                 .create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span }),\n-            ResolutionError::FailedToResolve { label, suggestion } => {\n+            ResolutionError::FailedToResolve { last_segment, label, suggestion, module } => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0433, \"failed to resolve: {}\", &label);\n                 err.span_label(span, label);\n@@ -789,6 +791,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     err.multipart_suggestion(msg, suggestions, applicability);\n                 }\n \n+                if let Some(ModuleOrUniformRoot::Module(module)) = module\n+                    && let Some(module) = module.opt_def_id()\n+                    && let Some(last_segment) = last_segment\n+                {\n+                    self.find_cfg_stripped(&mut err, &last_segment, module);\n+                }\n+\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n@@ -971,9 +980,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             VisResolutionError::AncestorOnly(span) => {\n                 self.tcx.sess.create_err(errs::AncestorOnly(span))\n             }\n-            VisResolutionError::FailedToResolve(span, label, suggestion) => {\n-                self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n-            }\n+            VisResolutionError::FailedToResolve(span, label, suggestion) => self.into_struct_error(\n+                span,\n+                ResolutionError::FailedToResolve {\n+                    last_segment: None,\n+                    label,\n+                    suggestion,\n+                    module: None,\n+                },\n+            ),\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n                 self.tcx.sess.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n@@ -1721,10 +1736,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n         ignore_binding: Option<&'a NameBinding<'a>>,\n         module: Option<ModuleOrUniformRoot<'a>>,\n-        i: usize,\n+        failed_segment_idx: usize,\n         ident: Ident,\n     ) -> (String, Option<Suggestion>) {\n-        let is_last = i == path.len() - 1;\n+        let is_last = failed_segment_idx == path.len() - 1;\n         let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n         let module_res = match module {\n             Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n@@ -1758,8 +1773,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 (format!(\"could not find `{ident}` in the crate root\"), None)\n             }\n-        } else if i > 0 {\n-            let parent = path[i - 1].ident.name;\n+        } else if failed_segment_idx > 0 {\n+            let parent = path[failed_segment_idx - 1].ident.name;\n             let parent = match parent {\n                 // ::foo is mounted at the crate root for 2015, and is the extern\n                 // prelude for 2018+\n@@ -2207,6 +2222,44 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             None\n         }\n     }\n+\n+    /// Finds a cfg-ed out item inside `module` with the matching name.\n+    pub(crate) fn find_cfg_stripped(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        last_segment: &Symbol,\n+        module: DefId,\n+    ) {\n+        let local_items;\n+        let symbols = if module.is_local() {\n+            local_items = self\n+                .stripped_cfg_items\n+                .iter()\n+                .filter_map(|item| {\n+                    let parent_module = self.opt_local_def_id(item.parent_module)?.to_def_id();\n+                    Some(StrippedCfgItem { parent_module, name: item.name, cfg: item.cfg.clone() })\n+                })\n+                .collect::<Vec<_>>();\n+            local_items.as_slice()\n+        } else {\n+            self.tcx.stripped_cfg_items(module.krate)\n+        };\n+\n+        for &StrippedCfgItem { parent_module, name, ref cfg } in symbols {\n+            if parent_module != module || name.name != *last_segment {\n+                continue;\n+            }\n+\n+            err.span_note(name.span, \"found an item that was configured out\");\n+\n+            if let MetaItemKind::List(nested) = &cfg.kind\n+                && let NestedMetaItem::MetaItem(meta_item) = &nested[0]\n+                && let MetaItemKind::NameValue(feature_name) = &meta_item.kind\n+            {\n+                err.note(format!(\"the item is gated behind the `{}` feature\", feature_name.symbol));\n+            }\n+        }\n+    }\n }\n \n /// Given a `binding_span` of a binding within a use statement:"}, {"sha": "e88cbb955b556d938231c7e47045615e1f31800c", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -330,6 +330,7 @@ pub(crate) struct ParamInTyOfConstParam {\n     pub(crate) param_kind: Option<ParamKindInTyOfConstParam>,\n }\n \n+#[derive(Debug)]\n #[derive(Subdiagnostic)]\n pub(crate) enum ParamKindInTyOfConstParam {\n     #[note(resolve_type_param_in_ty_of_const_param)]\n@@ -365,6 +366,7 @@ pub(crate) struct ParamInNonTrivialAnonConst {\n #[help(resolve_param_in_non_trivial_anon_const_help)]\n pub(crate) struct ParamInNonTrivialAnonConstHelp;\n \n+#[derive(Debug)]\n #[derive(Subdiagnostic)]\n pub(crate) enum ParamKindInNonTrivialAnonConst {\n     #[note(resolve_type_param_in_non_trivial_anon_const)]\n@@ -562,6 +564,7 @@ pub(crate) struct CfgAccessibleUnsure {\n     pub(crate) span: Span,\n }\n \n+#[derive(Debug)]\n #[derive(Diagnostic)]\n #[diag(resolve_param_in_enum_discriminant)]\n pub(crate) struct ParamInEnumDiscriminant {\n@@ -573,6 +576,7 @@ pub(crate) struct ParamInEnumDiscriminant {\n     pub(crate) param_kind: ParamKindInEnumDiscriminant,\n }\n \n+#[derive(Debug)]\n #[derive(Subdiagnostic)]\n pub(crate) enum ParamKindInEnumDiscriminant {\n     #[note(resolve_type_param_in_enum_discriminant)]"}, {"sha": "ec0a8535e7180caba77ac3c0b9a1a228ec8995a3", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -1365,20 +1365,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n         ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        debug!(\n-            \"resolve_path(path={:?}, opt_ns={:?}, finalize={:?}) path_len: {}\",\n-            path,\n-            opt_ns,\n-            finalize,\n-            path.len()\n-        );\n-\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n-        for (i, &Segment { ident, id, .. }) in path.iter().enumerate() {\n-            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+        for (segment_idx, &Segment { ident, id, .. }) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?} {:?}\", segment_idx, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n                 if finalize.is_some() {\n                     if let Some(id) = id {\n@@ -1390,7 +1382,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             };\n \n-            let is_last = i + 1 == path.len();\n+            let is_last = segment_idx + 1 == path.len();\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n             let name = ident.name;\n \n@@ -1399,7 +1391,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if ns == TypeNS {\n                 if allow_super && name == kw::Super {\n                     let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                    let self_module = match i {\n+                    let self_module = match segment_idx {\n                         0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n                         _ => match module {\n                             Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n@@ -1414,11 +1406,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             continue;\n                         }\n                     }\n-                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                        (\"there are too many leading `super` keywords\".to_string(), None)\n-                    });\n+                    return PathResult::failed(\n+                        ident.span,\n+                        false,\n+                        finalize.is_some(),\n+                        module,\n+                        || (\"there are too many leading `super` keywords\".to_string(), None),\n+                    );\n                 }\n-                if i == 0 {\n+                if segment_idx == 0 {\n                     if name == kw::SelfLower {\n                         let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                         module = Some(ModuleOrUniformRoot::Module(\n@@ -1447,14 +1443,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Report special messages for path segment keywords in wrong positions.\n-            if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+            if ident.is_path_segment_keyword() && segment_idx != 0 {\n+                return PathResult::failed(ident.span, false, finalize.is_some(), module, || {\n                     let name_str = if name == kw::PathRoot {\n                         \"crate root\".to_string()\n                     } else {\n                         format!(\"`{}`\", name)\n                     };\n-                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n+                    let label = if segment_idx == 1 && path[0].ident.name == kw::PathRoot {\n                         format!(\"global paths cannot start with {}\", name_str)\n                     } else {\n                         format!(\"{} in paths can only be used in start position\", name_str)\n@@ -1519,7 +1515,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             };\n             match binding {\n                 Ok(binding) => {\n-                    if i == 1 {\n+                    if segment_idx == 1 {\n                         second_binding = Some(binding);\n                     }\n                     let res = binding.res();\n@@ -1543,17 +1539,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         record_segment_res(self, res);\n                         return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res,\n-                            path.len() - i - 1,\n+                            path.len() - segment_idx - 1,\n                         ));\n                     } else {\n-                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                            let label = format!(\n-                                \"`{ident}` is {} {}, not a module\",\n-                                res.article(),\n-                                res.descr()\n-                            );\n-                            (label, None)\n-                        });\n+                        return PathResult::failed(\n+                            ident.span,\n+                            is_last,\n+                            finalize.is_some(),\n+                            module,\n+                            || {\n+                                let label = format!(\n+                                    \"`{ident}` is {} {}, not a module\",\n+                                    res.article(),\n+                                    res.descr()\n+                                );\n+                                (label, None)\n+                            },\n+                        );\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -1562,23 +1564,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         if opt_ns.is_some() && !module.is_normal() {\n                             return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                                 module.res().unwrap(),\n-                                path.len() - i,\n+                                path.len() - segment_idx,\n                             ));\n                         }\n                     }\n \n-                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                        self.report_path_resolution_error(\n-                            path,\n-                            opt_ns,\n-                            parent_scope,\n-                            ribs,\n-                            ignore_binding,\n-                            module,\n-                            i,\n-                            ident,\n-                        )\n-                    });\n+                    return PathResult::failed(\n+                        ident.span,\n+                        is_last,\n+                        finalize.is_some(),\n+                        module,\n+                        || {\n+                            self.report_path_resolution_error(\n+                                path,\n+                                opt_ns,\n+                                parent_scope,\n+                                ribs,\n+                                ignore_binding,\n+                                module,\n+                                segment_idx,\n+                                ident,\n+                            )\n+                        },\n+                    );\n                 }\n             }\n         }"}, {"sha": "7f944fb574596f72ea4d6a77a609c2cd107e8e7e", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -803,14 +803,34 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 module\n             }\n-            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n+            PathResult::Failed {\n+                is_error_from_last_segment: false,\n+                span,\n+                label,\n+                suggestion,\n+                module,\n+            } => {\n                 if no_ambiguity {\n                     assert!(import.imported_module.get().is_none());\n-                    self.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n+                    self.report_error(\n+                        span,\n+                        ResolutionError::FailedToResolve {\n+                            last_segment: None,\n+                            label,\n+                            suggestion,\n+                            module,\n+                        },\n+                    );\n                 }\n                 return None;\n             }\n-            PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n+            PathResult::Failed {\n+                is_error_from_last_segment: true,\n+                span,\n+                label,\n+                suggestion,\n+                ..\n+            } => {\n                 if no_ambiguity {\n                     assert!(import.imported_module.get().is_none());\n                     let err = match self.make_path_suggestion("}, {"sha": "ddd75ea3b33e0f368f8bb467e92dd0b3c9dd79e0", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -3524,15 +3524,17 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     None\n                 };\n \n-                this.r.use_injections.push(UseError {\n+                let ue = UseError {\n                     err,\n                     candidates,\n                     def_id,\n                     instead,\n                     suggestion,\n                     path: path.into(),\n                     is_call: source.is_call(),\n-                });\n+                };\n+\n+                this.r.use_injections.push(ue);\n             }\n \n             PartialRes::new(Res::Err)\n@@ -3866,8 +3868,22 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                 PartialRes::new(module.res().unwrap())\n             }\n-            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                return Err(respan(span, ResolutionError::FailedToResolve { label, suggestion }));\n+            PathResult::Failed {\n+                is_error_from_last_segment: false,\n+                span,\n+                label,\n+                suggestion,\n+                module,\n+            } => {\n+                return Err(respan(\n+                    span,\n+                    ResolutionError::FailedToResolve {\n+                        last_segment: None,\n+                        label,\n+                        suggestion,\n+                        module,\n+                    },\n+                ));\n             }\n             PathResult::Module(..) | PathResult::Failed { .. } => return Ok(None),\n             PathResult::Indeterminate => bug!(\"indeterminate path result in resolve_qpath\"),"}, {"sha": "2f9759a668bbe95284c8669b6bd34bb4fbf7b01a", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -149,6 +149,7 @@ struct BaseError {\n     span_label: Option<(Span, &'static str)>,\n     could_be_expr: bool,\n     suggestion: Option<(Span, &'static str, String)>,\n+    module: Option<DefId>,\n }\n \n #[derive(Debug)]\n@@ -210,10 +211,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     _ => false,\n                 },\n                 suggestion: None,\n+                module: None,\n             }\n         } else {\n             let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str, suggestion) = if path.len() == 1 {\n+            let (mod_prefix, mod_str, module, suggestion) = if path.len() == 1 {\n                 debug!(?self.diagnostic_metadata.current_impl_items);\n                 debug!(?self.diagnostic_metadata.current_function);\n                 let suggestion = if self.current_trait_ref.is_none()\n@@ -247,26 +249,37 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 } else {\n                     None\n                 };\n-                (String::new(), \"this scope\".to_string(), suggestion)\n+                (String::new(), \"this scope\".to_string(), None, suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n                 if self.r.tcx.sess.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n-                    (String::new(), \"the list of imported crates\".to_string(), None)\n+                    (String::new(), \"the list of imported crates\".to_string(), None, None)\n                 } else {\n-                    (String::new(), \"the crate root\".to_string(), None)\n+                    (\n+                        String::new(),\n+                        \"the crate root\".to_string(),\n+                        Some(CRATE_DEF_ID.to_def_id()),\n+                        None,\n+                    )\n                 }\n             } else if path.len() == 2 && path[0].ident.name == kw::Crate {\n-                (String::new(), \"the crate root\".to_string(), None)\n+                (String::new(), \"the crate root\".to_string(), Some(CRATE_DEF_ID.to_def_id()), None)\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), None) {\n+                let mod_res = self.resolve_path(mod_path, Some(TypeNS), None);\n+                let mod_prefix = match mod_res {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n                     _ => None,\n-                }\n-                .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)), None)\n+                };\n+\n+                let module_did = mod_prefix.as_ref().and_then(Res::mod_def_id);\n+\n+                let mod_prefix =\n+                    mod_prefix.map_or_else(String::new, |res| (format!(\"{} \", res.descr())));\n+\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)), module_did, None)\n             };\n \n             let (fallback_label, suggestion) = if path_str == \"async\"\n@@ -300,6 +313,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 span_label: None,\n                 could_be_expr: false,\n                 suggestion,\n+                module,\n             }\n         }\n     }\n@@ -315,6 +329,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     ) -> (DiagnosticBuilder<'tcx, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n         debug!(?res, ?source);\n         let base_error = self.make_base_error(path, span, source, res);\n+\n         let code = source.error_code(res.is_some());\n         let mut err = self.r.tcx.sess.struct_span_err_with_code(\n             base_error.span,\n@@ -366,6 +381,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         }\n         self.err_code_special_cases(&mut err, source, path, span);\n \n+        if let Some(module) = base_error.module {\n+            self.r.find_cfg_stripped(&mut err, &path.last().unwrap().ident.name, module);\n+        }\n+\n         (err, candidates)\n     }\n "}, {"sha": "dd8d01e35e5de7411c5bc1c85b4774950abbc68f", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -25,6 +25,7 @@ use errors::{\n     ParamKindInEnumDiscriminant, ParamKindInNonTrivialAnonConst, ParamKindInTyOfConstParam,\n };\n use rustc_arena::{DroplessArena, TypedArena};\n+use rustc_ast::expand::StrippedCfgItem;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, attr, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n@@ -171,13 +172,15 @@ enum ImplTraitContext {\n     Universal(LocalDefId),\n }\n \n+#[derive(Debug)]\n struct BindingError {\n     name: Symbol,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n     could_be_path: bool,\n }\n \n+#[derive(Debug)]\n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n     GenericParamsFromOuterFunction(Res, HasGenericParams),\n@@ -207,7 +210,12 @@ enum ResolutionError<'a> {\n     /// Error E0431: `self` import can only appear in an import list with a non-empty prefix.\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// Error E0433: failed to resolve.\n-    FailedToResolve { label: String, suggestion: Option<Suggestion> },\n+    FailedToResolve {\n+        last_segment: Option<Symbol>,\n+        label: String,\n+        suggestion: Option<Suggestion>,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n+    },\n     /// Error E0434: can't capture dynamic environment in a fn item.\n     CannotCaptureDynamicEnvironmentInFnItem,\n     /// Error E0435: attempt to use a non-constant value in a constant.\n@@ -402,6 +410,7 @@ enum PathResult<'a> {\n         label: String,\n         suggestion: Option<Suggestion>,\n         is_error_from_last_segment: bool,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n     },\n }\n \n@@ -410,11 +419,12 @@ impl<'a> PathResult<'a> {\n         span: Span,\n         is_error_from_last_segment: bool,\n         finalize: bool,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n         label_and_suggestion: impl FnOnce() -> (String, Option<Suggestion>),\n     ) -> PathResult<'a> {\n         let (label, suggestion) =\n             if finalize { label_and_suggestion() } else { (String::new(), None) };\n-        PathResult::Failed { span, label, suggestion, is_error_from_last_segment }\n+        PathResult::Failed { span, label, suggestion, is_error_from_last_segment, module }\n     }\n }\n \n@@ -685,6 +695,7 @@ struct PrivacyError<'a> {\n     dedup_span: Span,\n }\n \n+#[derive(Debug)]\n struct UseError<'a> {\n     err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n     /// Candidates which user could `use` to access the missing type.\n@@ -1059,6 +1070,9 @@ pub struct Resolver<'a, 'tcx> {\n     /// Whether lifetime elision was successful.\n     lifetime_elision_allowed: FxHashSet<NodeId>,\n \n+    /// Names of items that were stripped out via cfg with their corresponding cfg meta item.\n+    stripped_cfg_items: Vec<StrippedCfgItem<NodeId>>,\n+\n     effective_visibilities: EffectiveVisibilities,\n     doc_link_resolutions: FxHashMap<LocalDefId, DocLinkResMap>,\n     doc_link_traits_in_scope: FxHashMap<LocalDefId, Vec<DefId>>,\n@@ -1353,6 +1367,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             proc_macros: Default::default(),\n             confused_type_with_std_module: Default::default(),\n             lifetime_elision_allowed: Default::default(),\n+            stripped_cfg_items: Default::default(),\n             effective_visibilities: Default::default(),\n             doc_link_resolutions: Default::default(),\n             doc_link_traits_in_scope: Default::default(),\n@@ -1410,6 +1425,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let effective_visibilities = self.effective_visibilities;\n+\n+        self.tcx.feed_local_crate().stripped_cfg_items(self.tcx.arena.alloc_from_iter(\n+            self.stripped_cfg_items.into_iter().filter_map(|item| {\n+                let parent_module = self.node_id_to_def_id.get(&item.parent_module)?.to_def_id();\n+                Some(StrippedCfgItem { parent_module, name: item.name, cfg: item.cfg })\n+            }),\n+        ));\n+\n         let global_ctxt = ResolverGlobalCtxt {\n             expn_that_defined,\n             visibilities,"}, {"sha": "805c804e5759ffc8d840b8197a9e62f767b5bff6", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -6,6 +6,7 @@ use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n+use rustc_ast::expand::StrippedCfgItem;\n use rustc_ast::{self as ast, attr, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n@@ -465,6 +466,10 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n         self.proc_macros.push(id)\n     }\n \n+    fn append_stripped_cfg_item(&mut self, parent_node: NodeId, name: Ident, cfg: ast::MetaItem) {\n+        self.stripped_cfg_items.push(StrippedCfgItem { parent_module: parent_node, name, cfg });\n+    }\n+\n     fn registered_tools(&self) -> &RegisteredTools {\n         &self.registered_tools\n     }\n@@ -721,7 +726,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n                 path_res @ (PathResult::NonModule(..) | PathResult::Failed { .. }) => {\n                     let mut suggestion = None;\n-                    let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n+                    let (span, label, module) = if let PathResult::Failed { span, label, module, .. } = path_res {\n                         // try to suggest if it's not a macro, maybe a function\n                         if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n                             && partial_res.unresolved_segments() == 0 {\n@@ -733,7 +738,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect\n                                 ));\n                         }\n-                        (span, label)\n+                        (span, label, module)\n                     } else {\n                         (\n                             path_span,\n@@ -742,11 +747,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 kind.article(),\n                                 kind.descr()\n                             ),\n+                            None,\n                         )\n                     };\n                     self.report_error(\n                         span,\n-                        ResolutionError::FailedToResolve { label, suggestion },\n+                        ResolutionError::FailedToResolve { last_segment: path.last().map(|segment| segment.ident.name), label, suggestion, module },\n                     );\n                 }\n                 PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),"}, {"sha": "f6a9089cf29ded2b651e1df61b75779b7d48522a", "filename": "tests/ui/cfg/auxiliary/cfged_out.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfged_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfged_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fauxiliary%2Fcfged_out.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,22 @@\n+pub mod inner {\n+    #[cfg(FALSE)]\n+    pub fn uwu() {}\n+\n+    #[cfg(FALSE)]\n+    pub mod doesnt_exist {\n+        pub fn hello() {}\n+    }\n+\n+    pub mod wrong {\n+        #[cfg(feature = \"suggesting me fails the test!!\")]\n+        pub fn meow() {}\n+    }\n+\n+    pub mod right {\n+        #[cfg(feature = \"what-a-cool-feature\")]\n+        pub fn meow() {}\n+    }\n+}\n+\n+#[cfg(i_dont_exist_and_you_can_do_nothing_about_it)]\n+pub fn vanished() {}"}, {"sha": "d2725c94b083b6e019834bf86516012d27f3dfcc", "filename": "tests/ui/cfg/diagnostics-cross-crate.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,31 @@\n+// aux-build:cfged_out.rs\n+\n+extern crate cfged_out;\n+\n+fn main() {\n+    // There is no uwu at this path - no diagnostic.\n+    cfged_out::uwu(); //~ ERROR cannot find function\n+    //~^ NOTE not found in `cfged_out`\n+\n+    // It does exist here - diagnostic.\n+    cfged_out::inner::uwu(); //~ ERROR cannot find function\n+    //~^ NOTE found an item that was configured out\n+    //~| NOTE not found in `cfged_out::inner`\n+\n+    // The module isn't found - we would like to get a diagnostic, but currently don't due to\n+    // the awkward way the resolver diagnostics are currently implemented.\n+    // FIXME(Nilstrieb): Also add a note to the cfg diagnostic here\n+    cfged_out::inner::doesnt_exist::hello(); //~ ERROR failed to resolve\n+    //~^ NOTE could not find `doesnt_exist` in `inner`\n+\n+    // It should find the one in the right module, not the wrong one.\n+    cfged_out::inner::right::meow(); //~ ERROR cannot find function\n+    //~^ NOTE found an item that was configured out\n+    //~| NOTE not found in `cfged_out::inner::right\n+    //~| NOTE the item is gated behind the `what-a-cool-feature` feature\n+\n+    // Exists in the crate root - diagnostic.\n+    cfged_out::vanished(); //~ ERROR cannot find function\n+    //~^ NOTE found an item that was configured out\n+    //~| NOTE not found in `cfged_out`\n+}"}, {"sha": "046929bc260239317b550b2cb73e57504204cfad", "filename": "tests/ui/cfg/diagnostics-cross-crate.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-cross-crate.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,53 @@\n+error[E0433]: failed to resolve: could not find `doesnt_exist` in `inner`\n+  --> $DIR/diagnostics-cross-crate.rs:18:23\n+   |\n+LL |     cfged_out::inner::doesnt_exist::hello();\n+   |                       ^^^^^^^^^^^^ could not find `doesnt_exist` in `inner`\n+\n+error[E0425]: cannot find function `uwu` in crate `cfged_out`\n+  --> $DIR/diagnostics-cross-crate.rs:7:16\n+   |\n+LL |     cfged_out::uwu();\n+   |                ^^^ not found in `cfged_out`\n+\n+error[E0425]: cannot find function `uwu` in module `cfged_out::inner`\n+  --> $DIR/diagnostics-cross-crate.rs:11:23\n+   |\n+LL |     cfged_out::inner::uwu();\n+   |                       ^^^ not found in `cfged_out::inner`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/auxiliary/cfged_out.rs:3:12\n+   |\n+LL |     pub fn uwu() {}\n+   |            ^^^\n+\n+error[E0425]: cannot find function `meow` in module `cfged_out::inner::right`\n+  --> $DIR/diagnostics-cross-crate.rs:22:30\n+   |\n+LL |     cfged_out::inner::right::meow();\n+   |                              ^^^^ not found in `cfged_out::inner::right`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/auxiliary/cfged_out.rs:17:16\n+   |\n+LL |         pub fn meow() {}\n+   |                ^^^^\n+   = note: the item is gated behind the `what-a-cool-feature` feature\n+\n+error[E0425]: cannot find function `vanished` in crate `cfged_out`\n+  --> $DIR/diagnostics-cross-crate.rs:28:16\n+   |\n+LL |     cfged_out::vanished();\n+   |                ^^^^^^^^ not found in `cfged_out`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/auxiliary/cfged_out.rs:22:8\n+   |\n+LL | pub fn vanished() {}\n+   |        ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0425, E0433.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "72939471226754c89fc39be7a9392750ae1eae78", "filename": "tests/ui/cfg/diagnostics-not-a-def.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,12 @@\n+pub mod inner {\n+    pub fn i_am_here() {\n+        #[cfg(feature = \"another one that doesn't exist\")]\n+        loop {}\n+    }\n+}\n+\n+fn main() {\n+    inner::i_am_here();\n+    // ensure that nothing bad happens when we are checking for cfgs\n+    inner::i_am_not(); //~ ERROR cannot find function\n+}"}, {"sha": "af0e1a1727579e44a1a53fe1177766cb8bd257a1", "filename": "tests/ui/cfg/diagnostics-not-a-def.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-not-a-def.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find function `i_am_not` in module `inner`\n+  --> $DIR/diagnostics-not-a-def.rs:11:12\n+   |\n+LL |     inner::i_am_not();\n+   |            ^^^^^^^^ not found in `inner`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "1d43d6ba02f565abf0a87c3e8dae56ca00f9a924", "filename": "tests/ui/cfg/diagnostics-reexport.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,16 @@\n+pub mod inner {\n+    #[cfg(FALSE)]\n+    mod gone {\n+        pub fn uwu() {}\n+    }\n+\n+    #[cfg(FALSE)]\n+    pub use super::uwu;\n+    //~^ NOTE found an item that was configured out\n+}\n+\n+fn main() {\n+    // There is no uwu at this path - no diagnostic.\n+    inner::uwu(); //~ ERROR cannot find function\n+    //~^ NOTE not found in `inner`\n+}"}, {"sha": "6c977cbfa4172d2ef5ac58dab927e4ef11684868", "filename": "tests/ui/cfg/diagnostics-reexport.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-reexport.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,15 @@\n+error[E0425]: cannot find function `uwu` in module `inner`\n+  --> $DIR/diagnostics-reexport.rs:14:12\n+   |\n+LL |     inner::uwu();\n+   |            ^^^ not found in `inner`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/diagnostics-reexport.rs:8:20\n+   |\n+LL |     pub use super::uwu;\n+   |                    ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "f76ace06a762d4d672aaf52b995e0663cc4f0aa6", "filename": "tests/ui/cfg/diagnostics-same-crate.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.rs?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,51 @@\n+pub mod inner {\n+    #[cfg(FALSE)]\n+    pub fn uwu() {}\n+    //~^ NOTE found an item that was configured out\n+\n+    #[cfg(FALSE)]\n+    pub mod doesnt_exist {\n+        pub fn hello() {}\n+    }\n+\n+    pub mod wrong {\n+        #[cfg(feature = \"suggesting me fails the test!!\")]\n+        pub fn meow() {}\n+    }\n+\n+    pub mod right {\n+        #[cfg(feature = \"what-a-cool-feature\")]\n+        pub fn meow() {}\n+        //~^ NOTE found an item that was configured out\n+    }\n+}\n+\n+#[cfg(i_dont_exist_and_you_can_do_nothing_about_it)]\n+pub fn vanished() {}\n+\n+fn main() {\n+    // There is no uwu at this path - no diagnostic.\n+    uwu(); //~ ERROR cannot find function\n+    //~^ NOTE not found in this scope\n+\n+    // It does exist here - diagnostic.\n+    inner::uwu(); //~ ERROR cannot find function\n+    //~| NOTE not found in `inner`\n+\n+    // The module isn't found - we would like to get a diagnostic, but currently don't due to\n+    // the awkward way the resolver diagnostics are currently implemented.\n+    // FIXME(Nilstrieb): Also add a note to the cfg diagnostic here\n+    inner::doesnt_exist::hello(); //~ ERROR failed to resolve\n+    //~| NOTE could not find `doesnt_exist` in `inner`\n+\n+    // It should find the one in the right module, not the wrong one.\n+    inner::right::meow(); //~ ERROR cannot find function\n+    //~| NOTE not found in `inner::right\n+    //~| NOTE the item is gated behind the `what-a-cool-feature` feature\n+\n+    // Exists in the crate root - we would generally want a diagnostic,\n+    // but currently don't have one.\n+    // Not that it matters much though, this is highly unlikely to confuse anyone.\n+    vanished(); //~ ERROR cannot find function\n+    //~^ NOTE not found in this scope\n+}"}, {"sha": "30ee6479bd26c4f9f1ed638aa293fd7936d4fa49", "filename": "tests/ui/cfg/diagnostics-same-crate.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcfg%2Fdiagnostics-same-crate.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -0,0 +1,47 @@\n+error[E0433]: failed to resolve: could not find `doesnt_exist` in `inner`\n+  --> $DIR/diagnostics-same-crate.rs:38:12\n+   |\n+LL |     inner::doesnt_exist::hello();\n+   |            ^^^^^^^^^^^^ could not find `doesnt_exist` in `inner`\n+\n+error[E0425]: cannot find function `uwu` in module `inner`\n+  --> $DIR/diagnostics-same-crate.rs:32:12\n+   |\n+LL |     inner::uwu();\n+   |            ^^^ not found in `inner`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/diagnostics-same-crate.rs:3:12\n+   |\n+LL |     pub fn uwu() {}\n+   |            ^^^\n+\n+error[E0425]: cannot find function `meow` in module `inner::right`\n+  --> $DIR/diagnostics-same-crate.rs:42:19\n+   |\n+LL |     inner::right::meow();\n+   |                   ^^^^ not found in `inner::right`\n+   |\n+note: found an item that was configured out\n+  --> $DIR/diagnostics-same-crate.rs:18:16\n+   |\n+LL |         pub fn meow() {}\n+   |                ^^^^\n+   = note: the item is gated behind the `what-a-cool-feature` feature\n+\n+error[E0425]: cannot find function `uwu` in this scope\n+  --> $DIR/diagnostics-same-crate.rs:28:5\n+   |\n+LL |     uwu();\n+   |     ^^^ not found in this scope\n+\n+error[E0425]: cannot find function `vanished` in this scope\n+  --> $DIR/diagnostics-same-crate.rs:49:5\n+   |\n+LL |     vanished();\n+   |     ^^^^^^^^ not found in this scope\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0425, E0433.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "004a39043b778fbd57db8663770d292d14de6ec7", "filename": "tests/ui/macros/builtin-std-paths-fail.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fbuiltin-std-paths-fail.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -93,6 +93,9 @@ error[E0433]: failed to resolve: could not find `test` in `std`\n    |\n LL | #[std::test]\n    |        ^^^^ could not find `test` in `std`\n+   |\n+note: found an item that was configured out\n+  --> $SRC_DIR/std/src/lib.rs:LL:COL\n \n error: aborting due to 16 previous errors\n "}, {"sha": "0418e6116041b190b3077f78c80b8648ea96571a", "filename": "tests/ui/macros/macro-outer-attributes.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fmacros%2Fmacro-outer-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a97c36dd2e6f711949fc9b790476e93bd9e6d1f4/tests%2Fui%2Fmacros%2Fmacro-outer-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fmacro-outer-attributes.stderr?ref=a97c36dd2e6f711949fc9b790476e93bd9e6d1f4", "patch": "@@ -4,6 +4,11 @@ error[E0425]: cannot find function `bar` in module `a`\n LL |     a::bar();\n    |        ^^^ not found in `a`\n    |\n+note: found an item that was configured out\n+  --> $DIR/macro-outer-attributes.rs:9:14\n+   |\n+LL |       pub fn bar() { });\n+   |              ^^^\n help: consider importing this function\n    |\n LL + use b::bar;"}]}