{"sha": "a61691026a169a17f62de9de6ebab197faa7c703", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTY5MTAyNmExNjlhMTdmNjJkZTlkZTZlYmFiMTk3ZmFhN2M3MDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-19T17:46:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-19T17:53:23Z"}, "message": "Make ast editing more ergonomic\n\nchangelog internal", "tree": {"sha": "f6eb960ed1787c4f5db128f339ebb201aabf34c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6eb960ed1787c4f5db128f339ebb201aabf34c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a61691026a169a17f62de9de6ebab197faa7c703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a61691026a169a17f62de9de6ebab197faa7c703", "html_url": "https://github.com/rust-lang/rust/commit/a61691026a169a17f62de9de6ebab197faa7c703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a61691026a169a17f62de9de6ebab197faa7c703/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc8e2fea98aecbba0c587e5999b9e09533e0091c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8e2fea98aecbba0c587e5999b9e09533e0091c", "html_url": "https://github.com/rust-lang/rust/commit/dc8e2fea98aecbba0c587e5999b9e09533e0091c"}], "stats": {"total": 106, "additions": 66, "deletions": 40}, "files": [{"sha": "b1eed0a2ccabc3db8f0b97341f98eea050dc17ea", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a61691026a169a17f62de9de6ebab197faa7c703/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61691026a169a17f62de9de6ebab197faa7c703/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=a61691026a169a17f62de9de6ebab197faa7c703", "patch": "@@ -8,7 +8,7 @@ use parser::T;\n use crate::{\n     ast,\n     ted::{self, Position},\n-    AstNode, Direction, SyntaxElement,\n+    AstNode, Direction,\n };\n \n use super::NameOwner;\n@@ -21,11 +21,11 @@ impl GenericParamsOwnerEdit for ast::Fn {\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(ty) = self.ret_type() {\n-                Position::after(ty.syntax().clone())\n+                Position::after(ty.syntax())\n             } else if let Some(param_list) = self.param_list() {\n-                Position::after(param_list.syntax().clone())\n+                Position::after(param_list.syntax())\n             } else {\n-                Position::last_child_of(self.syntax().clone())\n+                Position::last_child_of(self.syntax())\n             };\n             create_where_clause(position)\n         }\n@@ -37,9 +37,9 @@ impl GenericParamsOwnerEdit for ast::Impl {\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n-                Position::before(items.syntax().clone())\n+                Position::before(items.syntax())\n             } else {\n-                Position::last_child_of(self.syntax().clone())\n+                Position::last_child_of(self.syntax())\n             };\n             create_where_clause(position)\n         }\n@@ -51,9 +51,9 @@ impl GenericParamsOwnerEdit for ast::Trait {\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n-                Position::before(items.syntax().clone())\n+                Position::before(items.syntax())\n             } else {\n-                Position::last_child_of(self.syntax().clone())\n+                Position::last_child_of(self.syntax())\n             };\n             create_where_clause(position)\n         }\n@@ -69,13 +69,13 @@ impl GenericParamsOwnerEdit for ast::Struct {\n                 ast::FieldList::TupleFieldList(it) => Some(it),\n             });\n             let position = if let Some(tfl) = tfl {\n-                Position::after(tfl.syntax().clone())\n+                Position::after(tfl.syntax())\n             } else if let Some(gpl) = self.generic_param_list() {\n-                Position::after(gpl.syntax().clone())\n+                Position::after(gpl.syntax())\n             } else if let Some(name) = self.name() {\n-                Position::after(name.syntax().clone())\n+                Position::after(name.syntax())\n             } else {\n-                Position::last_child_of(self.syntax().clone())\n+                Position::last_child_of(self.syntax())\n             };\n             create_where_clause(position)\n         }\n@@ -87,11 +87,11 @@ impl GenericParamsOwnerEdit for ast::Enum {\n     fn get_or_create_where_clause(&self) -> WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(gpl) = self.generic_param_list() {\n-                Position::after(gpl.syntax().clone())\n+                Position::after(gpl.syntax())\n             } else if let Some(name) = self.name() {\n-                Position::after(name.syntax().clone())\n+                Position::after(name.syntax())\n             } else {\n-                Position::last_child_of(self.syntax().clone())\n+                Position::last_child_of(self.syntax())\n             };\n             create_where_clause(position)\n         }\n@@ -100,19 +100,18 @@ impl GenericParamsOwnerEdit for ast::Enum {\n }\n \n fn create_where_clause(position: Position) {\n-    let where_clause: SyntaxElement =\n-        make::where_clause(empty()).clone_for_update().syntax().clone().into();\n-    ted::insert(position, where_clause);\n+    let where_clause = make::where_clause(empty()).clone_for_update();\n+    ted::insert(position, where_clause.syntax());\n }\n \n impl ast::WhereClause {\n     pub fn add_predicate(&self, predicate: ast::WherePred) {\n         if let Some(pred) = self.predicates().last() {\n             if !pred.syntax().siblings_with_tokens(Direction::Next).any(|it| it.kind() == T![,]) {\n-                ted::append_child_raw(self.syntax().clone(), make::token(T![,]));\n+                ted::append_child_raw(self.syntax(), make::token(T![,]));\n             }\n         }\n-        ted::append_child(self.syntax().clone(), predicate.syntax().clone())\n+        ted::append_child(self.syntax(), predicate.syntax())\n     }\n }\n \n@@ -123,7 +122,7 @@ impl ast::TypeBoundList {\n         {\n             ted::remove_all(colon..=self.syntax().clone().into())\n         } else {\n-            ted::remove(self.syntax().clone())\n+            ted::remove(self.syntax())\n         }\n     }\n }"}, {"sha": "be2b846b1513f5eb7dbba212eaed621c60932869", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a61691026a169a17f62de9de6ebab197faa7c703/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61691026a169a17f62de9de6ebab197faa7c703/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=a61691026a169a17f62de9de6ebab197faa7c703", "patch": "@@ -8,6 +8,33 @@ use parser::T;\n \n use crate::{ast::make, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken};\n \n+/// Utility trait to allow calling `ted` functions with references or owned\n+/// nodes. Do not use outside of this module.\n+pub trait Element {\n+    fn syntax_element(self) -> SyntaxElement;\n+}\n+\n+impl<E: Element + Clone> Element for &'_ E {\n+    fn syntax_element(self) -> SyntaxElement {\n+        self.clone().syntax_element()\n+    }\n+}\n+impl Element for SyntaxElement {\n+    fn syntax_element(self) -> SyntaxElement {\n+        self\n+    }\n+}\n+impl Element for SyntaxNode {\n+    fn syntax_element(self) -> SyntaxElement {\n+        self.into()\n+    }\n+}\n+impl Element for SyntaxToken {\n+    fn syntax_element(self) -> SyntaxElement {\n+        self.into()\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct Position {\n     repr: PositionRepr,\n@@ -20,24 +47,24 @@ enum PositionRepr {\n }\n \n impl Position {\n-    pub fn after(elem: impl Into<SyntaxElement>) -> Position {\n-        let repr = PositionRepr::After(elem.into());\n+    pub fn after(elem: impl Element) -> Position {\n+        let repr = PositionRepr::After(elem.syntax_element());\n         Position { repr }\n     }\n-    pub fn before(elem: impl Into<SyntaxElement>) -> Position {\n-        let elem = elem.into();\n+    pub fn before(elem: impl Element) -> Position {\n+        let elem = elem.syntax_element();\n         let repr = match elem.prev_sibling_or_token() {\n             Some(it) => PositionRepr::After(it),\n             None => PositionRepr::FirstChild(elem.parent().unwrap()),\n         };\n         Position { repr }\n     }\n-    pub fn first_child_of(node: impl Into<SyntaxNode>) -> Position {\n-        let repr = PositionRepr::FirstChild(node.into());\n+    pub fn first_child_of(node: &(impl Into<SyntaxNode> + Clone)) -> Position {\n+        let repr = PositionRepr::FirstChild(node.clone().into());\n         Position { repr }\n     }\n-    pub fn last_child_of(node: impl Into<SyntaxNode>) -> Position {\n-        let node = node.into();\n+    pub fn last_child_of(node: &(impl Into<SyntaxNode> + Clone)) -> Position {\n+        let node = node.clone().into();\n         let repr = match node.last_child_or_token() {\n             Some(it) => PositionRepr::After(it),\n             None => PositionRepr::FirstChild(node),\n@@ -46,11 +73,11 @@ impl Position {\n     }\n }\n \n-pub fn insert(position: Position, elem: impl Into<SyntaxElement>) {\n-    insert_all(position, vec![elem.into()])\n+pub fn insert(position: Position, elem: impl Element) {\n+    insert_all(position, vec![elem.syntax_element()])\n }\n-pub fn insert_raw(position: Position, elem: impl Into<SyntaxElement>) {\n-    insert_all_raw(position, vec![elem.into()])\n+pub fn insert_raw(position: Position, elem: impl Element) {\n+    insert_all_raw(position, vec![elem.syntax_element()])\n }\n pub fn insert_all(position: Position, mut elements: Vec<SyntaxElement>) {\n     if let Some(first) = elements.first() {\n@@ -73,17 +100,17 @@ pub fn insert_all_raw(position: Position, elements: Vec<SyntaxElement>) {\n     parent.splice_children(index..index, elements);\n }\n \n-pub fn remove(elem: impl Into<SyntaxElement>) {\n-    let elem = elem.into();\n+pub fn remove(elem: impl Element) {\n+    let elem = elem.syntax_element();\n     remove_all(elem.clone()..=elem)\n }\n pub fn remove_all(range: RangeInclusive<SyntaxElement>) {\n     replace_all(range, Vec::new())\n }\n \n-pub fn replace(old: impl Into<SyntaxElement>, new: impl Into<SyntaxElement>) {\n-    let old = old.into();\n-    replace_all(old.clone()..=old, vec![new.into()])\n+pub fn replace(old: impl Element, new: impl Element) {\n+    let old = old.syntax_element();\n+    replace_all(old.clone()..=old, vec![new.syntax_element()])\n }\n pub fn replace_all(range: RangeInclusive<SyntaxElement>, new: Vec<SyntaxElement>) {\n     let start = range.start().index();\n@@ -92,11 +119,11 @@ pub fn replace_all(range: RangeInclusive<SyntaxElement>, new: Vec<SyntaxElement>\n     parent.splice_children(start..end + 1, new)\n }\n \n-pub fn append_child(node: impl Into<SyntaxNode>, child: impl Into<SyntaxElement>) {\n+pub fn append_child(node: &(impl Into<SyntaxNode> + Clone), child: impl Element) {\n     let position = Position::last_child_of(node);\n     insert(position, child)\n }\n-pub fn append_child_raw(node: impl Into<SyntaxNode>, child: impl Into<SyntaxElement>) {\n+pub fn append_child_raw(node: &(impl Into<SyntaxNode> + Clone), child: impl Element) {\n     let position = Position::last_child_of(node);\n     insert_raw(position, child)\n }"}]}