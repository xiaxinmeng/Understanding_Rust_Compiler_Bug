{"sha": "3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOGI5NjE0ZDNhYWU2ZWY4YmQ4NzdlM2YwMjBmN2FjOGFkN2Y3ZTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-24T06:13:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-24T06:13:33Z"}, "message": "Rollup merge of #70074 - Centril:unpanictry, r=petrochenkov\n\nExpand: nix all fatal errors\n\nBasically, we go after all `.span_fatal` / `FatalError.raise()` and similar things and remove them one by one until there are no fatal errors left.\n\nr? @petrochenkov", "tree": {"sha": "628615bce56ac777f6908e6cf4c65d0e3d0ed213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/628615bce56ac777f6908e6cf4c65d0e3d0ed213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeaUNCRBK7hj4Ov3rIwAAdHIIAE/dJ3ZphigDi6cCps2RunPR\na6Wq/xbXSUmvobZ5jebYo64iQhFaUQvclV3ZnWENe2rJBRXAFpoI30MlUv3xodXz\nUzDp0/aFTU6E2TmpIgr02vbvPIxcQRrFHYGSYY7UJs6rCYSVXLvjd77MlSBxEvEC\nk0rUEFp8GiIJ8Oh12gLCvVccLkIHDguVRO7flZCe2JEQaXYPG31h2skw6ipNho7Z\n0W0AWTIIJBc6eeIUhb61jqKjTjanqZB65ROgwmP/W5s5BejD4WZBJusKiKWuCEto\nWA+NI1M6o276921tiL18OvJOn1CWRhQ+wtvzdlOaPCzV5P3VYyb07swDdKMVJkw=\n=8HVj\n-----END PGP SIGNATURE-----\n", "payload": "tree 628615bce56ac777f6908e6cf4c65d0e3d0ed213\nparent 0a39964ed23ebf17cc276c03317307e10445311a\nparent 470e16372fb5ff0f2c35948ada4d0fd832401cb4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585030413 +0100\ncommitter GitHub <noreply@github.com> 1585030413 +0100\n\nRollup merge of #70074 - Centril:unpanictry, r=petrochenkov\n\nExpand: nix all fatal errors\n\nBasically, we go after all `.span_fatal` / `FatalError.raise()` and similar things and remove them one by one until there are no fatal errors left.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "html_url": "https://github.com/rust-lang/rust/commit/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a39964ed23ebf17cc276c03317307e10445311a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a39964ed23ebf17cc276c03317307e10445311a", "html_url": "https://github.com/rust-lang/rust/commit/0a39964ed23ebf17cc276c03317307e10445311a"}, {"sha": "470e16372fb5ff0f2c35948ada4d0fd832401cb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/470e16372fb5ff0f2c35948ada4d0fd832401cb4", "html_url": "https://github.com/rust-lang/rust/commit/470e16372fb5ff0f2c35948ada4d0fd832401cb4"}], "stats": {"total": 858, "additions": 584, "deletions": 274}, "files": [{"sha": "093815dbbcd4f1c1dfb9821119f9a305fbdf2b48", "filename": "src/librustc_builtin_macros/cmdline_attrs.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcmdline_attrs.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -3,7 +3,6 @@\n use rustc_ast::ast::{self, AttrItem, AttrStyle};\n use rustc_ast::attr::mk_attr;\n use rustc_ast::token;\n-use rustc_expand::panictry;\n use rustc_session::parse::ParseSess;\n use rustc_span::FileName;\n \n@@ -16,7 +15,13 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, args } = panictry!(parser.parse_attr_item());\n+        let AttrItem { path, args } = match parser.parse_attr_item() {\n+            Ok(ai) => ai,\n+            Err(mut err) => {\n+                err.emit();\n+                continue;\n+            }\n+        };\n         let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic.span_err(start_span.to(end_span), \"invalid crate attribute\");"}, {"sha": "67145c6bf433be3c2c950ccfc6b5f6197ffd6891", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -5,7 +5,6 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n use rustc_expand::module::DirectoryOwnership;\n-use rustc_expand::panictry;\n use rustc_parse::{self, new_parser_from_file, parser::Parser};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n@@ -126,7 +125,7 @@ pub fn expand_include<'cx>(\n     }\n     impl<'a> base::MacResult for ExpandResult<'a> {\n         fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n-            let r = panictry!(self.p.parse_expr());\n+            let r = base::parse_expr(&mut self.p)?;\n             if self.p.token != token::Eof {\n                 self.p.sess.buffer_lint(\n                     &INCOMPLETE_INCLUDE,\n@@ -141,18 +140,17 @@ pub fn expand_include<'cx>(\n         fn make_items(mut self: Box<ExpandResult<'a>>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n             let mut ret = SmallVec::new();\n             while self.p.token != token::Eof {\n-                match panictry!(self.p.parse_item()) {\n-                    Some(item) => ret.push(item),\n-                    None => {\n+                match self.p.parse_item() {\n+                    Err(mut err) => {\n+                        err.emit();\n+                        break;\n+                    }\n+                    Ok(Some(item)) => ret.push(item),\n+                    Ok(None) => {\n                         let token = pprust::token_to_string(&self.p.token);\n-                        self.p\n-                            .sess\n-                            .span_diagnostic\n-                            .span_fatal(\n-                                self.p.token.span,\n-                                &format!(\"expected item, found `{}`\", token),\n-                            )\n-                            .raise();\n+                        let msg = format!(\"expected item, found `{}`\", token);\n+                        self.p.struct_span_err(self.p.token.span, &msg).emit();\n+                        break;\n                     }\n                 }\n             }"}, {"sha": "bdc4ae2fe274b9598ef2cca04a10e1b578714b11", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -74,16 +74,16 @@ pub fn expand_test_or_bench(\n         return vec![];\n     }\n \n-    let item = if let Annotatable::Item(i) = item {\n-        i\n-    } else {\n-        cx.parse_sess\n-            .span_diagnostic\n-            .span_fatal(\n-                item.span(),\n+    let item = match item {\n+        Annotatable::Item(i) => i,\n+        other => {\n+            cx.struct_span_err(\n+                other.span(),\n                 \"`#[test]` attribute is only allowed on non associated functions\",\n             )\n-            .raise();\n+            .emit();\n+            return vec![other];\n+        }\n     };\n \n     if let ast::ItemKind::MacCall(_) = item.kind {"}, {"sha": "160a5204eaf703d3352e6d6676ac4a3422d18e6b", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -345,14 +345,14 @@ fn is_test_case(i: &ast::Item) -> bool {\n \n fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n     let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n-    test_attr.meta_item_list().map(|meta_list| {\n-        if meta_list.len() != 1 {\n-            sd.span_fatal(test_attr.span, \"`#![test_runner(..)]` accepts exactly 1 argument\")\n-                .raise()\n-        }\n-        match meta_list[0].meta_item() {\n-            Some(meta_item) if meta_item.is_word() => meta_item.path.clone(),\n-            _ => sd.span_fatal(test_attr.span, \"`test_runner` argument must be a path\").raise(),\n-        }\n-    })\n+    let meta_list = test_attr.meta_item_list()?;\n+    let span = test_attr.span;\n+    match &*meta_list {\n+        [single] => match single.meta_item() {\n+            Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n+            _ => sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit(),\n+        },\n+        _ => sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit(),\n+    }\n+    None\n }"}, {"sha": "59c1a5468f100caf5771584f451cec1c3a4c9a75", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -10,7 +10,7 @@ use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n@@ -296,16 +296,26 @@ where\n }\n \n pub trait ProcMacro {\n-    fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt<'_>, span: Span, ts: TokenStream) -> TokenStream;\n+    fn expand<'cx>(\n+        &self,\n+        ecx: &'cx mut ExtCtxt<'_>,\n+        span: Span,\n+        ts: TokenStream,\n+    ) -> Result<TokenStream, ErrorReported>;\n }\n \n impl<F> ProcMacro for F\n where\n     F: Fn(TokenStream) -> TokenStream,\n {\n-    fn expand<'cx>(&self, _ecx: &'cx mut ExtCtxt<'_>, _span: Span, ts: TokenStream) -> TokenStream {\n+    fn expand<'cx>(\n+        &self,\n+        _ecx: &'cx mut ExtCtxt<'_>,\n+        _span: Span,\n+        ts: TokenStream,\n+    ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        (*self)(ts)\n+        Ok((*self)(ts))\n     }\n }\n \n@@ -316,7 +326,7 @@ pub trait AttrProcMacro {\n         span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream;\n+    ) -> Result<TokenStream, ErrorReported>;\n }\n \n impl<F> AttrProcMacro for F\n@@ -329,9 +339,9 @@ where\n         _span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         // FIXME setup implicit context in TLS before calling self.\n-        (*self)(annotation, annotated)\n+        Ok((*self)(annotation, annotated))\n     }\n }\n \n@@ -1004,31 +1014,9 @@ impl<'a> ExtCtxt<'a> {\n         self.current_expansion.id.expansion_cause()\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_warn(sp, msg)\n-    }\n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n         self.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_fatal(sp, msg)\n-    }\n-\n-    /// Emit `msg` attached to `sp`, and stop compilation immediately.\n-    ///\n-    /// `span_err` should be strongly preferred where-ever possible:\n-    /// this should *only* be used when:\n-    ///\n-    /// - continuing has a high risk of flow-on errors (e.g., errors in\n-    ///   declaring a macro would cause all uses of that macro to\n-    ///   complain about \"undefined macro\"), or\n-    /// - there is literally nothing else that can be done (however,\n-    ///   in most cases one can construct a dummy expression/item to\n-    ///   substitute; we never hit resolve/type-checking so the dummy\n-    ///   value doesn't have to match anything)\n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.span_fatal(sp, msg).raise();\n-    }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping\n     /// compilation.\n@@ -1038,9 +1026,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.parse_sess.span_diagnostic.span_err_with_code(sp, msg, code);\n-    }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n@@ -1168,6 +1153,18 @@ pub fn check_zero_tts(cx: &ExtCtxt<'_>, sp: Span, tts: TokenStream, name: &str)\n     }\n }\n \n+/// Parse an expression. On error, emit it, advancing to `Eof`, and return `None`.\n+pub fn parse_expr(p: &mut parser::Parser<'_>) -> Option<P<ast::Expr>> {\n+    match p.parse_expr() {\n+        Ok(e) => return Some(e),\n+        Err(mut err) => err.emit(),\n+    }\n+    while p.token != token::Eof {\n+        p.bump();\n+    }\n+    None\n+}\n+\n /// Interpreting `tts` as a comma-separated sequence of expressions,\n /// expect exactly one string literal, or emit an error and return `None`.\n pub fn get_single_str_from_tts(\n@@ -1181,7 +1178,7 @@ pub fn get_single_str_from_tts(\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None;\n     }\n-    let ret = panictry!(p.parse_expr());\n+    let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n@@ -1190,8 +1187,8 @@ pub fn get_single_str_from_tts(\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s.to_string())\n }\n \n-/// Extracts comma-separated expressions from `tts`. If there is a\n-/// parsing error, emit a non-fatal error and return `None`.\n+/// Extracts comma-separated expressions from `tts`.\n+/// On error, emit it, and return `None`.\n pub fn get_exprs_from_tts(\n     cx: &mut ExtCtxt<'_>,\n     sp: Span,\n@@ -1200,7 +1197,7 @@ pub fn get_exprs_from_tts(\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        let expr = panictry!(p.parse_expr());\n+        let expr = parse_expr(&mut p)?;\n \n         // Perform eager expansion on the expression.\n         // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`."}, {"sha": "51208906c2f2d97e221219e10ca1930a1b700adb", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -204,7 +204,7 @@ ast_fragments! {\n }\n \n impl AstFragmentKind {\n-    fn dummy(self, span: Span) -> AstFragment {\n+    crate fn dummy(self, span: Span) -> AstFragment {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n@@ -682,7 +682,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n+                    let tok_result = match expander.expand(self.cx, span, mac.args.inner_tokens()) {\n+                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n+                        Ok(ts) => ts,\n+                    };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n@@ -709,8 +712,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n-                    let tok_result =\n-                        expander.expand(self.cx, span, attr_item.args.inner_tokens(), tokens);\n+                    let inner_tokens = attr_item.args.inner_tokens();\n+                    let tok_result = match expander.expand(self.cx, span, inner_tokens, tokens) {\n+                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n+                        Ok(ts) => ts,\n+                    };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n@@ -1139,6 +1145,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             // macros are expanded before any lint passes so this warning has to be hardcoded\n             if attr.has_name(sym::derive) {\n                 self.cx\n+                    .parse_sess()\n+                    .span_diagnostic\n                     .struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n                     .note(\"this may become a hard error in a future release\")\n                     .emit();"}, {"sha": "876a26de3fb7e86c8fe355c585d6f8dd3490c840", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -9,25 +9,6 @@\n \n extern crate proc_macro as pm;\n \n-// A variant of 'try!' that panics on an Err. This is used as a crutch on the\n-// way towards a non-panic!-prone parser. It should be used for fatal parsing\n-// errors; eventually we plan to convert all code using panictry to just use\n-// normal try.\n-#[macro_export]\n-macro_rules! panictry {\n-    ($e:expr) => {{\n-        use rustc_errors::FatalError;\n-        use std::result::Result::{Err, Ok};\n-        match $e {\n-            Ok(e) => e,\n-            Err(mut e) => {\n-                e.emit();\n-                FatalError.raise()\n-            }\n-        }\n-    }};\n-}\n-\n mod placeholders;\n mod proc_macro_server;\n "}, {"sha": "e868b7e36aac5008d03236d7ab8012c30fb0dce5", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -84,7 +84,7 @@ use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n \n-use rustc_errors::{FatalError, PResult};\n+use rustc_errors::PResult;\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n@@ -271,6 +271,7 @@ crate enum ParseResult<T> {\n     Failure(Token, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n+    ErrorReported,\n }\n \n /// A `ParseResult` where the `Success` variant contains a mapping of\n@@ -652,6 +653,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             Success(_) => {}\n             Failure(token, msg) => return Failure(token, msg),\n             Error(sp, msg) => return Error(sp, msg),\n+            ErrorReported => return ErrorReported,\n         }\n \n         // inner parse loop handled all cur_items, so it's empty\n@@ -735,10 +737,11 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let mut item = bb_items.pop().unwrap();\n             if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                item.push_match(\n-                    match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(parser.to_mut(), span, ident.name))),\n-                );\n+                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n+                    Err(()) => return ErrorReported,\n+                    Ok(nt) => nt,\n+                };\n+                item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n                 item.idx += 1;\n                 item.match_cur += 1;\n             } else {\n@@ -849,20 +852,16 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n /// # Returns\n ///\n /// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n+fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n     // FIXME(Centril): Consider moving this to `parser.rs` to make\n     // the visibilities of the methods used below `pub(super)` at most.\n-\n     if name == sym::tt {\n-        return token::NtTT(p.parse_token_tree());\n-    }\n-    match parse_nt_inner(p, sp, name) {\n-        Ok(nt) => nt,\n-        Err(mut err) => {\n-            err.emit();\n-            FatalError.raise();\n-        }\n+        return Ok(token::NtTT(p.parse_token_tree()));\n     }\n+    parse_nt_inner(p, sp, name).map_err(|mut err| {\n+        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n+            .emit()\n+    })\n }\n \n fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {"}, {"sha": "859362b5e29d391cd269ff8fe344fd4d6c82d5a5", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 91, "deletions": 53, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -4,7 +4,7 @@ use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstF\n use crate::mbe;\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::parse_tt;\n-use crate::mbe::macro_parser::{Error, Failure, Success};\n+use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success};\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n@@ -15,7 +15,7 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, DiagnosticBuilder, FatalError};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n@@ -83,41 +83,56 @@ fn suggest_slice_pat(e: &mut DiagnosticBuilder<'_>, site_span: Span, parser: &Pa\n     );\n }\n \n+fn emit_frag_parse_err(\n+    mut e: DiagnosticBuilder<'_>,\n+    parser: &Parser<'_>,\n+    site_span: Span,\n+    macro_ident: ast::Ident,\n+    arm_span: Span,\n+    kind: AstFragmentKind,\n+) {\n+    if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n+        }\n+        let msg = &e.message[0];\n+        e.message[0] = (\n+            format!(\n+                \"macro expansion ends with an incomplete expression: {}\",\n+                msg.0.replace(\", found `<eof>`\", \"\"),\n+            ),\n+            msg.1,\n+        );\n+    }\n+    if e.span.is_dummy() {\n+        // Get around lack of span in error (#30128)\n+        e.replace_span_with(site_span);\n+        if !parser.sess.source_map().is_imported(arm_span) {\n+            e.span_label(arm_span, \"in this macro arm\");\n+        }\n+    } else if parser.sess.source_map().is_imported(parser.token.span) {\n+        e.span_label(site_span, \"in this macro invocation\");\n+    }\n+    match kind {\n+        AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n+            suggest_slice_pat(&mut e, site_span, parser);\n+        }\n+        _ => annotate_err_with_kind(&mut e, kind, site_span),\n+    };\n+    e.emit();\n+}\n+\n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n-        let fragment = panictry!(parse_ast_fragment(parser, kind).map_err(|mut e| {\n-            if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n-                if !e.span.is_dummy() {\n-                    // early end of macro arm (#52866)\n-                    e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n-                }\n-                let msg = &e.message[0];\n-                e.message[0] = (\n-                    format!(\n-                        \"macro expansion ends with an incomplete expression: {}\",\n-                        msg.0.replace(\", found `<eof>`\", \"\"),\n-                    ),\n-                    msg.1,\n-                );\n+        let fragment = match parse_ast_fragment(parser, kind) {\n+            Ok(f) => f,\n+            Err(err) => {\n+                emit_frag_parse_err(err, parser, site_span, macro_ident, arm_span, kind);\n+                return kind.dummy(site_span);\n             }\n-            if e.span.is_dummy() {\n-                // Get around lack of span in error (#30128)\n-                e.replace_span_with(site_span);\n-                if !parser.sess.source_map().is_imported(arm_span) {\n-                    e.span_label(arm_span, \"in this macro arm\");\n-                }\n-            } else if parser.sess.source_map().is_imported(parser.token.span) {\n-                e.span_label(site_span, \"in this macro invocation\");\n-            }\n-            match kind {\n-                AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n-                    suggest_slice_pat(&mut e, site_span, parser);\n-                }\n-                _ => annotate_err_with_kind(&mut e, kind, site_span),\n-            };\n-            e\n-        }));\n+        };\n \n         // We allow semicolons at the end of expressions -- e.g., the semicolon in\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n@@ -165,6 +180,14 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n+fn macro_rules_dummy_expander<'cx>(\n+    _: &'cx mut ExtCtxt<'_>,\n+    span: Span,\n+    _: TokenStream,\n+) -> Box<dyn MacResult + 'cx> {\n+    DummyResult::any(span)\n+}\n+\n fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n     cx_expansions.entry(sp).or_default().push(message);\n@@ -240,7 +263,13 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n+                let mut tts = match transcribe(cx, &named_matches, rhs, transparency) {\n+                    Ok(tts) => tts,\n+                    Err(mut err) => {\n+                        err.emit();\n+                        return DummyResult::any(arm_span);\n+                    }\n+                };\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -278,7 +307,12 @@ fn generic_extension<'cx>(\n                 Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n                 _ => best_failure = Some((token, msg)),\n             },\n-            Error(err_sp, ref msg) => cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]),\n+            Error(err_sp, ref msg) => {\n+                let span = err_sp.substitute_dummy(sp);\n+                cx.struct_span_err(span, &msg).emit();\n+                return DummyResult::any(span);\n+            }\n+            ErrorReported => return DummyResult::any(sp),\n         }\n \n         // The matcher was not `Success(..)`ful.\n@@ -337,6 +371,18 @@ pub fn compile_declarative_macro(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    let mk_syn_ext = |expander| {\n+        SyntaxExtension::new(\n+            sess,\n+            SyntaxExtensionKind::LegacyBang(expander),\n+            def.span,\n+            Vec::new(),\n+            edition,\n+            def.ident.name,\n+            &def.attrs,\n+        )\n+    };\n+\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = ast::Ident::new(sym::lhs, def.span);\n     let rhs_nm = ast::Ident::new(sym::rhs, def.span);\n@@ -391,13 +437,15 @@ pub fn compile_declarative_macro(\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n             let sp = token.span.substitute_dummy(def.span);\n-            let mut err = sess.span_diagnostic.struct_span_fatal(sp, &s);\n-            err.span_label(sp, msg);\n-            err.emit();\n-            FatalError.raise();\n+            sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+        }\n+        Error(sp, msg) => {\n+            sess.span_diagnostic.struct_span_err(sp.substitute_dummy(def.span), &msg).emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n-        Error(sp, s) => {\n-            sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &s).raise();\n+        ErrorReported => {\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n     };\n \n@@ -460,24 +508,14 @@ pub fn compile_declarative_macro(\n         None => {}\n     }\n \n-    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+    mk_syn_ext(Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         span: def.span,\n         transparency,\n         lhses,\n         rhses,\n         valid,\n-    });\n-\n-    SyntaxExtension::new(\n-        sess,\n-        SyntaxExtensionKind::LegacyBang(expander),\n-        def.span,\n-        Vec::new(),\n-        edition,\n-        def.ident.name,\n-        &def.attrs,\n-    )\n+    }))\n }\n \n fn check_lhs_nt_follows("}, {"sha": "e2d3d5c4d644e04076ac1fbb31ac672bdfa7f29e", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::pluralize;\n+use rustc_errors::{pluralize, PResult};\n use rustc_span::hygiene::{ExpnId, Transparency};\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n@@ -80,15 +80,15 @@ impl Iterator for Frame {\n /// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n ///\n /// Along the way, we do some additional error checking.\n-pub(super) fn transcribe(\n-    cx: &ExtCtxt<'_>,\n+pub(super) fn transcribe<'a>(\n+    cx: &ExtCtxt<'a>,\n     interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     src: Vec<mbe::TokenTree>,\n     transparency: Transparency,\n-) -> TokenStream {\n+) -> PResult<'a, TokenStream> {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n-        return TokenStream::default();\n+        return Ok(TokenStream::default());\n     }\n \n     // We descend into the RHS (`src`), expanding things as we go. This stack contains the things\n@@ -152,7 +152,7 @@ pub(super) fn transcribe(\n                 Frame::Delimited { forest, span, .. } => {\n                     if result_stack.is_empty() {\n                         // No results left to compute! We are back at the top-level.\n-                        return TokenStream::new(result);\n+                        return Ok(TokenStream::new(result));\n                     }\n \n                     // Step back into the parent Delimited.\n@@ -173,19 +173,19 @@ pub(super) fn transcribe(\n             seq @ mbe::TokenTree::Sequence(..) => {\n                 match lockstep_iter_size(&seq, interp, &repeats) {\n                     LockstepIterSize::Unconstrained => {\n-                        cx.span_fatal(\n+                        return Err(cx.struct_span_err(\n                             seq.span(), /* blame macro writer */\n                             \"attempted to repeat an expression containing no syntax variables \\\n                              matched as repeating at this depth\",\n-                        );\n+                        ));\n                     }\n \n                     LockstepIterSize::Contradiction(ref msg) => {\n                         // FIXME: this really ought to be caught at macro definition time... It\n                         // happens when two meta-variables are used in the same repetition in a\n                         // sequence, but they come from different sequence matchers and repeat\n                         // different amounts.\n-                        cx.span_fatal(seq.span(), &msg[..]);\n+                        return Err(cx.struct_span_err(seq.span(), &msg[..]));\n                     }\n \n                     LockstepIterSize::Constraint(len, _) => {\n@@ -203,7 +203,10 @@ pub(super) fn transcribe(\n                                 // FIXME: this really ought to be caught at macro definition\n                                 // time... It happens when the Kleene operator in the matcher and\n                                 // the body for the same meta-variable do not match.\n-                                cx.span_fatal(sp.entire(), \"this must repeat at least once\");\n+                                return Err(cx.struct_span_err(\n+                                    sp.entire(),\n+                                    \"this must repeat at least once\",\n+                                ));\n                             }\n                         } else {\n                             // 0 is the initial counter (we have done 0 repretitions so far). `len`\n@@ -242,10 +245,10 @@ pub(super) fn transcribe(\n                         }\n                     } else {\n                         // We were unable to descend far enough. This is an error.\n-                        cx.span_fatal(\n+                        return Err(cx.struct_span_err(\n                             sp, /* blame the macro writer */\n                             &format!(\"variable '{}' is still repeating at this depth\", ident),\n-                        );\n+                        ));\n                     }\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but"}, {"sha": "df7bf9438c3d03c2d175105b4b88175506c0b74e", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, TokenStream};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, FatalError};\n+use rustc_errors::{Applicability, ErrorReported};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -21,21 +21,16 @@ impl base::ProcMacro for BangProcMacro {\n         ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc macro panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n+        self.client.run(&EXEC_STRATEGY, server, input).map_err(|e| {\n+            let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n+            if let Some(s) = e.as_str() {\n+                err.help(&format!(\"message: {}\", s));\n             }\n-        }\n+            err.emit();\n+            ErrorReported\n+        })\n     }\n }\n \n@@ -50,21 +45,16 @@ impl base::AttrProcMacro for AttrProcMacro {\n         span: Span,\n         annotation: TokenStream,\n         annotated: TokenStream,\n-    ) -> TokenStream {\n+    ) -> Result<TokenStream, ErrorReported> {\n         let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"custom attribute panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n+        self.client.run(&EXEC_STRATEGY, server, annotation, annotated).map_err(|e| {\n+            let mut err = ecx.struct_span_err(span, \"custom attribute panicked\");\n+            if let Some(s) = e.as_str() {\n+                err.help(&format!(\"message: {}\", s));\n             }\n-        }\n+            err.emit();\n+            ErrorReported\n+        })\n     }\n }\n \n@@ -96,8 +86,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             | Annotatable::Expr(_) => {\n                 ecx.span_err(\n                     span,\n-                    \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\",\n+                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n                 );\n                 return ExpandResult::Ready(Vec::new());\n             }\n@@ -107,8 +96,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             _ => {\n                 ecx.span_err(\n                     span,\n-                    \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\",\n+                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n                 );\n                 return ExpandResult::Ready(Vec::new());\n             }\n@@ -121,20 +109,16 @@ impl MultiItemModifier for ProcMacroDerive {\n         let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {\n-                let msg = \"proc-macro derive panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n+                let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");\n                 if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n-\n                 err.emit();\n-                FatalError.raise();\n+                return ExpandResult::Ready(vec![]);\n             }\n         };\n \n         let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        let msg = \"proc-macro derive produced unparseable tokens\";\n-\n         let mut parser =\n             rustc_parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n@@ -144,18 +128,15 @@ impl MultiItemModifier for ProcMacroDerive {\n                 Ok(None) => break,\n                 Ok(Some(item)) => items.push(Annotatable::Item(item)),\n                 Err(mut err) => {\n-                    // FIXME: handle this better\n-                    err.cancel();\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n+                    err.emit();\n+                    break;\n                 }\n             }\n         }\n \n         // fail if there have been errors emitted\n         if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_fatal(span, msg).emit();\n-            FatalError.raise();\n+            ecx.struct_span_err(span, \"proc-macro derive produced unparseable tokens\").emit();\n         }\n \n         ExpandResult::Ready(items)"}, {"sha": "d5ed9fb9a285efd885f5f40527eaf4ed7a1a6b48", "filename": "src/test/ui/editions/edition-keywords-2018-2015-parsing.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,9 +1,17 @@\n // edition:2018\n // aux-build:edition-kw-macro-2015.rs\n \n+#![feature(async_closure)]\n+\n+fn main() {}\n+\n #[macro_use]\n extern crate edition_kw_macro_2015;\n \n+mod module {\n+    pub fn r#async() {}\n+}\n+\n pub fn check_async() {\n     let mut async = 1; //~ ERROR expected identifier, found keyword `async`\n     let mut r#async = 1; // OK\n@@ -17,4 +25,6 @@ pub fn check_async() {\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found keyword `async`\n     module::r#async(); // OK\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "28663563c6ccdf1079aea69293ca1398d0613f09", "filename": "src/test/ui/editions/edition-keywords-2018-2015-parsing.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2015-parsing.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:8:13\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:16:13\n    |\n LL |     let mut async = 1;\n    |             ^^^^^ expected identifier, found keyword\n@@ -10,7 +10,7 @@ LL |     let mut r#async = 1;\n    |             ^^^^^^^\n \n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:18:13\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:26:13\n    |\n LL |     module::async();\n    |             ^^^^^ expected identifier, found keyword\n@@ -21,13 +21,13 @@ LL |     module::r#async();\n    |             ^^^^^^^\n \n error: no rules expected the token `r#async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:12:31\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:20:31\n    |\n LL |     r#async = consumes_async!(r#async);\n    |                               ^^^^^^^ no rules expected this token in macro call\n \n error: no rules expected the token `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:13:35\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:21:35\n    |\n LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n@@ -38,10 +38,19 @@ error: macro expansion ends with an incomplete expression: expected one of `move\n LL |     ($i: ident) => ($i)\n    |                       ^ expected one of `move`, `|`, or `||`\n    | \n-  ::: $DIR/edition-keywords-2018-2015-parsing.rs:16:8\n+  ::: $DIR/edition-keywords-2018-2015-parsing.rs:24:8\n    |\n LL |     if passes_ident!(async) == 1 {}\n    |        -------------------- in this macro invocation\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/edition-keywords-2018-2015-parsing.rs:29:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "044ab249f2c2660f61ae510d4c9e798fd0af578e", "filename": "src/test/ui/editions/edition-keywords-2018-2018-parsing.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,9 +1,17 @@\n // edition:2018\n // aux-build:edition-kw-macro-2018.rs\n \n+#![feature(async_closure)]\n+\n+fn main() {}\n+\n #[macro_use]\n extern crate edition_kw_macro_2018;\n \n+mod module {\n+    pub fn r#async() {}\n+}\n+\n pub fn check_async() {\n     let mut async = 1; //~ ERROR expected identifier, found keyword `async`\n     let mut r#async = 1; // OK\n@@ -17,4 +25,6 @@ pub fn check_async() {\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found keyword `async`\n     module::r#async(); // OK\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "cda7e65e437e85e1f31803096da47d7d1b4fd710", "filename": "src/test/ui/editions/edition-keywords-2018-2018-parsing.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-parsing.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,5 +1,5 @@\n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:8:13\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:16:13\n    |\n LL |     let mut async = 1;\n    |             ^^^^^ expected identifier, found keyword\n@@ -10,7 +10,7 @@ LL |     let mut r#async = 1;\n    |             ^^^^^^^\n \n error: expected identifier, found keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:18:13\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:26:13\n    |\n LL |     module::async();\n    |             ^^^^^ expected identifier, found keyword\n@@ -21,13 +21,13 @@ LL |     module::r#async();\n    |             ^^^^^^^\n \n error: no rules expected the token `r#async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:12:31\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:20:31\n    |\n LL |     r#async = consumes_async!(r#async);\n    |                               ^^^^^^^ no rules expected this token in macro call\n \n error: no rules expected the token `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:13:35\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:21:35\n    |\n LL |     r#async = consumes_async_raw!(async);\n    |                                   ^^^^^ no rules expected this token in macro call\n@@ -38,10 +38,19 @@ error: macro expansion ends with an incomplete expression: expected one of `move\n LL |     ($i: ident) => ($i)\n    |                       ^ expected one of `move`, `|`, or `||`\n    | \n-  ::: $DIR/edition-keywords-2018-2018-parsing.rs:16:8\n+  ::: $DIR/edition-keywords-2018-2018-parsing.rs:24:8\n    |\n LL |     if passes_ident!(async) == 1 {}\n    |        -------------------- in this macro invocation\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/edition-keywords-2018-2018-parsing.rs:29:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "18df3f6ee94c1e173e46509f9d35d0ebf0971762", "filename": "src/test/ui/macros/issue-61033-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,9 +1,10 @@\n // Regression test for issue #61033.\n \n macro_rules! test1 {\n-    ($x:ident, $($tt:tt)*) => { $($tt)+ } //~ERROR this must repeat at least once\n+    ($x:ident, $($tt:tt)*) => { $($tt)+ } //~ ERROR this must repeat at least once\n }\n \n fn main() {\n     test1!(x,);\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }"}, {"sha": "18205c3436b0b4f8ca9571dd03c176934b1e3d56", "filename": "src/test/ui/macros/issue-61033-1.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-1.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -4,5 +4,14 @@ error: this must repeat at least once\n LL |     ($x:ident, $($tt:tt)*) => { $($tt)+ }\n    |                                  ^^^^^\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61033-1.rs:9:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1760ba1584d0b2e495346e3176d35fc6bdc9d826", "filename": "src/test/ui/macros/issue-61033-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -5,7 +5,9 @@ macro_rules! test2 {\n         $(* $id1:ident)*\n         $(+ $id2:ident)*\n     ) => {\n-        $( //~ERROR meta-variable `id1` repeats 2 times\n+        $(\n+        //~^ ERROR meta-variable `id1` repeats 2 times\n+        //~| ERROR meta-variable `id1` repeats 2 times\n             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n         )*\n     }\n@@ -16,4 +18,8 @@ fn main() {\n         * a * b\n         + a + b + c\n     }\n+    test2! {\n+        * a * b\n+        + a + b + c + d\n+    }\n }"}, {"sha": "cdfe7934a0cac26af019674778b0c16718d1fcd4", "filename": "src/test/ui/macros/issue-61033-2.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-61033-2.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -3,9 +3,22 @@ error: meta-variable `id1` repeats 2 times, but `id2` repeats 3 times\n    |\n LL |           $(\n    |  __________^\n+LL | |\n+LL | |\n LL | |             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n LL | |         )*\n    | |_________^\n \n-error: aborting due to previous error\n+error: meta-variable `id1` repeats 2 times, but `id2` repeats 4 times\n+  --> $DIR/issue-61033-2.rs:8:10\n+   |\n+LL |           $(\n+   |  __________^\n+LL | |\n+LL | |\n+LL | |             $id1 + $id2 // $id1 and $id2 may repeat different numbers of times\n+LL | |         )*\n+   | |_________^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "3967481098cff05cf1e45789b9d40462b5007b4d", "filename": "src/test/ui/macros/local-ambiguity-multiple-parsing-options.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+macro_rules! ambiguity {\n+    ($($i:ident)* $j:ident) => {};\n+}\n+\n+ambiguity!(error); //~ ERROR local ambiguity\n+ambiguity!(error); //~ ERROR local ambiguity"}, {"sha": "0ae56c422213cbfc7fbe1b5d12e520b4c9f82b1b", "filename": "src/test/ui/macros/local-ambiguity-multiple-parsing-options.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Flocal-ambiguity-multiple-parsing-options.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -0,0 +1,14 @@\n+error: local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('j').\n+  --> $DIR/local-ambiguity-multiple-parsing-options.rs:7:12\n+   |\n+LL | ambiguity!(error);\n+   |            ^^^^^\n+\n+error: local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('j').\n+  --> $DIR/local-ambiguity-multiple-parsing-options.rs:8:12\n+   |\n+LL | ambiguity!(error);\n+   |            ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "13e179578ad012d22f73348cc7d7b65692d960ab", "filename": "src/test/ui/macros/macro-context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -4,6 +4,8 @@ macro_rules! m {\n                             //~| ERROR macro expansion ignores token `typeof`\n                             //~| ERROR macro expansion ignores token `;`\n                             //~| ERROR macro expansion ignores token `;`\n+                            //~| ERROR cannot find type `i` in this scope\n+                            //~| ERROR cannot find value `i` in this scope\n }\n \n fn main() {"}, {"sha": "17c7389812475ac0a8eb48aff453d1adc6246cbd", "filename": "src/test/ui/macros/macro-context.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-context.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -42,5 +42,29 @@ LL |     m!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error[E0412]: cannot find type `i` in this scope\n+  --> $DIR/macro-context.rs:3:13\n+   |\n+LL |     () => ( i ; typeof );\n+   |             ^ help: a builtin type with a similar name exists: `i8`\n+...\n+LL |     let a: m!();\n+   |            ---- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find value `i` in this scope\n+  --> $DIR/macro-context.rs:3:13\n+   |\n+LL |     () => ( i ; typeof );\n+   |             ^ help: a local variable with a similar name exists: `a`\n+...\n+LL |     let i = m!();\n+   |             ---- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n \n+Some errors have detailed explanations: E0412, E0425.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "b23e5c71c03f06e29245481dbfa775b0b3c57874", "filename": "src/test/ui/macros/macro-match-nonterminal.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,4 +1,11 @@\n-macro_rules! test { ($a, $b) => (()); } //~ ERROR missing fragment\n+macro_rules! test {\n+    ($a, $b) => {\n+        //~^ ERROR missing fragment\n+        //~| ERROR missing fragment\n+        //~| WARN this was previously accepted\n+        ()\n+    };\n+}\n \n fn main() {\n     test!()"}, {"sha": "674ce3434aac63fd9446e23a30c91f34fe2c3271", "filename": "src/test/ui/macros/macro-match-nonterminal.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-match-nonterminal.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,8 +1,18 @@\n error: missing fragment specifier\n-  --> $DIR/macro-match-nonterminal.rs:1:24\n+  --> $DIR/macro-match-nonterminal.rs:2:8\n    |\n-LL | macro_rules! test { ($a, $b) => (()); }\n-   |                        ^\n+LL |     ($a, $b) => {\n+   |        ^\n \n-error: aborting due to previous error\n+error: missing fragment specifier\n+  --> $DIR/macro-match-nonterminal.rs:2:10\n+   |\n+LL |     ($a, $b) => {\n+   |          ^^\n+   |\n+   = note: `#[deny(missing_fragment_specifier)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #40107 <https://github.com/rust-lang/rust/issues/40107>\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "5a8e2f50ce33d2fbca03f7f73da240fbe2c3e520", "filename": "src/test/ui/macros/trace_faulty_macros.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Z trace-macros\n \n-#![recursion_limit=\"4\"]\n+#![recursion_limit = \"4\"]\n \n macro_rules! my_faulty_macro {\n     () => {\n@@ -24,9 +24,7 @@ macro_rules! my_recursive_macro {\n }\n \n macro_rules! my_macro {\n-    () => {\n-\n-    };\n+    () => {};\n }\n \n fn main() {\n@@ -39,7 +37,7 @@ fn main() {\n }\n \n #[my_macro]\n-fn use_bang_macro_as_attr(){}\n+fn use_bang_macro_as_attr() {}\n \n-#[derive(Debug)]\n-fn use_derive_macro_as_attr(){}\n+#[derive(Debug)] //~ ERROR `derive` may only be applied to structs\n+fn use_derive_macro_as_attr() {}"}, {"sha": "aec9d1ab191af20ae77acd5b4e61b93fa486a245", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -13,7 +13,7 @@ LL |     my_faulty_macro!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: trace_macro\n-  --> $DIR/trace_faulty_macros.rs:33:5\n+  --> $DIR/trace_faulty_macros.rs:31:5\n    |\n LL |     my_faulty_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     my_recursive_macro!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: trace_macro\n-  --> $DIR/trace_faulty_macros.rs:34:5\n+  --> $DIR/trace_faulty_macros.rs:32:5\n    |\n LL |     my_recursive_macro!();\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,5 +60,22 @@ LL |     let a = pat_macro!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 3 previous errors\n+error: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/trace_faulty_macros.rs:42:1\n+   |\n+LL | #[derive(Debug)]\n+   | ^^^^^^^^^^^^^^^^\n+\n+note: trace_macro\n+  --> $DIR/trace_faulty_macros.rs:36:13\n+   |\n+LL |     let a = pat_macro!();\n+   |             ^^^^^^^^^^^^\n+   |\n+   = note: expanding `pat_macro! {  }`\n+   = note: to `pat_macro ! (A { a : a, b : 0, c : _, .. }) ;`\n+   = note: expanding `pat_macro! { A { a : a, b : 0, c : _, .. } }`\n+   = note: to `A { a: a, b: 0, c: _, .. }`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "e38b7b65089372fbcdc9858503f164a9ab7d4b14", "filename": "src/test/ui/parser/issue-62894.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // Regression test for #62894, shouldn't crash.\n // error-pattern: this file contains an unclosed delimiter\n // error-pattern: expected one of `(`, `[`, or `{`, found keyword `fn`"}, {"sha": "4a1d7e275bed86a90f440a80d8644c82b4bd900a", "filename": "src/test/ui/parser/issue-62894.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,5 +1,5 @@\n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -11,7 +11,7 @@ LL | fn main() {}\n    |              ^\n \n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -23,7 +23,7 @@ LL | fn main() {}\n    |              ^\n \n error: this file contains an unclosed delimiter\n-  --> $DIR/issue-62894.rs:7:14\n+  --> $DIR/issue-62894.rs:12:14\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |        -           -                   - unclosed delimiter\n@@ -35,13 +35,18 @@ LL | fn main() {}\n    |              ^\n \n error: expected one of `(`, `[`, or `{`, found keyword `fn`\n-  --> $DIR/issue-62894.rs:7:1\n+  --> $DIR/issue-62894.rs:12:1\n    |\n LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n    |                                                   - expected one of `(`, `[`, or `{`\n LL | \n LL | fn main() {}\n    | ^^ unexpected token\n+   | \n+  ::: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+   |\n+LL |     ($left:expr, $right:expr) => ({\n+   |      ---------- while parsing argument for this `expr` macro fragment\n \n error: aborting due to 4 previous errors\n "}, {"sha": "80e2d7c6545ba277512e0c9c2ad7ee0a0c70be40", "filename": "src/test/ui/parser/macro/issue-33569.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-33569.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -6,3 +6,5 @@ macro_rules! foo {\n }\n \n foo!();\n+\n+fn main() {}"}, {"sha": "3ffbea217e79ebf9de92687367079a543f79239b", "filename": "src/test/ui/parser/macro/macro-repeat.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,9 +1,12 @@\n macro_rules! mac {\n-    ( $($v:tt)* ) => (\n-        $v  //~ ERROR still repeating at this depth\n-    )\n+    ( $($v:tt)* ) => {\n+        $v\n+        //~^ ERROR still repeating at this depth\n+        //~| ERROR still repeating at this depth\n+    };\n }\n \n fn main() {\n     mac!(0);\n+    mac!(1);\n }"}, {"sha": "63554b197b91c19082cd28b8b9010a7e606b32cf", "filename": "src/test/ui/parser/macro/macro-repeat.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fmacro-repeat.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -4,5 +4,11 @@ error: variable 'v' is still repeating at this depth\n LL |         $v\n    |         ^^\n \n-error: aborting due to previous error\n+error: variable 'v' is still repeating at this depth\n+  --> $DIR/macro-repeat.rs:3:9\n+   |\n+LL |         $v\n+   |         ^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "ccbeb398af5baee5f87050f40c4dd01758b2c2c8", "filename": "src/test/ui/parser/nt-parsing-has-recovery.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! foo {\n+    ($e:expr) => {}\n+}\n+\n+foo!(1 + @); //~ ERROR expected expression, found `@`\n+foo!(1 + @); //~ ERROR expected expression, found `@`\n+\n+fn main() {\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "263c4ad53612ee98f7c90a3ff2055b6aec2a5eac", "filename": "src/test/ui/parser/nt-parsing-has-recovery.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fnt-parsing-has-recovery.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -0,0 +1,29 @@\n+error: expected expression, found `@`\n+  --> $DIR/nt-parsing-has-recovery.rs:5:10\n+   |\n+LL |     ($e:expr) => {}\n+   |      ------- while parsing argument for this `expr` macro fragment\n+...\n+LL | foo!(1 + @);\n+   |          ^ expected expression\n+\n+error: expected expression, found `@`\n+  --> $DIR/nt-parsing-has-recovery.rs:6:10\n+   |\n+LL |     ($e:expr) => {}\n+   |      ------- while parsing argument for this `expr` macro fragment\n+...\n+LL | foo!(1 + @);\n+   |          ^ expected expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/nt-parsing-has-recovery.rs:9:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cb5188b5fb43fd4c0e374a7e3fb58a8b3d0fdb78", "filename": "src/test/ui/proc-macro/derive-bad.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -3,11 +3,9 @@\n #[macro_use]\n extern crate derive_bad;\n \n-#[derive(\n-    A\n-)]\n-//~^^ ERROR proc-macro derive produced unparseable tokens\n+#[derive(A)]\n+//~^ ERROR proc-macro derive produced unparseable tokens\n //~| ERROR expected `:`, found `}`\n-struct A;\n+struct A; //~ ERROR the name `A` is defined multiple times\n \n fn main() {}"}, {"sha": "bc5ed9815238adf026d3e4d5130641585feda6f4", "filename": "src/test/ui/proc-macro/derive-bad.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-bad.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,16 +1,28 @@\n error: expected `:`, found `}`\n-  --> $DIR/derive-bad.rs:7:5\n+  --> $DIR/derive-bad.rs:6:10\n    |\n-LL |     A\n-   |     ^ expected `:`\n+LL | #[derive(A)]\n+   |          ^ expected `:`\n    |\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: proc-macro derive produced unparseable tokens\n-  --> $DIR/derive-bad.rs:7:5\n+  --> $DIR/derive-bad.rs:6:10\n    |\n-LL |     A\n-   |     ^\n+LL | #[derive(A)]\n+   |          ^\n \n-error: aborting due to 2 previous errors\n+error[E0428]: the name `A` is defined multiple times\n+  --> $DIR/derive-bad.rs:9:1\n+   |\n+LL | #[derive(A)]\n+   |          - previous definition of the type `A` here\n+...\n+LL | struct A;\n+   | ^^^^^^^^^ `A` redefined here\n+   |\n+   = note: `A` must be defined only once in the type namespace of this module\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "3f78dea917b1960b7910b42ad918718163d06359", "filename": "src/test/ui/proc-macro/invalid-punct-ident-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-1.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_punct!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "4e89e80ae7c412c68fc752a2306351d25e6ca843", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_ident!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "8d8ce8f932e7118fb27b0557ea1084882ea0ead8", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -14,3 +14,5 @@\n extern crate invalid_punct_ident;\n \n invalid_raw_ident!(); //~ ERROR proc macro panicked\n+\n+fn main() {}"}, {"sha": "59b347dac679c252dd44fccd83acda84ffa59d5e", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -3,5 +3,10 @@\n #[macro_use]\n extern crate invalid_punct_ident;\n \n-lexer_failure!(); //~ ERROR proc macro panicked\n-                  //~| ERROR unexpected closing delimiter: `)`\n+lexer_failure!();\n+//~^ ERROR proc macro panicked\n+//~| ERROR unexpected closing delimiter: `)`\n+\n+fn main() {\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "3b357aecea864d685397256279ec1cb31f317979", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -12,5 +12,14 @@ error: proc macro panicked\n LL | lexer_failure!();\n    | ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-punct-ident-4.rs:11:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5c43a564c00c2a3b502d4980cc3e74d1d15b384e", "filename": "src/test/ui/proc-macro/issue-36935.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -5,6 +5,7 @@ extern crate test_macros;\n \n #[derive(Identity, Panic)] //~ ERROR proc-macro derive panicked\n struct Baz {\n+    //~^ ERROR the name `Baz` is defined multiple times\n     a: i32,\n     b: i32,\n }"}, {"sha": "2b2e28fdb2fda4ecd081b957bda9c7eb2e2274fa", "filename": "src/test/ui/proc-macro/issue-36935.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -6,5 +6,17 @@ LL | #[derive(Identity, Panic)]\n    |\n    = help: message: panic-derive\n \n-error: aborting due to previous error\n+error[E0428]: the name `Baz` is defined multiple times\n+  --> $DIR/issue-36935.rs:7:1\n+   |\n+LL | struct Baz {\n+   | ^^^^^^^^^^\n+   | |\n+   | `Baz` redefined here\n+   | previous definition of the type `Baz` here\n+   |\n+   = note: `Baz` must be defined only once in the type namespace of this module\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "2d46f74ad9bc902ca80c1e7c93b61c558cf03ae4", "filename": "src/test/ui/span/transitive-dep-span.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -11,3 +11,5 @@\n extern crate transitive_dep_two;\n \n transitive_dep_two::parse_error!(); //~ ERROR expected one of\n+\n+fn main() {}"}, {"sha": "31e567c396067495eb1e8c9b55d7cda283faa659", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -6,7 +6,13 @@ struct A {}\n \n impl A {\n     #[test]\n-    fn new() -> A { //~ ERROR `#[test]` attribute is only allowed on non associated functions\n+    fn new() -> A {\n+        //~^ ERROR `#[test]` attribute is only allowed on non associated functions\n+        A {}\n+    }\n+    #[test]\n+    fn recovery_witness() -> A {\n+        //~^ ERROR `#[test]` attribute is only allowed on non associated functions\n         A {}\n     }\n }"}, {"sha": "a81b8f3980c374c7bc7c1112fc2a260d5a03f813", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -2,9 +2,19 @@ error: `#[test]` attribute is only allowed on non associated functions\n   --> $DIR/test-attr-non-associated-functions.rs:9:5\n    |\n LL | /     fn new() -> A {\n+LL | |\n LL | |         A {}\n LL | |     }\n    | |_____^\n \n-error: aborting due to previous error\n+error: `#[test]` attribute is only allowed on non associated functions\n+  --> $DIR/test-attr-non-associated-functions.rs:14:5\n+   |\n+LL | /     fn recovery_witness() -> A {\n+LL | |\n+LL | |         A {}\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "8035de4a48a92ceb16c26e4a4e742243b27b47ad", "filename": "src/test/ui/type/ascription/issue-47666.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.rs?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -1,5 +1,7 @@\n fn main() {\n     let _ = Option:Some(vec![0, 1]); //~ ERROR expected type, found\n+    //~^ ERROR expected value, found enum `Option`\n+    //~| ERROR expected type, found variant `Some`\n }\n \n // This case isn't currently being handled gracefully due to the macro invocation."}, {"sha": "3cd3be70aa75b4163ac0ad6cf7599bf912ccd038", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "patch": "@@ -13,5 +13,35 @@ LL |     let _ = Option:Some(vec![0, 1]);\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error[E0423]: expected value, found enum `Option`\n+  --> $DIR/issue-47666.rs:2:13\n+   |\n+LL |     let _ = Option:Some(vec![0, 1]);\n+   |             ^^^^^^\n+   |\n+help: try using one of the enum's variants\n+   |\n+LL |     let _ = std::option::Option::None:Some(vec![0, 1]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = std::option::Option::Some:Some(vec![0, 1]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0573]: expected type, found variant `Some`\n+  --> $DIR/issue-47666.rs:2:20\n+   |\n+LL |     let _ = Option:Some(vec![0, 1]);\n+   |                    ^^^^^^^^^^^^^^^^ not a type\n+   |\n+help: try using the variant's enum\n+   |\n+LL |     let _ = Option:std::option::Option;\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+help: maybe you meant to write a path separator here\n+   |\n+LL |     let _ = Option::Some(vec![0, 1]);\n+   |                   ^^\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0423, E0573.\n+For more information about an error, try `rustc --explain E0423`."}]}