{"sha": "3c4baf694e663bf3891caf550883fce66160b6b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNGJhZjY5NGU2NjNiZjM4OTFjYWY1NTA4ODNmY2U2NjE2MGI2YjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-04T18:21:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-04T18:46:23Z"}, "message": "better support for classes with polymorphic methods", "tree": {"sha": "74f4c7b310495f07a75a464e86e51a8c5e5b558a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74f4c7b310495f07a75a464e86e51a8c5e5b558a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4baf694e663bf3891caf550883fce66160b6b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4baf694e663bf3891caf550883fce66160b6b4", "html_url": "https://github.com/rust-lang/rust/commit/3c4baf694e663bf3891caf550883fce66160b6b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4baf694e663bf3891caf550883fce66160b6b4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7213274e57ef779620e6d68939816c66201d7d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/7213274e57ef779620e6d68939816c66201d7d36", "html_url": "https://github.com/rust-lang/rust/commit/7213274e57ef779620e6d68939816c66201d7d36"}], "stats": {"total": 107, "additions": 37, "deletions": 70}, "files": [{"sha": "113fafb73b31786e938d706cbd75782ebf48a35e", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -664,7 +664,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 ebml_w.start_tag(tag_item_iface_method);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));\n                 encode_name(ebml_w, m.ident);\n-                encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n+                encode_type_param_bounds(ebml_w, ecx, m.tps);\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n                 encode_def_id(ebml_w, local_def(m.id));\n                 ebml_w.end_tag();"}, {"sha": "fef2a0ad28ed5b7f7d1b11fb00f6166372981551", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -254,29 +254,16 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n               expr_field(base, _, _) {\n                 alt cx.method_map.get(e.id) {\n                   typeck::method_static(did) {\n-                   /*\n-                        If this is a class method, we want to use the\n-                        class bounds plus the method bounds -- otherwise the\n-                        indices come out wrong. So we check base's type...\n-                   */\n-                   let mut bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-                   alt ty::get(ty::node_id_to_type(cx.tcx, base.id)).struct {\n-                        ty::ty_class(parent_id, ts) {\n-                            /* ...and if it has a class type, prepend the\n-                               class bounds onto the method bounds */\n-                            /* n.b. this code is very likely sketchy --\n-                             currently, class-impl-very-parameterized-iface\n-                             fails here and is thus xfailed */\n-                            bounds =\n-                             @(*ty::lookup_item_type(cx.tcx, parent_id).bounds\n-                               + *bounds);\n-                        }\n-                        _ { }\n-                      }\n-                      bounds\n+                    // n.b.: When we encode class/impl methods, the bounds\n+                    // that we encode include both the class/impl bounds\n+                    // and then the method bounds themselves...\n+                    ty::lookup_item_type(cx.tcx, did).bounds\n                   }\n                   typeck::method_param(ifce_id, n_mth, _, _) |\n                   typeck::method_iface(ifce_id, n_mth) {\n+                    // ...iface methods bounds, in contrast, include only the\n+                    // method bounds, so we must preprend the tps from the\n+                    // iface itself.  This ought to be harmonized.\n                     let ifce_bounds =\n                         ty::lookup_item_type(cx.tcx, ifce_id).bounds;\n                     let mth = ty::iface_methods(cx.tcx, ifce_id)[n_mth];"}, {"sha": "d6d43b0d3b2d760ba383d3027d85a16f113cc70e", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -18,6 +18,9 @@ enum lookup = {\n impl methods for lookup {\n     // Entrypoint:\n     fn method() -> option<method_origin> {\n+        #debug[\"method lookup(m_name=%s, self_ty=%s)\",\n+               self.m_name, self.fcx.infcx.ty_to_str(self.self_ty)];\n+\n         // First, see whether this is an interface-bounded parameter\n         let pass1 = alt ty::get(self.self_ty).struct {\n           ty::ty_param(n, did) {\n@@ -288,6 +291,11 @@ impl methods for lookup {\n \n         let tcx = self.fcx.ccx.tcx;\n \n+        #debug[\"write_mty_from_fty(n_tps_m=%u, fty=%s, origin=%?)\",\n+               n_tps_m,\n+               self.fcx.infcx.ty_to_str(fty),\n+               origin];\n+\n         // Here I will use the \"c_\" prefix to refer to the method's\n         // owner.  You can read it as class, but it may also be an iface.\n "}, {"sha": "e97629a823b69ced412acab569a7ea6d4a910858", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -228,17 +228,15 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n                                rp: ast::region_param,\n                                selfty: ty::t,\n                                a_ifacety: @ast::iface_ref,\n-                               ms: [@ast::method]) {\n+                               ms: [converted_method]) {\n \n     let tcx = ccx.tcx;\n-    let i_bounds = ty_param_bounds(ccx, tps);\n-    let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n     let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n     if did.crate == ast::local_crate {\n         ensure_iface_methods(ccx, did.node);\n     }\n     for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-        alt vec::find(my_methods, {|m| if_m.ident == m.mty.ident}) {\n+        alt vec::find(ms, {|m| if_m.ident == m.mty.ident}) {\n           some({mty: m, id, span}) {\n             if m.purity != if_m.purity {\n                 ccx.tcx.sess.span_err(\n@@ -274,12 +272,13 @@ fn convert_class_item(ccx: @crate_ctxt,\n     ccx.tcx.tcache.insert(local_def(v.id), {bounds: bounds, rp: rp, ty: tt});\n }\n \n+type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n+\n fn convert_methods(ccx: @crate_ctxt,\n                    ms: [@ast::method],\n                    rp: ast::region_param,\n-                   i_bounds: @[ty::param_bounds],\n-                   self_ty: ty::t)\n-    -> [{mty: ty::method, id: ast::node_id, span: span}] {\n+                   rcvr_bounds: @[ty::param_bounds],\n+                   self_ty: ty::t) -> [converted_method] {\n \n     let tcx = ccx.tcx;\n     vec::map(ms) { |m|\n@@ -289,9 +288,10 @@ fn convert_methods(ccx: @crate_ctxt,\n         let fty = ty::mk_fn(tcx, mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n-            // n.b. This code is kind of sketchy (concat'ing i_bounds\n-            // with bounds), but removing *i_bounds breaks other stuff\n-            {bounds: @(*i_bounds + *bounds), rp: rp, ty: fty});\n+\n+            // n.b.: the type of a method is parameterized by both\n+            // the tps on the receiver and those on the method itself\n+            {bounds: @(*rcvr_bounds + *bounds), rp: rp, ty: fty});\n         write_ty_to_tcx(tcx, m.id, fty);\n         {mty: mty, id: m.id, span: m.span}\n     }\n@@ -316,19 +316,10 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                           {bounds: i_bounds,\n                            rp: rp,\n                            ty: selfty});\n-        alt ifce {\n-          some(t) {\n-            check_methods_against_iface(\n-                ccx, tps, rp,\n-                selfty, t, ms);\n-          }\n-          _ {\n-            // Still have to do this to write method types\n-            // into the table\n-            convert_methods(\n-                ccx, ms, rp,\n-                i_bounds, selfty);\n-          }\n+\n+        let cms = convert_methods(ccx, ms, rp, i_bounds, selfty);\n+        for ifce.each { |t|\n+            check_methods_against_iface(ccx, tps, rp, selfty, t, cms);\n         }\n       }\n       ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n@@ -412,23 +403,11 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         for fields.each {|f|\n            convert_class_item(ccx, rp, tpt.bounds, f);\n         }\n-        // The selfty is just the class type\n-        let {bounds:_, substs} = mk_substs(ccx, tps, rp);\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n-        // Need to convert all methods so we can check internal\n-        // references to private methods\n-\n-        // NDM to TJC---I think we ought to be using bounds here, not @[].\n-        // But doing so causes errors later on.\n-        convert_methods(ccx, methods, rp, @[], selfty);\n-\n-        /*\n-        Finally, check that the class really implements the ifaces\n-        that it claims to implement.\n-        */\n+        let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n         for ifaces.each { |ifce|\n-            check_methods_against_iface(ccx, tps, rp, selfty,\n-                                        ifce, methods);\n+            check_methods_against_iface(ccx, tps, rp, selfty, ifce, cms);\n \n             // FIXME #2434---this is somewhat bogus, but it seems that\n             // the id of iface_ref is also the id of the impl, and so"}, {"sha": "718507d1efca78af13e190dd668b818eeddc38ae", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -1,4 +1,3 @@\n-// xfail-test  (still buggy)\n // xfail-fast  (compile-flags unsupported on windows)\n // compile-flags:--borrowck=err\n // exec-env:RUST_POISON_ON_FREE=1"}, {"sha": "74d8f921186cfc28ce9a962a4963d5102dfe7967", "filename": "src/test/run-pass/class-impl-very-parameterized-iface.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-// xfail-fast\n use std;\n import std::map::*;\n \n@@ -59,7 +57,7 @@ class cat<T: copy> implements map<int, T> {\n      }\n      else { none }\n   }\n-  \n+\n   fn remove(&&k:int) -> option<T> {\n     alt self.find(k) {\n       some(x) {\n@@ -76,7 +74,7 @@ class cat<T: copy> implements map<int, T> {\n         n -= 1;\n     }\n   }\n-  \n+\n   fn each_key(&&f: fn(&&int) -> bool) {\n     for self.each {|k, _v| if !f(k) { break; } cont;};\n   }\n@@ -88,11 +86,11 @@ class cat<T: copy> implements map<int, T> {\n \n fn main() {\n   let nyan : cat<str> = cat(0, 2, \"nyan\");\n-  uint::range(1u, 5u) {|_i| nyan.speak(); }\n+  for uint::range(1u, 5u) {|_i| nyan.speak(); }\n   assert(nyan.find(1) == some(\"nyan\"));\n   assert(nyan.find(10) == none);\n   let spotty : cat<cat_type> = cat(2, 57, tuxedo);\n-  uint::range(0u, 6u) {|_i| spotty.speak(); }\n+  for uint::range(0u, 6u) {|_i| spotty.speak(); }\n   assert(spotty.size() == 8u);\n   assert(spotty.contains_key(2));\n   assert(spotty.get(3) == tuxedo);"}, {"sha": "28ddbfdd1e2fb8738fed844201e8c0b506058353", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-\n // xfail-fast\n // aux-build:cci_class_6.rs\n use cci_class_6;"}, {"sha": "caefb72a6a47d7322a515deea04b8075eed6aab6", "filename": "src/test/run-pass/class-typarams.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4baf694e663bf3891caf550883fce66160b6b4/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-typarams.rs?ref=3c4baf694e663bf3891caf550883fce66160b6b4", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-// needs metadata encoding on Windows\n class cat<U> {\n   priv {\n     let mut meows : uint;"}]}