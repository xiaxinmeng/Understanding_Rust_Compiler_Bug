{"sha": "ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMzBkNGUxYjk0N2Y4NTgwNjM2OTA5YzRjNmY1YWFlYjI1NGVhNGM=", "commit": {"author": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-02-27T17:37:35Z"}, "committer": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-02-27T17:37:35Z"}, "message": "replaced nonzeroparseerror with regular interror", "tree": {"sha": "4b34df1ceec806f55745d09c7b641fd8bd60dfaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b34df1ceec806f55745d09c7b641fd8bd60dfaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRSHIJXMGpVuikiTwqoW3QnLdkKoAUCXHbK+gAKCRCoW3QnLdkK\noMoVAP9weaTaGTgiNyWJYTlR9zhJ3l4D0bdej2xTOgXc0FKSXAEAjLhm5jo8Slbv\n5CIgkKxanQBq2cl9oFMg98/cWJpJoA0=\n=9GpG\n-----END PGP SIGNATURE-----", "payload": "tree 4b34df1ceec806f55745d09c7b641fd8bd60dfaa\nparent 36bcbc352d4b48f0f3aea35fd9ca74e856f797c9\nauthor Marcel Hellwig <git@cookiesoft.de> 1551289055 +0100\ncommitter Marcel Hellwig <git@cookiesoft.de> 1551289055 +0100\n\nreplaced nonzeroparseerror with regular interror\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "html_url": "https://github.com/rust-lang/rust/commit/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c/comments", "author": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9", "html_url": "https://github.com/rust-lang/rust/commit/36bcbc352d4b48f0f3aea35fd9ca74e856f797c9"}], "stats": {"total": 122, "additions": 23, "deletions": 99}, "files": [{"sha": "77b709a050d5710d200381b2f35facd072e979e1", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 10, "deletions": 92, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "patch": "@@ -112,103 +112,15 @@ nonzero_integers! {\n     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n }\n \n-/// An error which can be returned when parsing a non-zero integer.\n-///\n-/// # Potential causes\n-///\n-/// Among other causes, `ParseNonZeroIntError` can be thrown because of leading or trailing\n-/// whitespace in the string e.g., when it is obtained from the standard input.\n-/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n-///\n-/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n-#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ParseNonZeroIntError {\n-    kind: NonZeroIntErrorKind,\n-}\n-\n-/// Enum to store the various types of errors that can cause parsing a non-zero integer to fail.\n-#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[non_exhaustive]\n-pub enum NonZeroIntErrorKind {\n-    /// Value being parsed is empty.\n-    ///\n-    /// Among other causes, this variant will be constructed when parsing an empty string.\n-    Empty,\n-    /// Contains an invalid digit.\n-    ///\n-    /// Among other causes, this variant will be constructed when parsing a string that\n-    /// contains a letter.\n-    InvalidDigit,\n-    /// Integer is too large to store in target integer type.\n-    Overflow,\n-    /// Integer is too small to store in target integer type.\n-    Underflow,\n-    /// Integer contains the value `0` which is forbidden for a non-zero integer\n-    Zero,\n-}\n-\n-#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n-impl From<ParseIntError> for ParseNonZeroIntError {\n-    fn from(p: ParseIntError) -> Self {\n-        use self::IntErrorKind as IK;\n-        use self::NonZeroIntErrorKind as NK;\n-        ParseNonZeroIntError {\n-            kind: match p.kind {\n-                IK::Empty => NK::Empty,\n-                IK::InvalidDigit => NK::InvalidDigit,\n-                IK::Overflow => NK::Overflow,\n-                IK::Underflow => NK::Underflow,\n-            },\n-        }\n-    }\n-}\n-\n-impl ParseNonZeroIntError {\n-    /// Outputs the detailed cause of parsing an integer failing.\n-    #[unstable(feature = \"int_error_matching\",\n-               reason = \"it can be useful to match errors when making error messages \\\n-                         for integer parsing\",\n-               issue = \"22639\")]\n-    pub fn kind(&self) -> &NonZeroIntErrorKind {\n-        &self.kind\n-    }\n-\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.kind {\n-            NonZeroIntErrorKind::Empty => \"cannot parse integer from empty string\",\n-            NonZeroIntErrorKind::InvalidDigit => \"invalid digit found in string\",\n-            NonZeroIntErrorKind::Overflow => \"number too large to fit in target type\",\n-            NonZeroIntErrorKind::Underflow => \"number too small to fit in target type\",\n-            NonZeroIntErrorKind::Zero => \"number is 0\",\n-        }\n-    }\n-\n-}\n-\n-#[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n-impl fmt::Display for ParseNonZeroIntError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.__description().fmt(f)\n-    }\n-}\n-\n-\n macro_rules! from_str_radix_nzint_impl {\n     ($($t:ty)*) => {$(\n-        #[unstable(feature = \"nonzero_parse\", issue = \"0\")]\n+        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n         impl FromStr for $t {\n-            type Err = ParseNonZeroIntError;\n+            type Err = ParseIntError;\n             fn from_str(src: &str) -> Result<Self, Self::Err> {\n                 Self::new(from_str_radix(src, 10)?)\n-                    .ok_or(ParseNonZeroIntError {\n-                        kind: NonZeroIntErrorKind::Zero\n+                    .ok_or(ParseIntError {\n+                        kind: IntErrorKind::Zero\n                     })\n             }\n         }\n@@ -4968,6 +4880,11 @@ pub enum IntErrorKind {\n     Overflow,\n     /// Integer is too small to store in target integer type.\n     Underflow,\n+    /// Value was Zero\n+    ///\n+    /// This variant will be emitted when the parsing string has a value of zero, which\n+    /// would be illegal for non-zero types.\n+    Zero,\n }\n \n impl ParseIntError {\n@@ -4990,6 +4907,7 @@ impl ParseIntError {\n             IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n             IntErrorKind::Overflow => \"number too large to fit in target type\",\n             IntErrorKind::Underflow => \"number too small to fit in target type\",\n+            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n         }\n     }\n }"}, {"sha": "764b0c249f9cab55cda44b0703de2f868be7d9a9", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce30d4e1b947f8580636909c4c6f5aaeb254ea4c/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=ce30d4e1b947f8580636909c4c6f5aaeb254ea4c", "patch": "@@ -129,17 +129,23 @@ fn test_from_signed_nonzero() {\n \n #[test]\n fn test_from_str() {\n-    assert_eq!(FromStr::from_str(\"123\"), Ok(NonZeroU8::new(123).unwrap()));\n+    assert_eq!(\"123\".parse::<NonZeroU8>(), Ok(NonZeroU8::new(123).unwrap()));\n     assert_eq!(\n-        FromStr::from_str(\"0\"),\n-        Err(ParseNonZeroIntError {\n-            kind: NonZeroIntErrorKind::Zero\n+        \"0\".parse::<NonZeroU8>(),\n+        Err(ParseIntError {\n+            kind: IntErrorKind::Zero\n         })\n     );\n     assert_eq!(\n-        FromStr::from_str(\"-1\", \n-        Err(ParseNonZeroIntError {\n-            kind: NonZeroIntErrorKind::Underflow\n+        \"-1\".parse::<NonZeroU8>(),\n+        Err(ParseIntError {\n+            kind: IntErrorKind::Underflow\n+        })\n+    );\n+    assert_eq!(\n+        \"129\".parse::<NonZeroU8>(),\n+        Err(ParseIntError {\n+            kind: IntErrorKind::Overflow\n         })\n     );\n }"}]}