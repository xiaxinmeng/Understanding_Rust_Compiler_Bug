{"sha": "e2c84a78b4a3e95ea0def29172022ef4cf695958", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYzg0YTc4YjRhM2U5NWVhMGRlZjI5MTcyMDIyZWY0Y2Y2OTU5NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-09T21:11:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-09T21:11:56Z"}, "message": "auto merge of #13383 : ben0x539/rust/glob-dots, r=brson\n\nFixes #12930.", "tree": {"sha": "793ca5b48afeae1aaab984a2956d16670930a697", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/793ca5b48afeae1aaab984a2956d16670930a697"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2c84a78b4a3e95ea0def29172022ef4cf695958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c84a78b4a3e95ea0def29172022ef4cf695958", "html_url": "https://github.com/rust-lang/rust/commit/e2c84a78b4a3e95ea0def29172022ef4cf695958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2c84a78b4a3e95ea0def29172022ef4cf695958/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8801d891c4674f335fcdc67cb34237902d89a5ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8801d891c4674f335fcdc67cb34237902d89a5ec", "html_url": "https://github.com/rust-lang/rust/commit/8801d891c4674f335fcdc67cb34237902d89a5ec"}, {"sha": "1700f359bc5d6b8086194e3cc0f3698666dd41a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1700f359bc5d6b8086194e3cc0f3698666dd41a4", "html_url": "https://github.com/rust-lang/rust/commit/1700f359bc5d6b8086194e3cc0f3698666dd41a4"}], "stats": {"total": 128, "additions": 111, "deletions": 17}, "files": [{"sha": "d19924da5bedab10143ea74a56218e92152d7522", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 96, "deletions": 10, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e2c84a78b4a3e95ea0def29172022ef4cf695958/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c84a78b4a3e95ea0def29172022ef4cf695958/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=e2c84a78b4a3e95ea0def29172022ef4cf695958", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,6 +43,7 @@ use std::path::is_sep;\n pub struct Paths {\n     root: Path,\n     dir_patterns: Vec<Pattern>,\n+    require_dir: bool,\n     options: MatchOptions,\n     todo: Vec<(Path,uint)>,\n }\n@@ -51,7 +52,7 @@ pub struct Paths {\n /// Return an iterator that produces all the Paths that match the given pattern,\n /// which may be absolute or relative to the current working directory.\n ///\n-/// is method uses the default match options and is equivalent to calling\n+/// This method uses the default match options and is equivalent to calling\n /// `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n /// want to use non-default match options.\n ///\n@@ -106,6 +107,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n             return Paths {\n                 root: root,\n                 dir_patterns: Vec::new(),\n+                require_dir: false,\n                 options: options,\n                 todo: Vec::new(),\n             };\n@@ -117,13 +119,21 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n                        .split_terminator(is_sep)\n                        .map(|s| Pattern::new(s))\n-                       .collect();\n+                       .collect::<Vec<Pattern>>();\n+    let require_dir = pattern.chars().next_back().map(is_sep) == Some(true);\n \n-    let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).collect();\n+    let mut todo = Vec::new();\n+    if dir_patterns.len() > 0 {\n+        // Shouldn't happen, but we're using -1 as a special index.\n+        assert!(dir_patterns.len() < -1 as uint);\n+\n+        fill_todo(&mut todo, dir_patterns.as_slice(), 0, &root, options);\n+    }\n \n     Paths {\n         root: root,\n         dir_patterns: dir_patterns,\n+        require_dir: require_dir,\n         options: options,\n         todo: todo,\n     }\n@@ -138,6 +148,12 @@ impl Iterator<Path> for Paths {\n             }\n \n             let (path,idx) = self.todo.pop().unwrap();\n+            // idx -1: was already checked by fill_todo, maybe path was '.' or\n+            // '..' that we can't match here because of normalization.\n+            if idx == -1 as uint {\n+                if self.require_dir && !path.is_dir() { continue; }\n+                return Some(path);\n+            }\n             let ref pattern = *self.dir_patterns.get(idx);\n \n             if pattern.matches_with(match path.filename_str() {\n@@ -152,23 +168,27 @@ impl Iterator<Path> for Paths {\n                 if idx == self.dir_patterns.len() - 1 {\n                     // it is not possible for a pattern to match a directory *AND* its children\n                     // so we don't need to check the children\n-                    return Some(path);\n+\n+                    if !self.require_dir || path.is_dir() {\n+                        return Some(path);\n+                    }\n                 } else {\n-                    self.todo.extend(list_dir_sorted(&path).move_iter().map(|x|(x,idx+1)));\n+                    fill_todo(&mut self.todo, self.dir_patterns.as_slice(),\n+                              idx + 1, &path, self.options);\n                 }\n             }\n         }\n     }\n \n }\n \n-fn list_dir_sorted(path: &Path) -> Vec<Path> {\n+fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n     match fs::readdir(path) {\n         Ok(mut children) => {\n             children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            children.move_iter().collect()\n+            Some(children.move_iter().collect())\n         }\n-        Err(..) => Vec::new()\n+        Err(..) => None\n     }\n }\n \n@@ -435,6 +455,72 @@ impl Pattern {\n \n }\n \n+// Fills `todo` with paths under `path` to be matched by `patterns[idx]`,\n+// special-casing patterns to match `.` and `..`, and avoiding `readdir()`\n+// calls when there are no metacharacters in the pattern.\n+fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path: &Path,\n+             options: MatchOptions) {\n+    // convert a pattern that's just many Char(_) to a string\n+    fn pattern_as_str(pattern: &Pattern) -> Option<~str> {\n+        let mut s = ~\"\";\n+        for token in pattern.tokens.iter() {\n+            match *token {\n+                Char(c) => s.push_char(c),\n+                _ => return None\n+            }\n+        }\n+        return Some(s);\n+    }\n+\n+    let add = |todo: &mut Vec<_>, next_path: Path| {\n+        if idx + 1 == patterns.len() {\n+            // We know it's good, so don't make the iterator match this path\n+            // against the pattern again. In particular, it can't match\n+            // . or .. globs since these never show up as path components.\n+            todo.push((next_path, -1 as uint));\n+        } else {\n+            fill_todo(todo, patterns, idx + 1, &next_path, options);\n+        }\n+    };\n+\n+    let pattern = &patterns[idx];\n+\n+    match pattern_as_str(pattern) {\n+        Some(s) => {\n+            // This pattern component doesn't have any metacharacters, so we\n+            // don't need to read the current directory to know where to\n+            // continue. So instead of passing control back to the iterator,\n+            // we can just check for that one entry and potentially recurse\n+            // right away.\n+            let special = \".\" == s || \"..\" == s;\n+            let next_path = path.join(s);\n+            if (special && path.is_dir()) || (!special && next_path.exists()) {\n+                add(todo, next_path);\n+            }\n+        },\n+        None => {\n+            match list_dir_sorted(path) {\n+                Some(entries) => {\n+                    todo.extend(entries.move_iter().map(|x|(x, idx)));\n+\n+                    // Matching the special directory entries . and .. that refer to\n+                    // the current and parent directory respectively requires that\n+                    // the pattern has a leading dot, even if the `MatchOptions` field\n+                    // `require_literal_leading_dot` is not set.\n+                    if pattern.tokens.len() > 0 && pattern.tokens.get(0) == &Char('.') {\n+                        for &special in [\".\", \"..\"].iter() {\n+                            if pattern.matches_with(special, options) {\n+                                add(todo, path.join(special));\n+                            }\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+}\n+\n fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {\n     let mut cs = Vec::new();\n     let mut i = 0;\n@@ -567,7 +653,7 @@ mod test {\n     fn test_absolute_pattern() {\n         // assume that the filesystem is not empty!\n         assert!(glob(\"/*\").next().is_some());\n-        assert!(glob(\"//\").next().is_none());\n+        assert!(glob(\"//\").next().is_some());\n \n         // check windows absolute paths with host/device components\n         let root_with_device = os::getcwd().root_path().unwrap().join(\"*\");"}, {"sha": "2918d5776f0f4f7575217464cb257906bee429b4", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2c84a78b4a3e95ea0def29172022ef4cf695958/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c84a78b4a3e95ea0def29172022ef4cf695958/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=e2c84a78b4a3e95ea0def29172022ef4cf695958", "patch": "@@ -10,13 +10,12 @@\n \n // ignore-win32 TempDir may cause IoError on windows: #10462\n \n-#[feature(macro_rules)];\n+#![feature(macro_rules)]\n \n extern crate glob;\n \n use glob::glob;\n-use std::unstable::finally::Finally;\n-use std::{os, unstable};\n+use std::os;\n use std::io;\n use std::io::TempDir;\n \n@@ -29,9 +28,9 @@ macro_rules! assert_eq ( ($e1:expr, $e2:expr) => (\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            io::fs::mkdir(&Path::new(path), io::UserRWX);\n+            io::fs::mkdir(&Path::new(path), io::UserRWX).unwrap();\n         } else {\n-            io::File::create(&Path::new(path));\n+            io::File::create(&Path::new(path)).unwrap();\n         }\n     }\n \n@@ -72,8 +71,8 @@ pub fn main() {\n     mk_file(\"xyz/z\", false);\n \n     assert_eq!(glob_vec(\"\"), Vec::new());\n-    assert_eq!(glob_vec(\".\"), Vec::new());\n-    assert_eq!(glob_vec(\"..\"), Vec::new());\n+    assert_eq!(glob_vec(\".\"), vec!(os::getcwd()));\n+    assert_eq!(glob_vec(\"..\"), vec!(os::getcwd().join(\"..\")));\n \n     assert_eq!(glob_vec(\"aaa\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"aaa/\"), vec!(abs_path(\"aaa\")));\n@@ -131,6 +130,15 @@ pub fn main() {\n         abs_path(\"aaa/tomato/tomato.txt\"),\n         abs_path(\"aaa/tomato/tomoto.txt\")));\n \n+    assert_eq!(glob_vec(\"./aaa\"), vec!(abs_path(\"aaa\")));\n+    assert_eq!(glob_vec(\"./*\"), glob_vec(\"*\"));\n+    assert_eq!(glob_vec(\"*/..\").pop().unwrap(), abs_path(\".\"));\n+    assert_eq!(glob_vec(\"aaa/../bbb\"), vec!(abs_path(\"bbb\")));\n+    assert_eq!(glob_vec(\"nonexistent/../bbb\"), Vec::new());\n+    assert_eq!(glob_vec(\"aaa/tomato/tomato.txt/..\"), Vec::new());\n+\n+    assert_eq!(glob_vec(\"aaa/tomato/tomato.txt/\"), Vec::new());\n+\n     assert_eq!(glob_vec(\"aa[a]\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"aa[abc]\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"a[bca]a\"), vec!(abs_path(\"aaa\")));"}]}