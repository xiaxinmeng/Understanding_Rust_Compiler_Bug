{"sha": "a973e4cda5191040ca219fb4a4f8041e9b560301", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NzNlNGNkYTUxOTEwNDBjYTIxOWZiNGE0ZjgwNDFlOWI1NjAzMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-29T00:03:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-29T00:03:37Z"}, "message": "Auto merge of #26582 - jroesch:infer-ctxt-refactor, r=nikomatsakis\n\nThis branch begins the work of unifying our type checking contexts into a single piece of state. The goal is to eventually have a single context that we can pass around instead of the fractured situation we currently have. There are still several things that must be done before beginning to make tables item local:\r\n\r\n- [ ] move FulfillmentContext into InferCtxt\r\n- [ ] modify SelectionContext to only take a single context argument\r\n- [ ] remove remaining typer impls \r\n- [ ] remove the ClosureTyper + Typer trait\r\n- [ ] do some renaming to make these things more applicable to their new roles\r\n\r\nr? @nikomatsakis \r\n\r\nAs a side note there are a couple oddities that are temporary refactors that will be quickly cleaned up in a follow-up PR.\r\n\r\ncc @eddyb @Aatch @arielb1 @nrc", "tree": {"sha": "bc5e59e528305223710334dcb55d39786aa8fd52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc5e59e528305223710334dcb55d39786aa8fd52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a973e4cda5191040ca219fb4a4f8041e9b560301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a973e4cda5191040ca219fb4a4f8041e9b560301", "html_url": "https://github.com/rust-lang/rust/commit/a973e4cda5191040ca219fb4a4f8041e9b560301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a973e4cda5191040ca219fb4a4f8041e9b560301/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2671e8cee08eb35013dc211286a6765c80b49c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/2671e8cee08eb35013dc211286a6765c80b49c29", "html_url": "https://github.com/rust-lang/rust/commit/2671e8cee08eb35013dc211286a6765c80b49c29"}, {"sha": "5c3753f6b457dbc8e4cf0e8ec2d085d03f310911", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3753f6b457dbc8e4cf0e8ec2d085d03f310911", "html_url": "https://github.com/rust-lang/rust/commit/5c3753f6b457dbc8e4cf0e8ec2d085d03f310911"}], "stats": {"total": 937, "additions": 586, "deletions": 351}, "files": [{"sha": "2cec42b76bce3359e8f772ea1bda80a492cbabd3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -61,6 +61,7 @@\n #![feature(str_match_indices)]\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n+#![feature(cell_extras)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "d2c79e1d820bf98751cb81b562eda485f0f5006d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -1027,7 +1027,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n+    if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_substs(ecx, &item_substs.substs);\n@@ -1051,7 +1051,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n+                let upvar_capture = tcx.tables\n+                                       .borrow()\n+                                       .upvar_capture_map\n+                                       .get(&upvar_id)\n+                                       .unwrap()\n+                                       .clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })\n@@ -1074,19 +1079,19 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n         })\n     }\n \n-    if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n+    if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+                    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             encode_method_callee(ecx, rbml_w,\n@@ -1104,14 +1109,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n-    if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             encode_closure_kind(rbml_w, *closure_kind)\n@@ -1630,7 +1635,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let item_substs = ty::ItemSubsts {\n                             substs: val_dsr.read_substs(dcx)\n                         };\n-                        dcx.tcx.item_substs.borrow_mut().insert(\n+                        dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n@@ -1646,7 +1651,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             closure_expr_id: id\n                         };\n                         let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_capture_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n+                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n@@ -1663,22 +1668,22 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             expr_id: id,\n                             autoderef: autoderef\n                         };\n-                        dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n+                        dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n-                        dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n+                        dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n                     c::tag_table_closure_tys => {\n                         let closure_ty =\n                             val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.closure_tys.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_tys.insert(ast_util::local_def(id),\n                                                                 closure_ty);\n                     }\n                     c::tag_table_closure_kinds => {\n                         let closure_kind =\n                             val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n                     c::tag_table_cast_kinds => {"}, {"sha": "7d62b6ff900408e62de48bd258153df79f68736e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -411,7 +411,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.method_map.borrow().get(&method_call) {\n+        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n             Some(method) => method.ty,\n             None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n         };\n@@ -634,6 +634,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         let method_call = ty::MethodCall::expr(expr.id);\n-        self.tcx.method_map.borrow().contains_key(&method_call)\n+        self.tcx.tables.borrow().method_map.contains_key(&method_call)\n     }\n }"}, {"sha": "8bbb6ae757fc1e1f0c63cd31dc9e7e791b79809d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -283,12 +283,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n         let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = self.tcx.empty_parameter_environment();\n-        match fulfill_cx.select_all_or_error(&infcx, &env) {\n+        match fulfill_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);\n@@ -544,7 +543,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match e.node {\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n-        ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n+        ast::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n@@ -695,7 +694,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_did = match v.tcx.method_map.borrow()[&method_call].origin {\n+            let method_did = match v.tcx.tables.borrow().method_map[&method_call].origin {\n                 ty::MethodStatic(did) => Some(did),\n                 _ => None\n             };"}, {"sha": "f61884e213666046ba54f91ec1897c1543a22c49", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -98,6 +98,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n     }\n }\n \n+//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub param_env: ParameterEnvironment<'a, 'tcx>,"}, {"sha": "a6b7d7f832a3cce31680729552231baafebbf60c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -1031,10 +1031,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n-    let param_env = tcx.empty_parameter_environment();\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {"}, {"sha": "d8ee38b847830f941f2eaeceef92f8d0b70f8a87", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = ty::MethodCall::expr(id);\n-        match self.tcx.method_map.borrow().get(&method_call) {\n+        match self.tcx.tables.borrow().method_map.get(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     ty::MethodStatic(def_id) => {"}, {"sha": "8084c2b0c39b884a677ee86da98c5889bd282530", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n+                let base_type = self.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "25728c50c61f4a6784ae7fccd8d52aa3c7634970", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -257,8 +257,9 @@ impl OverloadedCallType {\n     fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n                     -> OverloadedCallType {\n         let trait_did =\n-            tcx.closure_kinds\n+            tcx.tables\n                .borrow()\n+               .closure_kinds\n                .get(&closure_did)\n                .expect(\"OverloadedCallType::from_closure: didn't find closure id\")\n                .trait_did(tcx);\n@@ -787,8 +788,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        if let Some(adjustment) = typer.adjustments().borrow().get(&expr.id) {\n-            match *adjustment {\n+        //NOTE(@jroesch): mixed RefCell borrow causes crash\n+        let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n+        if let Some(adjustment) = adj {\n+            match adjustment {\n                 ty::AdjustReifyFnPointer |\n                 ty::AdjustUnsafeFnPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes"}, {"sha": "c355e8b82a6ef9f201b8fe8b982ded75db45cff6", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 201, "deletions": 3, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -23,19 +23,24 @@ pub use self::freshen::TypeFreshener;\n pub use self::region_inference::GenericKind;\n \n use middle::free_region::FreeRegionMap;\n+use middle::mem_categorization as mc;\n+use middle::mem_categorization::McResult;\n+use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n+use middle::subst::Subst;\n+use middle::traits;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{RefCell};\n+use std::cell::{RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -64,6 +69,8 @@ pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n+    pub tables: &'a RefCell<ty::Tables<'tcx>>,\n+\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n@@ -77,6 +84,17 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'tcx>,\n+\n+    pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n+\n+    // This is a temporary field used for toggling on normalization in the inference context,\n+    // as we move towards the approach described here:\n+    // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n+    // At a point sometime in the future normalization will be done by the typing context\n+    // directly.\n+    normalize: bool,\n+\n+    err_count_on_creation: usize,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -309,14 +327,20 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n-pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n+pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                tables: &'a RefCell<ty::Tables<'tcx>>,\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n+        tables: tables,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n+        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+        normalize: false,\n+        err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n@@ -431,6 +455,127 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+impl<'a, 'tcx> mc::Typer<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        let ty = self.node_ty(id);\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        !traits::type_known_to_meet_builtin_bound(self, self, ty, ty::BoundCopy, span)\n+    }\n+\n+    fn node_method_ty(&self, method_call: ty::MethodCall)\n+                      -> Option<Ty<'tcx>> {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.ty)\n+            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n+    }\n+\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n+\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n+                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tables.borrow(), project_adjustments)\n+    }\n+\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n+    }\n+\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n+        self.parameter_environment.temporary_scope(rvalue_id)\n+    }\n+\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.parameter_environment\n+    }\n+\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n+        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+    }\n+\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n+    {\n+\n+        let closure_ty = self.tables\n+                             .borrow()\n+                             .closure_tys\n+                             .get(&def_id)\n+                             .unwrap()\n+                             .subst(self.tcx, substs);\n+\n+        if self.normalize {\n+            // NOTE: this flag is currently *always* set to false, we are slowly folding\n+            // normalization into this trait and will come back to remove this in the near\n+            // future.\n+\n+            // code from NormalizingClosureTyper:\n+            // the substitutions in `substs` are already monomorphized,\n+            // but we still must normalize associated types\n+            // normalize_associated_type(self.param_env.tcx, &closure_ty)\n+            panic!(\"see issue 26597: fufillment context refactor must occur\")\n+        } else {\n+            closure_ty\n+        }\n+    }\n+\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n+    {\n+        let result = ty::ctxt::closure_upvars(self, def_id, substs);\n+\n+        if self.normalize {\n+            // NOTE: this flag is currently *always* set to false, we are slowly folding\n+            // normalization into this trait and will come back to remove this in the near\n+            // future.\n+\n+            // code from NormalizingClosureTyper:\n+            // the substitutions in `substs` are already monomorphized,\n+            // but we still must normalize associated types\n+            // monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n+            panic!(\"see issue 26597: fufillment context refactor must occur\")\n+        } else {\n+            result\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n@@ -852,6 +997,49 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n+    /// Apply `adjustment` to the type of `expr`\n+    pub fn adjust_expr_ty(&self,\n+                          expr: &ast::Expr,\n+                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          -> Ty<'tcx>\n+    {\n+        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.shallow_resolve(raw_ty);\n+        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n+        raw_ty.adjust(self.tcx,\n+                      expr.span,\n+                      expr.id,\n+                      adjustment,\n+                      |method_call| self.tables\n+                                        .borrow()\n+                                        .method_map\n+                                        .get(&method_call)\n+                                        .map(|method| resolve_ty(method.ty)))\n+    }\n+\n+    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&id) {\n+            Some(&t) => t,\n+            // FIXME\n+            None if self.tcx.sess.err_count() - self.err_count_on_creation != 0 =>\n+                self.tcx.types.err,\n+            None => {\n+                self.tcx.sess.bug(\n+                    &format!(\"no type for node {}: {} in fcx\",\n+                            id, self.tcx.map.node_to_string(id)));\n+            }\n+        }\n+    }\n+\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&ex.id) {\n+            Some(&t) => t,\n+            None => {\n+                self.tcx.sess.bug(&format!(\"no type for expr in fcx\"));\n+            }\n+        }\n+    }\n+\n     pub fn resolve_regions_and_report_errors(&self,\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n@@ -926,6 +1114,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    /// Resolves all type variables in `t` and then, if any were left\n+    /// unresolved, substitutes an error type. This is used after the\n+    /// main checking when doing a second pass before writeback. The\n+    /// justification is that writeback will produce an error for\n+    /// these unconstrained type variables.\n+    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let ty = self.resolve_type_vars_if_possible(t);\n+        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n+    }\n+\n     pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> fres<T> {\n         /*!\n          * Attempts to resolve all type/region variables in"}, {"sha": "7d237a511c4a173240da94101c01a582c85f6dae", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -1150,7 +1150,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n+            let method_ty = self.ir.tcx.tables.borrow().method_map.get(&method_call).unwrap().ty;\n             let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {"}, {"sha": "13e127e9126139caed875c100b53c51d17c7b09c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -83,7 +83,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n \n-use std::cell::RefCell;\n+use std::cell::Ref;\n use std::fmt;\n use std::rc::Rc;\n \n@@ -289,7 +289,7 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>;\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n@@ -408,7 +408,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n-            self.typer.adjustments().borrow().get(&expr.id),\n+            self.typer.adjustments().get(&expr.id),\n             |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n@@ -440,7 +440,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        match self.typer.adjustments().borrow().get(&expr.id) {\n+        match self.typer.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)"}, {"sha": "6ea726062cad6eab58668bc5dbb82a590f18bf68", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n+                match self.tcx.tables.borrow().method_map.get(&method_call).unwrap().origin {\n                     ty::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "e6bbae6405bf4f8c4f02ef04a8151a30490e4e72", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -406,7 +406,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n-            match tcx.method_map.borrow().get(&method_call) {\n+            match tcx.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         ty::MethodStatic(def_id) => {"}, {"sha": "9df6ed5d68126cf7923bf2d0a6d02b1f3c7b708b", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -351,6 +351,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+// FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n                                              cause: ObligationCause<'tcx>)\n@@ -396,13 +397,13 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = match fully_normalize(&infcx, &elaborated_env, cause,\n-                                           &elaborated_env.caller_bounds) {\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let predicates = match fully_normalize(&infcx, &infcx.parameter_environment, cause,\n+                                           &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n             report_fulfillment_errors(&infcx, &errors);\n-            return unnormalized_env; // an unnormalized env is better than nothing\n+            return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };\n \n@@ -420,11 +421,11 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n             // all things considered.\n             let err_msg = fixup_err_to_string(fixup_err);\n             tcx.sess.span_err(span, &err_msg);\n-            return elaborated_env; // an unnormalized env is better than nothing\n+            return infcx.parameter_environment; // an unnormalized env is better than nothing\n         }\n     };\n \n-    elaborated_env.with_caller_bounds(predicates)\n+    infcx.parameter_environment.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,"}, {"sha": "ae15c8aa8e028379eda46f5a0d62f57fdd6d86e1", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -54,6 +54,7 @@ use util::nodemap::FnvHashMap;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n+\n     closure_typer: &'cx (ty::ClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n@@ -77,6 +78,7 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n+\n     intercrate: bool,\n }\n "}, {"sha": "489ce7bc4cf78c102eb07846f8d5fd17dcec4f97", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 73, "deletions": 47, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -728,7 +728,7 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap<'tcx> = RefCell<FnvHashMap<MethodCall, MethodCallee<'tcx>>>;\n+pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -815,6 +815,48 @@ pub struct CommonTypes<'tcx> {\n     pub err: Ty<'tcx>,\n }\n \n+pub struct Tables<'tcx> {\n+    /// Stores the types for various nodes in the AST.  Note that this table\n+    /// is not guaranteed to be populated until after typeck.  See\n+    /// typeck::check::fn_ctxt for details.\n+    pub node_types: NodeMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node.  This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    pub item_substs: NodeMap<ItemSubsts<'tcx>>,\n+\n+    pub adjustments: NodeMap<ty::AutoAdjustment<'tcx>>,\n+\n+    pub method_map: MethodMap<'tcx>,\n+\n+    /// Borrows\n+    pub upvar_capture_map: UpvarCaptureMap,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: DefIdMap<ClosureTy<'tcx>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: DefIdMap<ClosureKind>,\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn empty() -> Tables<'tcx> {\n+        Tables {\n+            node_types: FnvHashMap(),\n+            item_substs: NodeMap(),\n+            adjustments: NodeMap(),\n+            method_map: FnvHashMap(),\n+            upvar_capture_map: FnvHashMap(),\n+            closure_tys: DefIdMap(),\n+            closure_kinds: DefIdMap(),\n+        }\n+    }\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -850,17 +892,9 @@ pub struct ctxt<'tcx> {\n     // borrowck. (They are not used during trans, and hence are not\n     // serialized or needed for cross-crate fns.)\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n+    // FIXME: jroesch make this a refcell\n \n-    /// Stores the types for various nodes in the AST.  Note that this table\n-    /// is not guaranteed to be populated until after typeck.  See\n-    /// typeck::check::fn_ctxt for details.\n-    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n-\n-    /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node.  This only applies to nodes that refer to entities\n-    /// parameterized by type parameters, such as generic fns, types, or\n-    /// other items.\n-    pub item_substs: RefCell<NodeMap<ItemSubsts<'tcx>>>,\n+    pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub impl_or_trait_items: RefCell<DefIdMap<ImplOrTraitItem<'tcx>>>,\n@@ -894,7 +928,6 @@ pub struct ctxt<'tcx> {\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n-    pub adjustments: RefCell<NodeMap<AutoAdjustment<'tcx>>>,\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n@@ -944,26 +977,13 @@ pub struct ctxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// Borrows\n-    pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n-\n     /// These caches are used by const_eval when decoding external constants.\n     pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n \n-    pub method_map: MethodMap<'tcx>,\n-\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: RefCell<DefIdMap<ClosureKind>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: RefCell<DefIdMap<ClosureTy<'tcx>>>,\n-\n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n@@ -1000,9 +1020,16 @@ pub struct ctxt<'tcx> {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> { self.node_types.borrow() }\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) ->  &'a NodeMap<Ty<'tcx>> {\n+            &tables.node_types\n+        }\n+\n+        Ref::map(self.tables.borrow(), projection)\n+    }\n+\n     pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n-        self.node_types.borrow_mut().insert(id, ty);\n+        self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n     pub fn intern_trait_def(&self, def: TraitDef<'tcx>) -> &'tcx TraitDef<'tcx> {\n@@ -3421,8 +3448,7 @@ impl<'tcx> ctxt<'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             def_map: def_map,\n-            node_types: RefCell::new(FnvHashMap()),\n-            item_substs: RefCell::new(NodeMap()),\n+            tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DefIdMap()),\n             trait_defs: RefCell::new(DefIdMap()),\n             predicates: RefCell::new(DefIdMap()),\n@@ -3439,7 +3465,6 @@ impl<'tcx> ctxt<'tcx> {\n             trait_item_def_ids: RefCell::new(DefIdMap()),\n             trait_items_cache: RefCell::new(DefIdMap()),\n             ty_param_defs: RefCell::new(NodeMap()),\n-            adjustments: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             provided_method_sources: RefCell::new(DefIdMap()),\n@@ -3452,14 +3477,10 @@ impl<'tcx> ctxt<'tcx> {\n             used_mut_nodes: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n-            upvar_capture_map: RefCell::new(FnvHashMap()),\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_variants: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n-            method_map: RefCell::new(FnvHashMap()),\n             dependency_formats: RefCell::new(FnvHashMap()),\n-            closure_kinds: RefCell::new(DefIdMap()),\n-            closure_tys: RefCell::new(DefIdMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n             transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),\n@@ -3515,15 +3536,15 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        *self.closure_kinds.borrow().get(&def_id).unwrap()\n+        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closure_tys.borrow().get(&def_id).unwrap().subst(self, substs)\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, substs)\n     }\n \n     pub fn type_parameter_def(&self,\n@@ -4369,7 +4390,8 @@ impl<'tcx> TyS<'tcx> {\n                        span: Span)\n                        -> bool\n     {\n-        let infcx = infer::new_infer_ctxt(param_env.tcx());\n+        let tcx = param_env.tcx();\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env,\n                                                                 self, bound, span);\n@@ -5276,11 +5298,11 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn node_id_to_type_opt(&self, id: ast::NodeId) -> Option<Ty<'tcx>> {\n-        self.node_types.borrow().get(&id).cloned()\n+        self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n     pub fn node_id_item_substs(&self, id: ast::NodeId) -> ItemSubsts<'tcx> {\n-        match self.item_substs.borrow().get(&id) {\n+        match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts::empty(),\n             Some(ts) => ts.clone(),\n         }\n@@ -5325,9 +5347,9 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         self.expr_ty(expr)\n             .adjust(self, expr.span, expr.id,\n-                    self.adjustments.borrow().get(&expr.id),\n+                    self.tables.borrow().adjustments.get(&expr.id),\n                     |method_call| {\n-            self.method_map.borrow().get(&method_call).map(|method| method.ty)\n+            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n         })\n     }\n \n@@ -6671,11 +6693,11 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n-        self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n+        self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n+        Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n }\n \n@@ -6689,17 +6711,21 @@ impl<'a,'tcx> Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-        self.tcx.method_map.borrow().get(&method_call).map(|method| method.ty)\n+        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n     }\n \n     fn node_method_origin(&self, method_call: ty::MethodCall)\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n-        self.tcx.method_map.borrow().get(&method_call).map(|method| method.origin.clone())\n+        self.tcx.tables.borrow().method_map.get(&method_call).map(|method| method.origin.clone())\n     }\n \n-    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.tcx.adjustments\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tcx.tables.borrow(), projection)\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {"}, {"sha": "de2f33e8a4ac9dd3233639804f2428759eec7e17", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -688,7 +688,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyStr => write!(f, \"str\"),\n             TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n-                let closure_tys = tcx.closure_tys.borrow();\n+                let closure_tys = &tcx.tables.borrow().closure_tys;\n                 try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n                     tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n                 }).map(|sig| {"}, {"sha": "80c4fc28703ac78dd131925ea13376a7d2aefa2e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -602,7 +602,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> (Session, R)\n-                                               where F: FnOnce(&ty::ctxt<'tcx>,\n+                                               where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n                                                                ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();"}, {"sha": "fb2f6b2b08db8e8e2f6d2644d6f8416ef96eee4f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -140,7 +140,7 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-        let infcx = infer::new_infer_ctxt(tcx);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n         body(Env { infcx: &infcx });\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);"}, {"sha": "db48608823d216e1f8278a79b08e4cab0d2cd447", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -1446,7 +1446,7 @@ impl LintPass for UnusedAllocation {\n             _ => return\n         }\n \n-        if let Some(adjustment) = cx.tcx.adjustments.borrow().get(&e.id) {\n+        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n             if let ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) = *adjustment {\n                 match autoref {\n                     &Some(ty::AutoPtr(_, ast::MutImmutable)) => {\n@@ -1984,7 +1984,7 @@ impl LintPass for UnconditionalRecursion {\n                                           method_id: ast::NodeId,\n                                           method_name: ast::Ident,\n                                           id: ast::NodeId) -> bool {\n-            let did = match tcx.method_map.borrow().get(&ty::MethodCall::expr(id)) {\n+            let did = match tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)) {\n                 None => return false,\n                 Some(m) => match m.origin {\n                     // There's no way to know if a method call via a"}, {"sha": "239141df9e8c7be7274d0fd8742aab53daa83a05", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -904,7 +904,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().get(&method_call) {\n+                match self.tcx.tables.borrow().method_map.get(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\"}, {"sha": "dc692b0e765dd5e9949a920067bdf687ebc99bc4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -43,6 +43,7 @@\n #![feature(unicode)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n+#![feature(cell_extras)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "d86242f39cea7763e94e9d3ebff435a0402059f4", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -886,7 +886,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n-        let method_map = self.tcx.method_map.borrow();\n+        let method_map = &self.tcx.tables.borrow().method_map;\n         let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |"}, {"sha": "0cd6bbad03aa9206dfbc3789c62f0f15277e89ac", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -212,7 +212,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n+    *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,"}, {"sha": "dfe807d6c9152012511317d7a797587c6269f2cd", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -518,7 +518,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => tcx.node_id_to_type(id),\n                 MethodCallKey(method_call) => {\n-                    tcx.method_map.borrow().get(&method_call).unwrap().ty\n+                    tcx.tables.borrow().method_map.get(&method_call).unwrap().ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,\n@@ -610,7 +610,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={:?})\", call_expr);\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n+    let method_ty = match bcx.tcx().tables.borrow().method_map.get(&method_call) {\n         Some(method) => match method.origin {\n             ty::MethodTraitObject(_) => match method.ty.sty {\n                 ty::TyBareFn(_, ref fty) => {"}, {"sha": "b6378062855400c5b885961feede03c4ca34f11a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -130,7 +130,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n                                                       closure_id: ast::DefId,\n                                                       substs: &Substs<'tcx>)\n                                                       -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().closure_kinds.borrow().contains_key(&closure_id) {\n+    if !ccx.tcx().tables.borrow().closure_kinds.contains_key(&closure_id) {\n         // Not a closure.\n         return None\n     }"}, {"sha": "483d82f508f25a8ec84ffbaabe0023fac3a675b9", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -47,7 +47,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n@@ -353,7 +353,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // section of the executable we're generating.\n     pub llfn: ValueRef,\n \n-    // always an empty parameter-environment\n+    // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n     pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n     // The environment argument in a closure.\n@@ -630,8 +630,9 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n         self.tcx()\n-            .method_map\n+            .tables\n             .borrow()\n+            .method_map\n             .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n@@ -640,26 +641,34 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n                           -> Option<ty::MethodOrigin<'tcx>>\n     {\n         self.tcx()\n-            .method_map\n+            .tables\n             .borrow()\n+            .method_map\n             .get(&method_call)\n             .map(|method| method.origin.clone())\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.tcx().adjustments\n+    fn adjustments<'a>(&'a self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        // FIXME (@jroesch): this is becuase we currently have a HR inference problem\n+        // in the snapshot that causes this code not to work.\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) ->\n+            &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tcx().tables.borrow(), project_adjustments)\n     }\n \n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+        self.tcx().tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n+        Some(self.tcx().tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n     fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -991,7 +1000,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -1053,7 +1062,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new(false);\n@@ -1070,6 +1079,10 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n+// NOTE: here is another use of parameter environment without an InferCtxt,\n+// this is obviously related to the typer interface requiring a parameter env.\n+// We should pay attention to this when refactoring\n+// - @jroesch\n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n@@ -1191,7 +1204,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             tcx.node_id_item_substs(id).substs\n         }\n         MethodCallKey(method_call) => {\n-            tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n+            tcx.tables.borrow().method_map.get(&method_call).unwrap().substs.clone()\n         }\n     };\n "}, {"sha": "57af688ef60d7bea7af9e1a5d9f098fc2f64081a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -228,7 +228,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n                 def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n-                    if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+                    if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                         debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n                                expr.id, def_id);\n                         return get_const_val(ccx, def_id, expr);\n@@ -281,7 +281,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n-    let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n+    let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n         Some(ty::AdjustReifyFnPointer) => {\n             // FIXME(#19925) once fn item types are\n@@ -894,7 +894,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprMethodCall(_, _, ref args) => {\n               let arg_vals = map_list(args);\n               let method_call = ty::MethodCall::expr(e.id);\n-              let method_did = match cx.tcx().method_map.borrow()[&method_call].origin {\n+              let method_did = match cx.tcx().tables.borrow().method_map[&method_call].origin {\n                   ty::MethodStatic(did) => did,\n                   _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n               };"}, {"sha": "045cc69bf954b26c357015ed0e80c5edce398d88", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -117,7 +117,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    if bcx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+    if bcx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n         // use trans, which may be less efficient but\n         // which will perform the adjustments:\n         let datum = unpack_datum!(bcx, trans(bcx, expr));\n@@ -345,7 +345,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let mut bcx = bcx;\n     let mut datum = datum;\n-    let adjustment = match bcx.tcx().adjustments.borrow().get(&expr.id).cloned() {\n+    let adjustment = match bcx.tcx().tables.borrow().adjustments.get(&expr.id).cloned() {\n         None => {\n             return DatumBlock::new(bcx, datum);\n         }\n@@ -372,7 +372,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     // Don't skip a conversion from Box<T> to &T, etc.\n                     ty::TyRef(..) => {\n                         let method_call = MethodCall::autoderef(expr.id, 0);\n-                        if bcx.tcx().method_map.borrow().contains_key(&method_call) {\n+                        if bcx.tcx().tables.borrow().method_map.contains_key(&method_call) {\n                             // Don't skip an overloaded deref.\n                             0\n                         } else {\n@@ -774,8 +774,9 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Check for overloaded index.\n     let method_ty = ccx.tcx()\n-                       .method_map\n+                       .tables\n                        .borrow()\n+                       .method_map\n                        .get(&method_call)\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n@@ -1617,7 +1618,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.tcx().method_map.borrow().contains_key(&method_call));\n+        !ccx.tcx().tables.borrow().method_map.contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1910,7 +1911,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n \n     match op.node {\n         ast::BiAnd => {\n@@ -1950,7 +1951,12 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).unwrap().ty;\n+    let method_ty = bcx.tcx()\n+                       .tables\n+                       .borrow()\n+                       .method_map\n+                       .get(&method_call).unwrap().ty;\n+\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n@@ -1973,8 +1979,9 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_overloaded_call {}\", expr.id);\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n-                         .method_map\n+                         .tables\n                          .borrow()\n+                         .method_map\n                          .get(&method_call)\n                          .unwrap()\n                          .ty;\n@@ -2154,7 +2161,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -2229,8 +2236,12 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n \n     // Check for overloaded deref.\n-    let method_ty = ccx.tcx().method_map.borrow()\n+    let method_ty = ccx.tcx()\n+                       .tables\n+                       .borrow()\n+                       .method_map\n                        .get(&method_call).map(|method| method.ty);\n+\n     let datum = match method_ty {\n         Some(method_ty) => {\n             let method_ty = monomorphize_type(bcx, method_ty);\n@@ -2615,7 +2626,7 @@ enum ExprKind {\n }\n \n fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n-    if tcx.method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n+    if tcx.tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:\n         return match expr.node {"}, {"sha": "e46c3b5fab1f784e7a34ebbc55f5a3e4c44ca580", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -109,11 +109,13 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) =\n-        bcx.tcx().method_map\n-                 .borrow()\n-                 .get(&method_call)\n-                 .map(|method| (method.origin.clone(), method.ty))\n-                 .unwrap();\n+        bcx.tcx()\n+           .tables\n+           .borrow()\n+           .method_map\n+           .get(&method_call)\n+           .map(|method| (method.origin.clone(), method.ty))\n+           .unwrap();\n \n     match origin {\n         ty::MethodStatic(did) |"}, {"sha": "67ccf64621a854cf0e17037738e2ee0993657462", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -322,8 +322,9 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     }\n \n     // FIXME(#20304) -- cache\n-\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    // NOTE: @jroesch\n+    // Here is of an example where we do not use a param_env but use a typer instead.\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();"}, {"sha": "d29c0494572cb4d3e9b098bc6b029e7f59912c0c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -137,9 +137,9 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // Check whether this is a call to a closure where we\n             // haven't yet decided on whether the closure is fn vs\n             // fnmut vs fnonce. If so, we have to defer further processing.\n-            if fcx.closure_kind(def_id).is_none() {\n+            if fcx.infcx().closure_kind(def_id).is_none() {\n                 let closure_ty =\n-                    fcx.closure_type(def_id, substs);\n+                    fcx.infcx().closure_type(def_id, substs);\n                 let fn_sig =\n                     fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                           infer::FnCall,\n@@ -324,7 +324,7 @@ fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              call_expr: &ast::Expr,\n                                              method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n-    fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n+    fcx.inh.tables.borrow_mut().method_map.insert(method_call, method_callee);\n }\n \n #[derive(Debug)]\n@@ -344,7 +344,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id).is_some());\n+        assert!(fcx.infcx().closure_kind(self.closure_def_id).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,"}, {"sha": "b5ee46ece94be16d505654aaa7dc5f7d68b6bf8b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -61,7 +61,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         expected_sig);\n \n     let closure_type = fcx.ccx.tcx.mk_closure(expr_def_id,\n-        fcx.ccx.tcx.mk_substs(fcx.inh.param_env.free_substs.clone()));\n+        fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n@@ -86,9 +86,9 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            fn_ty.sig,\n            opt_kind);\n \n-    fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n+    fcx.inh.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n     match opt_kind {\n-        Some(kind) => { fcx.inh.closure_kinds.borrow_mut().insert(expr_def_id, kind); }\n+        Some(kind) => { fcx.inh.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n         None => { }\n     }\n }"}, {"sha": "b38b6884a98ad639688ca6e2ed0cc970bf113562", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -273,7 +273,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n         let source = source.adjust_for_autoref(self.tcx(), reborrow);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();"}, {"sha": "f62411e85828de96c2fcabc219d83d19b55052d6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -43,7 +43,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -240,11 +240,13 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n     let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n                                                                normalize_cause.clone());\n+    // FIXME(@jroesch) this seems ugly, but is a temporary change\n+    infcx.parameter_environment = trait_param_env;\n \n     debug!(\"compare_impl_method: trait_bounds={:?}\",\n-        trait_param_env.caller_bounds);\n+        infcx.parameter_environment.caller_bounds);\n \n-    let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n \n     for predicate in impl_pred.fns {\n         let traits::Normalized { value: predicate, .. } =\n@@ -345,7 +347,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n-    match fulfillment_cx.select_all_or_error(&infcx, &trait_param_env) {\n+    match fulfillment_cx.select_all_or_error(&infcx, &infcx.parameter_environment) {\n         Err(ref errors) => { traits::report_fulfillment_errors(&infcx, errors) }\n         Ok(_) => {}\n     }\n@@ -360,7 +362,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // anyway, so it shouldn't be needed there either. Anyway, we can\n     // always add more relations later (it's backwards compat).\n     let mut free_regions = FreeRegionMap::new();\n-    free_regions.relate_free_regions_from_predicates(tcx, &trait_param_env.caller_bounds);\n+    free_regions.relate_free_regions_from_predicates(tcx,\n+                                                     &infcx.parameter_environment.caller_bounds);\n \n     infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n \n@@ -416,7 +419,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "6f0fbfebf46cc8fd37192d5b5a6833c7a1452b5b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -93,7 +93,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                          ty: named_type } =\n         tcx.lookup_item_type(self_type_did);\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+\n     infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);"}, {"sha": "9c2d1c4a34df1dbd9a3d9337b5054229eb5410fb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -488,8 +488,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n-                                            .adjustments\n+                                            .tables\n                                             .borrow()\n+                                            .adjustments\n                                             .get(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n@@ -527,7 +528,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         // expects. This is annoying and horrible. We\n                         // ought to recode this routine so it doesn't\n                         // (ab)use the normal type checking paths.\n-                        let adj = self.fcx.inh.adjustments.borrow().get(&base_expr.id).cloned();\n+                        let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n+                                                                          .cloned();\n                         let (autoderefs, unsize) = match adj {\n                             Some(ty::AdjustDerefRef(adr)) => match adr.autoref {\n                                 None => {\n@@ -589,7 +591,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         // if this is an overloaded deref, then re-evaluate with\n                         // a preference for mut\n                         let method_call = MethodCall::expr(expr.id);\n-                        if self.fcx.inh.method_map.borrow().contains_key(&method_call) {\n+                        if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n                             check::try_overloaded_deref(\n                                 self.fcx,\n                                 expr.span,"}, {"sha": "f312db9c4dcf2b75ff48925020a294cb16c6699f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -195,7 +195,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                               poly_trait_ref.to_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx);\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible."}, {"sha": "94a2050829dfa3213f332ab7a579f7f7cfa3d503", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -421,7 +421,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n@@ -477,7 +477,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let bounds: Vec<_> =\n-            self.fcx.inh.param_env.caller_bounds\n+            self.fcx.inh.infcx.parameter_environment.caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -681,7 +681,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // as it will pollute the fcx's fulfillment context after this probe\n             // is over.\n             let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n@@ -742,7 +742,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 _ => continue,\n             };\n \n-            let closure_kinds = self.fcx.inh.closure_kinds.borrow();\n+            let closure_kinds = &self.fcx.inh.tables.borrow().closure_kinds;\n             let closure_kind = match closure_kinds.get(&closure_def_id) {\n                 Some(&k) => k,\n                 None => {\n@@ -845,7 +845,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n+        let caller_predicates = self.fcx.inh.infcx.parameter_environment.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n                           .filter_map(|p| p.to_opt_poly_trait_ref())\n                           .filter(|b| b.def_id() == trait_def_id)\n@@ -1076,7 +1076,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n-                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx);\n+                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx.infcx());\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about."}, {"sha": "b81b672e684a5aa76f740a2e25615e60f25920c7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -102,7 +102,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             let obligation = Obligation::misc(span,\n                                                               fcx.body_id,\n                                                               poly_trait_ref.to_predicate());\n-                            let mut selcx = SelectionContext::new(infcx, fcx);\n+                            let mut selcx = SelectionContext::new(infcx, fcx.infcx());\n \n                             if selcx.evaluate_obligation(&obligation) {\n                                 span_stored_function();"}, {"sha": "7e87dc6540ea517f122b631c29beef3ec5e7a7d0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 127, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -87,8 +87,6 @@ use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::def;\n use middle::infer;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n@@ -97,7 +95,7 @@ use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n-use middle::ty::{MethodCall, MethodCallee, MethodMap};\n+use middle::ty::{MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n@@ -152,16 +150,8 @@ mod op;\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // Temporary tables:\n-    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n-    item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n-    adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n-    method_map: MethodMap<'tcx>,\n-    upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n-    closure_tys: RefCell<DefIdMap<ty::ClosureTy<'tcx>>>,\n-    closure_kinds: RefCell<DefIdMap<ty::ClosureKind>>,\n+    tables: &'a RefCell<ty::Tables<'tcx>>,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n@@ -298,90 +288,16 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        let ty = self.node_ty(id);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.inh.adjustments.borrow().get(&expr.id));\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        !traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n-    }\n-    fn node_method_ty(&self, method_call: ty::MethodCall)\n-                      -> Option<Ty<'tcx>> {\n-        self.inh.method_map.borrow()\n-                           .get(&method_call)\n-                           .map(|method| method.ty)\n-                           .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n-    }\n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.inh.method_map.borrow()\n-                           .get(&method_call)\n-                           .map(|method| method.origin.clone())\n-    }\n-    fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        &self.inh.adjustments\n-    }\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.inh.method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n-    }\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n-        self.param_env().temporary_scope(rvalue_id)\n-    }\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        self.inh.upvar_capture_map.borrow().get(&upvar_id).cloned()\n-    }\n-}\n-\n-impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.inh.param_env\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        self.inh.closure_kinds.borrow().get(&def_id).cloned()\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        self.inh.closure_tys.borrow().get(&def_id).unwrap().subst(self.tcx(), substs)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>> {\n-        ty::ctxt::closure_upvars(self, def_id, substs)\n-    }\n-}\n-\n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n+           tables: &'a RefCell<ty::Tables<'tcx>>,\n            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx> {\n+\n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n             locals: RefCell::new(NodeMap()),\n-            param_env: param_env,\n-            node_types: RefCell::new(NodeMap()),\n-            item_substs: RefCell::new(NodeMap()),\n-            adjustments: RefCell::new(NodeMap()),\n-            method_map: RefCell::new(FnvHashMap()),\n-            upvar_capture_map: RefCell::new(FnvHashMap()),\n-            closure_tys: RefCell::new(DefIdMap()),\n-            closure_kinds: RefCell::new(DefIdMap()),\n+            tables: tables,\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n@@ -424,12 +340,13 @@ pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n+fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                                     tables: &'a RefCell<ty::Tables<'tcx>>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ccx.tcx.empty_parameter_environment();\n-    Inherited::new(ccx.tcx, param_env)\n+    Inherited::new(ccx.tcx, &tables, param_env)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n@@ -504,16 +421,20 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     match raw_fty.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n-            let inh = Inherited::new(ccx.tcx, param_env);\n+            let tables = RefCell::new(ty::Tables::empty());\n+            let inh = Inherited::new(ccx.tcx, &tables, param_env);\n \n             // Compute the fty from point of view of inside fn.\n             let fn_sig =\n-                fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n+                fn_ty.sig.subst(ccx.tcx, &inh.infcx.parameter_environment.free_substs);\n             let fn_sig =\n                 ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n                                                     &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n+                inh.normalize_associated_types_in(&inh.infcx.parameter_environment,\n+                                                  body.span,\n+                                                  body.id,\n+                                                  &fn_sig);\n \n             let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n                                decl, fn_id, body, &inh);\n@@ -1198,7 +1119,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        Some(&self.inh.param_env.free_substs)\n+        Some(&self.inh.infcx.parameter_environment.free_substs)\n     }\n \n     fn get_type_parameter_bounds(&self,\n@@ -1207,7 +1128,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         let def = self.tcx().type_parameter_def(node_id);\n-        let r = self.inh.param_env.caller_bounds\n+        let r = self.inh.infcx.parameter_environment\n+                                  .caller_bounds\n                                   .iter()\n                                   .filter_map(|predicate| {\n                                       match *predicate {\n@@ -1273,7 +1195,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> {\n-        &self.inh.param_env\n+        &self.inh.infcx.parameter_environment\n     }\n \n     pub fn sess(&self) -> &Session {\n@@ -1322,16 +1244,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    /// Resolves all type variables in `t` and then, if any were left\n-    /// unresolved, substitutes an error type. This is used after the\n-    /// main checking when doing a second pass before writeback. The\n-    /// justification is that writeback will produce an error for\n-    /// these unconstrained type variables.\n-    fn resolve_type_vars_or_error(&self, ty: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n-        let ty = self.infcx().resolve_type_vars_if_possible(ty);\n-        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n-    }\n-\n     fn record_deferred_call_resolution(&self,\n                                        closure_def_id: ast::DefId,\n                                        r: DeferredCallResolutionHandler<'tcx>) {\n@@ -1368,7 +1280,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n+        for (_, &mut ref ty) in &mut self.inh.tables.borrow_mut().node_types {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n@@ -1390,7 +1302,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n-        self.inh.node_types.borrow_mut().insert(node_id, ty);\n+        self.inh.tables.borrow_mut().node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1400,7 +1312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    substs,\n                    self.tag());\n \n-            self.inh.item_substs.borrow_mut().insert(node_id, substs);\n+            self.inh.tables.borrow_mut().item_substs.insert(node_id, substs);\n         }\n     }\n \n@@ -1426,7 +1338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        self.inh.adjustments.borrow_mut().insert(node_id, adj);\n+        self.inh.tables.borrow_mut().adjustments.insert(node_id, adj);\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -1465,7 +1377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n-        self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n+        self.inh.normalize_associated_types_in(self.infcx(), span, self.body_id, value)\n     }\n \n     fn normalize_associated_type(&self,\n@@ -1480,7 +1392,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n-                                       self,\n+                                       self.infcx(),\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n                                            item_name: item_name,\n@@ -1627,7 +1539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n-        match self.inh.node_types.borrow().get(&ex.id) {\n+        match self.inh.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n@@ -1646,13 +1558,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n         raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n-            self.inh.method_map.borrow().get(&method_call)\n+            self.inh.tables.borrow().method_map.get(&method_call)\n                                         .map(|method| resolve_ty(method.ty))\n         })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.inh.node_types.borrow().get(&id) {\n+        match self.inh.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx().types.err,\n             None => {\n@@ -1665,15 +1577,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n-        self.inh.item_substs.borrow()\n+        // NOTE: @jroesch this is hack that appears to be fixed on nightly, will monitor if\n+        // it changes when we upgrade the snapshot compiler\n+        fn project_item_susbts<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n+                                        -> &'a NodeMap<ty::ItemSubsts<'tcx>> {\n+            &tables.item_substs\n+        }\n+\n+        Ref::map(self.inh.tables.borrow(), project_item_susbts)\n     }\n \n     pub fn opt_node_ty_substs<F>(&self,\n                                  id: ast::NodeId,\n                                  f: F) where\n         F: FnOnce(&ty::ItemSubsts<'tcx>),\n     {\n-        match self.inh.item_substs.borrow().get(&id) {\n+        match self.inh.tables.borrow().item_substs.get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n@@ -1829,7 +1748,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.select_all_obligations_and_apply_defaults();\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(self.infcx(), self) {\n+        match fulfillment_cx.select_all_or_error(self.infcx(), self.infcx()) {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n@@ -1840,7 +1759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match\n             self.inh.fulfillment_cx\n             .borrow_mut()\n-            .select_where_possible(self.infcx(), self)\n+            .select_where_possible(self.infcx(), self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n@@ -1855,7 +1774,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match\n             self.inh.fulfillment_cx\n             .borrow_mut()\n-            .select_new_obligations(self.infcx(), self)\n+            .select_new_obligations(self.infcx(), self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n@@ -2039,7 +1958,7 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n             if let Some(method_call) = method_call {\n-                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n \n             // method returns &T, but the type as visible to user is T, so deref\n@@ -2640,7 +2559,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n-                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n                 method_ty\n             }\n             Err(error) => {\n@@ -4074,7 +3993,8 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n                                 expr: &'tcx ast::Expr,\n                                 expected_type: Ty<'tcx>) {\n-    let inh = static_inherited_fields(ccx);\n+    let tables = RefCell::new(ty::Tables::empty());\n+    let inh = static_inherited_fields(ccx, &tables);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n@@ -4083,7 +4003,8 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         sp: Span,\n                         e: &'tcx ast::Expr,\n                         id: ast::NodeId) {\n-    let inh = static_inherited_fields(ccx);\n+    let tables = RefCell::new(ty::Tables::empty());\n+    let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n@@ -4235,7 +4156,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let rty = ccx.tcx.node_id_to_type(id);\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n \n-        let inh = static_inherited_fields(ccx);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = static_inherited_fields(ccx, &tables);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n         let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));"}, {"sha": "c419a986f95b189491811fe1a1476af6a0386798", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -330,7 +330,7 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n             // HACK(eddyb) Fully qualified path to work around a resolve bug.\n             let method_call = ::middle::ty::MethodCall::expr(expr.id);\n-            fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+            fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n@@ -454,4 +454,3 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         }\n     }\n }\n-"}, {"sha": "a86301907385a1246dc033758bddee9fe4fb9de4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -86,6 +86,7 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n+use middle::infer::InferCtxt;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n@@ -124,7 +125,8 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n     let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n     let tcx = fcx.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n+    rcx.free_region_map\n+       .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n     rcx.visit_region_obligations(item.id);\n     rcx.resolve_regions_and_report_errors();\n }\n@@ -143,7 +145,8 @@ pub fn regionck_fn(fcx: &FnCtxt,\n     }\n \n     let tcx = fcx.tcx();\n-    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n+    rcx.free_region_map\n+       .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n \n     rcx.resolve_regions_and_report_errors();\n \n@@ -254,7 +257,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.fcx.inh.method_map.borrow()\n+        let method_ty = self.fcx.inh.tables.borrow().method_map\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n@@ -267,7 +270,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         } else {\n             ty_unadjusted.adjust(\n                 self.fcx.tcx(), expr.span, expr.id,\n-                self.fcx.inh.adjustments.borrow().get(&expr.id),\n+                self.fcx.inh.tables.borrow().adjustments.get(&expr.id),\n                 |method_call| self.resolve_method_type(method_call))\n         }\n     }\n@@ -353,7 +356,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={:?})\", ty);\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n+            let implications = implicator::implications(self.fcx.infcx(), self.fcx.infcx(), body_id,\n                                                         ty, body_scope, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n@@ -511,12 +514,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n     let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n+    let has_method_map = rcx.fcx.inh.tables.borrow().method_map.contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    if let Some(adjustment) = rcx.fcx.inh.adjustments.borrow().get(&expr.id) {\n+    let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n+    if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n-        match *adjustment {\n+        match adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, ref autoref, ..}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n@@ -548,7 +552,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+            let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n             mc.cat_expr_unadjusted(expr)\n         };\n         match cmt_result {\n@@ -567,7 +571,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     // If necessary, constrain destructors in this expression. This will be\n     // the adjusted form if there is an adjustment.\n     let cmt_result = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n         mc.cat_expr(expr)\n     };\n     match cmt_result {\n@@ -657,7 +661,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n+            let base_ty = match rcx.fcx.inh.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n@@ -884,7 +888,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n \n-        derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n+        let method = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n+\n+        derefd_ty = match method {\n             Some(method) => {\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n                        i, method);\n@@ -909,7 +915,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                        r, m);\n \n                 {\n-                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                            self_cmt);\n@@ -1018,7 +1024,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let ty = ty0.adjust(tcx, origin.span(), id,\n-                        rcx.fcx.inh.adjustments.borrow().get(&id),\n+                        rcx.fcx.inh.tables.borrow().adjustments.get(&id),\n                         |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n@@ -1034,7 +1040,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n         ignore_err!(mc.cat_expr(base))\n     };\n \n@@ -1052,7 +1058,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n@@ -1062,7 +1068,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n@@ -1077,7 +1083,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     for arg in args {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n@@ -1092,7 +1098,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n+                          mc: mc::MemCategorizationContext<InferCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n@@ -1131,7 +1137,7 @@ fn link_autoref(rcx: &Rcx,\n                 autoref: &ty::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n@@ -1155,7 +1161,7 @@ fn link_by_ref(rcx: &Rcx,\n                callee_scope: CodeExtent) {\n     debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n            expr, callee_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n@@ -1292,7 +1298,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let upvar_capture_map = rcx.fcx.inh.upvar_capture_map.borrow_mut();\n+            let upvar_capture_map = &rcx.fcx.inh.tables.borrow_mut().upvar_capture_map;\n             match upvar_capture_map.get(upvar_id) {\n                 Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n@@ -1399,7 +1405,7 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty,\n            region);\n \n-    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n+    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx.infcx(), rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n         debug!(\"implication: {:?}\", implication);\n@@ -1440,7 +1446,7 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n            region, def_id, substs);\n \n-    let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n+    let upvars = rcx.fcx.infcx().closure_upvars(def_id, substs).unwrap();\n     for upvar in upvars {\n         let var_id = upvar.def.def_id().local_id();\n         type_must_outlive(\n@@ -1453,7 +1459,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,\n                                   generic: &GenericKind<'tcx>) {\n-    let param_env = &rcx.fcx.inh.param_env;\n+    let param_env = &rcx.fcx.inh.infcx.parameter_environment;\n \n     debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n            region,"}, {"sha": "c7f084e27cda015f456bec5d6d0906b2b445bcf1", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -129,9 +129,10 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      _body: &ast::Block)\n     {\n         let closure_def_id = ast_util::local_def(expr.id);\n-        if !self.fcx.inh.closure_kinds.borrow().contains_key(&closure_def_id) {\n+        if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n-            self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n+            self.fcx.inh.tables.borrow_mut().closure_kinds\n+                                            .insert(closure_def_id, ty::FnClosureKind);\n             debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n                    closure_def_id);\n         }\n@@ -156,7 +157,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                     }\n                 };\n \n-                self.fcx.inh.upvar_capture_map.borrow_mut().insert(upvar_id, capture_kind);\n+                self.fcx.inh.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n         });\n     }\n@@ -186,7 +187,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         debug!(\"analyzing closure `{}` with fn body id `{}`\", id, body.id);\n \n-        let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n+        let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n         euv.walk_fn(decl, body);\n \n         // If we had not yet settled on a closure kind for this closure,\n@@ -267,7 +268,10 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n \n-                        let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                        let upvar_capture_map = &mut self.fcx\n+                                                         .inh\n+                                                         .tables.borrow_mut()\n+                                                         .upvar_capture_map;\n                         upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n@@ -374,9 +378,11 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                 // upvar, then we need to modify the\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n-                let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n-                self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+                {\n+                    let upvar_capture_map = &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+                    let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n+                    self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+                }\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n                 self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n@@ -442,7 +448,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n \n         let closure_def_id = ast_util::local_def(closure_id);\n-        let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n+        let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\","}, {"sha": "df01b99fd9b808cf2748635409dcfc400c6fd70e", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -18,6 +18,7 @@ use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n \n+use std::cell::RefCell;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -143,7 +144,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                                 &type_scheme.generics,\n                                                                 &type_predicates,\n                                                                 item.id);\n-        let inh = Inherited::new(ccx.tcx, param_env);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n         fcx.select_all_obligations_or_error();\n@@ -199,7 +201,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh.param_env.free_substs,\n+                                                      &fcx.inh\n+                                                          .infcx\n+                                                          .parameter_environment\n+                                                          .free_substs,\n                                                       &type_scheme.ty);\n \n             bounds_checker.check_traits_in_ty(item_ty, item.span);\n@@ -220,7 +225,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // to free.\n             let self_ty = fcx.tcx().node_id_to_type(item.id);\n             let self_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh.param_env.free_substs,\n+                                                      &fcx.inh\n+                                                          .infcx\n+                                                          .parameter_environment\n+                                                          .free_substs,\n                                                       &self_ty);\n \n             bounds_checker.check_traits_in_ty(self_ty, item.span);\n@@ -233,7 +241,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             };\n \n             let trait_ref = fcx.instantiate_type_scheme(item.span,\n-                                                        &fcx.inh.param_env.free_substs,\n+                                                        &fcx.inh\n+                                                            .infcx\n+                                                            .parameter_environment\n+                                                            .free_substs,\n                                                         &trait_ref);\n \n             // We are stricter on the trait-ref in an impl than the\n@@ -257,7 +268,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n             let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n-                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n+                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n             for predicate in predicates.value.predicates {\n@@ -635,7 +646,10 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .map(|field| {\n             let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n             let field_ty = fcx.instantiate_type_scheme(field.span,\n-                                                       &fcx.inh.param_env.free_substs,\n+                                                       &fcx.inh\n+                                                           .infcx\n+                                                           .parameter_environment\n+                                                           .free_substs,\n                                                        &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n@@ -660,7 +674,10 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             let arg_ty = arg_tys[index];\n                             let arg_ty =\n                                 fcx.instantiate_type_scheme(variant.span,\n-                                                            &fcx.inh.param_env.free_substs,\n+                                                            &fcx.inh\n+                                                                .infcx\n+                                                                .parameter_environment\n+                                                                .free_substs,\n                                                             &arg_ty);\n                             AdtField {\n                                 ty: arg_ty,"}, {"sha": "1fc7224737d2d8b095e848a14d930baf3b536a13", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -96,14 +96,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n \n             if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n+                self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n \n                 // weird but true: the by-ref binops put an\n                 // adjustment on the lhs but not the rhs; the\n                 // adjustment for rhs is kind of baked into the\n                 // system.\n                 if !ast_util::is_by_value_binop(op.node) {\n-                    self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n+                    self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n                 }\n             }\n         }\n@@ -204,7 +204,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+        for (upvar_id, upvar_capture) in self.fcx.inh.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -217,7 +217,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n+            self.fcx.tcx()\n+                    .tables\n+                    .borrow_mut()\n+                    .upvar_capture_map\n+                    .insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -226,13 +230,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.inh.closure_tys.borrow().iter() {\n+        for (def_id, closure_ty) in self.fcx.inh.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n-            self.fcx.tcx().closure_tys.borrow_mut().insert(*def_id, closure_ty);\n+            self.fcx.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.inh.closure_kinds.borrow().iter() {\n-            self.fcx.tcx().closure_kinds.borrow_mut().insert(*def_id, closure_kind);\n+        for (def_id, &closure_kind) in self.fcx.inh.tables.borrow().closure_kinds.iter() {\n+            self.fcx.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n         }\n     }\n \n@@ -254,7 +258,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n-        match self.fcx.inh.adjustments.borrow_mut().remove(&id) {\n+        let adjustments = self.fcx.inh.tables.borrow_mut().adjustments.remove(&id);\n+        match adjustments {\n             None => {\n                 debug!(\"No adjustments for node {}\", id);\n             }\n@@ -281,7 +286,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     }\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tcx().adjustments.borrow_mut().insert(\n+                self.tcx().tables.borrow_mut().adjustments.insert(\n                     id, resolved_adjustment);\n             }\n         }\n@@ -291,7 +296,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n-        match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n+        let new_method = match self.fcx.inh.tables.borrow_mut().method_map.remove(&method_call) {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                        method_call,\n@@ -302,9 +307,17 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     substs: self.resolve(&method.substs, reason),\n                 };\n \n-                self.tcx().method_map.borrow_mut().insert(\n+                Some(new_method)\n+            }\n+            None => None\n+        };\n+\n+        //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n+        match new_method {\n+            Some(method) => {\n+                self.tcx().tables.borrow_mut().method_map.insert(\n                     method_call,\n-                    new_method);\n+                    method);\n             }\n             None => {}\n         }"}, {"sha": "fbabc287342e9e0ce9d5c59f1f6a18e17203580b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx);\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n             let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -540,13 +540,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n             // Check that all transitive obligations are satisfied.\n-            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx, &param_env) {\n+            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx,\n+                                                                &infcx.parameter_environment) {\n                 traits::report_fulfillment_errors(&infcx, &errors);\n             }\n \n             // Finally, resolve all regions.\n             let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(tcx, &param_env.caller_bounds);\n+            free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment\n+                                                                        .caller_bounds);\n             infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n \n             if let Some(kind) = kind {\n@@ -630,7 +632,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx),\n+        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     unsafety::check(crate_context.tcx);"}, {"sha": "3495714fcc7367d08ecd42a5094a7e39977bdfd3", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n             }"}, {"sha": "ef9dcd56a578bdc1d8f04777a9f482e0965576dd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -2204,7 +2204,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                base_type,\n                base_type_free);\n \n-        let infcx = infer::new_infer_ctxt(tcx);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n         drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,"}, {"sha": "48a64675c708a3c38046e687f5ad490a16db221b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a973e4cda5191040ca219fb4a4f8041e9b560301/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a973e4cda5191040ca219fb4a4f8041e9b560301", "patch": "@@ -88,6 +88,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_extras)]\n #![feature(staged_api)]\n #![feature(vec_push_all)]\n+#![feature(cell_extras)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -162,7 +163,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         assert!(!item_substs.substs.types.needs_infer());\n \n-        tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n+        tcx.tables.borrow_mut().item_substs.insert(node_id, item_substs);\n     }\n }\n \n@@ -187,7 +188,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n             infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}