{"sha": "e6428873cb0eba71e052d8a65708a69be97d17e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDI4ODczY2IwZWJhNzFlMDUyZDhhNjU3MDhhNjliZTk3ZDE3ZTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-01-19T12:31:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-19T12:31:00Z"}, "message": "Merge pull request #2350 from theotherphil/fold_any\n\nLint for using hand-writing a fold with the same behaviour as any", "tree": {"sha": "4ccc163907d5c0f874ae623d08a6f40d3a5f480c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ccc163907d5c0f874ae623d08a6f40d3a5f480c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6428873cb0eba71e052d8a65708a69be97d17e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaYeUECRBK7hj4Ov3rIwAAdHIIADS7kjrj0LskSmATXbs2J7Xk\n7RvFCShN9oYj9iKWobmMHyjAo0TZJ+m+AVYRnMxeI6t7avF+PeSErIg1hyHh8Dr6\nS1jhEURmW+qhltiFuRXzjmIAbtQ93c7tkkC+tWzykbW3ZTU1e6nuz1UiJK7nCX6m\ntflECiFymnrkktiEagV8j2+rXqMHjy78Jmjt3jSkqb8qHlZWiibLZDsb6iMEQoEh\nxp3qH2tWmoc+dxHZSHahSdwP2IVYzVesQ95lJUlv6Ks4NIzi7PF3Vi/i9+LcVytL\ntxWO2LEW5kMWIKGVQV5VlCtwM0DsN4Tcasftp7w861judFHsdzIOEX49XY0sug8=\n=taMP\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ccc163907d5c0f874ae623d08a6f40d3a5f480c\nparent e08d8e4876c3ef62d734afdb942b931c6374039e\nparent 71abd81d221235bb61fc6683e81b346234802879\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1516365060 +0100\ncommitter GitHub <noreply@github.com> 1516365060 +0100\n\nMerge pull request #2350 from theotherphil/fold_any\n\nLint for using hand-writing a fold with the same behaviour as any"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6428873cb0eba71e052d8a65708a69be97d17e1", "html_url": "https://github.com/rust-lang/rust/commit/e6428873cb0eba71e052d8a65708a69be97d17e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6428873cb0eba71e052d8a65708a69be97d17e1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e08d8e4876c3ef62d734afdb942b931c6374039e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e08d8e4876c3ef62d734afdb942b931c6374039e", "html_url": "https://github.com/rust-lang/rust/commit/e08d8e4876c3ef62d734afdb942b931c6374039e"}, {"sha": "71abd81d221235bb61fc6683e81b346234802879", "url": "https://api.github.com/repos/rust-lang/rust/commits/71abd81d221235bb61fc6683e81b346234802879", "html_url": "https://github.com/rust-lang/rust/commit/71abd81d221235bb61fc6683e81b346234802879"}], "stats": {"total": 229, "additions": 212, "deletions": 17}, "files": [{"sha": "4eeaf675c88b906c026856e525cf2dd552d04357", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=e6428873cb0eba71e052d8a65708a69be97d17e1", "patch": "@@ -2,8 +2,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use utils::{is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type, paths, remove_blocks, snippet,\n-            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+use utils::{get_arg_name, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n+            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -123,14 +123,6 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n-    match pat.node {\n-        PatKind::Binding(_, _, name, None) => Some(name.node),\n-        PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n-        _ => None,\n-    }\n-}\n-\n fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),"}, {"sha": "d9b61a9e5cdcc8ebb767b2385166ffa7a864aadb", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 117, "deletions": 4, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=e6428873cb0eba71e052d8a65708a69be97d17e1", "patch": "@@ -9,10 +9,10 @@ use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n use syntax::ast;\n-use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n+use syntax::codemap::{Span, BytePos};\n+use utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n             iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, single_segment_path, snippet, span_lint,\n+            match_type, method_chain_args, return_ty, remove_blocks, same_tys, single_segment_path, snippet, span_lint,\n             span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::paths;\n use utils::sugg;\n@@ -622,6 +622,29 @@ declare_lint! {\n     \"using `as_ref` where the types before and after the call are the same\"\n }\n \n+\n+/// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n+/// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n+/// `sum` or `product`.\n+///\n+/// **Why is this bad?** Readability.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+/// ```\n+/// This could be written as:\n+/// ```rust\n+/// let _ = (0..3).any(|x| x > 2);\n+/// ```\n+declare_lint! {\n+    pub UNNECESSARY_FOLD,\n+    Warn,\n+    \"using `fold` when a more succinct alternative exists\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -652,7 +675,8 @@ impl LintPass for Pass {\n             GET_UNWRAP,\n             STRING_EXTEND_CHARS,\n             ITER_CLONED_COLLECT,\n-            USELESS_ASREF\n+            USELESS_ASREF,\n+            UNNECESSARY_FOLD\n         )\n     }\n }\n@@ -716,6 +740,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     lint_asref(cx, expr, \"as_ref\", arglists[0]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"as_mut\"]) {\n                     lint_asref(cx, expr, \"as_mut\", arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"fold\"]) {\n+                    lint_unnecessary_fold(cx, expr, arglists[0]);\n                 }\n \n                 lint_or_fun_call(cx, expr, &method_call.name.as_str(), args);\n@@ -1106,6 +1132,93 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n     }\n }\n \n+fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n+    // Check that this is a call to Iterator::fold rather than just some function called fold\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+        return;\n+    }\n+\n+    assert!(fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n+\n+    fn check_fold_with_op(\n+        cx: &LateContext,\n+        fold_args: &[hir::Expr],\n+        op: hir::BinOp_,\n+        replacement_method_name: &str,\n+        replacement_has_args: bool) {\n+\n+        if_chain! {\n+            // Extract the body of the closure passed to fold\n+            if let hir::ExprClosure(_, _, body_id, _, _) = fold_args[2].node;\n+            let closure_body = cx.tcx.hir.body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            // Check if the closure body is of the form `acc <op> some_expr(x)`\n+            if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+            if bin_op.node == op;\n+\n+            // Extract the names of the two arguments to the closure\n+            if let Some(first_arg_ident) = get_arg_name(&closure_body.arguments[0].pat);\n+            if let Some(second_arg_ident) = get_arg_name(&closure_body.arguments[1].pat);\n+\n+            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = left_expr.node;\n+            if path.segments.len() == 1 && &path.segments[0].name == &first_arg_ident;\n+\n+            then {\n+                // Span containing `.fold(...)`\n+                let fold_span = fold_args[0].span.next_point().with_hi(fold_args[2].span.hi() + BytePos(1));\n+\n+                let sugg = if replacement_has_args {\n+                    format!(\n+                        \".{replacement}(|{s}| {r})\",\n+                        replacement = replacement_method_name,\n+                        s = second_arg_ident,\n+                        r = snippet(cx, right_expr.span, \"EXPR\"),\n+                    )\n+                } else {\n+                    format!(\n+                        \".{replacement}()\",\n+                        replacement = replacement_method_name,\n+                    )\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_FOLD,\n+                    fold_span,\n+                    // TODO #2371 don't suggest e.g. .any(|x| f(x)) if we can suggest .any(f)\n+                    \"this `.fold` can be written more succinctly using another method\",\n+                    \"try\",\n+                    sugg,\n+                );\n+            }\n+        }\n+    }\n+\n+    // Check if the first argument to .fold is a suitable literal\n+    match fold_args[1].node {\n+        hir::ExprLit(ref lit) => {\n+            match lit.node {\n+                ast::LitKind::Bool(false) => check_fold_with_op(\n+                    cx, fold_args, hir::BinOp_::BiOr, \"any\", true\n+                ),\n+                ast::LitKind::Bool(true) => check_fold_with_op(\n+                    cx, fold_args, hir::BinOp_::BiAnd, \"all\", true\n+                ),\n+                ast::LitKind::Int(0, _) => check_fold_with_op(\n+                    cx, fold_args, hir::BinOp_::BiAdd, \"sum\", false\n+                ),\n+                ast::LitKind::Int(1, _) => check_fold_with_op(\n+                    cx, fold_args, hir::BinOp_::BiMul, \"product\", false\n+                ),\n+                _ => return\n+            }\n+        }\n+        _ => return\n+    };\n+}\n+\n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {"}, {"sha": "4019321d71160d8af5a89af028d587ff203b51a0", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6428873cb0eba71e052d8a65708a69be97d17e1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e6428873cb0eba71e052d8a65708a69be97d17e1", "patch": "@@ -596,6 +596,20 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n     db.docs_link(lint);\n }\n \n+/// Add a span lint with a suggestion on how to fix it.\n+///\n+/// These suggestions can be parsed by rustfix to allow it to automatically fix your code.\n+/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x > 2)\"`.\n+///\n+/// ```\n+/// error: This `.fold` can be more succinctly expressed as `.any`\n+/// --> $DIR/methods.rs:390:13\n+///     |\n+/// 390 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+///     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n+///     |\n+///     = note: `-D fold-any` implied by `-D warnings`\n+/// ```\n pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     cx: &'a T,\n     lint: &'static Lint,\n@@ -1034,3 +1048,11 @@ pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u\n pub fn is_allowed(cx: &LateContext, lint: &'static Lint, id: NodeId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n+\n+pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n+    match pat.node {\n+        PatKind::Binding(_, _, name, None) => Some(name.node),\n+        PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n+        _ => None,\n+    }\n+}"}, {"sha": "f7a4b39c7a6f205c090aa0882e64ea21a427fe08", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e6428873cb0eba71e052d8a65708a69be97d17e1/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6428873cb0eba71e052d8a65708a69be97d17e1/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=e6428873cb0eba71e052d8a65708a69be97d17e1", "patch": "@@ -385,6 +385,42 @@ fn iter_skip_next() {\n     let _ = foo.filter().skip(42).next();\n }\n \n+/// Calls which should trigger the `UNNECESSARY_FOLD` lint\n+fn unnecessary_fold() {\n+    // Can be replaced by .any\n+    let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+    // Can be replaced by .all\n+    let _ = (0..3).fold(true, |acc, x| acc && x > 2);\n+    // Can be replaced by .sum\n+    let _ = (0..3).fold(0, |acc, x| acc + x);\n+    // Can be replaced by .product\n+    let _ = (0..3).fold(1, |acc, x| acc * x);\n+}\n+\n+/// Should trigger the `UNNECESSARY_FOLD` lint, with an error span including exactly `.fold(...)`\n+fn unnecessary_fold_span_for_multi_element_chain() {\n+    let _ = (0..3).map(|x| 2 * x).fold(false, |acc, x| acc || x > 2);\n+}\n+\n+/// Calls which should not trigger the `UNNECESSARY_FOLD` lint\n+fn unnecessary_fold_should_ignore() {\n+    let _ = (0..3).fold(true, |acc, x| acc || x > 2);\n+    let _ = (0..3).fold(false, |acc, x| acc && x > 2);\n+    let _ = (0..3).fold(1, |acc, x| acc + x);\n+    let _ = (0..3).fold(0, |acc, x| acc * x);\n+    let _ = (0..3).fold(0, |acc, x| 1 + acc + x);\n+\n+    // We only match against an accumulator on the left\n+    // hand side. We could lint for .sum and .product when\n+    // it's on the right, but don't for now (and this wouldn't\n+    // be valid if we extended the lint to cover arbitrary numeric\n+    // types).\n+    let _ = (0..3).fold(false, |acc, x| x > 2 || acc);\n+    let _ = (0..3).fold(true, |acc, x| x > 2 && acc);\n+    let _ = (0..3).fold(0, |acc, x| x + acc);\n+    let _ = (0..3).fold(1, |acc, x| x * acc);\n+}\n+\n #[allow(similar_names)]\n fn main() {\n     let opt = Some(0);"}, {"sha": "5d3015f5e606f0846ef6b251717708f8a6628701", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e6428873cb0eba71e052d8a65708a69be97d17e1/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6428873cb0eba71e052d8a65708a69be97d17e1/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=e6428873cb0eba71e052d8a65708a69be97d17e1", "patch": "@@ -493,13 +493,45 @@ error: called `skip(x).next()` on an iterator. This is more succinctly expressed\n 382 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: this `.fold` can be written more succinctly using another method\n+   --> $DIR/methods.rs:391:19\n+    |\n+391 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n+    |\n+    = note: `-D unnecessary-fold` implied by `-D warnings`\n+\n+error: this `.fold` can be written more succinctly using another method\n+   --> $DIR/methods.rs:393:19\n+    |\n+393 |     let _ = (0..3).fold(true, |acc, x| acc && x > 2);\n+    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.all(|x| x > 2)`\n+\n+error: this `.fold` can be written more succinctly using another method\n+   --> $DIR/methods.rs:395:19\n+    |\n+395 |     let _ = (0..3).fold(0, |acc, x| acc + x);\n+    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.sum()`\n+\n+error: this `.fold` can be written more succinctly using another method\n+   --> $DIR/methods.rs:397:19\n+    |\n+397 |     let _ = (0..3).fold(1, |acc, x| acc * x);\n+    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.product()`\n+\n+error: this `.fold` can be written more succinctly using another method\n+   --> $DIR/methods.rs:402:34\n+    |\n+402 |     let _ = (0..3).map(|x| 2 * x).fold(false, |acc, x| acc || x > 2);\n+    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.any(|x| x > 2)`\n+\n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:391:13\n+   --> $DIR/methods.rs:427:13\n     |\n-391 |     let _ = opt.unwrap();\n+427 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 66 previous errors\n+error: aborting due to 71 previous errors\n "}]}