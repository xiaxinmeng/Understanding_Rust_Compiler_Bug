{"sha": "963ab91dd40a57c061229f006dcf8ce271d89664", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2FiOTFkZDQwYTU3YzA2MTIyOWYwMDZkY2Y4Y2UyNzFkODk2NjQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-29T10:37:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-29T10:37:44Z"}, "message": "Rollup merge of #46077 - LukasKalbertodt:stabilize-ascii-ctype, r=alexcrichton\n\nStabilize some `ascii_ctype` methods\n\nAs discussed in #39658, this PR stabilizes those methods for `u8` and `char`. All inherent `ascii_ctype` for `[u8]` and `str` are removed as we prefer the more explicit version `s.chars().all(|c| c.is_ascii_())`.\n\nThis PR doesn't modify the `AsciiExt` trait. There, the `ascii_ctype` methods are still unstable. It is planned to remove those in the future (I think). I had to modify some code in `ascii.rs` to properly implement `AsciiExt` for all types.\n\nFixes #39658.", "tree": {"sha": "40c0aaa5494f132492f7fb1fdc94cec54723f612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40c0aaa5494f132492f7fb1fdc94cec54723f612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963ab91dd40a57c061229f006dcf8ce271d89664", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963ab91dd40a57c061229f006dcf8ce271d89664", "html_url": "https://github.com/rust-lang/rust/commit/963ab91dd40a57c061229f006dcf8ce271d89664", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963ab91dd40a57c061229f006dcf8ce271d89664/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec3aee569a8a34117d265e48eb980a955a2186d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec3aee569a8a34117d265e48eb980a955a2186d", "html_url": "https://github.com/rust-lang/rust/commit/0ec3aee569a8a34117d265e48eb980a955a2186d"}, {"sha": "c5aad96739228e8e05b597b32ee7126c843b7228", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5aad96739228e8e05b597b32ee7126c843b7228", "html_url": "https://github.com/rust-lang/rust/commit/c5aad96739228e8e05b597b32ee7126c843b7228"}], "stats": {"total": 510, "additions": 186, "deletions": 324}, "files": [{"sha": "499608e3ea83a951f07c62cd328331d5fa2900a2", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=963ab91dd40a57c061229f006dcf8ce271d89664", "patch": "@@ -1626,120 +1626,6 @@ impl [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n-\n-    /// Checks if all bytes of this slice are ASCII alphabetic characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII alphanumeric characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII punctuation characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_control())\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9755c5d54f24d0d648a0e444124f4d9086445f57", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=963ab91dd40a57c061229f006dcf8ce271d89664", "patch": "@@ -2199,153 +2199,6 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n-\n-    /// Checks if all characters of this string are ASCII alphabetic\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"HELLO\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are ascii, 'y' and 'e' are not uppercase\n-    /// assert!(!\"Bye\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are uppercase, '\u00dc' is not ascii\n-    /// assert!(!\"TSCH\u00dcSS\".is_ascii_uppercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"hello\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are ascii, 'B' is not lowercase\n-    /// assert!(!\"Bye\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are lowercase, '\u00dc' is not ascii\n-    /// assert!(!\"tsch\u00fcss\".is_ascii_lowercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII alphanumeric\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII punctuation\n-    /// characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_control())\n-    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "a70694b01278b13e8774347e600b1ceb06246b96", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=963ab91dd40a57c061229f006dcf8ce271d89664", "patch": "@@ -2438,7 +2438,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_alphabetic());\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2476,7 +2476,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_uppercase());\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2514,7 +2514,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_lowercase());\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2555,7 +2555,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_alphanumeric());\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2593,7 +2593,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_digit());\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2634,7 +2634,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_hexdigit());\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2676,7 +2676,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_punctuation());\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2714,7 +2714,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_graphic());\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2769,7 +2769,7 @@ impl u8 {\n     /// assert!(lf.is_ascii_whitespace());\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2809,7 +2809,7 @@ impl u8 {\n     /// assert!(lf.is_ascii_control());\n     /// assert!(esc.is_ascii_control());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n         if *self >= 0x80 { return false; }"}, {"sha": "312da2035744939518fadc2336579708d73e557b", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 166, "deletions": 43, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=963ab91dd40a57c061229f006dcf8ce271d89664", "patch": "@@ -490,77 +490,199 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-macro_rules! impl_by_delegating {\n-    ($ty:ty, $owned:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl AsciiExt for $ty {\n-            type Owned = $owned;\n+macro_rules! delegating_ascii_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii(&self) -> bool { self.is_ascii() }\n \n-            #[inline]\n-            fn is_ascii(&self) -> bool { self.is_ascii() }\n+        #[inline]\n+        fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n \n-            #[inline]\n-            fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n+        #[inline]\n+        fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n \n-            #[inline]\n-            fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n+        #[inline]\n+        fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n \n-            #[inline]\n-            fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n+        #[inline]\n+        fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n \n-            #[inline]\n-            fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n-\n-            #[inline]\n-            fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+        #[inline]\n+        fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+    }\n+}\n \n-            #[inline]\n-            fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n+macro_rules! delegating_ascii_ctype_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n \n-            #[inline]\n-            fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n+        #[inline]\n+        fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n \n-            #[inline]\n-            fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n+        #[inline]\n+        fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n \n-            #[inline]\n-            fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n+        #[inline]\n+        fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n \n-            #[inline]\n-            fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n+        #[inline]\n+        fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n \n-            #[inline]\n-            fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n+        #[inline]\n+        fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n \n-            #[inline]\n-            fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n+        #[inline]\n+        fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n \n-            #[inline]\n-            fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n+        #[inline]\n+        fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n \n-            #[inline]\n-            fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n+        #[inline]\n+        fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n \n-            #[inline]\n-            fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n-        }\n+        #[inline]\n+        fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n     }\n }\n \n-impl_by_delegating!(u8, u8);\n-impl_by_delegating!(char, char);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for u8 {\n+    type Owned = u8;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for char {\n+    type Owned = char;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `[u8]` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `[u8]`.\n #[cfg(not(stage0))]\n-impl_by_delegating!([u8], Vec<u8>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for [u8] {\n+    type Owned = Vec<u8>;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `str` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `str`.\n #[cfg(not(stage0))]\n-impl_by_delegating!(str, String);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for str {\n+    type Owned = String;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n+}\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -684,6 +806,7 @@ mod tests {\n     //! Note that most of these tests are not testing `AsciiExt` methods, but\n     //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n     //! just using those methods, though.\n+    use super::AsciiExt;\n     use char::from_u32;\n \n     #[test]"}, {"sha": "6b573e5011bfabc1bf1289ed2587a896d0579c34", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963ab91dd40a57c061229f006dcf8ce271d89664/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=963ab91dd40a57c061229f006dcf8ce271d89664", "patch": "@@ -1109,7 +1109,7 @@ impl char {\n     /// assert!(!lf.is_ascii_alphabetic());\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n@@ -1143,7 +1143,7 @@ impl char {\n     /// assert!(!lf.is_ascii_uppercase());\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_uppercase()\n@@ -1177,7 +1177,7 @@ impl char {\n     /// assert!(!lf.is_ascii_lowercase());\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_lowercase()\n@@ -1214,7 +1214,7 @@ impl char {\n     /// assert!(!lf.is_ascii_alphanumeric());\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n@@ -1248,7 +1248,7 @@ impl char {\n     /// assert!(!lf.is_ascii_digit());\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_digit()\n@@ -1285,7 +1285,7 @@ impl char {\n     /// assert!(!lf.is_ascii_hexdigit());\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n@@ -1323,7 +1323,7 @@ impl char {\n     /// assert!(!lf.is_ascii_punctuation());\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_punctuation()\n@@ -1357,7 +1357,7 @@ impl char {\n     /// assert!(!lf.is_ascii_graphic());\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_graphic()\n@@ -1408,7 +1408,7 @@ impl char {\n     /// assert!(lf.is_ascii_whitespace());\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_whitespace()\n@@ -1444,7 +1444,7 @@ impl char {\n     /// assert!(lf.is_ascii_control());\n     /// assert!(esc.is_ascii_control());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_control()"}]}