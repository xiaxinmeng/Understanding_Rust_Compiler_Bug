{"sha": "34d14e7eed48c755a660224266e2c86669cf5483", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDE0ZTdlZWQ0OGM3NTVhNjYwMjI0MjY2ZTJjODY2NjljZjU0ODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-02T06:42:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-02T06:42:48Z"}, "message": "Auto merge of #34096 - eddyb:launch, r=nikomatsakis\n\nSwitch to MIR-based translation by default.\n\nThis patch makes `-Z orbit` default to \"on\", which means that by default, functions will be translated from Rust to LLVM IR through the upcoming MIR backend, instead of the antiquated AST backend.\n\nThis switch is made possible by the recently merged #33622, #33905 and smaller fixes.\n\nIf you experience any issues, please file a report for each of them. You can switch to the old backend to work around problems by either setting `RUSTFLAGS=\"-Zorbit=off\"` or by annotating specific functions with `#[rustc_no_mir]` (which requires `#![feature(rustc_attrs)]` at the crate-level).\n\nI would like this PR to get into nightly soon so that we can get early feedback in this release cycle and focus on correctness fixes and performance improvements, with the potential for removing the old backend implementation before beta branches off.\n\ncc @rust-lang/compiler", "tree": {"sha": "a9bd8a5c322a9299f7b3f4da0496e8933cb548d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9bd8a5c322a9299f7b3f4da0496e8933cb548d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d14e7eed48c755a660224266e2c86669cf5483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d14e7eed48c755a660224266e2c86669cf5483", "html_url": "https://github.com/rust-lang/rust/commit/34d14e7eed48c755a660224266e2c86669cf5483", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d14e7eed48c755a660224266e2c86669cf5483/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19765f2ab18ebb79f8615951b7cb8b86d896ecda", "url": "https://api.github.com/repos/rust-lang/rust/commits/19765f2ab18ebb79f8615951b7cb8b86d896ecda", "html_url": "https://github.com/rust-lang/rust/commit/19765f2ab18ebb79f8615951b7cb8b86d896ecda"}, {"sha": "b583711ff965db3b113ad6f468f32ad6ec1330a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b583711ff965db3b113ad6f468f32ad6ec1330a3", "html_url": "https://github.com/rust-lang/rust/commit/b583711ff965db3b113ad6f468f32ad6ec1330a3"}], "stats": {"total": 99, "additions": 66, "deletions": 33}, "files": [{"sha": "29f16da058129f917ae7e667a346a6020b5e0334", "filename": "configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/configure", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -609,7 +609,7 @@ opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n opt rustbuild 0 \"use the rust and cargo based build system\"\n-opt orbit 0 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n+opt orbit 1 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n@@ -733,7 +733,7 @@ if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTION\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n-if [ -n \"$CFG_ENABLE_ORBIT\" ]; then putvar CFG_ENABLE_ORBIT; fi\n+if [ -n \"$CFG_DISABLE_ORBIT\" ]; then putvar CFG_DISABLE_ORBIT; fi\n \n step_msg \"looking for build programs\"\n "}, {"sha": "9a3a59ded35add8f81bce93744e6e6839a13d2b4", "filename": "mk/main.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -162,9 +162,9 @@ ifdef CFG_ENABLE_DEBUGINFO\n   CFG_RUSTC_FLAGS += -g\n endif\n \n-ifdef CFG_ENABLE_ORBIT\n-  $(info cfg: launching MIR (CFG_ENABLE_ORBIT))\n-  CFG_RUSTC_FLAGS += -Z orbit\n+ifdef CFG_DISABLE_ORBIT\n+  $(info cfg: HOLD HOLD HOLD (CFG_DISABLE_ORBIT))\n+  CFG_RUSTC_FLAGS += -Z orbit=off\n endif\n \n ifdef SAVE_TEMPS"}, {"sha": "72a3c08225d035866f8269f273b4a00839492295", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -15,7 +15,7 @@ For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n-```rust\n+```rust,ignore\n #![feature(lang_items, box_syntax, start, libc)]\n #![no_std]\n "}, {"sha": "1d839be9f5378964c5c4be185790e8631e845bc2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -463,6 +463,8 @@ macro_rules! options {\n         pub const parse_bool: Option<&'static str> = None;\n         pub const parse_opt_bool: Option<&'static str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n+        pub const parse_all_bool: Option<&'static str> =\n+            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n@@ -512,6 +514,25 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_all_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s {\n+                        \"n\" | \"no\" | \"off\" => {\n+                            *slot = false;\n+                        }\n+                        \"y\" | \"yes\" | \"on\" => {\n+                            *slot = true;\n+                        }\n+                        _ => { return false; }\n+                    }\n+\n+                    true\n+                },\n+                None => { *slot = true; true }\n+            }\n+        }\n+\n         fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = Some(s.to_string()); true },\n@@ -756,7 +777,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string,\n           \"the directory the MIR is dumped into\"),\n-    orbit: bool = (false, parse_bool,\n+    orbit: bool = (true, parse_all_bool,\n           \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n "}, {"sha": "97d65ce9c53614bf1a2600fd48e6c0fb1f15f3cc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -244,18 +244,46 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_immediate(bcx.ccx(), operand.ty) => {\n+                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.tcx(), operand.ty) => {\n+                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n+                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n+                            if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                                let ll_cft = ll_cast_ty.field_types();\n+                                let ll_fft = ll_from_ty.field_types();\n+                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n+                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n+                                OperandValue::Pair(data_cast, meta_ptr)\n+                            } else { // cast to thin-ptr\n+                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n+                                // pointer-cast of that pointer to desired pointer type.\n+                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n+                                OperandValue::Immediate(llval)\n+                            }\n+                        } else {\n+                            bug!(\"Unexpected non-Pair operand\")\n+                        }\n+                    }\n+                    mir::CastKind::Misc => {\n                         debug_assert!(common::type_is_immediate(bcx.ccx(), cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                         let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n-                        let llval = operand.immediate();\n-                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n+                        let (llval, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n-                            adt::is_discr_signed(&repr)\n+                            let discr = match operand.val {\n+                                OperandValue::Immediate(llval) => llval,\n+                                OperandValue::Ref(llptr) => {\n+                                    bcx.with_block(|bcx| {\n+                                        adt::trans_get_discr(bcx, &repr, llptr, None, true)\n+                                    })\n+                                }\n+                                OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n+                            };\n+                            (discr, adt::is_discr_signed(&repr))\n                         } else {\n-                            operand.ty.is_signed()\n+                            (operand.immediate(), operand.ty.is_signed())\n                         };\n \n                         let newval = match (r_t_in, r_t_out) {\n@@ -304,26 +332,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n-                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n-                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n-                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n-                                let ll_cft = ll_cast_ty.field_types();\n-                                let ll_fft = ll_from_ty.field_types();\n-                                let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n-                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                OperandValue::Pair(data_cast, meta_ptr)\n-                            } else { // cast to thin-ptr\n-                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n-                                // pointer-cast of that pointer to desired pointer type.\n-                                let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n-                                OperandValue::Immediate(llval)\n-                            }\n-                        } else {\n-                            bug!(\"Unexpected non-Pair operand\")\n-                        }\n-                    }\n                 };\n                 let operand = OperandRef {\n                     val: val,"}, {"sha": "428d4e4dbb12de1d80018cc9632b7b64e0d4ec9d", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -28,7 +28,8 @@ macro_rules! demo {\n             unsafe {\n                 asm!(\"mov ($1), $0\"\n                      : $output_constraint (*wrap(&mut x, \"out\", &mut history))\n-                     : \"r\"(&wrap(y, \"in\", &mut history)));\n+                     : \"r\"(&wrap(y, \"in\", &mut history))\n+                     :: \"volatile\");\n             }\n             assert_eq!((x,y), (1,1));\n             let b: &[_] = &[\"out\", \"in\"];"}, {"sha": "efce148ea51d487f851e4bdab84c4dd1d45eca52", "filename": "src/test/run-pass/issue-28950.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d14e7eed48c755a660224266e2c86669cf5483/src%2Ftest%2Frun-pass%2Fissue-28950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d14e7eed48c755a660224266e2c86669cf5483/src%2Ftest%2Frun-pass%2Fissue-28950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28950.rs?ref=34d14e7eed48c755a660224266e2c86669cf5483", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z orbit=off\n+// (blows the stack with MIR trans and no optimizations)\n+\n // Tests that the `vec!` macro does not overflow the stack when it is\n // given data larger than the stack.\n "}]}