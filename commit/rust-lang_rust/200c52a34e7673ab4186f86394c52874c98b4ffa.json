{"sha": "200c52a34e7673ab4186f86394c52874c98b4ffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMGM1MmEzNGU3NjczYWI0MTg2Zjg2Mzk0YzUyODc0Yzk4YjRmZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-28T18:36:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-28T18:36:54Z"}, "message": "auto merge of #11159 : alexcrichton/rust/native-io, r=pcwalton\n\nThe old `rtio-processes` run-pass test is now moved into libstd's `io::process` module, and all process and TCP tests are now run with `iotest!` (both a native and a green version are tested).\r\n\r\nAll TCP networking on windows is provided by `ws2_32` which is apparently very similar to unix networking (hurray!).", "tree": {"sha": "9a083f25aa13d80ac60e04cbdd76f90fc75ff97a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a083f25aa13d80ac60e04cbdd76f90fc75ff97a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/200c52a34e7673ab4186f86394c52874c98b4ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/200c52a34e7673ab4186f86394c52874c98b4ffa", "html_url": "https://github.com/rust-lang/rust/commit/200c52a34e7673ab4186f86394c52874c98b4ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/200c52a34e7673ab4186f86394c52874c98b4ffa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70", "html_url": "https://github.com/rust-lang/rust/commit/1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70"}, {"sha": "2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915", "html_url": "https://github.com/rust-lang/rust/commit/2a4f9d69afd19603ed3354fa8e64ab0e67c6a915"}], "stats": {"total": 1451, "additions": 1109, "deletions": 342}, "files": [{"sha": "6197bd70c76109dddb14b46b73274d255522ed0a", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -26,7 +26,7 @@ use super::IoResult;\n #[cfg(windows)] use std::ptr;\n #[cfg(windows)] use std::str;\n \n-fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+pub fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n \n@@ -37,7 +37,7 @@ fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n         let mut ret;\n         loop {\n             ret = f(data, amt);\n-            if cfg!(not(windows)) { break } // windows has no eintr\n+            if cfg!(windows) { break } // windows has no eintr\n             // if we get an eintr, then try again\n             if ret != -1 || os::errno() as int != eintr { break }\n         }\n@@ -73,7 +73,10 @@ impl FileDesc {\n         FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    // FIXME(#10465) these functions should not be public, but anything in\n+    //               native::io wanting to use them is forced to have all the\n+    //               rtio traits in scope\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n         let ret = keep_going(buf, |buf, len| {\n@@ -89,7 +92,7 @@ impl FileDesc {\n             Ok(ret as uint)\n         }\n     }\n-    fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n         let ret = keep_going(buf, |buf, len| {\n@@ -103,6 +106,8 @@ impl FileDesc {\n             Ok(())\n         }\n     }\n+\n+    pub fn fd(&self) -> fd_t { self.fd }\n }\n \n impl io::Reader for FileDesc {"}, {"sha": "9e76dea5ebf7391b92ae73550dfedf65bba61a9a", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -44,6 +44,7 @@ pub use self::process::Process;\n // Native I/O implementations\n pub mod file;\n pub mod process;\n+pub mod net;\n \n type IoResult<T> = Result<T, IoError>;\n \n@@ -55,12 +56,25 @@ fn unimpl() -> IoError {\n     }\n }\n \n-fn last_error() -> IoError {\n+fn translate_error(errno: i32, detail: bool) -> IoError {\n     #[cfg(windows)]\n     fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n         match errno {\n             libc::EOF => (io::EndOfFile, \"end of file\"),\n-            _ => (io::OtherIoError, \"unknown error\"),\n+            libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+            libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+            libc::WSAEACCES => (io::PermissionDenied, \"permission denied\"),\n+            libc::WSAEWOULDBLOCK =>\n+                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+            libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n+            libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+            libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+            libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+\n+            x => {\n+                debug!(\"ignoring {}: {}\", x, os::last_os_error());\n+                (io::OtherIoError, \"unknown error\")\n+            }\n         }\n     }\n \n@@ -69,24 +83,38 @@ fn last_error() -> IoError {\n         // XXX: this should probably be a bit more descriptive...\n         match errno {\n             libc::EOF => (io::EndOfFile, \"end of file\"),\n+            libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+            libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+            libc::EPERM | libc::EACCES =>\n+                (io::PermissionDenied, \"permission denied\"),\n+            libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n+            libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n+            libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+            libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+            libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n \n             // These two constants can have the same value on some systems, but\n             // different values on others, so we can't use a match clause\n             x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n                 (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n \n-            _ => (io::OtherIoError, \"unknown error\"),\n+            x => {\n+                debug!(\"ignoring {}: {}\", x, os::last_os_error());\n+                (io::OtherIoError, \"unknown error\")\n+            }\n         }\n     }\n \n-    let (kind, desc) = get_err(os::errno() as i32);\n+    let (kind, desc) = get_err(errno);\n     IoError {\n         kind: kind,\n         desc: desc,\n-        detail: Some(os::last_os_error())\n+        detail: if detail {Some(os::last_os_error())} else {None},\n     }\n }\n \n+fn last_error() -> IoError { translate_error(os::errno() as i32, true) }\n+\n // unix has nonzero values as errors\n fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n     if ret != 0 {\n@@ -106,17 +134,37 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     }\n }\n \n+#[cfg(unix)]\n+fn retry(f: || -> libc::c_int) -> IoResult<libc::c_int> {\n+    loop {\n+        match f() {\n+            -1 if os::errno() as int == libc::EINTR as int => {}\n+            -1 => return Err(last_error()),\n+            n => return Ok(n),\n+        }\n+    }\n+}\n+\n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n-pub struct IoFactory;\n+pub struct IoFactory {\n+    priv cannot_construct_outside_of_this_module: ()\n+}\n+\n+impl IoFactory {\n+    pub fn new() -> IoFactory {\n+        net::init();\n+        IoFactory { cannot_construct_outside_of_this_module: () }\n+    }\n+}\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n-        Err(unimpl())\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n+        net::TcpStream::connect(addr).map(|s| ~s as ~RtioTcpStream)\n     }\n-    fn tcp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n-        Err(unimpl())\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n+        net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener)\n     }\n     fn udp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n         Err(unimpl())\n@@ -204,9 +252,7 @@ impl rtio::IoFactory for IoFactory {\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n         if unsafe { libc::isatty(fd) } != 0 {\n-            // Don't ever close the stdio file descriptors, nothing good really\n-            // comes of that.\n-            Ok(~file::FileDesc::new(fd, fd > libc::STDERR_FILENO) as ~RtioTTY)\n+            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n         } else {\n             Err(IoError {\n                 kind: io::MismatchedFileTypeForOperation,"}, {"sha": "aaa95ce0cfbe2d95367df9f8c61deaa1b0d69fac", "filename": "src/libnative/io/net.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+use std::io::net::ip;\n+use std::io;\n+use std::libc;\n+use std::mem;\n+use std::rt::rtio;\n+use std::unstable::intrinsics;\n+\n+use super::IoResult;\n+use super::file::keep_going;\n+\n+#[cfg(windows)] pub type sock_t = libc::SOCKET;\n+#[cfg(unix)]    pub type sock_t = super::file::fd_t;\n+\n+pub struct TcpStream {\n+    priv fd: sock_t,\n+}\n+\n+#[cfg(target_endian = \"big\")] pub fn htons(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"big\")] pub fn ntohs(x: u16) -> u16 { x }\n+#[cfg(target_endian = \"little\")]\n+pub fn htons(u: u16) -> u16 {\n+    unsafe { intrinsics::bswap16(u as i16) as u16 }\n+}\n+#[cfg(target_endian = \"little\")]\n+pub fn ntohs(u: u16) -> u16 {\n+    unsafe { intrinsics::bswap16(u as i16) as u16 }\n+}\n+\n+fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+    unsafe {\n+        let storage: libc::sockaddr_storage = intrinsics::init();\n+        let len = match addr.ip {\n+            ip::Ipv4Addr(a, b, c, d) => {\n+                let storage: *mut libc::sockaddr_in = cast::transmute(&storage);\n+                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n+                (*storage).sin_port = htons(addr.port);\n+                (*storage).sin_addr.s_addr = (d as u32 << 24) |\n+                                             (c as u32 << 16) |\n+                                             (b as u32 <<  8) |\n+                                             (a as u32 <<  0);\n+                mem::size_of::<libc::sockaddr_in>()\n+            }\n+            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+                let storage: *mut libc::sockaddr_in6 = cast::transmute(&storage);\n+                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n+                (*storage).sin6_port = htons(addr.port);\n+                (*storage).sin6_addr.s6_addr[0] = htons(a);\n+                (*storage).sin6_addr.s6_addr[1] = htons(b);\n+                (*storage).sin6_addr.s6_addr[2] = htons(c);\n+                (*storage).sin6_addr.s6_addr[3] = htons(d);\n+                (*storage).sin6_addr.s6_addr[4] = htons(e);\n+                (*storage).sin6_addr.s6_addr[5] = htons(f);\n+                (*storage).sin6_addr.s6_addr[6] = htons(g);\n+                (*storage).sin6_addr.s6_addr[7] = htons(h);\n+                mem::size_of::<libc::sockaddr_in6>()\n+            }\n+        };\n+        return (storage, len);\n+    }\n+}\n+\n+fn socket(addr: ip::SocketAddr) -> IoResult<sock_t> {\n+    unsafe {\n+        let fam = match addr.ip {\n+            ip::Ipv4Addr(..) => libc::AF_INET,\n+            ip::Ipv6Addr(..) => libc::AF_INET6,\n+        };\n+        match libc::socket(fam, libc::SOCK_STREAM, 0) {\n+            -1 => Err(super::last_error()),\n+            fd => Ok(fd),\n+        }\n+    }\n+}\n+\n+fn sockname(fd: sock_t,\n+            f: extern \"system\" unsafe fn(sock_t, *mut libc::sockaddr,\n+                                         *mut libc::socklen_t) -> libc::c_int)\n+    -> IoResult<ip::SocketAddr>\n+{\n+    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+    unsafe {\n+        let storage = &mut storage as *mut libc::sockaddr_storage;\n+        let ret = f(fd,\n+                    storage as *mut libc::sockaddr,\n+                    &mut len as *mut libc::socklen_t);\n+        if ret != 0 {\n+            return Err(super::last_error())\n+        }\n+    }\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_INET => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n+            let storage: &mut libc::sockaddr_in = unsafe {\n+                cast::transmute(&mut storage)\n+            };\n+            let addr = storage.sin_addr.s_addr as u32;\n+            let a = (addr >>  0) as u8;\n+            let b = (addr >>  8) as u8;\n+            let c = (addr >> 16) as u8;\n+            let d = (addr >> 24) as u8;\n+            Ok(ip::SocketAddr {\n+                ip: ip::Ipv4Addr(a, b, c, d),\n+                port: ntohs(storage.sin_port),\n+            })\n+        }\n+        libc::AF_INET6 => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n+            let storage: &mut libc::sockaddr_in6 = unsafe {\n+                cast::transmute(&mut storage)\n+            };\n+            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n+            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n+            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n+            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n+            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n+            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n+            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n+            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n+            Ok(ip::SocketAddr {\n+                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+                port: ntohs(storage.sin6_port),\n+            })\n+        }\n+        _ => {\n+            Err(io::standard_error(io::OtherIoError))\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+pub fn init() {}\n+\n+#[cfg(windows)]\n+pub fn init() {\n+    static WSADESCRIPTION_LEN: uint = 256;\n+    static WSASYS_STATUS_LEN: uint = 128;\n+    struct WSADATA {\n+        wVersion: libc::WORD,\n+        wHighVersion: libc::WORD,\n+        szDescription: [u8, ..WSADESCRIPTION_LEN + 1],\n+        szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n+        iMaxSockets: u16,\n+        iMaxUdpDg: u16,\n+        lpVendorInfo: *u8,\n+    }\n+    type LPWSADATA = *mut WSADATA;\n+\n+    #[link(name = \"ws2_32\")]\n+    extern \"system\" {\n+        fn WSAStartup(wVersionRequested: libc::WORD,\n+                       lpWSAData: LPWSADATA) -> libc::c_int;\n+    }\n+\n+    unsafe {\n+        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut INITIALIZED: bool = false;\n+        if INITIALIZED { return }\n+        LOCK.lock();\n+        if !INITIALIZED {\n+            let mut data: WSADATA = intrinsics::init();\n+            let ret = WSAStartup(0x202,      // version 2.2\n+                                 &mut data);\n+            assert_eq!(ret, 0);\n+            INITIALIZED = true;\n+        }\n+        LOCK.unlock();\n+    }\n+}\n+\n+impl TcpStream {\n+    pub fn connect(addr: ip::SocketAddr) -> IoResult<TcpStream> {\n+        unsafe {\n+            socket(addr).and_then(|fd| {\n+                let (addr, len) = addr_to_sockaddr(addr);\n+                let addrp = &addr as *libc::sockaddr_storage;\n+                let ret = TcpStream { fd: fd };\n+                match libc::connect(fd, addrp as *libc::sockaddr,\n+                                    len as libc::socklen_t) {\n+                    -1 => Err(super::last_error()),\n+                    _ => Ok(ret),\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n+        unsafe {\n+            let on = nodelay as libc::c_int;\n+            let on = &on as *libc::c_int;\n+            super::mkerr_libc(libc::setsockopt(self.fd,\n+                                               libc::IPPROTO_TCP,\n+                                               libc::TCP_NODELAY,\n+                                               on as *libc::c_void,\n+                                               mem::size_of::<libc::c_void>()\n+                                                    as libc::socklen_t))\n+        }\n+    }\n+\n+    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+        unsafe {\n+            let on = seconds.is_some() as libc::c_int;\n+            let on = &on as *libc::c_int;\n+            let ret = libc::setsockopt(self.fd,\n+                                       libc::SOL_SOCKET,\n+                                       libc::SO_KEEPALIVE,\n+                                       on as *libc::c_void,\n+                                       mem::size_of::<libc::c_void>()\n+                                            as libc::socklen_t);\n+            if ret != 0 { return Err(super::last_error()) }\n+\n+            match seconds {\n+                Some(n) => self.set_tcp_keepalive(n),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        let delay = seconds as libc::c_uint;\n+        let delay = &delay as *libc::c_uint;\n+        let ret = libc::setsockopt(self.fd,\n+                                   libc::IPPROTO_TCP,\n+                                   libc::TCP_KEEPALIVE,\n+                                   delay as *libc::c_void,\n+                                   mem::size_of::<libc::c_uint>()\n+                                        as libc::socklen_t);\n+        super::mkerr_libc(ret)\n+    }\n+    #[cfg(target_os = \"freebsd\")]\n+    unsafe fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+        let delay = seconds as libc::c_uint;\n+        let delay = &delay as *libc::c_uint;\n+        let ret = libc::setsockopt(self.fd,\n+                                   libc::IPPROTO_TCP,\n+                                   libc::TCP_KEEPIDLE,\n+                                   delay as *libc::c_void,\n+                                   mem::size_of::<libc::c_uint>()\n+                                        as libc::socklen_t);\n+        super::mkerr_libc(ret)\n+    }\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n+    unsafe fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(windows)] type wrlen = libc::c_int;\n+#[cfg(not(windows))] type wrlen = libc::size_t;\n+\n+impl rtio::RtioTcpStream for TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+    fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getpeername)\n+    }\n+    fn control_congestion(&mut self) -> IoResult<()> {\n+        self.set_nodelay(false)\n+    }\n+    fn nodelay(&mut self) -> IoResult<()> {\n+        self.set_nodelay(true)\n+    }\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> {\n+        self.set_keepalive(Some(delay_in_seconds))\n+    }\n+    fn letdie(&mut self) -> IoResult<()> {\n+        self.set_keepalive(None)\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpStream {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+impl Drop for TcpStream {\n+    #[cfg(unix)]\n+    fn drop(&mut self) {\n+        unsafe { libc::close(self.fd); }\n+    }\n+\n+    #[cfg(windows)]\n+    fn drop(&mut self) {\n+        unsafe { libc::closesocket(self.fd); }\n+    }\n+}\n+\n+pub struct TcpListener {\n+    priv fd: sock_t,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        unsafe {\n+            socket(addr).and_then(|fd| {\n+                let (addr, len) = addr_to_sockaddr(addr);\n+                let addrp = &addr as *libc::sockaddr_storage;\n+                let ret = TcpListener { fd: fd };\n+                match libc::bind(fd, addrp as *libc::sockaddr,\n+                                 len as libc::socklen_t) {\n+                    -1 => Err(super::last_error()),\n+                    _ => Ok(ret),\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n+            -1 => Err(super::last_error()),\n+            _ => Ok(TcpAcceptor { fd: self.fd })\n+        }\n+    }\n+}\n+\n+impl rtio::RtioTcpListener for TcpListener {\n+    fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioTcpAcceptor)\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpListener {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    priv fd: sock_t,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let size = mem::size_of::<libc::sockaddr_storage>();\n+            let mut size = size as libc::socklen_t;\n+            match libc::accept(self.fd,\n+                               storagep as *mut libc::sockaddr,\n+                               &mut size as *mut libc::socklen_t) {\n+                -1 => Err(super::last_error()),\n+                fd => Ok(TcpStream { fd: fd })\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioSocket for TcpAcceptor {\n+    fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd, libc::getsockname)\n+    }\n+}\n+\n+impl rtio::RtioTcpAcceptor for TcpAcceptor {\n+    fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioTcpStream)\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n+    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n+}"}, {"sha": "3fda4486921591fc7d1a0d7ff260af7568ed85f3", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -18,6 +18,7 @@ use p = std::io::process;\n \n #[cfg(windows)] use std::cast;\n \n+use super::IoResult;\n use super::file;\n \n /**\n@@ -37,7 +38,7 @@ pub struct Process {\n     priv handle: *(),\n \n     /// None until finish() is called.\n-    priv exit_code: Option<int>,\n+    priv exit_code: Option<p::ProcessExit>,\n }\n \n impl Process {\n@@ -105,23 +106,28 @@ impl Process {\n             for pipe in err_pipe.iter() { libc::close(pipe.out); }\n         }\n \n-        Ok((Process { pid: res.pid, handle: res.handle, exit_code: None }, ret_io))\n+        match res {\n+            Ok(res) => {\n+                Ok((Process { pid: res.pid, handle: res.handle, exit_code: None },\n+                    ret_io))\n+            }\n+            Err(e) => Err(e)\n+        }\n     }\n }\n \n impl rtio::RtioProcess for Process {\n     fn id(&self) -> pid_t { self.pid }\n \n     fn wait(&mut self) -> p::ProcessExit {\n-        let code = match self.exit_code {\n+        match self.exit_code {\n             Some(code) => code,\n             None => {\n                 let code = waitpid(self.pid);\n                 self.exit_code = Some(code);\n                 code\n             }\n-        };\n-        return p::ExitStatus(code); // XXX: this is wrong\n+        }\n     }\n \n     fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n@@ -177,7 +183,8 @@ struct SpawnProcessResult {\n fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+                    in_fd: c_int, out_fd: c_int,\n+                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use std::libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use std::libc::consts::os::extra::{\n         TRUE, FALSE,\n@@ -241,7 +248,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n                     if created == FALSE {\n-                        create_err = Some(os::last_os_error());\n+                        create_err = Some(super::last_error());\n                     }\n                 })\n             })\n@@ -251,21 +258,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdOutput);\n         CloseHandle(si.hStdError);\n \n-        for msg in create_err.iter() {\n-            fail!(\"failure in CreateProcess: {}\", *msg);\n+        match create_err {\n+            Some(err) => return Err(err),\n+            None => {}\n         }\n \n-        // We close the thread handle because std::we don't care about keeping the\n+        // We close the thread handle because we don't care about keeping the\n         // thread id valid, and we aren't keeping the thread handle around to be\n         // able to close it later. We don't close the process handle however\n         // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n         CloseHandle(pi.hThread);\n \n-        SpawnProcessResult {\n+        Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n             handle: pi.hProcess as *()\n-        }\n+        })\n     }\n }\n \n@@ -303,9 +311,8 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n     }\n }\n \n-// FIXME: this is only pub so it can be tested (see issue #4536)\n #[cfg(windows)]\n-pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     let mut cmd = ~\"\";\n     append_arg(&mut cmd, prog);\n     for arg in args.iter() {\n@@ -360,55 +367,102 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+                    in_fd: c_int, out_fd: c_int,\n+                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use std::libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use std::libc::funcs::bsd44::getdtablesize;\n+    use std::libc::c_ulong;\n+    use std::unstable::intrinsics;\n \n     mod rustrt {\n         extern {\n             pub fn rust_unset_sigprocmask();\n         }\n     }\n \n-    #[cfg(windows)]\n-    unsafe fn set_environ(_envp: *c_void) {}\n     #[cfg(target_os = \"macos\")]\n     unsafe fn set_environ(envp: *c_void) {\n         extern { fn _NSGetEnviron() -> *mut *c_void; }\n \n         *_NSGetEnviron() = envp;\n     }\n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    #[cfg(not(target_os = \"macos\"))]\n     unsafe fn set_environ(envp: *c_void) {\n-        extern {\n-            static mut environ: *c_void;\n-        }\n+        extern { static mut environ: *c_void; }\n         environ = envp;\n     }\n \n-    unsafe {\n+    unsafe fn set_cloexec(fd: c_int) {\n+        extern { fn ioctl(fd: c_int, req: c_ulong) -> c_int; }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        static FIOCLEX: c_ulong = 0x20006601;\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        static FIOCLEX: c_ulong = 0x5451;\n+\n+        let ret = ioctl(fd, FIOCLEX);\n+        assert_eq!(ret, 0);\n+    }\n+\n+    let pipe = os::pipe();\n+    let mut input = file::FileDesc::new(pipe.input, true);\n+    let mut output = file::FileDesc::new(pipe.out, true);\n+\n+    unsafe { set_cloexec(output.fd()) };\n \n+    unsafe {\n         let pid = fork();\n         if pid < 0 {\n             fail!(\"failure in fork: {}\", os::last_os_error());\n         } else if pid > 0 {\n-            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n+            drop(output);\n+            let mut bytes = [0, ..4];\n+            return match input.inner_read(bytes) {\n+                Ok(4) => {\n+                    let errno = (bytes[0] << 24) as i32 |\n+                                (bytes[1] << 16) as i32 |\n+                                (bytes[2] <<  8) as i32 |\n+                                (bytes[3] <<  0) as i32;\n+                    Err(super::translate_error(errno, false))\n+                }\n+                Err(e) => {\n+                    assert!(e.kind == io::BrokenPipe ||\n+                            e.kind == io::EndOfFile,\n+                            \"unexpected error: {:?}\", e);\n+                    Ok(SpawnProcessResult {\n+                        pid: pid,\n+                        handle: ptr::null()\n+                    })\n+                }\n+                Ok(..) => fail!(\"short read on the cloexec pipe\"),\n+            };\n         }\n+        drop(input);\n \n         rustrt::rust_unset_sigprocmask();\n \n-        if dup2(in_fd, 0) == -1 {\n+        if in_fd == -1 {\n+            libc::close(libc::STDIN_FILENO);\n+        } else if dup2(in_fd, 0) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n-        if dup2(out_fd, 1) == -1 {\n+        if out_fd == -1 {\n+            libc::close(libc::STDOUT_FILENO);\n+        } else if dup2(out_fd, 1) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n-        if dup2(err_fd, 2) == -1 {\n+        if err_fd == -1 {\n+            libc::close(libc::STDERR_FILENO);\n+        } else if dup2(err_fd, 2) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).invert() {\n-            close(fd as c_int);\n+            if fd != output.fd() {\n+                close(fd as c_int);\n+            }\n         }\n \n         with_dirp(dir, |dirp| {\n@@ -421,11 +475,18 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            with_argv(prog, args, |argv| {\n-                execvp(*argv, argv);\n-                // execvp only returns if an error occurred\n-                fail!(\"failure in execvp: {}\", os::last_os_error());\n-            })\n+        });\n+        with_argv(prog, args, |argv| {\n+            execvp(*argv, argv);\n+            let errno = os::errno();\n+            let bytes = [\n+                (errno << 24) as u8,\n+                (errno << 16) as u8,\n+                (errno <<  8) as u8,\n+                (errno <<  0) as u8,\n+            ];\n+            output.inner_write(bytes);\n+            intrinsics::abort();\n         })\n     }\n }\n@@ -534,11 +595,11 @@ fn free_handle(_handle: *()) {\n  * operate on a none-existent process or, even worse, on a newer process\n  * with the same id.\n  */\n-fn waitpid(pid: pid_t) -> int {\n+fn waitpid(pid: pid_t) -> p::ProcessExit {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> int {\n+    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n         use std::libc::types::os::arch::extra::DWORD;\n         use std::libc::consts::os::extra::{\n             SYNCHRONIZE,\n@@ -572,7 +633,7 @@ fn waitpid(pid: pid_t) -> int {\n                 }\n                 if status != STILL_ACTIVE {\n                     CloseHandle(process);\n-                    return status as int;\n+                    return p::ExitStatus(status as int);\n                 }\n                 if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n                     CloseHandle(process);\n@@ -583,43 +644,36 @@ fn waitpid(pid: pid_t) -> int {\n     }\n \n     #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> int {\n+    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n         use std::libc::funcs::posix01::wait;\n \n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0xffi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0x7fi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            (status >> 8i32) & 0xffi32\n+        mod imp {\n+            pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+            pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+            pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n         }\n \n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            status >> 8i32\n+        mod imp {\n+            pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+            pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+            pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n         }\n \n         let mut status = 0 as c_int;\n-        if unsafe { wait::waitpid(pid, &mut status, 0) } == -1 {\n-            fail!(\"failure in waitpid: {}\", os::last_os_error());\n+        match super::retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+            Err(e) => fail!(\"unknown waitpid error: {:?}\", e),\n+            Ok(_ret) => {\n+                if imp::WIFEXITED(status) {\n+                    p::ExitStatus(imp::WEXITSTATUS(status) as int)\n+                } else {\n+                    p::ExitSignal(imp::WTERMSIG(status) as int)\n+                }\n+            }\n         }\n-\n-        return if WIFEXITED(status) {\n-            WEXITSTATUS(status) as int\n-        } else {\n-            1\n-        };\n     }\n }\n \n@@ -646,8 +700,4 @@ mod tests {\n             ~\"echo \\\"a b c\\\"\"\n         );\n     }\n-\n-    // Currently most of the tests of this functionality live inside std::run,\n-    // but they may move here eventually as a non-blocking backend is added to\n-    // std::run\n }"}, {"sha": "8f2dff424049b3c4ef3410825b49761c0fb0a095", "filename": "src/libnative/task.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -34,6 +34,7 @@ pub fn new() -> ~Task {\n     task.put_runtime(~Ops {\n         lock: unsafe { Mutex::new() },\n         awoken: false,\n+        io: io::IoFactory::new(),\n     } as ~rt::Runtime);\n     return task;\n }\n@@ -86,8 +87,9 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n-    lock: Mutex,  // native synchronization\n-    awoken: bool, // used to prevent spurious wakeups\n+    lock: Mutex,       // native synchronization\n+    awoken: bool,      // used to prevent spurious wakeups\n+    io: io::IoFactory, // local I/O factory\n }\n \n impl rt::Runtime for Ops {\n@@ -217,11 +219,7 @@ impl rt::Runtime for Ops {\n     }\n \n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        static mut io: io::IoFactory = io::IoFactory;\n-        // Unsafety is from accessing `io`, which is guaranteed to be safe\n-        // because you can't do anything usable with this statically initialized\n-        // unit struct.\n-        Some(unsafe { rtio::LocalIo::new(&mut io as &mut rtio::IoFactory) })\n+        Some(rtio::LocalIo::new(&mut self.io as &mut rtio::IoFactory))\n     }\n }\n "}, {"sha": "5d08656b798cb4d565036d33f5244e5e8eb6f4ce", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -345,6 +345,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n             uvll::ENOENT => io::FileNotFound,\n             uvll::EPIPE => io::BrokenPipe,\n             uvll::ECONNABORTED => io::ConnectionAborted,\n+            uvll::EADDRNOTAVAIL => io::ConnectionRefused,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // XXX: Need to map remaining uv error types"}, {"sha": "dfe67f050ec9f30f3b275e1fb6ca29fd55421144", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -38,7 +38,7 @@ use std::libc;\n use std::libc::uintptr_t;\n \n pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n-                       ECANCELED, EBADF, ENOTCONN, ENOENT};\n+                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -60,6 +60,7 @@ pub mod errors {\n     pub static ECONNABORTED: c_int = -4079;\n     pub static ECANCELED: c_int = -4081;\n     pub static EBADF: c_int = -4083;\n+    pub static EADDRNOTAVAIL: c_int = -4090;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -75,6 +76,7 @@ pub mod errors {\n     pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n     pub static ECANCELED : c_int = -libc::ECANCELED;\n     pub static EBADF : c_int = -libc::EBADF;\n+    pub static EADDRNOTAVAIL : c_int = -libc::EADDRNOTAVAIL;\n }\n \n pub static PROCESS_SETUID: c_int = 1 << 0;"}, {"sha": "52cca7f622b532984e0da0794f903eaf9e3203f1", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 41, "deletions": 67, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -134,13 +134,11 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use io::net::ip::{Ipv4Addr, SocketAddr};\n+    use io::net::ip::SocketAddr;\n     use io::*;\n-    use io::test::{next_test_ip4, next_test_ip6};\n     use prelude::*;\n \n-    #[test] #[ignore]\n-    fn bind_error() {\n+    iotest!(fn bind_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n             assert!(e.kind == PermissionDenied);\n@@ -151,30 +149,22 @@ mod test {\n             assert!(listener.is_none());\n         });\n         assert!(called);\n-    }\n+    } #[ignore(cfg(windows))])\n \n-    #[test]\n-    fn connect_error() {\n+    iotest!(fn connect_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n-            let expected_error = if cfg!(unix) {\n-                ConnectionRefused\n-            } else {\n-                // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n-                OtherIoError\n-            };\n-            assert_eq!(e.kind, expected_error);\n+            assert_eq!(e.kind, ConnectionRefused);\n             called = true;\n         }).inside(|| {\n             let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n             let stream = TcpStream::connect(addr);\n             assert!(stream.is_none());\n         });\n         assert!(called);\n-    }\n+    })\n \n-    #[test]\n-    fn smoke_test_ip4() {\n+    iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -190,10 +180,9 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf);\n         assert!(buf[0] == 99);\n-    }\n+    })\n \n-    #[test]\n-    fn smoke_test_ip6() {\n+    iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -209,10 +198,9 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf);\n         assert!(buf[0] == 99);\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_ip4() {\n+    iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -228,10 +216,9 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_none());\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_ip6() {\n+    iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -247,10 +234,9 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_none());\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_twice_ip4() {\n+    iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -276,10 +262,9 @@ mod test {\n             let nread = stream.read(buf);\n             assert!(nread.is_none());\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn read_eof_twice_ip6() {\n+    iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -305,10 +290,9 @@ mod test {\n             let nread = stream.read(buf);\n             assert!(nread.is_none());\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn write_close_ip4() {\n+    iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n@@ -337,10 +321,9 @@ mod test {\n             });\n             if stop { break }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn write_close_ip6() {\n+    iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n@@ -369,10 +352,9 @@ mod test {\n             });\n             if stop { break }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_serial_ip4() {\n+    iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n         let max = 10;\n         let (port, chan) = Chan::new();\n@@ -392,10 +374,9 @@ mod test {\n             stream.read(buf);\n             assert_eq!(buf[0], 99);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_serial_ip6() {\n+    iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n         let max = 10;\n         let (port, chan) = Chan::new();\n@@ -415,10 +396,9 @@ mod test {\n             stream.read(buf);\n             assert_eq!(buf[0], 99);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n+    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -453,10 +433,9 @@ mod test {\n                 stream.write([i as u8]);\n             }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n+    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n         let (port, chan) = Chan::<()>::new();\n@@ -491,10 +470,9 @@ mod test {\n                 stream.write([i as u8]);\n             }\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n+    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -529,9 +507,9 @@ mod test {\n                 stream.write([99]);\n             }\n         }\n-    }\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n+    })\n+\n+    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n@@ -566,10 +544,9 @@ mod test {\n                 stream.write([99]);\n             }\n         }\n-    }\n+    })\n \n-    #[cfg(test)]\n-    fn socket_name(addr: SocketAddr) {\n+    pub fn socket_name(addr: SocketAddr) {\n         let mut listener = TcpListener::bind(addr).unwrap();\n \n         // Make sure socket_name gives\n@@ -579,8 +556,7 @@ mod test {\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n-    #[cfg(test)]\n-    fn peer_name(addr: SocketAddr) {\n+    pub fn peer_name(addr: SocketAddr) {\n         let (port, chan) = Chan::new();\n \n         do spawn {\n@@ -603,16 +579,14 @@ mod test {\n         assert_eq!(addr, peer_name.unwrap());\n     }\n \n-    #[test]\n-    fn socket_and_peer_name_ip4() {\n+    iotest!(fn socket_and_peer_name_ip4() {\n         peer_name(next_test_ip4());\n         socket_name(next_test_ip4());\n-    }\n+    })\n \n-    #[test]\n-    fn socket_and_peer_name_ip6() {\n+    iotest!(fn socket_and_peer_name_ip6() {\n         // XXX: peer name is not consistent\n         //peer_name(next_test_ip6());\n         socket_name(next_test_ip6());\n-    }\n+    })\n }"}, {"sha": "a8b7e8e00ead01139d0fbfeca6203c13729881d1", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 149, "deletions": 2, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -169,5 +169,152 @@ impl Drop for Process {\n     }\n }\n \n-// Tests for this module can be found in the rtio-processes run-pass test, along\n-// with the justification for why it's not located here.\n+#[cfg(test)]\n+mod tests {\n+    use io::process::{ProcessConfig, Process};\n+    use prelude::*;\n+    use str;\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn smoke() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"true\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().success());\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn smoke_failure() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"if-this-is-a-binary-then-the-world-has-ended\",\n+            args: [],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        match io::result(|| Process::new(args)) {\n+            Ok(..) => fail!(),\n+            Err(..) => {}\n+        }\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn exit_reported_right() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"exit 1\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().matches_exit_status(1));\n+    })\n+\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn signal_reported_right() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"kill -1 $$\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        match p.wait() {\n+            process::ExitSignal(1) => {},\n+            result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n+        }\n+    })\n+\n+    pub fn read_all(input: &mut Reader) -> ~str {\n+        let mut ret = ~\"\";\n+        let mut buf = [0, ..1024];\n+        loop {\n+            match input.read(buf) {\n+                None => { break }\n+                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    pub fn run_output(args: ProcessConfig) -> ~str {\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.io[0].is_none());\n+        assert!(p.io[1].is_some());\n+        let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert!(p.wait().success());\n+        return ret;\n+    }\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn stdout_works() {\n+        let io = ~[Ignored, CreatePipe(false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"echo foobar\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"foobar\\n\");\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn set_cwd_works() {\n+        let io = ~[Ignored, CreatePipe(false, true)];\n+        let cwd = Some(\"/\");\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"pwd\"],\n+            env: None,\n+            cwd: cwd,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"/\\n\");\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn stdin_works() {\n+        let io = ~[CreatePipe(true, false),\n+                   CreatePipe(false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"read line; echo $line\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n+        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+        p.io[0] = None; // close stdin;\n+        let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert!(p.wait().success());\n+        assert_eq!(out, ~\"foobar\\n\");\n+    })\n+\n+}"}, {"sha": "92b2cfa8be2008dba0a2ca9addf3eda6699cea70", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -18,7 +18,7 @@ use std::io::net::ip::*;\n use sync::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n \n macro_rules! iotest (\n-    { fn $name:ident() $b:block } => (\n+    { fn $name:ident() $b:block $($a:attr)* } => (\n         mod $name {\n             #[allow(unused_imports)];\n \n@@ -28,18 +28,20 @@ macro_rules! iotest (\n             use prelude::*;\n             use io::*;\n             use io::fs::*;\n+            use io::test::*;\n             use io::net::tcp::*;\n             use io::net::ip::*;\n             use io::net::udp::*;\n             #[cfg(unix)]\n             use io::net::unix::*;\n+            use io::process::*;\n             use str;\n             use util;\n \n             fn f() $b\n \n-            #[test] fn green() { f() }\n-            #[test] fn native() {\n+            $($a)* #[test] fn green() { f() }\n+            $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n                 do native::task::spawn { c.send(f()) }\n@@ -90,9 +92,9 @@ fn base_port() -> u16 {\n \n     let bases = [\n         (\"32-opt\", base + range * 1),\n-        (\"32-noopt\", base + range * 2),\n+        (\"32-nopt\", base + range * 2),\n         (\"64-opt\", base + range * 3),\n-        (\"64-noopt\", base + range * 4),\n+        (\"64-nopt\", base + range * 4),\n         (\"64-opt-vg\", base + range * 5),\n         (\"all-opt\", base + range * 6),\n         (\"snap3\", base + range * 7),"}, {"sha": "2696e27c373174f841dd1416cde375b904ab5064", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -76,6 +76,7 @@ pub use libc::types::common::posix01::*;\n pub use libc::types::common::posix08::*;\n pub use libc::types::common::bsd44::*;\n pub use libc::types::os::common::posix01::*;\n+pub use libc::types::os::common::bsd44::*;\n pub use libc::types::os::arch::c95::*;\n pub use libc::types::os::arch::c99::*;\n pub use libc::types::os::arch::posix88::*;\n@@ -111,6 +112,7 @@ pub use libc::funcs::posix01::glob::*;\n pub use libc::funcs::posix01::mman::*;\n pub use libc::funcs::posix08::unistd::*;\n \n+pub use libc::funcs::bsd43::*;\n pub use libc::funcs::bsd44::*;\n pub use libc::funcs::extra::*;\n \n@@ -240,6 +242,40 @@ pub mod types {\n                     __unused5: *c_void,\n                 }\n             }\n+            pub mod bsd44 {\n+                pub type socklen_t = u32;\n+                pub type sa_family_t = u16;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_family: sa_family_t,\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86\")]\n@@ -538,6 +574,45 @@ pub mod types {\n                     __unused8: *c_void,\n                 }\n             }\n+            pub mod bsd44 {\n+                pub type socklen_t = u32;\n+                pub type sa_family_t = u8;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_len: u8,\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_len: u8,\n+                    ss_family: sa_family_t,\n+                    __ss_pad1: [u8, ..6],\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_len: u8,\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_len: u8,\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n@@ -661,6 +736,44 @@ pub mod types {\n                     modtime: time64_t,\n                 }\n             }\n+\n+            pub mod bsd44 {\n+                use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+                pub type SOCKET = c_uint;\n+                pub type socklen_t = c_int;\n+                pub type sa_family_t = u16;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_family: sa_family_t,\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         pub mod arch {\n@@ -900,6 +1013,48 @@ pub mod types {\n                     __unused8: *c_void,\n                 }\n             }\n+\n+            pub mod bsd44 {\n+                use libc::types::os::arch::c95::c_int;\n+\n+                pub type socklen_t = c_int;\n+                pub type sa_family_t = u8;\n+                pub type in_port_t = u16;\n+                pub type in_addr_t = u32;\n+                pub struct sockaddr {\n+                    sa_len: u8,\n+                    sa_family: sa_family_t,\n+                    sa_data: [u8, ..14],\n+                }\n+                pub struct sockaddr_storage {\n+                    ss_len: u8,\n+                    ss_family: sa_family_t,\n+                    __ss_pad1: [u8, ..6],\n+                    __ss_align: i64,\n+                    __ss_pad2: [u8, ..112],\n+                }\n+                pub struct sockaddr_in {\n+                    sin_len: u8,\n+                    sin_family: sa_family_t,\n+                    sin_port: in_port_t,\n+                    sin_addr: in_addr,\n+                    sin_zero: [u8, ..8],\n+                }\n+                pub struct in_addr {\n+                    s_addr: in_addr_t,\n+                }\n+                pub struct sockaddr_in6 {\n+                    sin6_len: u8,\n+                    sin6_family: sa_family_t,\n+                    sin6_port: in_port_t,\n+                    sin6_flowinfo: u32,\n+                    sin6_addr: in6_addr,\n+                    sin6_scope_id: u32,\n+                }\n+                pub struct in6_addr {\n+                    s6_addr: [u16, ..8]\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86\")]\n@@ -1109,6 +1264,59 @@ pub mod consts {\n             pub static FILENAME_MAX : c_uint = 260_u32;\n             pub static L_tmpnam : c_uint = 16_u32;\n             pub static TMP_MAX : c_uint = 32767_u32;\n+\n+            pub static WSAEINTR: c_int = 10004;\n+            pub static WSAEBADF: c_int = 10009;\n+            pub static WSAEACCES: c_int = 10013;\n+            pub static WSAEFAULT: c_int = 10014;\n+            pub static WSAEINVAL: c_int = 10022;\n+            pub static WSAEMFILE: c_int = 10024;\n+            pub static WSAEWOULDBLOCK: c_int = 10035;\n+            pub static WSAEINPROGRESS: c_int = 10036;\n+            pub static WSAEALREADY: c_int = 10037;\n+            pub static WSAENOTSOCK: c_int = 10038;\n+            pub static WSAEDESTADDRREQ: c_int = 10039;\n+            pub static WSAEMSGSIZE: c_int = 10040;\n+            pub static WSAEPROTOTYPE: c_int = 10041;\n+            pub static WSAENOPROTOOPT: c_int = 10042;\n+            pub static WSAEPROTONOSUPPORT: c_int = 10043;\n+            pub static WSAESOCKTNOSUPPORT: c_int = 10044;\n+            pub static WSAEOPNOTSUPP: c_int = 10045;\n+            pub static WSAEPFNOSUPPORT: c_int = 10046;\n+            pub static WSAEAFNOSUPPORT: c_int = 10047;\n+            pub static WSAEADDRINUSE: c_int = 10048;\n+            pub static WSAEADDRNOTAVAIL: c_int = 10049;\n+            pub static WSAENETDOWN: c_int = 10050;\n+            pub static WSAENETUNREACH: c_int = 10051;\n+            pub static WSAENETRESET: c_int = 10052;\n+            pub static WSAECONNABORTED: c_int = 10053;\n+            pub static WSAECONNRESET: c_int = 10054;\n+            pub static WSAENOBUFS: c_int = 10055;\n+            pub static WSAEISCONN: c_int = 10056;\n+            pub static WSAENOTCONN: c_int = 10057;\n+            pub static WSAESHUTDOWN: c_int = 10058;\n+            pub static WSAETOOMANYREFS: c_int = 10059;\n+            pub static WSAETIMEDOUT: c_int = 10060;\n+            pub static WSAECONNREFUSED: c_int = 10061;\n+            pub static WSAELOOP: c_int = 10062;\n+            pub static WSAENAMETOOLONG: c_int = 10063;\n+            pub static WSAEHOSTDOWN: c_int = 10064;\n+            pub static WSAEHOSTUNREACH: c_int = 10065;\n+            pub static WSAENOTEMPTY: c_int = 10066;\n+            pub static WSAEPROCLIM: c_int = 10067;\n+            pub static WSAEUSERS: c_int = 10068;\n+            pub static WSAEDQUOT: c_int = 10069;\n+            pub static WSAESTALE: c_int = 10070;\n+            pub static WSAEREMOTE: c_int = 10071;\n+            pub static WSASYSNOTREADY: c_int = 10091;\n+            pub static WSAVERNOTSUPPORTED: c_int = 10092;\n+            pub static WSANOTINITIALISED: c_int = 10093;\n+            pub static WSAEDISCON: c_int = 10101;\n+            pub static WSAENOMORE: c_int = 10102;\n+            pub static WSAECANCELLED: c_int = 10103;\n+            pub static WSAEINVALIDPROCTABLE: c_int = 10104;\n+            pub static WSAEINVALIDPROVIDER: c_int = 10105;\n+            pub static WSAEPROVIDERFAILEDINIT: c_int = 10106;\n         }\n         pub mod c99 {\n         }\n@@ -1149,6 +1357,17 @@ pub mod consts {\n         pub mod posix08 {\n         }\n         pub mod bsd44 {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 23;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 0x0001;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 8;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -1845,6 +2064,16 @@ pub mod consts {\n             pub static MADV_MERGEABLE : c_int = 12;\n             pub static MADV_UNMERGEABLE : c_int = 13;\n             pub static MADV_HWPOISON : c_int = 100;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 10;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 1;\n+            pub static SOL_SOCKET: c_int = 1;\n+            pub static SO_KEEPALIVE: c_int = 9;\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch = \"x86_64\")]\n@@ -2262,6 +2491,17 @@ pub mod consts {\n             pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n             pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n             pub static MINCORE_SUPER : c_int = 0x20;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 28;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 1;\n+            pub static TCP_KEEPIDLE: c_int = 256;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 0x0008;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -2616,6 +2856,17 @@ pub mod consts {\n             pub static MINCORE_MODIFIED : c_int = 0x4;\n             pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n             pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n+\n+            pub static AF_INET: c_int = 2;\n+            pub static AF_INET6: c_int = 30;\n+            pub static SOCK_STREAM: c_int = 1;\n+            pub static SOCK_DGRAM: c_int = 2;\n+            pub static IPPROTO_TCP: c_int = 6;\n+\n+            pub static TCP_NODELAY: c_int = 0x01;\n+            pub static TCP_KEEPALIVE: c_int = 0x10;\n+            pub static SOL_SOCKET: c_int = 0xffff;\n+            pub static SO_KEEPALIVE: c_int = 0x0008;\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n@@ -3296,6 +3547,63 @@ pub mod funcs {\n         }\n     }\n \n+    #[cfg(not(windows))]\n+    pub mod bsd43 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::common::bsd44::{socklen_t, sockaddr};\n+        use libc::types::os::arch::c95::{c_int, size_t};\n+        use libc::types::os::arch::posix88::ssize_t;\n+\n+        extern \"system\" {\n+            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;\n+            pub fn connect(socket: c_int, address: *sockaddr,\n+                           len: socklen_t) -> c_int;\n+            pub fn bind(socket: c_int, address: *sockaddr,\n+                        address_len: socklen_t) -> c_int;\n+            pub fn listen(socket: c_int, backlog: c_int) -> c_int;\n+            pub fn accept(socket: c_int, address: *mut sockaddr,\n+                          address_len: *mut socklen_t) -> c_int;\n+            pub fn getpeername(socket: c_int, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn getsockname(socket: c_int, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn setsockopt(socket: c_int, level: c_int, name: c_int,\n+                              value: *c_void, option_len: socklen_t) -> c_int;\n+            pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,\n+                        flags: c_int) -> ssize_t;\n+            pub fn send(socket: c_int, buf: *mut c_void, len: size_t,\n+                        flags: c_int) -> ssize_t;\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    pub mod bsd43 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::common::bsd44::{socklen_t, sockaddr, SOCKET};\n+        use libc::types::os::arch::c95::c_int;\n+\n+        extern \"system\" {\n+            pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;\n+            pub fn connect(socket: SOCKET, address: *sockaddr,\n+                           len: socklen_t) -> c_int;\n+            pub fn bind(socket: SOCKET, address: *sockaddr,\n+                        address_len: socklen_t) -> c_int;\n+            pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n+            pub fn accept(socket: SOCKET, address: *mut sockaddr,\n+                          address_len: *mut socklen_t) -> SOCKET;\n+            pub fn getpeername(socket: SOCKET, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn getsockname(socket: SOCKET, address: *mut sockaddr,\n+                               address_len: *mut socklen_t) -> c_int;\n+            pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,\n+                              value: *c_void, option_len: socklen_t) -> c_int;\n+            pub fn closesocket(socket: SOCKET) -> c_int;\n+            pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                        flags: c_int) -> c_int;\n+            pub fn send(socket: SOCKET, buf: *mut c_void, len: c_int,\n+                        flags: c_int) -> c_int;\n+        }\n+    }\n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]"}, {"sha": "33be746e604d94c590c8db45b647871fd9a2d744", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200c52a34e7673ab4186f86394c52874c98b4ffa/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=200c52a34e7673ab4186f86394c52874c98b4ffa", "patch": "@@ -339,7 +339,7 @@ mod tests {\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::pipe::PipeStream;\n-    use io::{Writer, Reader, io_error, FileNotFound, OtherIoError};\n+    use io::{Writer, Reader, io_error, FileNotFound};\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)"}, {"sha": "6463a1d5321716350c6f739599d7108e3850bee8", "filename": "src/test/run-pass/rtio-processes.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=1b2cebc2c1f4d6e4bad36f4fa682f3d4e70cfb70", "patch": "@@ -1,178 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: --test\n-// xfail-fast\n-\n-// In the current state of affairs, libuv registers a SIGCHLD handler when a\n-// process is spawned through it. This is not done with a SA_RESTART flag,\n-// meaning that all of our syscalls run the risk of returning EINTR. This error\n-// is not correctly handled in the majority of std::io, so these can't run with\n-// the main body of tests there.\n-//\n-// That being said, libuv correctly handles EINTR completely, so these tests\n-// themselves are safe against that. Currently the test runner may run into this\n-// problem, but it's less likely than a whole suite of tests...\n-//\n-// See #9341\n-\n-use std::io;\n-use std::io::process;\n-use std::io::process::{Process, ProcessConfig, CreatePipe, Ignored};\n-use std::str;\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn smoke() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"true\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.wait().success());\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn smoke_failure() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-        args: [],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    match io::result(|| Process::new(args)) {\n-        Ok(..) => fail!(),\n-        Err(..) => {}\n-    }\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn exit_reported_right() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"exit 1\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.wait().matches_exit_status(1));\n-}\n-\n-#[test]\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn signal_reported_right() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"kill -1 $$\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    match p.wait() {\n-        process::ExitSignal(1) => {},\n-        result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n-    }\n-}\n-\n-fn read_all(input: &mut Reader) -> ~str {\n-    let mut ret = ~\"\";\n-    let mut buf = [0, ..1024];\n-    loop {\n-        match input.read(buf) {\n-            None => { break }\n-            Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n-        }\n-    }\n-    return ret;\n-}\n-\n-fn run_output(args: ProcessConfig) -> ~str {\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.io[0].is_none());\n-    assert!(p.io[1].is_some());\n-    let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert!(p.wait().success());\n-    return ret;\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn stdout_works() {\n-    let io = ~[Ignored, CreatePipe(false, true)];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"echo foobar\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    assert_eq!(run_output(args), ~\"foobar\\n\");\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn set_cwd_works() {\n-    let io = ~[Ignored, CreatePipe(false, true)];\n-    let cwd = Some(\"/\");\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"pwd\"],\n-        env: None,\n-        cwd: cwd,\n-        io: io,\n-    };\n-    assert_eq!(run_output(args), ~\"/\\n\");\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn stdin_works() {\n-    let io = ~[CreatePipe(true, false),\n-               CreatePipe(false, true)];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"read line; echo $line\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n-    p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n-    p.io[0] = None; // close stdin;\n-    let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert!(p.wait().success());\n-    assert_eq!(out, ~\"foobar\\n\");\n-}"}]}