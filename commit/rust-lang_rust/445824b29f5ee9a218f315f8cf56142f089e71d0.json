{"sha": "445824b29f5ee9a218f315f8cf56142f089e71d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTgyNGIyOWY1ZWU5YTIxOGYzMTVmOGNmNTYxNDJmMDg5ZTcxZDA=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-07T15:45:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-07T15:48:27Z"}, "message": "use is_method_call rather than directly accessing the method_map", "tree": {"sha": "1cd511cdae3e097b6cc717127141b6bdc1408ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cd511cdae3e097b6cc717127141b6bdc1408ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/445824b29f5ee9a218f315f8cf56142f089e71d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/445824b29f5ee9a218f315f8cf56142f089e71d0", "html_url": "https://github.com/rust-lang/rust/commit/445824b29f5ee9a218f315f8cf56142f089e71d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/445824b29f5ee9a218f315f8cf56142f089e71d0/comments", "author": null, "committer": null, "parents": [{"sha": "26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876", "html_url": "https://github.com/rust-lang/rust/commit/26f0cd5de7f71a0db0bb3857ce49a11cd0f7d876"}], "stats": {"total": 30, "additions": 13, "deletions": 17}, "files": [{"sha": "d4737f9d604d154467a10a6a5332248032ce0c1a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=445824b29f5ee9a218f315f8cf56142f089e71d0", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n+            ast::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n@@ -342,7 +342,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.straightline(expr, pred, fields)\n             }\n \n-            ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }\n \n@@ -631,9 +631,4 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_call = ty::MethodCall::expr(expr.id);\n-        self.tcx.tables.borrow().method_map.contains_key(&method_call)\n-    }\n }"}, {"sha": "b4b8fbf2064adb5bfce97dcd5488785e66860475", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=445824b29f5ee9a218f315f8cf56142f089e71d0", "patch": "@@ -6631,6 +6631,11 @@ impl<'tcx> ctxt<'tcx> {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n+    pub fn is_overloaded_autoderef(&self, expr_id: ast::NodeId, autoderefs: u32) -> bool {\n+        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n+                                                                            autoderefs))\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }"}, {"sha": "c88c194106e8ccb5e511f98bcd6792b3686cd5ce", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=445824b29f5ee9a218f315f8cf56142f089e71d0", "patch": "@@ -367,8 +367,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 match datum.ty.sty {\n                     // Don't skip a conversion from Box<T> to &T, etc.\n                     ty::TyRef(..) => {\n-                        let method_call = MethodCall::autoderef(expr.id, 0);\n-                        if bcx.tcx().tables.borrow().method_map.contains_key(&method_call) {\n+                        if bcx.tcx().is_overloaded_autoderef(expr.id, 0) {\n                             // Don't skip an overloaded deref.\n                             0\n                         } else {\n@@ -1612,9 +1611,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // The only overloaded operator that is translated to a datum\n     // is an overloaded deref, since it is always yields a `&T`.\n     // Otherwise, we should be in the RvalueDpsExpr path.\n-    assert!(\n-        op == ast::UnDeref ||\n-        !ccx.tcx().tables.borrow().method_map.contains_key(&method_call));\n+    assert!(op == ast::UnDeref || !ccx.tcx().is_method_call(expr.id));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1907,7 +1904,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().is_method_call(expr.id));\n \n     match op.node {\n         ast::BiAnd => {\n@@ -2141,7 +2138,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.tcx().is_method_call(expr.id));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -2606,7 +2603,7 @@ enum ExprKind {\n }\n \n fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n-    if tcx.tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)) {\n+    if tcx.is_method_call(expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:\n         return match expr.node {"}, {"sha": "1c21813fc63bda63920dfb881851332d8324abef", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445824b29f5ee9a218f315f8cf56142f089e71d0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=445824b29f5ee9a218f315f8cf56142f089e71d0", "patch": "@@ -516,8 +516,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n-    let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.tables.borrow().method_map.contains_key(&method_call);\n+    let has_method_map = rcx.fcx.infcx().is_method_call(expr.id);\n \n     // Check any autoderefs or autorefs that appear.\n     let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());"}]}