{"sha": "732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMmEyZGMwOTU3N2Y5M2M1ZWI5ZTRmMDM3ZjdjZTY3MjNkOGQ3ZWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-04T21:24:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-14T11:36:51Z"}, "message": "rustc_mir: split off some qualify_consts::Checker fields into a State struct.", "tree": {"sha": "0b051340f66e0840ee2635f5403609cc85b0ca07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b051340f66e0840ee2635f5403609cc85b0ca07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "html_url": "https://github.com/rust-lang/rust/commit/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5e4d1ad7dee869ff9647f1c6f16fa1e13953dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e4d1ad7dee869ff9647f1c6f16fa1e13953dd6", "html_url": "https://github.com/rust-lang/rust/commit/a5e4d1ad7dee869ff9647f1c6f16fa1e13953dd6"}], "stats": {"total": 134, "additions": 73, "deletions": 61}, "files": [{"sha": "99b825b97a05ae78c8609d6f98e70ff03a87fc2b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 73, "deletions": 61, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "patch": "@@ -94,18 +94,31 @@ impl fmt::Display for Mode {\n     }\n }\n \n-struct Checker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct State {\n+    local_qualif: IndexVec<Local, Option<Qualif>>,\n+\n+    qualif: Qualif,\n+}\n+\n+impl State {\n+    /// Add the given qualification to self.qualif.\n+    fn add(&mut self, qualif: Qualif) {\n+        self.qualif = self.qualif | qualif;\n+    }\n+}\n+\n+struct Checker<'a, 'gcx, 'tcx> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     span: Span,\n     def_id: DefId,\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    local_qualif: IndexVec<Local, Option<Qualif>>,\n-    qualif: Qualif,\n+\n+    state: State,\n     temp_promotion_state: IndexVec<Local, TempState>,\n-    promotion_candidates: Vec<Candidate>\n+    promotion_candidates: Vec<Candidate>,\n }\n \n macro_rules! unleash_miri {\n@@ -145,8 +158,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             rpo,\n             tcx,\n             param_env,\n-            local_qualif,\n-            qualif: Qualif::empty(),\n+            state: State {\n+                local_qualif,\n+                qualif: Qualif::empty(),\n+            },\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -157,7 +172,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n         unleash_miri!(self);\n-        self.add(Qualif::NOT_CONST);\n+        self.state.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n@@ -176,31 +191,26 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Adds the given qualification to `self.qualif`.\n-    fn add(&mut self, qualif: Qualif) {\n-        self.qualif = self.qualif | qualif;\n-    }\n-\n-    /// Adds the given type's qualification to `self.qualif`.\n+    /// Adds the given type's qualification to self.state.qualif.\n     fn add_type(&mut self, ty: Ty<'tcx>) {\n-        self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n-        self.qualif.restrict(ty, self.tcx, self.param_env);\n+        self.state.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n+        self.state.qualif.restrict(ty, self.tcx, self.param_env);\n     }\n \n-    /// Within the provided closure, `self.qualif` will start\n+    /// Within the provided closure, `self.state.qualif` will start\n     /// out empty, and its value after the closure returns will\n     /// be combined with the value before the call to nest.\n     fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let original = self.qualif;\n-        self.qualif = Qualif::empty();\n+        let original = self.state.qualif;\n+        self.state.qualif = Qualif::empty();\n         f(self);\n-        self.add(original);\n+        self.state.add(original);\n     }\n \n     /// Assign the current qualification to the given destination.\n     fn assign(&mut self, dest: &Place<'tcx>, location: Location) {\n         trace!(\"assign: {:?}\", dest);\n-        let qualif = self.qualif;\n+        let qualif = self.state.qualif;\n         let span = self.span;\n         let store = |slot: &mut Option<Qualif>| {\n             if slot.is_some() {\n@@ -215,7 +225,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n                 if self.mir.local_kind(index) == LocalKind::Temp\n                 && self.temp_promotion_state[index].is_promotable() {\n                     debug!(\"store to promotable temp {:?} ({:?})\", index, qualif);\n-                    store(&mut self.local_qualif[index]);\n+                    store(&mut self.state.local_qualif[index]);\n                 }\n             }\n             return;\n@@ -253,14 +263,14 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         };\n         debug!(\"store to var {:?}\", index);\n-        match &mut self.local_qualif[index] {\n+        match &mut self.state.local_qualif[index] {\n             // this is overly restrictive, because even full assignments do not clear the qualif\n             // While we could special case full assignments, this would be inconsistent with\n             // aggregates where we overwrite all fields via assignments, which would not get\n             // that feature.\n-            Some(ref mut qualif) => *qualif = *qualif | self.qualif,\n+            Some(ref mut qualif) => *qualif = *qualif | self.state.qualif,\n             // insert new qualification\n-            qualif @ None => *qualif = Some(self.qualif),\n+            qualif @ None => *qualif = Some(self.state.qualif),\n         }\n     }\n \n@@ -317,12 +327,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        self.qualif = self.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n+        self.state.qualif = self.state.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n \n         // Account for errors in consts by using the\n         // conservative type qualification instead.\n-        if self.qualif.intersects(Qualif::CONST_ERROR) {\n-            self.qualif = Qualif::empty();\n+        if self.state.qualif.intersects(Qualif::CONST_ERROR) {\n+            self.state.qualif = Qualif::empty();\n             let return_ty = mir.return_ty();\n             self.add_type(return_ty);\n         }\n@@ -346,7 +356,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        (self.qualif, Lrc::new(promoted_temps))\n+        (self.state.qualif, Lrc::new(promoted_temps))\n     }\n \n     fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n@@ -355,7 +365,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n     }\n }\n \n-/// Accumulates an Rvalue or Call's effects in self.qualif.\n+/// Accumulates an Rvalue or Call's effects in self.state.qualif.\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n@@ -370,22 +380,22 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                 self.not_const();\n             }\n             LocalKind::Var if self.mode == Mode::Fn => {\n-                self.add(Qualif::NOT_CONST);\n+                self.state.add(Qualif::NOT_CONST);\n             }\n             LocalKind::Var |\n             LocalKind::Arg |\n             LocalKind::Temp => {\n                 if let LocalKind::Arg = kind {\n-                    self.add(Qualif::FN_ARGUMENT);\n+                    self.state.add(Qualif::FN_ARGUMENT);\n                 }\n \n                 if !self.temp_promotion_state[local].is_promotable() {\n                     debug!(\"visit_local: (not promotable) local={:?}\", local);\n-                    self.add(Qualif::NOT_PROMOTABLE);\n+                    self.state.add(Qualif::NOT_PROMOTABLE);\n                 }\n \n-                if let Some(qualif) = self.local_qualif[local] {\n-                    self.add(qualif);\n+                if let Some(qualif) = self.state.local_qualif[local] {\n+                    self.state.add(qualif);\n                 } else {\n                     self.not_const();\n                 }\n@@ -411,7 +421,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                                   \"thread-local statics cannot be \\\n                                    accessed at compile-time\");\n                     }\n-                    self.add(Qualif::NOT_CONST);\n+                    self.state.add(Qualif::NOT_CONST);\n                     return;\n                 }\n \n@@ -430,7 +440,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     return;\n                 }\n                 unleash_miri!(self);\n-                self.add(Qualif::NOT_CONST);\n+                self.state.add(Qualif::NOT_CONST);\n \n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n@@ -458,7 +468,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                                 this.not_const()\n                             } else {\n                                 // just make sure this doesn't get promoted\n-                                this.add(Qualif::NOT_CONST);\n+                                this.state.add(Qualif::NOT_CONST);\n                             }\n                             let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             match this.mode {\n@@ -508,7 +518,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                             }\n \n                             let ty = place.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            this.qualif.restrict(ty, this.tcx, this.param_env);\n+                            this.state.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n \n                         ProjectionElem::Downcast(..) => {\n@@ -529,7 +539,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n             Operand::Move(_) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Operand::Move(Place::Local(local)) = *operand {\n-                    self.local_qualif[local] = self.local_qualif[local].map(|q|\n+                    self.state.local_qualif[local] = self.state.local_qualif[local].map(|q|\n                         q - Qualif::NEEDS_DROP\n                     );\n                 }\n@@ -543,12 +553,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                         let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n-                        self.add(qualif);\n+                        self.state.add(qualif);\n \n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n+                        self.state.qualif.restrict(constant.ty, self.tcx, self.param_env);\n                     }\n                 }\n             }\n@@ -630,7 +640,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n                     if forbidden_mut {\n                         unleash_miri!(self);\n-                        self.add(Qualif::NOT_CONST);\n+                        self.state.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n                             let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                                            \"references in {}s may only refer \\\n@@ -654,11 +664,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     // Constants cannot be borrowed if they contain interior mutability as\n                     // it means that our \"silent insertion of statics\" could change\n                     // initializer values (very bad).\n-                    if self.qualif.contains(Qualif::MUTABLE_INTERIOR) {\n+                    if self.state.qualif.contains(Qualif::MUTABLE_INTERIOR) {\n                         // A reference of a MUTABLE_INTERIOR place is instead\n                         // NOT_CONST (see `if forbidden_mut` below), to avoid\n                         // duplicate errors (from reborrowing, for example).\n-                        self.qualif = self.qualif - Qualif::MUTABLE_INTERIOR;\n+                        self.state.qualif = self.state.qualif - Qualif::MUTABLE_INTERIOR;\n                         if self.mode != Mode::Fn {\n                             span_err!(self.tcx.sess, self.span, E0492,\n                                       \"cannot borrow a constant which may contain \\\n@@ -673,7 +683,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                 debug!(\"visit_rvalue: forbidden_mut={:?}\", forbidden_mut);\n                 if forbidden_mut {\n                     unleash_miri!(self);\n-                    self.add(Qualif::NOT_CONST);\n+                    self.state.add(Qualif::NOT_CONST);\n                 } else {\n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n@@ -689,7 +699,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     if let Place::Local(local) = *place {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n                             debug!(\"visit_rvalue: local={:?}\", local);\n-                            if let Some(qualif) = self.local_qualif[local] {\n+                            if let Some(qualif) = self.state.local_qualif[local] {\n                                 // `forbidden_mut` is false, so we can safely ignore\n                                 // `MUTABLE_INTERIOR` from the local's qualifications.\n                                 // This allows borrowing fields which don't have\n@@ -716,7 +726,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                         unleash_miri!(self);\n                         if let Mode::Fn = self.mode {\n                             // in normal functions, mark such casts as not promotable\n-                            self.add(Qualif::NOT_CONST);\n+                            self.state.add(Qualif::NOT_CONST);\n                         } else if !self.tcx.features().const_raw_ptr_to_usize_cast {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n@@ -744,7 +754,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     unleash_miri!(self);\n                     if let Mode::Fn = self.mode {\n                         // raw pointer operations are not allowed inside promoteds\n-                        self.add(Qualif::NOT_CONST);\n+                        self.state.add(Qualif::NOT_CONST);\n                     } else if !self.tcx.features().const_compare_raw_pointers {\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n@@ -761,7 +771,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                self.add(Qualif::NOT_CONST);\n+                self.state.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n@@ -781,13 +791,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if def.has_dtor(self.tcx) {\n-                        self.add(Qualif::NEEDS_DROP);\n+                        self.state.add(Qualif::NEEDS_DROP);\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n                         let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n-                        assert!(self.qualif.contains(Qualif::MUTABLE_INTERIOR));\n+                        assert!(self.state.qualif.contains(Qualif::MUTABLE_INTERIOR));\n                     }\n                 }\n             }\n@@ -983,7 +993,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     }\n                     let candidate = Candidate::Argument { bb, index: i };\n                     if is_shuffle && i == 2 {\n-                        if this.qualif.is_empty() {\n+                        if this.state.qualif.is_empty() {\n                             debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                             this.promotion_candidates.push(candidate);\n                         } else {\n@@ -1010,7 +1020,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     // which happens even without the user requesting it.\n                     // We can error out with a hard error if the argument is not\n                     // constant here.\n-                    if (this.qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n+                    if (this.state.qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n                         debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n                         this.promotion_candidates.push(candidate);\n                     } else {\n@@ -1023,7 +1033,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n             // non-const fn calls\n             if !is_const_fn {\n-                self.qualif = Qualif::NOT_CONST;\n+                self.state.qualif = Qualif::NOT_CONST;\n                 if self.mode != Mode::Fn {\n                     self.tcx.sess.delay_span_bug(\n                         self.span,\n@@ -1034,16 +1044,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n             if let Some((ref dest, _)) = *destination {\n                 // Avoid propagating irrelevant callee/argument qualifications.\n-                if self.qualif.intersects(Qualif::CONST_ERROR) {\n-                    self.qualif = Qualif::NOT_CONST;\n+                if self.state.qualif.intersects(Qualif::CONST_ERROR) {\n+                    self.state.qualif = Qualif::NOT_CONST;\n                 } else {\n                     // Be conservative about the returned value of a const fn.\n                     let tcx = self.tcx;\n                     let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n                     if is_const_fn && !is_promotable_const_fn && self.mode == Mode::Fn {\n-                        self.qualif = Qualif::NOT_PROMOTABLE;\n+                        self.state.qualif = Qualif::NOT_PROMOTABLE;\n                     } else {\n-                        self.qualif = Qualif::empty();\n+                        self.state.qualif = Qualif::empty();\n                     }\n                     self.add_type(ty);\n                 }\n@@ -1058,7 +1068,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    if self.local_qualif[local].map_or(true, |q| q.contains(Qualif::NEEDS_DROP)) {\n+                    let local_needs_drop = self.state.local_qualif[local]\n+                        .map_or(true, |q| q.contains(Qualif::NEEDS_DROP));\n+                    if local_needs_drop {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n                         None"}]}