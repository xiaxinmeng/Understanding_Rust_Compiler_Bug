{"sha": "6ee4265ca6a7f037237974eeb66e8303282c6a4c", "node_id": "C_kwDOAAsO6NoAKDZlZTQyNjVjYTZhN2YwMzcyMzc5NzRlZWI2NmU4MzAzMjgyYzZhNGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-15T00:03:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-15T00:03:10Z"}, "message": "Auto merge of #104455 - the8472:dont-drain-on-drop, r=Amanieu\n\nDon't drain-on-drop in DrainFilter impls of various collections.\n\nThis removes drain-on-drop behavior from various unstable DrainFilter impls (not yet for HashSet/Map) because that behavior [is problematic](https://github.com/rust-lang/rust/issues/43244#issuecomment-641638196) (because it can lead to panic-in-drop when user closures panic) and may become forbidden if [this draft RFC passes](https://github.com/rust-lang/rfcs/pull/3288).\n\ncloses #101122\n\n[ACP](https://github.com/rust-lang/libs-team/issues/136)\n\naffected tracking issues\n* #43244\n* #70530\n* #59618\n\nRelated hashbrown update: https://github.com/rust-lang/hashbrown/pull/374", "tree": {"sha": "5863c54ae56b238f764911acb9113070d389c27e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5863c54ae56b238f764911acb9113070d389c27e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ee4265ca6a7f037237974eeb66e8303282c6a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee4265ca6a7f037237974eeb66e8303282c6a4c", "html_url": "https://github.com/rust-lang/rust/commit/6ee4265ca6a7f037237974eeb66e8303282c6a4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ee4265ca6a7f037237974eeb66e8303282c6a4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "html_url": "https://github.com/rust-lang/rust/commit/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220"}, {"sha": "0c5f442db425e05de7f57b040a9818186981d952", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5f442db425e05de7f57b040a9818186981d952", "html_url": "https://github.com/rust-lang/rust/commit/0c5f442db425e05de7f57b040a9818186981d952"}], "stats": {"total": 1026, "additions": 449, "deletions": 577}, "files": [{"sha": "4eafda94037c384b8931fe4b9c24405313ecc592", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -65,6 +65,12 @@ dependencies = [\n  \"rand_xorshift\",\n ]\n \n+[[package]]\n+name = \"allocator-api2\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c4f263788a35611fba42eb41ff811c5d0360c58b97402570312a350736e2542e\"\n+\n [[package]]\n name = \"ammonia\"\n version = \"3.2.0\"\n@@ -1522,6 +1528,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"33ff8ae62cd3a9102e5637afc8452c55acf3844001bd5374e0b0bd7b6616c038\"\n dependencies = [\n  \"ahash 0.8.2\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a\"\n+dependencies = [\n+ \"allocator-api2\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -4633,7 +4648,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.13.1\",\n+ \"hashbrown 0.14.0\",\n  \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\","}, {"sha": "24d1cc8af82f513060e0704ad967c3f1151d9082", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -4,7 +4,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n-#![feature(drain_filter)]\n+#![feature(extract_if)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(never_type)]\n@@ -1399,7 +1399,7 @@ impl HandlerInner {\n                     !self.emitted_diagnostics.insert(diagnostic_hash)\n                 };\n \n-                diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n+                diagnostic.children.extract_if(already_emitted_sub).for_each(|_| {});\n \n                 self.emitter.emit_diagnostic(diagnostic);\n                 if diagnostic.is_error() {"}, {"sha": "d2a1b1c1a428ee8f595b0434eedcaed39f886cc2", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -59,8 +59,6 @@ This API is completely unstable and subject to change.\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(drain_filter)]\n-#![feature(hash_drain_filter)]\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n #![feature(iter_intersperse)]"}, {"sha": "bf8ad5faac48219b13be34d004ba2c4a6318367a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -753,20 +753,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        errors.drain_filter(|error| {\n+        errors.retain(|error| {\n             let Error::Invalid(\n                 provided_idx,\n                 expected_idx,\n                 Compatibility::Incompatible(Some(e)),\n-            ) = error else { return false };\n+            ) = error else { return true };\n             let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n             let trace =\n                 mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n             if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308) {\n                 self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n-                return true;\n+                return false;\n             }\n-            false\n+            true\n         });\n \n         // We're done if we found errors, but we already emitted them."}, {"sha": "7a897778ff7af61c5b225d0ab64b61f14b17b06c", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -5,7 +5,6 @@\n #![feature(box_patterns)]\n #![feature(min_specialization)]\n #![feature(control_flow_enum)]\n-#![feature(drain_filter)]\n #![feature(option_as_slice)]\n #![allow(rustc::potential_query_instability)]\n #![recursion_limit = \"256\"]"}, {"sha": "87373d9974357178697a114af255ee3a0d3877f9", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1,6 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(decl_macro)]\n-#![feature(drain_filter)]\n+#![feature(extract_if)]\n #![feature(generators)]\n #![feature(iter_from_generator)]\n #![feature(let_chains)]"}, {"sha": "0dd7b11979168239dddc7425a79e9bc85e481ba2", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -425,7 +425,7 @@ impl<'tcx> Collector<'tcx> {\n             // can move them to the end of the list below.\n             let mut existing = self\n                 .libs\n-                .drain_filter(|lib| {\n+                .extract_if(|lib| {\n                     if lib.name.as_str() == passed_lib.name {\n                         // FIXME: This whole logic is questionable, whether modifiers are\n                         // involved or not, library reordering and kind overriding without"}, {"sha": "1b125e8e26dbc07af555f1694edd5091b25b41f8", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -54,7 +54,7 @@\n #![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n #![feature(decl_macro)]\n-#![feature(drain_filter)]\n+#![feature(extract_if)]\n #![feature(intra_doc_pointers)]\n #![feature(yeet_expr)]\n #![feature(result_option_inspect)]"}, {"sha": "9c948dba1e4382da0cb0cab77053ebfd0a4c08fa", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -237,7 +237,7 @@ pub fn suggest_constraining_type_params<'a>(\n \n         {\n             let mut sized_constraints =\n-                constraints.drain_filter(|(_, def_id)| *def_id == tcx.lang_items().sized_trait());\n+                constraints.extract_if(|(_, def_id)| *def_id == tcx.lang_items().sized_trait());\n             if let Some((constraint, def_id)) = sized_constraints.next() {\n                 applicability = Applicability::MaybeIncorrect;\n "}, {"sha": "9c8c0ea0be004c88b9b5553da36c74fee469577a", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -2,7 +2,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n #![feature(map_try_insert)]"}, {"sha": "881a1547c52458f0df09ac925a0fc395da3802dc", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -436,26 +436,24 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n             VarDebugInfoContents::Composite { ty: _, ref mut fragments } => {\n                 let mut new_fragments = Vec::new();\n                 debug!(?fragments);\n-                fragments\n-                    .drain_filter(|fragment| {\n-                        if let Some(repl) =\n+                fragments.retain_mut(|fragment| {\n+                    if let Some(repl) =\n                             self.replacements.replace_place(self.tcx, fragment.contents.as_ref())\n                         {\n                             fragment.contents = repl;\n-                            false\n+                            true\n                         } else if let Some(local) = fragment.contents.as_local()\n                             && let Some(frg) = self.gather_debug_info_fragments(local)\n                         {\n                             new_fragments.extend(frg.into_iter().map(|mut f| {\n                                 f.projection.splice(0..0, fragment.projection.iter().copied());\n                                 f\n                             }));\n-                            true\n-                        } else {\n                             false\n+                        } else {\n+                            true\n                         }\n-                    })\n-                    .for_each(drop);\n+                });\n                 debug!(?fragments);\n                 debug!(?new_fragments);\n                 fragments.extend(new_fragments);"}, {"sha": "e42b2df1a5ab80effb99a032acdde2baae877418", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -2494,7 +2494,7 @@ fn show_candidates(\n     for path_strings in [&mut accessible_path_strings, &mut inaccessible_path_strings] {\n         path_strings.sort_by(|a, b| a.0.cmp(&b.0));\n         let core_path_strings =\n-            path_strings.drain_filter(|p| p.0.starts_with(\"core::\")).collect::<Vec<_>>();\n+            path_strings.extract_if(|p| p.0.starts_with(\"core::\")).collect::<Vec<_>>();\n         path_strings.extend(core_path_strings);\n         path_strings.dedup_by(|a, b| a.0 == b.0);\n     }"}, {"sha": "e4b01ef2b17100979bd1f979b09a562a965c8e0e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -496,7 +496,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         // Try to filter out intrinsics candidates, as long as we have\n         // some other candidates to suggest.\n         let intrinsic_candidates: Vec<_> = candidates\n-            .drain_filter(|sugg| {\n+            .extract_if(|sugg| {\n                 let path = path_names_to_string(&sugg.path);\n                 path.starts_with(\"core::intrinsics::\") || path.starts_with(\"std::intrinsics::\")\n             })"}, {"sha": "82b333fee28b8622a4ccf0402ace21fcff3ec408", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -9,7 +9,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n+#![feature(extract_if)]\n #![feature(if_let_guard)]\n #![feature(iter_intersperse)]\n #![feature(let_chains)]"}, {"sha": "56d37d58de75268a3f8efc3d9c7b505ff0142aaa", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -14,8 +14,7 @@\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(drain_filter)]\n-#![feature(hash_drain_filter)]\n+#![feature(extract_if)]\n #![feature(let_chains)]\n #![feature(if_let_guard)]\n #![feature(never_type)]"}, {"sha": "db9cb82585f6934eefa1080773f5f5dba33bdbc4", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -354,7 +354,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| {\n+        .extract_if(|predicate| {\n             matches!(\n                 predicate.kind().skip_binder(),\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))"}, {"sha": "0a1e971f268e3cce987585257e439ad65689c878", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1170,11 +1170,11 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let mut deduped: SsoHashSet<_> = Default::default();\n-            result.obligations.drain_filter(|projected_obligation| {\n+            result.obligations.retain(|projected_obligation| {\n                 if !deduped.insert(projected_obligation.clone()) {\n-                    return true;\n+                    return false;\n                 }\n-                false\n+                true\n             });\n \n             if use_cache {"}, {"sha": "590d0bd0e42e1d59d9e3714a62ac8a979f6a3342", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -4,7 +4,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(let_chains)]\n-#![feature(drain_filter)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7d236647750d0878def9e9776550baf609ceee29", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -385,15 +385,15 @@ pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n #[bench]\n pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n     let src = slim_map(100);\n-    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+    b.iter(|| src.clone().extract_if(|_, _| true).count())\n }\n \n #[bench]\n pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n     let src = slim_map(100);\n     b.iter(|| {\n         let mut map = src.clone();\n-        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.extract_if(|i, _| i % 2 == 0).count(), 100 / 2);\n         assert_eq!(map.len(), 100 / 2);\n     })\n }\n@@ -456,15 +456,15 @@ pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n #[bench]\n pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n     let src = slim_map(10_000);\n-    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+    b.iter(|| src.clone().extract_if(|_, _| true).count())\n }\n \n #[bench]\n pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n     let src = slim_map(10_000);\n     b.iter(|| {\n         let mut map = src.clone();\n-        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.extract_if(|i, _| i % 2 == 0).count(), 10_000 / 2);\n         assert_eq!(map.len(), 10_000 / 2);\n     })\n }\n@@ -527,15 +527,15 @@ pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n #[bench]\n pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n     let src = fat_val_map(100);\n-    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+    b.iter(|| src.clone().extract_if(|_, _| true).count())\n }\n \n #[bench]\n pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n     let src = fat_val_map(100);\n     b.iter(|| {\n         let mut map = src.clone();\n-        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.extract_if(|i, _| i % 2 == 0).count(), 100 / 2);\n         assert_eq!(map.len(), 100 / 2);\n     })\n }"}, {"sha": "09d72c72064692b145c73793fcd339eeb9836dd8", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -69,15 +69,15 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n     let src = slim_set(100);\n-    b.iter(|| src.clone().drain_filter(|_| true).count())\n+    b.iter(|| src.clone().extract_if(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n     let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.extract_if(|i| i % 2 == 0).count(), 100 / 2);\n         assert_eq!(set.len(), 100 / 2);\n     })\n }\n@@ -140,15 +140,15 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n     let src = slim_set(10_000);\n-    b.iter(|| src.clone().drain_filter(|_| true).count())\n+    b.iter(|| src.clone().extract_if(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n     let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.extract_if(|i| i % 2 == 0).count(), 10_000 / 2);\n         assert_eq!(set.len(), 10_000 / 2);\n     })\n }"}, {"sha": "638f343fb244b6d07a9587630a7715bd0e87a787", "filename": "library/alloc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1,7 +1,7 @@\n // Disabling on android for the time being\n // See https://github.com/rust-lang/rust/issues/73535#event-3477699747\n #![cfg(not(target_os = \"android\"))]\n-#![feature(btree_drain_filter)]\n+#![feature(btree_extract_if)]\n #![feature(iter_next_chunk)]\n #![feature(repr_simd)]\n #![feature(slice_partition_dedup)]"}, {"sha": "ff908ec12ec86022a3039d0dd6ee5aea09e2ca51", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 32, "deletions": 44, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1132,7 +1132,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n         K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        self.drain_filter(|k, v| !f(k, v));\n+        self.extract_if(|k, v| !f(k, v)).for_each(drop);\n     }\n \n     /// Moves all elements from `other` into `self`, leaving `other` empty.\n@@ -1395,48 +1395,45 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// The iterator also lets you mutate the value of each element in the\n     /// closure, regardless of whether you choose to keep or remove it.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each\n-    /// of the remaining elements is still subjected to the closure, which may\n-    /// change its value and, by returning `true`, have the element removed and\n-    /// dropped.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more elements will be subjected to the\n-    /// closure if a panic occurs in the closure, or a panic occurs while\n-    /// dropping an element, or if the `DrainFilter` value is leaked.\n+    /// [`retain`]: BTreeMap::retain\n     ///\n     /// # Examples\n     ///\n     /// Splitting a map into even and odd keys, reusing the original map:\n     ///\n     /// ```\n-    /// #![feature(btree_drain_filter)]\n+    /// #![feature(btree_extract_if)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n-    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let evens: BTreeMap<_, _> = map.extract_if(|k, _v| k % 2 == 0).collect();\n     /// let odds = map;\n     /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), [0, 2, 4, 6]);\n     /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n     /// ```\n-    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F, A>\n+    #[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+    pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, K, V, F, A>\n     where\n         K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        let (inner, alloc) = self.drain_filter_inner();\n-        DrainFilter { pred, inner, alloc }\n+        let (inner, alloc) = self.extract_if_inner();\n+        ExtractIf { pred, inner, alloc }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> (DrainFilterInner<'_, K, V>, A)\n+    pub(super) fn extract_if_inner(&mut self) -> (ExtractIfInner<'_, K, V>, A)\n     where\n         K: Ord,\n     {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n             let front = root.borrow_mut().first_leaf_edge();\n             (\n-                DrainFilterInner {\n+                ExtractIfInner {\n                     length: &mut self.length,\n                     dormant_root: Some(dormant_root),\n                     cur_leaf_edge: Some(front),\n@@ -1445,7 +1442,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n             )\n         } else {\n             (\n-                DrainFilterInner {\n+                ExtractIfInner {\n                     length: &mut self.length,\n                     dormant_root: None,\n                     cur_leaf_edge: None,\n@@ -1899,9 +1896,10 @@ impl<K, V> Default for Values<'_, K, V> {\n     }\n }\n \n-/// An iterator produced by calling `drain_filter` on BTreeMap.\n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-pub struct DrainFilter<\n+/// An iterator produced by calling `extract_if` on BTreeMap.\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<\n     'a,\n     K,\n     V,\n@@ -1911,13 +1909,13 @@ pub struct DrainFilter<\n     F: 'a + FnMut(&K, &mut V) -> bool,\n {\n     pred: F,\n-    inner: DrainFilterInner<'a, K, V>,\n+    inner: ExtractIfInner<'a, K, V>,\n     /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n     alloc: A,\n }\n-/// Most of the implementation of DrainFilter are generic over the type\n-/// of the predicate, thus also serving for BTreeSet::DrainFilter.\n-pub(super) struct DrainFilterInner<'a, K, V> {\n+/// Most of the implementation of ExtractIf are generic over the type\n+/// of the predicate, thus also serving for BTreeSet::ExtractIf.\n+pub(super) struct ExtractIfInner<'a, K, V> {\n     /// Reference to the length field in the borrowed map, updated live.\n     length: &'a mut usize,\n     /// Buried reference to the root field in the borrowed map.\n@@ -1929,30 +1927,20 @@ pub(super) struct DrainFilterInner<'a, K, V> {\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F, A: Allocator + Clone> Drop for DrainFilter<'_, K, V, F, A>\n-where\n-    F: FnMut(&K, &mut V) -> bool,\n-{\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F> fmt::Debug for DrainFilter<'_, K, V, F>\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<K, V, F> fmt::Debug for ExtractIf<'_, K, V, F>\n where\n     K: fmt::Debug,\n     V: fmt::Debug,\n     F: FnMut(&K, &mut V) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+        f.debug_tuple(\"ExtractIf\").field(&self.inner.peek()).finish()\n     }\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F, A: Allocator + Clone> Iterator for DrainFilter<'_, K, V, F, A>\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<K, V, F, A: Allocator + Clone> Iterator for ExtractIf<'_, K, V, F, A>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -1967,14 +1955,14 @@ where\n     }\n }\n \n-impl<'a, K, V> DrainFilterInner<'a, K, V> {\n+impl<'a, K, V> ExtractIfInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n         let edge = self.cur_leaf_edge.as_ref()?;\n         edge.reborrow().next_kv().ok().map(Handle::into_kv)\n     }\n \n-    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    /// Implementation of a typical `ExtractIf::next` method, given the predicate.\n     pub(super) fn next<F, A: Allocator + Clone>(&mut self, pred: &mut F, alloc: A) -> Option<(K, V)>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n@@ -2001,7 +1989,7 @@ impl<'a, K, V> DrainFilterInner<'a, K, V> {\n         None\n     }\n \n-    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    /// Implementation of a typical `ExtractIf::size_hint` method.\n     pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n         // In most of the btree iterators, `self.length` is the number of elements\n         // yet to be visited. Here, it includes elements that were visited and that\n@@ -2011,8 +1999,8 @@ impl<'a, K, V> DrainFilterInner<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for ExtractIf<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {"}, {"sha": "8681cfcd6175728f3caf7805fd682385ae391f62", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -941,13 +941,13 @@ fn test_retain() {\n     assert_eq!(map[&6], 60);\n }\n \n-mod test_drain_filter {\n+mod test_extract_if {\n     use super::*;\n \n     #[test]\n     fn empty() {\n         let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n-        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        map.extract_if(|_, _| unreachable!(\"there's nothing to decide on\")).for_each(drop);\n         assert_eq!(map.height(), None);\n         map.check();\n     }\n@@ -957,7 +957,7 @@ mod test_drain_filter {\n     fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n+        assert!(map.extract_if(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n@@ -966,7 +966,7 @@ mod test_drain_filter {\n     fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs.clone());\n-        assert!(map.drain_filter(|_, _| true).eq(pairs));\n+        assert!(map.extract_if(|_, _| true).eq(pairs));\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -977,7 +977,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 false\n             })\n@@ -994,7 +994,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 true\n             })\n@@ -1008,7 +1008,7 @@ mod test_drain_filter {\n     fn underfull_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| false);\n+        map.extract_if(|_, _| false).for_each(drop);\n         assert!(map.keys().copied().eq(0..3));\n         map.check();\n     }\n@@ -1018,7 +1018,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         for doomed in 0..3 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.extract_if(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), 2);\n             map.check();\n         }\n@@ -1029,7 +1029,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         for sacred in 0..3 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.extract_if(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1039,7 +1039,7 @@ mod test_drain_filter {\n     fn underfull_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.extract_if(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1048,7 +1048,7 @@ mod test_drain_filter {\n     fn height_0_keeping_all() {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| false);\n+        map.extract_if(|_, _| false).for_each(drop);\n         assert!(map.keys().copied().eq(0..node::CAPACITY));\n         map.check();\n     }\n@@ -1058,7 +1058,7 @@ mod test_drain_filter {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         for doomed in 0..node::CAPACITY {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.extract_if(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), node::CAPACITY - 1);\n             map.check();\n         }\n@@ -1069,7 +1069,7 @@ mod test_drain_filter {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         for sacred in 0..node::CAPACITY {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.extract_if(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1079,15 +1079,15 @@ mod test_drain_filter {\n     fn height_0_removing_all() {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.extract_if(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_half() {\n         let mut map = BTreeMap::from_iter((0..16).map(|i| (i, i)));\n-        assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n+        assert_eq!(map.extract_if(|i, _| *i % 2 == 0).count(), 8);\n         assert_eq!(map.len(), 8);\n         map.check();\n     }\n@@ -1096,7 +1096,7 @@ mod test_drain_filter {\n     fn height_1_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.extract_if(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1106,7 +1106,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.extract_if(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n             map.check();\n         }\n@@ -1117,7 +1117,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.extract_if(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1128,7 +1128,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.extract_if(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n             map.check();\n         }\n@@ -1139,7 +1139,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.extract_if(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1149,7 +1149,7 @@ mod test_drain_filter {\n     fn height_2_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.extract_if(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1165,7 +1165,8 @@ mod test_drain_filter {\n         map.insert(b.spawn(Panic::InDrop), ());\n         map.insert(c.spawn(Panic::Never), ());\n \n-        catch_unwind(move || drop(map.drain_filter(|dummy, _| dummy.query(true)))).unwrap_err();\n+        catch_unwind(move || map.extract_if(|dummy, _| dummy.query(true)).for_each(drop))\n+            .unwrap_err();\n \n         assert_eq!(a.queried(), 1);\n         assert_eq!(b.queried(), 1);\n@@ -1186,8 +1187,10 @@ mod test_drain_filter {\n         map.insert(b.spawn(Panic::InQuery), ());\n         map.insert(c.spawn(Panic::InQuery), ());\n \n-        catch_unwind(AssertUnwindSafe(|| drop(map.drain_filter(|dummy, _| dummy.query(true)))))\n-            .unwrap_err();\n+        catch_unwind(AssertUnwindSafe(|| {\n+            map.extract_if(|dummy, _| dummy.query(true)).for_each(drop)\n+        }))\n+        .unwrap_err();\n \n         assert_eq!(a.queried(), 1);\n         assert_eq!(b.queried(), 1);\n@@ -1214,7 +1217,7 @@ mod test_drain_filter {\n         map.insert(c.spawn(Panic::InQuery), ());\n \n         {\n-            let mut it = map.drain_filter(|dummy, _| dummy.query(true));\n+            let mut it = map.extract_if(|dummy, _| dummy.query(true));\n             catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n             // Iterator behaviour after a panic is explicitly unspecified,\n             // so this is just the current implementation:\n@@ -1657,8 +1660,8 @@ fn assert_sync() {\n         v.into_values()\n     }\n \n-    fn drain_filter<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n-        v.drain_filter(|_, _| false)\n+    fn extract_if<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.extract_if(|_, _| false)\n     }\n \n     fn iter<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n@@ -1726,8 +1729,8 @@ fn assert_send() {\n         v.into_values()\n     }\n \n-    fn drain_filter<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n-        v.drain_filter(|_, _| false)\n+    fn extract_if<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.extract_if(|_, _| false)\n     }\n \n     fn iter<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {"}, {"sha": "c4461040b20d78c4c843a7e4d68b228cb55606de", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -999,7 +999,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n         T: Ord,\n         F: FnMut(&T) -> bool,\n     {\n-        self.drain_filter(|v| !f(v));\n+        self.extract_if(|v| !f(v)).for_each(drop);\n     }\n \n     /// Moves all elements from `other` into `self`, leaving `other` empty.\n@@ -1084,36 +1084,33 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// yielded. If the closure returns `false`, or panics, the element remains\n     /// in the set and will not be yielded.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each\n-    /// of the remaining elements is still subjected to the closure and removed\n-    /// and dropped if it returns `true`.\n-    ///\n-    /// It is unspecified how many more elements will be subjected to the\n-    /// closure if a panic occurs in the closure, or if a panic occurs while\n-    /// dropping an element, or if the `DrainFilter` itself is leaked.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n+    /// [`retain`]: BTreeSet::retain\n     /// # Examples\n     ///\n     /// Splitting a set into even and odd values, reusing the original set:\n     ///\n     /// ```\n-    /// #![feature(btree_drain_filter)]\n+    /// #![feature(btree_extract_if)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut set: BTreeSet<i32> = (0..8).collect();\n-    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let evens: BTreeSet<_> = set.extract_if(|v| v % 2 == 0).collect();\n     /// let odds = set;\n     /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n     /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n     /// ```\n-    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F, A>\n+    #[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+    pub fn extract_if<'a, F>(&'a mut self, pred: F) -> ExtractIf<'a, T, F, A>\n     where\n         T: Ord,\n         F: 'a + FnMut(&T) -> bool,\n     {\n-        let (inner, alloc) = self.map.drain_filter_inner();\n-        DrainFilter { pred, inner, alloc }\n+        let (inner, alloc) = self.map.extract_if_inner();\n+        ExtractIf { pred, inner, alloc }\n     }\n \n     /// Gets an iterator that visits the elements in the `BTreeSet` in ascending\n@@ -1275,9 +1272,10 @@ impl<'a, T, A: Allocator + Clone> IntoIterator for &'a BTreeSet<T, A> {\n     }\n }\n \n-/// An iterator produced by calling `drain_filter` on BTreeSet.\n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-pub struct DrainFilter<\n+/// An iterator produced by calling `extract_if` on BTreeSet.\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<\n     'a,\n     T,\n     F,\n@@ -1287,34 +1285,24 @@ pub struct DrainFilter<\n     F: 'a + FnMut(&T) -> bool,\n {\n     pred: F,\n-    inner: super::map::DrainFilterInner<'a, T, SetValZST>,\n+    inner: super::map::ExtractIfInner<'a, T, SetValZST>,\n     /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n     alloc: A,\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator + Clone> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator + Clone> fmt::Debug for DrainFilter<'_, T, F, A>\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<T, F, A: Allocator + Clone> fmt::Debug for ExtractIf<'_, T, F, A>\n where\n     T: fmt::Debug,\n     F: FnMut(&T) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+        f.debug_tuple(\"ExtractIf\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n     }\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F, A: Allocator + Clone> Iterator for DrainFilter<'_, T, F, A>\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<'a, T, F, A: Allocator + Clone> Iterator for ExtractIf<'_, T, F, A>\n where\n     F: 'a + FnMut(&T) -> bool,\n {\n@@ -1331,11 +1319,8 @@ where\n     }\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator + Clone> FusedIterator for DrainFilter<'_, T, F, A> where\n-    F: FnMut(&T) -> bool\n-{\n-}\n+#[unstable(feature = \"btree_extract_if\", issue = \"70530\")]\n+impl<T, F, A: Allocator + Clone> FusedIterator for ExtractIf<'_, T, F, A> where F: FnMut(&T) -> bool {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord, A: Allocator + Clone> Extend<T> for BTreeSet<T, A> {"}, {"sha": "e05bf0e20036d1040b68152ef69a702703ce185f", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -366,19 +366,19 @@ fn test_retain() {\n }\n \n #[test]\n-fn test_drain_filter() {\n+fn test_extract_if() {\n     let mut x = BTreeSet::from([1]);\n     let mut y = BTreeSet::from([1]);\n \n-    x.drain_filter(|_| true);\n-    y.drain_filter(|_| false);\n+    x.extract_if(|_| true).for_each(drop);\n+    y.extract_if(|_| false).for_each(drop);\n     assert_eq!(x.len(), 0);\n     assert_eq!(y.len(), 1);\n }\n \n #[test]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn test_drain_filter_drop_panic_leak() {\n+fn test_extract_if_drop_panic_leak() {\n     let a = CrashTestDummy::new(0);\n     let b = CrashTestDummy::new(1);\n     let c = CrashTestDummy::new(2);\n@@ -387,7 +387,7 @@ fn test_drain_filter_drop_panic_leak() {\n     set.insert(b.spawn(Panic::InDrop));\n     set.insert(c.spawn(Panic::Never));\n \n-    catch_unwind(move || drop(set.drain_filter(|dummy| dummy.query(true)))).ok();\n+    catch_unwind(move || set.extract_if(|dummy| dummy.query(true)).for_each(drop)).ok();\n \n     assert_eq!(a.queried(), 1);\n     assert_eq!(b.queried(), 1);\n@@ -399,7 +399,7 @@ fn test_drain_filter_drop_panic_leak() {\n \n #[test]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn test_drain_filter_pred_panic_leak() {\n+fn test_extract_if_pred_panic_leak() {\n     let a = CrashTestDummy::new(0);\n     let b = CrashTestDummy::new(1);\n     let c = CrashTestDummy::new(2);\n@@ -408,7 +408,8 @@ fn test_drain_filter_pred_panic_leak() {\n     set.insert(b.spawn(Panic::InQuery));\n     set.insert(c.spawn(Panic::InQuery));\n \n-    catch_unwind(AssertUnwindSafe(|| drop(set.drain_filter(|dummy| dummy.query(true))))).ok();\n+    catch_unwind(AssertUnwindSafe(|| set.extract_if(|dummy| dummy.query(true)).for_each(drop)))\n+        .ok();\n \n     assert_eq!(a.queried(), 1);\n     assert_eq!(b.queried(), 1);\n@@ -605,8 +606,8 @@ fn assert_sync() {\n         v.range(..)\n     }\n \n-    fn drain_filter<T: Sync + Ord>(v: &mut BTreeSet<T>) -> impl Sync + '_ {\n-        v.drain_filter(|_| false)\n+    fn extract_if<T: Sync + Ord>(v: &mut BTreeSet<T>) -> impl Sync + '_ {\n+        v.extract_if(|_| false)\n     }\n \n     fn difference<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n@@ -644,8 +645,8 @@ fn assert_send() {\n         v.range(..)\n     }\n \n-    fn drain_filter<T: Send + Ord>(v: &mut BTreeSet<T>) -> impl Send + '_ {\n-        v.drain_filter(|_| false)\n+    fn extract_if<T: Send + Ord>(v: &mut BTreeSet<T>) -> impl Send + '_ {\n+        v.extract_if(|_| false)\n     }\n \n     fn difference<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {"}, {"sha": "052edf453f6793cd18a113dac5ad873f11aff6f9", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1030,36 +1030,40 @@ impl<T, A: Allocator> LinkedList<T, A> {\n     /// If the closure returns false, the element will remain in the list and will not be yielded\n     /// by the iterator.\n     ///\n-    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use `extract_if().for_each(drop)` if you do not need the returned iterator.\n+    ///\n+    /// Note that `extract_if` lets you mutate every element in the filter closure, regardless of\n     /// whether you choose to keep or remove it.\n     ///\n     /// # Examples\n     ///\n     /// Splitting a list into evens and odds, reusing the original list:\n     ///\n     /// ```\n-    /// #![feature(drain_filter)]\n+    /// #![feature(extract_if)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut numbers: LinkedList<u32> = LinkedList::new();\n     /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n     ///\n-    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n+    /// let evens = numbers.extract_if(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n     /// let odds = numbers;\n     ///\n     /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n     /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n-    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F, A>\n+    #[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn extract_if<F>(&mut self, filter: F) -> ExtractIf<'_, T, F, A>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n         // avoid borrow issues.\n         let it = self.head;\n         let old_len = self.len;\n \n-        DrainFilter { list: self, it, pred: filter, idx: 0, old_len }\n+        ExtractIf { list: self, it, pred: filter, idx: 0, old_len }\n     }\n }\n \n@@ -1803,9 +1807,10 @@ impl<'a, T, A: Allocator> CursorMut<'a, T, A> {\n     }\n }\n \n-/// An iterator produced by calling `drain_filter` on LinkedList.\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-pub struct DrainFilter<\n+/// An iterator produced by calling `extract_if` on LinkedList.\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<\n     'a,\n     T: 'a,\n     F: 'a,\n@@ -1820,8 +1825,8 @@ pub struct DrainFilter<\n     old_len: usize,\n }\n \n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Iterator for ExtractIf<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n@@ -1849,40 +1854,13 @@ where\n     }\n }\n \n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        struct DropGuard<'r, 'a, T, F, A: Allocator>(&'r mut DrainFilter<'a, T, F, A>)\n-        where\n-            F: FnMut(&mut T) -> bool;\n-\n-        impl<'r, 'a, T, F, A: Allocator> Drop for DropGuard<'r, 'a, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                self.0.for_each(drop);\n-            }\n-        }\n-\n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T: fmt::Debug, F> fmt::Debug for DrainFilter<'_, T, F>\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+impl<T: fmt::Debug, F> fmt::Debug for ExtractIf<'_, T, F>\n where\n     F: FnMut(&mut T) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DrainFilter\").field(&self.list).finish()\n+        f.debug_tuple(\"ExtractIf\").field(&self.list).finish()\n     }\n }\n "}, {"sha": "8dcd59d12d927f7c41d7bd43064fc5e340169f31", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -540,10 +540,10 @@ fn test_show() {\n }\n \n #[test]\n-fn drain_filter_test() {\n+fn extract_if_test() {\n     let mut m: LinkedList<u32> = LinkedList::new();\n     m.extend(&[1, 2, 3, 4, 5, 6]);\n-    let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+    let deleted = m.extract_if(|v| *v < 4).collect::<Vec<_>>();\n \n     check_links(&m);\n \n@@ -555,7 +555,7 @@ fn drain_filter_test() {\n fn drain_to_empty_test() {\n     let mut m: LinkedList<u32> = LinkedList::new();\n     m.extend(&[1, 2, 3, 4, 5, 6]);\n-    let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+    let deleted = m.extract_if(|_| true).collect::<Vec<_>>();\n \n     check_links(&m);\n \n@@ -811,11 +811,11 @@ fn test_contains() {\n }\n \n #[test]\n-fn drain_filter_empty() {\n+fn extract_if_empty() {\n     let mut list: LinkedList<i32> = LinkedList::new();\n \n     {\n-        let mut iter = list.drain_filter(|_| true);\n+        let mut iter = list.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(0)));\n         assert_eq!(iter.next(), None);\n         assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -828,13 +828,13 @@ fn drain_filter_empty() {\n }\n \n #[test]\n-fn drain_filter_zst() {\n+fn extract_if_zst() {\n     let mut list: LinkedList<_> = [(), (), (), (), ()].into_iter().collect();\n     let initial_len = list.len();\n     let mut count = 0;\n \n     {\n-        let mut iter = list.drain_filter(|_| true);\n+        let mut iter = list.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         while let Some(_) = iter.next() {\n             count += 1;\n@@ -851,14 +851,14 @@ fn drain_filter_zst() {\n }\n \n #[test]\n-fn drain_filter_false() {\n+fn extract_if_false() {\n     let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n     let initial_len = list.len();\n     let mut count = 0;\n \n     {\n-        let mut iter = list.drain_filter(|_| false);\n+        let mut iter = list.extract_if(|_| false);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         for _ in iter.by_ref() {\n             count += 1;\n@@ -874,14 +874,14 @@ fn drain_filter_false() {\n }\n \n #[test]\n-fn drain_filter_true() {\n+fn extract_if_true() {\n     let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n     let initial_len = list.len();\n     let mut count = 0;\n \n     {\n-        let mut iter = list.drain_filter(|_| true);\n+        let mut iter = list.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         while let Some(_) = iter.next() {\n             count += 1;\n@@ -898,7 +898,7 @@ fn drain_filter_true() {\n }\n \n #[test]\n-fn drain_filter_complex() {\n+fn extract_if_complex() {\n     {\n         //                [+xxx++++++xxxxx++++x+x++]\n         let mut list = [\n@@ -908,7 +908,7 @@ fn drain_filter_complex() {\n         .into_iter()\n         .collect::<LinkedList<_>>();\n \n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = list.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -926,7 +926,7 @@ fn drain_filter_complex() {\n                 .into_iter()\n                 .collect::<LinkedList<_>>();\n \n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = list.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -944,7 +944,7 @@ fn drain_filter_complex() {\n                 .into_iter()\n                 .collect::<LinkedList<_>>();\n \n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = list.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -961,7 +961,7 @@ fn drain_filter_complex() {\n             .into_iter()\n             .collect::<LinkedList<_>>();\n \n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = list.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n \n@@ -975,7 +975,7 @@ fn drain_filter_complex() {\n             .into_iter()\n             .collect::<LinkedList<_>>();\n \n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = list.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n \n@@ -986,7 +986,7 @@ fn drain_filter_complex() {\n \n #[test]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn drain_filter_drop_panic_leak() {\n+fn extract_if_drop_panic_leak() {\n     let d0 = CrashTestDummy::new(0);\n     let d1 = CrashTestDummy::new(1);\n     let d2 = CrashTestDummy::new(2);\n@@ -1005,22 +1005,28 @@ fn drain_filter_drop_panic_leak() {\n     q.push_front(d1.spawn(Panic::InDrop));\n     q.push_front(d0.spawn(Panic::Never));\n \n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).unwrap_err();\n+    catch_unwind(AssertUnwindSafe(|| q.extract_if(|_| true).for_each(drop))).unwrap_err();\n \n     assert_eq!(d0.dropped(), 1);\n     assert_eq!(d1.dropped(), 1);\n+    assert_eq!(d2.dropped(), 0);\n+    assert_eq!(d3.dropped(), 0);\n+    assert_eq!(d4.dropped(), 0);\n+    assert_eq!(d5.dropped(), 0);\n+    assert_eq!(d6.dropped(), 0);\n+    assert_eq!(d7.dropped(), 0);\n+    drop(q);\n     assert_eq!(d2.dropped(), 1);\n     assert_eq!(d3.dropped(), 1);\n     assert_eq!(d4.dropped(), 1);\n     assert_eq!(d5.dropped(), 1);\n     assert_eq!(d6.dropped(), 1);\n     assert_eq!(d7.dropped(), 1);\n-    assert!(q.is_empty());\n }\n \n #[test]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn drain_filter_pred_panic_leak() {\n+fn extract_if_pred_panic_leak() {\n     static mut DROPS: i32 = 0;\n \n     #[derive(Debug)]\n@@ -1045,7 +1051,7 @@ fn drain_filter_pred_panic_leak() {\n     q.push_front(D(0));\n \n     catch_unwind(AssertUnwindSafe(|| {\n-        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n+        q.extract_if(|item| if item.0 >= 2 { panic!() } else { true }).for_each(drop)\n     }))\n     .ok();\n "}, {"sha": "21b0902346206aaef0dccefc37f4d8dfdc4a1298", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -1,197 +0,0 @@\n-use crate::alloc::{Allocator, Global};\n-use core::mem::{ManuallyDrop, SizedTypeProperties};\n-use core::ptr;\n-use core::slice;\n-\n-use super::Vec;\n-\n-/// An iterator which uses a closure to determine if an element should be removed.\n-///\n-/// This struct is created by [`Vec::drain_filter`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(drain_filter)]\n-///\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::DrainFilter<'_, _, _> = v.drain_filter(|x| *x % 2 == 0);\n-/// ```\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-#[derive(Debug)]\n-pub struct DrainFilter<\n-    'a,\n-    T,\n-    F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    pub(super) vec: &'a mut Vec<T, A>,\n-    /// The index of the item that will be inspected by the next call to `next`.\n-    pub(super) idx: usize,\n-    /// The number of items that have been drained (removed) thus far.\n-    pub(super) del: usize,\n-    /// The original length of `vec` prior to draining.\n-    pub(super) old_len: usize,\n-    /// The filter test predicate.\n-    pub(super) pred: F,\n-    /// A flag that indicates a panic has occurred in the filter test predicate.\n-    /// This is used as a hint in the drop implementation to prevent consumption\n-    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n-    /// backshifted in the `vec`, but no further items will be dropped or\n-    /// tested by the filter predicate.\n-    pub(super) panic_flag: bool,\n-}\n-\n-impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        self.vec.allocator()\n-    }\n-\n-    /// Keep unyielded elements in the source `Vec`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(drain_filter)]\n-    /// #![feature(drain_keep_rest)]\n-    ///\n-    /// let mut vec = vec!['a', 'b', 'c'];\n-    /// let mut drain = vec.drain_filter(|_| true);\n-    ///\n-    /// assert_eq!(drain.next().unwrap(), 'a');\n-    ///\n-    /// // This call keeps 'b' and 'c' in the vec.\n-    /// drain.keep_rest();\n-    ///\n-    /// // If we wouldn't call `keep_rest()`,\n-    /// // `vec` would be empty.\n-    /// assert_eq!(vec, ['b', 'c']);\n-    /// ```\n-    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n-    pub fn keep_rest(self) {\n-        // At this moment layout looks like this:\n-        //\n-        //  _____________________/-- old_len\n-        // /                     \\\n-        // [kept] [yielded] [tail]\n-        //        \\_______/ ^-- idx\n-        //                \\-- del\n-        //\n-        // Normally `Drop` impl would drop [tail] (via .for_each(drop), ie still calling `pred`)\n-        //\n-        // 1. Move [tail] after [kept]\n-        // 2. Update length of the original vec to `old_len - del`\n-        //    a. In case of ZST, this is the only thing we want to do\n-        // 3. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n-        let mut this = ManuallyDrop::new(self);\n-\n-        unsafe {\n-            // ZSTs have no identity, so we don't need to move them around.\n-            if !T::IS_ZST && this.idx < this.old_len && this.del > 0 {\n-                let ptr = this.vec.as_mut_ptr();\n-                let src = ptr.add(this.idx);\n-                let dst = src.sub(this.del);\n-                let tail_len = this.old_len - this.idx;\n-                src.copy_to(dst, tail_len);\n-            }\n-\n-            let new_len = this.old_len - this.del;\n-            this.vec.set_len(new_len);\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            while self.idx < self.old_len {\n-                let i = self.idx;\n-                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                self.panic_flag = true;\n-                let drained = (self.pred)(&mut v[i]);\n-                self.panic_flag = false;\n-                // Update the index *after* the predicate is called. If the index\n-                // is updated prior and the predicate panics, the element at this\n-                // index would be leaked.\n-                self.idx += 1;\n-                if drained {\n-                    self.del += 1;\n-                    return Some(ptr::read(&v[i]));\n-                } else if self.del > 0 {\n-                    let del = self.del;\n-                    let src: *const T = &v[i];\n-                    let dst: *mut T = &mut v[i - del];\n-                    ptr::copy_nonoverlapping(src, dst, 1);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.old_len - self.idx))\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            drain: &'b mut DrainFilter<'a, T, F, A>,\n-        }\n-\n-        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n-                        // This is a pretty messed up state, and there isn't really an\n-                        // obviously right thing to do. We don't want to keep trying\n-                        // to execute `pred`, so we just backshift all the unprocessed\n-                        // elements and tell the vec that they still exist. The backshift\n-                        // is required to prevent a double-drop of the last successfully\n-                        // drained item prior to a panic in the predicate.\n-                        let ptr = self.drain.vec.as_mut_ptr();\n-                        let src = ptr.add(self.drain.idx);\n-                        let dst = src.sub(self.drain.del);\n-                        let tail_len = self.drain.old_len - self.drain.idx;\n-                        src.copy_to(dst, tail_len);\n-                    }\n-                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n-                }\n-            }\n-        }\n-\n-        let backshift = BackshiftOnDrop { drain: self };\n-\n-        // Attempt to consume any remaining elements if the filter predicate\n-        // has not yet panicked. We'll backshift any remaining elements\n-        // whether we've already panicked or if the consumption here panics.\n-        if !backshift.drain.panic_flag {\n-            backshift.drain.for_each(drop);\n-        }\n-    }\n-}"}, {"sha": "e8e6bd56d21ba4412a01fbe7c99d459ec8458822", "filename": "library/alloc/src/vec/extract_if.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fvec%2Fextract_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fvec%2Fextract_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fextract_if.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -0,0 +1,121 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr;\n+use core::slice;\n+\n+use super::Vec;\n+\n+/// An iterator which uses a closure to determine if an element should be removed.\n+///\n+/// This struct is created by [`Vec::extract_if`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(extract_if)]\n+///\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::ExtractIf<'_, _, _> = v.extract_if(|x| *x % 2 == 0);\n+/// ```\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    pub(super) vec: &'a mut Vec<T, A>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n+    pub(super) idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n+    pub(super) del: usize,\n+    /// The original length of `vec` prior to draining.\n+    pub(super) old_len: usize,\n+    /// The filter test predicate.\n+    pub(super) pred: F,\n+    /// A flag that indicates a panic has occurred in the filter test predicate.\n+    /// This is used as a hint in the drop implementation to prevent consumption\n+    /// of the remainder of the `ExtractIf`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    pub(super) panic_flag: bool,\n+}\n+\n+impl<T, F, A: Allocator> ExtractIf<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.vec.allocator()\n+    }\n+}\n+\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Iterator for ExtractIf<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx < self.old_len {\n+                let i = self.idx;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    let del = self.del;\n+                    let src: *const T = &v[i];\n+                    let dst: *mut T = &mut v[i - del];\n+                    ptr::copy_nonoverlapping(src, dst, 1);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Drop for ExtractIf<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.idx < self.old_len && self.del > 0 {\n+                // This is a pretty messed up state, and there isn't really an\n+                // obviously right thing to do. We don't want to keep trying\n+                // to execute `pred`, so we just backshift all the unprocessed\n+                // elements and tell the vec that they still exist. The backshift\n+                // is required to prevent a double-drop of the last successfully\n+                // drained item prior to a panic in the predicate.\n+                let ptr = self.vec.as_mut_ptr();\n+                let src = ptr.add(self.idx);\n+                let dst = src.sub(self.del);\n+                let tail_len = self.old_len - self.idx;\n+                src.copy_to(dst, tail_len);\n+            }\n+            self.vec.set_len(self.old_len - self.del);\n+        }\n+    }\n+}"}, {"sha": "289bbc7d2effd99825e3d4dcc14ea0bee906d18b", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -71,10 +71,10 @@ use crate::boxed::Box;\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n \n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-pub use self::drain_filter::DrainFilter;\n+#[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+pub use self::extract_if::ExtractIf;\n \n-mod drain_filter;\n+mod extract_if;\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n@@ -2892,6 +2892,12 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// If the closure returns false, the element will remain in the vector and will not be yielded\n     /// by the iterator.\n     ///\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n+    ///\n+    /// [`retain`]: Vec::retain\n+    ///\n     /// Using this method is equivalent to the following code:\n     ///\n     /// ```\n@@ -2910,28 +2916,28 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// # assert_eq!(vec, vec![1, 4, 5]);\n     /// ```\n     ///\n-    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n+    /// But `extract_if` is easier to use. `extract_if` is also more efficient,\n     /// because it can backshift the elements of the array in bulk.\n     ///\n-    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n+    /// Note that `extract_if` also lets you mutate every element in the filter closure,\n     /// regardless of whether you choose to keep or remove it.\n     ///\n     /// # Examples\n     ///\n     /// Splitting an array into evens and odds, reusing the original allocation:\n     ///\n     /// ```\n-    /// #![feature(drain_filter)]\n+    /// #![feature(extract_if)]\n     /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n     ///\n-    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+    /// let evens = numbers.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n     /// let odds = numbers;\n     ///\n     /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n     /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n-    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F, A>\n+    #[unstable(feature = \"extract_if\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn extract_if<F>(&mut self, filter: F) -> ExtractIf<'_, T, F, A>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n@@ -2942,7 +2948,7 @@ impl<T, A: Allocator> Vec<T, A> {\n             self.set_len(0);\n         }\n \n-        DrainFilter { vec: self, idx: 0, del: 0, old_len, pred: filter, panic_flag: false }\n+        ExtractIf { vec: self, idx: 0, del: 0, old_len, pred: filter, panic_flag: false }\n     }\n }\n "}, {"sha": "6a8e55bff23d980b129aea32a90103527a3e1c53", "filename": "library/alloc/tests/autotraits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Fautotraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Fautotraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fautotraits.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -55,7 +55,7 @@ fn test_btree_map() {\n \n     require_send_sync(async {\n         let _v = None::<\n-            alloc::collections::btree_map::DrainFilter<\n+            alloc::collections::btree_map::ExtractIf<\n                 '_,\n                 &u32,\n                 &u32,\n@@ -149,7 +149,7 @@ fn test_btree_set() {\n     });\n \n     require_send_sync(async {\n-        let _v = None::<alloc::collections::btree_set::DrainFilter<'_, &u32, fn(&&u32) -> bool>>;\n+        let _v = None::<alloc::collections::btree_set::ExtractIf<'_, &u32, fn(&&u32) -> bool>>;\n         async {}.await;\n     });\n \n@@ -238,7 +238,7 @@ fn test_linked_list() {\n     /*\n     require_send_sync(async {\n         let _v =\n-            None::<alloc::collections::linked_list::DrainFilter<'_, &u32, fn(&mut &u32) -> bool>>;\n+            None::<alloc::collections::linked_list::ExtractIf<'_, &u32, fn(&mut &u32) -> bool>>;\n         async {}.await;\n     });\n     */"}, {"sha": "aa7a331b368be836f6bf6e2b06fe6acba52d7634", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1,7 +1,7 @@\n #![feature(allocator_api)]\n #![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n-#![feature(btree_drain_filter)]\n+#![feature(btree_extract_if)]\n #![feature(cow_is_borrowed)]\n #![feature(const_cow_is_borrowed)]\n #![feature(const_heap)]\n@@ -10,7 +10,7 @@\n #![feature(const_ptr_write)]\n #![feature(const_try)]\n #![feature(core_intrinsics)]\n-#![feature(drain_filter)]\n+#![feature(extract_if)]\n #![feature(exact_size_is_empty)]\n #![feature(linked_list_cursors)]\n #![feature(map_try_insert)]"}, {"sha": "21824c8a17c4609fedded6e2bd09b1cde0eaefa6", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1347,11 +1347,11 @@ fn overaligned_allocations() {\n }\n \n #[test]\n-fn drain_filter_empty() {\n+fn extract_if_empty() {\n     let mut vec: Vec<i32> = vec![];\n \n     {\n-        let mut iter = vec.drain_filter(|_| true);\n+        let mut iter = vec.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(0)));\n         assert_eq!(iter.next(), None);\n         assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -1363,12 +1363,12 @@ fn drain_filter_empty() {\n }\n \n #[test]\n-fn drain_filter_zst() {\n+fn extract_if_zst() {\n     let mut vec = vec![(), (), (), (), ()];\n     let initial_len = vec.len();\n     let mut count = 0;\n     {\n-        let mut iter = vec.drain_filter(|_| true);\n+        let mut iter = vec.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         while let Some(_) = iter.next() {\n             count += 1;\n@@ -1385,13 +1385,13 @@ fn drain_filter_zst() {\n }\n \n #[test]\n-fn drain_filter_false() {\n+fn extract_if_false() {\n     let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n     let initial_len = vec.len();\n     let mut count = 0;\n     {\n-        let mut iter = vec.drain_filter(|_| false);\n+        let mut iter = vec.extract_if(|_| false);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         for _ in iter.by_ref() {\n             count += 1;\n@@ -1407,13 +1407,13 @@ fn drain_filter_false() {\n }\n \n #[test]\n-fn drain_filter_true() {\n+fn extract_if_true() {\n     let mut vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n \n     let initial_len = vec.len();\n     let mut count = 0;\n     {\n-        let mut iter = vec.drain_filter(|_| true);\n+        let mut iter = vec.extract_if(|_| true);\n         assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n         while let Some(_) = iter.next() {\n             count += 1;\n@@ -1430,15 +1430,15 @@ fn drain_filter_true() {\n }\n \n #[test]\n-fn drain_filter_complex() {\n+fn extract_if_complex() {\n     {\n         //                [+xxx++++++xxxxx++++x+x++]\n         let mut vec = vec![\n             1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n             39,\n         ];\n \n-        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = vec.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -1452,7 +1452,7 @@ fn drain_filter_complex() {\n             2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n         ];\n \n-        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = vec.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -1465,7 +1465,7 @@ fn drain_filter_complex() {\n         let mut vec =\n             vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36];\n \n-        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = vec.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n \n@@ -1477,7 +1477,7 @@ fn drain_filter_complex() {\n         //                [xxxxxxxxxx+++++++++++]\n         let mut vec = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];\n \n-        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = vec.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n \n@@ -1489,7 +1489,7 @@ fn drain_filter_complex() {\n         //                [+++++++++++xxxxxxxxxx]\n         let mut vec = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20];\n \n-        let removed = vec.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        let removed = vec.extract_if(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n         assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n \n@@ -1502,7 +1502,7 @@ fn drain_filter_complex() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn drain_filter_consumed_panic() {\n+fn extract_if_consumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n \n@@ -1537,9 +1537,9 @@ fn drain_filter_consumed_panic() {\n             }\n             c.index < 6\n         };\n-        let drain = data.drain_filter(filter);\n+        let drain = data.extract_if(filter);\n \n-        // NOTE: The DrainFilter is explicitly consumed\n+        // NOTE: The ExtractIf is explicitly consumed\n         drain.for_each(drop);\n     });\n \n@@ -1555,7 +1555,7 @@ fn drain_filter_consumed_panic() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n #[cfg_attr(not(panic = \"unwind\"), ignore = \"test requires unwinding support\")]\n-fn drain_filter_unconsumed_panic() {\n+fn extract_if_unconsumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n \n@@ -1590,9 +1590,9 @@ fn drain_filter_unconsumed_panic() {\n             }\n             c.index < 6\n         };\n-        let _drain = data.drain_filter(filter);\n+        let _drain = data.extract_if(filter);\n \n-        // NOTE: The DrainFilter is dropped without being consumed\n+        // NOTE: The ExtractIf is dropped without being consumed\n     });\n \n     let drop_counts = drop_counts.lock().unwrap();\n@@ -1604,40 +1604,11 @@ fn drain_filter_unconsumed_panic() {\n }\n \n #[test]\n-fn drain_filter_unconsumed() {\n+fn extract_if_unconsumed() {\n     let mut vec = vec![1, 2, 3, 4];\n-    let drain = vec.drain_filter(|&mut x| x % 2 != 0);\n+    let drain = vec.extract_if(|&mut x| x % 2 != 0);\n     drop(drain);\n-    assert_eq!(vec, [2, 4]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    let mut drain = v.drain_filter(|&mut x| x % 2 == 0);\n-    assert_eq!(drain.next(), Some(0));\n-    assert_eq!(drain.next(), Some(2));\n-\n-    drain.keep_rest();\n-    assert_eq!(v, &[1, 3, 4, 5, 6]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest_all() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    v.drain_filter(|_| true).keep_rest();\n-    assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6]);\n-}\n-\n-#[test]\n-fn test_drain_filter_keep_rest_none() {\n-    let mut v = vec![0, 1, 2, 3, 4, 5, 6];\n-    let mut drain = v.drain_filter(|_| true);\n-\n-    drain.by_ref().for_each(drop);\n-\n-    drain.keep_rest();\n-    assert_eq!(v, &[]);\n+    assert_eq!(vec, [1, 2, 3, 4]);\n }\n \n #[test]"}, {"sha": "e6b051838861adcf4eb089eb3df732493787b249", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -21,7 +21,7 @@ libc = { version = \"0.2.146\", default-features = false, features = ['rustc-dep-o\n compiler_builtins = { version = \"0.1.92\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.13\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.14\", default-features = false, features = ['rustc-dep-of-std'] }\n std_detect = { path = \"../stdarch/crates/std_detect\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate"}, {"sha": "f3316d97c5faf0d20722eb9dc3024eb2a4113b11", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -623,28 +623,27 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// If the closure returns false, or panics, the element remains in the map and will not be\n     /// yielded.\n     ///\n-    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// Note that `extract_if` lets you mutate every value in the filter closure, regardless of\n     /// whether you choose to keep or remove it.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n-    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more elements will be subjected to the closure\n-    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n-    /// or if the `DrainFilter` value is leaked.\n+    /// [`retain`]: HashMap::retain\n     ///\n     /// # Examples\n     ///\n     /// Splitting a map into even and odd keys, reusing the original map:\n     ///\n     /// ```\n-    /// #![feature(hash_drain_filter)]\n+    /// #![feature(hash_extract_if)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n-    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let extracted: HashMap<i32, i32> = map.extract_if(|k, _v| k % 2 == 0).collect();\n     ///\n-    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n+    /// let mut evens = extracted.keys().copied().collect::<Vec<_>>();\n     /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n     /// evens.sort();\n     /// odds.sort();\n@@ -654,12 +653,12 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// ```\n     #[inline]\n     #[rustc_lint_query_instability]\n-    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    #[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+    pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, K, V, F>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        DrainFilter { base: self.base.drain_filter(pred) }\n+        ExtractIf { base: self.base.extract_if(pred) }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1578,28 +1577,29 @@ impl<'a, K, V> Drain<'a, K, V> {\n \n /// A draining, filtering iterator over the entries of a `HashMap`.\n ///\n-/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n+/// This `struct` is created by the [`extract_if`] method on [`HashMap`].\n ///\n-/// [`drain_filter`]: HashMap::drain_filter\n+/// [`extract_if`]: HashMap::extract_if\n ///\n /// # Example\n ///\n /// ```\n-/// #![feature(hash_drain_filter)]\n+/// #![feature(hash_extract_if)]\n ///\n /// use std::collections::HashMap;\n ///\n /// let mut map = HashMap::from([\n ///     (\"a\", 1),\n /// ]);\n-/// let iter = map.drain_filter(|_k, v| *v % 2 == 0);\n+/// let iter = map.extract_if(|_k, v| *v % 2 == 0);\n /// ```\n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-pub struct DrainFilter<'a, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+pub struct ExtractIf<'a, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n-    base: base::DrainFilter<'a, K, V, F>,\n+    base: base::ExtractIf<'a, K, V, F>,\n }\n \n /// A mutable iterator over the values of a `HashMap`.\n@@ -2479,8 +2479,8 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, V, F> Iterator for ExtractIf<'_, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n@@ -2496,16 +2496,16 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, V, F> FusedIterator for ExtractIf<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<'a, K, V, F> fmt::Debug for ExtractIf<'a, K, V, F>\n where\n     F: FnMut(&K, &mut V) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n+        f.debug_struct(\"ExtractIf\").finish_non_exhaustive()\n     }\n }\n "}, {"sha": "91a3776e7be84a20d20701cf20fe3192662bdad1", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -944,7 +944,7 @@ fn test_raw_entry() {\n     }\n }\n \n-mod test_drain_filter {\n+mod test_extract_if {\n     use super::*;\n \n     use crate::panic::{catch_unwind, AssertUnwindSafe};\n@@ -968,23 +968,23 @@ mod test_drain_filter {\n     #[test]\n     fn empty() {\n         let mut map: HashMap<i32, i32> = HashMap::new();\n-        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        map.extract_if(|_, _| unreachable!(\"there's nothing to decide on\")).for_each(drop);\n         assert!(map.is_empty());\n     }\n \n     #[test]\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n-        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n+        assert!(map.extract_if(|_, _| false).eq_sorted(crate::iter::empty()));\n         assert_eq!(map.len(), 3);\n     }\n \n     #[test]\n     fn consuming_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.clone().collect();\n-        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n+        assert!(map.extract_if(|_, _| true).eq_sorted(pairs));\n         assert!(map.is_empty());\n     }\n \n@@ -993,7 +993,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 false\n             })\n@@ -1008,7 +1008,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: HashMap<_, _> = pairs.collect();\n         assert!(\n-            map.drain_filter(|_, v| {\n+            map.extract_if(|_, v| {\n                 *v += 6;\n                 true\n             })\n@@ -1034,14 +1034,15 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         catch_unwind(move || {\n-            drop(map.drain_filter(|_, _| {\n+            map.extract_if(|_, _| {\n                 PREDS.fetch_add(1, Ordering::SeqCst);\n                 true\n-            }))\n+            })\n+            .for_each(drop)\n         })\n         .unwrap_err();\n \n-        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n     }\n \n@@ -1060,10 +1061,11 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         catch_unwind(AssertUnwindSafe(|| {\n-            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            map.extract_if(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                 0 => true,\n                 _ => panic!(),\n-            }))\n+            })\n+            .for_each(drop)\n         }))\n         .unwrap_err();\n \n@@ -1088,7 +1090,7 @@ mod test_drain_filter {\n         let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n \n         {\n-            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            let mut it = map.extract_if(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n                 0 => true,\n                 _ => panic!(),\n             });"}, {"sha": "ec59634df363a9f50be1f062e2045856eb6bffda", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -262,25 +262,24 @@ impl<T, S> HashSet<T, S> {\n     /// If the closure returns false, the value will remain in the list and will not be yielded\n     /// by the iterator.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n-    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    /// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more values will be subjected to the closure\n-    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n-    /// `DrainFilter` itself is leaked.\n+    /// [`retain`]: HashSet::retain\n     ///\n     /// # Examples\n     ///\n     /// Splitting a set into even and odd values, reusing the original set:\n     ///\n     /// ```\n-    /// #![feature(hash_drain_filter)]\n+    /// #![feature(hash_extract_if)]\n     /// use std::collections::HashSet;\n     ///\n     /// let mut set: HashSet<i32> = (0..8).collect();\n-    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let extracted: HashSet<i32> = set.extract_if(|v| v % 2 == 0).collect();\n     ///\n-    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n+    /// let mut evens = extracted.into_iter().collect::<Vec<_>>();\n     /// let mut odds = set.into_iter().collect::<Vec<_>>();\n     /// evens.sort();\n     /// odds.sort();\n@@ -290,12 +289,12 @@ impl<T, S> HashSet<T, S> {\n     /// ```\n     #[inline]\n     #[rustc_lint_query_instability]\n-    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n+    #[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+    pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, T, F>\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        DrainFilter { base: self.base.drain_filter(pred) }\n+        ExtractIf { base: self.base.extract_if(pred) }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1312,27 +1311,27 @@ pub struct Drain<'a, K: 'a> {\n \n /// A draining, filtering iterator over the items of a `HashSet`.\n ///\n-/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n+/// This `struct` is created by the [`extract_if`] method on [`HashSet`].\n ///\n-/// [`drain_filter`]: HashSet::drain_filter\n+/// [`extract_if`]: HashSet::extract_if\n ///\n /// # Examples\n ///\n /// ```\n-/// #![feature(hash_drain_filter)]\n+/// #![feature(hash_extract_if)]\n ///\n /// use std::collections::HashSet;\n ///\n /// let mut a = HashSet::from([1, 2, 3]);\n ///\n-/// let mut drain_filtered = a.drain_filter(|v| v % 2 == 0);\n+/// let mut extract_ifed = a.extract_if(|v| v % 2 == 0);\n /// ```\n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-pub struct DrainFilter<'a, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+pub struct ExtractIf<'a, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n-    base: base::DrainFilter<'a, K, F>,\n+    base: base::ExtractIf<'a, K, F>,\n }\n \n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n@@ -1578,8 +1577,8 @@ impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, F> Iterator for DrainFilter<'_, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, F> Iterator for ExtractIf<'_, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n@@ -1595,16 +1594,16 @@ where\n     }\n }\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<K, F> FusedIterator for ExtractIf<'_, K, F> where F: FnMut(&K) -> bool {}\n \n-#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n-impl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\n+#[unstable(feature = \"hash_extract_if\", issue = \"59618\")]\n+impl<'a, K, F> fmt::Debug for ExtractIf<'a, K, F>\n where\n     F: FnMut(&K) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"DrainFilter\").finish_non_exhaustive()\n+        f.debug_struct(\"ExtractIf\").finish_non_exhaustive()\n     }\n }\n "}, {"sha": "e0cd80b44f8e6c6f3f3e4b00a12183fe58dfeabc", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -419,18 +419,18 @@ fn test_retain() {\n }\n \n #[test]\n-fn test_drain_filter() {\n+fn test_extract_if() {\n     let mut x: HashSet<_> = [1].iter().copied().collect();\n     let mut y: HashSet<_> = [1].iter().copied().collect();\n \n-    x.drain_filter(|_| true);\n-    y.drain_filter(|_| false);\n+    x.extract_if(|_| true).for_each(drop);\n+    y.extract_if(|_| false).for_each(drop);\n     assert_eq!(x.len(), 0);\n     assert_eq!(y.len(), 1);\n }\n \n #[test]\n-fn test_drain_filter_drop_panic_leak() {\n+fn test_extract_if_drop_panic_leak() {\n     static PREDS: AtomicU32 = AtomicU32::new(0);\n     static DROPS: AtomicU32 = AtomicU32::new(0);\n \n@@ -447,19 +447,20 @@ fn test_drain_filter_drop_panic_leak() {\n     let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n \n     catch_unwind(move || {\n-        drop(set.drain_filter(|_| {\n+        set.extract_if(|_| {\n             PREDS.fetch_add(1, Ordering::SeqCst);\n             true\n-        }))\n+        })\n+        .for_each(drop)\n     })\n     .ok();\n \n-    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n     assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n }\n \n #[test]\n-fn test_drain_filter_pred_panic_leak() {\n+fn test_extract_if_pred_panic_leak() {\n     static PREDS: AtomicU32 = AtomicU32::new(0);\n     static DROPS: AtomicU32 = AtomicU32::new(0);\n \n@@ -474,10 +475,11 @@ fn test_drain_filter_pred_panic_leak() {\n     let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n \n     catch_unwind(AssertUnwindSafe(|| {\n-        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+        set.extract_if(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n             0 => true,\n             _ => panic!(),\n-        }))\n+        })\n+        .for_each(drop)\n     }))\n     .ok();\n "}, {"sha": "870cfa93058aad3596757a5e0bd2e33b241797dc", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -158,13 +158,13 @@ pub(crate) fn try_inline_glob(\n                 .filter_map(|child| child.res.opt_def_id())\n                 .collect();\n             let mut items = build_module_items(cx, did, visited, inlined_names, Some(&reexports));\n-            items.drain_filter(|item| {\n+            items.retain(|item| {\n                 if let Some(name) = item.name {\n                     // If an item with the same type and name already exists,\n                     // it takes priority over the inlined stuff.\n-                    !inlined_names.insert((item.type_(), name))\n+                    inlined_names.insert((item.type_(), name))\n                 } else {\n-                    false\n+                    true\n                 }\n             });\n             Some(items)"}, {"sha": "a8cd0ec453ed7ee436da4bfb309cfff0b2efb4e9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -6,7 +6,6 @@\n #![feature(array_methods)]\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n #![feature(impl_trait_in_assoc_type)]\n #![feature(iter_intersperse)]\n #![feature(lazy_cell)]"}, {"sha": "1213f81a6f1288bb5329017d0dcf76c7e016f588", "filename": "src/tools/miri/tests/pass/btreemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -1,7 +1,7 @@\n //@revisions: stack tree\n //@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n-#![feature(btree_drain_filter)]\n+#![feature(btree_extract_if)]\n use std::collections::{BTreeMap, BTreeSet};\n use std::mem;\n \n@@ -49,8 +49,8 @@ pub fn main() {\n     }\n     test_all_refs(&mut 13, b.values_mut());\n \n-    // Test forgetting the drain.\n-    let mut d = b.drain_filter(|_, i| *i < 30);\n+    // Test forgetting the extractor.\n+    let mut d = b.extract_if(|_, i| *i < 30);\n     d.next().unwrap();\n     mem::forget(d);\n }"}, {"sha": "ac2056bcc855ac4877aa69ecb2ace49cb73ab077", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -108,6 +108,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"adler\",\n     \"ahash\",\n     \"aho-corasick\",\n+    \"allocator-api2\", // FIXME: only appears in Cargo.lock due to https://github.com/rust-lang/cargo/issues/10801\n     \"annotate-snippets\",\n     \"ansi_term\",\n     \"ar_archive_writer\","}, {"sha": "a386e9f40ccaf07c02694723bf6e704910903700", "filename": "tests/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee4265ca6a7f037237974eeb66e8303282c6a4c/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee4265ca6a7f037237974eeb66e8303282c6a4c/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs?ref=6ee4265ca6a7f037237974eeb66e8303282c6a4c", "patch": "@@ -2,7 +2,7 @@\n //check-pass\n #![warn(unused)]\n #![feature(rustc_attrs)]\n-#![feature(btree_drain_filter)]\n+#![feature(btree_extract_if)]\n \n use std::collections::BTreeMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -14,14 +14,14 @@ fn main() {\n     map.insert(\"c\", ());\n \n     {\n-        let mut it = map.drain_filter(|_, _| true);\n+        let mut it = map.extract_if(|_, _| true);\n         catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n         let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n         assert!(matches!(result, Ok(None)));\n     }\n \n     {\n-        let mut it = map.drain_filter(|_, _| true);\n+        let mut it = map.extract_if(|_, _| true);\n         catch_unwind(AssertUnwindSafe(|| while let Some(_) = it.next() {})).unwrap_err();\n         let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n         assert!(matches!(result, Ok(None)));"}]}