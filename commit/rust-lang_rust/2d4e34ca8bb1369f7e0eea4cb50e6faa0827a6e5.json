{"sha": "2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNGUzNGNhOGJiMTM2OWY3ZTBlZWE0Y2I1MGU2ZmFhMDgyN2E2ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-09T21:00:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-09T21:00:55Z"}, "message": "Auto merge of #53778 - petrochenkov:shadrelax2, r=nikomatsakis\n\nresolve: Relax shadowing restrictions on macro-expanded macros\n\nPreviously any macro-expanded macros weren't allowed to shadow macros from outer scopes.\nNow only \"more macro-expanded\" macros cannot shadow \"less macro-expanded\" macros.\nSee comments to `fn may_appear_after` and added tests for more details and examples.\n\nThe functional changes are a21f6f588fc28c97533130ae44a6957b579ab58c and 46dd365ce9ca0a6b8653849b80267763c542842a, other commits are refactorings.", "tree": {"sha": "9e250b17aba2c7174bea5e7d7fb1a598da7e0ff2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e250b17aba2c7174bea5e7d7fb1a598da7e0ff2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "html_url": "https://github.com/rust-lang/rust/commit/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50b7758f4dc85dc1c5e38258adaa94213ac6ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50b7758f4dc85dc1c5e38258adaa94213ac6ed1", "html_url": "https://github.com/rust-lang/rust/commit/f50b7758f4dc85dc1c5e38258adaa94213ac6ed1"}, {"sha": "2dce3779bbc0353ff9fb544774417a851027fcab", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dce3779bbc0353ff9fb544774417a851027fcab", "html_url": "https://github.com/rust-lang/rust/commit/2dce3779bbc0353ff9fb544774417a851027fcab"}], "stats": {"total": 1475, "additions": 1230, "deletions": 245}, "files": [{"sha": "63f643d7a2964db4ad58c9417a4a07f01e38e09d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -946,7 +946,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a, 'c: 'b> {\n     pub resolver: &'a mut Resolver<'b, 'c>,\n-    pub legacy_scope: LegacyScope<'b>,\n+    pub current_legacy_scope: LegacyScope<'b>,\n     pub expansion: Mark,\n }\n \n@@ -956,7 +956,8 @@ impl<'a, 'b, 'cl> BuildReducedGraphVisitor<'a, 'b, 'cl> {\n         self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n-        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation.parent_legacy_scope.set(self.current_legacy_scope);\n+        invocation.output_legacy_scope.set(self.current_legacy_scope);\n         invocation\n     }\n }\n@@ -982,29 +983,30 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, self.expansion, &mut self.legacy_scope);\n+                self.resolver.define_macro(item, self.expansion, &mut self.current_legacy_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n \n-        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        let orig_current_module = self.resolver.current_module;\n+        let orig_current_legacy_scope = self.current_legacy_scope;\n         self.resolver.build_reduced_graph_for_item(item, self.expansion);\n         visit::walk_item(self, item);\n-        self.resolver.current_module = parent;\n+        self.resolver.current_module = orig_current_module;\n         if !macro_use {\n-            self.legacy_scope = legacy_scope;\n+            self.current_legacy_scope = orig_current_legacy_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+            self.current_legacy_scope = LegacyScope::Invocation(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1021,11 +1023,12 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n     }\n \n     fn visit_block(&mut self, block: &'a Block) {\n-        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        let orig_current_module = self.resolver.current_module;\n+        let orig_current_legacy_scope = self.current_legacy_scope;\n         self.resolver.build_reduced_graph_for_block(block, self.expansion);\n         visit::walk_block(self, block);\n-        self.resolver.current_module = parent;\n-        self.legacy_scope = legacy_scope;\n+        self.resolver.current_module = orig_current_module;\n+        self.current_legacy_scope = orig_current_legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {"}, {"sha": "5cb615554ee686173629d424a4a80d9f0c56555d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -1177,9 +1177,7 @@ struct UseError<'a> {\n }\n \n struct AmbiguityError<'a> {\n-    span: Span,\n-    name: Name,\n-    lexical: bool,\n+    ident: Ident,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n }\n@@ -1283,6 +1281,26 @@ impl<'a> NameBinding<'a> {\n     fn descr(&self) -> &'static str {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n+\n+    // Suppose that we resolved macro invocation with `invoc_id` to binding `binding` at some\n+    // expansion round `max(invoc_id, binding)` when they both emerged from macros.\n+    // Then this function returns `true` if `self` may emerge from a macro *after* that\n+    // in some later round and screw up our previously found resolution.\n+    // See more detailed explanation in\n+    // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n+    fn may_appear_after(&self, invoc_id: Mark, binding: &NameBinding) -> bool {\n+        // self > max(invoc_id, binding) => !(self <= invoc_id || self <= binding)\n+        // Expansions are partially ordered, so \"may appear after\" is an inversion of\n+        // \"certainly appears before or simultaneously\" and includes unordered cases.\n+        let self_parent_expansion = self.expansion;\n+        let other_parent_expansion = binding.expansion;\n+        let invoc_parent_expansion = invoc_id.parent();\n+        let certainly_before_other_or_simultaneously =\n+            other_parent_expansion.is_descendant_of(self_parent_expansion);\n+        let certainly_before_invoc_or_simultaneously =\n+            invoc_parent_expansion.is_descendant_of(self_parent_expansion);\n+        !(certainly_before_other_or_simultaneously || certainly_before_invoc_or_simultaneously)\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1416,8 +1434,6 @@ pub struct Resolver<'a, 'b: 'a> {\n     proc_mac_errors: Vec<macros::ProcMacError>,\n     /// crate-local macro expanded `macro_export` referred to by a module-relative path\n     macro_expanded_macro_export_errors: BTreeSet<(Span, Span)>,\n-    /// macro-expanded `macro_rules` shadowing existing macros\n-    disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1729,7 +1745,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ambiguity_errors: Vec::new(),\n             use_injections: Vec::new(),\n             proc_mac_errors: Vec::new(),\n-            disallowed_shadowing: Vec::new(),\n             macro_expanded_macro_export_errors: BTreeSet::new(),\n \n             arenas,\n@@ -1815,7 +1830,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         self.arenas.alloc_module(module)\n     }\n \n-    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n+    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>)\n                   -> bool /* true if an error was reported */ {\n         match binding.kind {\n             NameBindingKind::Import { directive, binding, ref used }\n@@ -1824,13 +1839,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 directive.used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n                 self.add_to_glob_map(directive.id, ident);\n-                self.record_use(ident, ns, binding, span)\n+                self.record_use(ident, ns, binding)\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n-                self.ambiguity_errors.push(AmbiguityError {\n-                    span, name: ident.name, lexical: false, b1, b2,\n-                });\n+                self.ambiguity_errors.push(AmbiguityError { ident, b1, b2 });\n                 true\n             }\n             _ => false\n@@ -2850,7 +2863,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n-                                self.record_use(ident, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident, ValueNS, binding.unwrap());\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -3483,6 +3496,20 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_invoc_id(base_module, path, opt_ns, Mark::root(),\n+                                        record_used, path_span, crate_lint)\n+    }\n+\n+    fn resolve_path_with_invoc_id(\n+        &mut self,\n+        base_module: Option<ModuleOrUniformRoot<'a>>,\n+        path: &[Ident],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        invoc_id: Mark,\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         let mut module = base_module;\n         let mut allow_super = true;\n@@ -3572,8 +3599,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used, record_used,\n-                                                        false, path_span).map(|(b, _)| b)\n+                self.resolve_lexical_macro_path_segment(ident, ns, invoc_id, record_used,\n+                                                        record_used, false, path_span)\n+                                                        .map(|(binding, _)| binding)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -4514,35 +4542,33 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n-    fn report_ambiguity_error(\n-        &self, name: Name, span: Span, _lexical: bool,\n-        def1: Def, is_import1: bool, is_glob1: bool, from_expansion1: bool, span1: Span,\n-        def2: Def, is_import2: bool, _is_glob2: bool, _from_expansion2: bool, span2: Span,\n-    ) {\n+    fn report_ambiguity_error(&self, ident: Ident, b1: &NameBinding, b2: &NameBinding) {\n         let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n-        let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(is_import1));\n+        let msg1 =\n+            format!(\"`{}` could refer to the name {} here\", ident, participle(b1.is_import()));\n         let msg2 =\n-            format!(\"`{}` could also refer to the name {} here\", name, participle(is_import2));\n-        let note = if from_expansion1 {\n-            Some(if let Def::Macro(..) = def1 {\n+            format!(\"`{}` could also refer to the name {} here\", ident, participle(b2.is_import()));\n+        let note = if b1.expansion != Mark::root() {\n+            Some(if let Def::Macro(..) = b1.def() {\n                 format!(\"macro-expanded {} do not shadow\",\n-                        if is_import1 { \"macro imports\" } else { \"macros\" })\n+                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n             } else {\n                 format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if is_import1 { \"imports\" } else { \"items\" })\n+                        if b1.is_import() { \"imports\" } else { \"items\" })\n             })\n-        } else if is_glob1 {\n-            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", name))\n+        } else if b1.is_glob_import() {\n+            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", ident))\n         } else {\n             None\n         };\n \n-        let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n-        err.span_note(span1, &msg1);\n-        match def2 {\n-            Def::Macro(..) if span2.is_dummy() =>\n-                err.note(&format!(\"`{}` is also a builtin macro\", name)),\n-            _ => err.span_note(span2, &msg2),\n+        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{}` is ambiguous\", ident);\n+        err.span_label(ident.span, \"ambiguous name\");\n+        err.span_note(b1.span, &msg1);\n+        match b2.def() {\n+            Def::Macro(..) if b2.span.is_dummy() =>\n+                err.note(&format!(\"`{}` is also a builtin macro\", ident)),\n+            _ => err.span_note(b2.span, &msg2),\n         };\n         if let Some(note) = note {\n             err.note(&note);\n@@ -4551,7 +4577,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn report_errors(&mut self, krate: &Crate) {\n-        self.report_shadowing_errors();\n         self.report_with_use_injections(krate);\n         self.report_proc_macro_import(krate);\n         let mut reported_spans = FxHashSet();\n@@ -4567,15 +4592,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             );\n         }\n \n-        for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n-            if reported_spans.insert(span) {\n-                self.report_ambiguity_error(\n-                    name, span, lexical,\n-                    b1.def(), b1.is_import(), b1.is_glob_import(),\n-                    b1.expansion != Mark::root(), b1.span,\n-                    b2.def(), b2.is_import(), b2.is_glob_import(),\n-                    b2.expansion != Mark::root(), b2.span,\n-                );\n+        for &AmbiguityError { ident, b1, b2 } in &self.ambiguity_errors {\n+            if reported_spans.insert(ident.span) {\n+                self.report_ambiguity_error(ident, b1, b2);\n             }\n         }\n \n@@ -4595,20 +4614,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n     }\n \n-    fn report_shadowing_errors(&mut self) {\n-        let mut reported_errors = FxHashSet();\n-        for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_legacy_scope(&binding.parent, binding.ident, false).is_some() &&\n-               reported_errors.insert((binding.ident, binding.span)) {\n-                let msg = format!(\"`{}` is already in scope\", binding.ident);\n-                self.session.struct_span_err(binding.span, &msg)\n-                    .note(\"macro-expanded `macro_rules!`s may not shadow \\\n-                           existing macros (see RFC 1560)\")\n-                    .emit();\n-            }\n-        }\n-    }\n-\n     fn report_conflict<'b>(&mut self,\n                        parent: Module,\n                        ident: Ident,"}, {"sha": "93874ee0e85d58d0785bf80170928c31b12bb8f2", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 167, "deletions": 129, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -45,50 +45,60 @@ use std::mem;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::small_vec::ExpectOne;\n \n+#[derive(Clone, Copy)]\n crate struct FromPrelude(bool);\n-crate struct FromExpansion(bool);\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n-    pub module: Cell<Module<'a>>,\n-    pub def_index: DefIndex,\n-    // The scope in which the invocation path is resolved.\n-    pub legacy_scope: Cell<LegacyScope<'a>>,\n-    // The smallest scope that includes this invocation's expansion,\n-    // or `Empty` if this invocation has not been expanded yet.\n-    pub expansion: Cell<LegacyScope<'a>>,\n+    def_index: DefIndex,\n+    /// Module in which the macro was invoked.\n+    crate module: Cell<Module<'a>>,\n+    /// Legacy scope in which the macro was invoked.\n+    /// The invocation path is resolved in this scope.\n+    crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    /// Legacy scope *produced* by expanding this macro invocation,\n+    /// includes all the macro_rules items, other invocations, etc generated by it.\n+    /// Set to the parent scope if the macro is not expanded yet (as if the macro produced nothing).\n+    crate output_legacy_scope: Cell<LegacyScope<'a>>,\n }\n \n impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         InvocationData {\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n+            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(LegacyScope::Empty),\n         }\n     }\n }\n \n+/// Binding produced by a `macro_rules` item.\n+/// Not modularized, can shadow previous legacy bindings, etc.\n+pub struct LegacyBinding<'a> {\n+    binding: &'a NameBinding<'a>,\n+    /// Legacy scope into which the `macro_rules` item was planted.\n+    parent_legacy_scope: LegacyScope<'a>,\n+    ident: Ident,\n+}\n+\n+/// Scope introduced by a `macro_rules!` macro.\n+/// Starts at the macro's definition and ends at the end of the macro's parent module\n+/// (named or unnamed), or even further if it escapes with `#[macro_use]`.\n+/// Some macro invocations need to introduce legacy scopes too because they\n+/// potentially can expand into macro definitions.\n #[derive(Copy, Clone)]\n pub enum LegacyScope<'a> {\n+    /// Created when invocation data is allocated in the arena,\n+    /// must be replaced with a proper scope later.\n+    Uninitialized,\n+    /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n-    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n-    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    /// Scope introduced by a `macro_rules!` macro definition.\n     Binding(&'a LegacyBinding<'a>),\n-}\n-\n-pub struct LegacyBinding<'a> {\n-    pub parent: Cell<LegacyScope<'a>>,\n-    pub ident: Ident,\n-    def_id: DefId,\n-    pub span: Span,\n-}\n-\n-impl<'a> LegacyBinding<'a> {\n-    fn def(&self) -> Def {\n-        Def::Macro(self.def_id, MacroKind::Bang)\n-    }\n+    /// Scope introduced by a macro invocation that can potentially\n+    /// create a `macro_rules!` macro definition.\n+    Invocation(&'a InvocationData<'a>),\n }\n \n pub struct ProcMacError {\n@@ -110,8 +120,8 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n+            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(LegacyScope::Empty),\n         }));\n         mark\n     }\n@@ -183,11 +193,11 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         }\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            legacy_scope: LegacyScope::Invocation(invocation),\n+            current_legacy_scope: invocation.parent_legacy_scope.get(),\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.expansion.set(visitor.legacy_scope);\n+        invocation.output_legacy_scope.set(visitor.current_legacy_scope);\n     }\n \n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n@@ -437,12 +447,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         Ok((def, self.get_macro(def)))\n     }\n \n-    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                                       derives_in_scope: &[ast::Path], force: bool)\n                                       -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n-        let invocation = self.invocations[&scope];\n+        let invocation = self.invocations[&invoc_id];\n         let module = invocation.module.get();\n         self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n \n@@ -454,8 +464,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let res = self.resolve_path(None, &path, Some(MacroNS), false, span, CrateLint::No);\n-            let def = match res {\n+            let def = match self.resolve_path_with_invoc_id(None, &path, Some(MacroNS), invoc_id,\n+                                                            false, span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -486,11 +496,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n-        let result = if let Some((legacy_binding, _)) = legacy_resolution {\n+        let legacy_resolution = self.resolve_legacy_scope(\n+            path[0], invoc_id, invocation.parent_legacy_scope.get(), false\n+        );\n+        let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, force,\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, invoc_id, false, force,\n                                                           kind == MacroKind::Attr, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n@@ -502,7 +514,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0], kind, result.ok()));\n+            .push((invoc_id, path[0], kind, result.ok()));\n \n         if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n             return result;\n@@ -521,7 +533,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         enum ConvertToDeriveHelper { Yes, No, DontKnow }\n         let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n         for derive in derives_in_scope {\n-            match self.resolve_macro_path(derive, MacroKind::Derive, scope, &[], force) {\n+            match self.resolve_macro_path(derive, MacroKind::Derive, invoc_id, &[], force) {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&path[0].name) {\n                         convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n@@ -549,10 +561,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n+        invoc_id: Mark,\n         record_used: bool,\n         force: bool,\n         is_attr: bool,\n-        path_span: Span\n+        path_span: Span,\n     ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n@@ -585,15 +598,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         assert!(force || !record_used); // `record_used` implies `force`\n         ident = ident.modern();\n \n-        // Names from inner scope that can't shadow names from outer scopes, e.g.\n-        // mod m { ... }\n+        // This is *the* result, resolution from the scope closest to the resolved identifier.\n+        // However, sometimes this result is \"weak\" because it comes from a glob import or\n+        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n+        // mod m { ... } // solution in outer scope\n         // {\n-        //     use prefix::*; // if this imports another `m`, then it can't shadow the outer `m`\n-        //                    // and we have and ambiguity error\n+        //     use prefix::*; // imports another `m` - innermost solution\n+        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n         //     m::mac!();\n         // }\n-        // This includes names from globs and from macro expansions.\n-        let mut potentially_ambiguous_result: Option<(&NameBinding, FromPrelude)> = None;\n+        // So we have to save the innermost solution and continue searching in outer scopes\n+        // to detect potential ambiguities.\n+        let mut innermost_result: Option<(&NameBinding, FromPrelude)> = None;\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n@@ -736,33 +752,24 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         return Ok(result);\n                     }\n \n-                    // Found a solution that is ambiguous with a previously found solution.\n-                    // Push an ambiguity error for later reporting and\n-                    // return something for better recovery.\n-                    if let Some(previous_result) = potentially_ambiguous_result {\n-                        if result.0.def() != previous_result.0.def() {\n+                    if let Some(innermost_result) = innermost_result {\n+                        // Found another solution, if the first one was \"weak\", report an error.\n+                        if result.0.def() != innermost_result.0.def() &&\n+                           (innermost_result.0.is_glob_import() ||\n+                            innermost_result.0.may_appear_after(invoc_id, result.0)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n-                                span: path_span,\n-                                name: ident.name,\n-                                b1: previous_result.0,\n+                                ident,\n+                                b1: innermost_result.0,\n                                 b2: result.0,\n-                                lexical: true,\n                             });\n-                            return Ok(previous_result);\n+                            return Ok(innermost_result);\n                         }\n+                    } else {\n+                        // Found the first solution.\n+                        innermost_result = Some(result);\n                     }\n \n-                    // Found a solution that's not an ambiguity yet, but is \"suspicious\" and\n-                    // can participate in ambiguities later on.\n-                    // Remember it and go search for other solutions in outer scopes.\n-                    if result.0.is_glob_import() || result.0.expansion != Mark::root() {\n-                        potentially_ambiguous_result = Some(result);\n-\n-                        continue_search!();\n-                    }\n-\n-                    // Found a solution that can't be ambiguous, great success.\n-                    return Ok(result);\n+                    continue_search!();\n                 },\n                 Err(Determinacy::Determined) => {\n                     continue_search!();\n@@ -771,9 +778,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        // Previously found potentially ambiguous result turned out to not be ambiguous after all.\n-        if let Some(previous_result) = potentially_ambiguous_result {\n-            return Ok(previous_result);\n+        // The first found solution was the only one, return it.\n+        if let Some(innermost_result) = innermost_result {\n+            return Ok(innermost_result);\n         }\n \n         let determinacy = Determinacy::determined(force);\n@@ -791,45 +798,79 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n     }\n \n-    crate fn resolve_legacy_scope(&mut self,\n-                                  mut scope: &'a Cell<LegacyScope<'a>>,\n-                                  ident: Ident,\n-                                  record_used: bool)\n-                                  -> Option<(&'a LegacyBinding<'a>, FromExpansion)> {\n+    fn resolve_legacy_scope(&mut self,\n+                            ident: Ident,\n+                            invoc_id: Mark,\n+                            invoc_parent_legacy_scope: LegacyScope<'a>,\n+                            record_used: bool)\n+                            -> Option<&'a NameBinding<'a>> {\n         let ident = ident.modern();\n-        let mut relative_depth: u32 = 0;\n+\n+        // This is *the* result, resolution from the scope closest to the resolved identifier.\n+        // However, sometimes this result is \"weak\" because it comes from a macro expansion,\n+        // and in this case it cannot shadow names from outer scopes, e.g.\n+        // macro_rules! m { ... } // solution in outer scope\n+        // {\n+        //     define_m!(); // generates another `macro_rules! m` - innermost solution\n+        //                  // weak, cannot shadow the outer `m`, need to report ambiguity error\n+        //     m!();\n+        // }\n+        // So we have to save the innermost solution and continue searching in outer scopes\n+        // to detect potential ambiguities.\n+        let mut innermost_result: Option<&NameBinding> = None;\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let mut where_to_resolve = invoc_parent_legacy_scope;\n         loop {\n-            match scope.get() {\n-                LegacyScope::Empty => break,\n-                LegacyScope::Expansion(invocation) => {\n-                    match invocation.expansion.get() {\n-                        LegacyScope::Invocation(_) => scope.set(invocation.legacy_scope.get()),\n-                        LegacyScope::Empty => {\n-                            scope = &invocation.legacy_scope;\n-                        }\n-                        _ => {\n-                            relative_depth += 1;\n-                            scope = &invocation.expansion;\n-                        }\n+            let result = match where_to_resolve {\n+                LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n+                    Some(legacy_binding.binding),\n+                _ => None,\n+            };\n+\n+            macro_rules! continue_search { () => {\n+                where_to_resolve = match where_to_resolve {\n+                    LegacyScope::Empty => break, // nowhere else to search\n+                    LegacyScope::Binding(binding) => binding.parent_legacy_scope,\n+                    LegacyScope::Invocation(invocation) => invocation.output_legacy_scope.get(),\n+                    LegacyScope::Uninitialized => unreachable!(),\n+                };\n+\n+                continue;\n+            }}\n+\n+            match result {\n+                Some(result) => {\n+                    if !record_used {\n+                        return Some(result);\n                     }\n-                }\n-                LegacyScope::Invocation(invocation) => {\n-                    relative_depth = relative_depth.saturating_sub(1);\n-                    scope = &invocation.legacy_scope;\n-                }\n-                LegacyScope::Binding(potential_binding) => {\n-                    if potential_binding.ident == ident {\n-                        if record_used && relative_depth > 0 {\n-                            self.disallowed_shadowing.push(potential_binding);\n+\n+                    if let Some(innermost_result) = innermost_result {\n+                        // Found another solution, if the first one was \"weak\", report an error.\n+                        if result.def() != innermost_result.def() &&\n+                           innermost_result.may_appear_after(invoc_id, result) {\n+                            self.ambiguity_errors.push(AmbiguityError {\n+                                ident,\n+                                b1: innermost_result,\n+                                b2: result,\n+                            });\n+                            return Some(innermost_result);\n                         }\n-                        return Some((potential_binding, FromExpansion(relative_depth > 0)));\n+                    } else {\n+                        // Found the first solution.\n+                        innermost_result = Some(result);\n                     }\n-                    scope = &potential_binding.parent;\n+\n+                    continue_search!();\n                 }\n-            };\n+                None => {\n+                    continue_search!();\n+                }\n+            }\n         }\n \n-        None\n+        // The first found solution was the only one (or there was no solution at all), return it.\n+        innermost_result\n     }\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n@@ -844,17 +885,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(mark, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, true,\n-                                                                     kind == MacroKind::Attr, span);\n+            let invocation = self.invocations[&invoc_id];\n+            let legacy_resolution = self.resolve_legacy_scope(\n+                ident, invoc_id, invocation.parent_legacy_scope.get(), true\n+            );\n+            let resolution = self.resolve_lexical_macro_path_segment(\n+                ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n+            );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n                 if let Some(def) = def {\n-                    if this.ambiguity_errors.is_empty() && this.disallowed_shadowing.is_empty() &&\n-                       new_def != def && new_def != Def::Err {\n+                    if this.ambiguity_errors.is_empty() && new_def != def && new_def != Def::Err {\n                         // Make sure compilation does not succeed if preferred macro resolution\n                         // has changed after the macro had been expanded. In theory all such\n                         // situations should be reported as ambiguity errors, so this is span-bug.\n@@ -882,31 +925,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                (Some((legacy_binding, FromExpansion(from_expansion))),\n-                 Ok((binding, FromPrelude(false)))) |\n-                (Some((legacy_binding, FromExpansion(from_expansion @ true))),\n-                 Ok((binding, FromPrelude(true)))) => {\n-                    if legacy_binding.def() != binding.def_ignoring_ambiguity() {\n-                        self.report_ambiguity_error(\n-                            ident.name, span, true,\n-                            legacy_binding.def(), false, false,\n-                            from_expansion, legacy_binding.span,\n-                            binding.def(), binding.is_import(), binding.is_glob_import(),\n-                            binding.expansion != Mark::root(), binding.span,\n-                        );\n+                (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n+                        if !from_prelude || legacy_binding.may_appear_after(invoc_id, binding) => {\n+                    if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n+                        self.report_ambiguity_error(ident, legacy_binding, binding);\n                     }\n                 },\n-                // OK, non-macro-expanded legacy wins over macro prelude even if defs are different\n-                (Some((legacy_binding, FromExpansion(false))), Ok((_, FromPrelude(true)))) |\n+                // OK, non-macro-expanded legacy wins over prelude even if defs are different\n+                (Some(legacy_binding), Ok(_)) |\n                 // OK, unambiguous resolution\n-                (Some((legacy_binding, _)), Err(_)) => {\n+                (Some(legacy_binding), Err(_)) => {\n                     check_consistency(self, legacy_binding.def());\n                 }\n                 // OK, unambiguous resolution\n                 (None, Ok((binding, FromPrelude(from_prelude)))) => {\n                     check_consistency(self, binding.def_ignoring_ambiguity());\n                     if from_prelude {\n-                        self.record_use(ident, MacroNS, binding, span);\n+                        self.record_use(ident, MacroNS, binding);\n                         self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                     }\n                 }\n@@ -981,8 +1016,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 arenas.alloc_invocation_data(InvocationData {\n                     def_index: invoc.def_index,\n                     module: Cell::new(graph_root),\n-                    expansion: Cell::new(LegacyScope::Empty),\n-                    legacy_scope: Cell::new(LegacyScope::Empty),\n+                    parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n+                    output_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n                 })\n             });\n         };\n@@ -997,7 +1032,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: Mark,\n-                        legacy_scope: &mut LegacyScope<'a>) {\n+                        current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n         if ident.name == \"macro_rules\" {\n@@ -1014,10 +1049,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent: Cell::new(*legacy_scope), ident: ident, def_id: def_id, span: item.span,\n-            }));\n             let def = Def::Macro(def_id, MacroKind::Bang);\n+            let vis = ty::Visibility::Invisible; // Doesn't matter for legacy bindings\n+            let binding = (def, vis, item.span, expansion).to_name_binding(self.arenas);\n+            let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent_legacy_scope: *current_legacy_scope, binding, ident\n+            });\n+            *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n             self.all_macros.insert(ident.name, def);\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n                 let module = self.graph_root;"}, {"sha": "f8767fa553f5f08816e0b6b160a81d19b6b515c4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -242,22 +242,19 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         if record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                    let name = ident.name;\n                     // Forbid expanded shadowing to avoid time travel.\n                     if restricted_shadowing &&\n                        binding.expansion != Mark::root() &&\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n-                            span: path_span,\n-                            name,\n-                            lexical: false,\n+                            ident,\n                             b1: binding,\n                             b2: shadowed_glob,\n                         });\n                     }\n                 }\n-                if self.record_use(ident, ns, binding, path_span) {\n+                if self.record_use(ident, ns, binding) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n@@ -937,7 +934,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(ident, ns, binding, directive.span) {\n+                if this.record_use(ident, ns, binding) {\n                     if let ModuleOrUniformRoot::Module(module) = module {\n                         this.resolution(module, ident, ns).borrow_mut().binding =\n                             Some(this.dummy_binding);"}, {"sha": "e912482cf586e07e00732087cbbd7acafe20693c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -966,6 +966,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                      \"the `#[rustc_test_marker]` attribute \\\n                                       is used internally to track tests\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_transparent_macro\", Whitelisted, Gated(Stability::Unstable,\n+                                                   \"rustc_attrs\",\n+                                                   \"used internally for testing macro hygiene\",\n+                                                    cfg_fn!(rustc_attrs))),\n \n     // RFC #2094\n     (\"nll\", Whitelisted, Gated(Stability::Unstable,"}, {"sha": "f053cb10d0649b893c41a014434097444d6bdff6", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -100,6 +100,11 @@ impl Mark {\n         Mark(raw)\n     }\n \n+    #[inline]\n+    pub fn parent(self) -> Mark {\n+        HygieneData::with(|data| data.marks[self.0 as usize].parent)\n+    }\n+\n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())"}, {"sha": "f168b7797ca6d0097e0833ea8410defe96d1cd2b", "filename": "src/test/ui/error-codes/E0659.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -1,8 +1,8 @@\n error[E0659]: `foo` is ambiguous\n-  --> $DIR/E0659.rs:25:5\n+  --> $DIR/E0659.rs:25:15\n    |\n LL |     collider::foo(); //~ ERROR E0659\n-   |     ^^^^^^^^^^^^^\n+   |               ^^^ ambiguous name\n    |\n note: `foo` could refer to the name imported here\n   --> $DIR/E0659.rs:20:13"}, {"sha": "9cdd7aa88f18e497be985f0dfdb471801434be8f", "filename": "src/test/ui/imports/duplicate.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -13,10 +13,10 @@ LL |     use a::foo as other_foo; //~ ERROR the name `foo` is defined multiple t\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error[E0659]: `foo` is ambiguous\n-  --> $DIR/duplicate.rs:56:9\n+  --> $DIR/duplicate.rs:56:15\n    |\n LL |     use self::foo::bar; //~ ERROR `foo` is ambiguous\n-   |         ^^^^^^^^^^^^^^\n+   |               ^^^ ambiguous name\n    |\n note: `foo` could refer to the name imported here\n   --> $DIR/duplicate.rs:53:9\n@@ -31,10 +31,10 @@ LL |     use self::m2::*;\n    = note: consider adding an explicit import of `foo` to disambiguate\n \n error[E0659]: `foo` is ambiguous\n-  --> $DIR/duplicate.rs:45:5\n+  --> $DIR/duplicate.rs:45:8\n    |\n LL |     f::foo(); //~ ERROR `foo` is ambiguous\n-   |     ^^^^^^\n+   |        ^^^ ambiguous name\n    |\n note: `foo` could refer to the name imported here\n   --> $DIR/duplicate.rs:34:13\n@@ -49,10 +49,10 @@ LL |     pub use b::*;\n    = note: consider adding an explicit import of `foo` to disambiguate\n \n error[E0659]: `foo` is ambiguous\n-  --> $DIR/duplicate.rs:46:5\n+  --> $DIR/duplicate.rs:46:8\n    |\n LL |     g::foo(); //~ ERROR `foo` is ambiguous\n-   |     ^^^^^^\n+   |        ^^^ ambiguous name\n    |\n note: `foo` could refer to the name imported here\n   --> $DIR/duplicate.rs:39:13\n@@ -70,7 +70,7 @@ error[E0659]: `foo` is ambiguous\n   --> $DIR/duplicate.rs:59:9\n    |\n LL |         foo::bar(); //~ ERROR `foo` is ambiguous\n-   |         ^^^^^^^^\n+   |         ^^^ ambiguous name\n    |\n note: `foo` could refer to the name imported here\n   --> $DIR/duplicate.rs:53:9"}, {"sha": "33a2963fa29474a7381e8d3160e1a6d571b5ecb8", "filename": "src/test/ui/imports/glob-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `env` is ambiguous\n   --> $DIR/glob-shadowing.rs:21:17\n    |\n LL |         let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n-   |                 ^^^\n+   |                 ^^^ ambiguous name\n    |\n note: `env` could refer to the name imported here\n   --> $DIR/glob-shadowing.rs:19:9\n@@ -16,7 +16,7 @@ error[E0659]: `env` is ambiguous\n   --> $DIR/glob-shadowing.rs:29:21\n    |\n LL |             let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n-   |                     ^^^\n+   |                     ^^^ ambiguous name\n    |\n note: `env` could refer to the name imported here\n   --> $DIR/glob-shadowing.rs:27:13\n@@ -30,7 +30,7 @@ error[E0659]: `fenv` is ambiguous\n   --> $DIR/glob-shadowing.rs:39:21\n    |\n LL |             let x = fenv!(); //~ ERROR `fenv` is ambiguous\n-   |                     ^^^^\n+   |                     ^^^^ ambiguous name\n    |\n note: `fenv` could refer to the name imported here\n   --> $DIR/glob-shadowing.rs:37:13"}, {"sha": "e125983151d2b6c38d12e80cbe063be62bf174f0", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -8,7 +8,7 @@ error[E0659]: `mac` is ambiguous\n   --> $DIR/issue-53269.rs:18:5\n    |\n LL |     mac!(); //~ ERROR `mac` is ambiguous\n-   |     ^^^\n+   |     ^^^ ambiguous name\n    |\n note: `mac` could refer to the name defined here\n   --> $DIR/issue-53269.rs:13:1"}, {"sha": "fb05b95a96dc621bde8238c8ce3788dafd2b4752", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -43,7 +43,6 @@ mod inner2 {\n \n fn main() {\n     panic!(); //~ ERROR `panic` is ambiguous\n-              //~^ ERROR `panic` is ambiguous\n }\n \n mod inner3 {"}, {"sha": "cce1fd30f1d6db14ae3e90934113884afbc47c88", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `exported` is ambiguous\n   --> $DIR/local-modularized-tricky-fail-1.rs:38:1\n    |\n LL | exported!(); //~ ERROR `exported` is ambiguous\n-   | ^^^^^^^^\n+   | ^^^^^^^^ ambiguous name\n    |\n note: `exported` could refer to the name defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:15:5\n@@ -22,10 +22,10 @@ LL | use inner1::*;\n    = note: macro-expanded macros do not shadow\n \n error[E0659]: `include` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:57:1\n+  --> $DIR/local-modularized-tricky-fail-1.rs:56:1\n    |\n LL | include!(); //~ ERROR `include` is ambiguous\n-   | ^^^^^^^\n+   | ^^^^^^^ ambiguous name\n    |\n note: `include` could refer to the name defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:27:5\n@@ -44,7 +44,7 @@ error[E0659]: `panic` is ambiguous\n   --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n-   |     ^^^^^\n+   |     ^^^^^ ambiguous name\n    |\n note: `panic` could refer to the name defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n@@ -60,10 +60,10 @@ LL |       define_panic!();\n    = note: macro-expanded macros do not shadow\n \n error[E0659]: `panic` is ambiguous\n-  --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n+  --> <panic macros>:1:13\n    |\n-LL |     panic!(); //~ ERROR `panic` is ambiguous\n-   |     ^^^^^^^^^\n+LL | (  ) => ( { panic ! ( \"explicit panic\" ) } ) ; ( $ msg : expr ) => (\n+   |             ^^^^^ ambiguous name\n    |\n note: `panic` could refer to the name defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n@@ -77,7 +77,6 @@ LL |       define_panic!();\n    |       ---------------- in this macro invocation\n    = note: `panic` is also a builtin macro\n    = note: macro-expanded macros do not shadow\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a612c64c2f4705daf0bbadab487087b88209648d", "filename": "src/test/ui/imports/macro-paths.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `bar` is ambiguous\n   --> $DIR/macro-paths.rs:23:5\n    |\n LL |     bar::m! { //~ ERROR ambiguous\n-   |     ^^^^^^\n+   |     ^^^ ambiguous name\n    |\n note: `bar` could refer to the name defined here\n   --> $DIR/macro-paths.rs:24:9\n@@ -20,7 +20,7 @@ error[E0659]: `baz` is ambiguous\n   --> $DIR/macro-paths.rs:33:5\n    |\n LL |     baz::m! { //~ ERROR ambiguous\n-   |     ^^^^^^\n+   |     ^^^ ambiguous name\n    |\n note: `baz` could refer to the name defined here\n   --> $DIR/macro-paths.rs:34:9"}, {"sha": "c54101fc6e6a8ec69d2d43f6665c58c7b98d73d2", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:48:5\n    |\n LL |     m!(); //~ ERROR ambiguous\n-   |     ^\n+   |     ^ ambiguous name\n    |\n note: `m` could refer to the name defined here\n   --> $DIR/macros.rs:46:5\n@@ -19,7 +19,7 @@ error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:26:5\n    |\n LL |     m! { //~ ERROR ambiguous\n-   |     ^\n+   |     ^ ambiguous name\n    |\n note: `m` could refer to the name imported here\n   --> $DIR/macros.rs:27:13\n@@ -37,7 +37,7 @@ error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:39:9\n    |\n LL |         m! { //~ ERROR ambiguous\n-   |         ^\n+   |         ^ ambiguous name\n    |\n note: `m` could refer to the name imported here\n   --> $DIR/macros.rs:40:17"}, {"sha": "91af3a4b6ac736d625116d66a3e923a43f19b94e", "filename": "src/test/ui/imports/rfc-1560-warning-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `Foo` is ambiguous\n   --> $DIR/rfc-1560-warning-cycle.rs:19:17\n    |\n LL |         fn f(_: Foo) {} //~ ERROR `Foo` is ambiguous\n-   |                 ^^^\n+   |                 ^^^ ambiguous name\n    |\n note: `Foo` could refer to the name imported here\n   --> $DIR/rfc-1560-warning-cycle.rs:17:13"}, {"sha": "e554bbb4f3146073d85a8c96baaf920da8c3db17", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:43:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n-   |     ^^^^^\n+   |     ^^^^^ ambiguous name\n    |\n note: `panic` could refer to the name defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n@@ -19,7 +19,7 @@ error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n-   |              ^^^^^\n+   |              ^^^^^ ambiguous name\n    |\n note: `panic` could refer to the name imported here\n   --> $DIR/shadow_builtin_macros.rs:24:9\n@@ -33,7 +33,7 @@ error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:30:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n-   |              ^^^^^\n+   |              ^^^^^ ambiguous name\n    |\n note: `panic` could refer to the name imported here\n   --> $DIR/shadow_builtin_macros.rs:29:26\n@@ -47,7 +47,7 @@ error[E0659]: `n` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:59:5\n    |\n LL |     n!(); //~ ERROR ambiguous\n-   |     ^\n+   |     ^ ambiguous name\n    |\n note: `n` could refer to the name imported here\n   --> $DIR/shadow_builtin_macros.rs:58:9"}, {"sha": "7f716c5012efda47aaeb73041dd7307005139a6e", "filename": "src/test/ui/macros/auxiliary/macro-in-other-crate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fmacro-in-other-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fmacro-in-other-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fmacro-in-other-crate.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -17,3 +17,8 @@ macro_rules! mac {\n macro_rules! inline {\n     () => ()\n }\n+\n+#[macro_export]\n+macro_rules! from_prelude {\n+    () => ()\n+}"}, {"sha": "607d3e100aa25cb64993429a4b32eb3f99e50542", "filename": "src/test/ui/macros/macro-path-prelude-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -2,7 +2,7 @@ error[E0659]: `std` is ambiguous\n   --> $DIR/macro-path-prelude-shadowing.rs:39:9\n    |\n LL |         std::panic!(); //~ ERROR `std` is ambiguous\n-   |         ^^^^^^^^^^\n+   |         ^^^ ambiguous name\n    |\n note: `std` could refer to the name imported here\n   --> $DIR/macro-path-prelude-shadowing.rs:37:9"}, {"sha": "8d5b03b098f2934a9ebecd9bb29b7f5c2a6360eb", "filename": "src/test/ui/macros/macro-shadowing-relaxed.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing-relaxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing-relaxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing-relaxed.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// aux-build:macro-in-other-crate.rs\n+\n+#![feature(decl_macro)]\n+\n+macro_rules! my_include {() => {\n+    // Outer\n+    macro m() {}\n+    #[macro_use(from_prelude)] extern crate macro_in_other_crate;\n+\n+    fn inner() {\n+        // Inner\n+        macro m() {}\n+        macro_rules! from_prelude { () => {} }\n+\n+        // OK, both `m` and `from_prelude` are macro-expanded,\n+        // but no more macro-expanded than their counterpart from outer scope.\n+        m!();\n+        from_prelude!();\n+    }\n+}}\n+\n+my_include!();\n+\n+fn main() {}"}, {"sha": "bf0a7fa21d37acb3126d0292f8efa1e1b1b74ef2", "filename": "src/test/ui/macros/macro-shadowing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -17,14 +17,14 @@ macro_rules! macro_one { () => {} }\n #[macro_use(macro_two)] extern crate two_macros;\n \n macro_rules! m1 { () => {\n-    macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n+    macro_rules! foo { () => {} }\n \n     #[macro_use] //~ ERROR `macro_two` is already in scope\n     extern crate two_macros as __;\n }}\n m1!();\n \n-foo!();\n+foo!(); //~ ERROR `foo` is ambiguous\n \n macro_rules! m2 { () => {\n     macro_rules! foo { () => {} }"}, {"sha": "d996f3a7041953300d268de80ec3d8bed343ec02", "filename": "src/test/ui/macros/macro-shadowing.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -9,16 +9,27 @@ LL | m1!();\n    |\n    = note: macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\n \n-error: `foo` is already in scope\n+error[E0659]: `foo` is ambiguous\n+  --> $DIR/macro-shadowing.rs:27:1\n+   |\n+LL | foo!(); //~ ERROR `foo` is ambiguous\n+   | ^^^ ambiguous name\n+   |\n+note: `foo` could refer to the name defined here\n   --> $DIR/macro-shadowing.rs:20:5\n    |\n-LL |     macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n+LL |     macro_rules! foo { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | m1!();\n    | ------ in this macro invocation\n+note: `foo` could also refer to the name defined here\n+  --> $DIR/macro-shadowing.rs:15:1\n    |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+LL | macro_rules! foo { () => {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: macro-expanded macros do not shadow\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "f5cac2dfbfb4113b7593cf4ee58d59e8398c0563", "filename": "src/test/ui/macros/restricted-shadowing-legacy.rs", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -0,0 +1,289 @@\n+// Legend:\n+// `N` - number of combination, from 0 to 4*4*4=64\n+// `Outer < Invoc` means that expansion that produced macro definition `Outer`\n+// is a strict ancestor of expansion that produced macro definition `Inner`.\n+// `>`, `=` and `Unordered` mean \"strict descendant\", \"same\" and\n+// \"not in ordering relation\" for parent expansions.\n+// `+` - possible configuration\n+// `-` - configuration impossible due to properties of partial ordering\n+// `-?` - configuration impossible due to block/scope syntax\n+// `+?` - configuration possible only with legacy scoping\n+\n+//  N | Outer ~ Invoc | Invoc ~ Inner | Outer ~ Inner | Possible |\n+//  1 |       <       |       <       |       <       |    +     |\n+//  2 |       <       |       <       |       =       |    -     |\n+//  3 |       <       |       <       |       >       |    -     |\n+//  4 |       <       |       <       |   Unordered   |    -     |\n+//  5 |       <       |       =       |       <       |    +     |\n+//  6 |       <       |       =       |       =       |    -     |\n+//  7 |       <       |       =       |       >       |    -     |\n+//  8 |       <       |       =       |   Unordered   |    -     |\n+//  9 |       <       |       >       |       <       |    +     |\n+// 10 |       <       |       >       |       =       |    +     |\n+// 11 |       <       |       >       |       >       |    -?    |\n+// 12 |       <       |       >       |   Unordered   |    -?    |\n+// 13 |       <       |   Unordered   |       <       |    +     |\n+// 14 |       <       |   Unordered   |       =       |    -     |\n+// 15 |       <       |   Unordered   |       >       |    -     |\n+// 16 |       <       |   Unordered   |   Unordered   |    -?    |\n+// 17 |       =       |       <       |       <       |    +     |\n+// 18 |       =       |       <       |       =       |    -     |\n+// 19 |       =       |       <       |       >       |    -     |\n+// 20 |       =       |       <       |   Unordered   |    -     |\n+// 21 |       =       |       =       |       <       |    -     |\n+// 22 |       =       |       =       |       =       |    +     |\n+// 23 |       =       |       =       |       >       |    -     |\n+// 24 |       =       |       =       |   Unordered   |    -     |\n+// 25 |       =       |       >       |       <       |    -     |\n+// 26 |       =       |       >       |       =       |    -     |\n+// 27 |       =       |       >       |       >       |    -?    |\n+// 28 |       =       |       >       |   Unordered   |    -     |\n+// 29 |       =       |   Unordered   |       <       |    -     |\n+// 30 |       =       |   Unordered   |       =       |    -     |\n+// 31 |       =       |   Unordered   |       >       |    -     |\n+// 32 |       =       |   Unordered   |   Unordered   |    -?    |\n+// 33 |       >       |       <       |       <       |    +?    |\n+// 34 |       >       |       <       |       =       |    +?    |\n+// 35 |       >       |       <       |       >       |    +?    |\n+// 36 |       >       |       <       |   Unordered   |    +     |\n+// 37 |       >       |       =       |       <       |    -     |\n+// 38 |       >       |       =       |       =       |    -     |\n+// 39 |       >       |       =       |       >       |    +     |\n+// 40 |       >       |       =       |   Unordered   |    -     |\n+// 41 |       >       |       >       |       <       |    -     |\n+// 42 |       >       |       >       |       =       |    -     |\n+// 43 |       >       |       >       |       >       |    -?    |\n+// 44 |       >       |       >       |   Unordered   |    -     |\n+// 45 |       >       |   Unordered   |       <       |    -     |\n+// 46 |       >       |   Unordered   |       =       |    -     |\n+// 47 |       >       |   Unordered   |       >       |    -?    |\n+// 48 |       >       |   Unordered   |   Unordered   |    -?    |\n+// 49 |   Unordered   |       <       |       <       |    -?    |\n+// 50 |   Unordered   |       <       |       =       |    -     |\n+// 51 |   Unordered   |       <       |       >       |    -     |\n+// 52 |   Unordered   |       <       |   Unordered   |    +     |\n+// 53 |   Unordered   |       =       |       <       |    -     |\n+// 54 |   Unordered   |       =       |       =       |    -     |\n+// 55 |   Unordered   |       =       |       >       |    -     |\n+// 56 |   Unordered   |       =       |   Unordered   |    +     |\n+// 57 |   Unordered   |       >       |       <       |    -     |\n+// 58 |   Unordered   |       >       |       =       |    -     |\n+// 59 |   Unordered   |       >       |       >       |    +     |\n+// 60 |   Unordered   |       >       |   Unordered   |    +     |\n+// 61 |   Unordered   |   Unordered   |       <       |    +?    |\n+// 62 |   Unordered   |   Unordered   |       =       |    +?    |\n+// 63 |   Unordered   |   Unordered   |       >       |    +?    |\n+// 64 |   Unordered   |   Unordered   |   Unordered   |    +     |\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+struct Right;\n+// struct Wrong; // not defined\n+\n+macro_rules! include { () => {\n+    macro_rules! gen_outer { () => {\n+        macro_rules! m { () => { Wrong } }\n+    }}\n+    macro_rules! gen_inner { () => {\n+        macro_rules! m { () => { Right } }\n+    }}\n+    macro_rules! gen_invoc { () => {\n+        m!()\n+    }}\n+\n+    // -----------------------------------------------------------\n+\n+    fn check1() {\n+        macro_rules! m { () => {} }\n+\n+        macro_rules! gen_gen_inner_invoc { () => {\n+            gen_inner!();\n+            m!(); //~ ERROR `m` is ambiguous\n+        }}\n+        gen_gen_inner_invoc!();\n+    }\n+\n+    fn check5() {\n+        macro_rules! m { () => { Wrong } }\n+\n+        macro_rules! gen_inner_invoc { () => {\n+            macro_rules! m { () => { Right } }\n+            m!(); // OK\n+        }}\n+        gen_inner_invoc!();\n+    }\n+\n+    fn check9() {\n+        macro_rules! m { () => { Wrong } }\n+\n+        macro_rules! gen_inner_gen_invoc { () => {\n+            macro_rules! m { () => { Right } }\n+            gen_invoc!(); // OK\n+        }}\n+        gen_inner_gen_invoc!();\n+    }\n+\n+    fn check10() {\n+        macro_rules! m { () => { Wrong } }\n+\n+        macro_rules! m { () => { Right } }\n+\n+        gen_invoc!(); // OK\n+    }\n+\n+    fn check13() {\n+        macro_rules! m { () => {} }\n+\n+        gen_inner!();\n+\n+        macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+        gen_invoc!();\n+    }\n+\n+    fn check17() {\n+        macro_rules! m { () => {} }\n+\n+        gen_inner!();\n+\n+        m!(); //~ ERROR `m` is ambiguous\n+    }\n+\n+    fn check22() {\n+        macro_rules! m { () => { Wrong } }\n+\n+        macro_rules! m { () => { Right } }\n+\n+        m!(); // OK\n+    }\n+\n+    fn check36() {\n+        gen_outer!();\n+\n+        gen_inner!();\n+\n+        m!(); //~ ERROR `m` is ambiguous\n+    }\n+\n+    fn check39() {\n+        gen_outer!();\n+\n+        macro_rules! m { () => { Right } }\n+\n+        m!(); // OK\n+    }\n+\n+    fn check52() {\n+        gen_outer!();\n+\n+        macro_rules! gen_gen_inner_invoc { () => {\n+            gen_inner!();\n+            m!(); //~ ERROR `m` is ambiguous\n+        }}\n+        gen_gen_inner_invoc!();\n+    }\n+\n+    fn check56() {\n+        gen_outer!();\n+\n+        macro_rules! gen_inner_invoc { () => {\n+            macro_rules! m { () => { Right } }\n+            m!(); // OK\n+        }}\n+        gen_inner_invoc!();\n+    }\n+\n+    fn check59() {\n+        gen_outer!();\n+\n+        macro_rules! m { () => { Right } }\n+\n+        gen_invoc!(); // OK\n+    }\n+\n+    fn check60() {\n+        gen_outer!();\n+\n+        macro_rules! gen_inner_gen_invoc { () => {\n+            macro_rules! m { () => { Right } }\n+            gen_invoc!(); // OK\n+        }}\n+        gen_inner_gen_invoc!();\n+    }\n+\n+    fn check64() {\n+        gen_outer!();\n+\n+        gen_inner!();\n+\n+        macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+        gen_invoc!();\n+    }\n+\n+    // -----------------------------------------------------------\n+    // These configurations are only possible with legacy macro scoping\n+\n+    fn check33() {\n+        macro_rules! gen_outer_gen_inner { () => {\n+            macro_rules! m { () => {} }\n+            gen_inner!();\n+        }}\n+        gen_outer_gen_inner!();\n+\n+        m!(); //~ ERROR `m` is ambiguous\n+    }\n+\n+    fn check34() {\n+        macro_rules! gen_outer_inner { () => {\n+            macro_rules! m { () => { Wrong } }\n+            macro_rules! m { () => { Right } }\n+        }}\n+        gen_outer_inner!();\n+\n+        m!(); // OK\n+    }\n+\n+    fn check35() {\n+        macro_rules! gen_gen_outer_inner { () => {\n+            gen_outer!();\n+            macro_rules! m { () => { Right } }\n+        }}\n+        gen_gen_outer_inner!();\n+\n+        m!(); // OK\n+    }\n+\n+    fn check61() {\n+        macro_rules! gen_outer_gen_inner { () => {\n+            macro_rules! m { () => {} }\n+            gen_inner!();\n+        }}\n+        gen_outer_gen_inner!();\n+\n+        macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+        gen_invoc!();\n+    }\n+\n+    fn check62() {\n+        macro_rules! gen_outer_inner { () => {\n+            macro_rules! m { () => { Wrong } }\n+            macro_rules! m { () => { Right } }\n+        }}\n+        gen_outer_inner!();\n+\n+        gen_invoc!(); // OK\n+    }\n+\n+    fn check63() {\n+        macro_rules! gen_gen_outer_inner { () => {\n+            gen_outer!();\n+            macro_rules! m { () => { Right } }\n+        }}\n+        gen_gen_outer_inner!();\n+\n+        gen_invoc!(); // OK\n+    }\n+}}\n+\n+include!();\n+\n+fn main() {}"}, {"sha": "9e0d40c44b6834d1832dd1901ea3f9aace3bcc06", "filename": "src/test/ui/macros/restricted-shadowing-legacy.stderr", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -0,0 +1,195 @@\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:101:13\n+   |\n+LL |             m!(); //~ ERROR `m` is ambiguous\n+   |             ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:97:9\n+   |\n+LL |         macro_rules! m { () => {} }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:139:42\n+   |\n+LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+   |                                          ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:135:9\n+   |\n+LL |         macro_rules! m { () => {} }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:148:9\n+   |\n+LL |         m!(); //~ ERROR `m` is ambiguous\n+   |         ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:144:9\n+   |\n+LL |         macro_rules! m { () => {} }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:164:9\n+   |\n+LL |         m!(); //~ ERROR `m` is ambiguous\n+   |         ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:85:9\n+   |\n+LL |         macro_rules! m { () => { Wrong } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:180:13\n+   |\n+LL |             m!(); //~ ERROR `m` is ambiguous\n+   |             ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:85:9\n+   |\n+LL |         macro_rules! m { () => { Wrong } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:218:42\n+   |\n+LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+   |                                          ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:85:9\n+   |\n+LL |         macro_rules! m { () => { Wrong } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:232:9\n+   |\n+LL |         m!(); //~ ERROR `m` is ambiguous\n+   |         ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:227:13\n+   |\n+LL |             macro_rules! m { () => {} }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-legacy.rs:262:42\n+   |\n+LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n+   |                                          ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:88:9\n+   |\n+LL |         macro_rules! m { () => { Right } }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-legacy.rs:257:13\n+   |\n+LL |             macro_rules! m { () => {} }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "448f623c2208fe3d6ab10ba119ab33c045834a91", "filename": "src/test/ui/macros/restricted-shadowing-modern.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -0,0 +1,243 @@\n+// Legend:\n+// `N` - number of combination, from 0 to 4*4*4=64\n+// `Outer < Invoc` means that expansion that produced macro definition `Outer`\n+// is a strict ancestor of expansion that produced macro definition `Inner`.\n+// `>`, `=` and `Unordered` mean \"strict descendant\", \"same\" and\n+// \"not in ordering relation\" for parent expansions.\n+// `+` - possible configuration\n+// `-` - configuration impossible due to properties of partial ordering\n+// `-?` - configuration impossible due to block/scope syntax\n+// `+?` - configuration possible only with legacy scoping\n+\n+//  N | Outer ~ Invoc | Invoc ~ Inner | Outer ~ Inner | Possible |\n+//  1 |       <       |       <       |       <       |    +     |\n+//  2 |       <       |       <       |       =       |    -     |\n+//  3 |       <       |       <       |       >       |    -     |\n+//  4 |       <       |       <       |   Unordered   |    -     |\n+//  5 |       <       |       =       |       <       |    +     |\n+//  6 |       <       |       =       |       =       |    -     |\n+//  7 |       <       |       =       |       >       |    -     |\n+//  8 |       <       |       =       |   Unordered   |    -     |\n+//  9 |       <       |       >       |       <       |    +     |\n+// 10 |       <       |       >       |       =       |    +     |\n+// 11 |       <       |       >       |       >       |    -?    |\n+// 12 |       <       |       >       |   Unordered   |    -?    |\n+// 13 |       <       |   Unordered   |       <       |    +     |\n+// 14 |       <       |   Unordered   |       =       |    -     |\n+// 15 |       <       |   Unordered   |       >       |    -     |\n+// 16 |       <       |   Unordered   |   Unordered   |    -?    |\n+// 17 |       =       |       <       |       <       |    +     |\n+// 18 |       =       |       <       |       =       |    -     |\n+// 19 |       =       |       <       |       >       |    -     |\n+// 20 |       =       |       <       |   Unordered   |    -     |\n+// 21 |       =       |       =       |       <       |    -     |\n+// 22 |       =       |       =       |       =       |    +     |\n+// 23 |       =       |       =       |       >       |    -     |\n+// 24 |       =       |       =       |   Unordered   |    -     |\n+// 25 |       =       |       >       |       <       |    -     |\n+// 26 |       =       |       >       |       =       |    -     |\n+// 27 |       =       |       >       |       >       |    -?    |\n+// 28 |       =       |       >       |   Unordered   |    -     |\n+// 29 |       =       |   Unordered   |       <       |    -     |\n+// 30 |       =       |   Unordered   |       =       |    -     |\n+// 31 |       =       |   Unordered   |       >       |    -     |\n+// 32 |       =       |   Unordered   |   Unordered   |    -?    |\n+// 33 |       >       |       <       |       <       |    -?    |\n+// 34 |       >       |       <       |       =       |    -?    |\n+// 35 |       >       |       <       |       >       |    -?    |\n+// 36 |       >       |       <       |   Unordered   |    +     |\n+// 37 |       >       |       =       |       <       |    -     |\n+// 38 |       >       |       =       |       =       |    -     |\n+// 39 |       >       |       =       |       >       |    +     |\n+// 40 |       >       |       =       |   Unordered   |    -     |\n+// 41 |       >       |       >       |       <       |    -     |\n+// 42 |       >       |       >       |       =       |    -     |\n+// 43 |       >       |       >       |       >       |    -?    |\n+// 44 |       >       |       >       |   Unordered   |    -     |\n+// 45 |       >       |   Unordered   |       <       |    -     |\n+// 46 |       >       |   Unordered   |       =       |    -     |\n+// 47 |       >       |   Unordered   |       >       |    -?    |\n+// 48 |       >       |   Unordered   |   Unordered   |    -?    |\n+// 49 |   Unordered   |       <       |       <       |    -?    |\n+// 50 |   Unordered   |       <       |       =       |    -     |\n+// 51 |   Unordered   |       <       |       >       |    -     |\n+// 52 |   Unordered   |       <       |   Unordered   |    +     |\n+// 53 |   Unordered   |       =       |       <       |    -     |\n+// 54 |   Unordered   |       =       |       =       |    -     |\n+// 55 |   Unordered   |       =       |       >       |    -     |\n+// 56 |   Unordered   |       =       |   Unordered   |    +     |\n+// 57 |   Unordered   |       >       |       <       |    -     |\n+// 58 |   Unordered   |       >       |       =       |    -     |\n+// 59 |   Unordered   |       >       |       >       |    +     |\n+// 60 |   Unordered   |       >       |   Unordered   |    +     |\n+// 61 |   Unordered   |   Unordered   |       <       |    -?    |\n+// 62 |   Unordered   |   Unordered   |       =       |    -?    |\n+// 63 |   Unordered   |   Unordered   |       >       |    -?    |\n+// 64 |   Unordered   |   Unordered   |   Unordered   |    +     |\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+struct Right;\n+// struct Wrong; // not defined\n+\n+#[rustc_transparent_macro]\n+macro include() {\n+    #[rustc_transparent_macro]\n+    macro gen_outer() {\n+        macro m() { Wrong }\n+    }\n+    #[rustc_transparent_macro]\n+    macro gen_inner() {\n+        macro m() { Right }\n+    }\n+    #[rustc_transparent_macro]\n+    macro gen_invoc() {\n+        m!()\n+    }\n+\n+    // -----------------------------------------------------------\n+\n+    fn check1() {\n+        macro m() {}\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_gen_inner_invoc() {\n+                gen_inner!();\n+                m!(); //~ ERROR `m` is ambiguous\n+            }\n+            gen_gen_inner_invoc!();\n+        }\n+    }\n+\n+    fn check5() {\n+        macro m() { Wrong }\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_inner_invoc() {\n+                macro m() { Right }\n+                m!(); // OK\n+            }\n+            gen_inner_invoc!();\n+        }\n+    }\n+\n+    fn check9() {\n+        macro m() { Wrong }\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_inner_gen_invoc() {\n+                macro m() { Right }\n+                gen_invoc!(); // OK\n+            }\n+            gen_inner_gen_invoc!();\n+        }\n+    }\n+\n+    fn check10() {\n+        macro m() { Wrong }\n+        {\n+            macro m() { Right }\n+            gen_invoc!(); // OK\n+        }\n+    }\n+\n+    fn check13() {\n+        macro m() {}\n+        {\n+            gen_inner!();\n+            #[rustc_transparent_macro]\n+            macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n+            gen_invoc!();\n+        }\n+    }\n+\n+    fn check17() {\n+        macro m() {}\n+        {\n+            gen_inner!();\n+            m!(); //~ ERROR `m` is ambiguous\n+        }\n+    }\n+\n+    fn check22() {\n+        macro m() { Wrong }\n+        {\n+            macro m() { Right }\n+            m!(); // OK\n+        }\n+    }\n+\n+    fn check36() {\n+        gen_outer!();\n+        {\n+            gen_inner!();\n+            m!(); //~ ERROR `m` is ambiguous\n+        }\n+    }\n+\n+    fn check39() {\n+        gen_outer!();\n+        {\n+            macro m() { Right }\n+            m!(); // OK\n+        }\n+    }\n+\n+    fn check52() {\n+        gen_outer!();\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_gen_inner_invoc() {\n+                gen_inner!();\n+                m!(); //~ ERROR `m` is ambiguous\n+            }\n+            gen_gen_inner_invoc!();\n+        }\n+    }\n+\n+    fn check56() {\n+        gen_outer!();\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_inner_invoc() {\n+                macro m() { Right }\n+                m!(); // OK\n+            }\n+            gen_inner_invoc!();\n+        }\n+    }\n+\n+    fn check59() {\n+        gen_outer!();\n+        {\n+            macro m() { Right }\n+            gen_invoc!(); // OK\n+        }\n+    }\n+\n+    fn check60() {\n+        gen_outer!();\n+        {\n+            #[rustc_transparent_macro]\n+            macro gen_inner_gen_invoc() {\n+                macro m() { Right }\n+                gen_invoc!(); // OK\n+            }\n+            gen_inner_gen_invoc!();\n+        }\n+    }\n+\n+    fn check64() {\n+        gen_outer!();\n+        {\n+            gen_inner!();\n+            #[rustc_transparent_macro]\n+            macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n+            gen_invoc!();\n+        }\n+    }\n+}\n+\n+include!();\n+\n+fn main() {}"}, {"sha": "0462438be78079a161f61bbcd833c35ba42406d1", "filename": "src/test/ui/macros/restricted-shadowing-modern.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -0,0 +1,147 @@\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:106:17\n+   |\n+LL |                 m!(); //~ ERROR `m` is ambiguous\n+   |                 ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:101:9\n+   |\n+LL |         macro m() {}\n+   |         ^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:149:33\n+   |\n+LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n+   |                                 ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:145:9\n+   |\n+LL |         macro m() {}\n+   |         ^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:158:13\n+   |\n+LL |             m!(); //~ ERROR `m` is ambiguous\n+   |             ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:155:9\n+   |\n+LL |         macro m() {}\n+   |         ^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:174:13\n+   |\n+LL |             m!(); //~ ERROR `m` is ambiguous\n+   |             ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:87:9\n+   |\n+LL |         macro m() { Wrong }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:192:17\n+   |\n+LL |                 m!(); //~ ERROR `m` is ambiguous\n+   |                 ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:87:9\n+   |\n+LL |         macro m() { Wrong }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error[E0659]: `m` is ambiguous\n+  --> $DIR/restricted-shadowing-modern.rs:235:33\n+   |\n+LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n+   |                                 ^ ambiguous name\n+   |\n+note: `m` could refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:91:9\n+   |\n+LL |         macro m() { Right }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+note: `m` could also refer to the name defined here\n+  --> $DIR/restricted-shadowing-modern.rs:87:9\n+   |\n+LL |         macro m() { Wrong }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+...\n+LL | include!();\n+   | ----------- in this macro invocation\n+   = note: macro-expanded macros do not shadow\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "977b475b11340477b848f393f92d0f90e93f8d03", "filename": "src/test/ui/out-of-order-shadowing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n // aux-build:define_macro.rs\n-// error-pattern: `bar` is already in scope\n \n macro_rules! bar { () => {} }\n define_macro!(bar);\n-bar!();\n+bar!(); //~ ERROR `bar` is ambiguous\n \n macro_rules! m { () => { #[macro_use] extern crate define_macro; } }\n m!();"}, {"sha": "d96a802cb3f8f66b3a90707390534021e433cce2", "filename": "src/test/ui/out-of-order-shadowing.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr?ref=2d4e34ca8bb1369f7e0eea4cb50e6faa0827a6e5", "patch": "@@ -1,11 +1,22 @@\n-error: `bar` is already in scope\n+error[E0659]: `bar` is ambiguous\n   --> $DIR/out-of-order-shadowing.rs:15:1\n    |\n+LL | bar!(); //~ ERROR `bar` is ambiguous\n+   | ^^^ ambiguous name\n+   |\n+note: `bar` could refer to the name defined here\n+  --> $DIR/out-of-order-shadowing.rs:14:1\n+   |\n LL | define_macro!(bar);\n    | ^^^^^^^^^^^^^^^^^^^\n+note: `bar` could also refer to the name defined here\n+  --> $DIR/out-of-order-shadowing.rs:13:1\n    |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+LL | macro_rules! bar { () => {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: macro-expanded macros do not shadow\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}]}