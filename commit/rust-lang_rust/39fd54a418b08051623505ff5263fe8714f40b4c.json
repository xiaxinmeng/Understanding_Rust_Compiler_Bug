{"sha": "39fd54a418b08051623505ff5263fe8714f40b4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZmQ1NGE0MThiMDgwNTE2MjM1MDVmZjUyNjNmZTg3MTRmNDBiNGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-21T18:08:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: move the `FORCE_IMPL_FILENAME_LINE` hack into `print_def_path`.", "tree": {"sha": "281b203d03d8ed500c7fd84409cd2bf8faf57e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/281b203d03d8ed500c7fd84409cd2bf8faf57e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39fd54a418b08051623505ff5263fe8714f40b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39fd54a418b08051623505ff5263fe8714f40b4c", "html_url": "https://github.com/rust-lang/rust/commit/39fd54a418b08051623505ff5263fe8714f40b4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39fd54a418b08051623505ff5263fe8714f40b4c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aec5a484812e2e6d0077a960997f1f51f18c1c8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec5a484812e2e6d0077a960997f1f51f18c1c8a", "html_url": "https://github.com/rust-lang/rust/commit/aec5a484812e2e6d0077a960997f1f51f18c1c8a"}], "stats": {"total": 83, "additions": 42, "deletions": 41}, "files": [{"sha": "e0a5a2fcf843bca0aa286c4d3830da97dc7f908d", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/39fd54a418b08051623505ff5263fe8714f40b4c/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fd54a418b08051623505ff5263fe8714f40b4c/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=39fd54a418b08051623505ff5263fe8714f40b4c", "patch": "@@ -162,8 +162,10 @@ pub trait Printer: Sized {\n         impl_def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Self::Path {\n-        self.default_print_impl_path(impl_def_id, substs, ns)\n+        self.default_print_impl_path(impl_def_id, substs, ns, self_ty, trait_ref)\n     }\n \n     #[must_use]\n@@ -273,7 +275,16 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             }\n \n             DefPathData::Impl => {\n-                self.print_impl_path(def_id, substs, ns)\n+                let mut self_ty = self.tcx.type_of(def_id);\n+                if let Some(substs) = substs {\n+                    self_ty = self_ty.subst(self.tcx, substs);\n+                }\n+\n+                let mut impl_trait_ref = self.tcx.impl_trait_ref(def_id);\n+                if let Some(substs) = substs {\n+                    impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n+                }\n+                self.print_impl_path(def_id, substs, ns, self_ty, impl_trait_ref)\n             }\n \n             _ => {\n@@ -323,30 +334,24 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n     fn default_print_impl_path(\n         &mut self,\n         impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        _substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n+        self_ty: Ty<'tcx>,\n+        impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> P::Path {\n-        debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n-        let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n+        debug!(\"default_print_impl_path: impl_def_id={:?}, self_ty={}, impl_trait_ref={:?}\",\n+               impl_def_id, self_ty, impl_trait_ref);\n \n         // Decide whether to print the parent path for the impl.\n         // Logically, since impls are global, it's never needed, but\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let mut self_ty = self.tcx.type_of(impl_def_id);\n-        if let Some(substs) = substs {\n-            self_ty = self_ty.subst(self.tcx, substs);\n-        }\n+        let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.tcx.parent(ty_def_id) == Some(parent_def_id),\n         };\n-\n-        let mut impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n-        if let Some(substs) = substs {\n-            impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n-        }\n         let in_trait_mod = match impl_trait_ref {\n             None => false,\n             Some(trait_ref) => self.tcx.parent(trait_ref.def_id) == Some(parent_def_id),\n@@ -702,7 +707,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Self::Path {\n-        // FIXME(eddyb) avoid querying `tcx.generics_of`\n+        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n         // both here and in `default_print_def_path`.\n         let generics = substs.map(|_| self.tcx.generics_of(def_id));\n         if // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n@@ -720,35 +725,31 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             }\n         }\n \n-        self.default_print_def_path(def_id, substs, ns, projections)\n-    }\n-    fn print_impl_path(\n-        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n-        impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n-        ns: Namespace,\n-    ) -> Self::Path {\n-        // Always use types for non-local impls, where types are always\n-        // available, and filename/line-number is mostly uninteresting.\n-        let use_types = // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n-            FORCE_ABSOLUTE.with(|force| force.get()) ||\n-            !impl_def_id.is_local() || {\n-            // Otherwise, use filename/line-number if forced.\n-            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-            !force_no_types\n-        };\n+        let key = self.tcx.def_key(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                // HACK(eddyb) remove the `FORCE_ABSOLUTE` hack by bypassing `FmtPrinter`\n+                FORCE_ABSOLUTE.with(|force| force.get()) ||\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n \n-        if !use_types {\n-            // If no type info is available, fall back to\n-            // pretty printing some span information. This should\n-            // only occur very early in the compiler pipeline.\n-            let parent_def_id = self.tcx.parent(impl_def_id).unwrap();\n-            let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n-            let span = self.tcx.def_span(impl_def_id);\n-            return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n+                let span = self.tcx.def_span(def_id);\n+                return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n+            }\n         }\n \n-        self.default_print_impl_path(impl_def_id, substs, ns)\n+        self.default_print_def_path(def_id, substs, ns, projections)\n     }\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {"}]}