{"sha": "e64f1110c062f61746f222059439529a43ccf6dc", "node_id": "C_kwDOAAsO6NoAKGU2NGYxMTEwYzA2MmY2MTc0NmYyMjIwNTk0Mzk1MjlhNDNjY2Y2ZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T09:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T09:06:39Z"}, "message": "Auto merge of #103345 - Nilstrieb:diag-flat, r=compiler-errors\n\nFlatten diagnostic slug modules\n\nThis makes it easier to grep for the slugs in the code.\n\nSee https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Localization.20infra.20interferes.20with.20grepping.20for.20error for more discussion about it.\n\nThis was mostly done with a few regexes and a bunch of manual work. This also exposes a pretty annoying inconsistency for the extra labels. Some of the extra labels are defined as additional properties in the fluent message (which makes them not prefixed with the crate name) and some of them are new fluent messages themselves (which makes them prefixed with the crate name). I don't know whether we want to clean this up at some point but it's useful to know.\n\nr? `@davidtwco`", "tree": {"sha": "f6deb949a3796b6fd79eef0a3745e2d9dcc1ae8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6deb949a3796b6fd79eef0a3745e2d9dcc1ae8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64f1110c062f61746f222059439529a43ccf6dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64f1110c062f61746f222059439529a43ccf6dc", "html_url": "https://github.com/rust-lang/rust/commit/e64f1110c062f61746f222059439529a43ccf6dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64f1110c062f61746f222059439529a43ccf6dc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faab68eb29121f25b577b50e2e00e33bafc60a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/faab68eb29121f25b577b50e2e00e33bafc60a36", "html_url": "https://github.com/rust-lang/rust/commit/faab68eb29121f25b577b50e2e00e33bafc60a36"}, {"sha": "6987322445d7388b61d6249204402574ee0308f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6987322445d7388b61d6249204402574ee0308f5", "html_url": "https://github.com/rust-lang/rust/commit/6987322445d7388b61d6249204402574ee0308f5"}], "stats": {"total": 3360, "additions": 1666, "deletions": 1694}, "files": [{"sha": "157f46501e145eddc0c71f76c103cf6b53d33c1c", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n+#[diag(ast_lowering_generic_type_with_parentheses, code = \"E0214\")]\n pub struct GenericTypeWithParentheses {\n     #[primary_span]\n     #[label]\n@@ -13,7 +13,7 @@ pub struct GenericTypeWithParentheses {\n }\n \n #[derive(Clone, Copy, Subdiagnostic)]\n-#[multipart_suggestion(ast_lowering::use_angle_brackets, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(ast_lowering_use_angle_brackets, applicability = \"maybe-incorrect\")]\n pub struct UseAngleBrackets {\n     #[suggestion_part(code = \"<\")]\n     pub open_param: Span,\n@@ -22,7 +22,7 @@ pub struct UseAngleBrackets {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+#[diag(ast_lowering_invalid_abi, code = \"E0703\")]\n #[note]\n pub struct InvalidAbi {\n     #[primary_span]\n@@ -36,7 +36,7 @@ pub struct InvalidAbi {\n \n #[derive(Subdiagnostic)]\n #[suggestion(\n-    ast_lowering::invalid_abi_suggestion,\n+    ast_lowering_invalid_abi_suggestion,\n     code = \"{suggestion}\",\n     applicability = \"maybe-incorrect\"\n )]\n@@ -47,7 +47,7 @@ pub struct InvalidAbiSuggestion {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::assoc_ty_parentheses)]\n+#[diag(ast_lowering_assoc_ty_parentheses)]\n pub struct AssocTyParentheses {\n     #[primary_span]\n     pub span: Span,\n@@ -57,12 +57,12 @@ pub struct AssocTyParentheses {\n \n #[derive(Clone, Copy, Subdiagnostic)]\n pub enum AssocTyParenthesesSub {\n-    #[multipart_suggestion(ast_lowering::remove_parentheses)]\n+    #[multipart_suggestion(ast_lowering_remove_parentheses)]\n     Empty {\n         #[suggestion_part(code = \"\")]\n         parentheses_span: Span,\n     },\n-    #[multipart_suggestion(ast_lowering::use_angle_brackets)]\n+    #[multipart_suggestion(ast_lowering_use_angle_brackets)]\n     NotEmpty {\n         #[suggestion_part(code = \"<\")]\n         open_param: Span,\n@@ -72,99 +72,99 @@ pub enum AssocTyParenthesesSub {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n+#[diag(ast_lowering_misplaced_impl_trait, code = \"E0562\")]\n pub struct MisplacedImplTrait<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::rustc_box_attribute_error)]\n+#[diag(ast_lowering_rustc_box_attribute_error)]\n pub struct RustcBoxAttributeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::underscore_expr_lhs_assign)]\n+#[diag(ast_lowering_underscore_expr_lhs_assign)]\n pub struct UnderscoreExprLhsAssign {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::base_expression_double_dot)]\n+#[diag(ast_lowering_base_expression_double_dot)]\n pub struct BaseExpressionDoubleDot {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+#[diag(ast_lowering_await_only_in_async_fn_and_blocks, code = \"E0728\")]\n pub struct AwaitOnlyInAsyncFnAndBlocks {\n     #[primary_span]\n     #[label]\n     pub dot_await_span: Span,\n-    #[label(ast_lowering::this_not_async)]\n+    #[label(ast_lowering_this_not_async)]\n     pub item_span: Option<Span>,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n+#[diag(ast_lowering_generator_too_many_parameters, code = \"E0628\")]\n pub struct GeneratorTooManyParameters {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n+#[diag(ast_lowering_closure_cannot_be_static, code = \"E0697\")]\n pub struct ClosureCannotBeStatic {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n #[help]\n-#[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n+#[diag(ast_lowering_async_non_move_closure_not_supported, code = \"E0708\")]\n pub struct AsyncNonMoveClosureNotSupported {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n+#[diag(ast_lowering_functional_record_update_destructuring_assignment)]\n pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n+#[diag(ast_lowering_async_generators_not_supported, code = \"E0727\")]\n pub struct AsyncGeneratorsNotSupported {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+#[diag(ast_lowering_inline_asm_unsupported_target, code = \"E0472\")]\n pub struct InlineAsmUnsupportedTarget {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::att_syntax_only_x86)]\n+#[diag(ast_lowering_att_syntax_only_x86)]\n pub struct AttSyntaxOnlyX86 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::abi_specified_multiple_times)]\n+#[diag(ast_lowering_abi_specified_multiple_times)]\n pub struct AbiSpecifiedMultipleTimes {\n     #[primary_span]\n     pub abi_span: Span,\n@@ -176,23 +176,23 @@ pub struct AbiSpecifiedMultipleTimes {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::clobber_abi_not_supported)]\n+#[diag(ast_lowering_clobber_abi_not_supported)]\n pub struct ClobberAbiNotSupported {\n     #[primary_span]\n     pub abi_span: Span,\n }\n \n #[derive(Diagnostic)]\n #[note]\n-#[diag(ast_lowering::invalid_abi_clobber_abi)]\n+#[diag(ast_lowering_invalid_abi_clobber_abi)]\n pub struct InvalidAbiClobberAbi {\n     #[primary_span]\n     pub abi_span: Span,\n     pub supported_abis: String,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_register)]\n+#[diag(ast_lowering_invalid_register)]\n pub struct InvalidRegister<'a> {\n     #[primary_span]\n     pub op_span: Span,\n@@ -201,7 +201,7 @@ pub struct InvalidRegister<'a> {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_register_class)]\n+#[diag(ast_lowering_invalid_register_class)]\n pub struct InvalidRegisterClass<'a> {\n     #[primary_span]\n     pub op_span: Span,\n@@ -210,60 +210,60 @@ pub struct InvalidRegisterClass<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_reg_class)]\n pub struct InvalidAsmTemplateModifierRegClass {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n     #[subdiagnostic]\n     pub sub: InvalidAsmTemplateModifierRegClassSub,\n }\n \n #[derive(Subdiagnostic)]\n pub enum InvalidAsmTemplateModifierRegClassSub {\n-    #[note(ast_lowering::support_modifiers)]\n+    #[note(ast_lowering_support_modifiers)]\n     SupportModifier { class_name: Symbol, modifiers: String },\n-    #[note(ast_lowering::does_not_support_modifiers)]\n+    #[note(ast_lowering_does_not_support_modifiers)]\n     DoesNotSupportModifier { class_name: Symbol },\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_const)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_const)]\n pub struct InvalidAsmTemplateModifierConst {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_sym)]\n pub struct InvalidAsmTemplateModifierSym {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::register_class_only_clobber)]\n+#[diag(ast_lowering_register_class_only_clobber)]\n pub struct RegisterClassOnlyClobber {\n     #[primary_span]\n     pub op_span: Span,\n     pub reg_class_name: Symbol,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::register_conflict)]\n+#[diag(ast_lowering_register_conflict)]\n pub struct RegisterConflict<'a> {\n     #[primary_span]\n-    #[label(ast_lowering::register1)]\n+    #[label(ast_lowering_register1)]\n     pub op_span1: Span,\n-    #[label(ast_lowering::register2)]\n+    #[label(ast_lowering_register2)]\n     pub op_span2: Span,\n     pub reg1_name: &'a str,\n     pub reg2_name: &'a str,\n@@ -273,12 +273,12 @@ pub struct RegisterConflict<'a> {\n \n #[derive(Diagnostic, Clone, Copy)]\n #[help]\n-#[diag(ast_lowering::sub_tuple_binding)]\n+#[diag(ast_lowering_sub_tuple_binding)]\n pub struct SubTupleBinding<'a> {\n     #[primary_span]\n     #[label]\n     #[suggestion_verbose(\n-        ast_lowering::sub_tuple_binding_suggestion,\n+        ast_lowering_sub_tuple_binding_suggestion,\n         code = \"..\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -289,56 +289,56 @@ pub struct SubTupleBinding<'a> {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::extra_double_dot)]\n+#[diag(ast_lowering_extra_double_dot)]\n pub struct ExtraDoubleDot<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(ast_lowering::previously_used_here)]\n+    #[label(ast_lowering_previously_used_here)]\n     pub prev_span: Span,\n     pub ctx: &'a str,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n #[note]\n-#[diag(ast_lowering::misplaced_double_dot)]\n+#[diag(ast_lowering_misplaced_double_dot)]\n pub struct MisplacedDoubleDot {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::misplaced_relax_trait_bound)]\n+#[diag(ast_lowering_misplaced_relax_trait_bound)]\n pub struct MisplacedRelaxTraitBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n+#[diag(ast_lowering_not_supported_for_lifetime_binder_async_closure)]\n pub struct NotSupportedForLifetimeBinderAsyncClosure {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::arbitrary_expression_in_pattern)]\n+#[diag(ast_lowering_arbitrary_expression_in_pattern)]\n pub struct ArbitraryExpressionInPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::inclusive_range_with_no_end)]\n+#[diag(ast_lowering_inclusive_range_with_no_end)]\n pub struct InclusiveRangeWithNoEnd {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::trait_fn_async, code = \"E0706\")]\n+#[diag(ast_lowering_trait_fn_async, code = \"E0706\")]\n #[note]\n-#[note(ast_lowering::note2)]\n+#[note(note2)]\n pub struct TraitFnAsync {\n     #[primary_span]\n     pub fn_span: Span,"}, {"sha": "0366432440445e46e3f750aeddbd021aeff9a047", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -170,7 +170,7 @@ impl<'a> AstValidator<'a> {\n                 DEPRECATED_WHERE_CLAUSE_LOCATION,\n                 id,\n                 where_clauses.0.1,\n-                fluent::ast_passes::deprecated_where_clause_location,\n+                fluent::ast_passes_deprecated_where_clause_location,\n                 BuiltinLintDiagnostics::DeprecatedWhereclauseLocation(\n                     where_clauses.1.1.shrink_to_hi(),\n                     suggestion,\n@@ -1765,12 +1765,12 @@ pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator\n-    #[note(ast_passes::not_supported_or)]\n+    #[note(not_supported_or)]\n     NotSupportedOr(#[primary_span] Span),\n     /// A let chain with invalid parentheses\n     ///\n     /// For example, `let 1 = 1 && (expr && expr)` is allowed\n     /// but `(let 1 = 1 && (let 1 = 1 && (let 1 = 1))) && let a = 1` is not\n-    #[note(ast_passes::not_supported_parentheses)]\n+    #[note(not_supported_parentheses)]\n     NotSupportedParentheses(#[primary_span] Span),\n }"}, {"sha": "59f582f10d989be097f5f44eb6ad86827dfd8100", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -7,7 +7,7 @@ use rustc_span::{Span, Symbol};\n use crate::ast_validation::ForbiddenLetReason;\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_let)]\n+#[diag(ast_passes_forbidden_let)]\n #[note]\n pub struct ForbiddenLet {\n     #[primary_span]\n@@ -17,115 +17,115 @@ pub struct ForbiddenLet {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_let_stable)]\n+#[diag(ast_passes_forbidden_let_stable)]\n #[note]\n pub struct ForbiddenLetStable {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_assoc_constraint)]\n+#[diag(ast_passes_forbidden_assoc_constraint)]\n pub struct ForbiddenAssocConstraint {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::keyword_lifetime)]\n+#[diag(ast_passes_keyword_lifetime)]\n pub struct KeywordLifetime {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::invalid_label)]\n+#[diag(ast_passes_invalid_label)]\n pub struct InvalidLabel {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n+#[diag(ast_passes_invalid_visibility, code = \"E0449\")]\n pub struct InvalidVisibility {\n     #[primary_span]\n     pub span: Span,\n-    #[label(ast_passes::implied)]\n+    #[label(implied)]\n     pub implied: Option<Span>,\n     #[subdiagnostic]\n     pub note: Option<InvalidVisibilityNote>,\n }\n \n #[derive(Subdiagnostic)]\n pub enum InvalidVisibilityNote {\n-    #[note(ast_passes::individual_impl_items)]\n+    #[note(individual_impl_items)]\n     IndividualImplItems,\n-    #[note(ast_passes::individual_foreign_items)]\n+    #[note(individual_foreign_items)]\n     IndividualForeignItems,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n+#[diag(ast_passes_trait_fn_const, code = \"E0379\")]\n pub struct TraitFnConst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_lifetime_bound)]\n+#[diag(ast_passes_forbidden_lifetime_bound)]\n pub struct ForbiddenLifetimeBound {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_non_lifetime_param)]\n+#[diag(ast_passes_forbidden_non_lifetime_param)]\n pub struct ForbiddenNonLifetimeParam {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_too_many)]\n+#[diag(ast_passes_fn_param_too_many)]\n pub struct FnParamTooMany {\n     #[primary_span]\n     pub span: Span,\n     pub max_num_args: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_c_var_args_only)]\n+#[diag(ast_passes_fn_param_c_var_args_only)]\n pub struct FnParamCVarArgsOnly {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_c_var_args_not_last)]\n+#[diag(ast_passes_fn_param_c_var_args_not_last)]\n pub struct FnParamCVarArgsNotLast {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_doc_comment)]\n+#[diag(ast_passes_fn_param_doc_comment)]\n pub struct FnParamDocComment {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_forbidden_attr)]\n+#[diag(ast_passes_fn_param_forbidden_attr)]\n pub struct FnParamForbiddenAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_forbidden_self)]\n+#[diag(ast_passes_fn_param_forbidden_self)]\n #[note]\n pub struct FnParamForbiddenSelf {\n     #[primary_span]\n@@ -134,7 +134,7 @@ pub struct FnParamForbiddenSelf {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_default)]\n+#[diag(ast_passes_forbidden_default)]\n pub struct ForbiddenDefault {\n     #[primary_span]\n     pub span: Span,\n@@ -143,7 +143,7 @@ pub struct ForbiddenDefault {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_const_without_body)]\n+#[diag(ast_passes_assoc_const_without_body)]\n pub struct AssocConstWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -152,7 +152,7 @@ pub struct AssocConstWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_fn_without_body)]\n+#[diag(ast_passes_assoc_fn_without_body)]\n pub struct AssocFnWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -161,7 +161,7 @@ pub struct AssocFnWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_type_without_body)]\n+#[diag(ast_passes_assoc_type_without_body)]\n pub struct AssocTypeWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -170,7 +170,7 @@ pub struct AssocTypeWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::const_without_body)]\n+#[diag(ast_passes_const_without_body)]\n pub struct ConstWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -179,7 +179,7 @@ pub struct ConstWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::static_without_body)]\n+#[diag(ast_passes_static_without_body)]\n pub struct StaticWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -188,7 +188,7 @@ pub struct StaticWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::ty_alias_without_body)]\n+#[diag(ast_passes_ty_alias_without_body)]\n pub struct TyAliasWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -197,7 +197,7 @@ pub struct TyAliasWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_without_body)]\n+#[diag(ast_passes_fn_without_body)]\n pub struct FnWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -226,7 +226,7 @@ impl AddToDiagnostic for ExternBlockSuggestion {\n         let end_suggestion = \" }\".to_owned();\n \n         diag.multipart_suggestion(\n-            fluent::ast_passes::extern_block_suggestion,\n+            fluent::extern_block_suggestion,\n             vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "edccfa1c8ffa21f493a914323b419754fa093242", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -10,14 +10,14 @@ use rustc_span::{Span, Symbol};\n use crate::UnsupportedLiteralReason;\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n+#[diag(attr_expected_one_cfg_pattern, code = \"E0536\")]\n pub(crate) struct ExpectedOneCfgPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_predicate, code = \"E0537\")]\n+#[diag(attr_invalid_predicate, code = \"E0537\")]\n pub(crate) struct InvalidPredicate {\n     #[primary_span]\n     pub span: Span,\n@@ -26,7 +26,7 @@ pub(crate) struct InvalidPredicate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::multiple_item, code = \"E0538\")]\n+#[diag(attr_multiple_item, code = \"E0538\")]\n pub(crate) struct MultipleItem {\n     #[primary_span]\n     pub span: Span,\n@@ -35,7 +35,7 @@ pub(crate) struct MultipleItem {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_meta_item, code = \"E0539\")]\n+#[diag(attr_incorrect_meta_item, code = \"E0539\")]\n pub(crate) struct IncorrectMetaItem {\n     #[primary_span]\n     pub span: Span,\n@@ -54,39 +54,39 @@ impl<'a> IntoDiagnostic<'a> for UnknownMetaItem<'_> {\n         let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            fluent::attr::unknown_meta_item,\n+            fluent::attr_unknown_meta_item,\n             error_code!(E0541),\n         );\n         diag.set_arg(\"item\", self.item);\n         diag.set_arg(\"expected\", expected.join(\", \"));\n-        diag.span_label(self.span, fluent::attr::label);\n+        diag.span_label(self.span, fluent::label);\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_since, code = \"E0542\")]\n+#[diag(attr_missing_since, code = \"E0542\")]\n pub(crate) struct MissingSince {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_note, code = \"E0543\")]\n+#[diag(attr_missing_note, code = \"E0543\")]\n pub(crate) struct MissingNote {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::multiple_stability_levels, code = \"E0544\")]\n+#[diag(attr_multiple_stability_levels, code = \"E0544\")]\n pub(crate) struct MultipleStabilityLevels {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_issue_string, code = \"E0545\")]\n+#[diag(attr_invalid_issue_string, code = \"E0545\")]\n pub(crate) struct InvalidIssueString {\n     #[primary_span]\n     pub span: Span,\n@@ -99,31 +99,31 @@ pub(crate) struct InvalidIssueString {\n // translatable.\n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidIssueStringCause {\n-    #[label(attr::must_not_be_zero)]\n+    #[label(must_not_be_zero)]\n     MustNotBeZero {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::empty)]\n+    #[label(empty)]\n     Empty {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::invalid_digit)]\n+    #[label(invalid_digit)]\n     InvalidDigit {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::pos_overflow)]\n+    #[label(pos_overflow)]\n     PosOverflow {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::neg_overflow)]\n+    #[label(neg_overflow)]\n     NegOverflow {\n         #[primary_span]\n         span: Span,\n@@ -144,21 +144,21 @@ impl InvalidIssueStringCause {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_feature, code = \"E0546\")]\n+#[diag(attr_missing_feature, code = \"E0546\")]\n pub(crate) struct MissingFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::non_ident_feature, code = \"E0546\")]\n+#[diag(attr_non_ident_feature, code = \"E0546\")]\n pub(crate) struct NonIdentFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_issue, code = \"E0547\")]\n+#[diag(attr_missing_issue, code = \"E0547\")]\n pub(crate) struct MissingIssue {\n     #[primary_span]\n     pub span: Span,\n@@ -167,7 +167,7 @@ pub(crate) struct MissingIssue {\n // FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n // changing this to `IncorrectMetaItem`. See #51489.\n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_meta_item, code = \"E0551\")]\n+#[diag(attr_incorrect_meta_item, code = \"E0551\")]\n pub(crate) struct IncorrectMetaItem2 {\n     #[primary_span]\n     pub span: Span,\n@@ -176,14 +176,14 @@ pub(crate) struct IncorrectMetaItem2 {\n // FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n // It is more similar to `IncorrectReprFormatGeneric`.\n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n+#[diag(attr_incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n+#[diag(attr_invalid_repr_hint_no_paren, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoParen {\n     #[primary_span]\n     pub span: Span,\n@@ -192,7 +192,7 @@ pub(crate) struct InvalidReprHintNoParen {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n+#[diag(attr_invalid_repr_hint_no_value, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoValue {\n     #[primary_span]\n     pub span: Span,\n@@ -213,21 +213,21 @@ impl<'a> IntoDiagnostic<'a> for UnsupportedLiteral {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             match self.reason {\n-                UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n-                UnsupportedLiteralReason::CfgString => fluent::attr::unsupported_literal_cfg_string,\n+                UnsupportedLiteralReason::Generic => fluent::attr_unsupported_literal_generic,\n+                UnsupportedLiteralReason::CfgString => fluent::attr_unsupported_literal_cfg_string,\n                 UnsupportedLiteralReason::DeprecatedString => {\n-                    fluent::attr::unsupported_literal_deprecated_string\n+                    fluent::attr_unsupported_literal_deprecated_string\n                 }\n                 UnsupportedLiteralReason::DeprecatedKvPair => {\n-                    fluent::attr::unsupported_literal_deprecated_kv_pair\n+                    fluent::attr_unsupported_literal_deprecated_kv_pair\n                 }\n             },\n             error_code!(E0565),\n         );\n         if self.is_bytestr {\n             diag.span_suggestion(\n                 self.start_point_span,\n-                fluent::attr::unsupported_literal_suggestion,\n+                fluent::attr_unsupported_literal_suggestion,\n                 \"\",\n                 Applicability::MaybeIncorrect,\n             );\n@@ -237,15 +237,15 @@ impl<'a> IntoDiagnostic<'a> for UnsupportedLiteral {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n+#[diag(attr_invalid_repr_align_need_arg, code = \"E0589\")]\n pub(crate) struct InvalidReprAlignNeedArg {\n     #[primary_span]\n     #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_generic, code = \"E0589\")]\n+#[diag(attr_invalid_repr_generic, code = \"E0589\")]\n pub(crate) struct InvalidReprGeneric<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -255,14 +255,14 @@ pub(crate) struct InvalidReprGeneric<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n+#[diag(attr_incorrect_repr_format_align_one_arg, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatAlignOneArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n+#[diag(attr_incorrect_repr_format_generic, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatGeneric<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -275,7 +275,7 @@ pub(crate) struct IncorrectReprFormatGeneric<'a> {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n-    #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    #[suggestion(suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n     Int {\n         #[primary_span]\n         span: Span,\n@@ -287,11 +287,7 @@ pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n         int: u128,\n     },\n \n-    #[suggestion(\n-        attr::suggestion,\n-        code = \"{name}({symbol})\",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion(suggestion, code = \"{name}({symbol})\", applicability = \"machine-applicable\")]\n     Symbol {\n         #[primary_span]\n         span: Span,\n@@ -317,28 +313,28 @@ impl<'a> IncorrectReprFormatGenericCause<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n+#[diag(attr_rustc_promotable_pairing, code = \"E0717\")]\n pub(crate) struct RustcPromotablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n+#[diag(attr_rustc_allowed_unstable_pairing, code = \"E0789\")]\n pub(crate) struct RustcAllowedUnstablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::cfg_predicate_identifier)]\n+#[diag(attr_cfg_predicate_identifier)]\n pub(crate) struct CfgPredicateIdentifier {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::deprecated_item_suggestion)]\n+#[diag(attr_deprecated_item_suggestion)]\n pub(crate) struct DeprecatedItemSuggestion {\n     #[primary_span]\n     pub span: Span,\n@@ -351,21 +347,21 @@ pub(crate) struct DeprecatedItemSuggestion {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_single_version_literal)]\n+#[diag(attr_expected_single_version_literal)]\n pub(crate) struct ExpectedSingleVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_version_literal)]\n+#[diag(attr_expected_version_literal)]\n pub(crate) struct ExpectedVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expects_feature_list)]\n+#[diag(attr_expects_feature_list)]\n pub(crate) struct ExpectsFeatureList {\n     #[primary_span]\n     pub span: Span,\n@@ -374,7 +370,7 @@ pub(crate) struct ExpectsFeatureList {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expects_features)]\n+#[diag(attr_expects_features)]\n pub(crate) struct ExpectsFeatures {\n     #[primary_span]\n     pub span: Span,\n@@ -383,14 +379,14 @@ pub(crate) struct ExpectsFeatures {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::soft_no_args)]\n+#[diag(attr_soft_no_args)]\n pub(crate) struct SoftNoArgs {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::unknown_version_literal)]\n+#[diag(attr_unknown_version_literal)]\n pub(crate) struct UnknownVersionLiteral {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "cff3089c397cb8d16cc8a9597869519ef150230d", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -6,7 +6,7 @@ use rustc_span::Span;\n use crate::diagnostics::RegionName;\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::move_unsized, code = \"E0161\")]\n+#[diag(borrowck_move_unsized, code = \"E0161\")]\n pub(crate) struct MoveUnsized<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -15,7 +15,7 @@ pub(crate) struct MoveUnsized<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::higher_ranked_lifetime_error)]\n+#[diag(borrowck_higher_ranked_lifetime_error)]\n pub(crate) struct HigherRankedLifetimeError {\n     #[subdiagnostic]\n     pub cause: Option<HigherRankedErrorCause>,\n@@ -25,37 +25,37 @@ pub(crate) struct HigherRankedLifetimeError {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum HigherRankedErrorCause {\n-    #[note(borrowck::could_not_prove)]\n+    #[note(borrowck_could_not_prove)]\n     CouldNotProve { predicate: String },\n-    #[note(borrowck::could_not_normalize)]\n+    #[note(borrowck_could_not_normalize)]\n     CouldNotNormalize { value: String },\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::higher_ranked_subtype_error)]\n+#[diag(borrowck_higher_ranked_subtype_error)]\n pub(crate) struct HigherRankedSubtypeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::generic_does_not_live_long_enough)]\n+#[diag(borrowck_generic_does_not_live_long_enough)]\n pub(crate) struct GenericDoesNotLiveLongEnough {\n     pub kind: String,\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(borrowck::var_does_not_need_mut)]\n+#[diag(borrowck_var_does_not_need_mut)]\n pub(crate) struct VarNeedNotMut {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n #[derive(Diagnostic)]\n-#[diag(borrowck::var_cannot_escape_closure)]\n+#[diag(borrowck_var_cannot_escape_closure)]\n #[note]\n-#[note(borrowck::cannot_escape)]\n+#[note(cannot_escape)]\n pub(crate) struct FnMutError {\n     #[primary_span]\n     pub span: Span,\n@@ -65,17 +65,17 @@ pub(crate) struct FnMutError {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum VarHereDenote {\n-    #[label(borrowck::var_here_captured)]\n+    #[label(borrowck_var_here_captured)]\n     Captured {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::var_here_defined)]\n+    #[label(borrowck_var_here_defined)]\n     Defined {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::closure_inferred_mut)]\n+    #[label(borrowck_closure_inferred_mut)]\n     FnMutInferred {\n         #[primary_span]\n         span: Span,\n@@ -84,41 +84,41 @@ pub(crate) enum VarHereDenote {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum FnMutReturnTypeErr {\n-    #[label(borrowck::returned_closure_escaped)]\n+    #[label(borrowck_returned_closure_escaped)]\n     ReturnClosure {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::returned_async_block_escaped)]\n+    #[label(borrowck_returned_async_block_escaped)]\n     ReturnAsyncBlock {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::returned_ref_escaped)]\n+    #[label(borrowck_returned_ref_escaped)]\n     ReturnRef {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::lifetime_constraints_error)]\n+#[diag(borrowck_lifetime_constraints_error)]\n pub(crate) struct LifetimeOutliveErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Subdiagnostic)]\n pub(crate) enum LifetimeReturnCategoryErr<'a> {\n-    #[label(borrowck::returned_lifetime_wrong)]\n+    #[label(borrowck_returned_lifetime_wrong)]\n     WrongReturn {\n         #[primary_span]\n         span: Span,\n         mir_def_name: &'a str,\n         outlived_fr_name: RegionName,\n         fr_name: &'a RegionName,\n     },\n-    #[label(borrowck::returned_lifetime_short)]\n+    #[label(borrowck_returned_lifetime_short)]\n     ShortReturn {\n         #[primary_span]\n         span: Span,\n@@ -142,7 +142,7 @@ impl IntoDiagnosticArg for RegionName {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum RequireStaticErr {\n-    #[note(borrowck::used_impl_require_static)]\n+    #[note(borrowck_used_impl_require_static)]\n     UsedImpl {\n         #[primary_span]\n         multi_span: MultiSpan,"}, {"sha": "5638c2f6180cb8d29355b88bcb9c1559ce8b3921", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -36,15 +36,15 @@ pub fn expand_cfg(\n }\n \n #[derive(Diagnostic)]\n-#[diag(builtin_macros::requires_cfg_pattern)]\n+#[diag(builtin_macros_requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(builtin_macros::expected_one_cfg_pattern)]\n+#[diag(builtin_macros_expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]\n     span: Span,"}, {"sha": "15ad90f9043c0643f3fd34053c4210394c5f8b5a", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -17,7 +17,7 @@ impl IntoDiagnosticArg for ExitCode {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::ranlib_failure)]\n+#[diag(codegen_gcc_ranlib_failure)]\n pub(crate) struct RanlibFailure {\n     exit_code: ExitCode,\n }\n@@ -29,7 +29,7 @@ impl RanlibFailure {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -38,7 +38,7 @@ pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -48,7 +48,7 @@ pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_not_float, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -57,15 +57,15 @@ pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unrecognized, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnrecognized {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -75,7 +75,7 @@ pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_element, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -86,7 +86,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -97,7 +97,7 @@ pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -106,7 +106,7 @@ pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_simd, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -116,7 +116,7 @@ pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_mask_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -125,7 +125,7 @@ pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -136,7 +136,7 @@ pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -148,7 +148,7 @@ pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_element, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -160,7 +160,7 @@ pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -171,7 +171,7 @@ pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_inserted_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -182,7 +182,7 @@ pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -192,7 +192,7 @@ pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n     #[primary_span]\n     pub span: Span,\n@@ -202,7 +202,7 @@ pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -214,7 +214,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -224,18 +224,18 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::linkage_const_or_mut_type)]\n+#[diag(codegen_gcc_linkage_const_or_mut_type)]\n pub(crate) struct LinkageConstOrMutType {\n     #[primary_span]\n     pub span: Span\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::lto_not_supported)]\n+#[diag(codegen_gcc_lto_not_supported)]\n pub(crate) struct LTONotSupported;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::unwinding_inline_asm)]\n+#[diag(codegen_gcc_unwinding_inline_asm)]\n pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n     pub span: Span"}, {"sha": "6059e9f24ba8e555605f7303a9cc9b3bf587c31d", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -13,43 +13,43 @@ use std::path::{Path, PathBuf};\n use std::process::ExitStatus;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::lib_def_write_failure)]\n+#[diag(codegen_ssa_lib_def_write_failure)]\n pub struct LibDefWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::version_script_write_failure)]\n+#[diag(codegen_ssa_version_script_write_failure)]\n pub struct VersionScriptWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::symbol_file_write_failure)]\n+#[diag(codegen_ssa_symbol_file_write_failure)]\n pub struct SymbolFileWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ld64_unimplemented_modifier)]\n+#[diag(codegen_ssa_ld64_unimplemented_modifier)]\n pub struct Ld64UnimplementedModifier;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::linker_unsupported_modifier)]\n+#[diag(codegen_ssa_linker_unsupported_modifier)]\n pub struct LinkerUnsupportedModifier;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::L4Bender_exporting_symbols_unimplemented)]\n+#[diag(codegen_ssa_L4Bender_exporting_symbols_unimplemented)]\n pub struct L4BenderExportingSymbolsUnimplemented;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::no_natvis_directory)]\n+#[diag(codegen_ssa_no_natvis_directory)]\n pub struct NoNatvisDirectory {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::copy_path_buf)]\n+#[diag(codegen_ssa_copy_path_buf)]\n pub struct CopyPathBuf {\n     pub source_file: PathBuf,\n     pub output_path: PathBuf,\n@@ -58,7 +58,7 @@ pub struct CopyPathBuf {\n \n // Reports Paths using `Debug` implementation rather than Path's `Display` implementation.\n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::copy_path)]\n+#[diag(codegen_ssa_copy_path)]\n pub struct CopyPath<'a> {\n     from: DebugArgPath<'a>,\n     to: DebugArgPath<'a>,\n@@ -80,36 +80,36 @@ impl IntoDiagnosticArg for DebugArgPath<'_> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ignoring_emit_path)]\n+#[diag(codegen_ssa_ignoring_emit_path)]\n pub struct IgnoringEmitPath {\n     pub extension: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ignoring_output)]\n+#[diag(codegen_ssa_ignoring_output)]\n pub struct IgnoringOutput {\n     pub extension: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::create_temp_dir)]\n+#[diag(codegen_ssa_create_temp_dir)]\n pub struct CreateTempDir {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::incompatible_linking_modifiers)]\n+#[diag(codegen_ssa_incompatible_linking_modifiers)]\n pub struct IncompatibleLinkingModifiers;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::add_native_library)]\n+#[diag(codegen_ssa_add_native_library)]\n pub struct AddNativeLibrary {\n     pub library_path: PathBuf,\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::multiple_external_func_decl)]\n+#[diag(codegen_ssa_multiple_external_func_decl)]\n pub struct MultipleExternalFuncDecl<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -119,13 +119,13 @@ pub struct MultipleExternalFuncDecl<'a> {\n \n #[derive(Diagnostic)]\n pub enum LinkRlibError {\n-    #[diag(codegen_ssa::rlib_missing_format)]\n+    #[diag(codegen_ssa_rlib_missing_format)]\n     MissingFormat,\n \n-    #[diag(codegen_ssa::rlib_only_rmeta_found)]\n+    #[diag(codegen_ssa_rlib_only_rmeta_found)]\n     OnlyRmetaFound { crate_name: Symbol },\n \n-    #[diag(codegen_ssa::rlib_not_found)]\n+    #[diag(codegen_ssa_rlib_not_found)]\n     NotFound { crate_name: Symbol },\n }\n \n@@ -136,188 +136,188 @@ impl IntoDiagnostic<'_> for ThorinErrorWrapper {\n         let mut diag;\n         match self.0 {\n             thorin::Error::ReadInput(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_read_input_failure);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_read_input_failure);\n                 diag\n             }\n             thorin::Error::ParseFileKind(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_file_kind);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_file_kind);\n                 diag\n             }\n             thorin::Error::ParseObjectFile(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_object_file);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_object_file);\n                 diag\n             }\n             thorin::Error::ParseArchiveFile(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_archive_file);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_archive_file);\n                 diag\n             }\n             thorin::Error::ParseArchiveMember(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_archive_member);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_archive_member);\n                 diag\n             }\n             thorin::Error::InvalidInputKind => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_invalid_input_kind);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_invalid_input_kind);\n                 diag\n             }\n             thorin::Error::DecompressData(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_decompress_data);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_decompress_data);\n                 diag\n             }\n             thorin::Error::NamelessSection(_, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_without_name);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_section_without_name);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::RelocationWithInvalidSymbol(section, offset) => {\n                 diag =\n-                    handler.struct_err(fluent::codegen_ssa::thorin_relocation_with_invalid_symbol);\n+                    handler.struct_err(fluent::codegen_ssa_thorin_relocation_with_invalid_symbol);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::MultipleRelocations(section, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_relocations);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_relocations);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::UnsupportedRelocation(section, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_unsupported_relocation);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_unsupported_relocation);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::MissingDwoName(id) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_dwo_name);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_dwo_name);\n                 diag.set_arg(\"id\", format!(\"0x{:08x}\", id));\n                 diag\n             }\n             thorin::Error::NoCompilationUnits => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_compilation_units);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_no_compilation_units);\n                 diag\n             }\n             thorin::Error::NoDie => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_die);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_no_die);\n                 diag\n             }\n             thorin::Error::TopLevelDieNotUnit => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_top_level_die_not_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_top_level_die_not_unit);\n                 diag\n             }\n             thorin::Error::MissingRequiredSection(section) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_required_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_required_section);\n                 diag.set_arg(\"section\", section);\n                 diag\n             }\n             thorin::Error::ParseUnitAbbreviations(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_abbreviations);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_abbreviations);\n                 diag\n             }\n             thorin::Error::ParseUnitAttribute(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_attribute);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_attribute);\n                 diag\n             }\n             thorin::Error::ParseUnitHeader(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_header);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_header);\n                 diag\n             }\n             thorin::Error::ParseUnit(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit);\n                 diag\n             }\n             thorin::Error::IncompatibleIndexVersion(section, format, actual) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_incompatible_index_version);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_incompatible_index_version);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"actual\", actual);\n                 diag.set_arg(\"format\", format);\n                 diag\n             }\n             thorin::Error::OffsetAtIndex(_, index) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_offset_at_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_offset_at_index);\n                 diag.set_arg(\"index\", index);\n                 diag\n             }\n             thorin::Error::StrAtOffset(_, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_str_at_offset);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_str_at_offset);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::ParseIndex(_, section) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_index);\n                 diag.set_arg(\"section\", section);\n                 diag\n             }\n             thorin::Error::UnitNotInIndex(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_unit_not_in_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_unit_not_in_index);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::RowNotInIndex(_, row) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_row_not_in_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_row_not_in_index);\n                 diag.set_arg(\"row\", row);\n                 diag\n             }\n             thorin::Error::SectionNotInRow => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_not_in_row);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_section_not_in_row);\n                 diag\n             }\n             thorin::Error::EmptyUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_empty_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_empty_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::MultipleDebugInfoSection => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_info_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_debug_info_section);\n                 diag\n             }\n             thorin::Error::MultipleDebugTypesSection => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_types_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_debug_types_section);\n                 diag\n             }\n             thorin::Error::NotSplitUnit => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_split_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_not_split_unit);\n                 diag\n             }\n             thorin::Error::DuplicateUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_duplicate_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_duplicate_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::MissingReferencedUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_referenced_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_referenced_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::NoOutputObjectCreated => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_output_object_created);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_not_output_object_created);\n                 diag\n             }\n             thorin::Error::MixedInputEncodings => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_mixed_input_encodings);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_mixed_input_encodings);\n                 diag\n             }\n             thorin::Error::Io(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_io);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_io);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::ObjectRead(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_read);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_object_read);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::ObjectWrite(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_write);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_object_write);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::GimliRead(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_read);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_gimli_read);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::GimliWrite(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_write);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_gimli_write);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n@@ -335,7 +335,7 @@ pub struct LinkingFailed<'a> {\n \n impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::codegen_ssa::linking_failed);\n+        let mut diag = handler.struct_err(fluent::codegen_ssa_linking_failed);\n         diag.set_arg(\"linker_path\", format!(\"{}\", self.linker_path.display()));\n         diag.set_arg(\"exit_status\", format!(\"{}\", self.exit_status));\n \n@@ -344,9 +344,9 @@ impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n         // Trying to match an error from OS linkers\n         // which by now we have no way to translate.\n         if self.escaped_output.contains(\"undefined reference to\") {\n-            diag.note(fluent::codegen_ssa::extern_funcs_not_found)\n-                .note(fluent::codegen_ssa::specify_libraries_to_link)\n-                .note(fluent::codegen_ssa::use_cargo_directive);\n+            diag.note(fluent::codegen_ssa_extern_funcs_not_found)\n+                .note(fluent::codegen_ssa_specify_libraries_to_link)\n+                .note(fluent::codegen_ssa_use_cargo_directive);\n         }\n         diag\n     }"}, {"sha": "4b055076742b2f7e0ff60022806873c4f487f846", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,144 +3,144 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unstable_in_stable)]\n+#[diag(const_eval_unstable_in_stable)]\n pub(crate) struct UnstableInStable {\n     pub gate: String,\n     #[primary_span]\n     pub span: Span,\n     #[suggestion(\n-        const_eval::unstable_sugg,\n+        unstable_sugg,\n         code = \"#[rustc_const_unstable(feature = \\\"...\\\", issue = \\\"...\\\")]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n     #[suggestion(\n-        const_eval::bypass_sugg,\n+        bypass_sugg,\n         code = \"#[rustc_allow_const_fn_unstable({gate})]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::thread_local_access, code = \"E0625\")]\n+#[diag(const_eval_thread_local_access, code = \"E0625\")]\n pub(crate) struct NonConstOpErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::static_access, code = \"E0013\")]\n+#[diag(const_eval_static_access, code = \"E0013\")]\n #[help]\n pub(crate) struct StaticAccessErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n-    #[help(const_eval::teach_help)]\n+    #[note(teach_note)]\n+    #[help(teach_help)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::raw_ptr_to_int)]\n+#[diag(const_eval_raw_ptr_to_int)]\n #[note]\n-#[note(const_eval::note2)]\n+#[note(note2)]\n pub(crate) struct RawPtrToIntErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::raw_ptr_comparison)]\n+#[diag(const_eval_raw_ptr_comparison)]\n #[note]\n pub(crate) struct RawPtrComparisonErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::panic_non_str)]\n+#[diag(const_eval_panic_non_str)]\n pub(crate) struct PanicNonStrErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::mut_deref, code = \"E0658\")]\n+#[diag(const_eval_mut_deref, code = \"E0658\")]\n pub(crate) struct MutDerefErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::transient_mut_borrow, code = \"E0658\")]\n+#[diag(const_eval_transient_mut_borrow, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::transient_mut_borrow_raw, code = \"E0658\")]\n+#[diag(const_eval_transient_mut_borrow_raw, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErrRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::max_num_nodes_in_const)]\n+#[diag(const_eval_max_num_nodes_in_const)]\n pub(crate) struct MaxNumNodesInConstErr {\n     #[primary_span]\n     pub span: Span,\n     pub global_const_id: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_fn_pointer_call)]\n+#[diag(const_eval_unallowed_fn_pointer_call)]\n pub(crate) struct UnallowedFnPointerCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unstable_const_fn)]\n+#[diag(const_eval_unstable_const_fn)]\n pub(crate) struct UnstableConstFn {\n     #[primary_span]\n     pub span: Span,\n     pub def_path: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+#[diag(const_eval_unallowed_mutable_refs, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefs {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+#[diag(const_eval_unallowed_mutable_refs_raw, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefsRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n #[derive(Diagnostic)]\n-#[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+#[diag(const_eval_non_const_fmt_macro_call, code = \"E0015\")]\n pub(crate) struct NonConstFmtMacroCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n+#[diag(const_eval_non_const_fn_call, code = \"E0015\")]\n pub(crate) struct NonConstFnCall {\n     #[primary_span]\n     pub span: Span,\n@@ -149,47 +149,47 @@ pub(crate) struct NonConstFnCall {\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_op_in_const_context)]\n+#[diag(const_eval_unallowed_op_in_const_context)]\n pub(crate) struct UnallowedOpInConstContext {\n     #[primary_span]\n     pub span: Span,\n     pub msg: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+#[diag(const_eval_unallowed_heap_allocations, code = \"E0010\")]\n pub(crate) struct UnallowedHeapAllocations {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+#[diag(const_eval_unallowed_inline_asm, code = \"E0015\")]\n pub(crate) struct UnallowedInlineAsm {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+#[diag(const_eval_interior_mutable_data_refer, code = \"E0492\")]\n pub(crate) struct InteriorMutableDataRefer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     #[help]\n     pub opt_help: Option<()>,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::interior_mutability_borrow)]\n+#[diag(const_eval_interior_mutability_borrow)]\n pub(crate) struct InteriorMutabilityBorrow {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "c1bc10891144cf6ce07b5c1eea757d01d787288e", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -1,39 +1,39 @@\n use rustc_macros::Diagnostic;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_unable_to_read)]\n+#[diag(driver_rlink_unable_to_read)]\n pub(crate) struct RlinkUnableToRead {\n     pub err: std::io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_wrong_file_type)]\n+#[diag(driver_rlink_wrong_file_type)]\n pub(crate) struct RLinkWrongFileType;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_empty_version_number)]\n+#[diag(driver_rlink_empty_version_number)]\n pub(crate) struct RLinkEmptyVersionNumber;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_encoding_version_mismatch)]\n+#[diag(driver_rlink_encoding_version_mismatch)]\n pub(crate) struct RLinkEncodingVersionMismatch {\n     pub version_array: String,\n     pub rlink_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_rustc_version_mismatch)]\n+#[diag(driver_rlink_rustc_version_mismatch)]\n pub(crate) struct RLinkRustcVersionMismatch<'a> {\n     pub rustc_version: String,\n     pub current_version: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_no_a_file)]\n+#[diag(driver_rlink_no_a_file)]\n pub(crate) struct RlinkNotAFile;\n \n #[derive(Diagnostic)]\n-#[diag(driver::unpretty_dump_fail)]\n+#[diag(driver_unpretty_dump_fail)]\n pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,"}, {"sha": "7640b2919f78b6fc30339a666c8a27927b668ebe", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -175,45 +175,45 @@ impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n         let mut diag;\n         match self {\n             TargetDataLayoutErrors::InvalidAddressSpace { addr_space, err, cause } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_address_space);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_address_space);\n                 diag.set_arg(\"addr_space\", addr_space);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidBits { kind, bit, cause, err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_bits);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_bits);\n                 diag.set_arg(\"kind\", kind);\n                 diag.set_arg(\"bit\", bit);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::MissingAlignment { cause } => {\n-                diag = handler.struct_fatal(fluent::errors::target_missing_alignment);\n+                diag = handler.struct_fatal(fluent::errors_target_missing_alignment);\n                 diag.set_arg(\"cause\", cause);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_alignment);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_alignment);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {\n-                diag = handler.struct_fatal(fluent::errors::target_inconsistent_architecture);\n+                diag = handler.struct_fatal(fluent::errors_target_inconsistent_architecture);\n                 diag.set_arg(\"dl\", dl);\n                 diag.set_arg(\"target\", target);\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetPointerWidth { pointer_size, target } => {\n-                diag = handler.struct_fatal(fluent::errors::target_inconsistent_pointer_width);\n+                diag = handler.struct_fatal(fluent::errors_target_inconsistent_pointer_width);\n                 diag.set_arg(\"pointer_size\", pointer_size);\n                 diag.set_arg(\"target\", target);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidBitsSize { err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_bits_size);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_bits_size);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }"}, {"sha": "d383f4832f6999469ed43a96dbddd7d7a532b3a7", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,44 +3,44 @@ use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(expand::expr_repeat_no_syntax_vars)]\n+#[diag(expand_expr_repeat_no_syntax_vars)]\n pub(crate) struct NoSyntaxVarsExprRepeat {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::must_repeat_once)]\n+#[diag(expand_must_repeat_once)]\n pub(crate) struct MustRepeatOnce {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::count_repetition_misplaced)]\n+#[diag(expand_count_repetition_misplaced)]\n pub(crate) struct CountRepetitionMisplaced {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::meta_var_expr_unrecognized_var)]\n+#[diag(expand_meta_var_expr_unrecognized_var)]\n pub(crate) struct MetaVarExprUnrecognizedVar {\n     #[primary_span]\n     pub span: Span,\n     pub key: MacroRulesNormalizedIdent,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::var_still_repeating)]\n+#[diag(expand_var_still_repeating)]\n pub(crate) struct VarStillRepeating {\n     #[primary_span]\n     pub span: Span,\n     pub ident: MacroRulesNormalizedIdent,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::meta_var_dif_seq_matchers)]\n+#[diag(expand_meta_var_dif_seq_matchers)]\n pub(crate) struct MetaVarsDifSeqMatchers {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "1e268542bcd91ea5b308631a327953698c92ead6", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -598,12 +598,12 @@ pub fn compile_declarative_macro(\n \n #[derive(Subdiagnostic)]\n enum ExplainDocComment {\n-    #[label(expand::explain_doc_comment_inner)]\n+    #[label(expand_explain_doc_comment_inner)]\n     Inner {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(expand::explain_doc_comment_outer)]\n+    #[label(expand_explain_doc_comment_outer)]\n     Outer {\n         #[primary_span]\n         span: Span,"}, {"sha": "9457da32ce65a7c2b31d0510859851e257a42dd3", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::unrecognized_atomic_operation, code = \"E0092\")]\n+#[diag(hir_analysis_unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n     #[primary_span]\n     #[label]\n@@ -16,7 +16,7 @@ pub struct UnrecognizedAtomicOperation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n+#[diag(hir_analysis_wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n     #[primary_span]\n     #[label]\n@@ -27,7 +27,7 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::unrecognized_intrinsic_function, code = \"E0093\")]\n+#[diag(hir_analysis_unrecognized_intrinsic_function, code = \"E0093\")]\n pub struct UnrecognizedIntrinsicFunction {\n     #[primary_span]\n     #[label]\n@@ -36,85 +36,85 @@ pub struct UnrecognizedIntrinsicFunction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n+#[diag(hir_analysis_lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::generics_label)]\n+    #[label(generics_label)]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::drop_impl_on_wrong_item, code = \"E0120\")]\n+#[diag(hir_analysis_drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::field_already_declared, code = \"E0124\")]\n+#[diag(hir_analysis_field_already_declared, code = \"E0124\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::previous_decl_label)]\n+    #[label(previous_decl_label)]\n     pub prev_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::copy_impl_on_type_with_dtor, code = \"E0184\")]\n+#[diag(hir_analysis_copy_impl_on_type_with_dtor, code = \"E0184\")]\n pub struct CopyImplOnTypeWithDtor {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::multiple_relaxed_default_bounds, code = \"E0203\")]\n+#[diag(hir_analysis_multiple_relaxed_default_bounds, code = \"E0203\")]\n pub struct MultipleRelaxedDefaultBounds {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::copy_impl_on_non_adt, code = \"E0206\")]\n+#[diag(hir_analysis_copy_impl_on_non_adt, code = \"E0206\")]\n pub struct CopyImplOnNonAdt {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::trait_object_declared_with_no_traits, code = \"E0224\")]\n+#[diag(hir_analysis_trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label(hir_analysis::alias_span)]\n+    #[label(alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::ambiguous_lifetime_bound, code = \"E0227\")]\n+#[diag(hir_analysis_ambiguous_lifetime_bound, code = \"E0227\")]\n pub struct AmbiguousLifetimeBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::assoc_type_binding_not_allowed, code = \"E0229\")]\n+#[diag(hir_analysis_assoc_type_binding_not_allowed, code = \"E0229\")]\n pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::typeof_reserved_keyword_used, code = \"E0516\")]\n+#[diag(hir_analysis_typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -125,19 +125,19 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::value_of_associated_struct_already_specified, code = \"E0719\")]\n+#[diag(hir_analysis_value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::previous_bound_label)]\n+    #[label(previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::unconstrained_opaque_type)]\n+#[diag(hir_analysis_unconstrained_opaque_type)]\n #[note]\n pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n@@ -158,7 +158,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::hir_analysis::missing_type_params,\n+            rustc_errors::fluent::hir_analysis_missing_type_params,\n             error_code!(E0393),\n         );\n         err.set_arg(\"parameterCount\", self.missing_type_params.len());\n@@ -171,7 +171,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 .join(\", \"),\n         );\n \n-        err.span_label(self.def_span, rustc_errors::fluent::hir_analysis::label);\n+        err.span_label(self.def_span, rustc_errors::fluent::label);\n \n         let mut suggested = false;\n         // Don't suggest setting the type params if there are some already: the order is\n@@ -186,7 +186,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 // least we can clue them to the correct syntax `Iterator<Type>`.\n                 err.span_suggestion(\n                     self.span,\n-                    rustc_errors::fluent::hir_analysis::suggestion,\n+                    rustc_errors::fluent::suggestion,\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n@@ -202,16 +202,16 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n             }\n         }\n         if !suggested {\n-            err.span_label(self.span, rustc_errors::fluent::hir_analysis::no_suggestion_label);\n+            err.span_label(self.span, rustc_errors::fluent::no_suggestion_label);\n         }\n \n-        err.note(rustc_errors::fluent::hir_analysis::note);\n+        err.note(rustc_errors::fluent::note);\n         err\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::manual_implementation, code = \"E0183\")]\n+#[diag(hir_analysis_manual_implementation, code = \"E0183\")]\n #[help]\n pub struct ManualImplementation {\n     #[primary_span]\n@@ -221,21 +221,21 @@ pub struct ManualImplementation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::substs_on_overridden_impl)]\n+#[diag(hir_analysis_substs_on_overridden_impl)]\n pub struct SubstsOnOverriddenImpl {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(hir_analysis::unused_extern_crate)]\n+#[diag(hir_analysis_unused_extern_crate)]\n pub struct UnusedExternCrate {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(hir_analysis::extern_crate_not_idiomatic)]\n+#[diag(hir_analysis_extern_crate_not_idiomatic)]\n pub struct ExternCrateNotIdiomatic {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"{suggestion_code}\")]\n     pub span: Span,\n@@ -244,7 +244,7 @@ pub struct ExternCrateNotIdiomatic {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::expected_used_symbol)]\n+#[diag(hir_analysis_expected_used_symbol)]\n pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "175037f9b3a14791288ac72370bed988fc7afc2d", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -4,58 +4,58 @@ use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span};\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::field_multiply_specified_in_initializer, code = \"E0062\")]\n+#[diag(hir_analysis_field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::previous_use_label)]\n+    #[label(previous_use_label)]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::return_stmt_outside_of_fn_body, code = \"E0572\")]\n+#[diag(hir_analysis_return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n-    #[label(hir_analysis::encl_body_label)]\n+    #[label(encl_body_label)]\n     pub encl_body_span: Option<Span>,\n-    #[label(hir_analysis::encl_fn_label)]\n+    #[label(encl_fn_label)]\n     pub encl_fn_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::yield_expr_outside_of_generator, code = \"E0627\")]\n+#[diag(hir_analysis_yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::struct_expr_non_exhaustive, code = \"E0639\")]\n+#[diag(hir_analysis_struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::method_call_on_unknown_type, code = \"E0699\")]\n+#[diag(hir_analysis_method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::functional_record_update_on_non_struct, code = \"E0436\")]\n+#[diag(hir_analysis_functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::address_of_temporary_taken, code = \"E0745\")]\n+#[diag(hir_analysis_address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -65,7 +65,7 @@ pub struct AddressOfTemporaryTaken {\n #[derive(Subdiagnostic)]\n pub enum AddReturnTypeSuggestion {\n     #[suggestion(\n-        hir_analysis::add_return_type_add,\n+        hir_analysis_add_return_type_add,\n         code = \"-> {found} \",\n         applicability = \"machine-applicable\"\n     )]\n@@ -75,7 +75,7 @@ pub enum AddReturnTypeSuggestion {\n         found: String,\n     },\n     #[suggestion(\n-        hir_analysis::add_return_type_missing_here,\n+        hir_analysis_add_return_type_missing_here,\n         code = \"-> _ \",\n         applicability = \"has-placeholders\"\n     )]\n@@ -87,12 +87,12 @@ pub enum AddReturnTypeSuggestion {\n \n #[derive(Subdiagnostic)]\n pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(hir_analysis::expected_default_return_type)]\n+    #[label(hir_analysis_expected_default_return_type)]\n     Unit {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(hir_analysis::expected_return_type)]\n+    #[label(hir_analysis_expected_return_type)]\n     Other {\n         #[primary_span]\n         span: Span,\n@@ -101,21 +101,20 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::missing_parentheses_in_range, code = \"E0689\")]\n+#[diag(hir_analysis_missing_parentheses_in_range, code = \"E0689\")]\n pub struct MissingParentheseInRange {\n     #[primary_span]\n-    #[label(hir_analysis::missing_parentheses_in_range)]\n+    #[label(hir_analysis_missing_parentheses_in_range)]\n     pub span: Span,\n     pub ty_str: String,\n     pub method_name: String,\n-\n     #[subdiagnostic]\n     pub add_missing_parentheses: Option<AddMissingParenthesesInRange>,\n }\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion_verbose(\n-    hir_analysis::add_missing_parentheses_in_range,\n+    hir_analysis_add_missing_parentheses_in_range,\n     applicability = \"maybe-incorrect\"\n )]\n pub struct AddMissingParenthesesInRange {"}, {"sha": "2131d19068e50f25a00fa580e8e44383f7987a46", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -18,19 +18,19 @@ use crate::infer::error_reporting::{\n pub mod note_and_explain;\n \n #[derive(Diagnostic)]\n-#[diag(infer::opaque_hidden_type)]\n+#[diag(infer_opaque_hidden_type)]\n pub struct OpaqueHiddenTypeDiag {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[note(infer::opaque_type)]\n+    #[note(opaque_type)]\n     pub opaque_type: Span,\n-    #[note(infer::hidden_type)]\n+    #[note(hidden_type)]\n     pub hidden_type: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+#[diag(infer_type_annotations_needed, code = \"E0282\")]\n pub struct AnnotationRequired<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -48,7 +48,7 @@ pub struct AnnotationRequired<'a> {\n \n // Copy of `AnnotationRequired` for E0283\n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+#[diag(infer_type_annotations_needed, code = \"E0283\")]\n pub struct AmbigousImpl<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -66,7 +66,7 @@ pub struct AmbigousImpl<'a> {\n \n // Copy of `AnnotationRequired` for E0284\n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+#[diag(infer_type_annotations_needed, code = \"E0284\")]\n pub struct AmbigousReturn<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -83,7 +83,7 @@ pub struct AmbigousReturn<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+#[diag(infer_need_type_info_in_generator, code = \"E0698\")]\n pub struct NeedTypeInfoInGenerator<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -94,7 +94,7 @@ pub struct NeedTypeInfoInGenerator<'a> {\n \n // Used when a better one isn't available\n #[derive(Subdiagnostic)]\n-#[label(infer::label_bad)]\n+#[label(infer_label_bad)]\n pub struct InferenceBadError<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -110,7 +110,7 @@ pub struct InferenceBadError<'a> {\n #[derive(Subdiagnostic)]\n pub enum SourceKindSubdiag<'a> {\n     #[suggestion_verbose(\n-        infer::source_kind_subdiag_let,\n+        infer_source_kind_subdiag_let,\n         code = \": {type_name}\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -125,7 +125,7 @@ pub enum SourceKindSubdiag<'a> {\n         prefix: &'a str,\n         arg_name: String,\n     },\n-    #[label(infer::source_kind_subdiag_generic_label)]\n+    #[label(infer_source_kind_subdiag_generic_label)]\n     GenericLabel {\n         #[primary_span]\n         span: Span,\n@@ -136,7 +136,7 @@ pub enum SourceKindSubdiag<'a> {\n         parent_name: String,\n     },\n     #[suggestion_verbose(\n-        infer::source_kind_subdiag_generic_suggestion,\n+        infer_source_kind_subdiag_generic_suggestion,\n         code = \"::<{args}>\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -151,7 +151,7 @@ pub enum SourceKindSubdiag<'a> {\n #[derive(Subdiagnostic)]\n pub enum SourceKindMultiSuggestion<'a> {\n     #[multipart_suggestion_verbose(\n-        infer::source_kind_fully_qualified,\n+        infer_source_kind_fully_qualified,\n         applicability = \"has-placeholders\"\n     )]\n     FullyQualified {\n@@ -164,7 +164,7 @@ pub enum SourceKindMultiSuggestion<'a> {\n         successor_pos: &'a str,\n     },\n     #[multipart_suggestion_verbose(\n-        infer::source_kind_closure_return,\n+        infer_source_kind_closure_return,\n         applicability = \"has-placeholders\"\n     )]\n     ClosureReturn {\n@@ -260,7 +260,7 @@ impl AddToDiagnostic for RegionOriginNote<'_> {\n                 requirement,\n                 expected_found: Some((expected, found)),\n             } => {\n-                label_or_note(span, fluent::infer::subtype);\n+                label_or_note(span, fluent::infer_subtype);\n                 diag.set_arg(\"requirement\", requirement);\n \n                 diag.note_expected_found(&\"\", expected, &\"\", found);\n@@ -269,7 +269,7 @@ impl AddToDiagnostic for RegionOriginNote<'_> {\n                 // FIXME: this really should be handled at some earlier stage. Our\n                 // handling of region checking when type errors are present is\n                 // *terrible*.\n-                label_or_note(span, fluent::infer::subtype_2);\n+                label_or_note(span, fluent::infer_subtype_2);\n                 diag.set_arg(\"requirement\", requirement);\n             }\n         };\n@@ -300,9 +300,9 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n     {\n         match self {\n             LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n-                diag.span_label(param_span, fluent::infer::declared_different);\n-                diag.span_label(ret_span, fluent::infer::nothing);\n-                diag.span_label(span, fluent::infer::data_returned);\n+                diag.span_label(param_span, fluent::infer_declared_different);\n+                diag.span_label(ret_span, fluent::infer_nothing);\n+                diag.span_label(span, fluent::infer_data_returned);\n                 diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n                 diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n             }\n@@ -315,13 +315,13 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n                 sub: label_var2,\n             } => {\n                 if hir_equal {\n-                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n-                    diag.span_label(ty_sub, fluent::infer::nothing);\n-                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                    diag.span_label(ty_sup, fluent::infer_declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer_nothing);\n+                    diag.span_label(span, fluent::infer_data_lifetime_flow);\n                 } else {\n-                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n-                    diag.span_label(ty_sub, fluent::infer::nothing);\n-                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.span_label(ty_sup, fluent::infer_types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer_nothing);\n+                    diag.span_label(span, fluent::infer_data_flows);\n                     diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n                     diag.set_arg(\n                         \"label_var1\",\n@@ -419,21 +419,21 @@ impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n             }\n \n             diag.multipart_suggestion(\n-                fluent::infer::lifetime_param_suggestion,\n+                fluent::infer_lifetime_param_suggestion,\n                 suggestions,\n                 Applicability::MaybeIncorrect,\n             );\n             diag.set_arg(\"is_impl\", is_impl);\n             true\n         };\n         if mk_suggestion() && self.add_note {\n-            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+            diag.note(fluent::infer_lifetime_param_suggestion_elided);\n         }\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+#[diag(infer_lifetime_mismatch, code = \"E0623\")]\n pub struct LifetimeMismatch<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -454,32 +454,32 @@ impl AddToDiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n         self.unmet_requirements\n-            .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n-        diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n+            .push_span_label(self.binding_span, fluent::infer_msl_introduces_static);\n+        diag.span_note(self.unmet_requirements, fluent::infer_msl_unmet_req);\n     }\n }\n \n // FIXME(#100717): replace with a `Option<Span>` when subdiagnostic supports that\n #[derive(Subdiagnostic)]\n pub enum DoesNotOutliveStaticFromImpl {\n-    #[note(infer::does_not_outlive_static_from_impl)]\n+    #[note(infer_does_not_outlive_static_from_impl)]\n     Spanned {\n         #[primary_span]\n         span: Span,\n     },\n-    #[note(infer::does_not_outlive_static_from_impl)]\n+    #[note(infer_does_not_outlive_static_from_impl)]\n     Unspanned,\n }\n \n #[derive(Subdiagnostic)]\n pub enum ImplicitStaticLifetimeSubdiag {\n-    #[note(infer::implicit_static_lifetime_note)]\n+    #[note(infer_implicit_static_lifetime_note)]\n     Note {\n         #[primary_span]\n         span: Span,\n     },\n     #[suggestion_verbose(\n-        infer::implicit_static_lifetime_suggestion,\n+        infer_implicit_static_lifetime_suggestion,\n         code = \" + '_\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -490,7 +490,7 @@ pub enum ImplicitStaticLifetimeSubdiag {\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::mismatched_static_lifetime)]\n+#[diag(infer_mismatched_static_lifetime)]\n pub struct MismatchedStaticLifetime<'a> {\n     #[primary_span]\n     pub cause_span: Span,"}, {"sha": "6a29d85627a8446f4060bb4c63f6456321e7abcc", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -166,9 +166,9 @@ impl AddToDiagnostic for RegionExplanation<'_> {\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n         if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer::region_explanation);\n+            diag.span_note(span, fluent::infer_region_explanation);\n         } else {\n-            diag.note(fluent::infer::region_explanation);\n+            diag.note(fluent::infer_region_explanation);\n         }\n         self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -19,26 +19,27 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 expected_found: self.values_str(trace.values),\n             }\n             .add_to_diagnostic(err),\n-            infer::Reborrow(span) => RegionOriginNote::Plain { span, msg: fluent::infer::reborrow }\n-                .add_to_diagnostic(err),\n+            infer::Reborrow(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n+            }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::reborrow,\n+                    msg: fluent::infer_reborrow,\n                     name: &var_name.to_string(),\n                     continues: false,\n                 }\n                 .add_to_diagnostic(err);\n             }\n             infer::RelateObjectBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::relate_object_bound }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n                     .add_to_diagnostic(err);\n             }\n             infer::DataBorrowed(ty, span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::data_borrowed,\n+                    msg: fluent::infer_data_borrowed,\n                     name: &self.ty_to_string(ty),\n                     continues: false,\n                 }\n@@ -47,7 +48,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::reference_outlives_referent,\n+                    msg: fluent::infer_reference_outlives_referent,\n                     name: &self.ty_to_string(ty),\n                     continues: false,\n                 }\n@@ -56,22 +57,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::RelateParamBound(span, ty, opt_span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::relate_param_bound,\n+                    msg: fluent::infer_relate_param_bound,\n                     name: &self.ty_to_string(ty),\n                     continues: opt_span.is_some(),\n                 }\n                 .add_to_diagnostic(err);\n                 if let Some(span) = opt_span {\n-                    RegionOriginNote::Plain { span, msg: fluent::infer::relate_param_bound_2 }\n+                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n                         .add_to_diagnostic(err);\n                 }\n             }\n             infer::RelateRegionParamBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::relate_region_param_bound }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n                     .add_to_diagnostic(err);\n             }\n             infer::CompareImplItemObligation { span, .. } => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::compare_impl_item_obligation }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n                     .add_to_diagnostic(err);\n             }\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n@@ -80,7 +81,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::AscribeUserTypeProvePredicate(span) => {\n                 RegionOriginNote::Plain {\n                     span,\n-                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n                 }\n                 .add_to_diagnostic(err);\n             }"}, {"sha": "f5135c78dc8313c32dfea0a77e564ece5f972c1f", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -5,7 +5,7 @@ use std::io;\n use std::path::Path;\n \n #[derive(Diagnostic)]\n-#[diag(interface::ferris_identifier)]\n+#[diag(interface_ferris_identifier)]\n pub struct FerrisIdentifier {\n     #[primary_span]\n     pub spans: Vec<Span>,\n@@ -14,75 +14,75 @@ pub struct FerrisIdentifier {\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::emoji_identifier)]\n+#[diag(interface_emoji_identifier)]\n pub struct EmojiIdentifier {\n     #[primary_span]\n     pub spans: Vec<Span>,\n     pub ident: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::mixed_bin_crate)]\n+#[diag(interface_mixed_bin_crate)]\n pub struct MixedBinCrate;\n \n #[derive(Diagnostic)]\n-#[diag(interface::mixed_proc_macro_crate)]\n+#[diag(interface_mixed_proc_macro_crate)]\n pub struct MixedProcMacroCrate;\n \n #[derive(Diagnostic)]\n-#[diag(interface::proc_macro_doc_without_arg)]\n+#[diag(interface_proc_macro_doc_without_arg)]\n pub struct ProcMacroDocWithoutArg;\n \n #[derive(Diagnostic)]\n-#[diag(interface::error_writing_dependencies)]\n+#[diag(interface_error_writing_dependencies)]\n pub struct ErrorWritingDependencies<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::input_file_would_be_overwritten)]\n+#[diag(interface_input_file_would_be_overwritten)]\n pub struct InputFileWouldBeOverWritten<'a> {\n     pub path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::generated_file_conflicts_with_directory)]\n+#[diag(interface_generated_file_conflicts_with_directory)]\n pub struct GeneratedFileConflictsWithDirectory<'a> {\n     pub input_path: &'a Path,\n     pub dir_path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::temps_dir_error)]\n+#[diag(interface_temps_dir_error)]\n pub struct TempsDirError;\n \n #[derive(Diagnostic)]\n-#[diag(interface::out_dir_error)]\n+#[diag(interface_out_dir_error)]\n pub struct OutDirError;\n \n #[derive(Diagnostic)]\n-#[diag(interface::cant_emit_mir)]\n+#[diag(interface_cant_emit_mir)]\n pub struct CantEmitMIR {\n     pub error: io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::rustc_error_fatal)]\n+#[diag(interface_rustc_error_fatal)]\n pub struct RustcErrorFatal {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::rustc_error_unexpected_annotation)]\n+#[diag(interface_rustc_error_unexpected_annotation)]\n pub struct RustcErrorUnexpectedAnnotation {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::failed_writing_file)]\n+#[diag(interface_failed_writing_file)]\n pub struct FailedWritingFile<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,"}, {"sha": "abebc533cc17ba6f9b0c13865b3ffe405e92d1af", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -121,25 +121,25 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             cx.struct_span_lint(\n                 ARRAY_INTO_ITER,\n                 call.ident.span,\n-                fluent::lint::array_into_iter,\n+                fluent::lint_array_into_iter,\n                 |diag| {\n                     diag.set_arg(\"target\", target);\n                     diag.span_suggestion(\n                         call.ident.span,\n-                        fluent::lint::use_iter_suggestion,\n+                        fluent::use_iter_suggestion,\n                         \"iter\",\n                         Applicability::MachineApplicable,\n                     );\n                     if self.for_expr_span == expr.span {\n                         diag.span_suggestion(\n                             receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                            fluent::lint::remove_into_iter_suggestion,\n+                            fluent::remove_into_iter_suggestion,\n                             \"\",\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else if receiver_ty.is_array() {\n                         diag.multipart_suggestion(\n-                            fluent::lint::use_explicit_into_iter_suggestion,\n+                            fluent::use_explicit_into_iter_suggestion,\n                             vec![\n                                 (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n                                 ("}, {"sha": "27f8cc0a655ab8c8ecac79b03e09b107e480b92b", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 73, "deletions": 87, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -106,11 +106,11 @@ impl EarlyLintPass for WhileTrue {\n             cx.struct_span_lint(\n                             WHILE_TRUE,\n                             condition_span,\n-                fluent::lint::builtin_while_true,\n+                fluent::lint_builtin_while_true,\n                             |lint| {\n                     lint.span_suggestion_short(\n                         condition_span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         format!(\n                             \"{}loop\",\n                             label.map_or_else(String::new, |label| format!(\n@@ -160,7 +160,7 @@ impl BoxPointers {\n                     cx.struct_span_lint(\n                         BOX_POINTERS,\n                         span,\n-                        fluent::lint::builtin_box_pointers,\n+                        fluent::lint_builtin_box_pointers,\n                         |lint| lint.set_arg(\"ty\", ty),\n                     );\n                 }\n@@ -264,13 +264,13 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                         cx.struct_span_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            fluent::lint::builtin_non_shorthand_field_patterns,\n+                            fluent::lint_builtin_non_shorthand_field_patterns,\n                             |lint| {\n                                 let suggested_ident =\n                                     format!(\"{}{}\", binding_annot.prefix_str(), ident);\n                                 lint.set_arg(\"ident\", ident.clone()).span_suggestion(\n                                     fieldpat.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     suggested_ident,\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -335,7 +335,7 @@ impl UnsafeCode {\n         msg: DiagnosticMessage,\n     ) {\n         self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint::builtin_overridden_symbol_name)\n+            lint.note(fluent::lint_builtin_overridden_symbol_name)\n         })\n     }\n \n@@ -346,64 +346,61 @@ impl UnsafeCode {\n         msg: DiagnosticMessage,\n     ) {\n         self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint::builtin_overridden_symbol_section)\n+            lint.note(fluent::lint_builtin_overridden_symbol_section)\n         })\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(\n-                cx,\n-                attr.span,\n-                fluent::lint::builtin_allow_internal_unsafe,\n-                |lint| lint,\n-            );\n+            self.report_unsafe(cx, attr.span, fluent::lint_builtin_allow_internal_unsafe, |lint| {\n+                lint\n+            });\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, fluent::lint::builtin_unsafe_block, |lint| lint);\n+                self.report_unsafe(cx, blk.span, fluent::lint_builtin_unsafe_block, |lint| lint);\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_trait, |lint| lint)\n+                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_trait, |lint| lint)\n             }\n \n             ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_impl, |lint| lint)\n+                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_impl, |lint| lint)\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_no_mangle_fn,\n+                        fluent::lint_builtin_no_mangle_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_export_name_fn,\n+                        fluent::lint_builtin_export_name_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_link_section_fn,\n+                        fluent::lint_builtin_link_section_fn,\n                     );\n                 }\n             }\n@@ -413,23 +410,23 @@ impl EarlyLintPass for UnsafeCode {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_no_mangle_static,\n+                        fluent::lint_builtin_no_mangle_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_export_name_static,\n+                        fluent::lint_builtin_export_name_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_link_section_static,\n+                        fluent::lint_builtin_link_section_static,\n                     );\n                 }\n             }\n@@ -444,14 +441,14 @@ impl EarlyLintPass for UnsafeCode {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    fluent::lint::builtin_no_mangle_method,\n+                    fluent::lint_builtin_no_mangle_method,\n                 );\n             }\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    fluent::lint::builtin_export_name_method,\n+                    fluent::lint_builtin_export_name_method,\n                 );\n             }\n         }\n@@ -469,9 +466,9 @@ impl EarlyLintPass for UnsafeCode {\n         {\n             let msg = match ctxt {\n                 FnCtxt::Foreign => return,\n-                FnCtxt::Free => fluent::lint::builtin_decl_unsafe_fn,\n-                FnCtxt::Assoc(_) if body.is_none() => fluent::lint::builtin_decl_unsafe_method,\n-                FnCtxt::Assoc(_) => fluent::lint::builtin_impl_unsafe_method,\n+                FnCtxt::Free => fluent::lint_builtin_decl_unsafe_fn,\n+                FnCtxt::Assoc(_) if body.is_none() => fluent::lint_builtin_decl_unsafe_method,\n+                FnCtxt::Assoc(_) => fluent::lint_builtin_impl_unsafe_method,\n             };\n             self.report_unsafe(cx, span, msg, |lint| lint);\n         }\n@@ -577,7 +574,7 @@ impl MissingDoc {\n             cx.struct_span_lint(\n                 MISSING_DOCS,\n                 cx.tcx.def_span(def_id),\n-                fluent::lint::builtin_missing_doc,\n+                fluent::lint_builtin_missing_doc,\n                 |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n             );\n         }\n@@ -769,7 +766,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             cx.struct_span_lint(\n                 MISSING_COPY_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint::builtin_missing_copy_impl,\n+                fluent::lint_builtin_missing_copy_impl,\n                 |lint| lint,\n             )\n         }\n@@ -848,7 +845,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             cx.struct_span_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint::builtin_missing_debug_impl,\n+                fluent::lint_builtin_missing_debug_impl,\n                 |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n             );\n         }\n@@ -928,11 +925,11 @@ impl EarlyLintPass for AnonymousParameters {\n                         cx.struct_span_lint(\n                             ANONYMOUS_PARAMETERS,\n                             arg.pat.span,\n-                            fluent::lint::builtin_anonymous_params,\n+                            fluent::lint_builtin_anonymous_params,\n                             |lint| {\n                                 lint.span_suggestion(\n                                     arg.pat.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"_: {}\", ty_snip),\n                                     appl,\n                                 )\n@@ -976,15 +973,15 @@ impl EarlyLintPass for DeprecatedAttr {\n                     cx.struct_span_lint(\n                         DEPRECATED,\n                         attr.span,\n-                        fluent::lint::builtin_deprecated_attr_link,\n+                        fluent::lint_builtin_deprecated_attr_link,\n                         |lint| {\n                             lint.set_arg(\"name\", name)\n                                 .set_arg(\"reason\", reason)\n                                 .set_arg(\"link\", link)\n                                 .span_suggestion_short(\n                                     attr.span,\n                                     suggestion.map(|s| s.into()).unwrap_or(\n-                                        fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                                        fluent::lint_builtin_deprecated_attr_default_suggestion,\n                                     ),\n                                     \"\",\n                                     Applicability::MachineApplicable,\n@@ -999,12 +996,12 @@ impl EarlyLintPass for DeprecatedAttr {\n             cx.struct_span_lint(\n                 DEPRECATED,\n                 attr.span,\n-                fluent::lint::builtin_deprecated_attr_used,\n+                fluent::lint_builtin_deprecated_attr_used,\n                 |lint| {\n                     lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n                         .span_suggestion_short(\n                             attr.span,\n-                            fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                            fluent::lint_builtin_deprecated_attr_default_suggestion,\n                             \"\",\n                             Applicability::MachineApplicable,\n                         )\n@@ -1039,14 +1036,14 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n             cx.struct_span_lint(\n                 UNUSED_DOC_COMMENTS,\n                 span,\n-                fluent::lint::builtin_unused_doc_comment,\n+                fluent::lint_builtin_unused_doc_comment,\n                 |lint| {\n-                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::lint::label).help(\n+                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::label).help(\n                         match attr.kind {\n                             AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                                fluent::lint::plain_help\n+                                fluent::plain_help\n                             }\n-                            AttrKind::DocComment(CommentKind::Block, _) => fluent::lint::block_help,\n+                            AttrKind::DocComment(CommentKind::Block, _) => fluent::block_help,\n                         },\n                     )\n                 },\n@@ -1167,11 +1164,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                         cx.struct_span_lint(\n                             NO_MANGLE_GENERIC_ITEMS,\n                             span,\n-                            fluent::lint::builtin_no_mangle_generic,\n+                            fluent::lint_builtin_no_mangle_generic,\n                             |lint| {\n                                 lint.span_suggestion_short(\n                                     no_mangle_attr.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     \"\",\n                                     // Use of `#[no_mangle]` suggests FFI intent; correct\n                                     // fix may be to monomorphize source by hand\n@@ -1197,7 +1194,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                     cx.struct_span_lint(\n                         NO_MANGLE_CONST_ITEMS,\n                         it.span,\n-                        fluent::lint::builtin_const_no_mangle,\n+                        fluent::lint_builtin_const_no_mangle,\n                         |lint| {\n                             // account for \"pub const\" (#45562)\n                             let start = cx\n@@ -1211,7 +1208,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n                             lint.span_suggestion(\n                                 const_span,\n-                                fluent::lint::suggestion,\n+                                fluent::suggestion,\n                                 \"pub static\",\n                                 Applicability::MachineApplicable,\n                             )\n@@ -1279,7 +1276,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n                 cx.struct_span_lint(\n                     MUTABLE_TRANSMUTES,\n                     expr.span,\n-                    fluent::lint::builtin_mutable_transmutes,\n+                    fluent::lint_builtin_mutable_transmutes,\n                     |lint| lint,\n                 );\n             }\n@@ -1332,7 +1329,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n                     cx.struct_span_lint(\n                         UNSTABLE_FEATURES,\n                         item.span(),\n-                        fluent::lint::builtin_unstable_features,\n+                        fluent::lint_builtin_unstable_features,\n                         |lint| lint,\n                     );\n                 }\n@@ -1396,18 +1393,13 @@ impl UnreachablePub {\n             cx.struct_span_lint(\n                 UNREACHABLE_PUB,\n                 def_span,\n-                fluent::lint::builtin_unreachable_pub,\n+                fluent::lint_builtin_unreachable_pub,\n                 |lint| {\n                     lint.set_arg(\"what\", what);\n \n-                    lint.span_suggestion(\n-                        vis_span,\n-                        fluent::lint::suggestion,\n-                        \"pub(crate)\",\n-                        applicability,\n-                    );\n+                    lint.span_suggestion(vis_span, fluent::suggestion, \"pub(crate)\", applicability);\n                     if exportable {\n-                        lint.help(fluent::lint::help);\n+                        lint.help(fluent::help);\n                     }\n                     lint\n                 },\n@@ -1498,7 +1490,7 @@ impl TypeAliasBounds {\n         impl Visitor<'_> for WalkAssocTypes<'_> {\n             fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(span, fluent::lint::builtin_type_alias_bounds_help);\n+                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n                 }\n                 intravisit::walk_qpath(self, qpath, id)\n             }\n@@ -1541,11 +1533,11 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_where_clause, |lint| {\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_where_clause, |lint| {\n                 lint.set_span(where_spans);\n                 lint.span_suggestion(\n                     type_alias_generics.where_clause_span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n@@ -1558,10 +1550,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_generic_bounds, |lint| {\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_generic_bounds, |lint| {\n                 lint.set_span(inline_spans);\n                 lint.multipart_suggestion(\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     inline_sugg,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1670,7 +1662,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     cx.struct_span_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        fluent::lint::builtin_trivial_bounds,\n+                        fluent::lint_builtin_trivial_bounds,\n                         |lint| {\n                             lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n                                 .set_arg(\"predicate\", predicate)\n@@ -1775,8 +1767,8 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = fluent::lint::builtin_ellipsis_inclusive_range_patterns;\n-            let suggestion = fluent::lint::suggestion;\n+            let msg = fluent::lint_builtin_ellipsis_inclusive_range_patterns;\n+            let suggestion = fluent::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1899,7 +1891,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             cx.struct_span_lint(\n                 UNNAMEABLE_TEST_ITEMS,\n                 attr.span,\n-                fluent::lint::builtin_unnameable_test_items,\n+                fluent::lint_builtin_unnameable_test_items,\n                 |lint| lint,\n             );\n         }\n@@ -2020,11 +2012,11 @@ impl KeywordIdents {\n         cx.struct_span_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            fluent::lint::builtin_keyword_idents,\n+            fluent::lint_builtin_keyword_idents,\n             |lint| {\n                 lint.set_arg(\"kw\", ident.clone()).set_arg(\"next\", next_edition).span_suggestion(\n                     ident.span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     format!(\"r#{}\", ident),\n                     Applicability::MachineApplicable,\n                 )\n@@ -2283,10 +2275,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    fluent::lint::builtin_explicit_outlives,\n+                    fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             lint_spans\n                                 .into_iter()\n                                 .map(|span| (span, String::new()))\n@@ -2344,17 +2336,17 @@ impl EarlyLintPass for IncompleteFeatures {\n                 cx.struct_span_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    fluent::lint::builtin_incomplete_features,\n+                    fluent::lint_builtin_incomplete_features,\n                     |lint| {\n                         lint.set_arg(\"name\", name);\n                         if let Some(n) =\n                             rustc_feature::find_feature_issue(name, GateIssue::Language)\n                         {\n                             lint.set_arg(\"n\", n);\n-                            lint.note(fluent::lint::note);\n+                            lint.note(fluent::note);\n                         }\n                         if HAS_MIN_FEATURES.contains(&name) {\n-                            lint.help(fluent::lint::help);\n+                            lint.help(fluent::help);\n                         }\n                         lint\n                     },\n@@ -3015,9 +3007,9 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     // Finally, emit the diagnostic.\n \n                     let msg = if orig.get_name() == this_fi.ident.name {\n-                        fluent::lint::builtin_clashing_extern_same_name\n+                        fluent::lint_builtin_clashing_extern_same_name\n                     } else {\n-                        fluent::lint::builtin_clashing_extern_diff_name\n+                        fluent::lint_builtin_clashing_extern_diff_name\n                     };\n                     tcx.struct_span_lint_hir(\n                         CLASHING_EXTERN_DECLARATIONS,\n@@ -3032,14 +3024,8 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n \n                             lint.set_arg(\"this_fi\", this_fi.ident.name)\n                                 .set_arg(\"orig\", orig.get_name())\n-                                .span_label(\n-                                    get_relevant_span(orig_fi),\n-                                    fluent::lint::previous_decl_label,\n-                                )\n-                                .span_label(\n-                                    get_relevant_span(this_fi),\n-                                    fluent::lint::mismatch_label,\n-                                )\n+                                .span_label(get_relevant_span(orig_fi), fluent::previous_decl_label)\n+                                .span_label(get_relevant_span(this_fi), fluent::mismatch_label)\n                                 // FIXME(davidtwco): translatable expected/found\n                                 .note_expected_found(&\"\", expected_str, &\"\", found_str)\n                         },\n@@ -3125,8 +3111,8 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n                 cx.struct_span_lint(\n                     DEREF_NULLPTR,\n                     expr.span,\n-                    fluent::lint::builtin_deref_nullptr,\n-                    |lint| lint.span_label(expr.span, fluent::lint::label),\n+                    fluent::lint_builtin_deref_nullptr,\n+                    |lint| lint.span_label(expr.span, fluent::label),\n                 );\n             }\n         }\n@@ -3238,7 +3224,7 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                     cx.lookup_with_diagnostics(\n                             NAMED_ASM_LABELS,\n                             Some(target_spans),\n-                            fluent::lint::builtin_asm_labels,\n+                            fluent::lint_builtin_asm_labels,\n                             |lint| lint,\n                             BuiltinLintDiagnostics::NamedAsmLabel(\n                                 \"only local labels of the form `<number>:` should be used in inline asm\"\n@@ -3341,8 +3327,8 @@ impl EarlyLintPass for UnexpectedCfgs {\n                     cx.lookup(\n                         UNEXPECTED_CFGS,\n                         None::<MultiSpan>,\n-                        fluent::lint::builtin_unexpected_cli_config_name,\n-                        |diag| diag.help(fluent::lint::help).set_arg(\"name\", name),\n+                        fluent::lint_builtin_unexpected_cli_config_name,\n+                        |diag| diag.help(fluent::help).set_arg(\"name\", name),\n                     );\n                 }\n             }\n@@ -3352,9 +3338,9 @@ impl EarlyLintPass for UnexpectedCfgs {\n                         cx.lookup(\n                             UNEXPECTED_CFGS,\n                             None::<MultiSpan>,\n-                            fluent::lint::builtin_unexpected_cli_config_value,\n+                            fluent::lint_builtin_unexpected_cli_config_value,\n                             |diag| {\n-                                diag.help(fluent::lint::help)\n+                                diag.help(fluent::help)\n                                     .set_arg(\"name\", name)\n                                     .set_arg(\"value\", value)\n                             },"}, {"sha": "f9d7466228ad1fef85711256ceabd2cecc8b12dd", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -53,8 +53,8 @@ fn enforce_mem_discriminant(\n         cx.struct_span_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             expr_span,\n-            fluent::lint::enum_intrinsics_mem_discriminant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::lint::note),\n+            fluent::lint_enum_intrinsics_mem_discriminant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::note),\n         );\n     }\n }\n@@ -65,8 +65,8 @@ fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, sp\n         cx.struct_span_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             span,\n-            fluent::lint::enum_intrinsics_mem_variant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::lint::note),\n+            fluent::lint_enum_intrinsics_mem_variant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::note),\n         );\n     }\n }"}, {"sha": "a49d1bdacc25b087f200cbae6f7f4efe7fb50e4b", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -7,7 +7,7 @@ use rustc_session::lint::Level;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(lint::overruled_attribute, code = \"E0453\")]\n+#[diag(lint_overruled_attribute, code = \"E0453\")]\n pub struct OverruledAttribute {\n     #[primary_span]\n     pub span: Span,\n@@ -32,24 +32,24 @@ impl AddToDiagnostic for OverruledAttributeSub {\n     {\n         match self {\n             OverruledAttributeSub::DefaultSource { id } => {\n-                diag.note(fluent::lint::default_source);\n+                diag.note(fluent::lint_default_source);\n                 diag.set_arg(\"id\", id);\n             }\n             OverruledAttributeSub::NodeSource { span, reason } => {\n-                diag.span_label(span, fluent::lint::node_source);\n+                diag.span_label(span, fluent::lint_node_source);\n                 if let Some(rationale) = reason {\n                     diag.note(rationale.as_str());\n                 }\n             }\n             OverruledAttributeSub::CommandLineSource => {\n-                diag.note(fluent::lint::command_line_source);\n+                diag.note(fluent::lint_command_line_source);\n             }\n         }\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::malformed_attribute, code = \"E0452\")]\n+#[diag(lint_malformed_attribute, code = \"E0452\")]\n pub struct MalformedAttribute {\n     #[primary_span]\n     pub span: Span,\n@@ -59,16 +59,16 @@ pub struct MalformedAttribute {\n \n #[derive(Subdiagnostic)]\n pub enum MalformedAttributeSub {\n-    #[label(lint::bad_attribute_argument)]\n+    #[label(lint_bad_attribute_argument)]\n     BadAttributeArgument(#[primary_span] Span),\n-    #[label(lint::reason_must_be_string_literal)]\n+    #[label(lint_reason_must_be_string_literal)]\n     ReasonMustBeStringLiteral(#[primary_span] Span),\n-    #[label(lint::reason_must_come_last)]\n+    #[label(lint_reason_must_come_last)]\n     ReasonMustComeLast(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::unknown_tool_in_scoped_lint, code = \"E0710\")]\n+#[diag(lint_unknown_tool_in_scoped_lint, code = \"E0710\")]\n pub struct UnknownToolInScopedLint {\n     #[primary_span]\n     pub span: Option<Span>,\n@@ -79,7 +79,7 @@ pub struct UnknownToolInScopedLint {\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::builtin_ellipsis_inclusive_range_patterns, code = \"E0783\")]\n+#[diag(lint_builtin_ellipsis_inclusive_range_patterns, code = \"E0783\")]\n pub struct BuiltinEllpisisInclusiveRangePatterns {\n     #[primary_span]\n     pub span: Span,\n@@ -89,14 +89,14 @@ pub struct BuiltinEllpisisInclusiveRangePatterns {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(lint::requested_level)]\n+#[note(lint_requested_level)]\n pub struct RequestedLevel {\n     pub level: Level,\n     pub lint_name: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::unsupported_group, code = \"E0602\")]\n+#[diag(lint_unsupported_group, code = \"E0602\")]\n pub struct UnsupportedGroup {\n     pub lint_group: String,\n }\n@@ -112,10 +112,10 @@ impl IntoDiagnostic<'_> for CheckNameUnknown {\n         self,\n         handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::lint::check_name_unknown);\n+        let mut diag = handler.struct_err(fluent::lint_check_name_unknown);\n         diag.code(rustc_errors::error_code!(E0602));\n         if let Some(suggestion) = self.suggestion {\n-            diag.help(fluent::lint::help);\n+            diag.help(fluent::help);\n             diag.set_arg(\"suggestion\", suggestion);\n         }\n         diag.set_arg(\"lint_name\", self.lint_name);\n@@ -125,23 +125,23 @@ impl IntoDiagnostic<'_> for CheckNameUnknown {\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_unknown_tool, code = \"E0602\")]\n+#[diag(lint_check_name_unknown_tool, code = \"E0602\")]\n pub struct CheckNameUnknownTool {\n     pub tool_name: Symbol,\n     #[subdiagnostic]\n     pub sub: RequestedLevel,\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_warning)]\n+#[diag(lint_check_name_warning)]\n pub struct CheckNameWarning {\n     pub msg: String,\n     #[subdiagnostic]\n     pub sub: RequestedLevel,\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_deprecated)]\n+#[diag(lint_check_name_deprecated)]\n pub struct CheckNameDeprecated {\n     pub lint_name: String,\n     pub new_name: String,"}, {"sha": "cf8f31bcbd0650780b9374bed416b0cb9c9f95ce", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -45,14 +45,14 @@ fn emit_unfulfilled_expectation_lint(\n         builtin::UNFULFILLED_LINT_EXPECTATIONS,\n         hir_id,\n         expectation.emission_span,\n-        fluent::lint::expectation,\n+        fluent::lint_expectation,\n         |lint| {\n             if let Some(rationale) = expectation.reason {\n                 lint.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {\n-                lint.note(fluent::lint::note);\n+                lint.note(fluent::note);\n             }\n \n             lint"}, {"sha": "7e884e990ce35b084efa388271cb40d4bccf4491", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -63,26 +63,26 @@ impl HiddenUnicodeCodepoints {\n         cx.struct_span_lint(\n             TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n             span,\n-            fluent::lint::hidden_unicode_codepoints,\n+            fluent::lint_hidden_unicode_codepoints,\n             |lint| {\n                 lint.set_arg(\"label\", label);\n                 lint.set_arg(\"count\", spans.len());\n-                lint.span_label(span, fluent::lint::label);\n-                lint.note(fluent::lint::note);\n+                lint.span_label(span, fluent::label);\n+                lint.note(fluent::note);\n                 if point_at_inner_spans {\n                     for (c, span) in &spans {\n                         lint.span_label(*span, format!(\"{:?}\", c));\n                     }\n                 }\n                 if point_at_inner_spans && !spans.is_empty() {\n                     lint.multipart_suggestion_with_style(\n-                        fluent::lint::suggestion_remove,\n+                        fluent::suggestion_remove,\n                         spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n                         Applicability::MachineApplicable,\n                         SuggestionStyle::HideCodeAlways,\n                     );\n                     lint.multipart_suggestion(\n-                        fluent::lint::suggestion_escape,\n+                        fluent::suggestion_escape,\n                         spans\n                             .into_iter()\n                             .map(|(c, span)| {\n@@ -104,8 +104,8 @@ impl HiddenUnicodeCodepoints {\n                             .collect::<Vec<String>>()\n                             .join(\", \"),\n                     );\n-                    lint.note(fluent::lint::suggestion_remove);\n-                    lint.note(fluent::lint::no_suggestion_note_escape);\n+                    lint.note(fluent::suggestion_remove);\n+                    lint.note(fluent::no_suggestion_note_escape);\n                 }\n                 lint\n             },"}, {"sha": "11e4650cb4b644f0072fc640077f986cb98bde43", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -37,11 +37,11 @@ impl LateLintPass<'_> for DefaultHashTypes {\n         cx.struct_span_lint(\n             DEFAULT_HASH_TYPES,\n             path.span,\n-            fluent::lint::default_hash_types,\n+            fluent::lint_default_hash_types,\n             |lint| {\n                 lint.set_arg(\"preferred\", replace)\n                     .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                    .note(fluent::lint::note)\n+                    .note(fluent::note)\n             },\n         );\n     }\n@@ -86,8 +86,8 @@ impl LateLintPass<'_> for QueryStability {\n                 cx.struct_span_lint(\n                     POTENTIAL_QUERY_INSTABILITY,\n                     span,\n-                    fluent::lint::query_instability,\n-                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::lint::note),\n+                    fluent::lint_query_instability,\n+                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::note),\n                 )\n             }\n         }\n@@ -126,11 +126,11 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint::tykind_kind, |lint| {\n+            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint_tykind_kind, |lint| {\n                 lint\n                     .span_suggestion(\n                         span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"ty\",\n                         Applicability::MaybeIncorrect, // ty maybe needs an import\n                     )\n@@ -193,10 +193,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                             cx.struct_span_lint(\n                                 USAGE_OF_TY_TYKIND,\n                                 path.span,\n-                                fluent::lint::tykind_kind,\n+                                fluent::lint_tykind_kind,\n                                 |lint| lint.span_suggestion(\n                                     span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     \"ty\",\n                                     Applicability::MaybeIncorrect, // ty maybe needs an import\n                                 )\n@@ -205,18 +205,18 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                         None => cx.struct_span_lint(\n                             USAGE_OF_TY_TYKIND,\n                             path.span,\n-                            fluent::lint::tykind,\n-                            |lint| lint.help(fluent::lint::help)\n+                            fluent::lint_tykind,\n+                            |lint| lint.help(fluent::help)\n                         )\n                     }\n                 } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n                     if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint::ty_qualified, |lint| {\n+                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint_ty_qualified, |lint| {\n                             lint\n                                 .set_arg(\"ty\", t.clone())\n                                 .span_suggestion(\n                                     path.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     t,\n                                     // The import probably needs to be changed\n                                     Applicability::MaybeIncorrect,\n@@ -310,8 +310,8 @@ impl EarlyLintPass for LintPassImpl {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            fluent::lint::lintpass_by_hand,\n-                            |lint| lint.help(fluent::lint::help),\n+                            fluent::lint_lintpass_by_hand,\n+                            |lint| lint.help(fluent::help),\n                         )\n                     }\n                 }\n@@ -351,8 +351,8 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n                         cx.struct_span_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            fluent::lint::non_existant_doc_keyword,\n-                            |lint| lint.set_arg(\"keyword\", v).help(fluent::lint::help),\n+                            fluent::lint_non_existant_doc_keyword,\n+                            |lint| lint.set_arg(\"keyword\", v).help(fluent::help),\n                         );\n                     }\n                 }\n@@ -414,7 +414,7 @@ impl LateLintPass<'_> for Diagnostics {\n             cx.struct_span_lint(\n                 DIAGNOSTIC_OUTSIDE_OF_IMPL,\n                 span,\n-                fluent::lint::diag_out_of_impl,\n+                fluent::lint_diag_out_of_impl,\n                 |lint| lint,\n             )\n         }\n@@ -435,7 +435,7 @@ impl LateLintPass<'_> for Diagnostics {\n             cx.struct_span_lint(\n                 UNTRANSLATABLE_DIAGNOSTIC,\n                 span,\n-                fluent::lint::untranslatable_diag,\n+                fluent::lint_untranslatable_diag,\n                 |lint| lint,\n             )\n         }"}, {"sha": "e2d7d5b49f69358bdd9dcf179dbfcdac80f1fcdb", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -93,12 +93,12 @@ fn lint_cstring_as_ptr(\n                     cx.struct_span_lint(\n                         TEMPORARY_CSTRING_AS_PTR,\n                         as_ptr_span,\n-                        fluent::lint::cstring_ptr,\n+                        fluent::lint_cstring_ptr,\n                         |diag| {\n-                            diag.span_label(as_ptr_span, fluent::lint::as_ptr_label)\n-                                .span_label(unwrap.span, fluent::lint::unwrap_label)\n-                                .note(fluent::lint::note)\n-                                .help(fluent::lint::help)\n+                            diag.span_label(as_ptr_span, fluent::as_ptr_label)\n+                                .span_label(unwrap.span, fluent::unwrap_label)\n+                                .note(fluent::note)\n+                                .help(fluent::help)\n                         },\n                     );\n                 }"}, {"sha": "dea9506acb200fcec3e4a02afdcd857cf64007e1", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -183,7 +183,7 @@ impl EarlyLintPass for NonAsciiIdents {\n             cx.struct_span_lint(\n                 NON_ASCII_IDENTS,\n                 sp,\n-                fluent::lint::identifier_non_ascii_char,\n+                fluent::lint_identifier_non_ascii_char,\n                 |lint| lint,\n             );\n             if check_uncommon_codepoints\n@@ -192,7 +192,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                 cx.struct_span_lint(\n                     UNCOMMON_CODEPOINTS,\n                     sp,\n-                    fluent::lint::identifier_uncommon_codepoints,\n+                    fluent::lint_identifier_uncommon_codepoints,\n                     |lint| lint,\n                 )\n             }\n@@ -225,11 +225,11 @@ impl EarlyLintPass for NonAsciiIdents {\n                             cx.struct_span_lint(\n                                 CONFUSABLE_IDENTS,\n                                 sp,\n-                                fluent::lint::confusable_identifier_pair,\n+                                fluent::lint_confusable_identifier_pair,\n                                 |lint| {\n                                     lint.set_arg(\"existing_sym\", *existing_symbol)\n                                         .set_arg(\"sym\", symbol)\n-                                        .span_label(*existing_span, fluent::lint::label)\n+                                        .span_label(*existing_span, fluent::label)\n                                 },\n                             );\n                         }\n@@ -334,7 +334,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                     cx.struct_span_lint(\n                         MIXED_SCRIPT_CONFUSABLES,\n                         sp,\n-                        fluent::lint::mixed_script_confusables,\n+                        fluent::lint_mixed_script_confusables,\n                         |lint| {\n                             let mut includes = String::new();\n                             for (idx, ch) in ch_list.into_iter().enumerate() {\n@@ -346,8 +346,8 @@ impl EarlyLintPass for NonAsciiIdents {\n                             }\n                             lint.set_arg(\"set\", script_set.to_string())\n                                 .set_arg(\"includes\", includes)\n-                                .note(fluent::lint::includes_note)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::includes_note)\n+                                .note(fluent::note)\n                         },\n                     );\n                 }"}, {"sha": "6ad2e0294b9b0af0774f81ed9422479c691e2a0a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -119,20 +119,20 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         arg_span = expn.call_site;\n     }\n \n-    cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint::non_fmt_panic, |lint| {\n+    cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint_non_fmt_panic, |lint| {\n         lint.set_arg(\"name\", symbol);\n-        lint.note(fluent::lint::note);\n-        lint.note(fluent::lint::more_info_note);\n+        lint.note(fluent::note);\n+        lint.note(fluent::more_info_note);\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n             return lint;\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            lint.note(fluent::lint::supports_fmt_note);\n+            lint.note(fluent::supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 lint.multipart_suggestion(\n-                    fluent::lint::supports_fmt_suggestion,\n+                    fluent::supports_fmt_suggestion,\n                     vec![\n                         (arg_span.until(open.shrink_to_hi()), \"\".into()),\n                         (close.until(arg_span.shrink_to_hi()), \"\".into()),\n@@ -178,15 +178,15 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             if suggest_display {\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::lint::display_suggestion,\n+                    fluent::display_suggestion,\n                     \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n                 lint.set_arg(\"ty\", ty);\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::lint::debug_suggestion,\n+                    fluent::debug_suggestion,\n                     \"\\\"{:?}\\\", \",\n                     fmt_applicability,\n                 );\n@@ -196,7 +196,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 if let Some((open, close, del)) = find_delimiters(cx, span) {\n                     lint.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n                     lint.multipart_suggestion(\n-                        fluent::lint::panic_suggestion,\n+                        fluent::panic_suggestion,\n                         if del == '(' {\n                             vec![(span.until(open), \"std::panic::panic_any\".into())]\n                         } else {\n@@ -254,30 +254,25 @@ fn check_panic_str<'tcx>(\n                 .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n                 .collect(),\n         };\n-        cx.struct_span_lint(\n-            NON_FMT_PANICS,\n-            arg_spans,\n-            fluent::lint::non_fmt_panic_unused,\n-            |lint| {\n-                lint.set_arg(\"count\", n_arguments);\n-                lint.note(fluent::lint::note);\n-                if is_arg_inside_call(arg.span, span) {\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_hi(),\n-                        fluent::lint::add_args_suggestion,\n-                        \", ...\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_lo(),\n-                        fluent::lint::add_fmt_suggestion,\n-                        \"\\\"{}\\\", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                lint\n-            },\n-        );\n+        cx.struct_span_lint(NON_FMT_PANICS, arg_spans, fluent::lint_non_fmt_panic_unused, |lint| {\n+            lint.set_arg(\"count\", n_arguments);\n+            lint.note(fluent::note);\n+            if is_arg_inside_call(arg.span, span) {\n+                lint.span_suggestion(\n+                    arg.span.shrink_to_hi(),\n+                    fluent::add_args_suggestion,\n+                    \", ...\",\n+                    Applicability::HasPlaceholders,\n+                );\n+                lint.span_suggestion(\n+                    arg.span.shrink_to_lo(),\n+                    fluent::add_fmt_suggestion,\n+                    \"\\\"{}\\\", \",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            lint\n+        });\n     } else {\n         let brace_spans: Option<Vec<_>> =\n             snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n@@ -290,14 +285,14 @@ fn check_panic_str<'tcx>(\n         cx.struct_span_lint(\n             NON_FMT_PANICS,\n             brace_spans.unwrap_or_else(|| vec![span]),\n-            fluent::lint::non_fmt_panic_braces,\n+            fluent::lint_non_fmt_panic_braces,\n             |lint| {\n                 lint.set_arg(\"count\", count);\n-                lint.note(fluent::lint::note);\n+                lint.note(fluent::note);\n                 if is_arg_inside_call(arg.span, span) {\n                     lint.span_suggestion(\n                         arg.span.shrink_to_lo(),\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"\\\"{}\\\", \",\n                         Applicability::MachineApplicable,\n                     );"}, {"sha": "7e50801f80c7bbbf6797b8aa84224ff84dc61b18", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -139,20 +139,20 @@ impl NonCamelCaseTypes {\n             cx.struct_span_lint(\n                 NON_CAMEL_CASE_TYPES,\n                 ident.span,\n-                fluent::lint::non_camel_case_type,\n+                fluent::lint_non_camel_case_type,\n                 |lint| {\n                     let cc = to_camel_case(name);\n                     // We cannot provide meaningful suggestions\n                     // if the characters are in the category of \"Lowercase Letter\".\n                     if *name != cc {\n                         lint.span_suggestion(\n                             ident.span,\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             to_camel_case(name),\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.span_label(ident.span, fluent::lint::label);\n+                        lint.span_label(ident.span, fluent::label);\n                     }\n \n                     lint.set_arg(\"sort\", sort);\n@@ -284,7 +284,7 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint::non_snake_case, |lint| {\n+            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint_non_snake_case, |lint| {\n                 let sc = NonSnakeCase::to_snake_case(name);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Uppercase Letter\".\n@@ -298,13 +298,13 @@ impl NonSnakeCase {\n                             // Instead, recommend renaming the identifier entirely or, if permitted,\n                             // escaping it to create a raw identifier.\n                             if sc_ident.name.can_be_raw() {\n-                                (fluent::lint::rename_or_convert_suggestion, sc_ident.to_string())\n+                                (fluent::rename_or_convert_suggestion, sc_ident.to_string())\n                             } else {\n-                                lint.note(fluent::lint::cannot_convert_note);\n-                                (fluent::lint::rename_suggestion, String::new())\n+                                lint.note(fluent::cannot_convert_note);\n+                                (fluent::rename_suggestion, String::new())\n                             }\n                         } else {\n-                            (fluent::lint::convert_suggestion, sc.clone())\n+                            (fluent::convert_suggestion, sc.clone())\n                         };\n \n                         lint.span_suggestion(\n@@ -314,10 +314,10 @@ impl NonSnakeCase {\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.help(fluent::lint::help);\n+                        lint.help(fluent::help);\n                     }\n                 } else {\n-                    lint.span_label(ident.span, fluent::lint::label);\n+                    lint.span_label(ident.span, fluent::label);\n                 }\n \n                 lint.set_arg(\"sort\", sort);\n@@ -484,20 +484,20 @@ impl NonUpperCaseGlobals {\n             cx.struct_span_lint(\n                 NON_UPPER_CASE_GLOBALS,\n                 ident.span,\n-                fluent::lint::non_upper_case_global,\n+                fluent::lint_non_upper_case_global,\n                 |lint| {\n                     let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n                     // We cannot provide meaningful suggestions\n                     // if the characters are in the category of \"Lowercase Letter\".\n                     if *name != uc {\n                         lint.span_suggestion(\n                             ident.span,\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             uc,\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.span_label(ident.span, fluent::lint::label);\n+                        lint.span_label(ident.span, fluent::label);\n                     }\n \n                     lint.set_arg(\"sort\", sort);"}, {"sha": "2ef425a1093121532b516076b83accf15cfc6bc1", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -85,11 +85,11 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let expr_span = expr.span;\n         let span = expr_span.with_lo(receiver.span.hi());\n-        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint::noop_method_call, |lint| {\n+        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint_noop_method_call, |lint| {\n             lint.set_arg(\"method\", call.ident.name)\n                 .set_arg(\"receiver_ty\", receiver_ty)\n-                .span_label(span, fluent::lint::label)\n-                .note(fluent::lint::note)\n+                .span_label(span, fluent::label)\n+                .note(fluent::note)\n         });\n     }\n }"}, {"sha": "7f6f4a0abb4a55413b9dd58b21a1da5d28748d92", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -139,19 +139,19 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(lint::opaque_hidden_inferred_bound)]\n+#[diag(lint_opaque_hidden_inferred_bound)]\n struct OpaqueHiddenInferredBoundLint<'tcx> {\n     ty: Ty<'tcx>,\n     proj_ty: Ty<'tcx>,\n-    #[label(lint::specifically)]\n+    #[label(specifically)]\n     assoc_pred_span: Span,\n     #[subdiagnostic]\n     add_bound: Option<AddBound<'tcx>>,\n }\n \n #[derive(Subdiagnostic)]\n #[suggestion_verbose(\n-    lint::opaque_hidden_inferred_bound_sugg,\n+    lint_opaque_hidden_inferred_bound_sugg,\n     applicability = \"machine-applicable\",\n     code = \" + {trait_ref}\"\n )]"}, {"sha": "01bface718a7802843c08e71a1969272b98a7b56", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -32,11 +32,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     cx.struct_span_lint(\n                         PASS_BY_VALUE,\n                         ty.span,\n-                        fluent::lint::pass_by_value,\n+                        fluent::lint_pass_by_value,\n                         |lint| {\n                             lint.set_arg(\"ty\", t.clone()).span_suggestion(\n                                 ty.span,\n-                                fluent::lint::suggestion,\n+                                fluent::suggestion,\n                                 t,\n                                 // Changing type of function argument\n                                 Applicability::MaybeIncorrect,"}, {"sha": "3521de7fc08483dcfb48de8d44764b1ad4481dfa", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -51,11 +51,11 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n         cx.struct_span_lint(\n             REDUNDANT_SEMICOLONS,\n             span,\n-            fluent::lint::redundant_semicolons,\n+            fluent::lint_redundant_semicolons,\n             |lint| {\n                 lint.set_arg(\"multiple\", multiple).span_suggestion(\n                     span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     \"\",\n                     Applicability::MaybeIncorrect,\n                 )"}, {"sha": "a118dda8b40f16d6e4f5fab2ff064e2d8f8f6b4d", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                 cx.struct_span_lint(\n                     DROP_BOUNDS,\n                     span,\n-                    fluent::lint::drop_trait_constraints,\n+                    fluent::lint_drop_trait_constraints,\n                     |lint| {\n                         lint.set_arg(\"predicate\", predicate)\n                             .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n@@ -125,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n             if cx.tcx.lang_items().drop_trait() == def_id\n                 && let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop)\n             {\n-                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint::drop_glue, |lint| {\n+                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint_drop_glue, |lint| {\n                     lint.set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n                 });\n             }"}, {"sha": "7c99bb2790fd0705fb551e355b84e6263107a8c1", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -151,7 +151,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     cx.struct_span_lint(\n         OVERFLOWING_LITERALS,\n         struct_expr.span,\n-        fluent::lint::range_endpoint_out_of_range,\n+        fluent::lint_range_endpoint_out_of_range,\n         |lint| {\n             use ast::{LitIntType, LitKind};\n \n@@ -168,7 +168,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n             let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n             lint.span_suggestion(\n                 struct_expr.span,\n-                fluent::lint::suggestion,\n+                fluent::suggestion,\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n@@ -233,7 +233,7 @@ fn report_bin_hex_error(\n     cx.struct_span_lint(\n         OVERFLOWING_LITERALS,\n         expr.span,\n-        fluent::lint::overflowing_bin_hex,\n+        fluent::lint_overflowing_bin_hex,\n         |lint| {\n             let (t, actually) = match ty {\n                 attr::IntType::SignedInt(t) => {\n@@ -253,10 +253,10 @@ fn report_bin_hex_error(\n             if negative {\n                 // If the value is negative,\n                 // emits a note about the value itself, apart from the literal.\n-                lint.note(fluent::lint::negative_note);\n-                lint.note(fluent::lint::negative_becomes_note);\n+                lint.note(fluent::negative_note);\n+                lint.note(fluent::negative_becomes_note);\n             } else {\n-                lint.note(fluent::lint::positive_note);\n+                lint.note(fluent::positive_note);\n             }\n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n@@ -266,12 +266,12 @@ fn report_bin_hex_error(\n                     let (sans_suffix, _) = repr_str.split_at(pos);\n                     lint.span_suggestion(\n                         expr.span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         format!(\"{}{}\", sans_suffix, sugg_ty),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    lint.help(fluent::lint::help);\n+                    lint.help(fluent::help);\n                 }\n             }\n             lint.set_arg(\"ty\", t)\n@@ -364,7 +364,7 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_int, |lint| {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_int, |lint| {\n             lint.set_arg(\"ty\", t.name_str())\n                 .set_arg(\n                     \"lit\",\n@@ -375,13 +375,13 @@ fn lint_int_literal<'tcx>(\n                 )\n                 .set_arg(\"min\", min)\n                 .set_arg(\"max\", max)\n-                .note(fluent::lint::note);\n+                .note(fluent::note);\n \n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n                 lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                lint.help(fluent::lint::help);\n+                lint.help(fluent::help);\n             }\n \n             lint\n@@ -412,11 +412,11 @@ fn lint_uint_literal<'tcx>(\n                         cx.struct_span_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n-                            fluent::lint::only_cast_u8_to_char,\n+                            fluent::lint_only_cast_u8_to_char,\n                             |lint| {\n                                 lint.span_suggestion(\n                                     par_e.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -443,7 +443,7 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_uint, |lint| {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_uint, |lint| {\n             lint.set_arg(\"ty\", t.name_str())\n                 .set_arg(\n                     \"lit\",\n@@ -454,7 +454,7 @@ fn lint_uint_literal<'tcx>(\n                 )\n                 .set_arg(\"min\", min)\n                 .set_arg(\"max\", max)\n-                .note(fluent::lint::note)\n+                .note(fluent::note)\n         });\n     }\n }\n@@ -487,7 +487,7 @@ fn lint_literal<'tcx>(\n                 cx.struct_span_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    fluent::lint::overflowing_literal,\n+                    fluent::lint_overflowing_literal,\n                     |lint| {\n                         lint.set_arg(\"ty\", t.name_str())\n                             .set_arg(\n@@ -497,7 +497,7 @@ fn lint_literal<'tcx>(\n                                     .span_to_snippet(lit.span)\n                                     .expect(\"must get snippet from literal\"),\n                             )\n-                            .note(fluent::lint::note)\n+                            .note(fluent::note)\n                     },\n                 );\n             }\n@@ -520,7 +520,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n                     cx.struct_span_lint(\n                         UNUSED_COMPARISONS,\n                         e.span,\n-                        fluent::lint::unused_comparisons,\n+                        fluent::lint_unused_comparisons,\n                         |lint| lint,\n                     );\n                 }\n@@ -842,8 +842,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             self.emit_ffi_unsafe_type_lint(\n                 ty,\n                 sp,\n-                fluent::lint::improper_ctypes_array_reason,\n-                Some(fluent::lint::improper_ctypes_array_help),\n+                fluent::lint_improper_ctypes_array_reason,\n+                Some(fluent::lint_improper_ctypes_array_help),\n             );\n             true\n         } else {\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             } else {\n                 // All fields are ZSTs; this means that the type should behave\n                 // like (), which is FFI-unsafe\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_struct_zst, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_struct_zst, help: None }\n             }\n         } else {\n             // We can't completely trust repr(C) markings; make sure the fields are\n@@ -900,7 +900,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     FfiPhantom(..) if def.is_enum() => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: fluent::lint::improper_ctypes_enum_phantomdata,\n+                            reason: fluent::lint_improper_ctypes_enum_phantomdata,\n                             help: None,\n                         };\n                     }\n@@ -936,7 +936,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     } else {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: fluent::lint::improper_ctypes_box,\n+                            reason: fluent::lint_improper_ctypes_box,\n                             help: None,\n                         };\n                     }\n@@ -950,14 +950,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_layout_reason\n+                                    fluent::lint_improper_ctypes_struct_layout_reason\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_layout_reason\n+                                    fluent::lint_improper_ctypes_union_layout_reason\n                                 },\n                                 help: if def.is_struct() {\n-                                    Some(fluent::lint::improper_ctypes_struct_layout_help)\n+                                    Some(fluent::lint_improper_ctypes_struct_layout_help)\n                                 } else {\n-                                    Some(fluent::lint::improper_ctypes_union_layout_help)\n+                                    Some(fluent::lint_improper_ctypes_union_layout_help)\n                                 },\n                             };\n                         }\n@@ -968,9 +968,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_non_exhaustive\n+                                    fluent::lint_improper_ctypes_struct_non_exhaustive\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_non_exhaustive\n+                                    fluent::lint_improper_ctypes_union_non_exhaustive\n                                 },\n                                 help: None,\n                             };\n@@ -980,14 +980,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_fieldless_reason\n+                                    fluent::lint_improper_ctypes_struct_fieldless_reason\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_fieldless_reason\n+                                    fluent::lint_improper_ctypes_union_fieldless_reason\n                                 },\n                                 help: if def.is_struct() {\n-                                    Some(fluent::lint::improper_ctypes_struct_fieldless_help)\n+                                    Some(fluent::lint_improper_ctypes_struct_fieldless_help)\n                                 } else {\n-                                    Some(fluent::lint::improper_ctypes_union_fieldless_help)\n+                                    Some(fluent::lint_improper_ctypes_union_fieldless_help)\n                                 },\n                             };\n                         }\n@@ -1008,16 +1008,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: fluent::lint::improper_ctypes_enum_repr_reason,\n-                                    help: Some(fluent::lint::improper_ctypes_enum_repr_help),\n+                                    reason: fluent::lint_improper_ctypes_enum_repr_reason,\n+                                    help: Some(fluent::lint_improper_ctypes_enum_repr_help),\n                                 };\n                             }\n                         }\n \n                         if def.is_variant_list_non_exhaustive() && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: fluent::lint::improper_ctypes_non_exhaustive,\n+                                reason: fluent::lint_improper_ctypes_non_exhaustive,\n                                 help: None,\n                             };\n                         }\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: fluent::lint::improper_ctypes_non_exhaustive_variant,\n+                                    reason: fluent::lint_improper_ctypes_non_exhaustive_variant,\n                                     help: None,\n                                 };\n                             }\n@@ -1046,37 +1046,37 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_char_reason,\n-                help: Some(fluent::lint::improper_ctypes_char_help),\n+                reason: fluent::lint_improper_ctypes_char_reason,\n+                help: Some(fluent::lint_improper_ctypes_char_help),\n             },\n \n             ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_128bit, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_128bit, help: None }\n             }\n \n             // Primitive types with a stable representation.\n             ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_slice_reason,\n-                help: Some(fluent::lint::improper_ctypes_slice_help),\n+                reason: fluent::lint_improper_ctypes_slice_reason,\n+                help: Some(fluent::lint_improper_ctypes_slice_help),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_dyn, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_dyn, help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_str_reason,\n-                help: Some(fluent::lint::improper_ctypes_str_help),\n+                reason: fluent::lint_improper_ctypes_str_reason,\n+                help: Some(fluent::lint_improper_ctypes_str_help),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_tuple_reason,\n-                help: Some(fluent::lint::improper_ctypes_tuple_help),\n+                reason: fluent::lint_improper_ctypes_tuple_reason,\n+                help: Some(fluent::lint_improper_ctypes_tuple_help),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n@@ -1107,8 +1107,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if self.is_internal_abi(sig.abi()) {\n                     return FfiUnsafe {\n                         ty,\n-                        reason: fluent::lint::improper_ctypes_fnptr_reason,\n-                        help: Some(fluent::lint::improper_ctypes_fnptr_help),\n+                        reason: fluent::lint_improper_ctypes_fnptr_reason,\n+                        help: Some(fluent::lint_improper_ctypes_fnptr_help),\n                     };\n                 }\n \n@@ -1139,7 +1139,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n             ty::Opaque(..) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_opaque, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n@@ -1173,21 +1173,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n-        self.cx.struct_span_lint(lint, sp, fluent::lint::improper_ctypes, |lint| {\n+        self.cx.struct_span_lint(lint, sp, fluent::lint_improper_ctypes, |lint| {\n             let item_description = match self.mode {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n             lint.set_arg(\"ty\", ty);\n             lint.set_arg(\"desc\", item_description);\n-            lint.span_label(sp, fluent::lint::label);\n+            lint.span_label(sp, fluent::label);\n             if let Some(help) = help {\n                 lint.help(help);\n             }\n             lint.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    lint.span_note(sp, fluent::lint::note);\n+                    lint.span_note(sp, fluent::note);\n                 }\n             }\n             lint\n@@ -1224,7 +1224,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let Some(ty) = ty.visit_with(&mut ProhibitOpaqueTypes { cx: self.cx }).break_value() {\n-            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint::improper_ctypes_opaque, None);\n+            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint_improper_ctypes_opaque, None);\n             true\n         } else {\n             false\n@@ -1269,7 +1269,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 self.emit_ffi_unsafe_type_lint(\n                     ty,\n                     sp,\n-                    fluent::lint::improper_ctypes_only_phantomdata,\n+                    fluent::lint_improper_ctypes_only_phantomdata,\n                     None,\n                 );\n             }\n@@ -1403,7 +1403,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    fluent::lint::variant_size_differences,\n+                    fluent::lint_variant_size_differences,\n                     |lint| lint.set_arg(\"largest\", largest),\n                 );\n             }\n@@ -1513,15 +1513,15 @@ impl InvalidAtomicOrdering {\n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n             && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n-                sym::load => Some((&args[0], sym::Release, fluent::lint::atomic_ordering_load)),\n-                sym::store => Some((&args[1], sym::Acquire, fluent::lint::atomic_ordering_store)),\n+                sym::load => Some((&args[0], sym::Release, fluent::lint_atomic_ordering_load)),\n+                sym::store => Some((&args[1], sym::Acquire, fluent::lint_atomic_ordering_store)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n-                lint.help(fluent::lint::help)\n+                lint.help(fluent::help)\n             });\n         }\n     }\n@@ -1533,9 +1533,9 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint::atomic_ordering_fence, |lint| {\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint_atomic_ordering_fence, |lint| {\n                 lint\n-                    .help(fluent::lint::help)\n+                    .help(fluent::help)\n             });\n         }\n     }\n@@ -1554,7 +1554,7 @@ impl InvalidAtomicOrdering {\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n             #[derive(LintDiagnostic)]\n-            #[diag(lint::atomic_ordering_invalid)]\n+            #[diag(lint_atomic_ordering_invalid)]\n             #[help]\n             struct InvalidAtomicOrderingDiag {\n                 method: Symbol,"}, {"sha": "46706e498445107b8a26a065f167fb7ab5102fe9", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -155,12 +155,12 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint::unused_op, |lint| {\n+            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n                 lint.set_arg(\"op\", must_use_op)\n-                    .span_label(expr.span, fluent::lint::label)\n+                    .span_label(expr.span, fluent::label)\n                     .span_suggestion_verbose(\n                         expr.span.shrink_to_lo(),\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"let _ = \",\n                         Applicability::MachineApplicable,\n                     )\n@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint::unused_result, |lint| {\n+            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n                 lint.set_arg(\"ty\", ty)\n             });\n         }\n@@ -272,14 +272,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n                         span,\n-                        fluent::lint::unused_closure,\n+                        fluent::lint_unused_closure,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n                             // pre/post strings\n                             lint.set_arg(\"count\", plural_len)\n                                 .set_arg(\"pre\", descr_pre)\n                                 .set_arg(\"post\", descr_post)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::note)\n                         },\n                     );\n                     true\n@@ -288,14 +288,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n                         span,\n-                        fluent::lint::unused_generator,\n+                        fluent::lint_unused_generator,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n                             // pre/post strings\n                             lint.set_arg(\"count\", plural_len)\n                                 .set_arg(\"pre\", descr_pre)\n                                 .set_arg(\"post\", descr_post)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::note)\n                         },\n                     );\n                     true\n@@ -317,7 +317,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint::unused_def, |lint| {\n+                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint_unused_def, |lint| {\n                     // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n                     // strings\n                     lint.set_arg(\"pre\", descr_pre_path);\n@@ -369,17 +369,17 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n                     cx.struct_span_lint(\n                         PATH_STATEMENTS,\n                         s.span,\n-                        fluent::lint::path_statement_drop,\n+                        fluent::lint_path_statement_drop,\n                         |lint| {\n                             if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n                                 lint.span_suggestion(\n                                     s.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"drop({});\", snippet),\n                                     Applicability::MachineApplicable,\n                                 );\n                             } else {\n-                                lint.span_help(s.span, fluent::lint::suggestion);\n+                                lint.span_help(s.span, fluent::suggestion);\n                             }\n                             lint\n                         },\n@@ -388,7 +388,7 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n                     cx.struct_span_lint(\n                         PATH_STATEMENTS,\n                         s.span,\n-                        fluent::lint::path_statement_no_effect,\n+                        fluent::lint_path_statement_no_effect,\n                         |lint| lint,\n                     );\n                 }\n@@ -561,7 +561,7 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, fluent::lint::unused_delim, |lint| {\n+        cx.struct_span_lint(self.lint(), primary_span, fluent::lint_unused_delim, |lint| {\n             lint.set_arg(\"delim\", Self::DELIM_STR);\n             lint.set_arg(\"item\", msg);\n             if let Some((lo, hi)) = spans {\n@@ -570,7 +570,7 @@ trait UnusedDelimLint {\n                     (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n                 ];\n                 lint.multipart_suggestion(\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     replacement,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1146,7 +1146,7 @@ impl UnusedImportBraces {\n             cx.struct_span_lint(\n                 UNUSED_IMPORT_BRACES,\n                 item.span,\n-                fluent::lint::unused_import_braces,\n+                fluent::lint_unused_import_braces,\n                 |lint| lint.set_arg(\"node\", node_name),\n             );\n         }\n@@ -1201,9 +1201,9 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n                     UNUSED_ALLOCATION,\n                     e.span,\n                     match m {\n-                        adjustment::AutoBorrowMutability::Not => fluent::lint::unused_allocation,\n+                        adjustment::AutoBorrowMutability::Not => fluent::lint_unused_allocation,\n                         adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            fluent::lint::unused_allocation_mut\n+                            fluent::lint_unused_allocation_mut\n                         }\n                     },\n                     |lint| lint,"}, {"sha": "ef1985b960e361ac2e065a60a5f8beec6ba7c3be", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -40,7 +40,7 @@ impl<'a> DiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the `#[diag(...)]` \\\n-                            attribute, such as `#[diag(hir_analysis::example_error)]`\",\n+                            attribute, such as `#[diag(hir_analysis_example_error)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n@@ -121,7 +121,7 @@ impl<'a> LintDiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n-                            `#[diag(compiletest::example)]`\",\n+                            `#[diag(compiletest_example)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();"}, {"sha": "3e447c94ef1238d3d977356d6ea70e8f3ce9fe3d", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -25,18 +25,18 @@ use syn::{\n use unic_langid::langid;\n \n struct Resource {\n-    ident: Ident,\n+    krate: Ident,\n     #[allow(dead_code)]\n     fat_arrow_token: token::FatArrow,\n-    resource: LitStr,\n+    resource_path: LitStr,\n }\n \n impl Parse for Resource {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n         Ok(Resource {\n-            ident: input.parse()?,\n+            krate: input.parse()?,\n             fat_arrow_token: input.parse()?,\n-            resource: input.parse()?,\n+            resource_path: input.parse()?,\n         })\n     }\n }\n@@ -94,19 +94,20 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n     // diagnostics.\n     let mut previous_defns = HashMap::new();\n \n+    // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n+    // constant created for a given attribute is the same.\n+    let mut previous_attrs = HashSet::new();\n+\n     let mut includes = TokenStream::new();\n     let mut generated = TokenStream::new();\n-    for res in resources.0 {\n-        let ident_span = res.ident.span().unwrap();\n-        let path_span = res.resource.span().unwrap();\n \n-        // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n-        // constant created for a given attribute is the same.\n-        let mut previous_attrs = HashSet::new();\n+    for res in resources.0 {\n+        let krate_span = res.krate.span().unwrap();\n+        let path_span = res.resource_path.span().unwrap();\n \n-        let relative_ftl_path = res.resource.value();\n+        let relative_ftl_path = res.resource_path.value();\n         let absolute_ftl_path =\n-            invocation_relative_path_to_absolute(ident_span, &relative_ftl_path);\n+            invocation_relative_path_to_absolute(krate_span, &relative_ftl_path);\n         // As this macro also outputs an `include_str!` for this file, the macro will always be\n         // re-executed when the file changes.\n         let mut resource_file = match File::open(absolute_ftl_path) {\n@@ -185,7 +186,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         let mut constants = TokenStream::new();\n         for entry in resource.entries() {\n-            let span = res.ident.span();\n+            let span = res.krate.span();\n             if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n                 let _ = previous_defns.entry(name.to_string()).or_insert(path_span);\n \n@@ -199,29 +200,30 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                     .emit();\n                 }\n \n-                // `typeck_foo_bar` => `foo_bar` (in `typeck.ftl`)\n-                // `const_eval_baz` => `baz` (in `const_eval.ftl`)\n+                // Require that the message name starts with the crate name\n+                // `hir_typeck_foo_bar` (in `hir_typeck.ftl`)\n+                // `const_eval_baz` (in `const_eval.ftl`)\n                 // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n                 // The last case we error about above, but we want to fall back gracefully\n                 // so that only the error is being emitted and not also one about the macro\n                 // failing.\n-                let crate_prefix = format!(\"{}_\", res.ident);\n+                let crate_prefix = format!(\"{}_\", res.krate);\n \n                 let snake_name = name.replace('-', \"_\");\n-                let snake_name = match snake_name.strip_prefix(&crate_prefix) {\n-                    Some(rest) => Ident::new(rest, span),\n-                    None => {\n-                        Diagnostic::spanned(\n-                            path_span,\n-                            Level::Error,\n-                            format!(\"name `{name}` does not start with the crate name\"),\n-                        )\n-                        .help(format!(\"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"))\n-                        .emit();\n-                        Ident::new(&snake_name, span)\n-                    }\n+                if !snake_name.starts_with(&crate_prefix) {\n+                    Diagnostic::spanned(\n+                        path_span,\n+                        Level::Error,\n+                        format!(\"name `{name}` does not start with the crate name\"),\n+                    )\n+                    .help(format!(\n+                        \"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"\n+                    ))\n+                    .emit();\n                 };\n \n+                let snake_name = Ident::new(&snake_name, span);\n+\n                 constants.extend(quote! {\n                     pub const #snake_name: crate::DiagnosticMessage =\n                         crate::DiagnosticMessage::FluentIdentifier(\n@@ -275,12 +277,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         includes.extend(quote! { include_str!(#relative_ftl_path), });\n \n-        let ident = res.ident;\n-        generated.extend(quote! {\n-            pub mod #ident {\n-                #constants\n-            }\n-        });\n+        generated.extend(constants);\n     }\n \n     quote! {"}, {"sha": "860340b439061906321dbcfb53b1d38c85faf1d2", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -23,14 +23,14 @@ use synstructure::Structure;\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(Diagnostic)]\n-/// #[diag(borrowck::move_out_of_borrow, code = \"E0505\")]\n+/// #[diag(borrowck_move_out_of_borrow, code = \"E0505\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n ///     #[primary_span]\n ///     #[label]\n ///     pub span: Span,\n-///     #[label(borrowck::first_borrow_label)]\n+///     #[label(first_borrow_label)]\n ///     pub first_borrow_span: Span,\n ///     #[suggestion(code = \"{name}.clone()\")]\n ///     pub clone_sugg: Option<(Span, Applicability)>\n@@ -67,14 +67,14 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n ///\n /// ```ignore (rust)\n /// #[derive(LintDiagnostic)]\n-/// #[diag(lint::atomic_ordering_invalid_fail_success)]\n+/// #[diag(lint_atomic_ordering_invalid_fail_success)]\n /// pub struct AtomicOrderingInvalidLint {\n ///     method: Symbol,\n ///     success_ordering: Symbol,\n ///     fail_ordering: Symbol,\n-///     #[label(lint::fail_label)]\n+///     #[label(fail_label)]\n ///     fail_order_arg_span: Span,\n-///     #[label(lint::success_label)]\n+///     #[label(success_label)]\n ///     #[suggestion(\n ///         code = \"std::sync::atomic::Ordering::{success_suggestion}\",\n ///         applicability = \"maybe-incorrect\"\n@@ -115,12 +115,12 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```ignore (rust)\n /// #[derive(Subdiagnostic)]\n /// pub enum ExpectedIdentifierLabel<'tcx> {\n-///     #[label(parser::expected_identifier)]\n+///     #[label(expected_identifier)]\n ///     WithoutFound {\n ///         #[primary_span]\n ///         span: Span,\n ///     }\n-///     #[label(parser::expected_identifier_found)]\n+///     #[label(expected_identifier_found)]\n ///     WithFound {\n ///         #[primary_span]\n ///         span: Span,"}, {"sha": "7c387b9a9ecde156409a01d08f83511d1f0a27c5", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -12,128 +12,128 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use crate::locator::CrateFlavor;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::rlib_required)]\n+#[diag(metadata_rlib_required)]\n pub struct RlibRequired {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_required)]\n+#[diag(metadata_lib_required)]\n pub struct LibRequired<'a> {\n     pub crate_name: Symbol,\n     pub kind: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_dep_multiple)]\n+#[diag(metadata_crate_dep_multiple)]\n #[help]\n pub struct CrateDepMultiple {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::two_panic_runtimes)]\n+#[diag(metadata_two_panic_runtimes)]\n pub struct TwoPanicRuntimes {\n     pub prev_name: Symbol,\n     pub cur_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::bad_panic_strategy)]\n+#[diag(metadata_bad_panic_strategy)]\n pub struct BadPanicStrategy {\n     pub runtime: Symbol,\n     pub strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::required_panic_strategy)]\n+#[diag(metadata_required_panic_strategy)]\n pub struct RequiredPanicStrategy {\n     pub crate_name: Symbol,\n     pub found_strategy: PanicStrategy,\n     pub desired_strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_panic_in_drop_strategy)]\n+#[diag(metadata_incompatible_panic_in_drop_strategy)]\n pub struct IncompatiblePanicInDropStrategy {\n     pub crate_name: Symbol,\n     pub found_strategy: PanicStrategy,\n     pub desired_strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_names_in_link)]\n+#[diag(metadata_multiple_names_in_link)]\n pub struct MultipleNamesInLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_kinds_in_link)]\n+#[diag(metadata_multiple_kinds_in_link)]\n pub struct MultipleKindsInLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_name_form)]\n+#[diag(metadata_link_name_form)]\n pub struct LinkNameForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_kind_form)]\n+#[diag(metadata_link_kind_form)]\n pub struct LinkKindForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_modifiers_form)]\n+#[diag(metadata_link_modifiers_form)]\n pub struct LinkModifiersForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_cfg_form)]\n+#[diag(metadata_link_cfg_form)]\n pub struct LinkCfgForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::wasm_import_form)]\n+#[diag(metadata_wasm_import_form)]\n pub struct WasmImportForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::empty_link_name, code = \"E0454\")]\n+#[diag(metadata_empty_link_name, code = \"E0454\")]\n pub struct EmptyLinkName {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_framework_apple, code = \"E0455\")]\n+#[diag(metadata_link_framework_apple, code = \"E0455\")]\n pub struct LinkFrameworkApple {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::framework_only_windows, code = \"E0455\")]\n+#[diag(metadata_framework_only_windows, code = \"E0455\")]\n pub struct FrameworkOnlyWindows {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_link_kind, code = \"E0458\")]\n+#[diag(metadata_unknown_link_kind, code = \"E0458\")]\n pub struct UnknownLinkKind<'a> {\n     #[primary_span]\n     #[label]\n@@ -142,235 +142,235 @@ pub struct UnknownLinkKind<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_link_modifiers)]\n+#[diag(metadata_multiple_link_modifiers)]\n pub struct MultipleLinkModifiers {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_cfgs)]\n+#[diag(metadata_multiple_cfgs)]\n pub struct MultipleCfgs {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_cfg_single_predicate)]\n+#[diag(metadata_link_cfg_single_predicate)]\n pub struct LinkCfgSinglePredicate {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_wasm_import)]\n+#[diag(metadata_multiple_wasm_import)]\n pub struct MultipleWasmImport {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unexpected_link_arg)]\n+#[diag(metadata_unexpected_link_arg)]\n pub struct UnexpectedLinkArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::invalid_link_modifier)]\n+#[diag(metadata_invalid_link_modifier)]\n pub struct InvalidLinkModifier {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_modifiers)]\n+#[diag(metadata_multiple_modifiers)]\n pub struct MultipleModifiers<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub modifier: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::bundle_needs_static)]\n+#[diag(metadata_bundle_needs_static)]\n pub struct BundleNeedsStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::whole_archive_needs_static)]\n+#[diag(metadata_whole_archive_needs_static)]\n pub struct WholeArchiveNeedsStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::as_needed_compatibility)]\n+#[diag(metadata_as_needed_compatibility)]\n pub struct AsNeededCompatibility {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_link_modifier)]\n+#[diag(metadata_unknown_link_modifier)]\n pub struct UnknownLinkModifier<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub modifier: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_wasm_link)]\n+#[diag(metadata_incompatible_wasm_link)]\n pub struct IncompatibleWasmLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_requires_name, code = \"E0459\")]\n+#[diag(metadata_link_requires_name, code = \"E0459\")]\n pub struct LinkRequiresName {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::raw_dylib_no_nul)]\n+#[diag(metadata_raw_dylib_no_nul)]\n pub struct RawDylibNoNul {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_ordinal_raw_dylib)]\n+#[diag(metadata_link_ordinal_raw_dylib)]\n pub struct LinkOrdinalRawDylib {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_framework_apple)]\n+#[diag(metadata_lib_framework_apple)]\n pub struct LibFrameworkApple;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::empty_renaming_target)]\n+#[diag(metadata_empty_renaming_target)]\n pub struct EmptyRenamingTarget<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::renaming_no_link)]\n+#[diag(metadata_renaming_no_link)]\n pub struct RenamingNoLink<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_renamings)]\n+#[diag(metadata_multiple_renamings)]\n pub struct MultipleRenamings<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_link_mod_override)]\n+#[diag(metadata_no_link_mod_override)]\n pub struct NoLinkModOverride {\n     #[primary_span]\n     pub span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unsupported_abi_i686)]\n+#[diag(metadata_unsupported_abi_i686)]\n pub struct UnsupportedAbiI686 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unsupported_abi)]\n+#[diag(metadata_unsupported_abi)]\n pub struct UnsupportedAbi {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_create_file_encoder)]\n+#[diag(metadata_fail_create_file_encoder)]\n pub struct FailCreateFileEncoder {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_seek_file)]\n+#[diag(metadata_fail_seek_file)]\n pub struct FailSeekFile {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_write_file)]\n+#[diag(metadata_fail_write_file)]\n pub struct FailWriteFile {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_not_panic_runtime)]\n+#[diag(metadata_crate_not_panic_runtime)]\n pub struct CrateNotPanicRuntime {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_panic_strategy)]\n+#[diag(metadata_no_panic_strategy)]\n pub struct NoPanicStrategy {\n     pub crate_name: Symbol,\n     pub strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::profiler_builtins_needs_core)]\n+#[diag(metadata_profiler_builtins_needs_core)]\n pub struct ProfilerBuiltinsNeedsCore;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::not_profiler_runtime)]\n+#[diag(metadata_not_profiler_runtime)]\n pub struct NotProfilerRuntime {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_multiple_global_alloc)]\n+#[diag(metadata_no_multiple_global_alloc)]\n pub struct NoMultipleGlobalAlloc {\n     #[primary_span]\n     #[label]\n     pub span2: Span,\n-    #[label(metadata::prev_global_alloc)]\n+    #[label(metadata_prev_global_alloc)]\n     pub span1: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::conflicting_global_alloc)]\n+#[diag(metadata_conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n     pub crate_name: Symbol,\n     pub other_crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::global_alloc_required)]\n+#[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_transitive_needs_dep)]\n+#[diag(metadata_no_transitive_needs_dep)]\n pub struct NoTransitiveNeedsDep<'a> {\n     pub crate_name: Symbol,\n     pub needs_crate_name: &'a str,\n     pub deps_crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_write_error)]\n+#[diag(metadata_failed_write_error)]\n pub struct FailedWriteError {\n     pub filename: PathBuf,\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::missing_native_library)]\n+#[diag(metadata_missing_native_library)]\n pub struct MissingNativeLibrary<'a> {\n     libname: &'a str,\n     #[subdiagnostic]\n@@ -404,40 +404,40 @@ impl<'a> MissingNativeLibrary<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[help(metadata::only_provide_library_name)]\n+#[help(metadata_only_provide_library_name)]\n pub struct SuggestLibraryName<'a> {\n     suggested_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_tempdir)]\n+#[diag(metadata_failed_create_tempdir)]\n pub struct FailedCreateTempdir {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_file)]\n+#[diag(metadata_failed_create_file)]\n pub struct FailedCreateFile<'a> {\n     pub filename: &'a Path,\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_encoded_metadata)]\n+#[diag(metadata_failed_create_encoded_metadata)]\n pub struct FailedCreateEncodedMetadata {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::non_ascii_name)]\n+#[diag(metadata_non_ascii_name)]\n pub struct NonAsciiName {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::extern_location_not_exist)]\n+#[diag(metadata_extern_location_not_exist)]\n pub struct ExternLocationNotExist<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -446,7 +446,7 @@ pub struct ExternLocationNotExist<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::extern_location_not_file)]\n+#[diag(metadata_extern_location_not_file)]\n pub struct ExternLocationNotFile<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -466,7 +466,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n         diag.code(error_code!(E0465));\n@@ -479,7 +479,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_matching_crates, code = \"E0464\")]\n+#[diag(metadata_multiple_matching_crates, code = \"E0464\")]\n #[note]\n pub struct MultipleMatchingCrates {\n     #[primary_span]\n@@ -489,23 +489,23 @@ pub struct MultipleMatchingCrates {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::symbol_conflicts_current, code = \"E0519\")]\n+#[diag(metadata_symbol_conflicts_current, code = \"E0519\")]\n pub struct SymbolConflictsCurrent {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::symbol_conflicts_others, code = \"E0523\")]\n+#[diag(metadata_symbol_conflicts_others, code = \"E0523\")]\n pub struct SymbolConflictsOthers {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::stable_crate_id_collision)]\n+#[diag(metadata_stable_crate_id_collision)]\n pub struct StableCrateIdCollision {\n     #[primary_span]\n     pub span: Span,\n@@ -514,17 +514,17 @@ pub struct StableCrateIdCollision {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::dl_error)]\n+#[diag(metadata_dl_error)]\n pub struct DlError {\n     #[primary_span]\n     pub span: Span,\n     pub err: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::newer_crate_version, code = \"E0460\")]\n+#[diag(metadata_newer_crate_version, code = \"E0460\")]\n #[note]\n-#[note(metadata::found_crate_versions)]\n+#[note(metadata_found_crate_versions)]\n pub struct NewerCrateVersion {\n     #[primary_span]\n     pub span: Span,\n@@ -534,8 +534,8 @@ pub struct NewerCrateVersion {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_crate_with_triple, code = \"E0461\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_no_crate_with_triple, code = \"E0461\")]\n+#[note(metadata_found_crate_versions)]\n pub struct NoCrateWithTriple<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -546,8 +546,8 @@ pub struct NoCrateWithTriple<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::found_staticlib, code = \"E0462\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_found_staticlib, code = \"E0462\")]\n+#[note(metadata_found_crate_versions)]\n #[help]\n pub struct FoundStaticlib {\n     #[primary_span]\n@@ -558,8 +558,8 @@ pub struct FoundStaticlib {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_rustc, code = \"E0514\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_incompatible_rustc, code = \"E0514\")]\n+#[note(metadata_found_crate_versions)]\n #[help]\n pub struct IncompatibleRustc {\n     #[primary_span]\n@@ -582,7 +582,7 @@ impl IntoDiagnostic<'_> for InvalidMetadataFiles {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_invalid_meta_files);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n         diag.code(error_code!(E0786));\n@@ -610,7 +610,7 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_cannot_find_crate);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"current_crate\", self.current_crate);\n         diag.set_arg(\"add_info\", self.add_info);\n@@ -621,54 +621,54 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n             && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n         {\n             if self.missing_core {\n-                diag.note(rustc_errors::fluent::metadata::target_not_installed);\n+                diag.note(rustc_errors::fluent::metadata_target_not_installed);\n             } else {\n-                diag.note(rustc_errors::fluent::metadata::target_no_std_support);\n+                diag.note(rustc_errors::fluent::metadata_target_no_std_support);\n             }\n             // NOTE: this suggests using rustup, even though the user may not have it installed.\n             // That's because they could choose to install it; or this may give them a hint which\n             // target they need to install from their distro.\n             if self.missing_core {\n-                diag.help(rustc_errors::fluent::metadata::consider_downloading_target);\n+                diag.help(rustc_errors::fluent::metadata_consider_downloading_target);\n             }\n             // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n             // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n             // If it's not a dummy, that means someone added `extern crate std` explicitly and\n             // `#![no_std]` won't help.\n             if !self.missing_core && self.span.is_dummy() {\n-                diag.note(rustc_errors::fluent::metadata::std_required);\n+                diag.note(rustc_errors::fluent::metadata_std_required);\n             }\n             if self.is_nightly_build {\n-                diag.help(rustc_errors::fluent::metadata::consider_building_std);\n+                diag.help(rustc_errors::fluent::metadata_consider_building_std);\n             }\n         } else if self.crate_name == self.profiler_runtime {\n-            diag.note(rustc_errors::fluent::metadata::compiler_missing_profiler);\n+            diag.note(rustc_errors::fluent::metadata_compiler_missing_profiler);\n         } else if self.crate_name.as_str().starts_with(\"rustc_\") {\n-            diag.help(rustc_errors::fluent::metadata::install_missing_components);\n+            diag.help(rustc_errors::fluent::metadata_install_missing_components);\n         }\n-        diag.span_label(self.span, rustc_errors::fluent::metadata::cant_find_crate);\n+        diag.span_label(self.span, rustc_errors::fluent::metadata_cant_find_crate);\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_dylib_plugin, code = \"E0457\")]\n+#[diag(metadata_no_dylib_plugin, code = \"E0457\")]\n pub struct NoDylibPlugin {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_location_unknown_type)]\n+#[diag(metadata_crate_location_unknown_type)]\n pub struct CrateLocationUnknownType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_filename_form)]\n+#[diag(metadata_lib_filename_form)]\n pub struct LibFilenameForm<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -677,36 +677,36 @@ pub struct LibFilenameForm<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_import_name_type)]\n+#[diag(metadata_multiple_import_name_type)]\n pub struct MultipleImportNameType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_form)]\n+#[diag(metadata_import_name_type_form)]\n pub struct ImportNameTypeForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_x86)]\n+#[diag(metadata_import_name_type_x86)]\n pub struct ImportNameTypeX86 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_import_name_type)]\n+#[diag(metadata_unknown_import_name_type)]\n pub struct UnknownImportNameType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub import_name_type: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_raw)]\n+#[diag(metadata_import_name_type_raw)]\n pub struct ImportNameTypeRaw {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "a7a7ac0599d7176a831892136e96f2f4f720f7b3", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -4,7 +4,7 @@ use rustc_span::Span;\n use crate::ty::Ty;\n \n #[derive(Diagnostic)]\n-#[diag(middle::drop_check_overflow, code = \"E0320\")]\n+#[diag(middle_drop_check_overflow, code = \"E0320\")]\n #[note]\n pub struct DropCheckOverflow<'tcx> {\n     #[primary_span]\n@@ -14,7 +14,7 @@ pub struct DropCheckOverflow<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::opaque_hidden_type_mismatch)]\n+#[diag(middle_opaque_hidden_type_mismatch)]\n pub struct OpaqueHiddenTypeMismatch<'tcx> {\n     pub self_ty: Ty<'tcx>,\n     pub other_ty: Ty<'tcx>,\n@@ -27,20 +27,20 @@ pub struct OpaqueHiddenTypeMismatch<'tcx> {\n \n #[derive(Subdiagnostic)]\n pub enum TypeMismatchReason {\n-    #[label(middle::conflict_types)]\n+    #[label(middle_conflict_types)]\n     ConflictType {\n         #[primary_span]\n         span: Span,\n     },\n-    #[note(middle::previous_use_here)]\n+    #[note(middle_previous_use_here)]\n     PreviousUse {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::limit_invalid)]\n+#[diag(middle_limit_invalid)]\n pub struct LimitInvalid<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -50,7 +50,7 @@ pub struct LimitInvalid<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::const_eval_non_int)]\n+#[diag(middle_const_eval_non_int)]\n pub struct ConstEvalNonIntError {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "b8fd01e6a77975c099a351d990dae5301e69fb96", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -513,7 +513,7 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::const_not_used_in_type_alias)]\n+#[diag(borrowck_const_not_used_in_type_alias)]\n pub(super) struct ConstNotUsedTraitAlias {\n     pub ct: String,\n     #[primary_span]"}, {"sha": "0a109fd8f44f85125baa0bcc9f65af9e1f981428", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -196,16 +196,16 @@ impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n         match self {\n             LayoutError::Unknown(ty) => {\n                 diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(rustc_errors::fluent::middle::unknown_layout);\n+                diag.set_primary_message(rustc_errors::fluent::middle_unknown_layout);\n             }\n             LayoutError::SizeOverflow(ty) => {\n                 diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(rustc_errors::fluent::middle::values_too_big);\n+                diag.set_primary_message(rustc_errors::fluent::middle_values_too_big);\n             }\n             LayoutError::NormalizationFailure(ty, e) => {\n                 diag.set_arg(\"ty\", ty);\n                 diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n-                diag.set_primary_message(rustc_errors::fluent::middle::cannot_be_normalized);\n+                diag.set_primary_message(rustc_errors::fluent::middle_cannot_be_normalized);\n             }\n         }\n         diag"}, {"sha": "cfacc0ec370c114f293f6f8969525b57906cb10b", "filename": "compiler/rustc_mir_dataflow/src/errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -2,69 +2,69 @@ use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::path_must_end_in_filename)]\n+#[diag(mir_dataflow_path_must_end_in_filename)]\n pub(crate) struct PathMustEndInFilename {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::unknown_formatter)]\n+#[diag(mir_dataflow_unknown_formatter)]\n pub(crate) struct UnknownFormatter {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::duplicate_values_for)]\n+#[diag(mir_dataflow_duplicate_values_for)]\n pub(crate) struct DuplicateValuesFor {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::requires_an_argument)]\n+#[diag(mir_dataflow_requires_an_argument)]\n pub(crate) struct RequiresAnArgument {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::stop_after_dataflow_ended_compilation)]\n+#[diag(mir_dataflow_stop_after_dataflow_ended_compilation)]\n pub(crate) struct StopAfterDataFlowEndedCompilation;\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_must_be_place_or_ref_place)]\n+#[diag(mir_dataflow_peek_must_be_place_or_ref_place)]\n pub(crate) struct PeekMustBePlaceOrRefPlace {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_must_be_not_temporary)]\n+#[diag(mir_dataflow_peek_must_be_not_temporary)]\n pub(crate) struct PeekMustBeNotTemporary {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_bit_not_set)]\n+#[diag(mir_dataflow_peek_bit_not_set)]\n pub(crate) struct PeekBitNotSet {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_argument_not_a_local)]\n+#[diag(mir_dataflow_peek_argument_not_a_local)]\n pub(crate) struct PeekArgumentNotALocal {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_argument_untracked)]\n+#[diag(mir_dataflow_peek_argument_untracked)]\n pub(crate) struct PeekArgumentUntracked {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "ce097b8d846aa3f41db29948e674683ba1f130a0", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -6,34 +6,34 @@ use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::recursion_limit)]\n+#[diag(monomorphize_recursion_limit)]\n pub struct RecursionLimit {\n     #[primary_span]\n     pub span: Span,\n     pub shrunk: String,\n     #[note]\n     pub def_span: Span,\n     pub def_path_str: String,\n-    #[note(monomorphize::written_to_path)]\n+    #[note(monomorphize_written_to_path)]\n     pub was_written: Option<()>,\n     pub path: PathBuf,\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::type_length_limit)]\n-#[help(monomorphize::consider_type_length_limit)]\n+#[diag(monomorphize_type_length_limit)]\n+#[help(monomorphize_consider_type_length_limit)]\n pub struct TypeLengthLimit {\n     #[primary_span]\n     pub span: Span,\n     pub shrunk: String,\n-    #[note(monomorphize::written_to_path)]\n+    #[note(monomorphize_written_to_path)]\n     pub was_written: Option<()>,\n     pub path: PathBuf,\n     pub type_length: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::requires_lang_item)]\n+#[diag(monomorphize_requires_lang_item)]\n pub struct RequiresLangItem {\n     pub lang_item: String,\n }\n@@ -49,8 +49,7 @@ impl IntoDiagnostic<'_> for UnusedGenericParams {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag =\n-            handler.struct_err(rustc_errors::fluent::monomorphize::unused_generic_params);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::monomorphize_unused_generic_params);\n         diag.set_span(self.span);\n         for (span, name) in self.param_spans.into_iter().zip(self.param_names) {\n             // FIXME: I can figure out how to do a label with a fluent string with a fixed message,\n@@ -63,7 +62,7 @@ impl IntoDiagnostic<'_> for UnusedGenericParams {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(monomorphize::large_assignments)]\n+#[diag(monomorphize_large_assignments)]\n #[note]\n pub struct LargeAssignmentsLint {\n     #[label]\n@@ -73,11 +72,11 @@ pub struct LargeAssignmentsLint {\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::unknown_partition_strategy)]\n+#[diag(monomorphize_unknown_partition_strategy)]\n pub struct UnknownPartitionStrategy;\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::symbol_already_defined)]\n+#[diag(monomorphize_symbol_already_defined)]\n pub struct SymbolAlreadyDefined {\n     #[primary_span]\n     pub span: Option<Span>,"}, {"sha": "9b177c5189bfbe426acff8c8410eb8ab6a03512d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 170, "deletions": 184, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{Span, Symbol};\n use crate::parser::TokenDescription;\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_report_ambiguous_plus)]\n+#[diag(parser_maybe_report_ambiguous_plus)]\n pub(crate) struct AmbiguousPlus {\n     pub sum_ty: String,\n     #[primary_span]\n@@ -18,7 +18,7 @@ pub(crate) struct AmbiguousPlus {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n+#[diag(parser_maybe_recover_from_bad_type_plus, code = \"E0178\")]\n pub(crate) struct BadTypePlus {\n     pub ty: String,\n     #[primary_span]\n@@ -30,7 +30,7 @@ pub(crate) struct BadTypePlus {\n #[derive(Subdiagnostic)]\n pub(crate) enum BadTypePlusSub {\n     #[suggestion(\n-        parser::add_paren,\n+        parser_add_paren,\n         code = \"{sum_with_parens}\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -39,20 +39,20 @@ pub(crate) enum BadTypePlusSub {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser::forgot_paren)]\n+    #[label(parser_forgot_paren)]\n     ForgotParen {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser::expect_path)]\n+    #[label(parser_expect_path)]\n     ExpectPath {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n+#[diag(parser_maybe_recover_from_bad_qpath_stage_2)]\n pub(crate) struct BadQPathStage2 {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n@@ -61,7 +61,7 @@ pub(crate) struct BadQPathStage2 {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_semicolon)]\n+#[diag(parser_incorrect_semicolon)]\n pub(crate) struct IncorrectSemicolon<'a> {\n     #[primary_span]\n     #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n@@ -72,26 +72,26 @@ pub(crate) struct IncorrectSemicolon<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n+#[diag(parser_incorrect_use_of_await)]\n pub(crate) struct IncorrectUseOfAwait {\n     #[primary_span]\n-    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n+#[diag(parser_incorrect_use_of_await)]\n pub(crate) struct IncorrectAwait {\n     #[primary_span]\n     pub span: Span,\n-    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n+    #[suggestion(postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n     pub sugg_span: (Span, Applicability),\n     pub expr: String,\n     pub question_mark: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::in_in_typo)]\n+#[diag(parser_in_in_typo)]\n pub(crate) struct InInTypo {\n     #[primary_span]\n     pub span: Span,\n@@ -100,7 +100,7 @@ pub(crate) struct InInTypo {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_variable_declaration)]\n+#[diag(parser_invalid_variable_declaration)]\n pub(crate) struct InvalidVariableDeclaration {\n     #[primary_span]\n     pub span: Span,\n@@ -110,26 +110,22 @@ pub(crate) struct InvalidVariableDeclaration {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidVariableDeclarationSub {\n-    #[suggestion(\n-        parser::switch_mut_let_order,\n-        applicability = \"maybe-incorrect\",\n-        code = \"let mut\"\n-    )]\n+    #[suggestion(parser_switch_mut_let_order, applicability = \"maybe-incorrect\", code = \"let mut\")]\n     SwitchMutLetOrder(#[primary_span] Span),\n     #[suggestion(\n-        parser::missing_let_before_mut,\n+        parser_missing_let_before_mut,\n         applicability = \"machine-applicable\",\n         code = \"let mut\"\n     )]\n     MissingLet(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parser_use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotAuto(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parser_use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotVar(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_comparison_operator)]\n+#[diag(parser_invalid_comparison_operator)]\n pub(crate) struct InvalidComparisonOperator {\n     #[primary_span]\n     pub span: Span,\n@@ -140,23 +136,19 @@ pub(crate) struct InvalidComparisonOperator {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidComparisonOperatorSub {\n-    #[suggestion_short(\n-        parser::use_instead,\n-        applicability = \"machine-applicable\",\n-        code = \"{correct}\"\n-    )]\n+    #[suggestion_short(use_instead, applicability = \"machine-applicable\", code = \"{correct}\")]\n     Correctable {\n         #[primary_span]\n         span: Span,\n         invalid: String,\n         correct: String,\n     },\n-    #[label(parser::spaceship_operator_invalid)]\n+    #[label(spaceship_operator_invalid)]\n     Spaceship(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_logical_operator)]\n+#[diag(parser_invalid_logical_operator)]\n #[note]\n pub(crate) struct InvalidLogicalOperator {\n     #[primary_span]\n@@ -169,29 +161,29 @@ pub(crate) struct InvalidLogicalOperator {\n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidLogicalOperatorSub {\n     #[suggestion_short(\n-        parser::use_amp_amp_for_conjunction,\n+        use_amp_amp_for_conjunction,\n         applicability = \"machine-applicable\",\n         code = \"&&\"\n     )]\n     Conjunction(#[primary_span] Span),\n     #[suggestion_short(\n-        parser::use_pipe_pipe_for_disjunction,\n+        use_pipe_pipe_for_disjunction,\n         applicability = \"machine-applicable\",\n         code = \"||\"\n     )]\n     Disjunction(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::tilde_is_not_unary_operator)]\n+#[diag(parser_tilde_is_not_unary_operator)]\n pub(crate) struct TildeAsUnaryOperator(\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n     pub Span,\n );\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_not)]\n+#[diag(parser_unexpected_token_after_not)]\n pub(crate) struct NotAsNegationOperator {\n     #[primary_span]\n     pub negated: Span,\n@@ -203,29 +195,29 @@ pub(crate) struct NotAsNegationOperator {\n #[derive(Subdiagnostic)]\n pub enum NotAsNegationOperatorSub {\n     #[suggestion_short(\n-        parser::unexpected_token_after_not_default,\n+        parser_unexpected_token_after_not_default,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotDefault(#[primary_span] Span),\n \n     #[suggestion_short(\n-        parser::unexpected_token_after_not_bitwise,\n+        parser_unexpected_token_after_not_bitwise,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotBitwise(#[primary_span] Span),\n \n     #[suggestion_short(\n-        parser::unexpected_token_after_not_logical,\n+        parser_unexpected_token_after_not_logical,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotLogical(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::malformed_loop_label)]\n+#[diag(parser_malformed_loop_label)]\n pub(crate) struct MalformedLoopLabel {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n@@ -234,7 +226,7 @@ pub(crate) struct MalformedLoopLabel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::lifetime_in_borrow_expression)]\n+#[diag(parser_lifetime_in_borrow_expression)]\n pub(crate) struct LifetimeInBorrowExpression {\n     #[primary_span]\n     pub span: Span,\n@@ -244,27 +236,27 @@ pub(crate) struct LifetimeInBorrowExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::field_expression_with_generic)]\n+#[diag(parser_field_expression_with_generic)]\n pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser::macro_invocation_with_qualified_path)]\n+#[diag(parser_macro_invocation_with_qualified_path)]\n pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_label)]\n+#[diag(parser_unexpected_token_after_label)]\n pub(crate) struct UnexpectedTokenAfterLabel {\n     #[primary_span]\n-    #[label(parser::unexpected_token_after_label)]\n+    #[label(parser_unexpected_token_after_label)]\n     pub span: Span,\n-    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n+    #[suggestion_verbose(suggestion_remove_label, code = \"\")]\n     pub remove_label: Option<Span>,\n     #[subdiagnostic]\n     pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n pub(crate) struct UnexpectedTokenAfterLabelSugg {\n     #[suggestion_part(code = \"{{ \")]\n     pub left: Span,\n@@ -273,7 +265,7 @@ pub(crate) struct UnexpectedTokenAfterLabelSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::require_colon_after_labeled_expression)]\n+#[diag(parser_require_colon_after_labeled_expression)]\n #[note]\n pub(crate) struct RequireColonAfterLabeledExpression {\n     #[primary_span]\n@@ -285,7 +277,7 @@ pub(crate) struct RequireColonAfterLabeledExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::do_catch_syntax_removed)]\n+#[diag(parser_do_catch_syntax_removed)]\n #[note]\n pub(crate) struct DoCatchSyntaxRemoved {\n     #[primary_span]\n@@ -294,7 +286,7 @@ pub(crate) struct DoCatchSyntaxRemoved {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::float_literal_requires_integer_part)]\n+#[diag(parser_float_literal_requires_integer_part)]\n pub(crate) struct FloatLiteralRequiresIntegerPart {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n@@ -303,7 +295,7 @@ pub(crate) struct FloatLiteralRequiresIntegerPart {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_int_literal_width)]\n+#[diag(parser_invalid_int_literal_width)]\n #[help]\n pub(crate) struct InvalidIntLiteralWidth {\n     #[primary_span]\n@@ -312,7 +304,7 @@ pub(crate) struct InvalidIntLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_base_prefix)]\n+#[diag(parser_invalid_num_literal_base_prefix)]\n #[note]\n pub(crate) struct InvalidNumLiteralBasePrefix {\n     #[primary_span]\n@@ -322,7 +314,7 @@ pub(crate) struct InvalidNumLiteralBasePrefix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_suffix)]\n+#[diag(parser_invalid_num_literal_suffix)]\n #[help]\n pub(crate) struct InvalidNumLiteralSuffix {\n     #[primary_span]\n@@ -332,7 +324,7 @@ pub(crate) struct InvalidNumLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_width)]\n+#[diag(parser_invalid_float_literal_width)]\n #[help]\n pub(crate) struct InvalidFloatLiteralWidth {\n     #[primary_span]\n@@ -341,7 +333,7 @@ pub(crate) struct InvalidFloatLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_suffix)]\n+#[diag(parser_invalid_float_literal_suffix)]\n #[help]\n pub(crate) struct InvalidFloatLiteralSuffix {\n     #[primary_span]\n@@ -351,14 +343,14 @@ pub(crate) struct InvalidFloatLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::int_literal_too_large)]\n+#[diag(parser_int_literal_too_large)]\n pub(crate) struct IntLiteralTooLarge {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_semicolon_before_array)]\n+#[diag(parser_missing_semicolon_before_array)]\n pub(crate) struct MissingSemicolonBeforeArray {\n     #[primary_span]\n     pub open_delim: Span,\n@@ -367,7 +359,7 @@ pub(crate) struct MissingSemicolonBeforeArray {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_block_macro_segment)]\n+#[diag(parser_invalid_block_macro_segment)]\n pub(crate) struct InvalidBlockMacroSegment {\n     #[primary_span]\n     pub span: Span,\n@@ -376,7 +368,7 @@ pub(crate) struct InvalidBlockMacroSegment {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_then_block)]\n+#[diag(parser_if_expression_missing_then_block)]\n pub(crate) struct IfExpressionMissingThenBlock {\n     #[primary_span]\n     pub if_span: Span,\n@@ -386,31 +378,31 @@ pub(crate) struct IfExpressionMissingThenBlock {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum IfExpressionMissingThenBlockSub {\n-    #[help(parser::condition_possibly_unfinished)]\n+    #[help(condition_possibly_unfinished)]\n     UnfinishedCondition(#[primary_span] Span),\n-    #[help(parser::add_then_block)]\n+    #[help(add_then_block)]\n     AddThenBlock(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_condition)]\n+#[diag(parser_if_expression_missing_condition)]\n pub(crate) struct IfExpressionMissingCondition {\n     #[primary_span]\n-    #[label(parser::condition_label)]\n+    #[label(condition_label)]\n     pub if_span: Span,\n-    #[label(parser::block_label)]\n+    #[label(block_label)]\n     pub block_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_expression_found_let)]\n+#[diag(parser_expected_expression_found_let)]\n pub(crate) struct ExpectedExpressionFoundLet {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_else_block)]\n+#[diag(parser_expected_else_block)]\n pub(crate) struct ExpectedElseBlock {\n     #[primary_span]\n     pub first_tok_span: Span,\n@@ -422,15 +414,15 @@ pub(crate) struct ExpectedElseBlock {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+#[diag(parser_outer_attribute_not_allowed_on_if_else)]\n pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n     #[primary_span]\n     pub last: Span,\n \n-    #[label(parser::branch_label)]\n+    #[label(branch_label)]\n     pub branch_span: Span,\n \n-    #[label(parser::ctx_label)]\n+    #[label(ctx_label)]\n     pub ctx_span: Span,\n     pub ctx: String,\n \n@@ -439,7 +431,7 @@ pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_in_in_for_loop)]\n+#[diag(parser_missing_in_in_for_loop)]\n pub(crate) struct MissingInInForLoop {\n     #[primary_span]\n     pub span: Span,\n@@ -450,30 +442,30 @@ pub(crate) struct MissingInInForLoop {\n #[derive(Subdiagnostic)]\n pub(crate) enum MissingInInForLoopSub {\n     // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n-    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    #[suggestion_short(use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n     InNotOf(#[primary_span] Span),\n-    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    #[suggestion_short(add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n     AddIn(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_comma_after_match_arm)]\n+#[diag(parser_missing_comma_after_match_arm)]\n pub(crate) struct MissingCommaAfterMatchArm {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::catch_after_try)]\n+#[diag(parser_catch_after_try)]\n #[help]\n pub(crate) struct CatchAfterTry {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comma_after_base_struct)]\n+#[diag(parser_comma_after_base_struct)]\n #[note]\n pub(crate) struct CommaAfterBaseStruct {\n     #[primary_span]\n@@ -483,7 +475,7 @@ pub(crate) struct CommaAfterBaseStruct {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::eq_field_init)]\n+#[diag(parser_eq_field_init)]\n pub(crate) struct EqFieldInit {\n     #[primary_span]\n     pub span: Span,\n@@ -492,74 +484,74 @@ pub(crate) struct EqFieldInit {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::dotdotdot)]\n+#[diag(parser_dotdotdot)]\n pub(crate) struct DotDotDot {\n     #[primary_span]\n-    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n-    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    #[suggestion(suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::left_arrow_operator)]\n+#[diag(parser_left_arrow_operator)]\n pub(crate) struct LeftArrowOperator {\n     #[primary_span]\n     #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::remove_let)]\n+#[diag(parser_remove_let)]\n pub(crate) struct RemoveLet {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::use_eq_instead)]\n+#[diag(parser_use_eq_instead)]\n pub(crate) struct UseEqInstead {\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::use_empty_block_not_semi)]\n+#[diag(parser_use_empty_block_not_semi)]\n pub(crate) struct UseEmptyBlockNotSemi {\n     #[primary_span]\n     #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comparison_interpreted_as_generic)]\n+#[diag(parser_comparison_interpreted_as_generic)]\n pub(crate) struct ComparisonInterpretedAsGeneric {\n     #[primary_span]\n-    #[label(parser::label_comparison)]\n+    #[label(label_comparison)]\n     pub comparison: Span,\n     pub r#type: Path,\n-    #[label(parser::label_args)]\n+    #[label(label_args)]\n     pub args: Span,\n     #[subdiagnostic]\n     pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::shift_interpreted_as_generic)]\n+#[diag(parser_shift_interpreted_as_generic)]\n pub(crate) struct ShiftInterpretedAsGeneric {\n     #[primary_span]\n-    #[label(parser::label_comparison)]\n+    #[label(label_comparison)]\n     pub shift: Span,\n     pub r#type: Path,\n-    #[label(parser::label_args)]\n+    #[label(label_args)]\n     pub args: Span,\n     #[subdiagnostic]\n     pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -568,7 +560,7 @@ pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::found_expr_would_be_stmt)]\n+#[diag(parser_found_expr_would_be_stmt)]\n pub(crate) struct FoundExprWouldBeStmt {\n     #[primary_span]\n     #[label]\n@@ -579,23 +571,19 @@ pub(crate) struct FoundExprWouldBeStmt {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::leading_plus_not_supported)]\n+#[diag(parser_leading_plus_not_supported)]\n pub(crate) struct LeadingPlusNotSupported {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[suggestion_verbose(\n-        parser::suggestion_remove_plus,\n-        code = \"\",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion_verbose(suggestion_remove_plus, code = \"\", applicability = \"machine-applicable\")]\n     pub remove_plus: Option<Span>,\n     #[subdiagnostic]\n     pub add_parentheses: Option<ExprParenthesesNeeded>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::parentheses_with_struct_fields)]\n+#[diag(parser_parentheses_with_struct_fields)]\n pub(crate) struct ParenthesesWithStructFields {\n     #[primary_span]\n     pub span: Span,\n@@ -607,7 +595,7 @@ pub(crate) struct ParenthesesWithStructFields {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n pub(crate) struct BracesForStructLiteral {\n     #[suggestion_part(code = \" {{ \")]\n     pub first: Span,\n@@ -616,14 +604,14 @@ pub(crate) struct BracesForStructLiteral {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n pub(crate) struct NoFieldsForFnCall {\n     #[suggestion_part(code = \"\")]\n     pub fields: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::labeled_loop_in_break)]\n+#[diag(parser_labeled_loop_in_break)]\n pub(crate) struct LabeledLoopInBreak {\n     #[primary_span]\n     pub span: Span,\n@@ -633,7 +621,7 @@ pub(crate) struct LabeledLoopInBreak {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(\n-    parser::sugg_wrap_expression_in_parentheses,\n+    parser_sugg_wrap_expression_in_parentheses,\n     applicability = \"machine-applicable\"\n )]\n pub(crate) struct WrapExpressionInParentheses {\n@@ -644,7 +632,7 @@ pub(crate) struct WrapExpressionInParentheses {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::array_brackets_instead_of_braces)]\n+#[diag(parser_array_brackets_instead_of_braces)]\n pub(crate) struct ArrayBracketsInsteadOfSpaces {\n     #[primary_span]\n     pub span: Span,\n@@ -653,7 +641,7 @@ pub(crate) struct ArrayBracketsInsteadOfSpaces {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n     #[suggestion_part(code = \"[\")]\n     pub left: Span,\n@@ -662,12 +650,12 @@ pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::match_arm_body_without_braces)]\n+#[diag(parser_match_arm_body_without_braces)]\n pub(crate) struct MatchArmBodyWithoutBraces {\n     #[primary_span]\n-    #[label(parser::label_statements)]\n+    #[label(label_statements)]\n     pub statements: Span,\n-    #[label(parser::label_arrow)]\n+    #[label(label_arrow)]\n     pub arrow: Span,\n     pub num_statements: usize,\n     #[subdiagnostic]\n@@ -676,15 +664,15 @@ pub(crate) struct MatchArmBodyWithoutBraces {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum MatchArmBodyWithoutBracesSugg {\n-    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion_add_braces, applicability = \"machine-applicable\")]\n     AddBraces {\n         #[suggestion_part(code = \"{{ \")]\n         left: Span,\n         #[suggestion_part(code = \" }}\")]\n         right: Span,\n     },\n     #[suggestion(\n-        parser::suggestion_use_comma_not_semicolon,\n+        suggestion_use_comma_not_semicolon,\n         code = \",\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -695,7 +683,7 @@ pub(crate) enum MatchArmBodyWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::struct_literal_not_allowed_here)]\n+#[diag(parser_struct_literal_not_allowed_here)]\n pub(crate) struct StructLiteralNotAllowedHere {\n     #[primary_span]\n     pub span: Span,\n@@ -704,7 +692,7 @@ pub(crate) struct StructLiteralNotAllowedHere {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct StructLiteralNotAllowedHereSugg {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -713,38 +701,38 @@ pub(crate) struct StructLiteralNotAllowedHereSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_interpolated_expression)]\n+#[diag(parser_invalid_interpolated_expression)]\n pub(crate) struct InvalidInterpolatedExpression {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::hexadecimal_float_literal_not_supported)]\n+#[diag(parser_hexadecimal_float_literal_not_supported)]\n pub(crate) struct HexadecimalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::octal_float_literal_not_supported)]\n+#[diag(parser_octal_float_literal_not_supported)]\n pub(crate) struct OctalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::binary_float_literal_not_supported)]\n+#[diag(parser_binary_float_literal_not_supported)]\n pub(crate) struct BinaryFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix)]\n+#[diag(parser_invalid_literal_suffix)]\n pub(crate) struct InvalidLiteralSuffix {\n     #[primary_span]\n     #[label]\n@@ -755,42 +743,42 @@ pub(crate) struct InvalidLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix_on_tuple_index)]\n+#[diag(parser_invalid_literal_suffix_on_tuple_index)]\n pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub suffix: Symbol,\n-    #[help(parser::tuple_exception_line_1)]\n-    #[help(parser::tuple_exception_line_2)]\n-    #[help(parser::tuple_exception_line_3)]\n+    #[help(tuple_exception_line_1)]\n+    #[help(tuple_exception_line_2)]\n+    #[help(tuple_exception_line_3)]\n     pub exception: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::non_string_abi_literal)]\n+#[diag(parser_non_string_abi_literal)]\n pub(crate) struct NonStringAbiLiteral {\n     #[primary_span]\n     #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::mismatched_closing_delimiter)]\n+#[diag(parser_mismatched_closing_delimiter)]\n pub(crate) struct MismatchedClosingDelimiter {\n     #[primary_span]\n     pub spans: Vec<Span>,\n     pub delimiter: String,\n-    #[label(parser::label_unmatched)]\n+    #[label(label_unmatched)]\n     pub unmatched: Span,\n-    #[label(parser::label_opening_candidate)]\n+    #[label(label_opening_candidate)]\n     pub opening_candidate: Option<Span>,\n-    #[label(parser::label_unclosed)]\n+    #[label(label_unclosed)]\n     pub unclosed: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_visibility_restriction, code = \"E0704\")]\n+#[diag(parser_incorrect_visibility_restriction, code = \"E0704\")]\n #[help]\n pub(crate) struct IncorrectVisibilityRestriction {\n     #[primary_span]\n@@ -800,21 +788,21 @@ pub(crate) struct IncorrectVisibilityRestriction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::assignment_else_not_allowed)]\n+#[diag(parser_assignment_else_not_allowed)]\n pub(crate) struct AssignmentElseNotAllowed {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_statement_after_outer_attr)]\n+#[diag(parser_expected_statement_after_outer_attr)]\n pub(crate) struct ExpectedStatementAfterOuterAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::doc_comment_does_not_document_anything, code = \"E0585\")]\n+#[diag(parser_doc_comment_does_not_document_anything, code = \"E0585\")]\n #[help]\n pub(crate) struct DocCommentDoesNotDocumentAnything {\n     #[primary_span]\n@@ -824,15 +812,15 @@ pub(crate) struct DocCommentDoesNotDocumentAnything {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::const_let_mutually_exclusive)]\n+#[diag(parser_const_let_mutually_exclusive)]\n pub(crate) struct ConstLetMutuallyExclusive {\n     #[primary_span]\n     #[suggestion(code = \"const\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_expression_in_let_else)]\n+#[diag(parser_invalid_expression_in_let_else)]\n pub(crate) struct InvalidExpressionInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -842,7 +830,7 @@ pub(crate) struct InvalidExpressionInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_curly_in_let_else)]\n+#[diag(parser_invalid_curly_in_let_else)]\n pub(crate) struct InvalidCurlyInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -851,7 +839,7 @@ pub(crate) struct InvalidCurlyInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::compound_assignment_expression_in_let)]\n+#[diag(parser_compound_assignment_expression_in_let)]\n #[help]\n pub(crate) struct CompoundAssignmentExpressionInLet {\n     #[primary_span]\n@@ -860,15 +848,15 @@ pub(crate) struct CompoundAssignmentExpressionInLet {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::suffixed_literal_in_attribute)]\n+#[diag(parser_suffixed_literal_in_attribute)]\n #[help]\n pub(crate) struct SuffixedLiteralInAttribute {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_meta_item)]\n+#[diag(parser_invalid_meta_item)]\n pub(crate) struct InvalidMetaItem {\n     #[primary_span]\n     pub span: Span,\n@@ -877,7 +865,7 @@ pub(crate) struct InvalidMetaItem {\n \n #[derive(Subdiagnostic)]\n #[suggestion_verbose(\n-    parser::sugg_escape_to_use_as_identifier,\n+    parser_sugg_escape_to_use_as_identifier,\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n )]\n@@ -888,23 +876,23 @@ pub(crate) struct SuggEscapeToUseAsIdentifier {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n+#[suggestion(parser_sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n pub(crate) struct SuggRemoveComma {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedIdentifierFound {\n-    #[label(parser::expected_identifier_found_reserved_identifier)]\n+    #[label(parser_expected_identifier_found_reserved_identifier)]\n     ReservedIdentifier(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_keyword)]\n+    #[label(parser_expected_identifier_found_keyword)]\n     Keyword(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_reserved_keyword)]\n+    #[label(parser_expected_identifier_found_reserved_keyword)]\n     ReservedKeyword(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_doc_comment)]\n+    #[label(parser_expected_identifier_found_doc_comment)]\n     DocComment(#[primary_span] Span),\n-    #[label(parser::expected_identifier)]\n+    #[label(parser_expected_identifier)]\n     Other(#[primary_span] Span),\n }\n \n@@ -938,18 +926,16 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser::expected_identifier_found_reserved_identifier_str\n-            }\n-            Some(TokenDescription::Keyword) => {\n-                fluent::parser::expected_identifier_found_keyword_str\n+                fluent::parser_expected_identifier_found_reserved_identifier_str\n             }\n+            Some(TokenDescription::Keyword) => fluent::parser_expected_identifier_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser::expected_identifier_found_reserved_keyword_str\n+                fluent::parser_expected_identifier_found_reserved_keyword_str\n             }\n             Some(TokenDescription::DocComment) => {\n-                fluent::parser::expected_identifier_found_doc_comment_str\n+                fluent::parser_expected_identifier_found_doc_comment_str\n             }\n-            None => fluent::parser::expected_identifier_found_str,\n+            None => fluent::parser_expected_identifier_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n@@ -985,22 +971,22 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser::expected_semi_found_reserved_identifier_str\n+                fluent::parser_expected_semi_found_reserved_identifier_str\n             }\n-            Some(TokenDescription::Keyword) => fluent::parser::expected_semi_found_keyword_str,\n+            Some(TokenDescription::Keyword) => fluent::parser_expected_semi_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser::expected_semi_found_reserved_keyword_str\n+                fluent::parser_expected_semi_found_reserved_keyword_str\n             }\n             Some(TokenDescription::DocComment) => {\n-                fluent::parser::expected_semi_found_doc_comment_str\n+                fluent::parser_expected_semi_found_doc_comment_str\n             }\n-            None => fluent::parser::expected_semi_found_str,\n+            None => fluent::parser_expected_semi_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n \n         if let Some(unexpected_token_label) = self.unexpected_token_label {\n-            diag.span_label(unexpected_token_label, fluent::parser::label_unexpected_token);\n+            diag.span_label(unexpected_token_label, fluent::parser_label_unexpected_token);\n         }\n \n         self.sugg.add_to_diagnostic(&mut diag);\n@@ -1012,17 +998,17 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedSemiSugg {\n     #[suggestion(\n-        parser::sugg_change_this_to_semi,\n+        parser_sugg_change_this_to_semi,\n         code = \";\",\n         applicability = \"machine-applicable\"\n     )]\n     ChangeToSemi(#[primary_span] Span),\n-    #[suggestion_short(parser::sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n+    #[suggestion_short(parser_sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n     AddSemi(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::struct_literal_body_without_path)]\n+#[diag(parser_struct_literal_body_without_path)]\n pub(crate) struct StructLiteralBodyWithoutPath {\n     #[primary_span]\n     pub span: Span,\n@@ -1031,7 +1017,7 @@ pub(crate) struct StructLiteralBodyWithoutPath {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"has-placeholders\")]\n+#[multipart_suggestion(suggestion, applicability = \"has-placeholders\")]\n pub(crate) struct StructLiteralBodyWithoutPathSugg {\n     #[suggestion_part(code = \"{{ SomeStruct \")]\n     pub before: Span,\n@@ -1040,7 +1026,7 @@ pub(crate) struct StructLiteralBodyWithoutPathSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unmatched_angle_brackets)]\n+#[diag(parser_unmatched_angle_brackets)]\n pub(crate) struct UnmatchedAngleBrackets {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n@@ -1049,7 +1035,7 @@ pub(crate) struct UnmatchedAngleBrackets {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::generic_parameters_without_angle_brackets)]\n+#[diag(parser_generic_parameters_without_angle_brackets)]\n pub(crate) struct GenericParamsWithoutAngleBrackets {\n     #[primary_span]\n     pub span: Span,\n@@ -1058,7 +1044,7 @@ pub(crate) struct GenericParamsWithoutAngleBrackets {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n     #[suggestion_part(code = \"<\")]\n     pub left: Span,\n@@ -1067,18 +1053,18 @@ pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comparison_operators_cannot_be_chained)]\n+#[diag(parser_comparison_operators_cannot_be_chained)]\n pub(crate) struct ComparisonOperatorsCannotBeChained {\n     #[primary_span]\n     pub span: Vec<Span>,\n     #[suggestion_verbose(\n-        parser::sugg_turbofish_syntax,\n+        parser_sugg_turbofish_syntax,\n         code = \"::\",\n         applicability = \"maybe-incorrect\"\n     )]\n     pub suggest_turbofish: Option<Span>,\n-    #[help(parser::sugg_turbofish_syntax)]\n-    #[help(parser::sugg_parentheses_for_function_args)]\n+    #[help(parser_sugg_turbofish_syntax)]\n+    #[help(sugg_parentheses_for_function_args)]\n     pub help_turbofish: Option<()>,\n     #[subdiagnostic]\n     pub chaining_sugg: Option<ComparisonOperatorsCannotBeChainedSugg>,\n@@ -1087,7 +1073,7 @@ pub(crate) struct ComparisonOperatorsCannotBeChained {\n #[derive(Subdiagnostic)]\n pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n     #[suggestion_verbose(\n-        parser::sugg_split_comparison,\n+        sugg_split_comparison,\n         code = \" && {middle_term}\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -1096,7 +1082,7 @@ pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n         span: Span,\n         middle_term: String,\n     },\n-    #[multipart_suggestion(parser::sugg_parenthesize, applicability = \"maybe-incorrect\")]\n+    #[multipart_suggestion(sugg_parenthesize, applicability = \"maybe-incorrect\")]\n     Parenthesize {\n         #[suggestion_part(code = \"(\")]\n         left: Span,\n@@ -1106,7 +1092,7 @@ pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::question_mark_in_type)]\n+#[diag(parser_question_mark_in_type)]\n pub(crate) struct QuestionMarkInType {\n     #[primary_span]\n     #[label]\n@@ -1116,7 +1102,7 @@ pub(crate) struct QuestionMarkInType {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct QuestionMarkInTypeSugg {\n     #[suggestion_part(code = \"Option<\")]\n     pub left: Span,\n@@ -1125,7 +1111,7 @@ pub(crate) struct QuestionMarkInTypeSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_parentheses_in_for_head)]\n+#[diag(parser_unexpected_parentheses_in_for_head)]\n pub(crate) struct ParenthesesInForHead {\n     #[primary_span]\n     pub span: Vec<Span>,\n@@ -1134,7 +1120,7 @@ pub(crate) struct ParenthesesInForHead {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ParenthesesInForHeadSugg {\n     #[suggestion_part(code = \"\")]\n     pub left: Span,\n@@ -1143,39 +1129,39 @@ pub(crate) struct ParenthesesInForHeadSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::doc_comment_on_param_type)]\n+#[diag(parser_doc_comment_on_param_type)]\n pub(crate) struct DocCommentOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::attribute_on_param_type)]\n+#[diag(parser_attribute_on_param_type)]\n pub(crate) struct AttributeOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::pattern_method_param_without_body, code = \"E0642\")]\n+#[diag(parser_pattern_method_param_without_body, code = \"E0642\")]\n pub(crate) struct PatternMethodParamWithoutBody {\n     #[primary_span]\n     #[suggestion(code = \"_\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::self_param_not_first)]\n+#[diag(parser_self_param_not_first)]\n pub(crate) struct SelfParamNotFirst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::const_generic_without_braces)]\n+#[diag(parser_const_generic_without_braces)]\n pub(crate) struct ConstGenericWithoutBraces {\n     #[primary_span]\n     pub span: Span,\n@@ -1184,7 +1170,7 @@ pub(crate) struct ConstGenericWithoutBraces {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ConstGenericWithoutBracesSugg {\n     #[suggestion_part(code = \"{{ \")]\n     pub left: Span,\n@@ -1193,7 +1179,7 @@ pub(crate) struct ConstGenericWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_const_param_declaration)]\n+#[diag(parser_unexpected_const_param_declaration)]\n pub(crate) struct UnexpectedConstParamDeclaration {\n     #[primary_span]\n     #[label]\n@@ -1204,7 +1190,7 @@ pub(crate) struct UnexpectedConstParamDeclaration {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum UnexpectedConstParamDeclarationSugg {\n-    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n     AddParam {\n         #[suggestion_part(code = \"<{snippet}>\")]\n         impl_generics: Span,\n@@ -1213,7 +1199,7 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n         snippet: String,\n         ident: String,\n     },\n-    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n     AppendParam {\n         #[suggestion_part(code = \", {snippet}\")]\n         impl_generics_end: Span,\n@@ -1225,7 +1211,7 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_const_in_generic_param)]\n+#[diag(parser_unexpected_const_in_generic_param)]\n pub(crate) struct UnexpectedConstInGenericParam {\n     #[primary_span]\n     pub span: Span,\n@@ -1234,15 +1220,15 @@ pub(crate) struct UnexpectedConstInGenericParam {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::async_move_order_incorrect)]\n+#[diag(parser_async_move_order_incorrect)]\n pub(crate) struct AsyncMoveOrderIncorrect {\n     #[primary_span]\n     #[suggestion_verbose(code = \"async move\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::double_colon_in_bound)]\n+#[diag(parser_double_colon_in_bound)]\n pub(crate) struct DoubleColonInBound {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "9e45656946b34fe9f86075c103b1cab51a6469dd", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n                     let span = self.token.span;\n                     let mut err = self.sess.span_diagnostic.struct_span_err_with_code(\n                         span,\n-                        fluent::parser::inner_doc_comment_not_permitted,\n+                        fluent::parser_inner_doc_comment_not_permitted,\n                         error_code!(E0753),\n                     );\n                     if let Some(replacement_span) = self.annotate_following_item_if_applicable(\n@@ -66,10 +66,10 @@ impl<'a> Parser<'a> {\n                             token::CommentKind::Block => OuterAttributeType::DocBlockComment,\n                         },\n                     ) {\n-                        err.note(fluent::parser::note);\n+                        err.note(fluent::note);\n                         err.span_suggestion_verbose(\n                             replacement_span,\n-                            fluent::parser::suggestion,\n+                            fluent::suggestion,\n                             \"\",\n                             rustc_errors::Applicability::MachineApplicable,\n                         );\n@@ -173,10 +173,10 @@ impl<'a> Parser<'a> {\n             Ok(Some(item)) => {\n                 // FIXME(#100717)\n                 err.set_arg(\"item\", item.kind.descr());\n-                err.span_label(item.span, fluent::parser::label_does_not_annotate_this);\n+                err.span_label(item.span, fluent::label_does_not_annotate_this);\n                 err.span_suggestion_verbose(\n                     replacement_span,\n-                    fluent::parser::sugg_change_inner_to_outer,\n+                    fluent::sugg_change_inner_to_outer,\n                     match attr_type {\n                         OuterAttributeType::Attribute => \"\",\n                         OuterAttributeType::DocBlockComment => \"*\",\n@@ -200,27 +200,27 @@ impl<'a> Parser<'a> {\n                 Some(InnerAttrForbiddenReason::AfterOuterDocComment { prev_doc_comment_span }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser::inner_attr_not_permitted_after_outer_doc_comment,\n+                        fluent::parser_inner_attr_not_permitted_after_outer_doc_comment,\n                     );\n-                    diag.span_label(attr_sp, fluent::parser::label_attr)\n-                        .span_label(prev_doc_comment_span, fluent::parser::label_prev_doc_comment);\n+                    diag.span_label(attr_sp, fluent::label_attr)\n+                        .span_label(prev_doc_comment_span, fluent::label_prev_doc_comment);\n                     diag\n                 }\n                 Some(InnerAttrForbiddenReason::AfterOuterAttribute { prev_outer_attr_sp }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser::inner_attr_not_permitted_after_outer_attr,\n+                        fluent::parser_inner_attr_not_permitted_after_outer_attr,\n                     );\n-                    diag.span_label(attr_sp, fluent::parser::label_attr)\n-                        .span_label(prev_outer_attr_sp, fluent::parser::label_prev_attr);\n+                    diag.span_label(attr_sp, fluent::label_attr)\n+                        .span_label(prev_outer_attr_sp, fluent::label_prev_attr);\n                     diag\n                 }\n                 Some(InnerAttrForbiddenReason::InCodeBlock) | None => {\n-                    self.struct_span_err(attr_sp, fluent::parser::inner_attr_not_permitted)\n+                    self.struct_span_err(attr_sp, fluent::parser_inner_attr_not_permitted)\n                 }\n             };\n \n-            diag.note(fluent::parser::inner_attr_explanation);\n+            diag.note(fluent::parser_inner_attr_explanation);\n             if self\n                 .annotate_following_item_if_applicable(\n                     &mut diag,\n@@ -229,7 +229,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .is_some()\n             {\n-                diag.note(fluent::parser::outer_attr_explanation);\n+                diag.note(fluent::parser_outer_attr_explanation);\n             };\n             diag.emit();\n         }"}, {"sha": "887a4a6de33b1c3d7722763c63a7de85bf0c44b6", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -926,7 +926,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Gt) {\n                         e.span_suggestion_verbose(\n                             binop.span.shrink_to_lo(),\n-                            fluent::parser::sugg_turbofish_syntax,\n+                            fluent::parser_sugg_turbofish_syntax,\n                             \"::\",\n                             Applicability::MaybeIncorrect,\n                         )"}, {"sha": "b19e85427e729d01e93c580b67bd17a6444deae3", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -822,8 +822,8 @@ impl CheckAttrVisitor<'_> {\n             if let Some((prev_inline, prev_span)) = *specified_inline {\n                 if do_inline != prev_inline {\n                     let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, fluent::passes::doc_inline_conflict_first);\n-                    spans.push_span_label(meta.span(), fluent::passes::doc_inline_conflict_second);\n+                    spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n+                    spans.push_span_label(meta.span(), fluent::passes_doc_inline_conflict_second);\n                     self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n                     return false;\n                 }\n@@ -873,7 +873,7 @@ impl CheckAttrVisitor<'_> {\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                fluent::passes::attr_crate_level,\n+                fluent::passes_attr_crate_level,\n                 |err| {\n                     if attr.style == AttrStyle::Outer\n                         && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n@@ -882,15 +882,15 @@ impl CheckAttrVisitor<'_> {\n                             src.insert(1, '!');\n                             err.span_suggestion_verbose(\n                                 attr.span,\n-                                fluent::passes::suggestion,\n+                                fluent::suggestion,\n                                 src,\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n-                            err.span_help(attr.span, fluent::passes::help);\n+                            err.span_help(attr.span, fluent::help);\n                         }\n                     }\n-                    err.note(fluent::passes::note);\n+                    err.note(fluent::note);\n                     err\n                 },\n             );"}, {"sha": "adaaf5392425b6805b454ca4acc914484fb7b4d0", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 200, "deletions": 201, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -13,37 +13,37 @@ use rustc_span::{Span, Symbol, DUMMY_SP};\n use crate::lang_items::Duplicate;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::outer_crate_level_attr)]\n+#[diag(passes_outer_crate_level_attr)]\n pub struct OuterCrateLevelAttr;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inner_crate_level_attr)]\n+#[diag(passes_inner_crate_level_attr)]\n pub struct InnerCrateLevelAttr;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::ignored_attr_with_macro)]\n+#[diag(passes_ignored_attr_with_macro)]\n pub struct IgnoredAttrWithMacro<'a> {\n     pub sym: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::ignored_attr)]\n+#[diag(passes_ignored_attr)]\n pub struct IgnoredAttr<'a> {\n     pub sym: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inline_ignored_function_prototype)]\n+#[diag(passes_inline_ignored_function_prototype)]\n pub struct IgnoredInlineAttrFnProto;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inline_ignored_constants)]\n+#[diag(passes_inline_ignored_constants)]\n #[warning]\n #[note]\n pub struct IgnoredInlineAttrConstants;\n \n #[derive(Diagnostic)]\n-#[diag(passes::inline_not_fn_or_closure, code = \"E0518\")]\n+#[diag(passes_inline_not_fn_or_closure, code = \"E0518\")]\n pub struct InlineNotFnOrClosure {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -52,19 +52,19 @@ pub struct InlineNotFnOrClosure {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_ignored_function_prototype)]\n+#[diag(passes_no_coverage_ignored_function_prototype)]\n pub struct IgnoredNoCoverageFnProto;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_propagate)]\n+#[diag(passes_no_coverage_propagate)]\n pub struct IgnoredNoCoveragePropagate;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_fn_defn)]\n+#[diag(passes_no_coverage_fn_defn)]\n pub struct IgnoredNoCoverageFnDefn;\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_coverage_not_coverable, code = \"E0788\")]\n+#[diag(passes_no_coverage_not_coverable, code = \"E0788\")]\n pub struct IgnoredNoCoverageNotCoverable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -73,7 +73,7 @@ pub struct IgnoredNoCoverageNotCoverable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_fn)]\n+#[diag(passes_should_be_applied_to_fn)]\n pub struct AttrShouldBeAppliedToFn {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -82,14 +82,14 @@ pub struct AttrShouldBeAppliedToFn {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_tracked_caller, code = \"E0736\")]\n+#[diag(passes_naked_tracked_caller, code = \"E0736\")]\n pub struct NakedTrackedCaller {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_fn, code = \"E0739\")]\n+#[diag(passes_should_be_applied_to_fn, code = \"E0739\")]\n pub struct TrackedCallerWrongLocation {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -98,7 +98,7 @@ pub struct TrackedCallerWrongLocation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_struct_enum, code = \"E0701\")]\n+#[diag(passes_should_be_applied_to_struct_enum, code = \"E0701\")]\n pub struct NonExhaustiveWrongLocation {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -107,7 +107,7 @@ pub struct NonExhaustiveWrongLocation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_trait)]\n+#[diag(passes_should_be_applied_to_trait)]\n pub struct AttrShouldBeAppliedToTrait {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -116,11 +116,11 @@ pub struct AttrShouldBeAppliedToTrait {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::target_feature_on_statement)]\n+#[diag(passes_target_feature_on_statement)]\n pub struct TargetFeatureOnStatement;\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_static)]\n+#[diag(passes_should_be_applied_to_static)]\n pub struct AttrShouldBeAppliedToStatic {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -129,23 +129,23 @@ pub struct AttrShouldBeAppliedToStatic {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_expect_str)]\n+#[diag(passes_doc_expect_str)]\n pub struct DocExpectStr<'a> {\n     #[primary_span]\n     pub attr_span: Span,\n     pub attr_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_empty)]\n+#[diag(passes_doc_alias_empty)]\n pub struct DocAliasEmpty<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_bad_char)]\n+#[diag(passes_doc_alias_bad_char)]\n pub struct DocAliasBadChar<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -154,15 +154,15 @@ pub struct DocAliasBadChar<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_start_end)]\n+#[diag(passes_doc_alias_start_end)]\n pub struct DocAliasStartEnd<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_bad_location)]\n+#[diag(passes_doc_alias_bad_location)]\n pub struct DocAliasBadLocation<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -171,132 +171,132 @@ pub struct DocAliasBadLocation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_not_an_alias)]\n+#[diag(passes_doc_alias_not_an_alias)]\n pub struct DocAliasNotAnAlias<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_alias_duplicated)]\n+#[diag(passes_doc_alias_duplicated)]\n pub struct DocAliasDuplicated {\n     #[label]\n     pub first_defn: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_not_string_literal)]\n+#[diag(passes_doc_alias_not_string_literal)]\n pub struct DocAliasNotStringLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_malformed)]\n+#[diag(passes_doc_alias_malformed)]\n pub struct DocAliasMalformed {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_empty_mod)]\n+#[diag(passes_doc_keyword_empty_mod)]\n pub struct DocKeywordEmptyMod {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_not_mod)]\n+#[diag(passes_doc_keyword_not_mod)]\n pub struct DocKeywordNotMod {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_invalid_ident)]\n+#[diag(passes_doc_keyword_invalid_ident)]\n pub struct DocKeywordInvalidIdent {\n     #[primary_span]\n     pub span: Span,\n     pub doc_keyword: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_fake_variadic_not_valid)]\n+#[diag(passes_doc_fake_variadic_not_valid)]\n pub struct DocFakeVariadicNotValid {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_only_impl)]\n+#[diag(passes_doc_keyword_only_impl)]\n pub struct DocKeywordOnlyImpl {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_inline_conflict)]\n+#[diag(passes_doc_inline_conflict)]\n #[help]\n pub struct DocKeywordConflict {\n     #[primary_span]\n     pub spans: MultiSpan,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_inline_only_use)]\n+#[diag(passes_doc_inline_only_use)]\n #[note]\n pub struct DocInlineOnlyUse {\n     #[label]\n     pub attr_span: Span,\n-    #[label(passes::not_a_use_item_label)]\n+    #[label(not_a_use_item_label)]\n     pub item_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_attr_not_crate_level)]\n+#[diag(passes_doc_attr_not_crate_level)]\n pub struct DocAttrNotCrateLevel<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_name: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown)]\n+#[diag(passes_doc_test_unknown)]\n pub struct DocTestUnknown {\n     pub path: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_takes_list)]\n+#[diag(passes_doc_test_takes_list)]\n pub struct DocTestTakesList;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_cfg_hide_takes_list)]\n+#[diag(passes_doc_cfg_hide_takes_list)]\n pub struct DocCfgHideTakesList;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_primitive)]\n+#[diag(passes_doc_primitive)]\n pub struct DocPrimitive;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_any)]\n+#[diag(passes_doc_test_unknown_any)]\n pub struct DocTestUnknownAny {\n     pub path: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_spotlight)]\n+#[diag(passes_doc_test_unknown_spotlight)]\n #[note]\n-#[note(passes::no_op_note)]\n+#[note(no_op_note)]\n pub struct DocTestUnknownSpotlight {\n     pub path: String,\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"notable_trait\")]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_include)]\n+#[diag(passes_doc_test_unknown_include)]\n pub struct DocTestUnknownInclude {\n     pub path: String,\n     pub value: String,\n@@ -306,11 +306,11 @@ pub struct DocTestUnknownInclude {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_invalid)]\n+#[diag(passes_doc_invalid)]\n pub struct DocInvalid;\n \n #[derive(Diagnostic)]\n-#[diag(passes::pass_by_value)]\n+#[diag(passes_pass_by_value)]\n pub struct PassByValue {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -319,7 +319,7 @@ pub struct PassByValue {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::allow_incoherent_impl)]\n+#[diag(passes_allow_incoherent_impl)]\n pub struct AllowIncoherentImpl {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -328,7 +328,7 @@ pub struct AllowIncoherentImpl {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::has_incoherent_inherent_impl)]\n+#[diag(passes_has_incoherent_inherent_impl)]\n pub struct HasIncoherentInherentImpl {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -337,21 +337,21 @@ pub struct HasIncoherentInherentImpl {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::must_use_async)]\n+#[diag(passes_must_use_async)]\n pub struct MustUseAsync {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::must_use_no_effect)]\n+#[diag(passes_must_use_no_effect)]\n pub struct MustUseNoEffect {\n     pub article: &'static str,\n     pub target: rustc_hir::Target,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::must_not_suspend)]\n+#[diag(passes_must_not_suspend)]\n pub struct MustNotSuspend {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -360,23 +360,23 @@ pub struct MustNotSuspend {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::cold)]\n+#[diag(passes_cold)]\n #[warning]\n pub struct Cold {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link)]\n+#[diag(passes_link)]\n #[warning]\n pub struct Link {\n     #[label]\n     pub span: Option<Span>,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link_name)]\n+#[diag(passes_link_name)]\n #[warning]\n pub struct LinkName<'a> {\n     #[help]\n@@ -387,7 +387,7 @@ pub struct LinkName<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_link)]\n+#[diag(passes_no_link)]\n pub struct NoLink {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -396,7 +396,7 @@ pub struct NoLink {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::export_name)]\n+#[diag(passes_export_name)]\n pub struct ExportName {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -405,7 +405,7 @@ pub struct ExportName {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_layout_scalar_valid_range_not_struct)]\n+#[diag(passes_rustc_layout_scalar_valid_range_not_struct)]\n pub struct RustcLayoutScalarValidRangeNotStruct {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -414,14 +414,14 @@ pub struct RustcLayoutScalarValidRangeNotStruct {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_layout_scalar_valid_range_arg)]\n+#[diag(passes_rustc_layout_scalar_valid_range_arg)]\n pub struct RustcLayoutScalarValidRangeArg {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_only)]\n+#[diag(passes_rustc_legacy_const_generics_only)]\n pub struct RustcLegacyConstGenericsOnly {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -430,7 +430,7 @@ pub struct RustcLegacyConstGenericsOnly {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index)]\n+#[diag(passes_rustc_legacy_const_generics_index)]\n pub struct RustcLegacyConstGenericsIndex {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -439,7 +439,7 @@ pub struct RustcLegacyConstGenericsIndex {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index_exceed)]\n+#[diag(passes_rustc_legacy_const_generics_index_exceed)]\n pub struct RustcLegacyConstGenericsIndexExceed {\n     #[primary_span]\n     #[label]\n@@ -448,29 +448,29 @@ pub struct RustcLegacyConstGenericsIndexExceed {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index_negative)]\n+#[diag(passes_rustc_legacy_const_generics_index_negative)]\n pub struct RustcLegacyConstGenericsIndexNegative {\n     #[primary_span]\n     pub invalid_args: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_dirty_clean)]\n+#[diag(passes_rustc_dirty_clean)]\n pub struct RustcDirtyClean {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link_section)]\n+#[diag(passes_link_section)]\n #[warning]\n pub struct LinkSection {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_mangle_foreign)]\n+#[diag(passes_no_mangle_foreign)]\n #[warning]\n #[note]\n pub struct NoMangleForeign {\n@@ -482,40 +482,40 @@ pub struct NoMangleForeign {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_mangle)]\n+#[diag(passes_no_mangle)]\n #[warning]\n pub struct NoMangle {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::repr_ident, code = \"E0565\")]\n+#[diag(passes_repr_ident, code = \"E0565\")]\n pub struct ReprIdent {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::repr_conflicting, code = \"E0566\")]\n+#[diag(passes_repr_conflicting, code = \"E0566\")]\n pub struct ReprConflicting;\n \n #[derive(Diagnostic)]\n-#[diag(passes::used_static)]\n+#[diag(passes_used_static)]\n pub struct UsedStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::used_compiler_linker)]\n+#[diag(passes_used_compiler_linker)]\n pub struct UsedCompilerLinker {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::allow_internal_unstable)]\n+#[diag(passes_allow_internal_unstable)]\n pub struct AllowInternalUnstable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -524,24 +524,24 @@ pub struct AllowInternalUnstable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_placement)]\n+#[diag(passes_debug_visualizer_placement)]\n pub struct DebugVisualizerPlacement {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_invalid)]\n-#[note(passes::note_1)]\n-#[note(passes::note_2)]\n-#[note(passes::note_3)]\n+#[diag(passes_debug_visualizer_invalid)]\n+#[note(note_1)]\n+#[note(note_2)]\n+#[note(note_3)]\n pub struct DebugVisualizerInvalid {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_unreadable)]\n+#[diag(passes_debug_visualizer_unreadable)]\n pub struct DebugVisualizerUnreadable<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -550,7 +550,7 @@ pub struct DebugVisualizerUnreadable<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_allow_const_fn_unstable)]\n+#[diag(passes_rustc_allow_const_fn_unstable)]\n pub struct RustcAllowConstFnUnstable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -559,7 +559,7 @@ pub struct RustcAllowConstFnUnstable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_std_internal_symbol)]\n+#[diag(passes_rustc_std_internal_symbol)]\n pub struct RustcStdInternalSymbol {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -568,56 +568,56 @@ pub struct RustcStdInternalSymbol {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::const_trait)]\n+#[diag(passes_const_trait)]\n pub struct ConstTrait {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::link_ordinal)]\n+#[diag(passes_link_ordinal)]\n pub struct LinkOrdinal {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::stability_promotable)]\n+#[diag(passes_stability_promotable)]\n pub struct StabilityPromotable {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::deprecated)]\n+#[diag(passes_deprecated)]\n pub struct Deprecated;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::macro_use)]\n+#[diag(passes_macro_use)]\n pub struct MacroUse {\n     pub name: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::macro_export)]\n+#[diag(passes_macro_export)]\n pub struct MacroExport;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::plugin_registrar)]\n+#[diag(passes_plugin_registrar)]\n pub struct PluginRegistrar;\n \n #[derive(Subdiagnostic)]\n pub enum UnusedNote {\n-    #[note(passes::unused_empty_lints_note)]\n+    #[note(passes_unused_empty_lints_note)]\n     EmptyList { name: Symbol },\n-    #[note(passes::unused_no_lints_note)]\n+    #[note(passes_unused_no_lints_note)]\n     NoLints { name: Symbol },\n-    #[note(passes::unused_default_method_body_const_note)]\n+    #[note(passes_unused_default_method_body_const_note)]\n     DefaultMethodBodyConst,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::unused)]\n+#[diag(passes_unused)]\n pub struct Unused {\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub attr_span: Span,\n@@ -626,15 +626,15 @@ pub struct Unused {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::non_exported_macro_invalid_attrs, code = \"E0518\")]\n+#[diag(passes_non_exported_macro_invalid_attrs, code = \"E0518\")]\n pub struct NonExportedMacroInvalidAttrs {\n     #[primary_span]\n     #[label]\n     pub attr_span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::unused_duplicate)]\n+#[diag(passes_unused_duplicate)]\n pub struct UnusedDuplicate {\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub this: Span,\n@@ -645,7 +645,7 @@ pub struct UnusedDuplicate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unused_multiple)]\n+#[diag(passes_unused_multiple)]\n pub struct UnusedMultiple {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n@@ -656,7 +656,7 @@ pub struct UnusedMultiple {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_lint_opt_ty)]\n+#[diag(passes_rustc_lint_opt_ty)]\n pub struct RustcLintOptTy {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -665,7 +665,7 @@ pub struct RustcLintOptTy {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_lint_opt_deny_field_access)]\n+#[diag(passes_rustc_lint_opt_deny_field_access)]\n pub struct RustcLintOptDenyFieldAccess {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -674,7 +674,7 @@ pub struct RustcLintOptDenyFieldAccess {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::collapse_debuginfo)]\n+#[diag(passes_collapse_debuginfo)]\n pub struct CollapseDebuginfo {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -683,42 +683,42 @@ pub struct CollapseDebuginfo {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::deprecated_annotation_has_no_effect)]\n+#[diag(passes_deprecated_annotation_has_no_effect)]\n pub struct DeprecatedAnnotationHasNoEffect {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_external_lang_item, code = \"E0264\")]\n+#[diag(passes_unknown_external_lang_item, code = \"E0264\")]\n pub struct UnknownExternLangItem {\n     #[primary_span]\n     pub span: Span,\n     pub lang_item: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_panic_handler)]\n+#[diag(passes_missing_panic_handler)]\n pub struct MissingPanicHandler;\n \n #[derive(Diagnostic)]\n-#[diag(passes::alloc_func_required)]\n+#[diag(passes_alloc_func_required)]\n pub struct AllocFuncRequired;\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_alloc_error_handler)]\n+#[diag(passes_missing_alloc_error_handler)]\n pub struct MissingAllocErrorHandler;\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_lang_item)]\n+#[diag(passes_missing_lang_item)]\n #[note]\n #[help]\n pub struct MissingLangItem {\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::lang_item_on_incorrect_target, code = \"E0718\")]\n+#[diag(passes_lang_item_on_incorrect_target, code = \"E0718\")]\n pub struct LangItemOnIncorrectTarget {\n     #[primary_span]\n     #[label]\n@@ -729,7 +729,7 @@ pub struct LangItemOnIncorrectTarget {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_lang_item, code = \"E0522\")]\n+#[diag(passes_unknown_lang_item, code = \"E0522\")]\n pub struct UnknownLangItem {\n     #[primary_span]\n     #[label]\n@@ -748,8 +748,7 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag =\n-            handler.struct_err(rustc_errors::fluent::passes::invalid_attr_at_crate_level);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::passes_invalid_attr_at_crate_level);\n         diag.set_span(self.span);\n         diag.set_arg(\"name\", self.name);\n         // Only emit an error with a suggestion if we can create a string out\n@@ -758,7 +757,7 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n             let replacement = src.replace(\"#!\", \"#\");\n             diag.span_suggestion_verbose(\n                 self.span,\n-                rustc_errors::fluent::passes::suggestion,\n+                rustc_errors::fluent::suggestion,\n                 replacement,\n                 rustc_errors::Applicability::MachineApplicable,\n             );\n@@ -768,17 +767,17 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_diagnostic_item)]\n+#[diag(passes_duplicate_diagnostic_item)]\n pub struct DuplicateDiagnosticItem {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_diagnostic_item_in_crate)]\n+#[diag(passes_duplicate_diagnostic_item_in_crate)]\n pub struct DuplicateDiagnosticItemInCrate {\n-    #[note(passes::diagnostic_item_first_defined)]\n+    #[note(passes_diagnostic_item_first_defined)]\n     pub span: Option<Span>,\n     pub orig_crate_name: Symbol,\n     #[note]\n@@ -788,39 +787,39 @@ pub struct DuplicateDiagnosticItemInCrate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::abi)]\n+#[diag(passes_abi)]\n pub struct Abi {\n     #[primary_span]\n     pub span: Span,\n     pub abi: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::align)]\n+#[diag(passes_align)]\n pub struct Align {\n     #[primary_span]\n     pub span: Span,\n     pub align: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::size)]\n+#[diag(passes_size)]\n pub struct Size {\n     #[primary_span]\n     pub span: Span,\n     pub size: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::homogeneous_aggregate)]\n+#[diag(passes_homogeneous_aggregate)]\n pub struct HomogeneousAggregate {\n     #[primary_span]\n     pub span: Span,\n     pub homogeneous_aggregate: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::layout_of)]\n+#[diag(passes_layout_of)]\n pub struct LayoutOf {\n     #[primary_span]\n     pub span: Span,\n@@ -829,15 +828,15 @@ pub struct LayoutOf {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unrecognized_field)]\n+#[diag(passes_unrecognized_field)]\n pub struct UnrecognizedField {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_stable_twice, code = \"E0711\")]\n+#[diag(passes_feature_stable_twice, code = \"E0711\")]\n pub struct FeatureStableTwice {\n     #[primary_span]\n     pub span: Span,\n@@ -847,7 +846,7 @@ pub struct FeatureStableTwice {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_previously_declared, code = \"E0711\")]\n+#[diag(passes_feature_previously_declared, code = \"E0711\")]\n pub struct FeaturePreviouslyDeclared<'a, 'b> {\n     #[primary_span]\n     pub span: Span,\n@@ -857,7 +856,7 @@ pub struct FeaturePreviouslyDeclared<'a, 'b> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::expr_not_allowed_in_context, code = \"E0744\")]\n+#[diag(passes_expr_not_allowed_in_context, code = \"E0744\")]\n pub struct ExprNotAllowedInContext<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -883,17 +882,17 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::passes::break_non_loop,\n+            rustc_errors::fluent::passes_break_non_loop,\n             error_code!(E0571),\n         );\n         diag.set_arg(\"kind\", self.kind);\n-        diag.span_label(self.span, rustc_errors::fluent::passes::label);\n+        diag.span_label(self.span, rustc_errors::fluent::label);\n         if let Some(head) = self.head {\n-            diag.span_label(head, rustc_errors::fluent::passes::label2);\n+            diag.span_label(head, rustc_errors::fluent::label2);\n         }\n         diag.span_suggestion(\n             self.span,\n-            rustc_errors::fluent::passes::suggestion,\n+            rustc_errors::fluent::suggestion,\n             self.suggestion,\n             Applicability::MaybeIncorrect,\n         );\n@@ -911,7 +910,7 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n                 _ => {\n                     diag.span_suggestion(\n                         self.break_expr_span,\n-                        rustc_errors::fluent::passes::break_expr_suggestion,\n+                        rustc_errors::fluent::break_expr_suggestion,\n                         label.ident,\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -923,39 +922,39 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::continue_labeled_block, code = \"E0696\")]\n+#[diag(passes_continue_labeled_block, code = \"E0696\")]\n pub struct ContinueLabeledBlock {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::block_label)]\n+    #[label(block_label)]\n     pub block_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::break_inside_closure, code = \"E0267\")]\n+#[diag(passes_break_inside_closure, code = \"E0267\")]\n pub struct BreakInsideClosure<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::closure_label)]\n+    #[label(closure_label)]\n     pub closure_span: Span,\n     pub name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::break_inside_async_block, code = \"E0267\")]\n+#[diag(passes_break_inside_async_block, code = \"E0267\")]\n pub struct BreakInsideAsyncBlock<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::async_block_label)]\n+    #[label(async_block_label)]\n     pub closure_span: Span,\n     pub name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::outside_loop, code = \"E0268\")]\n+#[diag(passes_outside_loop, code = \"E0268\")]\n pub struct OutsideLoop<'a> {\n     #[primary_span]\n     #[label]\n@@ -964,7 +963,7 @@ pub struct OutsideLoop<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unlabeled_in_labeled_block, code = \"E0695\")]\n+#[diag(passes_unlabeled_in_labeled_block, code = \"E0695\")]\n pub struct UnlabeledInLabeledBlock<'a> {\n     #[primary_span]\n     #[label]\n@@ -973,7 +972,7 @@ pub struct UnlabeledInLabeledBlock<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unlabeled_cf_in_while_condition, code = \"E0590\")]\n+#[diag(passes_unlabeled_cf_in_while_condition, code = \"E0590\")]\n pub struct UnlabeledCfInWhileCondition<'a> {\n     #[primary_span]\n     #[label]\n@@ -982,25 +981,25 @@ pub struct UnlabeledCfInWhileCondition<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::cannot_inline_naked_function)]\n+#[diag(passes_cannot_inline_naked_function)]\n pub struct CannotInlineNakedFunction {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::undefined_naked_function_abi)]\n+#[diag(passes_undefined_naked_function_abi)]\n pub struct UndefinedNakedFunctionAbi;\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_patterns)]\n+#[diag(passes_no_patterns)]\n pub struct NoPatterns {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::params_not_allowed)]\n+#[diag(passes_params_not_allowed)]\n #[help]\n pub struct ParamsNotAllowed {\n     #[primary_span]\n@@ -1020,36 +1019,36 @@ impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::passes::naked_functions_asm_block,\n+            rustc_errors::fluent::passes_naked_functions_asm_block,\n             error_code!(E0787),\n         );\n         for span in self.multiple_asms.iter() {\n-            diag.span_label(*span, rustc_errors::fluent::passes::label_multiple_asm);\n+            diag.span_label(*span, rustc_errors::fluent::label_multiple_asm);\n         }\n         for span in self.non_asms.iter() {\n-            diag.span_label(*span, rustc_errors::fluent::passes::label_non_asm);\n+            diag.span_label(*span, rustc_errors::fluent::label_non_asm);\n         }\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_operands, code = \"E0787\")]\n+#[diag(passes_naked_functions_operands, code = \"E0787\")]\n pub struct NakedFunctionsOperands {\n     #[primary_span]\n     pub unsupported_operands: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_asm_options, code = \"E0787\")]\n+#[diag(passes_naked_functions_asm_options, code = \"E0787\")]\n pub struct NakedFunctionsAsmOptions {\n     #[primary_span]\n     pub span: Span,\n     pub unsupported_options: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_must_use_noreturn, code = \"E0787\")]\n+#[diag(passes_naked_functions_must_use_noreturn, code = \"E0787\")]\n pub struct NakedFunctionsMustUseNoreturn {\n     #[primary_span]\n     pub span: Span,\n@@ -1058,67 +1057,67 @@ pub struct NakedFunctionsMustUseNoreturn {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_on_main)]\n+#[diag(passes_attr_only_on_main)]\n pub struct AttrOnlyOnMain {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_on_root_main)]\n+#[diag(passes_attr_only_on_root_main)]\n pub struct AttrOnlyOnRootMain {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_in_functions)]\n+#[diag(passes_attr_only_in_functions)]\n pub struct AttrOnlyInFunctions {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::multiple_rustc_main, code = \"E0137\")]\n+#[diag(passes_multiple_rustc_main, code = \"E0137\")]\n pub struct MultipleRustcMain {\n     #[primary_span]\n     pub span: Span,\n-    #[label(passes::first)]\n+    #[label(first)]\n     pub first: Span,\n-    #[label(passes::additional)]\n+    #[label(additional)]\n     pub additional: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::multiple_start_functions, code = \"E0138\")]\n+#[diag(passes_multiple_start_functions, code = \"E0138\")]\n pub struct MultipleStartFunctions {\n     #[primary_span]\n     pub span: Span,\n     #[label]\n     pub labeled: Span,\n-    #[label(passes::previous)]\n+    #[label(previous)]\n     pub previous: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::extern_main)]\n+#[diag(passes_extern_main)]\n pub struct ExternMain {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unix_sigpipe_values)]\n+#[diag(passes_unix_sigpipe_values)]\n pub struct UnixSigpipeValues {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_main_function, code = \"E0601\")]\n+#[diag(passes_no_main_function, code = \"E0601\")]\n pub struct NoMainFunction {\n     #[primary_span]\n     pub span: Span,\n@@ -1143,24 +1142,24 @@ impl<'a> IntoDiagnostic<'a> for NoMainErr {\n     ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             DUMMY_SP,\n-            rustc_errors::fluent::passes::no_main_function,\n+            rustc_errors::fluent::passes_no_main_function,\n             error_code!(E0601),\n         );\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"filename\", self.filename);\n         diag.set_arg(\"has_filename\", self.has_filename);\n         let note = if !self.non_main_fns.is_empty() {\n             for &span in &self.non_main_fns {\n-                diag.span_note(span, rustc_errors::fluent::passes::here_is_main);\n+                diag.span_note(span, rustc_errors::fluent::here_is_main);\n             }\n-            diag.note(rustc_errors::fluent::passes::one_or_more_possible_main);\n-            diag.help(rustc_errors::fluent::passes::consider_moving_main);\n+            diag.note(rustc_errors::fluent::one_or_more_possible_main);\n+            diag.help(rustc_errors::fluent::consider_moving_main);\n             // There were some functions named `main` though. Try to give the user a hint.\n-            rustc_errors::fluent::passes::main_must_be_defined_at_crate\n+            rustc_errors::fluent::main_must_be_defined_at_crate\n         } else if self.has_filename {\n-            rustc_errors::fluent::passes::consider_adding_main_to_file\n+            rustc_errors::fluent::consider_adding_main_to_file\n         } else {\n-            rustc_errors::fluent::passes::consider_adding_main_at_crate\n+            rustc_errors::fluent::consider_adding_main_at_crate\n         };\n         if self.file_empty {\n             diag.note(note);\n@@ -1171,11 +1170,11 @@ impl<'a> IntoDiagnostic<'a> for NoMainErr {\n \n         if let Some(main_def) = self.main_def_opt && main_def.opt_fn_def_id().is_none(){\n             // There is something at `crate::main`, but it is not a function definition.\n-            diag.span_label(main_def.span, rustc_errors::fluent::passes::non_function_main);\n+            diag.span_label(main_def.span, rustc_errors::fluent::non_function_main);\n         }\n \n         if self.add_teach_note {\n-            diag.note(rustc_errors::fluent::passes::teach_note);\n+            diag.note(rustc_errors::fluent::teach_note);\n         }\n         diag\n     }\n@@ -1203,11 +1202,11 @@ impl IntoDiagnostic<'_> for DuplicateLangItem {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_err_with_code(\n             match self.duplicate {\n-                Duplicate::Plain => rustc_errors::fluent::passes::duplicate_lang_item,\n+                Duplicate::Plain => rustc_errors::fluent::passes_duplicate_lang_item,\n \n-                Duplicate::Crate => rustc_errors::fluent::passes::duplicate_lang_item_crate,\n+                Duplicate::Crate => rustc_errors::fluent::passes_duplicate_lang_item_crate,\n                 Duplicate::CrateDepends => {\n-                    rustc_errors::fluent::passes::duplicate_lang_item_crate_depends\n+                    rustc_errors::fluent::passes_duplicate_lang_item_crate_depends\n                 }\n             },\n             error_code!(E0152),\n@@ -1223,32 +1222,32 @@ impl IntoDiagnostic<'_> for DuplicateLangItem {\n             diag.set_span(span);\n         }\n         if let Some(span) = self.first_defined_span {\n-            diag.span_note(span, rustc_errors::fluent::passes::first_defined_span);\n+            diag.span_note(span, rustc_errors::fluent::first_defined_span);\n         } else {\n             if self.orig_dependency_of.is_empty() {\n-                diag.note(rustc_errors::fluent::passes::first_defined_crate);\n+                diag.note(rustc_errors::fluent::first_defined_crate);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::first_defined_crate_depends);\n+                diag.note(rustc_errors::fluent::first_defined_crate_depends);\n             }\n \n             if self.orig_is_local {\n-                diag.note(rustc_errors::fluent::passes::first_definition_local);\n+                diag.note(rustc_errors::fluent::first_definition_local);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::first_definition_path);\n+                diag.note(rustc_errors::fluent::first_definition_path);\n             }\n \n             if self.is_local {\n-                diag.note(rustc_errors::fluent::passes::second_definition_local);\n+                diag.note(rustc_errors::fluent::second_definition_local);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::second_definition_path);\n+                diag.note(rustc_errors::fluent::second_definition_path);\n             }\n         }\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::incorrect_target, code = \"E0718\")]\n+#[diag(passes_incorrect_target, code = \"E0718\")]\n pub struct IncorrectTarget<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -1262,29 +1261,29 @@ pub struct IncorrectTarget<'a> {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::useless_assignment)]\n+#[diag(passes_useless_assignment)]\n pub struct UselessAssignment<'a> {\n     pub is_field_assign: bool,\n     pub ty: Ty<'a>,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::only_has_effect_on)]\n+#[diag(passes_only_has_effect_on)]\n pub struct OnlyHasEffectOn {\n     pub attr_name: Symbol,\n     pub target_name: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::object_lifetime_err)]\n+#[diag(passes_object_lifetime_err)]\n pub struct ObjectLifetimeErr {\n     #[primary_span]\n     pub span: Span,\n     pub repr: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unrecognized_repr_hint, code = \"E0552\")]\n+#[diag(passes_unrecognized_repr_hint, code = \"E0552\")]\n #[help]\n pub struct UnrecognizedReprHint {\n     #[primary_span]\n@@ -1293,35 +1292,35 @@ pub struct UnrecognizedReprHint {\n \n #[derive(Diagnostic)]\n pub enum AttrApplication {\n-    #[diag(passes::attr_application_enum, code = \"E0517\")]\n+    #[diag(passes_attr_application_enum, code = \"E0517\")]\n     Enum {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct, code = \"E0517\")]\n     Struct {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_union, code = \"E0517\")]\n     StructUnion {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_enum_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_enum_union, code = \"E0517\")]\n     StructEnumUnion {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_enum_function_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_enum_function_union, code = \"E0517\")]\n     StructEnumFunctionUnion {\n         #[primary_span]\n         hint_span: Span,\n@@ -1331,102 +1330,102 @@ pub enum AttrApplication {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::transparent_incompatible, code = \"E0692\")]\n+#[diag(passes_transparent_incompatible, code = \"E0692\")]\n pub struct TransparentIncompatible {\n     #[primary_span]\n     pub hint_spans: Vec<Span>,\n     pub target: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::deprecated_attribute, code = \"E0549\")]\n+#[diag(passes_deprecated_attribute, code = \"E0549\")]\n pub struct DeprecatedAttribute {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::useless_stability)]\n+#[diag(passes_useless_stability)]\n pub struct UselessStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::invalid_stability)]\n+#[diag(passes_invalid_stability)]\n pub struct InvalidStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::cannot_stabilize_deprecated)]\n+#[diag(passes_cannot_stabilize_deprecated)]\n pub struct CannotStabilizeDeprecated {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::invalid_deprecation_version)]\n+#[diag(passes_invalid_deprecation_version)]\n pub struct InvalidDeprecationVersion {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_stability_attr)]\n+#[diag(passes_missing_stability_attr)]\n pub struct MissingStabilityAttr<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub descr: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_const_stab_attr)]\n+#[diag(passes_missing_const_stab_attr)]\n pub struct MissingConstStabAttr<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub descr: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::trait_impl_const_stable)]\n+#[diag(passes_trait_impl_const_stable)]\n #[note]\n pub struct TraitImplConstStable {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_only_on_nightly, code = \"E0554\")]\n+#[diag(passes_feature_only_on_nightly, code = \"E0554\")]\n pub struct FeatureOnlyOnNightly {\n     #[primary_span]\n     pub span: Span,\n     pub release_channel: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_feature, code = \"E0635\")]\n+#[diag(passes_unknown_feature, code = \"E0635\")]\n pub struct UnknownFeature {\n     #[primary_span]\n     pub span: Span,\n     pub feature: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::implied_feature_not_exist)]\n+#[diag(passes_implied_feature_not_exist)]\n pub struct ImpliedFeatureNotExist {\n     #[primary_span]\n     pub span: Span,\n@@ -1435,14 +1434,14 @@ pub struct ImpliedFeatureNotExist {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_feature_err, code = \"E0636\")]\n+#[diag(passes_duplicate_feature_err, code = \"E0636\")]\n pub struct DuplicateFeatureErr {\n     #[primary_span]\n     pub span: Span,\n     pub feature: Symbol,\n }\n #[derive(Diagnostic)]\n-#[diag(passes::missing_const_err)]\n+#[diag(passes_missing_const_err)]\n pub struct MissingConstErr {\n     #[primary_span]\n     #[help]"}, {"sha": "e6a7fc86bee3dc787ae8e0235c60b4acf7ffbb10", "filename": "compiler/rustc_plugin_impl/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -4,15 +4,15 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(plugin_impl::load_plugin_error)]\n+#[diag(plugin_impl_load_plugin_error)]\n pub struct LoadPluginError {\n     #[primary_span]\n     pub span: Span,\n     pub msg: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(plugin_impl::malformed_plugin_attribute, code = \"E0498\")]\n+#[diag(plugin_impl_malformed_plugin_attribute, code = \"E0498\")]\n pub struct MalformedPluginAttribute {\n     #[primary_span]\n     #[label]"}, {"sha": "a6c95f1a815acc5bed64a4bd147925b84b2ac85e", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(privacy::field_is_private, code = \"E0451\")]\n+#[diag(privacy_field_is_private, code = \"E0451\")]\n pub struct FieldIsPrivate {\n     #[primary_span]\n     pub span: Span,\n@@ -16,21 +16,21 @@ pub struct FieldIsPrivate {\n \n #[derive(Subdiagnostic)]\n pub enum FieldIsPrivateLabel {\n-    #[label(privacy::field_is_private_is_update_syntax_label)]\n+    #[label(privacy_field_is_private_is_update_syntax_label)]\n     IsUpdateSyntax {\n         #[primary_span]\n         span: Span,\n         field_name: Symbol,\n     },\n-    #[label(privacy::field_is_private_label)]\n+    #[label(privacy_field_is_private_label)]\n     Other {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::item_is_private)]\n+#[diag(privacy_item_is_private)]\n pub struct ItemIsPrivate<'a> {\n     #[primary_span]\n     #[label]\n@@ -40,7 +40,7 @@ pub struct ItemIsPrivate<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::unnamed_item_is_private)]\n+#[diag(privacy_unnamed_item_is_private)]\n pub struct UnnamedItemIsPrivate {\n     #[primary_span]\n     pub span: Span,\n@@ -49,50 +49,50 @@ pub struct UnnamedItemIsPrivate {\n \n // Duplicate of `InPublicInterface` but with a different error code, shares the same slug.\n #[derive(Diagnostic)]\n-#[diag(privacy::in_public_interface, code = \"E0445\")]\n+#[diag(privacy_in_public_interface, code = \"E0445\")]\n pub struct InPublicInterfaceTraits<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub vis_descr: &'static str,\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n-    #[label(privacy::visibility_label)]\n+    #[label(visibility_label)]\n     pub vis_span: Span,\n }\n \n // Duplicate of `InPublicInterfaceTraits` but with a different error code, shares the same slug.\n #[derive(Diagnostic)]\n-#[diag(privacy::in_public_interface, code = \"E0446\")]\n+#[diag(privacy_in_public_interface, code = \"E0446\")]\n pub struct InPublicInterface<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub vis_descr: &'static str,\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n-    #[label(privacy::visibility_label)]\n+    #[label(visibility_label)]\n     pub vis_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::report_effective_visibility)]\n+#[diag(privacy_report_effective_visibility)]\n pub struct ReportEffectiveVisibility {\n     #[primary_span]\n     pub span: Span,\n     pub descr: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(privacy::from_private_dep_in_public_interface)]\n+#[diag(privacy_from_private_dep_in_public_interface)]\n pub struct FromPrivateDependencyInPublicInterface<'a> {\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n     pub krate: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(privacy::private_in_public_lint)]\n+#[diag(privacy_private_in_public_lint)]\n pub struct PrivateInPublicLint<'a> {\n     pub vis_descr: &'static str,\n     pub kind: &'a str,"}, {"sha": "7a20eaceba0247682a7ae74451ddcbf3eeeb7772", "filename": "compiler/rustc_query_system/src/error.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,7 +3,7 @@ use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::cycle_stack_middle)]\n+#[note(query_system_cycle_stack_middle)]\n pub struct CycleStack {\n     #[primary_span]\n     pub span: Span,\n@@ -19,32 +19,32 @@ pub enum HandleCycleError {\n \n #[derive(Subdiagnostic)]\n pub enum StackCount {\n-    #[note(query_system::cycle_stack_single)]\n+    #[note(query_system_cycle_stack_single)]\n     Single,\n-    #[note(query_system::cycle_stack_multiple)]\n+    #[note(query_system_cycle_stack_multiple)]\n     Multiple,\n }\n \n #[derive(Subdiagnostic)]\n pub enum Alias {\n-    #[note(query_system::cycle_recursive_ty_alias)]\n-    #[help(query_system::cycle_recursive_ty_alias_help1)]\n-    #[help(query_system::cycle_recursive_ty_alias_help2)]\n+    #[note(query_system_cycle_recursive_ty_alias)]\n+    #[help(query_system_cycle_recursive_ty_alias_help1)]\n+    #[help(query_system_cycle_recursive_ty_alias_help2)]\n     Ty,\n-    #[note(query_system::cycle_recursive_trait_alias)]\n+    #[note(query_system_cycle_recursive_trait_alias)]\n     Trait,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::cycle_usage)]\n+#[note(query_system_cycle_usage)]\n pub struct CycleUsage {\n     #[primary_span]\n     pub span: Span,\n     pub usage: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(query_system::cycle, code = \"E0391\")]\n+#[diag(query_system_cycle, code = \"E0391\")]\n pub struct Cycle {\n     #[primary_span]\n     pub span: Span,\n@@ -60,22 +60,22 @@ pub struct Cycle {\n }\n \n #[derive(Diagnostic)]\n-#[diag(query_system::reentrant)]\n+#[diag(query_system_reentrant)]\n pub struct Reentrant;\n \n #[derive(Diagnostic)]\n-#[diag(query_system::increment_compilation)]\n+#[diag(query_system_increment_compilation)]\n #[help]\n-#[note(query_system::increment_compilation_note1)]\n-#[note(query_system::increment_compilation_note2)]\n+#[note(query_system_increment_compilation_note1)]\n+#[note(query_system_increment_compilation_note2)]\n pub struct IncrementCompilation {\n     pub run_cmd: String,\n     pub dep_node: String,\n }\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(query_system::query_overflow)]\n+#[diag(query_system_query_overflow)]\n pub struct QueryOverflow {\n     #[primary_span]\n     pub span: Option<Span>,\n@@ -86,7 +86,7 @@ pub struct QueryOverflow {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::layout_of_depth)]\n+#[note(query_system_layout_of_depth)]\n pub struct LayoutOfDepth {\n     pub desc: String,\n     pub depth: usize,"}, {"sha": "585aac8c1c3cc034fabcde0ea890a4e7c1ddb32c", "filename": "compiler/rustc_save_analysis/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::Diagnostic;\n use std::path::Path;\n \n #[derive(Diagnostic)]\n-#[diag(save_analysis::could_not_open)]\n+#[diag(save_analysis_could_not_open)]\n pub(crate) struct CouldNotOpen<'a> {\n     pub file_name: &'a Path,\n     pub err: std::io::Error,"}, {"sha": "bf542faec41d672eec81641e4a4ef5c5b1103f89", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -7,7 +7,7 @@ use rustc_span::{Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(Diagnostic)]\n-#[diag(session::incorrect_cgu_reuse_type)]\n+#[diag(session_incorrect_cgu_reuse_type)]\n pub struct IncorrectCguReuseType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -18,114 +18,114 @@ pub struct IncorrectCguReuseType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cgu_not_recorded)]\n+#[diag(session_cgu_not_recorded)]\n pub struct CguNotRecorded<'a> {\n     pub cgu_user_name: &'a str,\n     pub cgu_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::feature_gate_error, code = \"E0658\")]\n+#[diag(session_feature_gate_error, code = \"E0658\")]\n pub struct FeatureGateError<'a> {\n     #[primary_span]\n     pub span: MultiSpan,\n     pub explain: &'a str,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(session::feature_diagnostic_for_issue)]\n+#[note(session_feature_diagnostic_for_issue)]\n pub struct FeatureDiagnosticForIssue {\n     pub n: NonZeroU32,\n }\n \n #[derive(Subdiagnostic)]\n-#[help(session::feature_diagnostic_help)]\n+#[help(session_feature_diagnostic_help)]\n pub struct FeatureDiagnosticHelp {\n     pub feature: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::not_circumvent_feature)]\n+#[diag(session_not_circumvent_feature)]\n pub struct NotCircumventFeature;\n \n #[derive(Diagnostic)]\n-#[diag(session::linker_plugin_lto_windows_not_supported)]\n+#[diag(session_linker_plugin_lto_windows_not_supported)]\n pub struct LinkerPluginToWindowsNotSupported;\n \n #[derive(Diagnostic)]\n-#[diag(session::profile_use_file_does_not_exist)]\n+#[diag(session_profile_use_file_does_not_exist)]\n pub struct ProfileUseFileDoesNotExist<'a> {\n     pub path: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::profile_sample_use_file_does_not_exist)]\n+#[diag(session_profile_sample_use_file_does_not_exist)]\n pub struct ProfileSampleUseFileDoesNotExist<'a> {\n     pub path: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::target_requires_unwind_tables)]\n+#[diag(session_target_requires_unwind_tables)]\n pub struct TargetRequiresUnwindTables;\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizer_not_supported)]\n+#[diag(session_sanitizer_not_supported)]\n pub struct SanitizerNotSupported {\n     pub us: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizers_not_supported)]\n+#[diag(session_sanitizers_not_supported)]\n pub struct SanitizersNotSupported {\n     pub us: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cannot_mix_and_match_sanitizers)]\n+#[diag(session_cannot_mix_and_match_sanitizers)]\n pub struct CannotMixAndMatchSanitizers {\n     pub first: String,\n     pub second: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cannot_enable_crt_static_linux)]\n+#[diag(session_cannot_enable_crt_static_linux)]\n pub struct CannotEnableCrtStaticLinux;\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizer_cfi_enabled)]\n+#[diag(session_sanitizer_cfi_enabled)]\n pub struct SanitizerCfiEnabled;\n \n #[derive(Diagnostic)]\n-#[diag(session::unstable_virtual_function_elimination)]\n+#[diag(session_unstable_virtual_function_elimination)]\n pub struct UnstableVirtualFunctionElimination;\n \n #[derive(Diagnostic)]\n-#[diag(session::unsupported_dwarf_version)]\n+#[diag(session_unsupported_dwarf_version)]\n pub struct UnsupportedDwarfVersion {\n     pub dwarf_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::target_stack_protector_not_supported)]\n+#[diag(session_target_stack_protector_not_supported)]\n pub struct StackProtectorNotSupportedForTarget<'a> {\n     pub stack_protector: StackProtector,\n     pub target_triple: &'a TargetTriple,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::split_debuginfo_unstable_platform)]\n+#[diag(session_split_debuginfo_unstable_platform)]\n pub struct SplitDebugInfoUnstablePlatform {\n     pub debuginfo: SplitDebuginfo,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::file_is_not_writeable)]\n+#[diag(session_file_is_not_writeable)]\n pub struct FileIsNotWriteable<'a> {\n     pub file: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_does_not_match)]\n+#[diag(session_crate_name_does_not_match)]\n pub struct CrateNameDoesNotMatch<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -134,20 +134,20 @@ pub struct CrateNameDoesNotMatch<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_invalid)]\n+#[diag(session_crate_name_invalid)]\n pub struct CrateNameInvalid<'a> {\n     pub s: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_empty)]\n+#[diag(session_crate_name_empty)]\n pub struct CrateNameEmpty {\n     #[primary_span]\n     pub span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::invalid_character_in_create_name)]\n+#[diag(session_invalid_character_in_create_name)]\n pub struct InvalidCharacterInCrateName<'a> {\n     #[primary_span]\n     pub span: Option<Span>,\n@@ -156,7 +156,7 @@ pub struct InvalidCharacterInCrateName<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(session::expr_parentheses_needed, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(session_expr_parentheses_needed, applicability = \"machine-applicable\")]\n pub struct ExprParenthesesNeeded {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -171,21 +171,21 @@ impl ExprParenthesesNeeded {\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::skipping_const_checks)]\n+#[diag(session_skipping_const_checks)]\n pub struct SkippingConstChecks {\n     #[subdiagnostic(eager)]\n     pub unleashed_features: Vec<UnleashedFeatureHelp>,\n }\n \n #[derive(Subdiagnostic)]\n pub enum UnleashedFeatureHelp {\n-    #[help(session::unleashed_feature_help_named)]\n+    #[help(session_unleashed_feature_help_named)]\n     Named {\n         #[primary_span]\n         span: Span,\n         gate: Symbol,\n     },\n-    #[help(session::unleashed_feature_help_unnamed)]\n+    #[help(session_unleashed_feature_help_unnamed)]\n     Unnamed {\n         #[primary_span]\n         span: Span,"}, {"sha": "f4d0751f75370ea3c0bf27c96b3744a5a7f6bb3f", "filename": "compiler/rustc_symbol_mangling/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -5,7 +5,7 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(symbol_mangling::test_output)]\n+#[diag(symbol_mangling_test_output)]\n pub struct TestOutput {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "7f8705824445457538a74168409c0750b55ddf2e", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -5,7 +5,7 @@ use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::dump_vtable_entries)]\n+#[diag(trait_selection_dump_vtable_entries)]\n pub struct DumpVTableEntries<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -14,7 +14,7 @@ pub struct DumpVTableEntries<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::unable_to_construct_constant_value)]\n+#[diag(trait_selection_unable_to_construct_constant_value)]\n pub struct UnableToConstructConstantValue<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -23,7 +23,7 @@ pub struct UnableToConstructConstantValue<'a> {\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(trait_selection::auto_deref_reached_recursion_limit, code = \"E0055\")]\n+#[diag(trait_selection_auto_deref_reached_recursion_limit, code = \"E0055\")]\n pub struct AutoDerefReachedRecursionLimit<'a> {\n     #[primary_span]\n     #[label]\n@@ -34,23 +34,23 @@ pub struct AutoDerefReachedRecursionLimit<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::empty_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_empty_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n pub struct EmptyOnClauseInOnUnimplemented {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::invalid_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_invalid_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n pub struct InvalidOnClauseInOnUnimplemented {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::no_value_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_no_value_in_rustc_on_unimplemented, code = \"E0232\")]\n #[note]\n pub struct NoValueInOnUnimplemented {\n     #[primary_span]\n@@ -71,7 +71,7 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         self,\n         handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::trait_selection::negative_positive_conflict);\n+        let mut diag = handler.struct_err(fluent::trait_selection_negative_positive_conflict);\n         diag.set_arg(\"trait_desc\", self.trait_desc);\n         diag.set_arg(\n             \"self_desc\",\n@@ -81,19 +81,19 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag.code(rustc_errors::error_code!(E0751));\n         match self.negative_impl_span {\n             Ok(span) => {\n-                diag.span_label(span, fluent::trait_selection::negative_implementation_here);\n+                diag.span_label(span, fluent::negative_implementation_here);\n             }\n             Err(cname) => {\n-                diag.note(fluent::trait_selection::negative_implementation_in_crate);\n+                diag.note(fluent::negative_implementation_in_crate);\n                 diag.set_arg(\"negative_impl_cname\", cname.to_string());\n             }\n         }\n         match self.positive_impl_span {\n             Ok(span) => {\n-                diag.span_label(span, fluent::trait_selection::positive_implementation_here);\n+                diag.span_label(span, fluent::positive_implementation_here);\n             }\n             Err(cname) => {\n-                diag.note(fluent::trait_selection::positive_implementation_in_crate);\n+                diag.note(fluent::positive_implementation_in_crate);\n                 diag.set_arg(\"positive_impl_cname\", cname.to_string());\n             }\n         }"}, {"sha": "c05eeb353a84874155684dc4559743394521b91a", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -5,65 +5,65 @@ use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(ty_utils::needs_drop_overflow)]\n+#[diag(ty_utils_needs_drop_overflow)]\n pub struct NeedsDropOverflow<'tcx> {\n     pub query_ty: Ty<'tcx>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ty_utils::generic_constant_too_complex)]\n+#[diag(ty_utils_generic_constant_too_complex)]\n #[help]\n pub struct GenericConstantTooComplex {\n     #[primary_span]\n     pub span: Span,\n-    #[note(ty_utils::maybe_supported)]\n+    #[note(maybe_supported)]\n     pub maybe_supported: Option<()>,\n     #[subdiagnostic]\n     pub sub: GenericConstantTooComplexSub,\n }\n \n #[derive(Subdiagnostic)]\n pub enum GenericConstantTooComplexSub {\n-    #[label(ty_utils::borrow_not_supported)]\n+    #[label(ty_utils_borrow_not_supported)]\n     BorrowNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::address_and_deref_not_supported)]\n+    #[label(ty_utils_address_and_deref_not_supported)]\n     AddressAndDerefNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::array_not_supported)]\n+    #[label(ty_utils_array_not_supported)]\n     ArrayNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::block_not_supported)]\n+    #[label(ty_utils_block_not_supported)]\n     BlockNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::never_to_any_not_supported)]\n+    #[label(ty_utils_never_to_any_not_supported)]\n     NeverToAnyNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::tuple_not_supported)]\n+    #[label(ty_utils_tuple_not_supported)]\n     TupleNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::index_not_supported)]\n+    #[label(ty_utils_index_not_supported)]\n     IndexNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::field_not_supported)]\n+    #[label(ty_utils_field_not_supported)]\n     FieldNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::const_block_not_supported)]\n+    #[label(ty_utils_const_block_not_supported)]\n     ConstBlockNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::adt_not_supported)]\n+    #[label(ty_utils_adt_not_supported)]\n     AdtNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::pointer_not_supported)]\n+    #[label(ty_utils_pointer_not_supported)]\n     PointerNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::yield_not_supported)]\n+    #[label(ty_utils_yield_not_supported)]\n     YieldNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::loop_not_supported)]\n+    #[label(ty_utils_loop_not_supported)]\n     LoopNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::box_not_supported)]\n+    #[label(ty_utils_box_not_supported)]\n     BoxNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::binary_not_supported)]\n+    #[label(ty_utils_binary_not_supported)]\n     BinaryNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::logical_op_not_supported)]\n+    #[label(ty_utils_logical_op_not_supported)]\n     LogicalOpNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::assign_not_supported)]\n+    #[label(ty_utils_assign_not_supported)]\n     AssignNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::closure_and_return_not_supported)]\n+    #[label(ty_utils_closure_and_return_not_supported)]\n     ClosureAndReturnNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::control_flow_not_supported)]\n+    #[label(ty_utils_control_flow_not_supported)]\n     ControlFlowNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::inline_asm_not_supported)]\n+    #[label(ty_utils_inline_asm_not_supported)]\n     InlineAsmNotSupported(#[primary_span] Span),\n-    #[label(ty_utils::operation_not_supported)]\n+    #[label(ty_utils_operation_not_supported)]\n     OperationNotSupported(#[primary_span] Span),\n }"}, {"sha": "4e8147e2b76dce047fe95189e079aab739ee0ed2", "filename": "src/test/ui-fulldeps/fluent-messages/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -49,6 +49,7 @@ mod duplicate {\n     use super::fluent_messages;\n \n     fluent_messages! {\n+//~^ ERROR the name `a_b_key` is defined multiple times\n         a => \"./duplicate-a.ftl\",\n         a_b => \"./duplicate-a-b.ftl\",\n //~^ ERROR overrides existing message: `a_b_key`\n@@ -80,7 +81,7 @@ mod valid {\n         valid => \"./valid.ftl\",\n     }\n \n-    use self::fluent_generated::{DEFAULT_LOCALE_RESOURCES, valid::key};\n+    use self::fluent_generated::{DEFAULT_LOCALE_RESOURCES, valid_key};\n }\n \n mod missing_crate_name {\n@@ -93,5 +94,5 @@ mod missing_crate_name {\n //~| ERROR name `with-hyphens` does not start with the crate name\n     }\n \n-    use self::fluent_generated::{DEFAULT_LOCALE_RESOURCES, test_crate::{foo, with_hyphens}};\n+    use self::fluent_generated::{DEFAULT_LOCALE_RESOURCES, test_crate_foo, with_hyphens};\n }"}, {"sha": "d1cd4fe26da27aa3dd9e43168b30e3e2244acbd1", "filename": "src/test/ui-fulldeps/fluent-messages/test.stderr", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -30,56 +30,69 @@ error: expected a message field for \"missing_message\"\n   |\n \n error: overrides existing message: `a_b_key`\n-  --> $DIR/test.rs:53:16\n+  --> $DIR/test.rs:54:16\n    |\n LL |         a_b => \"./duplicate-a-b.ftl\",\n    |                ^^^^^^^^^^^^^^^^^^^^^\n    |\n help: previously defined in this resource\n-  --> $DIR/test.rs:52:14\n+  --> $DIR/test.rs:53:14\n    |\n LL |         a => \"./duplicate-a.ftl\",\n    |              ^^^^^^^^^^^^^^^^^^^\n \n+error[E0428]: the name `a_b_key` is defined multiple times\n+  --> $DIR/test.rs:51:5\n+   |\n+LL |     fluent_messages! {\n+   |     ^^^^^^^^^^^^^^^^\n+   |     |\n+   |     `a_b_key` redefined here\n+   |     previous definition of the value `a_b_key` here\n+   |\n+   = note: os-specific message\n+   = note: os-specific message\n+\n error: name `slug_with_hyphens_this-slug-has-hyphens` contains a '-' character\n-  --> $DIR/test.rs:62:30\n+  --> $DIR/test.rs:63:30\n    |\n LL |         slug_with_hyphens => \"./slug-with-hyphens.ftl\",\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: replace any '-'s with '_'s\n \n error: attribute `label-has-hyphens` contains a '-' character\n-  --> $DIR/test.rs:71:31\n+  --> $DIR/test.rs:72:31\n    |\n LL |         label_with_hyphens => \"./label-with-hyphens.ftl\",\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: replace any '-'s with '_'s\n \n error: name `with-hyphens` contains a '-' character\n-  --> $DIR/test.rs:90:23\n+  --> $DIR/test.rs:91:23\n    |\n LL |         test_crate => \"./missing-crate-name.ftl\",\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: replace any '-'s with '_'s\n \n error: name `with-hyphens` does not start with the crate name\n-  --> $DIR/test.rs:90:23\n+  --> $DIR/test.rs:91:23\n    |\n LL |         test_crate => \"./missing-crate-name.ftl\",\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: prepend `test_crate_` to the slug name: `test_crate_with_hyphens`\n \n error: name `test-crate_foo` contains a '-' character\n-  --> $DIR/test.rs:90:23\n+  --> $DIR/test.rs:91:23\n    |\n LL |         test_crate => \"./missing-crate-name.ftl\",\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: replace any '-'s with '_'s\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "643e81d99c6a69517b5345dd86063917a4110d63", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -19,14 +19,14 @@ use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct DeriveDiagnostic {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(compiletest::example)]\n+#[note(compiletest_example)]\n struct Note {\n     #[primary_span]\n     span: Span,\n@@ -45,7 +45,7 @@ pub struct TranslatableInIntoDiagnostic;\n \n impl<'a> IntoDiagnostic<'a, ErrorGuaranteed> for TranslatableInIntoDiagnostic {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        handler.struct_err(fluent::compiletest::example)\n+        handler.struct_err(fluent::compiletest_example)\n     }\n }\n \n@@ -68,12 +68,12 @@ impl AddToDiagnostic for TranslatableInAddToDiagnostic {\n     where\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n-        diag.note(fluent::compiletest::note);\n+        diag.note(fluent::note);\n     }\n }\n \n pub fn make_diagnostics<'a>(handler: &'a Handler) {\n-    let _diag = handler.struct_err(fluent::compiletest::example);\n+    let _diag = handler.struct_err(fluent::compiletest_example);\n     //~^ ERROR diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n \n     let _diag = handler.struct_err(\"untranslatable diagnostic\");"}, {"sha": "510d6a171087085c068efd92fbd5952076a4cddc", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -19,7 +19,7 @@ LL |         diag.note(\"untranslatable diagnostic\");\n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n   --> $DIR/diagnostics.rs:76:25\n    |\n-LL |     let _diag = handler.struct_err(fluent::compiletest::example);\n+LL |     let _diag = handler.struct_err(fluent::compiletest_example);\n    |                         ^^^^^^^^^^\n    |\n note: the lint level is defined here"}, {"sha": "46164d573b0bd4049963b44c0332d4c2b329ed25", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -28,15 +28,15 @@ use rustc_errors::{Applicability, MultiSpan};\n extern crate rustc_session;\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct Hello {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct HelloWarn {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n //~^ ERROR unsupported type attribute for diagnostic derive enum\n enum DiagnosticOnEnum {\n     Foo,\n@@ -46,13 +46,13 @@ enum DiagnosticOnEnum {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n #[diag = \"E0123\"]\n //~^ ERROR `#[diag = ...]` is not a valid attribute\n struct WrongStructAttrStyle {}\n \n #[derive(Diagnostic)]\n-#[nonsense(compiletest::example, code = \"E0123\")]\n+#[nonsense(compiletest_example, code = \"E0123\")]\n //~^ ERROR `#[nonsense(...)]` is not a valid attribute\n //~^^ ERROR diagnostic slug not specified\n //~^^^ ERROR cannot find attribute `nonsense` in this scope\n@@ -90,33 +90,33 @@ struct InvalidNestedStructAttr2 {}\n struct InvalidNestedStructAttr3 {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\", slug = \"foo\")]\n+#[diag(compiletest_example, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(slug = ...)]` is not a valid attribute\n struct InvalidNestedStructAttr4 {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct WrongPlaceField {\n     #[suggestion = \"bar\"]\n     //~^ ERROR `#[suggestion = ...]` is not a valid attribute\n     sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n-#[diag(compiletest::example, code = \"E0456\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0456\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n struct DiagSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n+#[diag(compiletest_example, code = \"E0456\", code = \"E0457\")]\n //~^ ERROR specified multiple times\n struct CodeSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, compiletest::example, code = \"E0456\")]\n-//~^ ERROR `#[diag(compiletest::example)]` is not a valid attribute\n+#[diag(compiletest_example, compiletest_example, code = \"E0456\")]\n+//~^ ERROR `#[diag(compiletest_example)]` is not a valid attribute\n struct SlugSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n@@ -128,19 +128,19 @@ struct KindNotProvided {} //~ ERROR diagnostic slug not specified\n struct SlugNotProvided {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct CodeNotProvided {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     foo: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct InvalidPathFieldAttr {\n     #[nonsense]\n     //~^ ERROR `#[nonsense]` is not a valid attribute\n@@ -149,84 +149,84 @@ struct InvalidPathFieldAttr {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithField {\n     name: String,\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     name: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithNonexistentField {\n-    #[suggestion(compiletest::suggestion, code = \"{name}\")]\n+    #[suggestion(suggestion, code = \"{name}\")]\n     //~^ ERROR `name` doesn't refer to a field on this type\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n //~^ ERROR invalid format string: expected `'}'`\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorMissingClosingBrace {\n-    #[suggestion(compiletest::suggestion, code = \"{name\")]\n+    #[suggestion(suggestion, code = \"{name\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(Diagnostic)]\n //~^ ERROR invalid format string: unmatched `}`\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorMissingOpeningBrace {\n-    #[suggestion(compiletest::suggestion, code = \"name}\")]\n+    #[suggestion(suggestion, code = \"name}\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct LabelOnSpan {\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct LabelOnNonSpan {\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     id: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct Suggest {\n-    #[suggestion(compiletest::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_short(compiletest::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_hidden(compiletest::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_verbose(compiletest::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion(suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_short(suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_hidden(suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_verbose(suggestion, code = \"This is the suggested code\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithoutCode {\n-    #[suggestion(compiletest::suggestion)]\n+    #[suggestion(suggestion)]\n     //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n@@ -235,7 +235,7 @@ struct SuggestWithBadKey {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n@@ -244,91 +244,91 @@ struct SuggestWithShorthandMsg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithoutMsg {\n     #[suggestion(code = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithTypesSwapped {\n-    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n-    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(suggestion, code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithSpanOnly {\n-    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(suggestion, code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n-    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(suggestion, code = \"This is suggested code\")]\n     suggestion: (Span, Span, Applicability),\n     //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n-    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Applicability, Span),\n     //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct WrongKindOfAnnotation {\n     #[label = \"bar\"]\n     //~^ ERROR `#[label = ...]` is not a valid attribute\n     z: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct OptionsInErrors {\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     label: Option<Span>,\n-    #[suggestion(compiletest::suggestion, code = \"...\")]\n+    #[suggestion(suggestion, code = \"...\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0456\")]\n+#[diag(compiletest_example, code = \"E0456\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n     #[primary_span]\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     span: Span,\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     other_span: Span,\n-    #[suggestion(compiletest::suggestion, code = \"{name}.clone()\")]\n+    #[suggestion(suggestion, code = \"{name}.clone()\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithLifetime<'a> {\n-    #[label(compiletest::label)]\n+    #[label(label)]\n     span: Span,\n     name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithDefaultLabelAttr<'a> {\n     #[label]\n     span: Span,\n@@ -337,15 +337,15 @@ struct ErrorWithDefaultLabelAttr<'a> {\n \n #[derive(Diagnostic)]\n //~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ArgFieldWithoutSkip {\n     #[primary_span]\n     span: Span,\n     other: Hello,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ArgFieldWithSkip {\n     #[primary_span]\n     span: Span,\n@@ -356,298 +356,298 @@ struct ArgFieldWithSkip {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithSpannedNote {\n     #[note]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithSpannedNoteCustom {\n-    #[note(compiletest::note)]\n+    #[note(note)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n #[note]\n struct ErrorWithNote {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n-#[note(compiletest::note)]\n+#[diag(compiletest_example, code = \"E0123\")]\n+#[note(note)]\n struct ErrorWithNoteCustom {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithSpannedHelp {\n     #[help]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithSpannedHelpCustom {\n-    #[help(compiletest::help)]\n+    #[help(help)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n #[help]\n struct ErrorWithHelp {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n-#[help(compiletest::help)]\n+#[diag(compiletest_example, code = \"E0123\")]\n+#[help(help)]\n struct ErrorWithHelpCustom {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithHelpWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[help(compiletest::help)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[help(help)]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithHelpCustomWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n #[note]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithNoteWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[note(compiletest::note)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[note(note)]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithNoteCustomWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ApplicabilityInBoth {\n-    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     //~^ ERROR specified multiple times\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct InvalidApplicability {\n-    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"batman\")]\n+    #[suggestion(suggestion, code = \"...\", applicability = \"batman\")]\n     //~^ ERROR invalid applicability\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ValidApplicability {\n-    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct NoApplicability {\n-    #[suggestion(compiletest::suggestion, code = \"...\")]\n+    #[suggestion(suggestion, code = \"...\")]\n     suggestion: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(parser::add_paren)]\n+#[note(parser_add_paren)]\n struct Note;\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct VecField {\n     #[primary_span]\n     #[label]\n     spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct UnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: (),\n-    #[help(compiletest::help)]\n+    #[help(help)]\n     bar: (),\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct OptUnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: Option<()>,\n-    #[help(compiletest::help)]\n+    #[help(help)]\n     bar: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct LabelWithTrailingPath {\n-    #[label(compiletest::label, foo)]\n+    #[label(label, foo)]\n     //~^ ERROR `#[label(foo)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n-    #[label(compiletest::label, foo = \"...\")]\n+    #[label(label, foo = \"...\")]\n     //~^ ERROR `#[label(foo = ...)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct LabelWithTrailingList {\n-    #[label(compiletest::label, foo(\"...\"))]\n+    #[label(label, foo(\"...\"))]\n     //~^ ERROR `#[label(foo(...))]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct LintsGood {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct PrimarySpanOnLint {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct ErrorWithMultiSpan {\n     #[primary_span]\n     span: MultiSpan,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n #[warning]\n struct ErrorWithWarn {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[error(compiletest::example, code = \"E0123\")]\n+#[error(compiletest_example, code = \"E0123\")]\n //~^ ERROR `#[error(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `error` in this scope\n struct ErrorAttribute {}\n \n #[derive(Diagnostic)]\n-#[warn_(compiletest::example, code = \"E0123\")]\n+#[warn_(compiletest_example, code = \"E0123\")]\n //~^ ERROR `#[warn_(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `warn_` in this scope\n struct WarnAttribute {}\n \n #[derive(Diagnostic)]\n-#[lint(compiletest::example, code = \"E0123\")]\n+#[lint(compiletest_example, code = \"E0123\")]\n //~^ ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `lint` in this scope\n struct LintAttributeOnSessionDiag {}\n \n #[derive(LintDiagnostic)]\n-#[lint(compiletest::example, code = \"E0123\")]\n+#[lint(compiletest_example, code = \"E0123\")]\n //~^ ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `lint` in this scope\n struct LintAttributeOnLintDiag {}\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct DuplicatedSuggestionCode {\n-    #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n+    #[suggestion(suggestion, code = \"...\", code = \",,,\")]\n     //~^ ERROR specified multiple times\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct InvalidTypeInSuggestionTuple {\n-    #[suggestion(compiletest::suggestion, code = \"...\")]\n+    #[suggestion(suggestion, code = \"...\")]\n     suggestion: (Span, usize),\n     //~^ ERROR wrong types for suggestion\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct MissingApplicabilityInSuggestionTuple {\n-    #[suggestion(compiletest::suggestion, code = \"...\")]\n+    #[suggestion(suggestion, code = \"...\")]\n     suggestion: (Span,),\n     //~^ ERROR wrong types for suggestion\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct MissingCodeInSuggestion {\n-    #[suggestion(compiletest::suggestion)]\n+    #[suggestion(suggestion)]\n     //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n-#[multipart_suggestion(compiletest::suggestion)]\n+#[diag(compiletest_example, code = \"E0123\")]\n+#[multipart_suggestion(suggestion)]\n //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n #[multipart_suggestion()]\n //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n struct MultipartSuggestion {\n-    #[multipart_suggestion(compiletest::suggestion)]\n+    #[multipart_suggestion(suggestion)]\n     //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n     //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n-#[suggestion(compiletest::suggestion, code = \"...\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n+#[suggestion(suggestion, code = \"...\")]\n //~^ ERROR `#[suggestion(...)]` is not a valid attribute\n struct SuggestionOnStruct {\n     #[primary_span]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n #[label]\n //~^ ERROR `#[label]` is not a valid attribute\n struct LabelOnStruct {\n@@ -657,70 +657,70 @@ struct LabelOnStruct {\n \n #[derive(Diagnostic)]\n enum ExampleEnum {\n-    #[diag(compiletest::example)]\n+    #[diag(compiletest_example)]\n     Foo {\n         #[primary_span]\n         sp: Span,\n         #[note]\n         note_sp: Span,\n     },\n-    #[diag(compiletest::example)]\n+    #[diag(compiletest_example)]\n     Bar {\n         #[primary_span]\n         sp: Span,\n     },\n-    #[diag(compiletest::example)]\n+    #[diag(compiletest_example)]\n     Baz,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct RawIdentDiagnosticArg {\n     pub r#type: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticBad {\n     #[subdiagnostic(bad)]\n //~^ ERROR `#[subdiagnostic(bad)]` is not a valid attribute\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticBadStr {\n     #[subdiagnostic = \"bad\"]\n //~^ ERROR `#[subdiagnostic = ...]` is not a valid attribute\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticBadTwice {\n     #[subdiagnostic(bad, bad)]\n //~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticBadLitStr {\n     #[subdiagnostic(\"bad\")]\n //~^ ERROR `#[subdiagnostic(\"...\")]` is not a valid attribute\n     note: Note,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticEagerLint {\n     #[subdiagnostic(eager)]\n //~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticEagerCorrect {\n     #[subdiagnostic(eager)]\n     note: Note,\n@@ -732,7 +732,7 @@ struct SubdiagnosticEagerCorrect {\n \n #[derive(Subdiagnostic)]\n #[suggestion_short(\n-    parser::use_instead,\n+    use_instead,\n     applicability = \"machine-applicable\",\n     code = \"{correct}\"\n )]\n@@ -744,15 +744,15 @@ pub(crate) struct SubdiagnosticWithSuggestion {\n }\n \n #[derive(Diagnostic)]\n-#[diag(compiletest::example)]\n+#[diag(compiletest_example)]\n struct SubdiagnosticEagerSuggestion {\n     #[subdiagnostic(eager)]\n     sub: SubdiagnosticWithSuggestion,\n }\n \n /// with a doc comment on the type..\n #[derive(Diagnostic)]\n-#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest_example, code = \"E0123\")]\n struct WithDocComment {\n     /// ..and the field\n     #[primary_span]"}, {"sha": "0a1c4bddb06a089eafc54d7deb989daa39769d4c", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -1,24 +1,24 @@\n error: unsupported type attribute for diagnostic derive enum\n   --> $DIR/diagnostic-derive.rs:39:1\n    |\n-LL | #[diag(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:42:5\n    |\n LL |     Foo,\n    |     ^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:44:5\n    |\n LL |     Bar,\n    |     ^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag = ...]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:50:1\n@@ -29,20 +29,20 @@ LL | #[diag = \"E0123\"]\n error: `#[nonsense(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:55:1\n    |\n-LL | #[nonsense(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[nonsense(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:55:1\n    |\n-LL | / #[nonsense(compiletest::example, code = \"E0123\")]\n+LL | / #[nonsense(compiletest_example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct InvalidStructAttr {}\n    | |___________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag(\"...\")]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:62:8\n@@ -61,7 +61,7 @@ LL | |\n LL | | struct InvalidLitNestedAttr {}\n    | |______________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag(nonsense(...))]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:73:8\n@@ -80,7 +80,7 @@ LL | |\n LL | | struct InvalidNestedStructAttr1 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:79:8\n@@ -108,7 +108,7 @@ LL | |\n LL | | struct InvalidNestedStructAttr2 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:86:8\n@@ -134,13 +134,13 @@ LL | |\n LL | | struct InvalidNestedStructAttr3 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:93:46\n+  --> $DIR/diagnostic-derive.rs:93:45\n    |\n-LL | #[diag(compiletest::example, code = \"E0123\", slug = \"foo\")]\n-   |                                              ^^^^^^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0123\", slug = \"foo\")]\n+   |                                             ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n@@ -153,44 +153,44 @@ LL |     #[suggestion = \"bar\"]\n error: specified multiple times\n   --> $DIR/diagnostic-derive.rs:107:8\n    |\n-LL | #[diag(compiletest::example, code = \"E0456\")]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0456\")]\n+   |        ^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n   --> $DIR/diagnostic-derive.rs:106:8\n    |\n-LL | #[diag(compiletest::example, code = \"E0123\")]\n-   |        ^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0123\")]\n+   |        ^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:107:37\n+  --> $DIR/diagnostic-derive.rs:107:36\n    |\n-LL | #[diag(compiletest::example, code = \"E0456\")]\n-   |                                     ^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0456\")]\n+   |                                    ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:106:37\n+  --> $DIR/diagnostic-derive.rs:106:36\n    |\n-LL | #[diag(compiletest::example, code = \"E0123\")]\n-   |                                     ^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0123\")]\n+   |                                    ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:113:53\n+  --> $DIR/diagnostic-derive.rs:113:52\n    |\n-LL | #[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n-   |                                                     ^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0456\", code = \"E0457\")]\n+   |                                                    ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:113:37\n+  --> $DIR/diagnostic-derive.rs:113:36\n    |\n-LL | #[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n-   |                                     ^^^^^^^\n+LL | #[diag(compiletest_example, code = \"E0456\", code = \"E0457\")]\n+   |                                    ^^^^^^^\n \n-error: `#[diag(compiletest::example)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:118:30\n+error: `#[diag(compiletest_example)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:118:29\n    |\n-LL | #[diag(compiletest::example, compiletest::example, code = \"E0456\")]\n-   |                              ^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest_example, compiletest_example, code = \"E0456\")]\n+   |                             ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: diagnostic slug must be the first argument\n \n@@ -200,7 +200,7 @@ error: diagnostic slug not specified\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:126:1\n@@ -210,7 +210,7 @@ LL | |\n LL | | struct SlugNotProvided {}\n    | |_________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:137:5\n@@ -227,14 +227,14 @@ LL |     #[nonsense]\n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:162:5\n    |\n-LL |     #[label(compiletest::label)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(label)]\n+   |     ^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:170:50\n+  --> $DIR/diagnostic-derive.rs:170:37\n    |\n-LL |     #[suggestion(compiletest::suggestion, code = \"{name}\")]\n-   |                                                  ^^^^^^^^\n+LL |     #[suggestion(suggestion, code = \"{name}\")]\n+   |                                     ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n   --> $DIR/diagnostic-derive.rs:175:10\n@@ -257,14 +257,14 @@ LL | #[derive(Diagnostic)]\n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:205:5\n    |\n-LL |     #[label(compiletest::label)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(label)]\n+   |     ^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:223:5\n    |\n-LL |     #[suggestion(compiletest::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:231:18\n@@ -297,7 +297,7 @@ LL |     #[suggestion(msg = \"bar\")]\n error: wrong field type for suggestion\n   --> $DIR/diagnostic-derive.rs:263:5\n    |\n-LL | /     #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n+LL | /     #[suggestion(suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: Applicability,\n    | |_____________________________^\n@@ -335,10 +335,10 @@ LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:445:57\n+  --> $DIR/diagnostic-derive.rs:445:44\n    |\n-LL |     #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n   --> $DIR/diagnostic-derive.rs:447:24\n@@ -347,30 +347,30 @@ LL |     suggestion: (Span, Applicability),\n    |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:453:57\n+  --> $DIR/diagnostic-derive.rs:453:44\n    |\n-LL |     #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"batman\")]\n-   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion, code = \"...\", applicability = \"batman\")]\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(foo)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:516:33\n+  --> $DIR/diagnostic-derive.rs:516:20\n    |\n-LL |     #[label(compiletest::label, foo)]\n-   |                                 ^^^\n+LL |     #[label(label, foo)]\n+   |                    ^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: `#[label(foo = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:524:33\n+  --> $DIR/diagnostic-derive.rs:524:20\n    |\n-LL |     #[label(compiletest::label, foo = \"...\")]\n-   |                                 ^^^^^^^^^^^\n+LL |     #[label(label, foo = \"...\")]\n+   |                    ^^^^^^^^^^^\n \n error: `#[label(foo(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:532:33\n+  --> $DIR/diagnostic-derive.rs:532:20\n    |\n-LL |     #[label(compiletest::label, foo(\"...\"))]\n-   |                                 ^^^^^^^^^^\n+LL |     #[label(label, foo(\"...\"))]\n+   |                    ^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:545:5\n@@ -383,93 +383,93 @@ LL |     #[primary_span]\n error: `#[error(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | #[error(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | / #[error(compiletest::example, code = \"E0123\")]\n+LL | / #[error(compiletest_example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct ErrorAttribute {}\n    | |________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:572:1\n    |\n-LL | #[warn_(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[warn_(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:572:1\n    |\n-LL | / #[warn_(compiletest::example, code = \"E0123\")]\n+LL | / #[warn_(compiletest_example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct WarnAttribute {}\n    | |_______________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:579:1\n    |\n-LL | #[lint(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:579:1\n    |\n-LL | / #[lint(compiletest::example, code = \"E0123\")]\n+LL | / #[lint(compiletest_example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct LintAttributeOnSessionDiag {}\n    | |____________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis_example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | #[lint(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | #[lint(compiletest::example, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest_example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | / #[lint(compiletest::example, code = \"E0123\")]\n+LL | / #[lint(compiletest_example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | |\n LL | | struct LintAttributeOnLintDiag {}\n    | |_________________________________^\n    |\n-   = help: specify the slug as the first argument to the attribute, such as `#[diag(compiletest::example)]`\n+   = help: specify the slug as the first argument to the attribute, such as `#[diag(compiletest_example)]`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:596:57\n+  --> $DIR/diagnostic-derive.rs:596:44\n    |\n-LL |     #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n-   |                                                         ^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion, code = \"...\", code = \",,,\")]\n+   |                                            ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:596:43\n+  --> $DIR/diagnostic-derive.rs:596:30\n    |\n-LL |     #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n-   |                                           ^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion, code = \"...\", code = \",,,\")]\n+   |                              ^^^^^^^^^^^^\n \n error: wrong types for suggestion\n   --> $DIR/diagnostic-derive.rs:605:24\n@@ -490,14 +490,14 @@ LL |     suggestion: (Span,),\n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:620:5\n    |\n-LL |     #[suggestion(compiletest::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:627:1\n    |\n-LL | #[multipart_suggestion(compiletest::suggestion)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[multipart_suggestion(suggestion)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n@@ -512,16 +512,16 @@ LL | #[multipart_suggestion()]\n error: `#[multipart_suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:634:5\n    |\n-LL |     #[multipart_suggestion(compiletest::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[multipart_suggestion(suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:642:1\n    |\n-LL | #[suggestion(compiletest::suggestion, code = \"...\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[suggestion(suggestion, code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n@@ -576,7 +576,7 @@ LL |     #[subdiagnostic(eager)]\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n-LL | #[nonsense(compiletest::example, code = \"E0123\")]\n+LL | #[nonsense(compiletest_example, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n@@ -588,31 +588,31 @@ LL |     #[nonsense]\n error: cannot find attribute `error` in this scope\n   --> $DIR/diagnostic-derive.rs:565:3\n    |\n-LL | #[error(compiletest::example, code = \"E0123\")]\n+LL | #[error(compiletest_example, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n   --> $DIR/diagnostic-derive.rs:572:3\n    |\n-LL | #[warn_(compiletest::example, code = \"E0123\")]\n+LL | #[warn_(compiletest_example, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n   --> $DIR/diagnostic-derive.rs:579:3\n    |\n-LL | #[lint(compiletest::example, code = \"E0123\")]\n+LL | #[lint(compiletest_example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n   --> $DIR/diagnostic-derive.rs:586:3\n    |\n-LL | #[lint(compiletest::example, code = \"E0123\")]\n+LL | #[lint(compiletest_example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `multipart_suggestion` in this scope\n   --> $DIR/diagnostic-derive.rs:627:3\n    |\n-LL | #[multipart_suggestion(compiletest::suggestion)]\n+LL | #[multipart_suggestion(suggestion)]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n@@ -624,7 +624,7 @@ LL | #[multipart_suggestion()]\n error: cannot find attribute `multipart_suggestion` in this scope\n   --> $DIR/diagnostic-derive.rs:634:7\n    |\n-LL |     #[multipart_suggestion(compiletest::suggestion)]\n+LL |     #[multipart_suggestion(suggestion)]\n    |       ^^^^^^^^^^^^^^^^^^^^\n \n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`"}, {"sha": "9088ca6ce462bb2c4b2cd039c051a9aed739898e", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -20,7 +20,7 @@ use rustc_span::Span;\n use rustc_macros::Subdiagnostic;\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct A {\n     #[primary_span]\n     span: Span,\n@@ -29,13 +29,13 @@ struct A {\n \n #[derive(Subdiagnostic)]\n enum B {\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n         var: String,\n     },\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     B {\n         #[primary_span]\n         span: Span,\n@@ -44,7 +44,7 @@ enum B {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n //~^ ERROR label without `#[primary_span]` field\n struct C {\n     var: String,\n@@ -138,7 +138,7 @@ struct M {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren, code = \"...\")]\n+#[label(parser_add_paren, code = \"...\")]\n //~^ ERROR `#[label(code = ...)]` is not a valid attribute\n struct N {\n     #[primary_span]\n@@ -147,7 +147,7 @@ struct N {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren, applicability = \"machine-applicable\")]\n+#[label(parser_add_paren, applicability = \"machine-applicable\")]\n //~^ ERROR `#[label(applicability = ...)]` is not a valid attribute\n struct O {\n     #[primary_span]\n@@ -160,7 +160,7 @@ struct O {\n //~^ ERROR cannot find attribute `foo` in this scope\n //~^^ ERROR unsupported type attribute for subdiagnostic enum\n enum P {\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -230,7 +230,7 @@ enum U {\n \n #[derive(Subdiagnostic)]\n enum V {\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -244,7 +244,7 @@ enum V {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n //~^ ERROR label without `#[primary_span]` field\n struct W {\n     #[primary_span]\n@@ -253,7 +253,7 @@ struct W {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct X {\n     #[primary_span]\n     span: Span,\n@@ -263,7 +263,7 @@ struct X {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct Y {\n     #[primary_span]\n     span: Span,\n@@ -274,7 +274,7 @@ struct Y {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct Z {\n     #[primary_span]\n     span: Span,\n@@ -285,7 +285,7 @@ struct Z {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct AA {\n     #[primary_span]\n     span: Span,\n@@ -296,7 +296,7 @@ struct AA {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct AB {\n     #[primary_span]\n     span: Span,\n@@ -312,23 +312,23 @@ union AC {\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n+#[label(parser_add_paren)]\n struct AD {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren, parser::add_paren)]\n-//~^ ERROR `#[label(parser::add_paren)]` is not a valid attribute\n+#[label(parser_add_paren, parser_add_paren)]\n+//~^ ERROR `#[label(parser_add_paren)]` is not a valid attribute\n struct AE {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct AF {\n     #[primary_span]\n     //~^ NOTE previously specified here\n@@ -346,7 +346,7 @@ struct AG {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n struct AH {\n     #[primary_span]\n     span: Span,\n@@ -357,15 +357,15 @@ struct AH {\n \n #[derive(Subdiagnostic)]\n enum AI {\n-    #[suggestion(parser::add_paren, code = \"...\")]\n+    #[suggestion(parser_add_paren, code = \"...\")]\n     A {\n         #[primary_span]\n         span: Span,\n         #[applicability]\n         applicability: Applicability,\n         var: String,\n     },\n-    #[suggestion(parser::add_paren, code = \"...\")]\n+    #[suggestion(parser_add_paren, code = \"...\")]\n     B {\n         #[primary_span]\n         span: Span,\n@@ -376,7 +376,7 @@ enum AI {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\", code = \"...\")]\n //~^ ERROR specified multiple times\n //~^^ NOTE previously specified here\n struct AJ {\n@@ -387,7 +387,7 @@ struct AJ {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n struct AK {\n     #[primary_span]\n     span: Span,\n@@ -400,7 +400,7 @@ struct AK {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n struct AL {\n     #[primary_span]\n     span: Span,\n@@ -410,14 +410,14 @@ struct AL {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n struct AM {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren)]\n+#[suggestion(parser_add_paren)]\n //~^ ERROR suggestion without `code = \"...\"`\n struct AN {\n     #[primary_span]\n@@ -427,32 +427,32 @@ struct AN {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n+#[suggestion(parser_add_paren, code =\"...\", applicability = \"foo\")]\n //~^ ERROR invalid applicability\n struct AO {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[help(parser::add_paren)]\n+#[help(parser_add_paren)]\n struct AP {\n     var: String\n }\n \n #[derive(Subdiagnostic)]\n-#[note(parser::add_paren)]\n+#[note(parser_add_paren)]\n struct AQ;\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n //~^ ERROR suggestion without `#[primary_span]` field\n struct AR {\n     var: String,\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code =\"...\", applicability = \"machine-applicable\")]\n+#[suggestion(parser_add_paren, code =\"...\", applicability = \"machine-applicable\")]\n struct AS {\n     #[primary_span]\n     span: Span,\n@@ -462,7 +462,7 @@ struct AS {\n #[label]\n //~^ ERROR unsupported type attribute for subdiagnostic enum\n enum AT {\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -471,15 +471,15 @@ enum AT {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+#[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n struct AU {\n     #[primary_span]\n     span: Span,\n     var: String,\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+#[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n //~^ ERROR `var` doesn't refer to a field on this type\n struct AV {\n     #[primary_span]\n@@ -488,7 +488,7 @@ struct AV {\n \n #[derive(Subdiagnostic)]\n enum AW {\n-    #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+    #[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -498,7 +498,7 @@ enum AW {\n \n #[derive(Subdiagnostic)]\n enum AX {\n-    #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+    #[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n //~^ ERROR `var` doesn't refer to a field on this type\n     A {\n         #[primary_span]\n@@ -507,18 +507,18 @@ enum AX {\n }\n \n #[derive(Subdiagnostic)]\n-#[warning(parser::add_paren)]\n+#[warning(parser_add_paren)]\n struct AY {}\n \n #[derive(Subdiagnostic)]\n-#[warning(parser::add_paren)]\n+#[warning(parser_add_paren)]\n struct AZ {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n+#[suggestion(parser_add_paren, code = \"...\")]\n //~^ ERROR suggestion without `#[primary_span]` field\n struct BA {\n     #[suggestion_part]\n@@ -533,31 +533,31 @@ struct BA {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, code = \"...\", applicability = \"machine-applicable\")]\n //~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n //~| ERROR `#[multipart_suggestion(code = ...)]` is not a valid attribute\n struct BBa {\n     var: String,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BBb {\n     #[suggestion_part]\n     //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n     span1: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BBc {\n     #[suggestion_part()]\n     //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n     span1: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n+#[multipart_suggestion(parser_add_paren)]\n //~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n struct BC {\n     #[primary_span]\n@@ -566,7 +566,7 @@ struct BC {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n+#[multipart_suggestion(parser_add_paren)]\n struct BD {\n     #[suggestion_part]\n     //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n@@ -586,7 +586,7 @@ struct BD {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BE {\n     #[suggestion_part(code = \"...\", code = \",,,\")]\n     //~^ ERROR specified multiple times\n@@ -595,7 +595,7 @@ struct BE {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BF {\n     #[suggestion_part(code = \"(\")]\n     first: Span,\n@@ -604,7 +604,7 @@ struct BF {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n+#[multipart_suggestion(parser_add_paren)]\n struct BG {\n     #[applicability]\n     appl: Applicability,\n@@ -615,7 +615,7 @@ struct BG {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BH {\n     #[applicability]\n     //~^ ERROR `#[applicability]` has no effect\n@@ -627,14 +627,14 @@ struct BH {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(parser_add_paren, applicability = \"machine-applicable\")]\n struct BI {\n     #[suggestion_part(code = \"\")]\n     spans: Vec<Span>,\n }\n \n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct BJ {\n     #[primary_span]\n     span: Span,\n@@ -643,7 +643,7 @@ struct BJ {\n \n /// with a doc comment on the type..\n #[derive(Subdiagnostic)]\n-#[label(parser::add_paren)]\n+#[label(parser_add_paren)]\n struct BK {\n     /// ..and the field\n     #[primary_span]\n@@ -654,7 +654,7 @@ struct BK {\n #[derive(Subdiagnostic)]\n enum BL {\n     /// ..and the variant..\n-    #[label(parser::add_paren)]\n+    #[label(parser_add_paren)]\n     Foo {\n         /// ..and the field\n         #[primary_span]"}, {"sha": "b21f9cc94a98c37565b9796b690c28cbe3f5cb44", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e64f1110c062f61746f222059439529a43ccf6dc/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=e64f1110c062f61746f222059439529a43ccf6dc", "patch": "@@ -1,7 +1,7 @@\n error: label without `#[primary_span]` field\n   --> $DIR/subdiagnostic-derive.rs:47:1\n    |\n-LL | / #[label(parser::add_paren)]\n+LL | / #[label(parser_add_paren)]\n LL | |\n LL | | struct C {\n LL | |     var: String,\n@@ -81,16 +81,16 @@ LL | #[label()]\n    | ^^^^^^^^^^\n \n error: `#[label(code = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:141:28\n+  --> $DIR/subdiagnostic-derive.rs:141:27\n    |\n-LL | #[label(parser::add_paren, code = \"...\")]\n-   |                            ^^^^^^^^^^^^\n+LL | #[label(parser_add_paren, code = \"...\")]\n+   |                           ^^^^^^^^^^^^\n \n error: `#[label(applicability = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:150:28\n+  --> $DIR/subdiagnostic-derive.rs:150:27\n    |\n-LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser_add_paren, applicability = \"machine-applicable\")]\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n   --> $DIR/subdiagnostic-derive.rs:159:1\n@@ -143,7 +143,7 @@ LL |     #[primary_span]\n error: label without `#[primary_span]` field\n   --> $DIR/subdiagnostic-derive.rs:247:1\n    |\n-LL | / #[label(parser::add_paren)]\n+LL | / #[label(parser_add_paren)]\n LL | |\n LL | | struct W {\n LL | |     #[primary_span]\n@@ -190,11 +190,11 @@ LL | |     b: u64\n LL | | }\n    | |_^\n \n-error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:323:28\n+error: `#[label(parser_add_paren)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:323:27\n    |\n-LL | #[label(parser::add_paren, parser::add_paren)]\n-   |                            ^^^^^^^^^^^^^^^^^\n+LL | #[label(parser_add_paren, parser_add_paren)]\n+   |                           ^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n@@ -217,16 +217,16 @@ LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:379:47\n+  --> $DIR/subdiagnostic-derive.rs:379:46\n    |\n-LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n-   |                                               ^^^^^^^^^^^^\n+LL | #[suggestion(parser_add_paren, code = \"...\", code = \"...\")]\n+   |                                              ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:379:33\n+  --> $DIR/subdiagnostic-derive.rs:379:32\n    |\n-LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n-   |                                 ^^^^^^^^^^^^\n+LL | #[suggestion(parser_add_paren, code = \"...\", code = \"...\")]\n+   |                                ^^^^^^^^^^^^\n \n error: specified multiple times\n   --> $DIR/subdiagnostic-derive.rs:397:5\n@@ -249,19 +249,19 @@ LL |     #[applicability]\n error: suggestion without `code = \"...\"`\n   --> $DIR/subdiagnostic-derive.rs:420:1\n    |\n-LL | #[suggestion(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[suggestion(parser_add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:430:46\n+  --> $DIR/subdiagnostic-derive.rs:430:45\n    |\n-LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^\n+LL | #[suggestion(parser_add_paren, code =\"...\", applicability = \"foo\")]\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `#[primary_span]` field\n   --> $DIR/subdiagnostic-derive.rs:448:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | / #[suggestion(parser_add_paren, code = \"...\")]\n LL | |\n LL | | struct AR {\n LL | |     var: String,\n@@ -275,16 +275,16 @@ LL | #[label]\n    | ^^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:482:39\n+  --> $DIR/subdiagnostic-derive.rs:482:38\n    |\n-LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                       ^^^^^^^\n+LL | #[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                      ^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:501:43\n+  --> $DIR/subdiagnostic-derive.rs:501:42\n    |\n-LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^\n+LL |     #[suggestion(parser_add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                          ^^^^^^^\n \n error: `#[suggestion_part]` is not a valid attribute\n   --> $DIR/subdiagnostic-derive.rs:524:5\n@@ -305,7 +305,7 @@ LL |     #[suggestion_part(code = \"...\")]\n error: suggestion without `#[primary_span]` field\n   --> $DIR/subdiagnostic-derive.rs:521:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | / #[suggestion(parser_add_paren, code = \"...\")]\n LL | |\n LL | | struct BA {\n LL | |     #[suggestion_part]\n@@ -315,17 +315,17 @@ LL | | }\n    | |_^\n \n error: `#[multipart_suggestion(code = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:536:43\n+  --> $DIR/subdiagnostic-derive.rs:536:42\n    |\n-LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^^^^^^\n+LL | #[multipart_suggestion(parser_add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+   |                                          ^^^^^^^^^^^^\n    |\n    = help: only `applicability` is a valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n   --> $DIR/subdiagnostic-derive.rs:536:1\n    |\n-LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+LL | / #[multipart_suggestion(parser_add_paren, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n LL | |\n LL | | struct BBa {\n@@ -356,7 +356,7 @@ LL |     #[primary_span]\n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n   --> $DIR/subdiagnostic-derive.rs:560:1\n    |\n-LL | / #[multipart_suggestion(parser::add_paren)]\n+LL | / #[multipart_suggestion(parser_add_paren)]\n LL | |\n LL | | struct BC {\n LL | |     #[primary_span]"}]}