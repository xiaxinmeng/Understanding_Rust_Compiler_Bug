{"sha": "9b820d0d634483e5400b1da52340a0606a32c84a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliODIwZDBkNjM0NDgzZTU0MDBiMWRhNTIzNDBhMDYwNmEzMmM4NGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-04T10:22:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-04T22:03:08Z"}, "message": "Correct the subtyping relations created by the pattern typechecking\ncode. Previously we were creating a subtyping relation in the wrong\ndirection. We now just unify types, which is stronger than necessary\nbut turns out fine.\n\nFixes #19552.\nFixes #19997.", "tree": {"sha": "b333150a1e846669ced81dc980e564f42ee860ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b333150a1e846669ced81dc980e564f42ee860ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b820d0d634483e5400b1da52340a0606a32c84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b820d0d634483e5400b1da52340a0606a32c84a", "html_url": "https://github.com/rust-lang/rust/commit/9b820d0d634483e5400b1da52340a0606a32c84a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b820d0d634483e5400b1da52340a0606a32c84a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc", "html_url": "https://github.com/rust-lang/rust/commit/fe7e285d0cbae8e44c3853a6965caf2b575dcfcc"}], "stats": {"total": 260, "additions": 251, "deletions": 9}, "files": [{"sha": "d0fd5732f233d0850040e59b6616e3322abe7ee1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -46,6 +46,19 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_expr(fcx, &**lt);\n             let expr_ty = fcx.expr_ty(&**lt);\n             fcx.write_ty(pat.id, expr_ty);\n+\n+            // somewhat surprising: in this case, the subtyping\n+            // relation goes the opposite way as the other\n+            // cases. Actually what we really want is not a subtyping\n+            // relation at all but rather that there exists a LUB (so\n+            // that they can be compared). However, in practice,\n+            // constants are always scalars or strings.  For scalars\n+            // subtyping is irrelevant, and for strings `expr_ty` is\n+            // type is `&'static str`, so if we say that\n+            //\n+            //     &'static str <: expected\n+            //\n+            // that's equivalent to there existing a LUB.\n             demand::suptype(fcx, pat.span, expected, expr_ty);\n         }\n         ast::PatRange(ref begin, ref end) => {\n@@ -54,10 +67,16 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let lhs_ty = fcx.expr_ty(&**begin);\n             let rhs_ty = fcx.expr_ty(&**end);\n-            if require_same_types(\n-                tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n-                || \"mismatched types in range\".to_string())\n-                && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(rhs_ty)) {\n+\n+            let lhs_eq_rhs =\n+                require_same_types(\n+                    tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n+                    || \"mismatched types in range\".to_string());\n+\n+            let numeric_or_char =\n+                lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n+\n+            if numeric_or_char {\n                 match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                     Some(false) => {\n                         span_err!(tcx.sess, begin.span, E0030,\n@@ -75,6 +94,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n \n             fcx.write_ty(pat.id, lhs_ty);\n+\n+            // subtyping doens't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n@@ -89,20 +110,29 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 ast::BindByRef(mutbl) => {\n                     // if the binding is like\n                     //    ref x | ref const x | ref mut x\n-                    // then the type of x is &M T where M is the mutability\n-                    // and T is the expected type\n+                    // then `x` is assigned a value of type `&M T` where M is the mutability\n+                    // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n                     let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n+\n+                    // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n+                    // required. However, we use equality, which is stronger. See (*) for\n+                    // an explanation.\n                     demand::eqtype(fcx, pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n                 ast::BindByValue(_) => {\n+                    // As above, `T <: typeof(x)` is required but we\n+                    // use equality, see (*) below.\n                     demand::eqtype(fcx, pat.span, expected, typ);\n                 }\n             }\n+\n             fcx.write_ty(pat.id, typ);\n \n+            // if there are multiple arms, make sure they all agree on\n+            // what the type of the binding `x` ought to be\n             let canon_id = pcx.map[path.node];\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n@@ -138,7 +168,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, uniq_ty);\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using\n+                // `demand::eqtype`.\n+                demand::eqtype(fcx, pat.span, expected, uniq_ty);\n                 fcx.write_ty(pat.id, uniq_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n@@ -158,7 +191,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, rptr_ty);\n+                // `demand::subtype` would be good enough, but using\n+                // `eqtype` turns out to be equally general. See (*)\n+                // below for details.\n+                demand::eqtype(fcx, pat.span, expected, rptr_ty);\n                 fcx.write_ty(pat.id, rptr_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n@@ -188,7 +224,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             };\n \n             fcx.write_ty(pat.id, pat_ty);\n-            demand::suptype(fcx, pat.span, expected, pat_ty);\n+\n+            // `demand::subtype` would be good enough, but using\n+            // `eqtype` turns out to be equally general. See (*)\n+            // below for details.\n+            demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n             for elt in before.iter() {\n                 check_pat(pcx, &**elt, inner_ty);\n@@ -210,6 +250,56 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatMac(_) => tcx.sess.bug(\"unexpanded macro\")\n     }\n+\n+\n+    // (*) In most of the cases above (literals and constants being\n+    // the exception), we relate types using strict equality, evewn\n+    // though subtyping would be sufficient. There are a few reasons\n+    // for this, some of which are fairly subtle and which cost me\n+    // (nmatsakis) an hour or two debugging to remember, so I thought\n+    // I'd write them down this time.\n+    //\n+    // 1. Most importantly, there is no loss of expressiveness\n+    // here. What we are saying is that the type of `x`\n+    // becomes *exactly* what is expected. This might seem\n+    // like it will cause errors in a case like this:\n+    //\n+    // ```\n+    // fn foo<'x>(x: &'x int) {\n+    //    let a = 1;\n+    //    let mut z = x;\n+    //    z = &a;\n+    // }\n+    // ```\n+    //\n+    // The reason we might get an error is that `z` might be\n+    // assigned a type like `&'x int`, and then we would have\n+    // a problem when we try to assign `&a` to `z`, because\n+    // the lifetime of `&a` (i.e., the enclosing block) is\n+    // shorter than `'x`.\n+    //\n+    // HOWEVER, this code works fine. The reason is that the\n+    // expected type here is whatever type the user wrote, not\n+    // the initializer's type. In this case the user wrote\n+    // nothing, so we are going to create a type variable `Z`.\n+    // Then we will assign the type of the initializer (`&'x\n+    // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+    // will instantiate `Z` as a type `&'0 int` where `'0` is\n+    // a fresh region variable, with the constraint that `'x :\n+    // '0`.  So basically we're all set.\n+    //\n+    // Note that there are two tests to check that this remains true\n+    // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+    //\n+    // 2. Things go horribly wrong if we use subtype. The reason for\n+    // THIS is a fairly subtle case involving bound regions. See the\n+    // `givens` field in `region_inference`, as well as the test\n+    // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+    // for details. Short version is that we must sometimes detect\n+    // relationships between specific region variables and regions\n+    // bound in a closure signature, and that detection gets thrown\n+    // off when we substitute fresh region variables here to enable\n+    // subtyping.\n }\n \n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,"}, {"sha": "3f722c9433bb263a0ec5ef38312a08d132ecfaaf", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19552.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn assert_send<T: Send>(_t: T) {}\n+\n+fn main() {\n+    let line = String::new();\n+    match [line.as_slice()] { //~ ERROR `line` does not live long enough\n+        [ word ] => { assert_send(word); }\n+    }\n+}"}, {"sha": "da839d72172619e19ecf7be11edc97235752b54e", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19997.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a0 = 0u8;\n+    let f = 1u8;\n+    let mut a1 = &a0;\n+    match (&a1,) {\n+        (&ref b0,) => {\n+            a1 = &f; //~ ERROR cannot assign\n+        }\n+    }\n+}"}, {"sha": "ecf79de6222225dae29db4ff1f68bf3968cb2abd", "filename": "src/test/run-pass/regions-reassign-let-bound-pointer.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the type checker permits us to reassign `z` which\n+// started out with a longer lifetime and was reassigned to a shorter\n+// one (it should infer to be the intersection).\n+\n+fn foo(x: &int) {\n+    let a = 1;\n+    let mut z = x;\n+    z = &a;\n+}\n+\n+pub fn main() {\n+    foo(&1);\n+}"}, {"sha": "18312b17339ce3ab29a7dfa983637530bc75c8bf", "filename": "src/test/run-pass/regions-reassign-match-bound-pointer.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the type checker permits us to reassign `z` which\n+// started out with a longer lifetime and was reassigned to a shorter\n+// one (it should infer to be the intersection).\n+\n+fn foo(x: &int) {\n+    let a = 1;\n+    match x {\n+        mut z => {\n+            z = &a;\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    foo(&1);\n+}"}, {"sha": "aa0ed023da3e2170cd34614fa07192321c44fc0d", "filename": "src/test/run-pass/regions-relate-bound-regions-on-closures-to-inference-variables.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b820d0d634483e5400b1da52340a0606a32c84a/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs?ref=9b820d0d634483e5400b1da52340a0606a32c84a", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that this fairly specialized, but also reasonable, pattern\n+// typechecks. The pattern involves regions bound in closures that\n+// wind up related to inference variables.\n+//\n+// NB. Changes to the region implementatiosn have broken this pattern\n+// a few times, but it happens to be used in the compiler so those\n+// changes were caught. However, those uses in the compiler could\n+// easily get changed or refactored away in the future.\n+\n+struct Ctxt<'tcx> {\n+    x: &'tcx Vec<int>\n+}\n+\n+struct Foo<'a,'tcx:'a> {\n+    cx: &'a Ctxt<'tcx>,\n+}\n+\n+impl<'a,'tcx> Foo<'a,'tcx> {\n+    fn bother(&mut self) -> int {\n+        self.elaborate_bounds(|this| {\n+            // (*) Here: type of `this` is `&'f0 Foo<&'f1, '_2>`,\n+            // where `'f0` and `'f1` are fresh, free regions that\n+            // result from the bound regions on the closure, and `'2`\n+            // is a region inference variable created by the call. Due\n+            // to the constraints on the type, we find that `'_2 : 'f1\n+            // + 'f2` must hold (and can be assumed by the callee).\n+            // Region inference has to do some clever stuff to avoid\n+            // inferring `'_2` to be `'static` in this case, because\n+            // it is created outside the closure but then related to\n+            // regions bound by the closure itself. See the\n+            // `region_inference.rs` file (and the `givens` field, in\n+            // particular) for more details.\n+            this.foo()\n+        })\n+    }\n+\n+    fn foo(&mut self) -> int {\n+        22\n+    }\n+\n+    fn elaborate_bounds(\n+        &mut self,\n+        mk_cand: for<'b>|this: &mut Foo<'b, 'tcx>| -> int)\n+        -> int\n+    {\n+        mk_cand(self)\n+    }\n+}\n+\n+fn main() {\n+    let v = vec!();\n+    let cx = Ctxt { x: &v };\n+    let mut foo = Foo { cx: &cx };\n+    assert_eq!(foo.bother(), 22); // just so the code is not dead, basically\n+}"}]}