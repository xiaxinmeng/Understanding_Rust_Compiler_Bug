{"sha": "31fc42b7f778accb21db8daaf0f0e725948c9d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZmM0MmI3Zjc3OGFjY2IyMWRiOGRhYWYwZjBlNzI1OTQ4YzlkNmQ=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2019-11-02T15:12:42Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2019-11-02T15:12:42Z"}, "message": "Merge branch 'master' into format-temporaries", "tree": {"sha": "85ddf145a04d381abae1b01906206e83b3813fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85ddf145a04d381abae1b01906206e83b3813fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31fc42b7f778accb21db8daaf0f0e725948c9d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31fc42b7f778accb21db8daaf0f0e725948c9d6d", "html_url": "https://github.com/rust-lang/rust/commit/31fc42b7f778accb21db8daaf0f0e725948c9d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31fc42b7f778accb21db8daaf0f0e725948c9d6d/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8990f7d627525db934831cc29d5805172d80e156", "url": "https://api.github.com/repos/rust-lang/rust/commits/8990f7d627525db934831cc29d5805172d80e156", "html_url": "https://github.com/rust-lang/rust/commit/8990f7d627525db934831cc29d5805172d80e156"}, {"sha": "f39205b5d9825fcf35989b5a04d115d411175d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39205b5d9825fcf35989b5a04d115d411175d18", "html_url": "https://github.com/rust-lang/rust/commit/f39205b5d9825fcf35989b5a04d115d411175d18"}], "stats": {"total": 84071, "additions": 50154, "deletions": 33917}, "files": [{"sha": "487867c375d4529a0a7f0e36c6b2207665e174c6", "filename": ".gitignore", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,6 +1,10 @@\n-# This file should only ignore things that are generated during a build,\n-# generated by common IDEs, and optional files controlled by the user\n-# that affect the build (such as config.toml).\n+# This file should only ignore things that are generated during a `x.py` build,\n+# generated by common IDEs, and optional files controlled by the user that\n+# affect the build (such as config.toml).\n+# In particular, things like `mir_dump` should not be listed here; they are only\n+# created during manual debugging and many people like to clean up instead of\n+# having git ignore such leftovers. You can use `.git/info/exclude` to\n+# configure your local ignore list.\n # FIXME: This needs cleanup.\n *~\n .#*\n@@ -52,3 +56,4 @@ config.stamp\n Session.vim\n .cargo\n no_llvm_build\n+# Before adding new lines, see the comment at the top."}, {"sha": "31db0772cfb6b3f789fde5073b823f3c74908998", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -3,13 +3,13 @@\n \turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n-\turl = https://github.com/rust-lang-nursery/nomicon.git\n+\turl = https://github.com/rust-lang/nomicon.git\n [submodule \"src/tools/cargo\"]\n \tpath = src/tools/cargo\n \turl = https://github.com/rust-lang/cargo.git\n [submodule \"src/doc/reference\"]\n \tpath = src/doc/reference\n-\turl = https://github.com/rust-lang-nursery/reference.git\n+\turl = https://github.com/rust-lang/reference.git\n [submodule \"src/doc/book\"]\n \tpath = src/doc/book\n \turl = https://github.com/rust-lang/book.git\n@@ -28,9 +28,6 @@\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example.git\n-[submodule \"src/llvm-emscripten\"]\n-\tpath = src/llvm-emscripten\n-\turl = https://github.com/rust-lang/llvm.git\n [submodule \"src/stdarch\"]\n \tpath = src/stdarch\n \turl = https://github.com/rust-lang/stdarch.git\n@@ -39,7 +36,7 @@\n \turl = https://github.com/rust-lang/rustc-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n-\turl = https://github.com/rust-lang-nursery/edition-guide.git\n+\turl = https://github.com/rust-lang/edition-guide.git\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git"}, {"sha": "e3708bc485399fd42b32c6a1c24491771afa1a04", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,40 +1,3 @@\n # The Rust Code of Conduct\n \n-A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n-\n-## Conduct\n-\n-**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n-\n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n-* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n-* Please be kind and courteous. There's no need to be mean or rude.\n-* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n-* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n-* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n-\n-## Moderation\n-\n-\n-These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team][mod_team].\n-\n-1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n-2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n-3. Moderators will first respond to such remarks with a warning.\n-4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n-5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n-6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.\n-7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.\n-8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.\n-\n-In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.\n-\n-And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.\n-\n-The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust, #rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n-\n-*Adapted from the [Node.js Policy on Trolling](https://blog.izs.me/2012/08/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n-\n-[mod_team]: https://www.rust-lang.org/team.html#Moderation-team\n+The Code of Conduct for this repository [can be found online](https://www.rust-lang.org/conduct.html)."}, {"sha": "37a217d2a04523fb53a3cc1c1ed6031ca2ff787b", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -15,7 +15,7 @@ links to the major sections:\n * [Helpful Links and Information](#helpful-links-and-information)\n \n If you have questions, please make a post on [internals.rust-lang.org][internals] or\n-hop on the [Rust Discord server][rust-discord], [Rust Zulip server][rust-zulip] or [#rust-internals][pound-rust-internals].\n+hop on the [Rust Discord server][rust-discord] or [Rust Zulip server][rust-zulip].\n \n As a reminder, all contributors are expected to follow our [Code of Conduct][coc].\n \n@@ -25,7 +25,6 @@ to contribute to it in more detail than this document.\n If this is your first time contributing, the [walkthrough] chapter of the guide\n can give you a good example of how a typical contribution would go.\n \n-[pound-rust-internals]: https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n [internals]: https://internals.rust-lang.org\n [rust-discord]: http://discord.gg/rust-lang\n [rust-zulip]: https://rust-lang.zulipchat.com\n@@ -129,6 +128,14 @@ the master branch to your feature branch.\n Also, please make sure that fixup commits are squashed into other related\n commits with meaningful commit messages.\n \n+GitHub allows [closing issues using keywords][closing-keywords]. This feature\n+should be used to keep the issue tracker tidy. However, it is generally preferred\n+to put the \"closes #123\" text in the PR description rather than the issue commit;\n+particularly during rebasing, citing the issue number in the commit can \"spam\"\n+the issue in question.\n+\n+[closing-keywords]: https://help.github.com/en/articles/closing-issues-using-keywords\n+\n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n \n@@ -404,7 +411,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n There are a number of other ways to contribute to Rust that don't deal with\n this repository.\n \n-Answer questions in [#rust][pound-rust], or on [users.rust-lang.org][users],\n+Answer questions in the _Get Help!_ channels from the [Rust Discord server][rust-discord], on [users.rust-lang.org][users],\n or on [StackOverflow][so].\n \n Participate in the [RFC process](https://github.com/rust-lang/rfcs).\n@@ -413,7 +420,7 @@ Find a [requested community library][community-library], build it, and publish\n it to [Crates.io](http://crates.io). Easier said than done, but very, very\n valuable!\n \n-[pound-rust]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n+[rust-discord]: https://discord.gg/rust-lang\n [users]: https://users.rust-lang.org/\n [so]: http://stackoverflow.com/questions/tagged/rust\n [community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library"}, {"sha": "46480aeb4476d840c412833f39e34e9663c3c5da", "filename": "Cargo.lock", "status": "modified", "additions": 247, "deletions": 130, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -27,16 +27,16 @@ dependencies = [\n \n [[package]]\n name = \"ammonia\"\n-version = \"2.1.2\"\n+version = \"3.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"384d704f242a0a9faf793fff775a0be6ab9aa27edabffa097331d73779142520\"\n+checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n dependencies = [\n  \"html5ever\",\n  \"lazy_static 1.3.0\",\n  \"maplit\",\n  \"matches\",\n  \"tendril\",\n- \"url 1.7.2\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -107,11 +107,17 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b671c8fb71b457dd4ae18c4ba1e59aa81793daacc361d82fcd410cef0d491875\"\n+\n [[package]]\n name = \"backtrace\"\n-version = \"0.3.37\"\n+version = \"0.3.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n+checksum = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -123,9 +129,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.30\"\n+version = \"0.1.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b3a000b9c543553af61bc01cbfc403b04b5caa9e421033866f2e98061eb3e61\"\n+checksum = \"5d6575f128516de27e3ce99689419835fce9643a9b215a14d2b5b685be018491\"\n dependencies = [\n  \"cc\",\n  \"compiler_builtins\",\n@@ -144,9 +150,9 @@ dependencies = [\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.1.0\"\n+version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3d155346769a6855b86399e9bc3814ab343cd3d62c7e985113d46a0ec3c281fd\"\n+checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n [[package]]\n name = \"blake2-rfc\"\n@@ -265,7 +271,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.40.0\"\n+version = \"0.41.0\"\n dependencies = [\n  \"atty\",\n  \"bytesize\",\n@@ -279,7 +285,7 @@ dependencies = [\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.7.0\",\n+ \"env_logger 0.7.1\",\n  \"failure\",\n  \"filetime\",\n  \"flate2\",\n@@ -367,15 +373,27 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n+dependencies = [\n+ \"semver\",\n+ \"serde\",\n+ \"serde_derive\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"cargotest2\"\n version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.35\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5e5f3fee5eeb60324c2781f1e41286bdee933850fff9b3c672587fed5ec58c83\"\n+checksum = \"39f75544d7bbaf57560d2168f28fd649ff9c76153874db88bdbdfd839b1a7e7d\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -437,7 +455,7 @@ dependencies = [\n name = \"clippy\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata\",\n+ \"cargo_metadata 0.9.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n  \"compiletest_rs\",\n@@ -458,7 +476,7 @@ version = \"0.2.0\"\n name = \"clippy_lints\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata\",\n+ \"cargo_metadata 0.9.0\",\n  \"if_chain\",\n  \"itertools 0.8.0\",\n  \"lazy_static 1.3.0\",\n@@ -534,7 +552,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.7.0\",\n+ \"env_logger 0.7.1\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -550,9 +568,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.23\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eb783fe7afb90ec3d3e49ccaf9196d29ab63c6ed61d4b0695839daa580ae3a3d\"\n+checksum = \"f75b10a18fb53549fdd090846eb01c7f8593914494d1faabc4d3005c436e417a\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -566,7 +584,6 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -601,7 +618,7 @@ checksum = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.28.0\"\n+version = \"0.29.0\"\n dependencies = [\n  \"curl\",\n  \"failure\",\n@@ -660,6 +677,16 @@ dependencies = [\n  \"crossbeam-utils 0.6.5\",\n ]\n \n+[[package]]\n+name = \"crossbeam-deque\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b18cd2e169ad86297e6bc0ad9aa679aee9daa4f19e8163860faf7c164e4f5a71\"\n+dependencies = [\n+ \"crossbeam-epoch 0.7.2\",\n+ \"crossbeam-utils 0.6.5\",\n+]\n+\n [[package]]\n name = \"crossbeam-epoch\"\n version = \"0.3.1\"\n@@ -731,25 +758,24 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.21\"\n+version = \"0.4.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a85f2f95f2bd277d316d1aa8a477687ab4a6942258c7db7c89c187534669979c\"\n+checksum = \"d08ad3cb89d076a36b0ce5749eec2c9964f70c0c58480ab6b75a91ec4fc206d8\"\n dependencies = [\n  \"curl-sys\",\n- \"kernel32-sys\",\n  \"libc\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n  \"schannel\",\n  \"socket2\",\n- \"winapi 0.2.8\",\n+ \"winapi 0.3.6\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.18\"\n+version = \"0.4.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9d91a0052d5b982887d8e829bee0faffc7218ea3c6ebd3d6c2c8f678a93c9a42\"\n+checksum = \"2e9a9a4e417722876332136a00cacf92c2ceb331fab4b52b6a1ad16c6cd79255\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -948,9 +974,9 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.7.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39ecdb7dd54465526f0a56d666e3b2dd5f3a218665a030b6e4ad9e70fa95d8fa\"\n+checksum = \"44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -995,7 +1021,7 @@ dependencies = [\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n@@ -1261,7 +1287,7 @@ version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n dependencies = [\n- \"hashbrown\",\n+ \"hashbrown 0.5.0\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"pest\",\n@@ -1278,10 +1304,19 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3cd9867f119b19fecb08cd5c326ad4488d7a1da4bf75b4d95d71db742525aaab\"\n+dependencies = [\n+ \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n- \"serde\",\n ]\n \n [[package]]\n@@ -1293,6 +1328,17 @@ dependencies = [\n  \"unicode-segmentation\",\n ]\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f22b8f315b98f415780ddbe9163c7dbbc5a07225b6d102ace1d8aeef85775140\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"hex\"\n version = \"0.3.2\"\n@@ -1307,26 +1353,26 @@ checksum = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n \n [[package]]\n name = \"home\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c07c315e106bd6f83f026a20ddaeef2706782e490db1dcdd37caad38a0e895b3\"\n+checksum = \"a3753954f7bd71f0e671afb8b5a992d1724cf43b7f95a563cd4a0bde94659ca8\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n  \"winapi 0.3.6\",\n ]\n \n [[package]]\n name = \"html5ever\"\n-version = \"0.23.0\"\n+version = \"0.24.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ce65ac8028cf5a287a7dbf6c4e0a6cf2dcf022ed5b167a81bae66ebf599a8b7\"\n+checksum = \"025483b0a1e4577bb28578318c886ee5f817dda6eb62473269349044406644cb\"\n dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n@@ -1585,9 +1631,9 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"13.1.0\"\n+version = \"13.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd42951eb35079520ee29b7efbac654d85821b397ef88c8151600ef7e2d00217\"\n+checksum = \"91d767c183a7e58618a609499d359ce3820700b3ebb4823a18c343b4a2a41a0d\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1690,9 +1736,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.62\"\n+version = \"0.2.64\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34fcd2c08d2f832f376f4173a231990fa5aef4e99fb569867318a227ef4c06ba\"\n+checksum = \"74dfca3d9957906e8d1e6a0b641dc9a59848e793f1da2165889fd4f62d10d79c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1856,9 +1902,9 @@ checksum = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \n [[package]]\n name = \"markup5ever\"\n-version = \"0.8.1\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1af46a727284117e09780d05038b1ce6fc9c76cc6df183c3dae5a8955a25e21\"\n+checksum = \"65381d9d47506b8592b97c4efd936afcf673b09b059f2bef39c7211ee78b9d03\"\n dependencies = [\n  \"log\",\n  \"phf\",\n@@ -1879,9 +1925,9 @@ checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.3.1\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"949bb2acb2cff9fa5c375cf9c43e70b3dba0a974d9fe01c31285d7a84d2a0fa2\"\n+checksum = \"9a070268274c566082efb6b2ace7743e43ba91a70d5c6982981e96d3c05ac81c\"\n dependencies = [\n  \"ammonia\",\n  \"chrono\",\n@@ -1931,9 +1977,9 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d09de7dafa3aa334bc806447c7e4de69419723312f4b88b80b561dea66601ce8\"\n+checksum = \"cd21b0e6e1af976b269ce062038fe5e1b9ca2f817ab7a3af09ec4210aebf0d30\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\",\n@@ -2101,13 +2147,13 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder\",\n- \"cargo_metadata\",\n+ \"cargo_metadata 0.9.0\",\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.1\",\n  \"getrandom\",\n- \"hex 0.3.2\",\n+ \"hex 0.4.0\",\n  \"log\",\n  \"num-traits\",\n  \"rand 0.7.0\",\n@@ -2634,9 +2680,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.27\"\n+version = \"2.1.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dde22b84ab75220015cbd91240222402bf885cbe3a5dc856475771abb82533ae\"\n+checksum = \"acc70369054bad4ad0c16a3f45cd73e0695361a3af35c7b465e619ac2674f064\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2793,22 +2839,22 @@ dependencies = [\n \n [[package]]\n name = \"rayon\"\n-version = \"1.1.0\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4b0186e22767d5b9738a05eab7c6ac90b15db17e5b5f9bd87976dd7d89a10a4\"\n+checksum = \"83a27732a533a1be0a0035a111fe76db89ad312f6f0347004c220c57f209a123\"\n dependencies = [\n- \"crossbeam-deque 0.6.3\",\n+ \"crossbeam-deque 0.7.1\",\n  \"either\",\n  \"rayon-core\",\n ]\n \n [[package]]\n name = \"rayon-core\"\n-version = \"1.5.0\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ebbe0df8435ac0c397d467b6cad6d25543d06e8a019ef3f6af3c384597515bd2\"\n+checksum = \"98dcf634205083b17d0861252431eb2acbfb698ab7478a2d20de07954f47ec7b\"\n dependencies = [\n- \"crossbeam-deque 0.6.3\",\n+ \"crossbeam-deque 0.7.1\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n  \"lazy_static 1.3.0\",\n@@ -2928,14 +2974,14 @@ checksum = \"cabe4fa914dec5870285fa7f71f602645da47c486e68486d2b4ceb4a343e90ac\"\n \n [[package]]\n name = \"rls\"\n-version = \"1.39.0\"\n+version = \"1.40.0\"\n dependencies = [\n  \"cargo\",\n- \"cargo_metadata\",\n+ \"cargo_metadata 0.8.0\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.1\",\n  \"failure\",\n  \"futures\",\n  \"heck\",\n@@ -2949,7 +2995,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -2958,7 +3004,6 @@ dependencies = [\n  \"rls-rustc\",\n  \"rls-span\",\n  \"rls-vfs\",\n- \"rustc-serialize\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfmt-nightly\",\n@@ -3019,11 +3064,11 @@ name = \"rls-rustc\"\n version = \"0.6.0\"\n dependencies = [\n  \"clippy_lints\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.1\",\n  \"failure\",\n  \"futures\",\n  \"log\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3057,6 +3102,7 @@ dependencies = [\n  \"failure\",\n  \"mdbook\",\n  \"mdbook-linkcheck\",\n+ \"rustc-workspace-hack\",\n ]\n \n [[package]]\n@@ -3067,6 +3113,7 @@ dependencies = [\n  \"backtrace\",\n  \"bitflags\",\n  \"byteorder\",\n+ \"cc\",\n  \"chalk-engine\",\n  \"fmt_macros\",\n  \"graphviz\",\n@@ -3076,12 +3123,13 @@ dependencies = [\n  \"num_cpus\",\n  \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.3.0\",\n+ \"rustc-rayon-core 0.3.0\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n+ \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_target\",\n  \"scoped-tls\",\n@@ -3093,25 +3141,25 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f59b76d334bd533f3fdc5c651c27678c5e80fac67c6f7da22ba21a58878c55f5\"\n+checksum = \"a623fd4805842e9bd0bb6e6dace63efede0ee22de4522a0b03b7c3d15a22f009\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e632ef08ca17458acfd46d2ead3d541a1c249586cd5329f5fe333dacfab6142\"\n+checksum = \"ee549ade784b444ef10c0240c3487ed785aa65d711071f7984246b15329a17b6\"\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e89e2c7be68185418f3cd56af3df8b29007a59a1cebefa63612d055f9bcb1a36\"\n+checksum = \"ca545744a5a9b42e3d0410d6290d40de96dd567253fe77f310c1de4afd213dd4\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n@@ -3120,21 +3168,22 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot 0.7.1\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-ap-graphviz\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.2.0\",\n+ \"rustc-rayon-core 0.2.0\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1e47cb380abeb72b01e42b2342d592f7eeea7d536c2f1f0d0e550dc509e46333\"\n+checksum = \"a6967a41ed38ef4bce0f559fe9a4801d8ba12ac032f40a12a55e72f79d52c9bb\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3147,64 +3196,75 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_index\"\n+version = \"606.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"457a5c204ae2fdaa5bdb5b196e58ca59896870d80445fe423063c9453496e3ea\"\n+dependencies = [\n+ \"rustc-ap-serialize\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"494cfaf67f49217d67d0774eeecbba61ac89acf478db97ef11f113ed8a959305\"\n+checksum = \"ed0c064676f8a08e42a36b0d4e4a102465fb0f4b75e11436cb7f66d2c3fa7139\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e5d36becc59b4497f9cbd3ae0610081de0207a1d0e95c066369167b14f486f\"\n+checksum = \"b2d77e46159c5288c585decbcdc9d742889c65e307c31e104c7a36d63fe1f5d0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7bfc5f96dfc3b9f8d5b57884f7f37467ecff6776cd4b8b491a7daece6fdd7c2\"\n+checksum = \"86ca895350b0de14d064b499168c93fa183958d5462eb042c927d93623e41ec1\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2bb9ee231cf79eded39c56647499f83d6136ff5c8c0baaa9e21b6febee00f4f6\"\n+checksum = \"92679240e86f4583cc05f8dcf6439bdab87bac9e6555718469176de9bd52ba20\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3827fc208814efbde82d613e31d11b4250ce9e8cf8afe4a4d47bbbd099632c9\"\n+checksum = \"0a0c30f8e38c847dbfd9e2f1e472ab06d0bd0a23ab53ae4c5a44912842ce834e\"\n dependencies = [\n  \"bitflags\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_target\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n@@ -3214,13 +3274,14 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"583.0.0\"\n+version = \"606.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"930ed81c34f325e512cc315c04d676fa84a373879d5c43bb54054a0522b05213\"\n+checksum = \"2bdaa0fb40143b4b878256ac4e2b498885daafc269502504d91929eab4744bf4\"\n dependencies = [\n  \"cfg-if\",\n  \"rustc-ap-arena\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-serialize\",\n  \"scoped-tls\",\n@@ -3264,7 +3325,18 @@ checksum = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\"\n dependencies = [\n  \"crossbeam-deque 0.2.0\",\n  \"either\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon-core 0.2.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-rayon\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f32767f90d938f1b7199a174ef249ae1924f6e5bbdb9d112fea141e016f25b3a\"\n+dependencies = [\n+ \"crossbeam-deque 0.7.1\",\n+ \"either\",\n+ \"rustc-rayon-core 0.3.0\",\n ]\n \n [[package]]\n@@ -3280,10 +3352,17 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc-serialize\"\n-version = \"0.3.24\"\n+name = \"rustc-rayon-core\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n+checksum = \"ea2427831f0053ea3ea73559c8eabd893133a51b251d142bacee53c62a288cb3\"\n+dependencies = [\n+ \"crossbeam-deque 0.7.1\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils 0.6.5\",\n+ \"lazy_static 1.3.0\",\n+ \"num_cpus\",\n+]\n \n [[package]]\n name = \"rustc-std-workspace-alloc\"\n@@ -3314,6 +3393,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n+ \"syn 0.15.35\",\n  \"url 2.1.0\",\n  \"winapi 0.3.6\",\n ]\n@@ -3362,6 +3442,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n  \"rustc_incremental\",\n+ \"rustc_index\",\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n@@ -3398,8 +3479,9 @@ dependencies = [\n  \"log\",\n  \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n+ \"rustc-rayon 0.3.0\",\n+ \"rustc-rayon-core 0.3.0\",\n+ \"rustc_index\",\n  \"serialize\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n@@ -3409,7 +3491,7 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.7.0\",\n+ \"env_logger 0.7.1\",\n  \"graphviz\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -3418,6 +3500,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_interface\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n  \"rustc_plugin\",\n@@ -3463,14 +3546,22 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_index\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"serialize\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"once_cell\",\n  \"rustc\",\n- \"rustc-rayon\",\n+ \"rustc-rayon 0.3.0\",\n  \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n@@ -3483,11 +3574,13 @@ dependencies = [\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n  \"rustc_resolve\",\n+ \"rustc_target\",\n  \"rustc_traits\",\n  \"rustc_typeck\",\n  \"serialize\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_ext\",\n  \"syntax_pos\",\n  \"tempfile\",\n@@ -3507,6 +3600,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_index\",\n  \"rustc_target\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3536,10 +3630,10 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"synstructure 0.12.1\",\n ]\n \n [[package]]\n@@ -3552,11 +3646,13 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3574,6 +3670,7 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_target\",\n  \"serialize\",\n@@ -3601,6 +3698,8 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n+ \"rustc_target\",\n  \"syntax\",\n  \"syntax_pos\",\n ]\n@@ -3619,6 +3718,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_metadata\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3647,6 +3747,7 @@ dependencies = [\n  \"rustc_metadata\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -3673,6 +3774,7 @@ dependencies = [\n  \"bitflags\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_index\",\n  \"serialize\",\n  \"syntax_pos\",\n ]\n@@ -3721,6 +3823,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\",\n@@ -3742,7 +3845,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"minifier\",\n  \"pulldown-cmark 0.5.3\",\n- \"rustc-rayon\",\n+ \"rustc-rayon 0.3.0\",\n  \"tempfile\",\n ]\n \n@@ -3781,11 +3884,11 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.8\"\n+version = \"1.4.9\"\n dependencies = [\n  \"annotate-snippets\",\n  \"bytecount\",\n- \"cargo_metadata\",\n+ \"cargo_metadata 0.8.0\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n@@ -4059,7 +4162,8 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown\",\n+ \"hashbrown 0.6.2\",\n+ \"hermit-abi\",\n  \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n@@ -4228,6 +4332,18 @@ dependencies = [\n  \"unicode-xid 0.1.0\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"unicode-xid 0.2.0\",\n+]\n+\n [[package]]\n name = \"syntax\"\n version = \"0.0.0\"\n@@ -4237,11 +4353,31 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_index\",\n+ \"rustc_lexer\",\n+ \"rustc_target\",\n+ \"scoped-tls\",\n+ \"serialize\",\n+ \"smallvec\",\n+ \"syntax_pos\",\n+]\n+\n+[[package]]\n+name = \"syntax_expand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"lazy_static 1.3.0\",\n+ \"log\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec\",\n+ \"syntax\",\n  \"syntax_pos\",\n ]\n \n@@ -4256,6 +4392,7 @@ dependencies = [\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\",\n+ \"syntax_expand\",\n  \"syntax_pos\",\n ]\n \n@@ -4266,6 +4403,7 @@ dependencies = [\n  \"arena\",\n  \"cfg-if\",\n  \"rustc_data_structures\",\n+ \"rustc_index\",\n  \"rustc_macros\",\n  \"scoped-tls\",\n  \"serialize\",\n@@ -4323,16 +4461,6 @@ dependencies = [\n  \"std\",\n ]\n \n-[[package]]\n-name = \"term\"\n-version = \"0.4.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n-dependencies = [\n- \"kernel32-sys\",\n- \"winapi 0.2.8\",\n-]\n-\n [[package]]\n name = \"term\"\n version = \"0.6.0\"\n@@ -4389,17 +4517,6 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n-[[package]]\n-name = \"tester\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5e812cb26c597f86a49b26dbb58b878bd2a2b4b93fc069dc39499228fe556ff6\"\n-dependencies = [\n- \"getopts\",\n- \"libc\",\n- \"term 0.4.6\",\n-]\n-\n [[package]]\n name = \"textwrap\"\n version = \"0.11.0\""}, {"sha": "c5468a2924888e877a5d18e5a7ed5b4c05bceb3d", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -33,6 +33,7 @@ or reading the [rustc guide][rustcguidebuild].\n    * `curl`\n    * `git`\n    * `ssl` which comes in `libssl-dev` or `openssl-devel`\n+   * `pkg-config` if you are compiling on Linux and targeting Linux\n \n 2. Clone the [source] with `git`:\n \n@@ -243,19 +244,17 @@ The Rust community congregates in a few places:\n \n To contribute to Rust, please see [CONTRIBUTING](CONTRIBUTING.md).\n \n-Rust has an [IRC] culture and most real-time collaboration happens in a\n-variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n-most popular channel is [#rust], a venue for general discussion about\n-Rust. And a good place to ask for help would be [#rust-beginners].\n+Most real-time collaboration happens in a variety of channels on the\n+[Rust Discord server][rust-discord], with channels dedicated for getting help,\n+community, documentation, and all major contribution areas in the Rust ecosystem.\n+A good place to ask for help would be the #help channel.\n \n The [rustc guide] might be a good place to start if you want to find out how\n various parts of the compiler work.\n \n Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n-[IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n-[#rust]: irc://irc.mozilla.org/rust\n-[#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n+[rust-discord]: https://discord.gg/rust-lang\n [rustc guide]: https://rust-lang.github.io/rustc-guide/about-this-guide.html\n [rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n "}, {"sha": "e832570ed982e5f858924128358dab9bcf08140c", "filename": "config.toml.example", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -258,10 +258,9 @@\n [rust]\n \n # Whether or not to optimize the compiler and standard library.\n-#\n-# Note: the slowness of the non optimized compiler compiling itself usually\n-#       outweighs the time gains in not doing optimizations, therefore a\n-#       full bootstrap takes much more time with `optimize` set to false.\n+# WARNING: Building with optimize = false is NOT SUPPORTED. Due to bootstrapping,\n+# building without optimizations takes much longer than optimizing. Further, some platforms\n+# fail to build without this optimization (c.f. #65352).\n #optimize = true\n \n # Indicates that the build should be configured for debugging Rust. A\n@@ -341,6 +340,9 @@\n # nightly features\n #channel = \"dev\"\n \n+# The root location of the MUSL installation directory.\n+#musl-root = \"...\"\n+\n # By default the `rustc` executable is built with `-Wl,-rpath` flags on Unix\n # platforms to ensure that the compiler is usable by default from the build\n # directory (as it links to a number of dynamic libraries). This may not be\n@@ -374,9 +376,7 @@\n \n # This is an array of the codegen backends that will be compiled for the rustc\n # that's being compiled. The default is to only build the LLVM codegen backend,\n-# but you can also optionally enable the \"emscripten\" backend for asm.js or\n-# make this an empty array (but that probably won't get too far in the\n-# bootstrap)\n+# and currently the only standard option supported is `\"llvm\"`\n #codegen-backends = [\"llvm\"]\n \n # This is the name of the directory in which codegen backends will get installed"}, {"sha": "2f7cf90c5f0305b433880a533ed6fd26621255e7", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -5,7 +5,4 @@ This directory contains the source code of the rust project, including:\n \n For more information on how various parts of the compiler work, see the [rustc guide].\n \n-There is also useful content in this README:\n-https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve.\n-\n [rustc guide]: https://rust-lang.github.io/rustc-guide/about-this-guide.html"}, {"sha": "c501378bff5491b0bba6cb39a3738f7e7f5845f4", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -328,6 +328,8 @@ are:\n   `Config` struct.\n * Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n-If you have any questions feel free to reach out on `#rust-infra` on IRC or ask on\n-internals.rust-lang.org. When you encounter bugs, please file issues on the\n-rust-lang/rust issue tracker.\n+If you have any questions feel free to reach out on `#infra` channel in the\n+[Rust Discord server][rust-discord] or ask on internals.rust-lang.org. When\n+you encounter bugs, please file issues on the rust-lang/rust issue tracker.\n+\n+[rust-discord]: https://discord.gg/rust-lang"}, {"sha": "4caf36a6f2a51442df56e79af4028492c25647e8", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -734,10 +734,6 @@ def update_submodules(self):\n             if module.endswith(\"llvm-project\"):\n                 if self.get_toml('llvm-config') and self.get_toml('lld') != 'true':\n                     continue\n-            if module.endswith(\"llvm-emscripten\"):\n-                backends = self.get_toml('codegen-backends')\n-                if backends is None or not 'emscripten' in backends:\n-                    continue\n             check = self.check_submodule(module, slow_submodules)\n             filtered_submodules.append((module, check))\n             submodules_names.append(module)"}, {"sha": "2748903f2d4756b34b5623ae324f0319f6977345", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -443,6 +443,7 @@ impl<'a> Builder<'a> {\n                 dist::Rustc,\n                 dist::DebuggerScripts,\n                 dist::Std,\n+                dist::RustcDev,\n                 dist::Analysis,\n                 dist::Src,\n                 dist::PlainSourceTarball,\n@@ -817,12 +818,22 @@ impl<'a> Builder<'a> {\n \n         let mut rustflags = Rustflags::new(&target);\n         if stage != 0 {\n+            if let Ok(s) = env::var(\"CARGOFLAGS_NOT_BOOTSTRAP\") {\n+                cargo.args(s.split_whitespace());\n+            }\n             rustflags.env(\"RUSTFLAGS_NOT_BOOTSTRAP\");\n         } else {\n+            if let Ok(s) = env::var(\"CARGOFLAGS_BOOTSTRAP\") {\n+                cargo.args(s.split_whitespace());\n+            }\n             rustflags.env(\"RUSTFLAGS_BOOTSTRAP\");\n             rustflags.arg(\"--cfg=bootstrap\");\n         }\n \n+        if let Ok(s) = env::var(\"CARGOFLAGS\") {\n+            cargo.args(s.split_whitespace());\n+        }\n+\n         match mode {\n             Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n@@ -970,6 +981,7 @@ impl<'a> Builder<'a> {\n                 Some(\"-Wl,-rpath,@loader_path/../lib\")\n             } else if !target.contains(\"windows\") &&\n                       !target.contains(\"wasm32\") &&\n+                      !target.contains(\"emscripten\") &&\n                       !target.contains(\"fuchsia\") {\n                 Some(\"-Wl,-rpath,$ORIGIN/../lib\")\n             } else {"}, {"sha": "4310f2c6fa1405902c8ee04fdf068be18dda8226", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -161,7 +161,7 @@ impl Ord for Interned<String> {\n     }\n }\n \n-struct TyIntern<T: Hash + Clone + Eq> {\n+struct TyIntern<T: Clone + Eq> {\n     items: Vec<T>,\n     set: HashMap<T, Interned<T>>,\n }"}, {"sha": "df1c72575846b0a69e17944473805299af834649", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -55,6 +55,7 @@ impl Step for Std {\n                   cargo,\n                   args(builder.kind),\n                   &libstd_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -103,6 +104,7 @@ impl Step for Rustc {\n                   cargo,\n                   args(builder.kind),\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n@@ -155,6 +157,7 @@ impl Step for CodegenBackend {\n                   cargo,\n                   args(builder.kind),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n+                  vec![],\n                   true);\n     }\n }\n@@ -199,6 +202,7 @@ impl Step for Rustdoc {\n                   cargo,\n                   args(builder.kind),\n                   &rustdoc_stamp(builder, compiler, target),\n+                  vec![],\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);"}, {"sha": "da8d43ed49b7f34895523e3f7fc1d716ca35a08a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -69,7 +69,7 @@ impl Step for Std {\n             return;\n         }\n \n-        builder.ensure(StartupObjects { compiler, target });\n+        let mut target_deps = builder.ensure(StartupObjects { compiler, target });\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n@@ -91,7 +91,7 @@ impl Step for Std {\n             return;\n         }\n \n-        copy_third_party_objects(builder, &compiler, target);\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n@@ -102,6 +102,7 @@ impl Step for Std {\n                   cargo,\n                   vec![],\n                   &libstd_stamp(builder, compiler, target),\n+                  target_deps,\n                   false);\n \n         builder.ensure(StdLink {\n@@ -113,29 +114,36 @@ impl Step for Std {\n }\n \n /// Copies third pary objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>) {\n+fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>)\n+    -> Vec<PathBuf>\n+{\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n+    let mut target_deps = vec![];\n+\n+    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n+        let target = libdir.join(name);\n+        builder.copy(\n+            &sourcedir.join(name),\n+            &target,\n+        );\n+        target_deps.push(target);\n+    };\n+\n     // Copies the crt(1,i,n).o startup objects\n     //\n     // Since musl supports fully static linking, we can cross link for it even\n     // with a glibc-targeting toolchain, given we have the appropriate startup\n     // files. As those shipped with glibc won't work, copy the ones provided by\n     // musl so we have them on linux-gnu hosts.\n     if target.contains(\"musl\") {\n+        let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-            builder.copy(\n-                &builder.musl_root(target).unwrap().join(\"lib\").join(obj),\n-                &libdir.join(obj),\n-            );\n+            copy_and_stamp(&srcdir, obj);\n         }\n     } else if target.ends_with(\"-wasi\") {\n-        for &obj in &[\"crt1.o\"] {\n-            builder.copy(\n-                &builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\").join(obj),\n-                &libdir.join(obj),\n-            );\n-        }\n+        let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n+        copy_and_stamp(&srcdir, \"crt1.o\");\n     }\n \n     // Copies libunwind.a compiled to be linked wit x86_64-fortanix-unknown-sgx.\n@@ -145,11 +153,11 @@ fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target:\n     // which is provided by std for this target.\n     if target == \"x86_64-fortanix-unknown-sgx\" {\n         let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let obj = \"libunwind.a\";\n         let src = env::var(src_path_env).expect(&format!(\"{} not found in env\", src_path_env));\n-        let src = Path::new(&src).join(obj);\n-        builder.copy(&src, &libdir.join(obj));\n+        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n     }\n+\n+    target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n@@ -210,7 +218,6 @@ pub fn std_cargo(builder: &Builder<'_>,\n             // config.toml equivalent) is used\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n             cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n@@ -307,7 +314,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = ();\n+    type Output = Vec<PathBuf>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -326,13 +333,15 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) {\n+    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n-            return\n+            return vec![]\n         }\n \n+        let mut target_deps = vec![];\n+\n         let src_dir = &builder.src.join(\"src/rtstartup\");\n         let dst_dir = &builder.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n@@ -351,16 +360,22 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            builder.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            let target = sysroot_dir.join(file.to_string() + \".o\");\n+            builder.copy(dst_file, &target);\n+            target_deps.push(target);\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(builder,\n                                     builder.cc(target),\n                                     target,\n                                     obj);\n-            builder.copy(&src, &sysroot_dir.join(obj));\n+            let target = sysroot_dir.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push(target);\n         }\n+\n+        target_deps\n     }\n }\n \n@@ -438,6 +453,7 @@ impl Step for Rustc {\n                   cargo,\n                   vec![],\n                   &librustc_stamp(builder, compiler, target),\n+                  vec![],\n                   false);\n \n         builder.ensure(RustcLink {\n@@ -586,7 +602,7 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, false);\n+        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n         if builder.config.dry_run {\n             return;\n         }\n@@ -615,36 +631,27 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                              compiler: &Compiler,\n                              target: Interned<String>,\n                              backend: Interned<String>) -> String {\n-    let mut features = String::new();\n-\n     match &*backend {\n-        \"llvm\" | \"emscripten\" => {\n+        \"llvm\" => {\n             // Build LLVM for our target. This will implicitly build the\n             // host LLVM if necessary.\n             let llvm_config = builder.ensure(native::Llvm {\n                 target,\n-                emscripten: backend == \"emscripten\",\n             });\n \n-            if backend == \"emscripten\" {\n-                features.push_str(\" emscripten\");\n-            }\n-\n             builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n                      compiler.stage, &compiler.host, target, backend));\n \n             // Pass down configuration from the LLVM build into the build of\n             // librustc_llvm and librustc_codegen_llvm.\n-            if builder.is_rust_llvm(target) && backend != \"emscripten\" {\n+            if builder.is_rust_llvm(target) {\n                 cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n             }\n \n             cargo.env(\"LLVM_CONFIG\", &llvm_config);\n-            if backend != \"emscripten\" {\n-                let target_config = builder.config.target_config.get(&target);\n-                if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-                    cargo.env(\"CFG_LLVM_ROOT\", s);\n-                }\n+            let target_config = builder.config.target_config.get(&target);\n+            if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+                cargo.env(\"CFG_LLVM_ROOT\", s);\n             }\n             // Some LLVM linker flags (-L and -l) may be needed to link librustc_llvm.\n             if let Some(ref s) = builder.config.llvm_ldflags {\n@@ -662,9 +669,7 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                                          \"libstdc++.a\");\n                 cargo.env(\"LLVM_STATIC_STDCPP\", file);\n             }\n-            if builder.config.llvm_link_shared ||\n-                (builder.config.llvm_thin_lto && backend != \"emscripten\")\n-            {\n+            if builder.config.llvm_link_shared || builder.config.llvm_thin_lto {\n                 cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n             }\n             if builder.config.llvm_use_libcxx {\n@@ -676,8 +681,7 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n         }\n         _ => panic!(\"unknown backend: {}\", backend),\n     }\n-\n-    features\n+    String::new()\n }\n \n /// Creates the `codegen-backends` folder for a compiler that's about to be\n@@ -954,6 +958,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: Cargo,\n                  tail_args: Vec<String>,\n                  stamp: &Path,\n+                 additional_target_deps: Vec<PathBuf>,\n                  is_check: bool)\n     -> Vec<PathBuf>\n {\n@@ -1070,6 +1075,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n+    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n     deps.sort();\n     let mut new_contents = Vec::new();\n     for (dep, proc_macro) in deps.iter() {"}, {"sha": "d1bdfa0a7676309ccd0209ea4ac8bd8397f358de", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -200,23 +200,23 @@ struct Build {\n     target: Vec<String>,\n     cargo: Option<String>,\n     rustc: Option<String>,\n-    low_priority: Option<bool>,\n-    compiler_docs: Option<bool>,\n     docs: Option<bool>,\n+    compiler_docs: Option<bool>,\n     submodules: Option<bool>,\n     fast_submodules: Option<bool>,\n     gdb: Option<String>,\n-    locked_deps: Option<bool>,\n-    vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n+    locked_deps: Option<bool>,\n+    vendor: Option<bool>,\n     full_bootstrap: Option<bool>,\n     extended: Option<bool>,\n     tools: Option<HashSet<String>>,\n     verbose: Option<usize>,\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n     cargo_native_static: Option<bool>,\n+    low_priority: Option<bool>,\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n     print_step_timings: Option<bool>,\n@@ -228,11 +228,11 @@ struct Build {\n struct Install {\n     prefix: Option<String>,\n     sysconfdir: Option<String>,\n-    datadir: Option<String>,\n     docdir: Option<String>,\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n+    datadir: Option<String>,\n \n     // standard paths, currently unused\n     infodir: Option<String>,\n@@ -243,14 +243,14 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n-    ccache: Option<StringOrBool>,\n-    ninja: Option<bool>,\n-    assertions: Option<bool>,\n     optimize: Option<bool>,\n     thin_lto: Option<bool>,\n     release_debuginfo: Option<bool>,\n+    assertions: Option<bool>,\n+    ccache: Option<StringOrBool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n+    ninja: Option<bool>,\n     targets: Option<String>,\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n@@ -293,6 +293,7 @@ impl Default for StringOrBool {\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Rust {\n     optimize: Option<bool>,\n+    debug: Option<bool>,\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n@@ -301,25 +302,24 @@ struct Rust {\n     debuginfo_level_std: Option<u32>,\n     debuginfo_level_tools: Option<u32>,\n     debuginfo_level_tests: Option<u32>,\n-    parallel_compiler: Option<bool>,\n     backtrace: Option<bool>,\n+    incremental: Option<bool>,\n+    parallel_compiler: Option<bool>,\n     default_linker: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n+    verbose_tests: Option<bool>,\n     optimize_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n-    debug: Option<bool>,\n     dist_src: Option<bool>,\n-    verbose_tests: Option<bool>,\n-    incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n     lld: Option<bool>,\n-    lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n+    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -333,13 +333,13 @@ struct Rust {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct TomlTarget {\n-    llvm_config: Option<String>,\n-    llvm_filecheck: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n     ar: Option<String>,\n     ranlib: Option<String>,\n     linker: Option<String>,\n+    llvm_config: Option<String>,\n+    llvm_filecheck: Option<String>,\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n@@ -668,7 +668,6 @@ impl Config {\n \n     pub fn llvm_enabled(&self) -> bool {\n         self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n-        || self.rust_codegen_backends.contains(&INTERNER.intern_str(\"emscripten\"))\n     }\n }\n "}, {"sha": "bb6041d7f31960c7b53d3cc31bbba0e852008bc7", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -55,7 +55,6 @@ def v(*args):\n o(\"dist-src\", \"rust.dist-src\", \"when building tarballs enables building a source tarball\")\n o(\"cargo-native-static\", \"build.cargo-native-static\", \"static native libraries in cargo\")\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n-o(\"emscripten\", None, \"compile the emscripten backend as well as LLVM\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n o(\"lldb\", \"rust.lldb\", \"build lldb\")\n@@ -134,6 +133,10 @@ def v(*args):\n   \"mips-unknown-linux-musl install directory\")\n v(\"musl-root-mipsel\", \"target.mipsel-unknown-linux-musl.musl-root\",\n   \"mipsel-unknown-linux-musl install directory\")\n+v(\"musl-root-mips64\", \"target.mips64-unknown-linux-muslabi64.musl-root\",\n+  \"mips64-unknown-linux-muslabi64 install directory\")\n+v(\"musl-root-mips64el\", \"target.mips64el-unknown-linux-muslabi64.musl-root\",\n+  \"mips64el-unknown-linux-muslabi64 install directory\")\n v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n@@ -335,10 +338,8 @@ def set(key, value):\n         set('build.host', value.split(','))\n     elif option.name == 'target':\n         set('build.target', value.split(','))\n-    elif option.name == 'emscripten':\n-        set('rust.codegen-backends', ['llvm', 'emscripten'])\n     elif option.name == 'full-tools':\n-        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+        set('rust.codegen-backends', ['llvm'])\n         set('rust.lld', True)\n         set('rust.llvm-tools', True)\n         set('build.extended', True)"}, {"sha": "93143570b0fe173fa474d3a8f1a3e5e2c3ab6f55", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 96, "deletions": 37, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -637,6 +637,28 @@ impl Step for DebuggerScripts {\n     }\n }\n \n+fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n+    // The only true set of target libraries came from the build triple, so\n+    // let's reduce redundant work by only producing archives from that host.\n+    if compiler.host != builder.config.build {\n+        builder.info(\"\\tskipping, not a build host\");\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Copy stamped files into an image's `target/lib` directory.\n+fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n+    let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    t!(fs::create_dir_all(&dst));\n+    for (path, host) in builder.read_stamp_file(stamp) {\n+        if !host || builder.config.build == target {\n+            builder.copy(&path, &dst.join(path.file_name().unwrap()));\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n@@ -667,44 +689,19 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(builder, \"rust-std\");\n-\n-        // The only true set of target libraries came from the build triple, so\n-        // let's reduce redundant work by only producing archives from that host.\n-        if compiler.host != builder.config.build {\n-            builder.info(\"\\tskipping, not a build host\");\n-            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if skip_host_target_lib(builder, compiler) {\n+            return archive;\n         }\n \n-        // We want to package up as many target libraries as possible\n-        // for the `rust-std` package, so if this is a host target we\n-        // depend on librustc and otherwise we just depend on libtest.\n-        if builder.hosts.iter().any(|t| t == target) {\n-            builder.ensure(compile::Rustc { compiler, target });\n-        } else {\n-            builder.ensure(compile::Std { compiler, target });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n-        let dst = image.join(\"lib/rustlib\").join(target);\n-        t!(fs::create_dir_all(&dst));\n-        let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n-        src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        builder.cp_filtered(&src, &dst, &|path| {\n-            if let Some(name) = path.file_name().and_then(|s| s.to_str()) {\n-                if name == builder.config.rust_codegen_backends_dir.as_str() {\n-                    return false\n-                }\n-                if name == \"bin\" {\n-                    return false\n-                }\n-                if name.contains(\"LLVM\") {\n-                    return false\n-                }\n-            }\n-            true\n-        });\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n+        copy_target_libs(builder, &target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -723,7 +720,73 @@ impl Step for Std {\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n-        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n+        archive\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDev {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustcDev {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"rustc-dev\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustcDev {\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+\n+        let name = pkgname(builder, \"rustc-dev\");\n+        let archive = distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if skip_host_target_lib(builder, compiler) {\n+            return archive;\n+        }\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n+\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        let stamp = compile::librustc_stamp(builder, compiler_to_use, target);\n+        copy_target_libs(builder, &target, &image, &stamp);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-is-ready-to-develop.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--component-name=rustc-dev-{}\", target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\"Dist rustc-dev stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target));\n+        let _time = timeit(builder);\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        archive\n     }\n }\n \n@@ -826,17 +889,13 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n \n         const LLVM_TEST: &[&str] = &[\n             \"llvm-project/llvm/test\", \"llvm-project\\\\llvm\\\\test\",\n-            \"llvm-emscripten/test\", \"llvm-emscripten\\\\test\",\n         ];\n         if LLVM_TEST.iter().any(|path| spath.contains(path)) &&\n             (spath.ends_with(\".ll\") ||\n              spath.ends_with(\".td\") ||\n              spath.ends_with(\".s\")) {\n             return false\n         }\n-        if spath.contains(\"test/emscripten\") || spath.contains(\"test\\\\emscripten\") {\n-            return false\n-        }\n \n         let full_path = Path::new(dir).join(path);\n         if exclude_dirs.iter().any(|excl| full_path == Path::new(excl)) {"}, {"sha": "39d7ea922bceda50770772869345adc83364b440", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -160,7 +160,7 @@ mod job {\n     }\n }\n \n-#[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n+#[cfg(any(target_os = \"haiku\", target_os = \"hermit\", not(any(unix, windows))))]\n mod job {\n     pub unsafe fn setup(_build: &mut crate::Build) {\n     }\n@@ -232,7 +232,6 @@ pub struct Build {\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n     in_tree_llvm_info: channel::GitInfo,\n-    emscripten_llvm_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     doc_tests: DocTests,\n@@ -351,7 +350,6 @@ impl Build {\n \n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n-        let emscripten_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-emscripten\"));\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -376,7 +374,6 @@ impl Build {\n             miri_info,\n             rustfmt_info,\n             in_tree_llvm_info,\n-            emscripten_llvm_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             ar: HashMap::new(),\n@@ -553,10 +550,6 @@ impl Build {\n         self.out.join(&*target).join(\"llvm\")\n     }\n \n-    fn emscripten_llvm_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"llvm-emscripten\")\n-    }\n-\n     fn lld_out(&self, target: Interned<String>) -> PathBuf {\n         self.out.join(&*target).join(\"lld\")\n     }\n@@ -1087,6 +1080,10 @@ impl Build {\n     /// done. The file is updated immediately after this function completes.\n     pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n         if let Some(ref path) = self.config.save_toolstates {\n+            if let Some(parent) = path.parent() {\n+                // Ensure the parent directory always exists\n+                t!(std::fs::create_dir_all(parent));\n+            }\n             let mut file = t!(fs::OpenOptions::new()\n                 .create(true)\n                 .read(true)\n@@ -1126,7 +1123,7 @@ impl Build {\n         }\n \n         let mut paths = Vec::new();\n-        let contents = t!(fs::read(stamp));\n+        let contents = t!(fs::read(stamp), &stamp);\n         // This is the method we use for extracting paths from the stamp file passed to us. See\n         // run_cargo for more information (in compile.rs).\n         for part in contents.split(|b| *b == 0) {\n@@ -1144,6 +1141,7 @@ impl Build {\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n         self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n+        if src == dst { return; }\n         let _ = fs::remove_file(&dst);\n         let metadata = t!(src.symlink_metadata());\n         if metadata.file_type().is_symlink() {"}, {"sha": "e76604e45bdeb3c60570e88e633a7d5039490a1f", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 30, "deletions": 59, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -28,7 +28,6 @@ use crate::GitRepo;\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n-    pub emscripten: bool,\n }\n \n impl Step for Llvm {\n@@ -40,46 +39,35 @@ impl Step for Llvm {\n         run.path(\"src/llvm-project\")\n             .path(\"src/llvm-project/llvm\")\n             .path(\"src/llvm\")\n-            .path(\"src/llvm-emscripten\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n-            emscripten,\n         });\n     }\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n-        let emscripten = self.emscripten;\n \n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n-        if !self.emscripten {\n-            if let Some(config) = builder.config.target_config.get(&target) {\n-                if let Some(ref s) = config.llvm_config {\n-                    check_llvm_version(builder, s);\n-                    return s.to_path_buf()\n-                }\n+        if let Some(config) = builder.config.target_config.get(&target) {\n+            if let Some(ref s) = config.llvm_config {\n+                check_llvm_version(builder, s);\n+                return s.to_path_buf()\n             }\n         }\n \n-        let (llvm_info, root, out_dir, llvm_config_ret_dir) = if emscripten {\n-            let info = &builder.emscripten_llvm_info;\n-            let dir = builder.emscripten_llvm_out(target);\n-            let config_dir = dir.join(\"bin\");\n-            (info, \"src/llvm-emscripten\", dir, config_dir)\n-        } else {\n-            let info = &builder.in_tree_llvm_info;\n-            let mut dir = builder.llvm_out(builder.config.build);\n-            if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n-                dir.push(\"build\");\n-            }\n-            (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n-        };\n+        let llvm_info = &builder.in_tree_llvm_info;\n+        let root = \"src/llvm-project/llvm\";\n+        let out_dir = builder.llvm_out(target);\n+        let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n+        if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+            llvm_config_ret_dir.push(\"build\");\n+        }\n+        llvm_config_ret_dir.push(\"bin\");\n \n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n@@ -107,8 +95,7 @@ impl Step for Llvm {\n             }\n         }\n \n-        let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        builder.info(&format!(\"Building LLVM for {}\", target));\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -123,23 +110,15 @@ impl Step for Llvm {\n \n         // NOTE: remember to also update `config.toml.example` when changing the\n         // defaults!\n-        let llvm_targets = if self.emscripten {\n-            \"JSBackend\"\n-        } else {\n-            match builder.config.llvm_targets {\n-                Some(ref s) => s,\n-                None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n-                         Sparc;SystemZ;WebAssembly;X86\",\n-            }\n+        let llvm_targets = match &builder.config.llvm_targets {\n+            Some(s) => s,\n+            None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                     Sparc;SystemZ;WebAssembly;X86\",\n         };\n \n-        let llvm_exp_targets = if self.emscripten {\n-            \"\"\n-        } else {\n-            match builder.config.llvm_experimental_targets {\n-                Some(ref s) => s,\n-                None => \"\",\n-            }\n+        let llvm_exp_targets = match builder.config.llvm_experimental_targets {\n+            Some(ref s) => s,\n+            None => \"\",\n         };\n \n         let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -157,39 +136,29 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+           .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")\n            .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n            .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n-        if builder.config.llvm_thin_lto && !emscripten {\n+        if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n                cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n             }\n         }\n \n-        // By default, LLVM will automatically find OCaml and, if it finds it,\n-        // install the LLVM bindings in LLVM_OCAML_INSTALL_PATH, which defaults\n-        // to /usr/bin/ocaml.\n-        // This causes problem for non-root builds of Rust. Side-step the issue\n-        // by setting LLVM_OCAML_INSTALL_PATH to a relative path, so it installs\n-        // in the prefix.\n-        cfg.define(\"LLVM_OCAML_INSTALL_PATH\",\n-            env::var_os(\"LLVM_OCAML_INSTALL_PATH\").unwrap_or_else(|| \"usr/lib/ocaml\".into()));\n-\n-        let want_lldb = builder.config.lldb_enabled && !self.emscripten;\n-\n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space\n         // for the tools. We don't do this on every platform as it doesn't work\n         // equally well everywhere.\n-        if builder.llvm_link_tools_dynamically(target) && !emscripten {\n+        if builder.llvm_link_tools_dynamically(target) {\n             cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || want_lldb {\n+        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n             if !target.contains(\"windows\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -217,7 +186,7 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if want_lldb {\n+        if builder.config.lldb_enabled {\n             enabled_llvm_projects.push(\"clang\");\n             enabled_llvm_projects.push(\"lldb\");\n             // For the time being, disable code signing.\n@@ -242,10 +211,9 @@ impl Step for Llvm {\n         }\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-        if target != builder.config.build && !emscripten {\n+        if target != builder.config.build {\n             builder.ensure(Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n@@ -489,7 +457,6 @@ impl Step for Lld {\n \n         let llvm_config = builder.ensure(Llvm {\n             target: self.target,\n-            emscripten: false,\n         });\n \n         let out_dir = builder.lld_out(target);\n@@ -567,6 +534,10 @@ impl Step for TestHelpers {\n         builder.info(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n+        // FIXME: Workaround for https://github.com/emscripten-core/emscripten/issues/9013\n+        if target.contains(\"emscripten\") {\n+            cfg.pic(false);\n+        }\n \n         // We may have found various cross-compilers a little differently due to our\n         // extra configuration, so inform gcc of these compilers. Note, though, that"}, {"sha": "60f0dccdb070ecc37b08ca66a689650e05a3fb32", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -386,8 +386,17 @@ impl Step for Miri {\n             extra_features: Vec::new(),\n         });\n         if let Some(miri) = miri {\n+            let mut cargo = builder.cargo(compiler, Mode::ToolRustc, host, \"install\");\n+            cargo.arg(\"xargo\");\n+            // Configure `cargo install` path. cargo adds a `bin/`.\n+            cargo.env(\"CARGO_INSTALL_ROOT\", &builder.out);\n+\n+            let mut cargo = Command::from(cargo);\n+            if !try_run(builder, &mut cargo) {\n+                return;\n+            }\n+\n             // # Run `cargo miri setup`.\n-            // As a side-effect, this will install xargo.\n             let mut cargo = tool::prepare_tool_cargo(\n                 builder,\n                 compiler,\n@@ -412,9 +421,7 @@ impl Step for Miri {\n             cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n             // Debug things.\n             cargo.env(\"RUST_BACKTRACE\", \"1\");\n-            // Configure `cargo install` path, and let cargo-miri know that that's where\n-            // xargo ends up.\n-            cargo.env(\"CARGO_INSTALL_ROOT\", &builder.out); // cargo adds a `bin/`\n+            // Let cargo-miri know where xargo ended up.\n             cargo.env(\"XARGO\", builder.out.join(\"bin\").join(\"xargo\"));\n \n             let mut cargo = Command::from(cargo);\n@@ -427,7 +434,7 @@ impl Step for Miri {\n             // (We do this separately from the above so that when the setup actually\n             // happens we get some output.)\n             // We re-use the `cargo` from above.\n-            cargo.arg(\"--env\");\n+            cargo.arg(\"--print-sysroot\");\n \n             // FIXME: Is there a way in which we can re-use the usual `run` helpers?\n             let miri_sysroot = if builder.config.dry_run {\n@@ -437,13 +444,11 @@ impl Step for Miri {\n                 let out = cargo.output()\n                     .expect(\"We already ran `cargo miri setup` before and that worked\");\n                 assert!(out.status.success(), \"`cargo miri setup` returned with non-0 exit code\");\n-                // Output is \"MIRI_SYSROOT=<str>\\n\".\n+                // Output is \"<sysroot>\\n\".\n                 let stdout = String::from_utf8(out.stdout)\n                     .expect(\"`cargo miri setup` stdout is not valid UTF-8\");\n-                let stdout = stdout.trim();\n-                builder.verbose(&format!(\"`cargo miri setup --env` returned: {:?}\", stdout));\n-                let sysroot = stdout.splitn(2, '=')\n-                    .nth(1).expect(\"`cargo miri setup` stdout did not contain '='\");\n+                let sysroot = stdout.trim_end();\n+                builder.verbose(&format!(\"`cargo miri setup --print-sysroot` said: {:?}\", sysroot));\n                 sysroot.to_owned()\n             };\n \n@@ -1047,10 +1052,11 @@ impl Step for Compiletest {\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n-        // wasm32 can't build the test helpers\n-        if !target.contains(\"wasm32\") {\n+        // As well as the target, except for plain wasm32, which can't build it\n+        if !target.contains(\"wasm32\") || target.contains(\"emscripten\") {\n             builder.ensure(native::TestHelpers { target });\n         }\n+\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n@@ -1164,7 +1170,7 @@ impl Step for Compiletest {\n                     }).to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled && !target.contains(\"emscripten\") {\n+        let lldb_exe = if builder.config.lldb_enabled {\n             // Test against the lldb that was just built.\n             builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n         } else {\n@@ -1233,7 +1239,6 @@ impl Step for Compiletest {\n         if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n-                emscripten: false,\n             });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));"}, {"sha": "815498047fd5d160ac9afef8dfcc2060558c7743", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -244,6 +244,7 @@ pub fn prepare_tool_cargo(\n             path.ends_with(\"rls\") ||\n             path.ends_with(\"clippy\") ||\n             path.ends_with(\"miri\") ||\n+            path.ends_with(\"rustbook\") ||\n             path.ends_with(\"rustfmt\")\n         {\n             cargo.env(\"LIBZ_SYS_STATIC\", \"1\");"}, {"sha": "bb94fb2b755f53342b76fd3dbd28e0e223510196", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -21,6 +21,13 @@ macro_rules! t {\n             Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n         }\n     };\n+    // it can show extra info in the second parameter\n+    ($e:expr, $extra:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{} failed with {} ({:?})\", stringify!($e), e, $extra),\n+        }\n+    };\n }\n \n // Because Cargo adds the compiler's dylib path to our library search path, llvm-config may"}, {"sha": "271c32585449ec295495a2882fb480de246af258", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -124,14 +124,14 @@ jobs:\n         IMAGE: dist-x86_64-netbsd\n         DEPLOY: 1\n \n-      asmjs:\n-        IMAGE: asmjs\n       i686-gnu:\n         IMAGE: i686-gnu\n       i686-gnu-nopt:\n         IMAGE: i686-gnu-nopt\n       test-various:\n         IMAGE: test-various\n+      wasm32:\n+        IMAGE: wasm32\n       x86_64-gnu:\n         IMAGE: x86_64-gnu\n       x86_64-gnu-full-bootstrap:\n@@ -140,6 +140,7 @@ jobs:\n         IMAGE: x86_64-gnu-aux\n       x86_64-gnu-tools:\n         IMAGE: x86_64-gnu-tools\n+        DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n       x86_64-gnu-debug:\n         IMAGE: x86_64-gnu-debug\n       x86_64-gnu-nopt:\n@@ -262,8 +263,9 @@ jobs:\n       # MSVC tools tests\n       x86_64-msvc-tools:\n         MSYS_BITS: 64\n-        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n-        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json\n+        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n+        DEPLOY_TOOLSTATES_JSON: toolstates-windows.json\n \n       # 32/64-bit MinGW builds.\n       #\n@@ -315,6 +317,7 @@ jobs:\n \n       # 32/64 bit MSVC and GNU deployment\n       dist-x86_64-msvc:\n+        MSYS_BITS: 64\n         RUST_CONFIGURE_ARGS: >\n           --build=x86_64-pc-windows-msvc\n           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n@@ -324,6 +327,7 @@ jobs:\n         DIST_REQUIRE_ALL_TOOLS: 1\n         DEPLOY: 1\n       dist-i686-msvc:\n+        MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: >\n           --build=i686-pc-windows-msvc\n           --target=i586-pc-windows-msvc"}, {"sha": "566e654fdb3f0f8ffb62fa70415f57af8070f367", "filename": "src/ci/azure-pipelines/pr.yml", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -22,14 +22,6 @@ jobs:\n         IMAGE: x86_64-gnu-llvm-6.0\n       mingw-check:\n         IMAGE: mingw-check\n-\n-- job: LinuxTools\n-  timeoutInMinutes: 600\n-  pool:\n-    vmImage: ubuntu-16.04\n-  steps:\n-    - template: steps/run.yml\n-      parameters:\n-        only_on_updated_submodules: 'yes'\n-  variables:\n-    IMAGE: x86_64-gnu-tools\n+      x86_64-gnu-tools:\n+        IMAGE: x86_64-gnu-tools\n+        CI_ONLY_WHEN_SUBMODULES_CHANGED: 1"}, {"sha": "14daf81b430755cda020c104ec9da8a8cc138f2c", "filename": "src/ci/azure-pipelines/steps/install-clang.yml", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,46 +0,0 @@\n-steps:\n-\n-- bash: |\n-    set -e\n-    curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf -\n-\n-    export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang\n-    echo \"##vso[task.setvariable variable=CC]$CC\"\n-\n-    export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++\n-    echo \"##vso[task.setvariable variable=CXX]$CXX\"\n-\n-    # Configure `AR` specifically so rustbuild doesn't try to infer it as\n-    # `clang-ar` by accident.\n-    echo \"##vso[task.setvariable variable=AR]ar\"\n-  displayName: Install clang (OSX)\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n-\n-# If we're compiling for MSVC then we, like most other distribution builders,\n-# switch to clang as the compiler. This'll allow us eventually to enable LTO\n-# amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n-# clang has an output mode compatible with MinGW that we need. If it does we\n-# should switch to clang for MinGW as well!\n-#\n-# Note that the LLVM installer is an NSIS installer\n-#\n-# Original downloaded here came from\n-# http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n-# That installer was run through `wine` on Linux and then the resulting\n-# installation directory (found in `$HOME/.wine/drive_c/Program Files/LLVM`) was\n-# packaged up into a tarball. We've had issues otherwise that the installer will\n-# randomly hang, provide not a lot of useful information, pollute global state,\n-# etc. In general the tarball is just more confined and easier to deal with when\n-# working with various CI environments.\n-- bash: |\n-    set -e\n-    mkdir -p citools\n-    cd citools\n-    curl -f https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/LLVM-7.0.0-win64.tar.gz | tar xzf -\n-    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --set llvm.clang-cl=`pwd`/clang-rust/bin/clang-cl.exe\"\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n-  displayName: Install clang (Windows)\n-\n-# Note that we don't install clang on Linux since its compiler story is just so\n-# different. Each container has its own toolchain configured appropriately\n-# already."}, {"sha": "d4679c1c6733e50807df5f8c61dec675a15e031c", "filename": "src/ci/azure-pipelines/steps/install-sccache.yml", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,21 +0,0 @@\n-steps:\n-\n-- bash: |\n-    set -e\n-    curl -fo /usr/local/bin/sccache https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-apple-darwin\n-    chmod +x /usr/local/bin/sccache\n-  displayName: Install sccache (OSX)\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n-\n-- script: |\n-    md sccache\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n-    echo ##vso[task.prependpath]%CD%\\sccache\n-  displayName: Install sccache (Windows)\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-# Note that we don't install sccache on Linux since it's installed elsewhere\n-# through all the containers.\n-#\n-# FIXME: we should probably install sccache outside the containers and then\n-# mount it inside the containers so we can centralize all installation here."}, {"sha": "bd4f1ed0cea439c4da31fd97114f16ef8511c865", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,120 +0,0 @@\n-steps:\n-# We use the WIX toolset to create combined installers for Windows, and these\n-# binaries are downloaded from\n-# https://github.com/wixtoolset/wix3 originally\n-- bash: |\n-    set -e\n-    curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/wix311-binaries.zip\n-    echo \"##vso[task.setvariable variable=WIX]`pwd`/wix\"\n-    mkdir -p wix/bin\n-    cd wix/bin\n-    7z x ../../wix311-binaries.zip\n-  displayName: Install wix\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-# We use InnoSetup and its `iscc` program to also create combined installers.\n-# Honestly at this point WIX above and `iscc` are just holdovers from\n-# oh-so-long-ago and are required for creating installers on Windows. I think\n-# one is MSI installers and one is EXE, but they're not used so frequently at\n-# this point anyway so perhaps it's a wash!\n-- script: |\n-    echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n-    curl.exe -o is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\n-    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n-  displayName: Install InnoSetup\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-# We've had issues with the default drive in use running out of space during a\n-# build, and it looks like the `C:` drive has more space than the default `D:`\n-# drive. We should probably confirm this with the azure pipelines team at some\n-# point, but this seems to fix our \"disk space full\" problems.\n-- script: |\n-    mkdir c:\\MORE_SPACE\n-    mklink /J build c:\\MORE_SPACE\n-  displayName: \"Ensure build happens on C:/ instead of D:/\"\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-- bash: git config --replace-all --global core.autocrlf false\n-  displayName: \"Disable git automatic line ending conversion (on C:/)\"\n-\n-# Download and install MSYS2, needed primarily for the test suite (run-make) but\n-# also used by the MinGW toolchain for assembling things.\n-#\n-# FIXME: we should probe the default azure image and see if we can use the MSYS2\n-# toolchain there. (if there's even one there). For now though this gets the job\n-# done.\n-- bash: |\n-    set -e\n-    choco install msys2 --params=\"/InstallDir:$(System.Workfolder)/msys2 /NoPath\" -y --no-progress\n-    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/usr/bin\"\n-    mkdir -p \"$(System.Workfolder)/msys2/home/$USERNAME\"\n-  displayName: Install msys2\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-- bash: pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n-  displayName: Install msys2 base deps\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-# If we need to download a custom MinGW, do so here and set the path\n-# appropriately.\n-#\n-# Here we also do a pretty heinous thing which is to mangle the MinGW\n-# installation we just downloaded. Currently, as of this writing, we're using\n-# MinGW-w64 builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it\n-# appears to be the first version which contains a fix for #40546, builds\n-# randomly failing during LLVM due to ar.exe/ranlib.exe failures.\n-#\n-# Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n-# to contain a regression in gdb (#40184). As a result if we were to use the\n-# gdb provided (7.11.1) then we would fail all debuginfo tests.\n-#\n-# In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n-# avoid disabling gdb tests we download an *old* version of gdb, specifically\n-# that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n-# with the 6.2.0 gdb to get tests passing.\n-#\n-# Note that we don't literally overwrite the gdb.exe binary because it appears\n-# to just use gdborig.exe, so that's the binary we deal with instead.\n-- bash: |\n-    set -e\n-    curl -o mingw.7z $MINGW_URL/$MINGW_ARCHIVE\n-    7z x -y mingw.7z > /dev/null\n-    curl -o $MINGW_DIR/bin/gdborig.exe $MINGW_URL/2017-04-20-${MSYS_BITS}bit-gdborig.exe\n-    echo \"##vso[task.prependpath]`pwd`/$MINGW_DIR/bin\"\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n-  displayName: Download custom MinGW\n-\n-# Otherwise install MinGW through `pacman`\n-- bash: |\n-    set -e\n-    arch=i686\n-    if [ \"$MSYS_BITS\" = \"64\" ]; then\n-      arch=x86_64\n-    fi\n-    pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake mingw-w64-$arch-gcc mingw-w64-$arch-python2\n-    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/mingw$MSYS_BITS/bin\"\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n-  displayName: Download standard MinGW\n-\n-# Make sure we use the native python interpreter instead of some msys equivalent\n-# one way or another. The msys interpreters seem to have weird path conversions\n-# baked in which break LLVM's build system one way or another, so let's use the\n-# native version which keeps everything as native as possible.\n-- bash: |\n-    set -e\n-    cp C:/Python27amd64/python.exe C:/Python27amd64/python2.7.exe\n-    echo \"##vso[task.prependpath]C:/Python27amd64\"\n-  displayName: Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-\n-# Note that this is originally from the github releases patch of Ninja\n-- bash: |\n-    set -e\n-    mkdir ninja\n-    curl -o ninja.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\n-    7z x -oninja ninja.zip\n-    rm ninja.zip\n-    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --enable-ninja\"\n-    echo \"##vso[task.prependpath]`pwd`/ninja\"\n-  displayName: Download and install ninja\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "cef2d235602f19c32325bedea47b3cf23eb8aab0", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 103, "deletions": 117, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -6,11 +6,6 @@\n #\n # Check travis config for `gdb --batch` command to print all crash logs\n \n-parameters:\n-  # When this parameter is set to anything other than an empty string the tests\n-  # will only be executed when the commit updates submodules\n-  only_on_updated_submodules: ''\n-\n steps:\n \n # Disable automatic line ending conversion, which is enabled by default on\n@@ -26,108 +21,115 @@ steps:\n - checkout: self\n   fetchDepth: 2\n \n-# Set the SKIP_JOB environment variable if this job is supposed to only run\n-# when submodules are updated and they were not. The following time consuming\n-# tasks will be skipped when the environment variable is present.\n-- ${{ if parameters.only_on_updated_submodules }}:\n-  - bash: |\n-      set -e\n-      # Submodules pseudo-files inside git have the 160000 permissions, so when\n-      # those files are present in the diff a submodule was updated.\n-      if git diff HEAD^ | grep \"^index .* 160000\" >/dev/null 2>&1; then\n-          echo \"Executing the job since submodules are updated\"\n-      else\n-          echo \"Not executing this job since no submodules were updated\"\n-          echo \"##vso[task.setvariable variable=SKIP_JOB;]1\"\n-      fi\n-    displayName: Decide whether to run this job\n+- bash: src/ci/scripts/should-skip-this.sh\n+  displayName: Decide whether to run this job\n \n # Spawn a background process to collect CPU usage statistics which we'll upload\n # at the end of the build. See the comments in the script here for more\n # information.\n - bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n   displayName: \"Collect CPU-usage statistics in the background\"\n \n-- bash: printenv | sort\n-  displayName: Show environment variables\n+- bash: src/ci/scripts/dump-environment.sh\n+  displayName: Show the current environment\n \n-- bash: |\n-    set -e\n-    df -h\n-    du . | sort -nr | head -n100\n-  displayName: Show disk usage\n-  # FIXME: this hasn't been tested, but maybe it works on Windows? Should test!\n-  condition: and(succeeded(), ne(variables['Agent.OS'], 'Windows_NT'))\n-\n-- template: install-sccache.yml\n-- template: install-clang.yml\n-\n-# Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n-# i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n-# force us to drop i686-apple-darwin, but let's keep the wheels turning for now.\n-- bash: |\n-    set -e\n-    sudo xcode-select --switch /Applications/Xcode_9.3.app\n-  displayName: Switch to Xcode 9.3 (OSX)\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+- bash: src/ci/scripts/install-sccache.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Install sccache\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- template: install-windows-build-deps.yml\n+- bash: src/ci/scripts/install-clang.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Install clang\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-# Looks like docker containers have IPv6 disabled by default, so let's turn it\n-# on since libstd tests require it\n-- bash: |\n-    set -e\n-    sudo mkdir -p /etc/docker\n-    echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json\n-    sudo service docker restart\n-  displayName: Enable IPv6\n-  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Linux'))\n+- bash: src/ci/scripts/switch-xcode.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Switch to Xcode 9.3\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-wix.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Install wix\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-innosetup.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Install InnoSetup\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/windows-symlink-build-dir.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Ensure the build happens on C:\\ instead of D:\\\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/disable-git-crlf-conversion.sh\n+  displayName: \"Disable git automatic line ending conversion (on C:/)\"\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-msys2.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+    SYSTEM_WORKFOLDER: $(System.Workfolder)\n+  displayName: Install msys2\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-msys2-packages.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+    SYSTEM_WORKFOLDER: $(System.Workfolder)\n+  displayName: Install msys2 packages\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-mingw.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+    SYSTEM_WORKFOLDER: $(System.Workfolder)\n+  displayName: Install MinGW\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/install-ninja.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Install ninja\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/enable-docker-ipv6.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Enable IPv6 on Docker\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n \n # Disable automatic line ending conversion (again). On Windows, when we're\n # installing dependencies, something switches the git configuration directory or\n # re-enables autocrlf. We've not tracked down the exact cause -- and there may\n # be multiple -- but this should ensure submodules are checked out with the\n # appropriate line endings.\n-- bash: git config --replace-all --global core.autocrlf false\n-  displayName: \"Disable git automatic line ending conversion\"\n+- bash: src/ci/scripts/disable-git-crlf-conversion.sh\n+  displayName: Disable git automatic line ending conversion\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-# Check out all our submodules, but more quickly than using git by using one of\n-# our custom scripts\n-- bash: |\n-    set -e\n-    mkdir -p $HOME/rustsrc\n-    $BUILD_SOURCESDIRECTORY/src/ci/init_repo.sh . $HOME/rustsrc\n-  condition: and(succeeded(), not(variables.SKIP_JOB), ne(variables['Agent.OS'], 'Windows_NT'))\n-  displayName: Check out submodules (Unix)\n-- script: |\n-    if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n-    sh src/ci/init_repo.sh . /c/cache/rustsrc\n-  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Windows_NT'))\n-  displayName: Check out submodules (Windows)\n-\n-# See also the disable for autocrlf above, this just checks that it worked\n-#\n-# We check both in rust-lang/rust and in a submodule to make sure both are\n-# accurate. Submodules are checked out significantly later than the main\n-# repository in this script, so settings can (and do!) change between then.\n-#\n-# Linux (and maybe macOS) builders don't currently have dos2unix so just only\n-# run this step on Windows.\n-- bash: |\n-    set -x\n-    # print out the git configuration so we can better investigate failures in\n-    # the following\n-    git config --list --show-origin\n-    dos2unix -ih Cargo.lock src/tools/rust-installer/install-template.sh\n-    endings=$(dos2unix -ic Cargo.lock src/tools/rust-installer/install-template.sh)\n-    # if endings has non-zero length, error out\n-    if [ -n \"$endings\" ]; then exit 1 ; fi\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n-  displayName: Verify line endings are LF\n+- bash: src/ci/scripts/checkout-submodules.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Checkout submodules\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+\n+- bash: src/ci/scripts/verify-line-endings.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  displayName: Verify line endings\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n \n # Ensure the `aws` CLI is installed so we can deploy later on, cache docker\n # images, etc.\n-- bash: src/ci/install-awscli.sh\n+- bash: src/ci/scripts/install-awscli.sh\n   env:\n     AGENT_OS: $(Agent.OS)\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n@@ -181,37 +183,21 @@ steps:\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n   displayName: Run build\n \n-# If we're a deploy builder, use the `aws` command to publish everything to our\n-# bucket.\n-- bash: |\n-    set -e\n-    source src/ci/shared.sh\n-    if [ \"$AGENT_OS\" = \"Linux\" ]; then\n-        rm -rf obj/build/dist/doc\n-        upload_dir=obj/build/dist\n-    else\n-        rm -rf build/dist/doc\n-        upload_dir=build/dist\n-    fi\n-    ls -la $upload_dir\n-    deploy_dir=rustc-builds\n-    if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n-        deploy_dir=rustc-builds-alt\n-    fi\n-    retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n+- bash: src/ci/scripts/upload-artifacts.sh\n   env:\n     AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n     AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n-  condition: and(succeeded(), not(variables.SKIP_JOB), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n   displayName: Upload artifacts\n-\n-# Upload CPU usage statistics that we've been gathering this whole time. Always\n-# execute this step in case we want to inspect failed builds, but don't let\n-# errors here ever fail the build since this is just informational.\n-- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n-  env:\n-    AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n-    AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n-  condition: variables['UPLOAD_AWS_SECRET_ACCESS_KEY']\n-  continueOnError: true\n-  displayName: Upload CPU usage statistics\n+  # Adding a condition on DEPLOY=1 or DEPLOY_ALT=1 is not needed as all deploy\n+  # builders *should* have the AWS credentials available. Still, explicitly\n+  # adding the condition is helpful as this way CI will not silently skip\n+  # deploying artifacts from a dist builder if the variables are misconfigured,\n+  # erroring about invalid credentials instead.\n+  condition: |\n+    and(\n+      succeeded(), not(variables.SKIP_JOB),\n+      or(\n+        variables.UPLOAD_AWS_SECRET_ACCESS_KEY,\n+        eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')\n+      )\n+    )"}, {"sha": "a2d83eca24b0a6eb3634f17771d51072612e67be", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -165,18 +165,17 @@ For targets: `arm-unknown-linux-gnueabihf`\n For targets: `armv7-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Suffix to the arch-part = v7\n - Target options > Architecture level = armv7-a -- (+)\n - Target options > Use specific FPU = vfpv3-d16 -- (\\*)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = thumb -- (\\*)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n (\\*) These options have been selected to match the configuration of the arm"}, {"sha": "3abaab6b34ef0dece78106d7955dc7f24c084a5d", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,47 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-COPY scripts/emscripten.sh /scripts/\n-RUN bash /scripts/emscripten.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/emsdk-portable\n-ENV PATH=$PATH:/emsdk-portable/clang/e1.38.15_64bit/\n-ENV PATH=$PATH:/emsdk-portable/emscripten/1.38.15/\n-ENV PATH=$PATH:/emsdk-portable/node/8.9.1_64bit/bin/\n-ENV EMSCRIPTEN=/emsdk-portable/emscripten/1.38.15/\n-ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.38.15_64bit/binaryen/\n-ENV EM_CONFIG=/emsdk-portable/.emscripten\n-\n-ENV TARGETS=asmjs-unknown-emscripten\n-\n-ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n-\n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n-  src/test/ui \\\n-  src/test/run-fail \\\n-  src/libstd \\\n-  src/liballoc \\\n-  src/libcore\n-\n-# Debug assertions in rustc are largely covered by other builders, and LLVM\n-# assertions cause this builder to slow down by quite a large amount and don't\n-# buy us a huge amount over other builders (not sure if we've ever seen an\n-# asmjs-specific backend assertion trip), so disable assertions for these\n-# tests.\n-ENV NO_LLVM_ASSERTIONS=1\n-ENV NO_DEBUG_ASSERTIONS=1"}, {"sha": "e27a2a529a8ca8995fe35bda4f560dcacc25ddfc", "filename": "src/ci/docker/disabled/asmjs/Dockerfile", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,41 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  bzip2\n+\n+COPY scripts/emscripten.sh /scripts/\n+RUN bash /scripts/emscripten.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/emsdk-portable\n+ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n+ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n+ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n+\n+ENV TARGETS=asmjs-unknown-emscripten\n+\n+# Use -O1 optimizations in the link step to reduce time spent optimizing JS.\n+ENV EMCC_CFLAGS=-O1\n+\n+# Emscripten installation is user-specific\n+ENV NO_CHANGE_USER=1\n+\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+\n+# This is almost identical to the wasm32-unknown-emscripten target, so\n+# running with assertions again is not useful\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "420d47b314c0f63da8e006eb78688c6051eec6c5", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,35 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils \\\n-  jq \\\n-  bzip2\n-\n-# emscripten\n-COPY scripts/emscripten-wasm.sh /scripts/\n-COPY wasm32-exp/node.sh /usr/local/bin/node\n-RUN bash /scripts/emscripten-wasm.sh\n-\n-# cache\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# env\n-ENV PATH=/wasm-install/emscripten:/wasm-install/bin:$PATH\n-ENV EM_CONFIG=/root/.emscripten\n-\n-ENV TARGETS=wasm32-experimental-emscripten\n-\n-ENV RUST_CONFIGURE_ARGS --experimental-targets=WebAssembly\n-\n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "aa938971c702f713e857c159d8bd8b67003ff982", "filename": "src/ci/docker/disabled/wasm32-exp/node.sh", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2Fnode.sh?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,9 +0,0 @@\n-#!/usr/bin/env bash\n-\n-path=\"$(dirname $1)\"\n-file=\"$(basename $1)\"\n-\n-shift\n-\n-cd \"$path\"\n-exec /node-v8.0.0-linux-x64/bin/node \"$file\" \"$@\""}, {"sha": "0d2bd39303ef8e1191b6986be45d546842b2b734", "filename": "src/ci/docker/disabled/wasm32/Dockerfile", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,32 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-# emscripten\n-COPY scripts/emscripten.sh /scripts/\n-RUN bash /scripts/emscripten.sh\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV PATH=$PATH:/emsdk-portable\n-ENV PATH=$PATH:/emsdk-portable/clang/e1.38.15_64bit/\n-ENV PATH=$PATH:/emsdk-portable/emscripten/1.38.15/\n-ENV PATH=$PATH:/emsdk-portable/node/8.9.1_64bit/bin/\n-ENV EMSCRIPTEN=/emsdk-portable/emscripten/1.38.15/\n-ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.38.15_64bit/binaryen/\n-ENV EM_CONFIG=/emsdk-portable/.emscripten\n-\n-ENV TARGETS=wasm32-unknown-emscripten\n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "417171a861d4a01be92f41a29a6f7ceaa6499777", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n+COPY dist-armv7-linux/crosstool-ng.sh /scripts/\n RUN sh /scripts/crosstool-ng.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-armv7-linux/patches/ /tmp/patches/\n COPY dist-armv7-linux/build-toolchains.sh dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "81b3d7477ec8d1537a5a9d787ca2bc6dc947a949", "filename": "src/ci/docker/dist-armv7-linux/armv7-linux-gnueabihf.config", "status": "modified", "additions": 493, "deletions": 306, "changes": 799, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,9 +1,32 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_python_3_4_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_dtc=y\n+CT_CONFIGURE_has_svn=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -21,40 +44,46 @@ CT_MODULES=y\n # Paths\n #\n CT_LOCAL_TARBALLS_DIR=\"\"\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -90,86 +119,81 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv7-a\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"vfpv3-d16\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-CT_ARCH_FLOAT_HW=y\n-# CT_ARCH_FLOAT_SW is not set\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"thumb\"\n+# CT_ARCH_ARM_MODE_ARM is not set\n+CT_ARCH_ARM_MODE_THUMB=y\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"v7\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv7-a\"\n+CT_ARCH_FPU=\"vfpv3-d16\"\n # CT_ARCH_FLOAT_AUTO is not set\n+CT_ARCH_FLOAT_HW=y\n # CT_ARCH_FLOAT_SOFTFP is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"hard\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"thumb\"\n-# CT_ARCH_ARM_MODE_ARM is not set\n-CT_ARCH_ARM_MODE_THUMB=y\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n-\n #\n # Toolchain options\n #\n@@ -182,7 +206,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -216,227 +242,279 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_29 is not set\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -465,97 +543,206 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+# CT_MPC_V_1_1 is not set\n+CT_MPC_V_1_0=y\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.0.3\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_older=y\n+CT_MPC_older_than_1_1_0=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_3_1=y\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"3.1.6\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_4_0_0_or_older=y\n+CT_MPFR_older_than_4_0_0=y\n+CT_MPFR_REQUIRE_older_than_4_0_0=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "ae737d9677d8716a60c4b667735f0a6a485f1ef9", "filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fcrosstool-ng.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,12 @@\n+set -ex\n+\n+# Mirrored from https://github.com/crosstool-ng/crosstool-ng/archive/crosstool-ng-1.24.0.tar.gz\n+url=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/crosstool-ng-1.24.0.tar.gz\"\n+curl -Lf $url | tar xzf -\n+cd crosstool-ng-crosstool-ng-1.24.0\n+./bootstrap\n+./configure --prefix=/usr/local\n+make -j$(nproc)\n+make install\n+cd ..\n+rm -rf crosstool-ng-crosstool-ng-1.24.0"}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armv7-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "816bdb34a7bfe216e91b438e9b4f13bf313ab1d7", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -15,6 +15,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++-arm-linux-gnueabi \\\n   g++-arm-linux-gnueabihf \\\n   g++-aarch64-linux-gnu \\\n+  g++-mips64-linux-gnuabi64 \\\n+  g++-mips64el-linux-gnuabi64 \\\n   gcc-sparc64-linux-gnu \\\n   libc6-dev-sparc64-cross \\\n   bzip2 \\\n@@ -77,6 +79,14 @@ RUN env \\\n     CC=mipsel-openwrt-linux-gcc \\\n     CXX=mipsel-openwrt-linux-g++ \\\n     bash musl.sh mipsel && \\\n+    env \\\n+    CC=mips64-linux-gnuabi64-gcc \\\n+    CXX=mips64-linux-gnuabi64-g++ \\\n+    bash musl.sh mips64 && \\\n+    env \\\n+    CC=mips64el-linux-gnuabi64-gcc \\\n+    CXX=mips64el-linux-gnuabi64-g++ \\\n+    bash musl.sh mips64el && \\\n     rm -rf /build/*\n \n # FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n@@ -97,6 +107,8 @@ ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n ENV TARGETS=$TARGETS,mips-unknown-linux-musl\n ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n+ENV TARGETS=$TARGETS,mips64-unknown-linux-muslabi64\n+ENV TARGETS=$TARGETS,mips64el-unknown-linux-muslabi64\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n@@ -125,6 +137,8 @@ ENV TARGETS=$TARGETS,thumbv7neon-unknown-linux-gnueabihf\n \n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n+    CC_mips64el_unknown_linux_muslabi64=mips64el-linux-gnuabi64-gcc \\\n+    CC_mips64_unknown_linux_muslabi64=mips64-linux-gnuabi64-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n@@ -139,7 +153,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\\n-      --enable-emscripten \\\n+      --musl-root-mips64=/musl-mips64 \\\n+      --musl-root-mips64el=/musl-mips64el \\\n       --disable-docs\n \n ENV SCRIPT \\"}, {"sha": "8200bbe2fdce5d84576795f2ecde89322ca5849e", "filename": "src/ci/docker/dist-x86_64-linux/build-curl.sh", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-curl.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -3,9 +3,11 @@\n set -ex\n source shared.sh\n \n-VERSION=7.51.0\n+VERSION=7.66.0\n \n-curl http://cool.haxx.se/download/curl-$VERSION.tar.bz2 | tar xjf -\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/curl-$VERSION.tar.xz \\\n+  | xz --decompress \\\n+  | tar xf -\n \n mkdir curl-build\n cd curl-build"}, {"sha": "cdafcbadc9ec768bc9c044cfc2369c7ac51f3a82", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -106,6 +106,7 @@ fi\n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n mkdir -p $objdir/cores\n+mkdir -p /tmp/toolstate\n \n args=\n if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n@@ -156,6 +157,7 @@ else\n   args=\"$args --volume $objdir:/checkout/obj\"\n   args=\"$args --volume $HOME/.cargo:/cargo\"\n   args=\"$args --volume $HOME/rustsrc:$HOME/rustsrc\"\n+  args=\"$args --volume /tmp/toolstate:/tmp/toolstate\"\n   args=\"$args --env LOCAL_USER_ID=`id -u`\"\n fi\n "}, {"sha": "bb72e33def21c107c7b4deb432629b72f2c4b424", "filename": "src/ci/docker/scripts/cross-apt-packages.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -22,5 +22,6 @@ apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   sudo \\\n   texinfo \\\n+  unzip \\\n   wget \\\n   xz-utils"}, {"sha": "e4a93d7a100920a6941c97bb1e62e095b8b74a83", "filename": "src/ci/docker/scripts/emscripten-wasm.sh", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fscripts%2Femscripten-wasm.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fci%2Fdocker%2Fscripts%2Femscripten-wasm.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten-wasm.sh?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,37 +0,0 @@\n-set -ex\n-\n-hide_output() {\n-  set +x\n-  on_err=\"\n-echo ERROR: An error was encountered with the build.\n-cat /tmp/build.log\n-exit 1\n-\"\n-  trap \"$on_err\" ERR\n-  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n-  PING_LOOP_PID=$!\n-  $@ &> /tmp/build.log\n-  trap - ERR\n-  kill $PING_LOOP_PID\n-  rm -f /tmp/build.log\n-  set -x\n-}\n-\n-# Download last known good emscripten from WebAssembly waterfall\n-BUILD=$(curl -fL https://storage.googleapis.com/wasm-llvm/builds/linux/lkgr.json | \\\n-    jq '.build | tonumber')\n-curl -sL https://storage.googleapis.com/wasm-llvm/builds/linux/$BUILD/wasm-binaries.tbz2 | \\\n-    hide_output tar xvkj\n-\n-# node 8 is required to run wasm\n-cd /\n-curl -sL https://nodejs.org/dist/v8.0.0/node-v8.0.0-linux-x64.tar.xz | \\\n-    tar -xJ\n-\n-# Make emscripten use wasm-ready node and LLVM tools\n-echo \"EMSCRIPTEN_ROOT = '/wasm-install/emscripten'\" >> /root/.emscripten\n-echo \"NODE_JS='/usr/local/bin/node'\" >> /root/.emscripten\n-echo \"LLVM_ROOT='/wasm-install/bin'\" >> /root/.emscripten\n-echo \"BINARYEN_ROOT = '/wasm-install'\" >> /root/.emscripten\n-echo \"COMPILER_ENGINE = NODE_JS\" >> /root/.emscripten\n-echo \"JS_ENGINES = [NODE_JS]\" >> /root/.emscripten"}, {"sha": "1be80741594cc930619dcef37fd5768513e4c21f", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -17,22 +17,7 @@ exit 1\n   set -x\n }\n \n-cd /\n-curl -fL https://mozilla-games.s3.amazonaws.com/emscripten/releases/emsdk-portable.tar.gz | \\\n-    tar -xz\n-\n+git clone https://github.com/emscripten-core/emsdk.git /emsdk-portable\n cd /emsdk-portable\n-./emsdk update\n-hide_output ./emsdk install sdk-1.38.15-64bit\n-./emsdk activate sdk-1.38.15-64bit\n-\n-# Compile and cache libc\n-source ./emsdk_env.sh\n-echo \"main(){}\" > a.c\n-HOME=/emsdk-portable/ emcc a.c\n-HOME=/emsdk-portable/ emcc -s BINARYEN=1 a.c\n-rm -f a.*\n-\n-# Make emsdk usable by any user\n-cp /root/.emscripten /emsdk-portable\n-chmod a+rxw -R /emsdk-portable\n+hide_output ./emsdk install 1.38.46-upstream\n+./emsdk activate 1.38.46-upstream"}, {"sha": "a0f35afd995b3f1bb69e1f00664616e395fb13b8", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,44 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  bzip2\n+\n+COPY scripts/emscripten.sh /scripts/\n+RUN bash /scripts/emscripten.sh\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV PATH=$PATH:/emsdk-portable\n+ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n+ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n+ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n+\n+ENV TARGETS=wasm32-unknown-emscripten\n+\n+# Use -O1 optimizations in the link step to reduce time spent optimizing.\n+ENV EMCC_CFLAGS=-O1\n+\n+# Emscripten installation is user-specific\n+ENV NO_CHANGE_USER=1\n+\n+# FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n+# is picked up by CI\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+    --exclude src/libcore \\\n+    --exclude src/liballoc \\\n+    --exclude src/libproc_macro \\\n+    --exclude src/libstd \\\n+    --exclude src/libterm \\\n+    --exclude src/libtest"}, {"sha": "7687a6ca23e180fb386ac2446fd169d239c21a45", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -26,5 +26,5 @@ ENV CHECK_LINKS 1\n \n ENV RUST_CONFIGURE_ARGS \\\n   --build=x86_64-unknown-linux-gnu \\\n-  --save-toolstates=/tmp/toolstates.json\n-ENV SCRIPT /tmp/checktools.sh ../x.py /tmp/toolstates.json linux\n+  --save-toolstates=/tmp/toolstate/toolstates.json\n+ENV SCRIPT /tmp/checktools.sh ../x.py /tmp/toolstate/toolstates.json linux"}, {"sha": "ebb8c0bda53ee2ae3654a1d9e28388b2eeafcb07", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -3,7 +3,7 @@\n set -eu\n \n X_PY=\"$1\"\n-TOOLSTATE_FILE=\"$(realpath $2)\"\n+TOOLSTATE_FILE=\"$(realpath -m $2)\"\n OS=\"$3\"\n COMMIT=\"$(git rev-parse HEAD)\"\n CHANGED_FILES=\"$(git diff --name-status HEAD HEAD^)\"\n@@ -13,6 +13,7 @@ SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 86400 - 20) % 42 ))\"\n #   The Wednesday after this has value 0.\n #   We track this value to prevent regressing tools in the last week of the 6-week cycle.\n \n+mkdir -p \"$(dirname $TOOLSTATE_FILE)\"\n touch \"$TOOLSTATE_FILE\"\n \n # Try to test all the tools and store the build/test success in the TOOLSTATE_FILE"}, {"sha": "92c6e546a389571c1ab59492104a8bd7afc787d7", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -47,7 +47,7 @@ function fetch_github_commit_archive {\n     rm $cached\n }\n \n-included=\"src/llvm-project src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n+included=\"src/llvm-project src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n modules=($modules)\n use_git=\"\""}, {"sha": "bce35670c8d46b8fdcba6030086b18db192ad099", "filename": "src/ci/run.sh", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -55,6 +55,9 @@ if [ \"$DEPLOY$DEPLOY_ALT\" = \"1\" ]; then\n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n   elif [ \"$DEPLOY_ALT\" != \"\" ]; then\n+    if [ \"$NO_PARALLEL_COMPILER\" = \"\" ]; then\n+      RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.parallel-compiler\"\n+    fi\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-assertions\"\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.verify-llvm-ir\"\n   fi\n@@ -114,7 +117,7 @@ make check-bootstrap\n \n # Display the CPU and memory information. This helps us know why the CI timing\n # is fluctuating.\n-if isOSX; then\n+if isMacOS; then\n     system_profiler SPHardwareDataType || true\n     sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)"}, {"sha": "0b44ea3c90bc91ea780f94082d1cafffdb6b3074", "filename": "src/ci/scripts/checkout-submodules.sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fcheckout-submodules.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fcheckout-submodules.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fcheckout-submodules.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,17 @@\n+#!/bin/bash\n+# Check out all our submodules, but more quickly than using git by using one of\n+# our custom scripts\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    path=\"/c/cache/rustsrc\"\n+else\n+    path=\"${HOME}/rustsrc\"\n+fi\n+\n+mkdir -p \"${path}\"\n+\"$(cd \"$(dirname \"$0\")\" && pwd)/../init_repo.sh\" . \"${path}\""}, {"sha": "836145fbb8e602e5c8868929d451a8fb2a35d37f", "filename": "src/ci/scripts/disable-git-crlf-conversion.sh", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fdisable-git-crlf-conversion.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fdisable-git-crlf-conversion.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fdisable-git-crlf-conversion.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,13 @@\n+#!/bin/bash\n+# Disable automatic line ending conversion, which is enabled by default on\n+# Azure's Windows image. Having the conversion enabled caused regressions both\n+# in our test suite (it broke miri tests) and in the ecosystem, since we\n+# started shipping install scripts with CRLF endings instead of the old LF.\n+#\n+# Note that we do this a couple times during the build as the PATH and current\n+# user/directory change, e.g. when mingw is enabled.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+git config --replace-all --global core.autocrlf false"}, {"sha": "c6774b52ab92dc8d2af0159d1bf2b24b7896e825", "filename": "src/ci/scripts/dump-environment.sh", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fdump-environment.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fdump-environment.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fdump-environment.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,19 @@\n+#!/bin/bash\n+# This script dumps information about the build environment to stdout.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+echo \"environment variables:\"\n+printenv | sort\n+echo\n+\n+echo \"disk usage:\"\n+df -h\n+echo\n+\n+echo \"biggest files in the working dir:\"\n+set +o pipefail\n+du . | sort -nr | head -n100\n+set -o pipefail\n+echo"}, {"sha": "03d5a75e24e27fa4c53231bebb6f926eaf7f8ac9", "filename": "src/ci/scripts/enable-docker-ipv6.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fenable-docker-ipv6.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fenable-docker-ipv6.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fenable-docker-ipv6.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,15 @@\n+#!/bin/bash\n+# Looks like docker containers have IPv6 disabled by default, so let's turn it\n+# on since libstd tests require it\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isLinux; then\n+    sudo mkdir -p /etc/docker\n+    echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' \\\n+        | sudo tee /etc/docker/daemon.json\n+    sudo service docker restart\n+fi"}, {"sha": "e21187938504caa08b6ee8c04c3a1f386d519549", "filename": "src/ci/scripts/install-awscli.sh", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-awscli.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -16,12 +16,14 @@\n set -euo pipefail\n IFS=$'\\n\\t'\n \n-MIRROR=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-07-27-awscli.tar\"\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+MIRROR=\"${MIRRORS_BASE}/2019-07-27-awscli.tar\"\n DEPS_DIR=\"/tmp/awscli-deps\"\n \n pip=\"pip\"\n pipflags=\"\"\n-if [[ \"${AGENT_OS}\" == \"Linux\" ]]; then\n+if isLinux; then\n     pip=\"pip3\"\n     pipflags=\"--user\"\n ", "previous_filename": "src/ci/install-awscli.sh"}, {"sha": "e9b685718e61f6acba9de10f7545ad10f4f64269", "filename": "src/ci/scripts/install-clang.sh", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,43 @@\n+#!/bin/bash\n+# This script installs clang on the local machine. Note that we don't install\n+# clang on Linux since its compiler story is just so different. Each container\n+# has its own toolchain configured appropriately already.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isMacOS; then\n+    curl -f \"${MIRRORS_BASE}/clang%2Bllvm-7.0.0-x86_64-apple-darwin.tar.xz\" | tar xJf -\n+\n+    ciCommandSetEnv CC \"$(pwd)/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang\"\n+    ciCommandSetEnv CXX \"$(pwd)/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++\"\n+\n+    # Configure `AR` specifically so rustbuild doesn't try to infer it as\n+    # `clang-ar` by accident.\n+    ciCommandSetEnv AR \"ar\"\n+elif isWindows && [[ -z ${MINGW_URL+x} ]]; then\n+    # If we're compiling for MSVC then we, like most other distribution builders,\n+    # switch to clang as the compiler. This'll allow us eventually to enable LTO\n+    # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n+    # clang has an output mode compatible with MinGW that we need. If it does we\n+    # should switch to clang for MinGW as well!\n+    #\n+    # Note that the LLVM installer is an NSIS installer\n+    #\n+    # Original downloaded here came from\n+    # http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n+    # That installer was run through `wine` on Linux and then the resulting\n+    # installation directory (found in `$HOME/.wine/drive_c/Program Files/LLVM`) was\n+    # packaged up into a tarball. We've had issues otherwise that the installer will\n+    # randomly hang, provide not a lot of useful information, pollute global state,\n+    # etc. In general the tarball is just more confined and easier to deal with when\n+    # working with various CI environments.\n+\n+    mkdir -p citools\n+    cd citools\n+    curl -f \"${MIRRORS_BASE}/LLVM-7.0.0-win64.tar.gz\" | tar xzf -\n+    ciCommandSetEnv RUST_CONFIGURE_ARGS \\\n+        \"${RUST_CONFIGURE_ARGS} --set llvm.clang-cl=$(pwd)/clang-rust/bin/clang-cl.exe\"\n+fi"}, {"sha": "04ca249777a11a55228c5dbb6a94c59254afab20", "filename": "src/ci/scripts/install-innosetup.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-innosetup.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+# We use InnoSetup and its `iscc` program to also create combined installers.\n+# Honestly at this point WIX above and `iscc` are just holdovers from\n+# oh-so-long-ago and are required for creating installers on Windows. I think\n+# one is MSI installers and one is EXE, but they're not used so frequently at\n+# this point anyway so perhaps it's a wash!\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    curl.exe -o is-install.exe \"${MIRRORS_BASE}/2017-08-22-is.exe\"\n+    cmd.exe //c \"is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\"\n+\n+    ciCommandAddPath \"C:\\\\Program Files (x86)\\\\Inno Setup 5\"\n+fi"}, {"sha": "b4e8b889f520a9e26fc17ccb3cb249fb0a303a7e", "filename": "src/ci/scripts/install-mingw.sh", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-mingw.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-mingw.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-mingw.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,45 @@\n+#!/bin/bash\n+# If we need to download a custom MinGW, do so here and set the path\n+# appropriately.\n+#\n+# Here we also do a pretty heinous thing which is to mangle the MinGW\n+# installation we just downloaded. Currently, as of this writing, we're using\n+# MinGW-w64 builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it\n+# appears to be the first version which contains a fix for #40546, builds\n+# randomly failing during LLVM due to ar.exe/ranlib.exe failures.\n+#\n+# Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n+# to contain a regression in gdb (#40184). As a result if we were to use the\n+# gdb provided (7.11.1) then we would fail all debuginfo tests.\n+#\n+# In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n+# avoid disabling gdb tests we download an *old* version of gdb, specifically\n+# that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n+# with the 6.2.0 gdb to get tests passing.\n+#\n+# Note that we don't literally overwrite the gdb.exe binary because it appears\n+# to just use gdborig.exe, so that's the binary we deal with instead.\n+#\n+# Otherwise install MinGW through `pacman`\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    if [[ -z \"${MINGW_URL+x}\" ]]; then\n+        arch=i686\n+        if [ \"$MSYS_BITS\" = \"64\" ]; then\n+          arch=x86_64\n+        fi\n+        pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake \\\n+            mingw-w64-$arch-gcc mingw-w64-$arch-python2\n+        ciCommandAddPath \"${SYSTEM_WORKFOLDER}/msys2/mingw${MSYS_BITS}/bin\"\n+    else\n+        curl -o mingw.7z \"${MINGW_URL}/${MINGW_ARCHIVE}\"\n+        7z x -y mingw.7z > /dev/null\n+        curl -o \"${MINGW_DIR}/bin/gdborig.exe\" \"${MINGW_URL}/2017-04-20-${MSYS_BITS}bit-gdborig.exe\"\n+        ciCommandAddPath \"$(pwd)/${MINGW_DIR}/bin\"\n+    fi\n+fi"}, {"sha": "36d9202f7a2d30e61fb7f8c8afd6d6538d9fc8cb", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,17 @@\n+#!/bin/bash\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n+\n+    # Make sure we use the native python interpreter instead of some msys equivalent\n+    # one way or another. The msys interpreters seem to have weird path conversions\n+    # baked in which break LLVM's build system one way or another, so let's use the\n+    # native version which keeps everything as native as possible.\n+    cp C:/Python27amd64/python.exe C:/Python27amd64/python2.7.exe\n+    ciCommandAddPath \"C:\\\\Python27amd64\"\n+fi"}, {"sha": "ce37c3b146977dafa2fcb3e08a79cdebf89a3f5f", "filename": "src/ci/scripts/install-msys2.sh", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,19 @@\n+#!/bin/bash\n+# Download and install MSYS2, needed primarily for the test suite (run-make) but\n+# also used by the MinGW toolchain for assembling things.\n+#\n+# FIXME: we should probe the default azure image and see if we can use the MSYS2\n+# toolchain there. (if there's even one there). For now though this gets the job\n+# done.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    choco install msys2 --params=\"/InstallDir:${SYSTEM_WORKFOLDER}/msys2 /NoPath\" -y --no-progress\n+    mkdir -p \"${SYSTEM_WORKFOLDER}/msys2/home/${USERNAME}\"\n+\n+    ciCommandAddPath \"${SYSTEM_WORKFOLDER}/msys2/usr/bin\"\n+fi"}, {"sha": "b8261d8a6f284fe97d486d1170b5d81b2a6b3d59", "filename": "src/ci/scripts/install-ninja.sh", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-ninja.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-ninja.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-ninja.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,16 @@\n+#!/bin/bash\n+# Note that this is originally from the github releases patch of Ninja\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    mkdir ninja\n+    curl -o ninja.zip \"${MIRRORS_BASE}/2017-03-15-ninja-win.zip\"\n+    7z x -oninja ninja.zip\n+    rm ninja.zip\n+    ciCommandSetEnv \"RUST_CONFIGURE_ARGS\" \"${RUST_CONFIGURE_ARGS} --enable-ninja\"\n+    ciCommandAddPath \"$(pwd)/ninja\"\n+fi"}, {"sha": "d3c298992254ef3424da236fbbaafceef4fb8e20", "filename": "src/ci/scripts/install-sccache.sh", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-sccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-sccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-sccache.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,20 @@\n+#!/bin/bash\n+# This script installs sccache on the local machine. Note that we don't install\n+# sccache on Linux since it's installed elsewhere through all the containers.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isMacOS; then\n+    curl -fo /usr/local/bin/sccache \"${MIRRORS_BASE}/2018-04-02-sccache-x86_64-apple-darwin\"\n+    chmod +x /usr/local/bin/sccache\n+elif isWindows; then\n+    mkdir -p sccache\n+    curl -fo sccache/sccache.exe \"${MIRRORS_BASE}/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    ciCommandAddPath \"$(pwd)/sccache\"\n+fi\n+\n+# FIXME: we should probably install sccache outside the containers and then\n+# mount it inside the containers so we can centralize all installation here."}, {"sha": "688f1a49cbfdc69fea8c5e86604b2ab0f7a20441", "filename": "src/ci/scripts/install-wix.sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-wix.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Finstall-wix.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-wix.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,17 @@\n+#!/bin/bash\n+# We use the WIX toolset to create combined installers for Windows, and these\n+# binaries are downloaded from https://github.com/wixtoolset/wix3 originally\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    ciCommandSetEnv WIX \"$(pwd)/wix\"\n+\n+    curl -O \"${MIRRORS_BASE}/wix311-binaries.zip\"\n+    mkdir -p wix/bin\n+    cd wix/bin\n+    7z x ../../wix311-binaries.zip\n+fi"}, {"sha": "f945db0ada27d70a93ccb5c6a54ed1a268600a2e", "filename": "src/ci/scripts/should-skip-this.sh", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fshould-skip-this.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,20 @@\n+#!/bin/bash\n+# Set the SKIP_JOB environment variable if this job is supposed to only run\n+# when submodules are updated and they were not. The following time consuming\n+# tasks will be skipped when the environment variable is present.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if [[ -z \"${CI_ONLY_WHEN_SUBMODULES_CHANGED+x}\" ]]; then\n+    echo \"Executing the job since there is no skip rule in effect\"\n+elif git diff HEAD^ | grep --quiet \"^index .* 160000\"; then\n+    # Submodules pseudo-files inside git have the 160000 permissions, so when\n+    # those files are present in the diff a submodule was updated.\n+    echo \"Executing the job since submodules are updated\"\n+else\n+    echo \"Not executing this job since no submodules were updated\"\n+    ciCommandSetEnv SKIP_JOB 1\n+fi"}, {"sha": "2cbb2ddbc7046ab77caf06977f76aad5e750568f", "filename": "src/ci/scripts/switch-xcode.sh", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fswitch-xcode.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fswitch-xcode.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fswitch-xcode.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,13 @@\n+#!/bin/bash\n+# Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n+# i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n+# force us to drop i686-apple-darwin, but let's keep the wheels turning for now.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isMacOS; then\n+    sudo xcode-select --switch /Applications/Xcode_9.3.app\n+fi"}, {"sha": "312ec9d805012c7433fc54b7643bf2cb9926a6d2", "filename": "src/ci/scripts/upload-artifacts.sh", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fupload-artifacts.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,41 @@\n+#!/bin/bash\n+# Upload all the artifacts to our S3 bucket. All the files inside ${upload_dir}\n+# will be uploaded to the deploy bucket and eventually signed and released in\n+# static.rust-lang.org.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+upload_dir=\"$(mktemp -d)\"\n+\n+# Release tarballs produced by a dist builder.\n+if [[ \"${DEPLOY-0}\" -eq \"1\" ]] || [[ \"${DEPLOY_ALT-0}\" -eq \"1\" ]]; then\n+    dist_dir=build/dist\n+    if isLinux; then\n+        dist_dir=obj/build/dist\n+    fi\n+    rm -rf \"${dist_dir}/doc\"\n+    cp -r \"${dist_dir}\"/* \"${upload_dir}\"\n+fi\n+\n+# CPU usage statistics.\n+cp cpu-usage.csv \"${upload_dir}/cpu-${CI_JOB_NAME}.csv\"\n+\n+# Toolstate data.\n+if [[ -n \"${DEPLOY_TOOLSTATES_JSON+x}\" ]]; then\n+    cp /tmp/toolstate/toolstates.json \"${upload_dir}/${DEPLOY_TOOLSTATES_JSON}\"\n+fi\n+\n+echo \"Files that will be uploaded:\"\n+ls -lah \"${upload_dir}\"\n+echo\n+\n+deploy_dir=\"rustc-builds\"\n+if [[ \"${DEPLOY_ALT-0}\" -eq \"1\" ]]; then\n+    deploy_dir=\"rustc-builds-alt\"\n+fi\n+deploy_url=\"s3://${DEPLOY_BUCKET}/${deploy_dir}/$(ciCommit)\"\n+\n+retry aws s3 cp --no-progress --recursive --acl public-read \"${upload_dir}\" \"${deploy_url}\""}, {"sha": "f3cac13ea4802f207338c00b2964f413fa345a80", "filename": "src/ci/scripts/verify-line-endings.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fverify-line-endings.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fverify-line-endings.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fverify-line-endings.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# See also the disable for autocrlf, this just checks that it worked.\n+#\n+# We check both in rust-lang/rust and in a submodule to make sure both are\n+# accurate. Submodules are checked out significantly later than the main\n+# repository in this script, so settings can (and do!) change between then.\n+#\n+# Linux (and maybe macOS) builders don't currently have dos2unix so just only\n+# run this step on Windows.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    # print out the git configuration so we can better investigate failures in\n+    # the following\n+    git config --list --show-origin\n+    dos2unix -ih Cargo.lock src/tools/rust-installer/install-template.sh\n+    endings=$(dos2unix -ic Cargo.lock src/tools/rust-installer/install-template.sh)\n+    # if endings has non-zero length, error out\n+    if [ -n \"$endings\" ]; then exit 1 ; fi\n+fi"}, {"sha": "e57128c70f5f194e533adfbc15c1f3cde35220b0", "filename": "src/ci/scripts/windows-symlink-build-dir.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,15 @@\n+#!/bin/bash\n+# We've had issues with the default drive in use running out of space during a\n+# build, and it looks like the `C:` drive has more space than the default `D:`\n+# drive. We should probably confirm this with the azure pipelines team at some\n+# point, but this seems to fix our \"disk space full\" problems.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows; then\n+    cmd //c \"mkdir c:\\\\MORE_SPACE\"\n+    cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n+fi"}, {"sha": "718a5379ae558c44aac11ac160163b71eb19225a", "filename": "src/ci/shared.sh", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -4,6 +4,8 @@\n # `source shared.sh`, hence the invalid shebang and not being\n # marked as an executable file in git.\n \n+export MIRRORS_BASE=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n+\n # See http://unix.stackexchange.com/questions/82598\n # Duplicated in docker/dist-various-2/shared.sh\n function retry {\n@@ -28,10 +30,43 @@ function isCI {\n   [ \"$CI\" = \"true\" ] || [ \"$TF_BUILD\" = \"True\" ]\n }\n \n-function isOSX {\n+function isMacOS {\n   [ \"$AGENT_OS\" = \"Darwin\" ]\n }\n \n+function isWindows {\n+  [ \"$AGENT_OS\" = \"Windows_NT\" ]\n+}\n+\n+function isLinux {\n+  [ \"$AGENT_OS\" = \"Linux\" ]\n+}\n+\n function getCIBranch {\n   echo \"$BUILD_SOURCEBRANCHNAME\"\n }\n+\n+function ciCommit {\n+  echo \"${BUILD_SOURCEVERSION}\"\n+}\n+\n+function ciCommandAddPath {\n+    if [[ $# -ne 1 ]]; then\n+        echo \"usage: $0 <path>\"\n+        exit 1\n+    fi\n+    path=\"$1\"\n+\n+    echo \"##vso[task.prependpath]${path}\"\n+}\n+\n+function ciCommandSetEnv {\n+    if [[ $# -ne 2 ]]; then\n+        echo \"usage: $0 <name> <value>\"\n+        exit 1\n+    fi\n+    name=\"$1\"\n+    value=\"$2\"\n+\n+    echo \"##vso[task.setvariable variable=${name}]${value}\"\n+}"}, {"sha": "28fa3d15b0bc67ea5e79eeff2198e4277fc61baf", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1 +1 @@\n-Subproject commit 871416b85c1a73717d65d6f4a9ea29e5aef3db0e\n+Subproject commit 28fa3d15b0bc67ea5e79eeff2198e4277fc61baf"}, {"sha": "4501d74073e900846f0bcf13196bfca39f6e9484", "filename": "src/doc/grammar.md", "status": "modified", "additions": 4, "deletions": 809, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,812 +1,7 @@\n % Grammar\n \n-# Introduction\n+The Rust grammar may now be found in the [reference]. Additionally, the [grammar\n+working group] is working on producing a testable grammar.\n \n-This document is the primary reference for the Rust programming language grammar. It\n-provides only one kind of material:\n-\n-  - Chapters that formally define the language grammar.\n-\n-This document does not serve as an introduction to the language. Background\n-familiarity with the language is assumed. A separate [guide] is available to\n-help acquire such background.\n-\n-This document also does not serve as a reference to the [standard] library\n-included in the language distribution. Those libraries are documented\n-separately by extracting documentation attributes from their source code. Many\n-of the features that one might expect to be language features are library\n-features in Rust, so what you're looking for may be there, not here.\n-\n-[guide]: guide.html\n-[standard]: std/index.html\n-\n-# Notation\n-\n-Rust's grammar is defined over Unicode codepoints, each conventionally denoted\n-`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n-confined to the ASCII range of Unicode, and is described in this document by a\n-dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n-supported by common automated LL(k) parsing tools such as `llgen`, rather than\n-the dialect given in ISO 14977. The dialect can be defined self-referentially\n-as follows:\n-\n-```antlr\n-grammar : rule + ;\n-rule    : nonterminal ':' productionrule ';' ;\n-productionrule : production [ '|' production ] * ;\n-production : term * ;\n-term : element repeats ;\n-element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n-repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-```\n-\n-Where:\n-\n-- Whitespace in the grammar is ignored.\n-- Square brackets are used to group rules.\n-- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n-  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode codepoint `U+00QQ`.\n-- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n-- The `repeat` forms apply to the adjacent `element`, and are as follows:\n-  - `?` means zero or one repetition\n-  - `*` means zero or more repetitions\n-  - `+` means one or more repetitions\n-  - NUMBER trailing a repeat symbol gives a maximum repetition count\n-  - NUMBER on its own gives an exact repetition count\n-\n-This EBNF dialect should hopefully be familiar to many readers.\n-\n-## Unicode productions\n-\n-A few productions in Rust's grammar permit Unicode codepoints outside the ASCII\n-range. We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range codepoints. The\n-section [Special Unicode Productions](#special-unicode-productions) lists these\n-productions.\n-\n-## String table productions\n-\n-Some rules in the grammar &mdash; notably [unary\n-operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), and [keywords](#keywords) &mdash; are\n-given in a simplified form: as a listing of a table of unquoted, printable\n-whitespace-separated strings. These cases form a subset of the rules regarding\n-the [token](#tokens) rule, and are assumed to be the result of a\n-lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n-disjunction of all such string table entries.\n-\n-When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n-it is an implicit reference to a single member of such a string table\n-production. See [tokens](#tokens) for more information.\n-\n-# Lexical structure\n-\n-## Input format\n-\n-Rust input is interpreted as a sequence of Unicode codepoints encoded in UTF-8.\n-Most Rust grammar rules are defined in terms of printable ASCII-range\n-codepoints, but a small number are defined in terms of Unicode properties or\n-explicit codepoint lists. [^inputformat]\n-\n-[^inputformat]: Substitute definitions for the special Unicode productions are\n-  provided to the grammar verifier, restricted to ASCII range, when verifying the\n-  grammar in this document.\n-\n-## Special Unicode Productions\n-\n-The following productions in the Rust grammar are defined in terms of Unicode\n-properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n-`non_double_quote`.\n-\n-### Identifiers\n-\n-The `ident` production is any nonempty Unicode string of\n-the following form:\n-\n-- The first character is in one of the following ranges `U+0041` to `U+005A`\n-(\"A\" to \"Z\"), `U+0061` to `U+007A` (\"a\" to \"z\"), or `U+005F` (\"\\_\").\n-- The remaining characters are in the range `U+0030` to `U+0039` (\"0\" to \"9\"),\n-or any of the prior valid initial characters.\n-\n-as long as the identifier does _not_ occur in the set of [keywords](#keywords).\n-\n-### Delimiter-restricted productions\n-\n-Some productions are defined by exclusion of particular Unicode characters:\n-\n-- `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is any single Unicode character aside from `U+000A` (`'\\n'`)\n-- `non_single_quote` is any single Unicode character aside from `U+0027`  (`'`)\n-- `non_double_quote` is any single Unicode character aside from `U+0022` (`\"`)\n-\n-## Comments\n-\n-```antlr\n-comment : block_comment | line_comment ;\n-block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : [block_comment | character] * ;\n-line_comment : \"//\" non_eol * ;\n-```\n-\n-**FIXME:** add doc grammar?\n-\n-## Whitespace\n-\n-```antlr\n-whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n-whitespace : [ whitespace_char | comment ] + ;\n-```\n-\n-## Tokens\n-\n-```antlr\n-simple_token : keyword | unop | binop ;\n-token : simple_token | ident | literal | symbol | whitespace token ;\n-```\n-\n-### Keywords\n-\n-<p id=\"keyword-table-marker\"></p>\n-\n-|          |          |          |          |          |\n-|----------|----------|----------|----------|----------|\n-| _        | abstract | alignof  | as       | become   |\n-| box      | break    | const    | continue | crate    |\n-| do       | else     | enum     | extern   | false    |\n-| final    | fn       | for      | if       | impl     |\n-| in       | let      | loop     | macro    | match    |\n-| mod      | move     | mut      | offsetof | override |\n-| priv     | proc     | pub      | pure     | ref      |\n-| return   | Self     | self     | sizeof   | static   |\n-| struct   | super    | trait    | true     | type     |\n-| typeof   | unsafe   | unsized  | use      | virtual  |\n-| where    | while    | yield    |          |          |\n-\n-\n-Each of these keywords has special meaning in its grammar, and all of them are\n-excluded from the `ident` rule.\n-\n-Not all of these keywords are used by the language. Some of them were used\n-before Rust 1.0, and were left reserved once their implementations were\n-removed. Some of them were reserved before 1.0 to make space for possible\n-future features.\n-\n-### Literals\n-\n-```antlr\n-lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit | bool_lit ] lit_suffix ?;\n-```\n-\n-The optional `lit_suffix` production is only used for certain numeric literals,\n-but is reserved for future extension. That is, the above gives the lexical\n-grammar, but a Rust parser will reject everything but the 12 special cases\n-mentioned in [Number literals](reference/tokens.html#number-literals) in the\n-reference.\n-\n-#### Character and string literals\n-\n-```antlr\n-char_lit : '\\x27' char_body '\\x27' ;\n-string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n-\n-char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n-\n-string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n-raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n-\n-common_escape : '\\x5c'\n-              | 'n' | 'r' | 't' | '0'\n-              | 'x' hex_digit 2\n-unicode_escape : 'u' '{' hex_digit+ 6 '}';\n-\n-hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n-          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-          | dec_digit ;\n-oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n-dec_digit : '0' | nonzero_dec ;\n-nonzero_dec: '1' | '2' | '3' | '4'\n-           | '5' | '6' | '7' | '8' | '9' ;\n-```\n-\n-#### Byte and byte string literals\n-\n-```antlr\n-byte_lit : \"b\\x27\" byte_body '\\x27' ;\n-byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n-\n-byte_body : ascii_non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n-\n-byte_string_body : ascii_non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n-raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n-\n-```\n-\n-#### Number literals\n-\n-```antlr\n-num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] +\n-              | 'o'   [ oct_digit | '_' ] +\n-              | 'x'   [ hex_digit | '_' ] +  ] ;\n-\n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n-\n-exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n-dec_lit : [ dec_digit | '_' ] + ;\n-```\n-\n-#### Boolean literals\n-\n-```antlr\n-bool_lit : [ \"true\" | \"false\" ] ;\n-```\n-\n-The two values of the boolean type are written `true` and `false`.\n-\n-### Symbols\n-\n-```antlr\n-symbol : \"::\" | \"->\"\n-       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n-       | ',' | ';' ;\n-```\n-\n-Symbols are a general class of printable [tokens](#tokens) that play structural\n-roles in a variety of grammar productions. They are cataloged here for\n-completeness as the set of remaining miscellaneous printable tokens that do not\n-otherwise appear as [unary operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), or [keywords](#keywords).\n-\n-## Paths\n-\n-```antlr\n-expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n-expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | expr_path ;\n-\n-type_path : ident [ type_path_tail ] + ;\n-type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | \"::\" type_path ;\n-```\n-\n-# Syntax extensions\n-\n-## Macros\n-\n-```antlr\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ';'\n-                 | \"macro_rules\" '!' ident '{' macro_rule * '}' ;\n-macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n-matcher : '(' matcher * ')' | '[' matcher * ']'\n-        | '{' matcher * '}' | '$' ident ':' ident\n-        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n-        | non_special_token ;\n-transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n-            | '{' transcriber * '}' | '$' ident\n-            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n-            | non_special_token ;\n-```\n-\n-# Crates and source files\n-\n-**FIXME:** grammar? What production covers #![crate_id = \"foo\"] ?\n-\n-# Items and attributes\n-\n-**FIXME:** grammar?\n-\n-## Items\n-\n-```antlr\n-item : vis ? mod_item | fn_item | type_item | struct_item | enum_item\n-     | const_item | static_item | trait_item | impl_item | extern_block_item ;\n-```\n-\n-### Type Parameters\n-\n-**FIXME:** grammar?\n-\n-### Modules\n-\n-```antlr\n-mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : [ view_item | item ] * ;\n-```\n-\n-#### View items\n-\n-```antlr\n-view_item : extern_crate_decl | use_decl ';' ;\n-```\n-\n-##### Extern crate declarations\n-\n-```antlr\n-extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( ident \"as\" ident )\n-```\n-\n-##### Use declarations\n-\n-```antlr\n-use_decl : vis ? \"use\" [ path \"as\" ident\n-                        | path_glob ] ;\n-\n-path_glob : ident [ \"::\" [ path_glob\n-                          | '*' ] ] ?\n-          | '{' path_item [ ',' path_item ] * '}' ;\n-\n-path_item : ident | \"self\" ;\n-```\n-\n-### Functions\n-\n-**FIXME:** grammar?\n-\n-#### Generic functions\n-\n-**FIXME:** grammar?\n-\n-#### Unsafety\n-\n-**FIXME:** grammar?\n-\n-##### Unsafe functions\n-\n-**FIXME:** grammar?\n-\n-##### Unsafe blocks\n-\n-**FIXME:** grammar?\n-\n-#### Diverging functions\n-\n-**FIXME:** grammar?\n-\n-### Type definitions\n-\n-**FIXME:** grammar?\n-\n-### Structures\n-\n-**FIXME:** grammar?\n-\n-### Enumerations\n-\n-**FIXME:** grammar?\n-\n-### Constant items\n-\n-```antlr\n-const_item : \"const\" ident ':' type '=' expr ';' ;\n-```\n-\n-### Static items\n-\n-```antlr\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n-```\n-\n-#### Mutable statics\n-\n-**FIXME:** grammar?\n-\n-### Traits\n-\n-**FIXME:** grammar?\n-\n-### Implementations\n-\n-**FIXME:** grammar?\n-\n-### External blocks\n-\n-```antlr\n-extern_block_item : \"extern\" '{' extern_block '}' ;\n-extern_block : [ foreign_fn ] * ;\n-```\n-\n-## Visibility and Privacy\n-\n-```antlr\n-vis : \"pub\" ;\n-```\n-### Re-exporting and Visibility\n-\n-See [Use declarations](#use-declarations).\n-\n-## Attributes\n-\n-```antlr\n-attribute : '#' '!' ? '[' meta_item ']' ;\n-meta_item : ident [ '=' literal\n-                  | '(' meta_seq ')' ] ? ;\n-meta_seq : meta_item [ ',' meta_seq ] ? ;\n-```\n-\n-# Statements and expressions\n-\n-## Statements\n-\n-```antlr\n-stmt : decl_stmt | expr_stmt | ';' ;\n-```\n-\n-### Declaration statements\n-\n-```antlr\n-decl_stmt : item | let_decl ;\n-```\n-\n-#### Item declarations\n-\n-See [Items](#items).\n-\n-#### Variable declarations\n-\n-```antlr\n-let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n-init : [ '=' ] expr ;\n-```\n-\n-### Expression statements\n-\n-```antlr\n-expr_stmt : expr ';' ;\n-```\n-\n-## Expressions\n-\n-```antlr\n-expr : literal | path | tuple_expr | unit_expr | struct_expr\n-     | block_expr | method_call_expr | field_expr | array_expr\n-     | idx_expr | range_expr | unop_expr | binop_expr\n-     | paren_expr | call_expr | lambda_expr | while_expr\n-     | loop_expr | break_expr | continue_expr | for_expr\n-     | if_expr | match_expr | if_let_expr | while_let_expr\n-     | return_expr ;\n-```\n-\n-#### Lvalues, rvalues and temporaries\n-\n-**FIXME:** grammar?\n-\n-#### Moved and copied types\n-\n-**FIXME:** Do we want to capture this in the grammar as different productions?\n-\n-### Literal expressions\n-\n-See [Literals](#literals).\n-\n-### Path expressions\n-\n-See [Paths](#paths).\n-\n-### Tuple expressions\n-\n-```antlr\n-tuple_expr : '(' [ expr [ ',' expr ] * | expr ',' ] ? ')' ;\n-```\n-\n-### Unit expressions\n-\n-```antlr\n-unit_expr : \"()\" ;\n-```\n-\n-### Structure expressions\n-\n-```antlr\n-struct_expr_field_init : ident | ident ':' expr ;\n-struct_expr : expr_path '{' struct_expr_field_init\n-                      [ ',' struct_expr_field_init ] *\n-                      [ \"..\" expr ] '}' |\n-              expr_path '(' expr\n-                      [ ',' expr ] * ')' |\n-              expr_path ;\n-```\n-\n-### Block expressions\n-\n-```antlr\n-block_expr : '{' [ stmt | item ] *\n-                 [ expr ] '}' ;\n-```\n-\n-### Method-call expressions\n-\n-```antlr\n-method_call_expr : expr '.' ident paren_expr_list ;\n-```\n-\n-### Field expressions\n-\n-```antlr\n-field_expr : expr '.' ident ;\n-```\n-\n-### Array expressions\n-\n-```antlr\n-array_expr : '[' \"mut\" ? array_elems? ']' ;\n-\n-array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n-```\n-\n-### Index expressions\n-\n-```antlr\n-idx_expr : expr '[' expr ']' ;\n-```\n-\n-### Range expressions\n-\n-```antlr\n-range_expr : expr \"..\" expr |\n-             expr \"..\" |\n-             \"..\" expr |\n-             \"..\" ;\n-```\n-\n-### Unary operator expressions\n-\n-```antlr\n-unop_expr : unop expr ;\n-unop : '-' | '*' | '!' ;\n-```\n-\n-### Binary operator expressions\n-\n-```antlr\n-binop_expr : expr binop expr | type_cast_expr\n-           | assignment_expr | compound_assignment_expr ;\n-binop : arith_op | bitwise_op | lazy_bool_op | comp_op\n-```\n-\n-#### Arithmetic operators\n-\n-```antlr\n-arith_op : '+' | '-' | '*' | '/' | '%' ;\n-```\n-\n-#### Bitwise operators\n-\n-```antlr\n-bitwise_op : '&' | '|' | '^' | \"<<\" | \">>\" ;\n-```\n-\n-#### Lazy boolean operators\n-\n-```antlr\n-lazy_bool_op : \"&&\" | \"||\" ;\n-```\n-\n-#### Comparison operators\n-\n-```antlr\n-comp_op : \"==\" | \"!=\" | '<' | '>' | \"<=\" | \">=\" ;\n-```\n-\n-#### Type cast expressions\n-\n-```antlr\n-type_cast_expr : value \"as\" type ;\n-```\n-\n-#### Assignment expressions\n-\n-```antlr\n-assignment_expr : expr '=' expr ;\n-```\n-\n-#### Compound assignment expressions\n-\n-```antlr\n-compound_assignment_expr : expr [ arith_op | bitwise_op ] '=' expr ;\n-```\n-\n-### Grouped expressions\n-\n-```antlr\n-paren_expr : '(' expr ')' ;\n-```\n-\n-### Call expressions\n-\n-```antlr\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-```\n-\n-### Lambda expressions\n-\n-```antlr\n-ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '|' expr ;\n-```\n-\n-### While loops\n-\n-```antlr\n-while_expr : [ lifetime ':' ] ? \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n-### Infinite loops\n-\n-```antlr\n-loop_expr : [ lifetime ':' ] ? \"loop\" '{' block '}';\n-```\n-\n-### Break expressions\n-\n-```antlr\n-break_expr : \"break\" [ lifetime ] ?;\n-```\n-\n-### Continue expressions\n-\n-```antlr\n-continue_expr : \"continue\" [ lifetime ] ?;\n-```\n-\n-### For expressions\n-\n-```antlr\n-for_expr : [ lifetime ':' ] ? \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n-### If expressions\n-\n-```antlr\n-if_expr : \"if\" no_struct_literal_expr '{' block '}'\n-          else_tail ? ;\n-\n-else_tail : \"else\" [ if_expr | if_let_expr\n-                   | '{' block '}' ] ;\n-```\n-\n-### Match expressions\n-\n-```antlr\n-match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n-\n-match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n-\n-match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-```\n-\n-### If let expressions\n-\n-```antlr\n-if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n-               else_tail ? ;\n-```\n-\n-### While let loops\n-\n-```antlr\n-while_let_expr : [ lifetime ':' ] ? \"while\" \"let\" pat '=' expr '{' block '}' ;\n-```\n-\n-### Return expressions\n-\n-```antlr\n-return_expr : \"return\" expr ? ;\n-```\n-\n-# Type system\n-\n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n-\n-## Types\n-\n-### Primitive types\n-\n-**FIXME:** grammar?\n-\n-#### Machine types\n-\n-**FIXME:** grammar?\n-\n-#### Machine-dependent integer types\n-\n-**FIXME:** grammar?\n-\n-### Textual types\n-\n-**FIXME:** grammar?\n-\n-### Tuple types\n-\n-**FIXME:** grammar?\n-\n-### Array, and Slice types\n-\n-**FIXME:** grammar?\n-\n-### Structure types\n-\n-**FIXME:** grammar?\n-\n-### Enumerated types\n-\n-**FIXME:** grammar?\n-\n-### Pointer types\n-\n-**FIXME:** grammar?\n-\n-### Function types\n-\n-**FIXME:** grammar?\n-\n-### Closure types\n-\n-```antlr\n-closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n-                [ ':' bound-list ] [ '->' type ]\n-lifetime-list := lifetime | lifetime ',' lifetime-list\n-arg-list := ident ':' type | ident ':' type ',' arg-list\n-```\n-\n-### Never type\n-An empty type\n-\n-```antlr\n-never_type : \"!\" ;\n-```\n-\n-### Object types\n-\n-**FIXME:** grammar?\n-\n-### Type parameters\n-\n-**FIXME:** grammar?\n-\n-### Type parameter bounds\n-\n-```antlr\n-bound-list := bound | bound '+' bound-list '+' ?\n-bound := ty_bound | lt_bound\n-lt_bound := lifetime\n-ty_bound := ty_bound_noparen | (ty_bound_noparen)\n-ty_bound_noparen := [?] [ for<lt_param_defs> ] simple_path\n-```\n-\n-### Self types\n-\n-**FIXME:** grammar?\n-\n-## Type kinds\n-\n-**FIXME:** this is probably not relevant to the grammar...\n-\n-# Memory and concurrency models\n-\n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n-\n-## Memory model\n-\n-### Memory allocation and lifetime\n-\n-### Memory ownership\n-\n-### Variables\n-\n-### Boxes\n-\n-## Threads\n-\n-### Communication between threads\n-\n-### Thread lifecycle\n+[reference]: https://doc.rust-lang.org/reference/\n+[grammar working group]: https://github.com/rust-lang/wg-grammar"}, {"sha": "5004ad30d69f93553ceef74439fea2159d1f769e", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1 +1 @@\n-Subproject commit 4374786f0b4bf0606b35d5c30a9681f342e5707b\n+Subproject commit 5004ad30d69f93553ceef74439fea2159d1f769e"}, {"sha": "4b21b646669e0af49fae7cae301898dc4bfaa1f0", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1 +1 @@\n-Subproject commit fa5dfb832ef8a7568e17dabf612f486d641ff4ac\n+Subproject commit 4b21b646669e0af49fae7cae301898dc4bfaa1f0"}, {"sha": "f3197ddf2abab9abdbc029def8164f4a748b0d91", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1 +1 @@\n-Subproject commit 67cfbf31df880728dcf7cb35b15b028ec92caf31\n+Subproject commit f3197ddf2abab9abdbc029def8164f4a748b0d91"}, {"sha": "b603c7b231e68471aacb58fe47a4349f52e80226", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -10,9 +10,11 @@\n         - [Warn-by-default lints](lints/listing/warn-by-default.md)\n         - [Deny-by-default lints](lints/listing/deny-by-default.md)\n - [Codegen options](codegen-options/index.md)\n+- [JSON Output](json.md)\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n+    - [Known Issues](targets/known-issues.md)\n - [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "f5d5f2089d7e76901c0f5a84912e8d02aaa26c84", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -61,6 +61,8 @@ enabling or disabling a feature.\n To see the valid options and an example of use, run `rustc --print\n target-features`.\n \n+Using this flag is unsafe and might result in [undefined runtime behavior](../targets/known-issues.md).\n+\n ## passes\n \n This flag can be used to add extra LLVM passes to the compilation.\n@@ -105,7 +107,7 @@ flag will turn that behavior off.\n \n ## no-vectorize-slp\n \n-By default, `rustc` will attempt to vectorize loops using [superword-level\n+By default, `rustc` will attempt to vectorize code using [superword-level\n parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n flag will turn that behavior off.\n "}, {"sha": "bdb3c5196585e09df6fc73d44116e4509603bea1", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -92,6 +92,7 @@ information about editions may be found in the [edition guide].\n [edition guide]: ../edition-guide/introduction.html\n \n ## `--emit`: specifies the types of output files to generate\n+ <a id=\"option-emit\"></a>\n \n This flag controls the types of output files generated by the compiler. It\n accepts a comma-separated list of values, and may be specified multiple times.\n@@ -144,7 +145,7 @@ of print values are:\n   target CPU may be selected with the `-C target-cpu=val` flag.\n - `target-features` \u2014 List of available target features for the current\n   target. Target features may be enabled with the `-C target-feature=val`\n-  flag.\n+  flag. This flag is unsafe. See [known issues](targets/known-issues.md) for more details.\n - `relocation-models` \u2014 List of relocation models. Relocation models may be\n   selected with the `-C relocation-model=val` flag.\n - `code-models` \u2014 List of code models. Code models may be selected with the\n@@ -241,12 +242,13 @@ The \"sysroot\" is where `rustc` looks for the crates that come with the Rust\n distribution; this flag allows that to be overridden.\n \n ## `--error-format`: control how errors are produced\n+ <a id=\"option-error-format\"></a>\n \n This flag lets you control the format of messages. Messages are printed to\n stderr. The valid options are:\n \n - `human` \u2014 Human-readable output. This is the default.\n-- `json` \u2014 Structured JSON output.\n+- `json` \u2014 Structured JSON output. See [the JSON chapter] for more detail.\n - `short` \u2014 Short, one-line messages.\n \n ## `--color`: configure coloring of output\n@@ -273,6 +275,7 @@ pathname syntax. For example `--remap-path-prefix foo=bar` will match\n `foo/lib.rs` but not `./foo/lib.rs`.\n \n ## `--json`: configure json messages printed by the compiler\n+ <a id=\"option-json\"></a>\n \n When the `--error-format=json` option is passed to rustc then all of the\n compiler's diagnostic output will be emitted in the form of JSON blobs. The\n@@ -305,9 +308,13 @@ to customize the output:\n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n \n+See [the JSON chapter] for more detail.\n+\n ## `@path`: load command-line flags from a path\n \n If you specify `@path` on the command-line, then it will open `path` and read\n command line options from it. These options are one per line; a blank line indicates\n an empty option. The file can use Unix or Windows style line endings, and must be\n encoded as UTF-8.\n+\n+[the JSON chapter]: json.md"}, {"sha": "b737849516310478fbfad3cfa86224b9c380e13d", "filename": "src/doc/rustc/src/json.md", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,231 @@\n+# JSON Output\n+\n+This chapter documents the JSON structures emitted by `rustc`. JSON may be\n+enabled with the [`--error-format=json` flag][option-error-format]. Additional\n+options may be specified with the [`--json` flag][option-json] which can\n+change which messages are generated, and the format of the messages.\n+\n+JSON messages are emitted one per line to stderr.\n+\n+If parsing the output with Rust, the\n+[`cargo_metadata`](https://crates.io/crates/cargo_metadata) crate provides\n+some support for parsing the messages.\n+\n+When parsing, care should be taken to be forwards-compatible with future changes\n+to the format. Optional values may be `null`. New fields may be added. Enumerated\n+fields like \"level\" or \"suggestion_applicability\" may add new values.\n+\n+## Diagnostics\n+\n+Diagnostic messages provide errors or possible concerns generated during\n+compilation. `rustc` provides detailed information about where the diagnostic\n+originates, along with hints and suggestions.\n+\n+Diagnostics are arranged in a parent/child relationship where the parent\n+diagnostic value is the core of the diagnostic, and the attached children\n+provide additional context, help, and information.\n+\n+Diagnostics have the following format:\n+\n+```javascript\n+{\n+    /* The primary message. */\n+    \"message\": \"unused variable: `x`\",\n+    /* The diagnostic code.\n+       Some messages may set this value to null.\n+    */\n+    \"code\": {\n+        /* A unique string identifying which diagnostic triggered. */\n+        \"code\": \"unused_variables\",\n+        /* An optional string explaining more detail about the diagnostic code. */\n+        \"explanation\": null\n+    },\n+    /* The severity of the diagnostic.\n+       Values may be:\n+       - \"error\": A fatal error that prevents compilation.\n+       - \"warning\": A possible error or concern.\n+       - \"note\": Additional information or context about the diagnostic.\n+       - \"help\": A suggestion on how to resolve the diagnostic.\n+       - \"failure-note\": A note attached to the message for further information.\n+       - \"error: internal compiler error\": Indicates a bug within the compiler.\n+    */\n+    \"level\": \"warning\",\n+    /* An array of source code locations to point out specific details about\n+       where the diagnostic originates from. This may be empty, for example\n+       for some global messages, or child messages attached to a parent.\n+\n+       Character offsets are offsets of Unicode Scalar Values.\n+    */\n+    \"spans\": [\n+        {\n+            /* The file where the span is located.\n+               For spans located within a macro expansion, this will be the\n+               name of the expanded macro in the format \"<MACRONAME macros>\".\n+            */\n+            \"file_name\": \"lib.rs\",\n+            /* The byte offset where the span starts (0-based, inclusive). */\n+            \"byte_start\": 21,\n+            /* The byte offset where the span ends (0-based, exclusive). */\n+            \"byte_end\": 22,\n+            /* The first line number of the span (1-based, inclusive). */\n+            \"line_start\": 2,\n+            /* The last line number of the span (1-based, inclusive). */\n+            \"line_end\": 2,\n+            /* The first character offset of the line_start (1-based, inclusive). */\n+            \"column_start\": 9,\n+            /* The last character offset of the line_end (1-based, exclusive). */\n+            \"column_end\": 10,\n+            /* Whether or not this is the \"primary\" span.\n+\n+               This indicates that this span is the focal point of the\n+               diagnostic.\n+\n+               There are rare cases where multiple spans may be marked as\n+               primary. For example, \"immutable borrow occurs here\" and\n+               \"mutable borrow ends here\" can be two separate primary spans.\n+\n+               The top (parent) message should always have at least one\n+               primary span, unless it has zero spans. Child messages may have\n+               zero or more primary spans.\n+            */\n+            \"is_primary\": true,\n+            /* An array of objects showing the original source code for this\n+               span. This shows the entire lines of text where the span is\n+               located. A span across multiple lines will have a separate\n+               value for each line.\n+            */\n+            \"text\": [\n+                {\n+                    /* The entire line of the original source code. */\n+                    \"text\": \"    let x = 123;\",\n+                    /* The first character offset of the line of\n+                       where the span covers this line (1-based, inclusive). */\n+                    \"highlight_start\": 9,\n+                    /* The last character offset of the line of\n+                       where the span covers this line (1-based, exclusive). */\n+                    \"highlight_end\": 10\n+                }\n+            ],\n+            /* An optional message to display at this span location.\n+               This is typically null for primary spans.\n+            */\n+            \"label\": null,\n+            /* An optional string of a suggested replacement for this span to\n+               solve the issue. Tools may try to replace the contents of the\n+               span with this text.\n+            */\n+            \"suggested_replacement\": null,\n+            /* An optional string that indicates the confidence of the\n+               \"suggested_replacement\". Tools may use this value to determine\n+               whether or not suggestions should be automatically applied.\n+\n+               Possible values may be:\n+               - \"MachineApplicable\": The suggestion is definitely what the\n+                 user intended. This suggestion should be automatically\n+                 applied.\n+               - \"MaybeIncorrect\": The suggestion may be what the user\n+                 intended, but it is uncertain. The suggestion should result\n+                 in valid Rust code if it is applied.\n+               - \"HasPlaceholders\": The suggestion contains placeholders like\n+                 `(...)`. The suggestion cannot be applied automatically\n+                 because it will not result in valid Rust code. The user will\n+                 need to fill in the placeholders.\n+               - \"Unspecified\": The applicability of the suggestion is unknown.\n+            */\n+            \"suggestion_applicability\": null,\n+            /* An optional object indicating the expansion of a macro within\n+               this span.\n+\n+               If a message occurs within a macro invocation, this object will\n+               provide details of where within the macro expansion the message\n+               is located.\n+            */\n+            \"expansion\": {\n+                /* The span of the macro invocation.\n+                   Uses the same span definition as the \"spans\" array.\n+                */\n+                \"span\": {/*...*/}\n+                /* Name of the macro, such as \"foo!\" or \"#[derive(Eq)]\". */\n+                \"macro_decl_name\": \"some_macro!\",\n+                /* Optional span where the relevant part of the macro is\n+                  defined. */\n+                \"def_site_span\": {/*...*/},\n+            }\n+        }\n+    ],\n+    /* Array of attached diagnostic messages.\n+       This is an array of objects using the same format as the parent\n+       message. Children are not nested (children do not themselves\n+       contain \"children\" definitions).\n+    */\n+    \"children\": [\n+        {\n+            \"message\": \"`#[warn(unused_variables)]` on by default\",\n+            \"code\": null,\n+            \"level\": \"note\",\n+            \"spans\": [],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"consider prefixing with an underscore\",\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"lib.rs\",\n+                    \"byte_start\": 21,\n+                    \"byte_end\": 22,\n+                    \"line_start\": 2,\n+                    \"line_end\": 2,\n+                    \"column_start\": 9,\n+                    \"column_end\": 10,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"    let x = 123;\",\n+                            \"highlight_start\": 9,\n+                            \"highlight_end\": 10\n+                        }\n+                    ],\n+                    \"label\": null,\n+                    \"suggested_replacement\": \"_x\",\n+                    \"suggestion_applicability\": \"MachineApplicable\",\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [],\n+            \"rendered\": null\n+        }\n+    ],\n+    /* Optional string of the rendered version of the diagnostic as displayed\n+       by rustc. Note that this may be influenced by the `--json` flag.\n+    */\n+    \"rendered\": \"warning: unused variable: `x`\\n --> lib.rs:2:9\\n  |\\n2 |     let x = 123;\\n  |         ^ help: consider prefixing with an underscore: `_x`\\n  |\\n  = note: `#[warn(unused_variables)]` on by default\\n\\n\"\n+}\n+```\n+\n+## Artifact notifications\n+\n+Artifact notifications are emitted when the [`--json=artifacts`\n+flag][option-json] is used. They indicate that a file artifact has been saved\n+to disk. More information about emit kinds may be found in the [`--emit`\n+flag][option-emit] documentation.\n+\n+```javascript\n+{\n+    /* The filename that was generated. */\n+    \"artifact\": \"libfoo.rlib\",\n+    /* The kind of artifact that was generated. Possible values:\n+       - \"link\": The generated crate as specified by the crate-type.\n+       - \"dep-info\": The `.d` file with dependency information in a Makefile-like syntax.\n+       - \"metadata\": The Rust `.rmeta` file containing metadata about the crate.\n+       - \"save-analysis\": A JSON file emitted by the `-Zsave-analysis` feature.\n+    */\n+    \"emit\": \"link\"\n+}\n+```\n+\n+[option-emit]: command-line-arguments.md#option-emit\n+[option-error-format]: command-line-arguments.md#option-error-format\n+[option-json]: command-line-arguments.md#option-json"}, {"sha": "5688e90ada129a8fa0fdc9942be4acff461767ae", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -222,3 +222,28 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n+\n+## const-err\n+\n+This lint detects expressions that will always panic at runtime and would be an\n+error in a `const` context.\n+\n+```rust,ignore\n+let _ = [0; 4][4];\n+```\n+\n+This will produce:\n+\n+```text\n+error: index out of bounds: the len is 4 but the index is 4\n+ --> src/lib.rs:1:9\n+  |\n+1 | let _ = [0; 4][4];\n+  |         ^^^^^^^^^\n+  |\n+```\n+\n+## order-dependent-trait-objects\n+\n+This lint detects a trait coherency violation that would allow creating two\n+trait impls for the same dynamic trait object involving marker traits."}, {"sha": "813d7c4bafef8cfdaf779be20dacf71cfc46de35", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -596,30 +596,6 @@ warning: function cannot return without recursing\n   |\n ```\n \n-## unions-with-drop-fields\n-\n-This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![feature(untagged_unions)]\n-\n-union U {\n-    s: String,\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n- --> src/main.rs:4:5\n-  |\n-4 |     s: String,\n-  |     ^^^^^^^^^\n-  |\n-```\n-\n ## unknown-lints\n \n This lint detects unrecognized lint attribute. Some"}, {"sha": "d066f4a9cf59c1040c8691b803b3d650f399944c", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -125,6 +125,17 @@ RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n     cargo build --release --target=x86_64-unknown-linux-gnu\n ```\n \n+### Troubleshooting\n+\n+- It is recommended to pass `-Cllvm-args=-pgo-warn-missing-function` during the\n+  `-Cprofile-use` phase. LLVM by default does not warn if it cannot find\n+  profiling data for a given function. Enabling this warning will make it\n+  easier to spot errors in your setup.\n+\n+- There is a [known issue](https://github.com/rust-lang/cargo/issues/7416) in\n+  Cargo prior to version 1.39 that will prevent PGO from working correctly. Be\n+  sure to use Cargo 1.39 or newer when doing PGO.\n+\n ## Further Reading\n \n `rustc`'s PGO support relies entirely on LLVM's implementation of the feature"}, {"sha": "5859df83f645bc8ea5e3cc4fd4e6057a29fad440", "filename": "src/doc/rustc/src/targets/index.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -11,3 +11,9 @@ To compile to a particular target, use the `--target` flag:\n ```bash\n $ rustc src/main.rs --target=wasm32-unknown-unknown\n ```\n+## Target Features\n+`x86`,  and `ARMv8` are two popular CPU architectures. Their instruction sets form a common baseline across most CPUs. However, some CPUs extend these with custom instruction sets, e.g. vector (`AVX`), bitwise manipulation (`BMI`) or cryptographic (`AES`).\n+\n+Developers, who know on which CPUs their compiled code is going to run can choose to add (or remove) CPU specific instruction sets via the `-C target-feature=val` flag.\n+\n+Please note, that this flag is generally considered as unsafe. More details can be found in [this section](known-issues.md)."}, {"sha": "89fd8ea6d32e96f1b3869eb9e5d091a16d0c3821", "filename": "src/doc/rustc/src/targets/known-issues.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fknown-issues.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,13 @@\n+# Known Issues\n+This section informs you about known \"gotchas\". Keep in mind, that this section is (and always will be) incomplete. For suggestions and amendments, feel free to [contribute](../contributing.md) to this guide.\n+\n+## Target Features\n+Most target-feature problems arise, when mixing code that have the target-feature _enabled_ with code that have it _disabled_. If you want to avoid undefined behavior, it is recommended to build _all code_ (including the standard library and imported crates) with a common set of target-features.\n+\n+By default, compiling your code with the `-C target-feature` flag will not recompile the entire standard library and/or imported crates with matching target features. Therefore, target features are generally considered as unsafe. Using `#[target_feature]` on individual functions makes the function unsafe.\n+\n+Examples:\n+\n+| Target-Feature | Issue | Seen on | Description | Details |\n+| -------------- | ----- | ------- | ----------- | ------- |\n+| `+soft-float` <br> and <br> `-sse` | Segfaults and ABI mismatches | `x86` and `x86-64` | The `x86` and `x86_64` architecture uses SSE registers (aka `xmm`) for floating point operations. Using software emulated floats (\"soft-floats\") disables usage of `xmm` registers, but parts of Rust's core libraries (e.g. `std::f32` or `std::f64`) are compiled without soft-floats and expect parameters to be passed in `xmm` registers. This leads to ABI mismatches. <br><br>  Attempting to compile with disabled SSE causes the same error, too. | [#63466](https://github.com/rust-lang/rust/issues/63466) |"}, {"sha": "bc1da5ff15a8c2de2557c5ce49720c006adab2a8", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -379,3 +379,49 @@ However, it's preferable to use fenced code blocks over indented code blocks.\n Not only are fenced code blocks considered more idiomatic for Rust code,\n but there is no way to use directives such as `ignore` or `should_panic` with\n indented code blocks.\n+\n+### Include items only when collecting doctests\n+\n+Rustdoc's documentation tests can do some things that regular unit tests can't, so it can\n+sometimes be useful to extend your doctests with samples that wouldn't otherwise need to be in\n+documentation. To this end, Rustdoc allows you to have certain items only appear when it's\n+collecting doctests, so you can utilize doctest functionality without forcing the test to appear in\n+docs, or to find an arbitrary private item to include it on.\n+\n+When compiling a crate for use in doctests (with `--test` option), rustdoc will set `cfg(doctest)`.\n+Note that they will still link against only the public items of your crate; if you need to test\n+private items, you need to write a unit test.\n+\n+In this example, we're adding doctests that we know won't compile, to verify that our struct can\n+only take in valid data:\n+\n+```rust\n+/// We have a struct here. Remember it doesn't accept negative numbers!\n+pub struct MyStruct(pub usize);\n+\n+/// ```compile_fail\n+/// let x = my_crate::MyStruct(-5);\n+/// ```\n+#[cfg(doctest)]\n+pub struct MyStructOnlyTakesUsize;\n+```\n+\n+Note that the struct `MyStructOnlyTakesUsize` here isn't actually part of your public crate\n+API. The use of `#[cfg(doctest)]` makes sure that this struct only exists while rustdoc is\n+collecting doctests. This means that its doctest is executed when `--test` is passed to rustdoc,\n+but is hidden from the public documentation.\n+\n+Another possible use of `cfg(doctest)` is to test doctests that are included in your README file\n+without including it in your main documentation. For example, you could write this into your\n+`lib.rs` to test your README as part of your doctests:\n+\n+```rust,ignore\n+#![feature(extern_doc)]\n+\n+#[doc(include=\"../README.md\")]\n+#[cfg(doctest)]\n+pub struct ReadmeDoctests;\n+```\n+\n+This will include your README as documentation on the hidden struct `ReadmeDoctests`, which will\n+then be tested alongside the rest of your doctests."}, {"sha": "3c3e72aa3795912e5cedfa08930e439ef3dd24c8", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -211,36 +211,6 @@ pub struct BigX;\n Then, when looking for it through the `rustdoc` search, if you enter \"x\" or\n \"big\", search will show the `BigX` struct first.\n \n-### Include items only when collecting doctests\n-\n-Rustdoc's [documentation tests] can do some things that regular unit tests can't, so it can\n-sometimes be useful to extend your doctests with samples that wouldn't otherwise need to be in\n-documentation. To this end, Rustdoc allows you to have certain items only appear when it's\n-collecting doctests, so you can utilize doctest functionality without forcing the test to appear in\n-docs, or to find an arbitrary private item to include it on.\n-\n-If you add `#![feature(cfg_doctest)]` to your crate, Rustdoc will set `cfg(doctest)` when collecting\n-doctests. Note that they will still link against only the public items of your crate; if you need to\n-test private items, unit tests are still the way to go.\n-\n-In this example, we're adding doctests that we know won't compile, to verify that our struct can\n-only take in valid data:\n-\n-```rust\n-#![feature(cfg_doctest)]\n-\n-/// We have a struct here. Remember it doesn't accept negative numbers!\n-pub struct MyStruct(usize);\n-\n-/// ```compile_fail\n-/// let x = my_crate::MyStruct(-5);\n-/// ```\n-#[cfg(doctest)]\n-pub struct MyStructOnlyTakesUsize;\n-```\n-\n-[documentation tests]: documentation-tests.html\n-\n ## Unstable command-line arguments\n \n These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are"}, {"sha": "ed4e9c6b56842cef485f063c14092500e23c58f5", "filename": "src/doc/unstable-book/src/compiler-flags/report-time.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Freport-time.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,80 @@\n+# `report-time`\n+\n+The tracking issue for this feature is: [#64888]\n+\n+[#64888]: https://github.com/rust-lang/rust/issues/64888\n+\n+------------------------\n+\n+The `report-time` feature adds a possibility to report execution time of the\n+tests generated via `libtest`.\n+\n+This is unstable feature, so you have to provide `-Zunstable-options` to get\n+this feature working.\n+\n+Sample usage command:\n+\n+```sh\n+./test_executable -Zunstable-options --report-time\n+```\n+\n+Available options:\n+\n+```sh\n+--report-time [plain|colored]\n+                Show execution time of each test. Awailable values:\n+                plain = do not colorize the execution time (default);\n+                colored = colorize output according to the `color`\n+                parameter value;\n+                Threshold values for colorized output can be\n+                configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                Not available for --format=terse\n+--ensure-time \n+                Treat excess of the test execution time limit as\n+                error.\n+                Threshold values for this option can be configured via\n+                `RUST_TEST_TIME_UNIT`, `RUST_TEST_TIME_INTEGRATION`\n+                and\n+                `RUST_TEST_TIME_DOCTEST` environment variables.\n+                Expected format of environment variable is\n+                `VARIABLE=WARN_TIME,CRITICAL_TIME`.\n+                `CRITICAL_TIME` here means the limit that should not be\n+                exceeded by test.\n+```\n+\n+Example of the environment variable format:\n+\n+```sh\n+RUST_TEST_TIME_UNIT=100,200\n+```\n+\n+where 100 stands for warn time, and 200 stands for critical time.\n+\n+## Examples\n+\n+```sh\n+cargo test --tests -- -Zunstable-options --report-time\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n+     Running target/debug/deps/example-27fb188025bec02c\n+\n+running 3 tests\n+test tests::unit_test_quick ... ok <0.000s>\n+test tests::unit_test_warn ... ok <0.055s>\n+test tests::unit_test_critical ... ok <0.110s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+     Running target/debug/deps/tests-cedb06f6526d15d9\n+\n+running 3 tests\n+test unit_test_quick ... ok <0.000s>\n+test unit_test_warn ... ok <0.550s>\n+test unit_test_critical ... ok <1.100s>\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+```"}, {"sha": "907147c17ef8e500260577c1c637d7260bc7bd5b", "filename": "src/doc/unstable-book/src/language-features/non-exhaustive.md", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,76 +0,0 @@\n-# `non_exhaustive`\n-\n-The tracking issue for this feature is: [#44109]\n-\n-[#44109]: https://github.com/rust-lang/rust/issues/44109\n-\n-------------------------\n-\n-The `non_exhaustive` gate allows you to use the `#[non_exhaustive]` attribute\n-on structs, enums and enum variants. When applied within a crate, users of the\n-crate will need to use the `_` pattern when matching enums and use the `..`\n-pattern when matching structs. Enum variants cannot be matched against.\n-Structs and enum variants marked as `non_exhaustive` will not be able to\n-be created normally outside of the defining crate. This is demonstrated\n-below:\n-\n-```rust,ignore (pseudo-Rust)\n-use std::error::Error as StdError;\n-\n-#[non_exhaustive]\n-pub enum Error {\n-    Message(String),\n-    Other,\n-}\n-impl StdError for Error {\n-    fn description(&self) -> &str {\n-        // This will not error, despite being marked as non_exhaustive, as this\n-        // enum is defined within the current crate, it can be matched\n-        // exhaustively.\n-        match *self {\n-            Message(ref s) => s,\n-            Other => \"other or unknown error\",\n-        }\n-    }\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-use mycrate::Error;\n-\n-// This will not error as the non_exhaustive Error enum has been matched with\n-// a wildcard.\n-match error {\n-    Message(ref s) => ...,\n-    Other => ...,\n-    _ => ...,\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-#[non_exhaustive]\n-pub struct Config {\n-    pub window_width: u16,\n-    pub window_height: u16,\n-}\n-\n-// We can create structs as normal within the defining crate when marked as\n-// non_exhaustive.\n-let config = Config { window_width: 640, window_height: 480 };\n-\n-// We can match structs exhaustively when within the defining crate.\n-if let Ok(Config { window_width, window_height }) = load_config() {\n-    // ...\n-}\n-```\n-\n-```rust,ignore (pseudo-Rust)\n-use mycrate::Config;\n-\n-// We cannot create a struct like normal if it has been marked as\n-// non_exhaustive.\n-let config = Config { window_width: 640, window_height: 480 };\n-// By adding the `..` we can match the config as below outside of the crate\n-// when marked non_exhaustive.\n-let &Config { window_width, window_height, .. } = config;\n-```"}, {"sha": "afc11a2b9492cfa8ef06de26bebf2a1662a2d195", "filename": "src/doc/unstable-book/src/language-features/track-caller.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrack-caller.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,5 @@\n+# `track_caller`\n+\n+The tracking issue for this feature is: [#47809](https://github.com/rust-lang/rust/issues/47809).\n+\n+------------------------"}, {"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "src/grammar/.gitignore", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,3 +0,0 @@\n-*.class\n-*.java\n-*.tokens"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "src/grammar/lexer.l", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,350 +0,0 @@\n-%{\n-#include <stdio.h>\n-#include <ctype.h>\n-\n-static int num_hashes;\n-static int end_hashes;\n-static int saw_non_hash;\n-\n-%}\n-\n-%option stack\n-%option yylineno\n-\n-%x str\n-%x rawstr\n-%x rawstr_esc_begin\n-%x rawstr_esc_body\n-%x rawstr_esc_end\n-%x byte\n-%x bytestr\n-%x rawbytestr\n-%x rawbytestr_nohash\n-%x pound\n-%x shebang_or_attr\n-%x ltorchar\n-%x linecomment\n-%x doc_line\n-%x blockcomment\n-%x doc_block\n-%x suffix\n-\n-ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n-\n-%%\n-\n-<suffix>{ident}            { BEGIN(INITIAL); }\n-<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n-\n-[ \\n\\t\\r]             { }\n-\n-\\xef\\xbb\\xbf {\n-  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n-  if (yyget_lineno() != 1) {\n-    return -1;\n-  }\n-}\n-\n-\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n-<doc_line>\\n          { BEGIN(INITIAL);\n-                        yyleng--;\n-                        yytext[yyleng] = 0;\n-                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-                      }\n-<doc_line>[^\\n]*      { yymore(); }\n-\n-\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n-<linecomment>\\n       { BEGIN(INITIAL); }\n-<linecomment>[^\\n]*   { }\n-\n-\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n-<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n-<doc_block>\\*\\/       {\n-    yy_pop_state();\n-    if (yy_top_state() == doc_block) {\n-        yymore();\n-    } else {\n-        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-    }\n-}\n-<doc_block>(.|\\n)     { yymore(); }\n-\n-\\/\\*                  { yy_push_state(blockcomment); }\n-<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n-<blockcomment>\\*\\/    { yy_pop_state(); }\n-<blockcomment>(.|\\n)   { }\n-\n-_        { return UNDERSCORE; }\n-abstract { return ABSTRACT; }\n-alignof  { return ALIGNOF; }\n-as       { return AS; }\n-become   { return BECOME; }\n-box      { return BOX; }\n-break    { return BREAK; }\n-catch    { return CATCH; }\n-const    { return CONST; }\n-continue { return CONTINUE; }\n-crate    { return CRATE; }\n-default  { return DEFAULT; }\n-do       { return DO; }\n-else     { return ELSE; }\n-enum     { return ENUM; }\n-extern   { return EXTERN; }\n-false    { return FALSE; }\n-final    { return FINAL; }\n-fn       { return FN; }\n-for      { return FOR; }\n-if       { return IF; }\n-impl     { return IMPL; }\n-in       { return IN; }\n-let      { return LET; }\n-loop     { return LOOP; }\n-macro    { return MACRO; }\n-match    { return MATCH; }\n-mod      { return MOD; }\n-move     { return MOVE; }\n-mut      { return MUT; }\n-offsetof { return OFFSETOF; }\n-override { return OVERRIDE; }\n-priv     { return PRIV; }\n-proc     { return PROC; }\n-pure     { return PURE; }\n-pub      { return PUB; }\n-ref      { return REF; }\n-return   { return RETURN; }\n-self     { return SELF; }\n-sizeof   { return SIZEOF; }\n-static   { return STATIC; }\n-struct   { return STRUCT; }\n-super    { return SUPER; }\n-trait    { return TRAIT; }\n-true     { return TRUE; }\n-type     { return TYPE; }\n-typeof   { return TYPEOF; }\n-union    { return UNION; }\n-unsafe   { return UNSAFE; }\n-unsized  { return UNSIZED; }\n-use      { return USE; }\n-virtual  { return VIRTUAL; }\n-where    { return WHERE; }\n-while    { return WHILE; }\n-yield    { return YIELD; }\n-\n-{ident}  { return IDENT; }\n-\n-0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-7_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n-0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n-\n-[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n-[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n-\n-;      { return ';'; }\n-,      { return ','; }\n-\\.\\.\\. { return DOTDOTDOT; }\n-\\.\\.   { return DOTDOT; }\n-\\.     { return '.'; }\n-\\(     { return '('; }\n-\\)     { return ')'; }\n-\\{     { return '{'; }\n-\\}     { return '}'; }\n-\\[     { return '['; }\n-\\]     { return ']'; }\n-@      { return '@'; }\n-#      { BEGIN(pound); yymore(); }\n-<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n-<shebang_or_attr>\\[ {\n-  BEGIN(INITIAL);\n-  yyless(2);\n-  return SHEBANG;\n-}\n-<shebang_or_attr>[^\\[\\n]*\\n {\n-  // Since the \\n was eaten as part of the token, yylineno will have\n-  // been incremented to the value 2 if the shebang was on the first\n-  // line. This yyless undoes that, setting yylineno back to 1.\n-  yyless(yyleng - 1);\n-  if (yyget_lineno() == 1) {\n-    BEGIN(INITIAL);\n-    return SHEBANG_LINE;\n-  } else {\n-    BEGIN(INITIAL);\n-    yyless(2);\n-    return SHEBANG;\n-  }\n-}\n-<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n-\n-\\~     { return '~'; }\n-::     { return MOD_SEP; }\n-:      { return ':'; }\n-\\$     { return '$'; }\n-\\?     { return '?'; }\n-\n-==    { return EQEQ; }\n-=>    { return FAT_ARROW; }\n-=     { return '='; }\n-\\!=   { return NE; }\n-\\!    { return '!'; }\n-\\<=   { return LE; }\n-\\<\\<  { return SHL; }\n-\\<\\<= { return SHLEQ; }\n-\\<    { return '<'; }\n-\\>=   { return GE; }\n-\\>\\>  { return SHR; }\n-\\>\\>= { return SHREQ; }\n-\\>    { return '>'; }\n-\n-\\x27                                      { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n-\n-b\\x22              { BEGIN(bytestr); yymore(); }\n-<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n-\n-<bytestr><<EOF>>                     { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n-<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n-<bytestr>(.|\\n)                      { yymore(); }\n-\n-br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n-<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n-<rawbytestr_nohash>(.|\\n)   { yymore(); }\n-<rawbytestr_nohash><<EOF>>  { return -1; }\n-\n-br/# {\n-    BEGIN(rawbytestr);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-<rawbytestr># {\n-    if (!saw_non_hash) {\n-        num_hashes++;\n-    } else if (end_hashes != 0) {\n-        end_hashes++;\n-        if (end_hashes == num_hashes) {\n-            BEGIN(INITIAL);\n-            return LIT_BYTE_STR_RAW;\n-        }\n-    }\n-    yymore();\n-}\n-<rawbytestr>\\x22# {\n-    end_hashes = 1;\n-    if (end_hashes == num_hashes) {\n-        BEGIN(INITIAL);\n-        return LIT_BYTE_STR_RAW;\n-    }\n-    yymore();\n-}\n-<rawbytestr>(.|\\n) {\n-    if (!saw_non_hash) {\n-        saw_non_hash = 1;\n-    }\n-    if (end_hashes != 0) {\n-        end_hashes = 0;\n-    }\n-    yymore();\n-}\n-<rawbytestr><<EOF>> { return -1; }\n-\n-b\\x27                           { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n-\n-r\\x22           { BEGIN(rawstr); yymore(); }\n-<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n-<rawstr>(.|\\n)  { yymore(); }\n-<rawstr><<EOF>> { return -1; }\n-\n-r/#             {\n-    BEGIN(rawstr_esc_begin);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-\n-<rawstr_esc_begin># {\n-    num_hashes++;\n-    yymore();\n-}\n-<rawstr_esc_begin>\\x22 {\n-    BEGIN(rawstr_esc_body);\n-    yymore();\n-}\n-<rawstr_esc_begin>(.|\\n) { return -1; }\n-\n-<rawstr_esc_body>\\x22/# {\n-  BEGIN(rawstr_esc_end);\n-  yymore();\n- }\n-<rawstr_esc_body>(.|\\n) {\n-  yymore();\n- }\n-\n-<rawstr_esc_end># {\n-  end_hashes++;\n-  if (end_hashes == num_hashes) {\n-    BEGIN(INITIAL);\n-    return LIT_STR_RAW;\n-  }\n-  yymore();\n- }\n-<rawstr_esc_end>[^#] {\n-  end_hashes = 0;\n-  BEGIN(rawstr_esc_body);\n-  yymore();\n- }\n-\n-<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n-\n-\\x22                     { BEGIN(str); yymore(); }\n-<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n-\n-<str><<EOF>>                     { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n-<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n-<str>(.|\\n)                      { yymore(); }\n-\n-\\<-  { return LARROW; }\n--\\>  { return RARROW; }\n--    { return '-'; }\n--=   { return MINUSEQ; }\n-&&   { return ANDAND; }\n-&    { return '&'; }\n-&=   { return ANDEQ; }\n-\\|\\| { return OROR; }\n-\\|   { return '|'; }\n-\\|=  { return OREQ; }\n-\\+   { return '+'; }\n-\\+=  { return PLUSEQ; }\n-\\*   { return '*'; }\n-\\*=  { return STAREQ; }\n-\\/   { return '/'; }\n-\\/=  { return SLASHEQ; }\n-\\^   { return '^'; }\n-\\^=  { return CARETEQ; }\n-%    { return '%'; }\n-%=   { return PERCENTEQ; }\n-\n-<<EOF>> { return 0; }\n-\n-%%"}, {"sha": "6348190cc140bc8ae496ec99a9000ef4d934c334", "filename": "src/grammar/parser-lalr-main.c", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,193 +0,0 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern int yylex();\n-extern int rsparse();\n-\n-#define PUSHBACK_LEN 4\n-\n-static char pushback[PUSHBACK_LEN];\n-static int verbose;\n-\n-void print(const char* format, ...) {\n-  va_list args;\n-  va_start(args, format);\n-  if (verbose) {\n-    vprintf(format, args);\n-  }\n-  va_end(args);\n-}\n-\n-// If there is a non-null char at the head of the pushback queue,\n-// dequeue it and shift the rest of the queue forwards. Otherwise,\n-// return the token from calling yylex.\n-int rslex() {\n-  if (pushback[0] == '\\0') {\n-    return yylex();\n-  } else {\n-    char c = pushback[0];\n-    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n-    pushback[PUSHBACK_LEN - 1] = '\\0';\n-    return c;\n-  }\n-}\n-\n-// Note: this does nothing if the pushback queue is full. As long as\n-// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n-// in an action, this shouldn't be a problem.\n-void push_back(char c) {\n-  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n-    if (pushback[i] == '\\0') {\n-      pushback[i] = c;\n-      break;\n-    }\n-  }\n-}\n-\n-extern int rsdebug;\n-\n-struct node {\n-  struct node *next;\n-  struct node *prev;\n-  int own_string;\n-  char const *name;\n-  int n_elems;\n-  struct node *elems[];\n-};\n-\n-struct node *nodes = NULL;\n-int n_nodes;\n-\n-struct node *mk_node(char const *name, int n, ...) {\n-  va_list ap;\n-  int i = 0;\n-  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n-  struct node *nn, *nd = (struct node *)malloc(sz);\n-\n-  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n-\n-  nd->own_string = 0;\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  if (nodes) {\n-    nodes->prev = nd;\n-  }\n-  nodes = nd;\n-\n-  nd->name = name;\n-  nd->n_elems = n;\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[i++] = nn;\n-  }\n-  va_end(ap);\n-  n_nodes++;\n-  return nd;\n-}\n-\n-struct node *mk_atom(char *name) {\n-  struct node *nd = mk_node((char const *)strdup(name), 0);\n-  nd->own_string = 1;\n-  return nd;\n-}\n-\n-struct node *mk_none() {\n-  return mk_atom(\"<none>\");\n-}\n-\n-struct node *ext_node(struct node *nd, int n, ...) {\n-  va_list ap;\n-  int i = 0, c = nd->n_elems + n;\n-  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n-  struct node *nn;\n-\n-  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n-        nd->n_elems, c, nd->name, nd);\n-\n-  if (nd->next) {\n-    nd->next->prev = nd->prev;\n-  }\n-  if (nd->prev) {\n-    nd->prev->next = nd->next;\n-  }\n-  nd = realloc(nd, sz);\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  nodes->prev = nd;\n-  nodes = nd;\n-\n-  print(\" ==> %p\\n\", nd);\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[nd->n_elems++] = nn;\n-    ++i;\n-  }\n-  va_end(ap);\n-  return nd;\n-}\n-\n-int const indent_step = 4;\n-\n-void print_indent(int depth) {\n-  while (depth) {\n-    if (depth-- % indent_step == 0) {\n-      print(\"|\");\n-    } else {\n-      print(\" \");\n-    }\n-  }\n-}\n-\n-void print_node(struct node *n, int depth) {\n-  int i = 0;\n-  print_indent(depth);\n-  if (n->n_elems == 0) {\n-    print(\"%s\\n\", n->name);\n-  } else {\n-    print(\"(%s\\n\", n->name);\n-    for (i = 0; i < n->n_elems; ++i) {\n-      print_node(n->elems[i], depth + indent_step);\n-    }\n-    print_indent(depth);\n-    print(\")\\n\");\n-  }\n-}\n-\n-int main(int argc, char **argv) {\n-  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n-    verbose = 1;\n-  } else {\n-    verbose = 0;\n-  }\n-  int ret = 0;\n-  struct node *tmp;\n-  memset(pushback, '\\0', PUSHBACK_LEN);\n-  ret = rsparse();\n-  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n-  if (nodes) {\n-    print_node(nodes, 0);\n-  }\n-  while (nodes) {\n-    tmp = nodes;\n-    nodes = tmp->next;\n-    if (tmp->own_string) {\n-      free((void*)tmp->name);\n-    }\n-    free(tmp);\n-  }\n-  return ret;\n-}\n-\n-void rserror(char const *s) {\n-  fprintf(stderr, \"%s\\n\", s);\n-}"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "src/grammar/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,1982 +0,0 @@\n-%{\n-#define YYERROR_VERBOSE\n-#define YYSTYPE struct node *\n-struct node;\n-extern int yylex();\n-extern void yyerror(char const *s);\n-extern struct node *mk_node(char const *name, int n, ...);\n-extern struct node *mk_atom(char *text);\n-extern struct node *mk_none();\n-extern struct node *ext_node(struct node *nd, int n, ...);\n-extern void push_back(char c);\n-extern char *yytext;\n-%}\n-%debug\n-\n-%token SHL\n-%token SHR\n-%token LE\n-%token EQEQ\n-%token NE\n-%token GE\n-%token ANDAND\n-%token OROR\n-%token SHLEQ\n-%token SHREQ\n-%token MINUSEQ\n-%token ANDEQ\n-%token OREQ\n-%token PLUSEQ\n-%token STAREQ\n-%token SLASHEQ\n-%token CARETEQ\n-%token PERCENTEQ\n-%token DOTDOT\n-%token DOTDOTDOT\n-%token MOD_SEP\n-%token RARROW\n-%token LARROW\n-%token FAT_ARROW\n-%token LIT_BYTE\n-%token LIT_CHAR\n-%token LIT_INTEGER\n-%token LIT_FLOAT\n-%token LIT_STR\n-%token LIT_STR_RAW\n-%token LIT_BYTE_STR\n-%token LIT_BYTE_STR_RAW\n-%token IDENT\n-%token UNDERSCORE\n-%token LIFETIME\n-\n-// keywords\n-%token SELF\n-%token STATIC\n-%token ABSTRACT\n-%token ALIGNOF\n-%token AS\n-%token BECOME\n-%token BREAK\n-%token CATCH\n-%token CRATE\n-%token DO\n-%token ELSE\n-%token ENUM\n-%token EXTERN\n-%token FALSE\n-%token FINAL\n-%token FN\n-%token FOR\n-%token IF\n-%token IMPL\n-%token IN\n-%token LET\n-%token LOOP\n-%token MACRO\n-%token MATCH\n-%token MOD\n-%token MOVE\n-%token MUT\n-%token OFFSETOF\n-%token OVERRIDE\n-%token PRIV\n-%token PUB\n-%token PURE\n-%token REF\n-%token RETURN\n-%token SIZEOF\n-%token STRUCT\n-%token SUPER\n-%token UNION\n-%token UNSIZED\n-%token TRUE\n-%token TRAIT\n-%token TYPE\n-%token UNSAFE\n-%token VIRTUAL\n-%token YIELD\n-%token DEFAULT\n-%token USE\n-%token WHILE\n-%token CONTINUE\n-%token PROC\n-%token BOX\n-%token CONST\n-%token WHERE\n-%token TYPEOF\n-%token INNER_DOC_COMMENT\n-%token OUTER_DOC_COMMENT\n-\n-%token SHEBANG\n-%token SHEBANG_LINE\n-%token STATIC_LIFETIME\n-\n- /*\n-   Quoting from the Bison manual:\n-\n-   \"Finally, the resolution of conflicts works by comparing the precedence\n-   of the rule being considered with that of the lookahead token. If the\n-   token's precedence is higher, the choice is to shift. If the rule's\n-   precedence is higher, the choice is to reduce. If they have equal\n-   precedence, the choice is made based on the associativity of that\n-   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n-   Bison) says how each conflict was resolved\"\n- */\n-\n-// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n-// all potential ambiguities are scrutinized and eliminated manually.\n-%expect 0\n-\n-// fake-precedence symbol to cause '|' bars in lambda context to parse\n-// at low precedence, permit things like |x| foo = bar, where '=' is\n-// otherwise lower-precedence than '|'. Also used for proc() to cause\n-// things like proc() a + b to parse as proc() { a + b }.\n-%precedence LAMBDA\n-\n-%precedence SELF\n-\n-// MUT should be lower precedence than IDENT so that in the pat rule,\n-// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n-%precedence MUT\n-\n-// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n-// trying to decide if we've got a struct-construction expr (esp. in\n-// contexts like 'if foo { .')\n-//\n-// IDENT also needs to be lower precedence than '<' so that '<' in\n-// 'foo:bar . <' is shifted (in a trait reference occurring in a\n-// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n-%precedence IDENT\n- // Put the weak keywords that can be used as idents here as well\n-%precedence CATCH\n-%precedence DEFAULT\n-%precedence UNION\n-\n-// A couple fake-precedence symbols to use in rules associated with +\n-// and < in trailing type contexts. These come up when you have a type\n-// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n-// has to be shifted so the parser keeps trying to parse a type, even\n-// though it might well consider reducing the type \"bar\" and then\n-// going on to \"<\" as a subsequent binop. The \"+\" case is with\n-// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n-%precedence SHIFTPLUS\n-\n-%precedence MOD_SEP\n-%precedence RARROW ':'\n-\n-// In where clauses, \"for\" should have greater precedence when used as\n-// a higher ranked constraint than when used as the beginning of a\n-// for_in_type (which is a ty)\n-%precedence FORTYPE\n-%precedence FOR\n-\n-// Binops & unops, and their precedences\n-%precedence '?'\n-%precedence BOX\n-%nonassoc DOTDOT\n-\n-// RETURN needs to be lower-precedence than tokens that start\n-// prefix_exprs\n-%precedence RETURN YIELD\n-\n-%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n-%right LARROW\n-%left OROR\n-%left ANDAND\n-%left EQEQ NE\n-%left '<' '>' LE GE\n-%left '|'\n-%left '^'\n-%left '&'\n-%left SHL SHR\n-%left '+' '-'\n-%precedence AS\n-%left '*' '/' '%'\n-%precedence '!'\n-\n-%precedence '{' '[' '(' '.'\n-\n-%precedence RANGE\n-\n-%start crate\n-\n-%%\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 1: Items and attributes\n-////////////////////////////////////////////////////////////////////////\n-\n-crate\n-: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n-| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n-;\n-\n-maybe_shebang\n-: SHEBANG_LINE\n-| %empty\n-;\n-\n-maybe_inner_attrs\n-: inner_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-inner_attrs\n-: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n-| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-inner_attr\n-: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n-| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n-;\n-\n-maybe_outer_attrs\n-: outer_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-outer_attrs\n-: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n-| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-outer_attr\n-: '#' '[' meta_item ']'    { $$ = $3; }\n-| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n-;\n-\n-meta_item\n-: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n-| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n-| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-;\n-\n-meta_seq\n-: %empty                   { $$ = mk_none(); }\n-| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n-| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_mod_items\n-: mod_items\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-mod_items\n-: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n-| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-attrs_and_vis\n-: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n-;\n-\n-mod_item\n-: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n-;\n-\n-// items that can appear outside of a fn block\n-item\n-: stmt_item\n-| item_macro\n-;\n-\n-// items that can appear in \"stmts\"\n-stmt_item\n-: item_static\n-| item_const\n-| item_type\n-| block_item\n-| view_item\n-;\n-\n-item_static\n-: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n-| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n-;\n-\n-item_const\n-: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n-;\n-\n-item_macro\n-: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-;\n-\n-view_item\n-: use_item\n-| extern_fn_item\n-| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n-| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n-;\n-\n-extern_fn_item\n-: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n-;\n-\n-use_item\n-: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n-;\n-\n-view_path\n-: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n-| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n-|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n-|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n-|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n-|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n-|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n-;\n-\n-block_item\n-: item_fn\n-| item_unsafe_fn\n-| item_mod\n-| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n-| item_struct\n-| item_enum\n-| item_union\n-| item_trait\n-| item_impl\n-;\n-\n-maybe_ty_ascription\n-: ':' ty_sum { $$ = $2; }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_init_expr\n-: '=' expr { $$ = $2; }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-// structs\n-item_struct\n-: STRUCT ident generic_params maybe_where_clause struct_decl_args\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n-}\n-;\n-\n-struct_decl_args\n-: '{' struct_decl_fields '}'                  { $$ = $2; }\n-| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n-;\n-\n-struct_tuple_args\n-: '(' struct_tuple_fields ')'                 { $$ = $2; }\n-| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n-;\n-\n-struct_decl_fields\n-: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_decl_field\n-: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n-;\n-\n-struct_tuple_fields\n-: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_tuple_field\n-: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n-;\n-\n-// enums\n-item_enum\n-: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n-| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n-;\n-\n-enum_defs\n-: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n-| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n-| %empty                 { $$ = mk_none(); }\n-;\n-\n-enum_def\n-: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n-;\n-\n-enum_args\n-: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| %empty                         { $$ = mk_none(); }\n-;\n-\n-// unions\n-item_union\n-: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n-| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n-\n-item_mod\n-: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n-| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n-| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n-;\n-\n-item_foreign_mod\n-: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n-| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n-;\n-\n-maybe_abi\n-: str\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_foreign_items\n-: foreign_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-foreign_items\n-: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n-| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n-;\n-\n-foreign_item\n-: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n-| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-;\n-\n-item_foreign_static\n-: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n-;\n-\n-item_foreign_fn\n-: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n-;\n-\n-fn_decl_allow_variadic\n-: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params_allow_variadic\n-: '(' ')'                      { $$ = mk_none(); }\n-| '(' params ')'               { $$ = $2; }\n-| '(' params ',' ')'           { $$ = $2; }\n-| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n-;\n-\n-visibility\n-: PUB      { $$ = mk_atom(\"Public\"); }\n-| %empty   { $$ = mk_atom(\"Inherited\"); }\n-;\n-\n-idents_or_self\n-: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n-| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ident_or_self\n-: ident\n-| SELF  { $$ = mk_atom(yytext); }\n-;\n-\n-item_type\n-: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n-;\n-\n-for_sized\n-: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n-| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n-| %empty        { $$ = mk_none(); }\n-;\n-\n-item_trait\n-: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n-{\n-  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n-}\n-;\n-\n-maybe_trait_items\n-: trait_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-trait_items\n-: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n-| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-trait_item\n-: trait_const\n-| trait_type\n-| trait_method\n-| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n-;\n-\n-trait_const\n-: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_const_default\n-: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-trait_type\n-: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n-;\n-\n-maybe_unsafe\n-: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_default_maybe_unsafe\n-: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n-| DEFAULT        { $$ = mk_atom(\"Default\"); }\n-|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-\n-trait_method\n-: type_method { $$ = mk_node(\"Required\", 1, $1); }\n-| method      { $$ = mk_node(\"Provided\", 1, $1); }\n-;\n-\n-type_method\n-: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n-}\n-| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n-}\n-| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n-}\n-;\n-\n-method\n-: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n-}\n-| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-impl_method\n-: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n-}\n-| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n-}\n-;\n-\n-// There are two forms of impl:\n-//\n-// impl (<...>)? TY { ... }\n-// impl (<...>)? TRAIT for TY { ... }\n-//\n-// Unfortunately since TY can begin with '<' itself -- as part of a\n-// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n-// should we reduce one of the early rules of TY (such as maybe_once)\n-// or shall we continue shifting into the generic_params list for the\n-// impl?\n-//\n-// The production parser disambiguates a different case here by\n-// permitting / requiring the user to provide parens around types when\n-// they are ambiguous with traits. We do the same here, regrettably,\n-// by splitting ty into ty and ty_prim.\n-item_impl\n-: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n-}\n-;\n-\n-maybe_impl_items\n-: impl_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_items\n-: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n-| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n-;\n-\n-impl_item\n-: impl_method\n-| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n-| impl_const\n-| impl_type\n-;\n-\n-maybe_default\n-: DEFAULT { $$ = mk_atom(\"Default\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_const\n-: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n-;\n-\n-impl_type\n-: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n-;\n-\n-item_fn\n-: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n-}\n-| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n-}\n-;\n-\n-item_unsafe_fn\n-: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n-}\n-| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n-}\n-| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n-}\n-;\n-\n-fn_decl\n-: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self\n-: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self_allow_anon_params\n-: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params\n-: '(' maybe_params ')'  { $$ = $2; }\n-;\n-\n-fn_anon_params\n-: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n-| '(' ')'                                            { $$ = mk_none(); }\n-;\n-\n-fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-maybe_params\n-: params\n-| params ','\n-| %empty  { $$ = mk_none(); }\n-;\n-\n-params\n-: param                { $$ = mk_node(\"Args\", 1, $1); }\n-| params ',' param     { $$ = ext_node($1, 1, $3); }\n-;\n-\n-param\n-: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-;\n-\n-inferrable_params\n-: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n-| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-inferrable_param\n-: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n-;\n-\n-maybe_comma_params\n-: ','            { $$ = mk_none(); }\n-| ',' params     { $$ = $2; }\n-| ',' params ',' { $$ = $2; }\n-| %empty         { $$ = mk_none(); }\n-;\n-\n-maybe_comma_anon_params\n-: ','                 { $$ = mk_none(); }\n-| ',' anon_params     { $$ = $2; }\n-| ',' anon_params ',' { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-maybe_anon_params\n-: anon_params\n-| anon_params ','\n-| %empty      { $$ = mk_none(); }\n-;\n-\n-anon_params\n-: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n-| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// anon means it's allowed to be anonymous (type-only), but it can\n-// still have a name\n-anon_param\n-: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-| ty\n-;\n-\n-anon_params_allow_variadic_tail\n-: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n-| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n-| %empty                                         { $$ = mk_none(); }\n-;\n-\n-named_arg\n-: ident\n-| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n-| '&' ident         { $$ = $2; }\n-| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n-| ANDAND ident      { $$ = $2; }\n-| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n-| MUT ident         { $$ = $2; }\n-;\n-\n-ret_ty\n-: RARROW '!'         { $$ = mk_none(); }\n-| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n-| %prec IDENT %empty { $$ = mk_none(); }\n-;\n-\n-generic_params\n-: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n-| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| %empty                              { $$ = mk_none(); }\n-;\n-\n-maybe_where_clause\n-: %empty                              { $$ = mk_none(); }\n-| where_clause\n-;\n-\n-where_clause\n-: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n-| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n-;\n-\n-where_predicates\n-: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n-| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n-;\n-\n-where_predicate\n-: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-;\n-\n-maybe_for_lifetimes\n-: FOR '<' lifetimes '>' { $$ = mk_none(); }\n-| %prec FORTYPE %empty  { $$ = mk_none(); }\n-\n-ty_params\n-: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n-| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with no type parameters; e.g. `foo::bar::Baz`\n-//\n-// These show up in 'use' view-items, because these are processed\n-// without respect to types.\n-path_no_types_allowed\n-: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n-| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n-| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n-| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n-| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters, with no double colons\n-// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-//\n-// These show up in \"trait references\", the components of\n-// type-parameter bounds lists, as well as in the prefix of the\n-// path_generic_args_and_bounds rule, which is the full form of a\n-// named typed expression.\n-//\n-// They do not have (nor need) an extra '::' before '<' because\n-// unlike in expr context, there are no \"less-than\" type exprs to\n-// be ambiguous with.\n-path_generic_args_without_colons\n-: %prec IDENT\n-  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n-| %prec IDENT\n-  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n-| %prec IDENT\n-  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n-;\n-\n-generic_args\n-: '<' generic_values '>'   { $$ = $2; }\n-| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n-| '<' generic_values GE    { push_back('='); $$ = $2; }\n-| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-// If generic_args starts with \"<<\", the first arg must be a\n-// TyQualifiedPath because that's the only type that can start with a\n-// '<'. This rule parses that as the first ty_sum and then continues\n-// with the rest of generic_values.\n-| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-;\n-\n-generic_values\n-: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n-;\n-\n-maybe_ty_sums_and_or_bindings\n-: ty_sums\n-| ty_sums ','\n-| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n-| bindings\n-| bindings ','\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_bindings\n-: ',' bindings { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 2: Patterns\n-////////////////////////////////////////////////////////////////////////\n-\n-pat\n-: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n-| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n-| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n-| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n-| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n-| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n-| lit_or_path\n-| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n-| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n-| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n-| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n-| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n-|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n-| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n-| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-;\n-\n-pats_or\n-: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n-| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding_mode\n-: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n-| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n-| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n-;\n-\n-lit_or_path\n-: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n-| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n-| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n-;\n-\n-pat_field\n-:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n-|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n-| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n-| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n-|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n-| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n-|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n-;\n-\n-pat_fields\n-: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n-| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_struct\n-: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n-| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n-| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n-;\n-\n-pat_tup\n-: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n-| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n-| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n-| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n-| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_tup_elts\n-: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n-| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_vec\n-: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_vec_elts\n-: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n-| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 3: Types\n-////////////////////////////////////////////////////////////////////////\n-\n-ty\n-: ty_prim\n-| ty_closure\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n-| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n-;\n-\n-ty_prim\n-: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n-| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n-| ty_bare_fn\n-| for_in_type\n-;\n-\n-ty_bare_fn\n-:                         FN ty_fn_decl { $$ = $2; }\n-| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n-|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n-| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n-;\n-\n-ty_fn_decl\n-: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n-;\n-\n-ty_closure\n-: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n-|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n-| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n-|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n-;\n-\n-for_in_type\n-: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n-;\n-\n-for_in_type_suffix\n-: ty_bare_fn\n-| trait_ref\n-| ty_closure\n-;\n-\n-maybe_mut\n-: MUT              { $$ = mk_atom(\"MutMutable\"); }\n-| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-maybe_mut_or_const\n-: MUT    { $$ = mk_atom(\"MutMutable\"); }\n-| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n-| %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-ty_qualified_path_and_generic_values\n-: ty_qualified_path maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n-}\n-| ty_qualified_path ',' ty_sums maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n-}\n-;\n-\n-ty_qualified_path\n-: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-;\n-\n-maybe_ty_sums\n-: ty_sums\n-| ty_sums ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-ty_sums\n-: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n-| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum\n-: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum_elt\n-: ty\n-| lifetime\n-;\n-\n-ty_prim_sum\n-: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_prim_sum_elt\n-: ty_prim\n-| lifetime\n-;\n-\n-maybe_ty_param_bounds\n-: ':' ty_param_bounds { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-ty_param_bounds\n-: boundseq\n-| %empty { $$ = mk_none(); }\n-;\n-\n-boundseq\n-: polybound\n-| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-polybound\n-: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n-| bound\n-| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n-| '?' bound { $$ = $2; }\n-;\n-\n-bindings\n-: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n-| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding\n-: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n-;\n-\n-ty_param\n-: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n-| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_bounds\n-: %prec SHIFTPLUS\n-  ':' bounds             { $$ = $2; }\n-| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n-;\n-\n-bounds\n-: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n-| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-bound\n-: lifetime\n-| trait_ref\n-;\n-\n-maybe_ltbounds\n-: %prec SHIFTPLUS\n-  ':' ltbounds       { $$ = $2; }\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-ltbounds\n-: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n-| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_ty_default\n-: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n-| %empty     { $$ = mk_none(); }\n-;\n-\n-maybe_lifetimes\n-: lifetimes\n-| lifetimes ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-lifetimes\n-: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n-| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n-;\n-\n-lifetime_and_bounds\n-: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n-| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-lifetime\n-: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n-| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-trait_ref\n-: %prec IDENT path_generic_args_without_colons\n-| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 4: Blocks, statements, and expressions\n-////////////////////////////////////////////////////////////////////////\n-\n-inner_attrs_and_block\n-: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n-;\n-\n-block\n-: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n-;\n-\n-maybe_stmts\n-: stmts\n-| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n-| nonblock_expr\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-// There are two sub-grammars within a \"stmts: exprs\" derivation\n-// depending on whether each stmt-expr is a block-expr form; this is to\n-// handle the \"semicolon rule\" for stmt sequencing that permits\n-// writing\n-//\n-//     if foo { bar } 10\n-//\n-// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n-// stmt). Unfortunately by permitting juxtaposition of exprs in\n-// sequence like that, the non-block expr grammar has to have a\n-// second limited sub-grammar that excludes the prefix exprs that\n-// are ambiguous with binops. That is to say:\n-//\n-//     {10} - 1\n-//\n-// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n-// is to say, two statements rather than one, at least according to\n-// the mainline rust parser.\n-//\n-// So we wind up with a 3-way split in exprs that occur in stmt lists:\n-// block, nonblock-prefix, and nonblock-nonprefix.\n-//\n-// In non-stmts contexts, expr can relax this trichotomy.\n-\n-stmts\n-: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n-| stmts stmt     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-stmt\n-: maybe_outer_attrs let     { $$ = $2; }\n-|                 stmt_item\n-|             PUB stmt_item { $$ = $2; }\n-| outer_attrs     stmt_item { $$ = $2; }\n-| outer_attrs PUB stmt_item { $$ = $3; }\n-| full_block_expr\n-| maybe_outer_attrs block   { $$ = $2; }\n-|             nonblock_expr ';'\n-| outer_attrs nonblock_expr ';' { $$ = $2; }\n-| ';'                   { $$ = mk_none(); }\n-;\n-\n-maybe_exprs\n-: exprs\n-| exprs ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_expr\n-: expr\n-| %empty { $$ = mk_none(); }\n-;\n-\n-exprs\n-: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n-| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n-;\n-\n-path_expr\n-: path_generic_args_with_colons\n-| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n-| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters with double colons before\n-// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-//\n-// These show up in expr context, in order to disambiguate from \"less-than\"\n-// expressions.\n-path_generic_args_with_colons\n-: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n-| SUPER                                              { $$ = mk_atom(\"Super\"); }\n-| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n-| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n-| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// the braces-delimited macro is a block_expr so it doesn't appear here\n-macro_expr\n-: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-;\n-\n-nonblock_expr\n-: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| nonblock_prefix_expr\n-;\n-\n-expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-expr_nostruct\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n-| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n-| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n-| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr_nostruct\n-;\n-\n-nonblock_prefix_expr_nostruct\n-: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr_nostruct\n-| MOVE lambda_expr_nostruct                 { $$ = $2; }\n-;\n-\n-nonblock_prefix_expr\n-: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr\n-| MOVE lambda_expr                 { $$ = $2; }\n-;\n-\n-expr_qualified_path\n-: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n-}\n-\n-maybe_qpath_params\n-: MOD_SEP generic_args { $$ = $2; }\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_as_trait_ref\n-: AS trait_ref { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-lambda_expr\n-: %prec LAMBDA\n-  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n-| %prec LAMBDA\n-  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n-;\n-\n-lambda_expr_no_first_bar\n-: %prec LAMBDA\n-  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n-| %prec LAMBDA\n-  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n-;\n-\n-lambda_expr_nostruct\n-: %prec LAMBDA\n-  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n-;\n-\n-lambda_expr_nostruct_no_first_bar\n-: %prec LAMBDA\n-  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n-| %prec LAMBDA\n-  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n-;\n-\n-vec_expr\n-: maybe_exprs\n-| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n-;\n-\n-struct_expr_fields\n-: field_inits\n-| field_inits ','\n-| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n-| %empty                               { $$ = mk_none(); }\n-;\n-\n-maybe_field_inits\n-: field_inits\n-| field_inits ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-field_inits\n-: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n-| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n-;\n-\n-field_init\n-: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n-| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n-| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n-;\n-\n-default_field_init\n-: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n-;\n-\n-block_expr\n-: expr_match\n-| expr_if\n-| expr_if_let\n-| expr_while\n-| expr_while_let\n-| expr_loop\n-| expr_for\n-| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n-;\n-\n-full_block_expr\n-: block_expr\n-| block_expr_dot\n-;\n-\n-block_expr_dot\n-: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-;\n-\n-expr_match\n-: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n-| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n-| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n-| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n-;\n-\n-match_clauses\n-: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n-| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n-;\n-\n-match_clause\n-: nonblock_match_clause ','\n-| block_match_clause\n-| block_match_clause ','\n-;\n-\n-nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n-;\n-\n-block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n-;\n-\n-maybe_guard\n-: IF expr_nostruct           { $$ = $2; }\n-| %empty                     { $$ = mk_none(); }\n-;\n-\n-expr_if\n-: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n-| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n-;\n-\n-expr_if_let\n-: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n-| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n-;\n-\n-block_or_if\n-: block\n-| expr_if\n-| expr_if_let\n-;\n-\n-expr_while\n-: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n-;\n-\n-expr_while_let\n-: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n-;\n-\n-expr_loop\n-: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n-;\n-\n-expr_for\n-: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n-;\n-\n-maybe_label\n-: lifetime ':'\n-| %empty { $$ = mk_none(); }\n-;\n-\n-let\n-: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 5: Macros and misc. rules\n-////////////////////////////////////////////////////////////////////////\n-\n-lit\n-: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n-| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n-| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n-| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n-| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| str\n-;\n-\n-str\n-: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n-| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n-| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n-| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n-;\n-\n-maybe_ident\n-: %empty { $$ = mk_none(); }\n-| ident\n-;\n-\n-ident\n-: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-// Weak keywords that can be used as identifiers\n-| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-;\n-\n-unpaired_token\n-: SHL                        { $$ = mk_atom(yytext); }\n-| SHR                        { $$ = mk_atom(yytext); }\n-| LE                         { $$ = mk_atom(yytext); }\n-| EQEQ                       { $$ = mk_atom(yytext); }\n-| NE                         { $$ = mk_atom(yytext); }\n-| GE                         { $$ = mk_atom(yytext); }\n-| ANDAND                     { $$ = mk_atom(yytext); }\n-| OROR                       { $$ = mk_atom(yytext); }\n-| LARROW                     { $$ = mk_atom(yytext); }\n-| SHLEQ                      { $$ = mk_atom(yytext); }\n-| SHREQ                      { $$ = mk_atom(yytext); }\n-| MINUSEQ                    { $$ = mk_atom(yytext); }\n-| ANDEQ                      { $$ = mk_atom(yytext); }\n-| OREQ                       { $$ = mk_atom(yytext); }\n-| PLUSEQ                     { $$ = mk_atom(yytext); }\n-| STAREQ                     { $$ = mk_atom(yytext); }\n-| SLASHEQ                    { $$ = mk_atom(yytext); }\n-| CARETEQ                    { $$ = mk_atom(yytext); }\n-| PERCENTEQ                  { $$ = mk_atom(yytext); }\n-| DOTDOT                     { $$ = mk_atom(yytext); }\n-| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n-| MOD_SEP                    { $$ = mk_atom(yytext); }\n-| RARROW                     { $$ = mk_atom(yytext); }\n-| FAT_ARROW                  { $$ = mk_atom(yytext); }\n-| LIT_BYTE                   { $$ = mk_atom(yytext); }\n-| LIT_CHAR                   { $$ = mk_atom(yytext); }\n-| LIT_INTEGER                { $$ = mk_atom(yytext); }\n-| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n-| LIT_STR                    { $$ = mk_atom(yytext); }\n-| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n-| IDENT                      { $$ = mk_atom(yytext); }\n-| UNDERSCORE                 { $$ = mk_atom(yytext); }\n-| LIFETIME                   { $$ = mk_atom(yytext); }\n-| SELF                       { $$ = mk_atom(yytext); }\n-| STATIC                     { $$ = mk_atom(yytext); }\n-| ABSTRACT                   { $$ = mk_atom(yytext); }\n-| ALIGNOF                    { $$ = mk_atom(yytext); }\n-| AS                         { $$ = mk_atom(yytext); }\n-| BECOME                     { $$ = mk_atom(yytext); }\n-| BREAK                      { $$ = mk_atom(yytext); }\n-| CATCH                      { $$ = mk_atom(yytext); }\n-| CRATE                      { $$ = mk_atom(yytext); }\n-| DEFAULT                    { $$ = mk_atom(yytext); }\n-| DO                         { $$ = mk_atom(yytext); }\n-| ELSE                       { $$ = mk_atom(yytext); }\n-| ENUM                       { $$ = mk_atom(yytext); }\n-| EXTERN                     { $$ = mk_atom(yytext); }\n-| FALSE                      { $$ = mk_atom(yytext); }\n-| FINAL                      { $$ = mk_atom(yytext); }\n-| FN                         { $$ = mk_atom(yytext); }\n-| FOR                        { $$ = mk_atom(yytext); }\n-| IF                         { $$ = mk_atom(yytext); }\n-| IMPL                       { $$ = mk_atom(yytext); }\n-| IN                         { $$ = mk_atom(yytext); }\n-| LET                        { $$ = mk_atom(yytext); }\n-| LOOP                       { $$ = mk_atom(yytext); }\n-| MACRO                      { $$ = mk_atom(yytext); }\n-| MATCH                      { $$ = mk_atom(yytext); }\n-| MOD                        { $$ = mk_atom(yytext); }\n-| MOVE                       { $$ = mk_atom(yytext); }\n-| MUT                        { $$ = mk_atom(yytext); }\n-| OFFSETOF                   { $$ = mk_atom(yytext); }\n-| OVERRIDE                   { $$ = mk_atom(yytext); }\n-| PRIV                       { $$ = mk_atom(yytext); }\n-| PUB                        { $$ = mk_atom(yytext); }\n-| PURE                       { $$ = mk_atom(yytext); }\n-| REF                        { $$ = mk_atom(yytext); }\n-| RETURN                     { $$ = mk_atom(yytext); }\n-| STRUCT                     { $$ = mk_atom(yytext); }\n-| SIZEOF                     { $$ = mk_atom(yytext); }\n-| SUPER                      { $$ = mk_atom(yytext); }\n-| TRUE                       { $$ = mk_atom(yytext); }\n-| TRAIT                      { $$ = mk_atom(yytext); }\n-| TYPE                       { $$ = mk_atom(yytext); }\n-| UNION                      { $$ = mk_atom(yytext); }\n-| UNSAFE                     { $$ = mk_atom(yytext); }\n-| UNSIZED                    { $$ = mk_atom(yytext); }\n-| USE                        { $$ = mk_atom(yytext); }\n-| VIRTUAL                    { $$ = mk_atom(yytext); }\n-| WHILE                      { $$ = mk_atom(yytext); }\n-| YIELD                      { $$ = mk_atom(yytext); }\n-| CONTINUE                   { $$ = mk_atom(yytext); }\n-| PROC                       { $$ = mk_atom(yytext); }\n-| BOX                        { $$ = mk_atom(yytext); }\n-| CONST                      { $$ = mk_atom(yytext); }\n-| WHERE                      { $$ = mk_atom(yytext); }\n-| TYPEOF                     { $$ = mk_atom(yytext); }\n-| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| SHEBANG                    { $$ = mk_atom(yytext); }\n-| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n-| ';'                        { $$ = mk_atom(yytext); }\n-| ','                        { $$ = mk_atom(yytext); }\n-| '.'                        { $$ = mk_atom(yytext); }\n-| '@'                        { $$ = mk_atom(yytext); }\n-| '#'                        { $$ = mk_atom(yytext); }\n-| '~'                        { $$ = mk_atom(yytext); }\n-| ':'                        { $$ = mk_atom(yytext); }\n-| '$'                        { $$ = mk_atom(yytext); }\n-| '='                        { $$ = mk_atom(yytext); }\n-| '?'                        { $$ = mk_atom(yytext); }\n-| '!'                        { $$ = mk_atom(yytext); }\n-| '<'                        { $$ = mk_atom(yytext); }\n-| '>'                        { $$ = mk_atom(yytext); }\n-| '-'                        { $$ = mk_atom(yytext); }\n-| '&'                        { $$ = mk_atom(yytext); }\n-| '|'                        { $$ = mk_atom(yytext); }\n-| '+'                        { $$ = mk_atom(yytext); }\n-| '*'                        { $$ = mk_atom(yytext); }\n-| '/'                        { $$ = mk_atom(yytext); }\n-| '^'                        { $$ = mk_atom(yytext); }\n-| '%'                        { $$ = mk_atom(yytext); }\n-;\n-\n-token_trees\n-: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n-| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-token_tree\n-: delimited_token_trees\n-| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n-;\n-\n-delimited_token_trees\n-: parens_delimited_token_trees\n-| braces_delimited_token_trees\n-| brackets_delimited_token_trees\n-;\n-\n-parens_delimited_token_trees\n-: '(' token_trees ')'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n-}\n-;\n-\n-braces_delimited_token_trees\n-: '{' token_trees '}'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n-}\n-;\n-\n-brackets_delimited_token_trees\n-: '[' token_trees ']'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n-}\n-;"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,64 +0,0 @@\n-Rust's lexical grammar is not context-free. Raw string literals are the source\n-of the problem. Informally, a raw string literal is an `r`, followed by `N`\n-hashes (where N can be zero), a quote, any characters, then a quote followed\n-by `N` hashes. Critically, once inside the first pair of quotes,\n-another quote cannot be followed by `N` consecutive hashes. e.g.\n-`r###\"\"###\"###` is invalid.\n-\n-This grammar describes this as best possible:\n-\n-    R -> 'r' S\n-    S -> '\"' B '\"'\n-    S -> '#' S '#'\n-    B -> . B\n-    B -> \u03b5\n-\n-Where `.` represents any character, and `\u03b5` the empty string. Consider the\n-string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n-accepted as one by the above grammar, using the derivation:\n-\n-    R : #\"\"#\"#\n-    S : \"\"#\"\n-    S : \"#\n-    B : #\n-    B : \u03b5\n-\n-(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n-string.) The difficulty arises from the fact that it is fundamentally\n-context-sensitive. In particular, the context needed is the number of hashes.\n-\n-To prove that Rust's string literals are not context-free, we will use\n-the fact that context-free languages are closed under intersection with\n-regular languages, and the\n-[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n-\n-Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n-context-free, then their intersection with `R`, `R'`, should also be context-free.\n-Therefore, to prove that raw string literals are not context-free,\n-it is sufficient to prove that `R'` is not context-free.\n-\n-The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n-\n-Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n-the pumping lemma applies. Consider the following string `s` in `R'`:\n-\n-`r#^p\"\"#^{p-1}\"#^p`\n-\n-e.g. for `p = 2`: `s = r##\"\"#\"##`\n-\n-Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n-`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n-\n-Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n-in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n-Consequently, of the three sequences of hashes, `v` and `x` combined\n-can only pump two of them.\n-If we ever choose the central sequence of hashes, then one of the outer sequences\n-will not grow when we pump, leading to an imbalance between the outer sequences.\n-Therefore, we must pump both outer sequences of hashes. However,\n-there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n-be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n-context-free.\n-\n-Since `R'` is not context-free, it follows that the Rust's raw string literals\n-must not be context-free."}, {"sha": "4b5a7fb9e10b5c4ce4f6d6f52932787194713d5d", "filename": "src/grammar/testparser.py", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,66 +0,0 @@\n-#!/usr/bin/env python\n-\n-# ignore-tidy-linelength\n-\n-import sys\n-\n-import os\n-import subprocess\n-import argparse\n-\n-# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n-\n-# Parsers should read from stdin and return exit status 0 for a\n-# successful parse, and nonzero for an unsuccessful parse\n-\n-parser = argparse.ArgumentParser()\n-parser.add_argument('-p', '--parser', nargs='+')\n-parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n-args = parser.parse_args(sys.argv[1:])\n-\n-total = 0\n-ok = {}\n-bad = {}\n-for parser in args.parser:\n-    ok[parser] = 0\n-    bad[parser] = []\n-devnull = open(os.devnull, 'w')\n-print(\"\\n\")\n-\n-for base, dirs, files in os.walk(args.source_dir[0]):\n-    for f in filter(lambda p: p.endswith('.rs'), files):\n-        p = os.path.join(base, f)\n-        parse_fail = 'parse-fail' in p\n-        if sys.version_info.major == 3:\n-            lines = open(p, encoding='utf-8').readlines()\n-        else:\n-            lines = open(p).readlines()\n-        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n-            continue\n-        total += 1\n-        for parser in args.parser:\n-            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n-                if parse_fail:\n-                    bad[parser].append(p)\n-                else:\n-                    ok[parser] += 1\n-            else:\n-                if parse_fail:\n-                    ok[parser] += 1\n-                else:\n-                    bad[parser].append(p)\n-        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n-        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n-                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n-\n-devnull.close()\n-\n-print(\"\\n\")\n-\n-for parser in args.parser:\n-    filename = os.path.basename(parser) + '.bad'\n-    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n-    with open(filename, \"w\") as f:\n-        for p in bad[parser]:\n-            f.write(p)\n-            f.write(\"\\n\")"}, {"sha": "297e3dc841e871502e2270c95fdf6565806f0f5a", "filename": "src/grammar/tokens.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/8990f7d627525db934831cc29d5805172d80e156/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=8990f7d627525db934831cc29d5805172d80e156", "patch": "@@ -1,99 +0,0 @@\n-enum Token {\n-  SHL = 257, // Parser generators reserve 0-256 for char literals\n-  SHR,\n-  LE,\n-  EQEQ,\n-  NE,\n-  GE,\n-  ANDAND,\n-  OROR,\n-  SHLEQ,\n-  SHREQ,\n-  MINUSEQ,\n-  ANDEQ,\n-  OREQ,\n-  PLUSEQ,\n-  STAREQ,\n-  SLASHEQ,\n-  CARETEQ,\n-  PERCENTEQ,\n-  DOTDOT,\n-  DOTDOTDOT,\n-  MOD_SEP,\n-  LARROW,\n-  RARROW,\n-  FAT_ARROW,\n-  LIT_BYTE,\n-  LIT_CHAR,\n-  LIT_INTEGER,\n-  LIT_FLOAT,\n-  LIT_STR,\n-  LIT_STR_RAW,\n-  LIT_BYTE_STR,\n-  LIT_BYTE_STR_RAW,\n-  IDENT,\n-  UNDERSCORE,\n-  LIFETIME,\n-\n-  // keywords\n-  SELF,\n-  STATIC,\n-  ABSTRACT,\n-  ALIGNOF,\n-  AS,\n-  BECOME,\n-  BREAK,\n-  CATCH,\n-  CRATE,\n-  DEFAULT,\n-  DO,\n-  ELSE,\n-  ENUM,\n-  EXTERN,\n-  FALSE,\n-  FINAL,\n-  FN,\n-  FOR,\n-  IF,\n-  IMPL,\n-  IN,\n-  LET,\n-  LOOP,\n-  MACRO,\n-  MATCH,\n-  MOD,\n-  MOVE,\n-  MUT,\n-  OFFSETOF,\n-  OVERRIDE,\n-  PRIV,\n-  PUB,\n-  PURE,\n-  REF,\n-  RETURN,\n-  SIZEOF,\n-  STRUCT,\n-  SUPER,\n-  UNION,\n-  TRUE,\n-  TRAIT,\n-  TYPE,\n-  UNSAFE,\n-  UNSIZED,\n-  USE,\n-  VIRTUAL,\n-  WHILE,\n-  YIELD,\n-  CONTINUE,\n-  PROC,\n-  BOX,\n-  CONST,\n-  WHERE,\n-  TYPEOF,\n-  INNER_DOC_COMMENT,\n-  OUTER_DOC_COMMENT,\n-\n-  SHEBANG,\n-  SHEBANG_LINE,\n-  STATIC_LIFETIME\n-};"}, {"sha": "d2bdda83fa998ae4e8e195d955627c7c88887fba", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -207,6 +207,47 @@ impl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {\n }\n \n impl<B: ?Sized + ToOwned> Cow<'_, B> {\n+    /// Returns true if the data is borrowed, i.e. if `to_mut` would require additional work.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow = Cow::Borrowed(\"moo\");\n+    /// assert!(cow.is_borrowed());\n+    ///\n+    /// let bull: Cow<'_, str> = Cow::Owned(\"...moo?\".to_string());\n+    /// assert!(!bull.is_borrowed());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            Owned(_) => false,\n+        }\n+    }\n+\n+    /// Returns true if the data is owned, i.e. if `to_mut` would be a no-op.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cow_is_borrowed)]\n+    /// use std::borrow::Cow;\n+    ///\n+    /// let cow: Cow<'_, str> = Cow::Owned(\"moo\".to_string());\n+    /// assert!(cow.is_owned());\n+    ///\n+    /// let bull = Cow::Borrowed(\"...moo?\");\n+    /// assert!(!bull.is_owned());\n+    /// ```\n+    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n+    pub fn is_owned(&self) -> bool {\n+        !self.is_borrowed()\n+    }\n+\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned."}, {"sha": "567b8ea722491edbe2c9bfe9218b1632038dbc92", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -29,10 +29,8 @@\n //!     Nil,\n //! }\n //!\n-//! fn main() {\n-//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n-//!     println!(\"{:?}\", list);\n-//! }\n+//! let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//! println!(\"{:?}\", list);\n //! ```\n //!\n //! This will print `Cons(1, Cons(2, Nil))`.\n@@ -144,6 +142,9 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        if layout.size() == 0 {\n+            return Box(NonNull::dangling().into())\n+        }\n         let ptr = unsafe {\n             Global.alloc(layout)\n                 .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n@@ -184,9 +185,16 @@ impl<T> Box<[T]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = unsafe { alloc::alloc(layout) };\n-        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n-        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        let ptr = if layout.size() == 0 {\n+            NonNull::dangling()\n+        } else {\n+            unsafe {\n+                Global.alloc(layout)\n+                    .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+                    .cast()\n+            }\n+        };\n+        let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n         Box(Unique::from(slice))\n     }\n }\n@@ -375,14 +383,12 @@ impl<T: ?Sized> Box<T> {\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n     ///\n-    /// fn main() {\n-    ///     let x = Box::new(5);\n-    ///     let ptr = Box::into_raw_non_null(x);\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw_non_null(x);\n     ///\n-    ///     // Clean up the memory by converting the NonNull pointer back\n-    ///     // into a Box and letting the Box be dropped.\n-    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n-    /// }\n+    /// // Clean up the memory by converting the NonNull pointer back\n+    /// // into a Box and letting the Box be dropped.\n+    /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -428,23 +434,19 @@ impl<T: ?Sized> Box<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = Box::new(41);\n-    ///     let static_ref: &'static mut usize = Box::leak(x);\n-    ///     *static_ref += 1;\n-    ///     assert_eq!(*static_ref, 42);\n-    /// }\n+    /// let x = Box::new(41);\n+    /// let static_ref: &'static mut usize = Box::leak(x);\n+    /// *static_ref += 1;\n+    /// assert_eq!(*static_ref, 42);\n     /// ```\n     ///\n     /// Unsized data:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3].into_boxed_slice();\n-    ///     let static_ref = Box::leak(x);\n-    ///     static_ref[0] = 4;\n-    ///     assert_eq!(*static_ref, [4, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3].into_boxed_slice();\n+    /// let static_ref = Box::leak(x);\n+    /// static_ref[0] = 4;\n+    /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n@@ -780,11 +782,9 @@ impl Box<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n         if self.is::<T>() {\n@@ -814,11 +814,9 @@ impl Box<dyn Any + Send> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n         <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {\n@@ -883,11 +881,33 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n         (**self).nth(n)\n     }\n+    fn last(self) -> Option<I::Item> {\n+        BoxIter::last(self)\n+    }\n+}\n+\n+trait BoxIter {\n+    type Item;\n+    fn last(self) -> Option<Self::Item>;\n+}\n+\n+impl<I: Iterator + ?Sized> BoxIter for Box<I> {\n+    type Item = I::Item;\n+    default fn last(self) -> Option<I::Item> {\n+        #[inline]\n+        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n+            Some(x)\n+        }\n+\n+        self.fold(None, some)\n+    }\n }\n \n+/// Specialization for sized `I`s that uses `I`s implementation of `last()`\n+/// instead of the default.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator + Sized> Iterator for Box<I> {\n-    fn last(self) -> Option<I::Item> where I: Sized {\n+impl<I: Iterator> BoxIter for Box<I> {\n+    fn last(self) -> Option<I::Item> {\n         (*self).last()\n     }\n }"}, {"sha": "fda6f090fd7795c4a19d831e29f1a6723ea2847f", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -146,7 +146,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::ops::{Deref, DerefMut};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem::{swap, size_of, ManuallyDrop};\n use core::ptr;\n use core::fmt;\n@@ -648,6 +648,36 @@ impl<T: Ord> BinaryHeap<T> {\n             self.extend(other.drain());\n         }\n     }\n+\n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// The retrieved elements are removed from the original heap.\n+    /// The remaining elements will be removed on drop in heap order.\n+    ///\n+    /// Note:\n+    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    ///   You should use the latter for most cases.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_drain_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(heap.len(), 5);\n+    ///\n+    /// drop(heap.drain_sorted()); // removes all elements in heap order\n+    /// assert_eq!(heap.len(), 0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+    pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n+        DrainSorted {\n+            inner: self,\n+        }\n+    }\n }\n \n impl<T> BinaryHeap<T> {\n@@ -672,6 +702,27 @@ impl<T> BinaryHeap<T> {\n         Iter { iter: self.data.iter() }\n     }\n \n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// This method consumes the original heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_into_iter_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n+    /// ```\n+    #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+    pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n+        IntoIterSorted {\n+            inner: self,\n+        }\n+    }\n+\n     /// Returns the greatest item in the binary heap, or `None` if it is empty.\n     ///\n     /// # Examples\n@@ -1115,6 +1166,37 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+#[derive(Clone, Debug)]\n+pub struct IntoIterSorted<T> {\n+    inner: BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for IntoIterSorted<T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for IntoIterSorted<T> {}\n+\n /// A draining iterator over the elements of a `BinaryHeap`.\n ///\n /// This `struct` is created by the [`drain`] method on [`BinaryHeap`]. See its\n@@ -1161,6 +1243,52 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Drain<'_, T> {}\n \n+/// A draining iterator over the elements of a `BinaryHeap`.\n+///\n+/// This `struct` is created by the [`drain_sorted`] method on [`BinaryHeap`]. See its\n+/// documentation for more.\n+///\n+/// [`drain_sorted`]: struct.BinaryHeap.html#method.drain_sorted\n+/// [`BinaryHeap`]: struct.BinaryHeap.html\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+#[derive(Debug)]\n+pub struct DrainSorted<'a, T: Ord> {\n+    inner: &'a mut BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n+    /// Removes heap elements in heap order.\n+    fn drop(&mut self) {\n+        while let Some(_) = self.inner.pop() {}\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for DrainSorted<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for DrainSorted<'_, T> { }\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for DrainSorted<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for DrainSorted<'_, T> {}\n+\n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     /// Converts a `Vec<T>` into a `BinaryHeap<T>`."}, {"sha": "83fd4485f7321dbc6e15693d78fa8ac04f7e4ff8", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2226,14 +2226,12 @@ impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # fn main() {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n     /// map.entry(\"poneyland\").or_default();\n     ///\n     /// assert_eq!(map[\"poneyland\"], None);\n-    /// # }\n     /// ```\n     pub fn or_default(self) -> &'a mut V {\n         match self {"}, {"sha": "f0796354e00c384076f8a47a59f62b849556cd1e", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 239, "deletions": 160, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2,7 +2,7 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{self, Less, Greater, Equal};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n@@ -109,6 +109,77 @@ pub struct Range<'a, T: 'a> {\n     iter: btree_map::Range<'a, T, ()>,\n }\n \n+/// Core of SymmetricDifference and Union.\n+/// More efficient than btree.map.MergeIter,\n+/// and crucially for SymmetricDifference, nexts() reports on both sides.\n+#[derive(Clone)]\n+struct MergeIterInner<I>\n+    where I: Iterator,\n+          I::Item: Copy,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<MergeIterPeeked<I>>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum MergeIterPeeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> MergeIterInner<I>\n+    where I: ExactSizeIterator + FusedIterator,\n+          I::Item: Copy + Ord,\n+{\n+    fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next = match self.peeked {\n+            Some(MergeIterPeeked::A(next)) => Some(next),\n+            _ => self.a.next(),\n+        };\n+        let mut b_next = match self.peeked {\n+            Some(MergeIterPeeked::B(next)) => Some(next),\n+            _ => self.b.next(),\n+        };\n+        let ord = match (a_next, b_next) {\n+            (None, None) => Equal,\n+            (_, None) => Less,\n+            (None, _) => Greater,\n+            (Some(a1), Some(b1)) => a1.cmp(&b1),\n+        };\n+        self.peeked = match ord {\n+            Less => b_next.take().map(MergeIterPeeked::B),\n+            Equal => None,\n+            Greater => a_next.take().map(MergeIterPeeked::A),\n+        };\n+        (a_next, b_next)\n+    }\n+\n+    fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+    where I: Iterator + Debug,\n+          I::Item: Copy + Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\")\n+            .field(&self.a)\n+            .field(&self.b)\n+            .finish()\n+    }\n+}\n+\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -120,34 +191,25 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n }\n+#[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n+        // iterate all of self and some of other, spotting matches along the way\n         self_iter: Iter<'a, T>,\n         other_iter: Peekable<Iter<'a, T>>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         self_iter: Iter<'a, T>,\n         other_set: &'a BTreeSet<T>,\n     },\n+    Iterate(Iter<'a, T>), // simply stream self's elements\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => f\n-                .debug_tuple(\"Difference\")\n-                .field(&self_iter)\n-                .field(&other_iter)\n-                .finish(),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set: _,\n-            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n-        }\n+        f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n }\n \n@@ -159,18 +221,12 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"SymmetricDifference\").field(&self.0).finish()\n     }\n }\n \n@@ -185,34 +241,25 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n }\n+#[derive(Debug)]\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n+        // iterate similarly sized sets jointly, spotting matches along the way\n         a: Iter<'a, T>,\n         b: Iter<'a, T>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         small_iter: Iter<'a, T>,\n         large_set: &'a BTreeSet<T>,\n     },\n+    Answer(Option<&'a T>), // return a specific value or emptiness\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => f\n-                .debug_tuple(\"Intersection\")\n-                .field(&a)\n-                .field(&b)\n-                .finish(),\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set: _,\n-            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n-        }\n+        f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n }\n \n@@ -224,18 +271,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Union\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"Union\").field(&self.0).finish()\n     }\n }\n \n@@ -314,24 +355,48 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is bigger than or not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Difference {\n-                inner: DifferenceInner::Stitch {\n-                    self_iter: self.iter(),\n-                    other_iter: other.iter().peekable(),\n-                },\n-            }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n+        } else {\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n         } else {\n-            // Self is much smaller than other set, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Difference {\n-                inner: DifferenceInner::Search {\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        Difference {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),\n+                (Equal, _) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                (_, Equal) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next_back();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    DifferenceInner::Search {\n+                        self_iter: self.iter(),\n+                        other_set: other,\n+                    }\n+                }\n+                _ => DifferenceInner::Stitch {\n                     self_iter: self.iter(),\n-                    other_set: other,\n+                    other_iter: other.iter().peekable(),\n                 },\n-            }\n+            },\n         }\n     }\n \n@@ -359,10 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn symmetric_difference<'a>(&'a self,\n                                     other: &'a BTreeSet<T>)\n                                     -> SymmetricDifference<'a, T> {\n-        SymmetricDifference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Visits the values representing the intersection,\n@@ -387,29 +449,46 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        let (small, other) = if self.len() <= other.len() {\n-            (self, other)\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n         } else {\n-            (other, self)\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n         };\n-        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Small set is not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Intersection {\n-                inner: IntersectionInner::Stitch {\n-                    a: small.iter(),\n-                    b: other.iter(),\n-                },\n-            }\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Intersection {\n-                inner: IntersectionInner::Search {\n-                    small_iter: small.iter(),\n-                    large_set: other,\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n+        };\n+        Intersection {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n+                (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n+                (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: self.iter(),\n+                        large_set: other,\n+                    }\n+                }\n+                _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: other.iter(),\n+                        large_set: self,\n+                    }\n+                }\n+                _ => IntersectionInner::Stitch {\n+                    a: self.iter(),\n+                    b: other.iter(),\n                 },\n-            }\n+            },\n         }\n     }\n \n@@ -433,10 +512,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Clears the set, removing all values.\n@@ -544,43 +620,61 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Same result as self.difference(other).next().is_none()\n-        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n-            false\n-        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is not much smaller than other set.\n-            // Stolen from TreeMap\n-            let mut x = self.iter();\n-            let mut y = other.iter();\n-            let mut a = x.next();\n-            let mut b = y.next();\n-            while a.is_some() {\n-                if b.is_none() {\n+            return false;\n+        }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n+        } else {\n+            return true; // self is empty\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n+        } else {\n+            return false; // other is empty\n+        };\n+        let mut self_iter = self.iter();\n+        match self_min.cmp(other_min) {\n+            Less => return false,\n+            Equal => {\n+                self_iter.next();\n+            }\n+            Greater => (),\n+        }\n+        match self_max.cmp(other_max) {\n+            Greater => return false,\n+            Equal => {\n+                self_iter.next_back();\n+            }\n+            Less => (),\n+        }\n+        if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Big difference in number of elements.\n+            for next in self_iter {\n+                if !other.contains(next) {\n                     return false;\n                 }\n-\n-                let a1 = a.unwrap();\n-                let b1 = b.unwrap();\n-\n-                match b1.cmp(a1) {\n-                    Less => (),\n-                    Greater => return false,\n-                    Equal => a = x.next(),\n-                }\n-\n-                b = y.next();\n             }\n-            true\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            for next in self {\n-                if !other.contains(next) {\n-                    return false;\n+            // Self is not much smaller than other set.\n+            let mut other_iter = other.iter();\n+            other_iter.next();\n+            other_iter.next_back();\n+            let mut self_next = self_iter.next();\n+            while let Some(self1) = self_next {\n+                match other_iter.next().map_or(Less, |other1| self1.cmp(other1)) {\n+                    Less => return false,\n+                    Equal => self_next = self_iter.next(),\n+                    Greater => (),\n                 }\n             }\n-            true\n         }\n+        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -1092,15 +1186,6 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None, _) => short,\n-        (_, None) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n@@ -1120,6 +1205,7 @@ impl<T> Clone for Difference<'_, T> {\n                     self_iter: self_iter.clone(),\n                     other_set,\n                 },\n+                DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),\n             },\n         }\n     }\n@@ -1138,7 +1224,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                 loop {\n                     match other_iter\n                         .peek()\n-                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                        .map_or(Less, |other_next| self_next.cmp(other_next))\n                     {\n                         Less => return Some(self_next),\n                         Equal => {\n@@ -1160,19 +1246,21 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                     return Some(self_next);\n                 }\n             },\n+            DifferenceInner::Iterate(iter) => iter.next(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (self_len, other_len) = match &self.inner {\n             DifferenceInner::Stitch {\n                 self_iter,\n-                other_iter\n+                other_iter,\n             } => (self_iter.len(), other_iter.len()),\n             DifferenceInner::Search {\n                 self_iter,\n-                other_set\n+                other_set,\n             } => (self_iter.len(), other_set.len()),\n+            DifferenceInner::Iterate(iter) => (iter.len(), 0),\n         };\n         (self_len.saturating_sub(other_len), Some(self_len))\n     }\n@@ -1184,10 +1272,7 @@ impl<T: Ord> FusedIterator for Difference<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n     fn clone(&self) -> Self {\n-        SymmetricDifference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        SymmetricDifference(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1196,19 +1281,19 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => return self.b.next(),\n+            let (a_next, b_next) = self.0.nexts();\n+            if a_next.and(b_next).is_none() {\n+                return a_next.or(b_next);\n             }\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.a.len() + self.b.len()))\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add, because even if a and b refer to the same set,\n+        // and T is an empty type, the storage overhead of sets limits\n+        // the number of elements to less than half the range of usize.\n+        (0, Some(a_len + b_len))\n     }\n }\n \n@@ -1234,6 +1319,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n     }\n@@ -1251,7 +1337,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                 let mut a_next = a.next()?;\n                 let mut b_next = b.next()?;\n                 loop {\n-                    match Ord::cmp(a_next, b_next) {\n+                    match a_next.cmp(b_next) {\n                         Less => a_next = a.next()?,\n                         Greater => b_next = b.next()?,\n                         Equal => return Some(a_next),\n@@ -1267,15 +1353,17 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                     return Some(small_next);\n                 }\n             },\n+            IntersectionInner::Answer(answer) => answer.take(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let min_len = match &self.inner {\n-            IntersectionInner::Stitch { a, b } => min(a.len(), b.len()),\n-            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n-        };\n-        (0, Some(min_len))\n+        match &self.inner {\n+            IntersectionInner::Stitch { a, b } => (0, Some(min(a.len(), b.len()))),\n+            IntersectionInner::Search { small_iter, .. } => (0, Some(small_iter.len())),\n+            IntersectionInner::Answer(None) => (0, Some(0)),\n+            IntersectionInner::Answer(Some(_)) => (1, Some(1)),\n+        }\n     }\n }\n \n@@ -1285,30 +1373,21 @@ impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {\n     fn clone(&self) -> Self {\n-        Union {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        Union(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-            Less => self.a.next(),\n-            Equal => {\n-                self.b.next();\n-                self.a.next()\n-            }\n-            Greater => self.b.next(),\n-        }\n+        let (a_next, b_next) = self.0.nexts();\n+        a_next.or(b_next)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n }"}, {"sha": "702df250999fbed23ebee3dd16ac53f5485719f6", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1197,6 +1197,19 @@ impl<T: Clone> Clone for LinkedList<T> {\n     fn clone(&self) -> Self {\n         self.iter().cloned().collect()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        let mut iter_other = other.iter();\n+        if self.len() > other.len() {\n+            self.split_off(other.len());\n+        }\n+        for (elem, elem_other) in self.iter_mut().zip(&mut iter_other) {\n+            elem.clone_from(elem_other);\n+        }\n+        if !iter_other.is_empty() {\n+            self.extend(iter_other.cloned());\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1001f6bba3b823573c7c15d378875b9fa222b0db", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -110,6 +110,49 @@ fn test_append() {\n     check_links(&n);\n }\n \n+#[test]\n+fn test_clone_from() {\n+    // Short cloned from long\n+    {\n+        let v = vec![1, 2, 3, 4, 5];\n+        let u = vec![8, 7, 6, 2, 3, 4, 5];\n+        let mut m = list_from(&v);\n+        let n = list_from(&u);\n+        m.clone_from(&n);\n+        check_links(&m);\n+        assert_eq!(m, n);\n+        for elt in u {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+    }\n+    // Long cloned from short\n+    {\n+        let v = vec![1, 2, 3, 4, 5];\n+        let u = vec![6, 7, 8];\n+        let mut m = list_from(&v);\n+        let n = list_from(&u);\n+        m.clone_from(&n);\n+        check_links(&m);\n+        assert_eq!(m, n);\n+        for elt in u {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+    }\n+    // Two equal length lists\n+    {\n+        let v = vec![1, 2, 3, 4, 5];\n+        let u = vec![9, 8, 1, 2, 3];\n+        let mut m = list_from(&v);\n+        let n = list_from(&u);\n+        m.clone_from(&n);\n+        check_links(&m);\n+        assert_eq!(m, n);\n+        for elt in u {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n+    }\n+}\n+\n #[test]\n fn test_insert_prev() {\n     let mut m = list_from(&[0, 2, 4, 6, 8]);"}, {"sha": "8f3dfabd8886d6286ae8949ddfd8bf1c1e00ffe9", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 100, "deletions": 3, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -10,8 +10,8 @@\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n-use core::mem;\n+use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n+use core::mem::{self, replace};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -57,11 +57,88 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// ([2], [c])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+struct PairSlices<'a, 'b, T> {\n+    a0: &'a mut [T],\n+    a1: &'a mut [T],\n+    b0: &'b [T],\n+    b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    fn remainder(self) -> impl Iterator<Item=&'b [T]> {\n+        once(self.b0).chain(once(self.b1))\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T>\n+{\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.truncate(other.len());\n+\n+        let mut iter = PairSlices::from(self, other);\n+        while let Some((dst, src)) = iter.next() {\n+            dst.clone_from_slice(&src);\n+        }\n+\n+        if iter.has_remainder() {\n+            for remainder in iter.remainder() {\n+                self.extend(remainder.iter().cloned());\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1740,7 +1817,7 @@ impl<T> VecDeque<T> {\n             }\n         }\n \n-        return elem;\n+        elem\n     }\n \n     /// Splits the `VecDeque` into two at the given index.\n@@ -2209,6 +2286,16 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         final_res\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n@@ -2327,6 +2414,16 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         back.iter_mut().fold(accum, &mut f)\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a mut T> {\n         self.next_back()"}, {"sha": "d578ee0dac493fa922bd7d6d72f7c36f8d3184f8", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -361,6 +361,29 @@ fn test_vec_from_vecdeque() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let m = vec![1; 8];\n+    let n = vec![2; 12];\n+    for pfv in 0..8 {\n+        for pfu in 0..8 {\n+            for longer in 0..2 {\n+                let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n+                let mut v = VecDeque::from(vr.clone());\n+                for _ in 0..pfv {\n+                    v.push_front(1);\n+                }\n+                let mut u = VecDeque::from(ur.clone());\n+                for _ in 0..pfu {\n+                    u.push_front(2);\n+                }\n+                v.clone_from(&u);\n+                assert_eq!(&v, &u);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn issue_53529() {\n     use crate::boxed::Box;"}, {"sha": "cbfc55233a1e0e3902444dd66e3bd182cec11c17", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 198, "deletions": 191, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -80,24 +80,210 @@\n //! arguments which have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n-//! ## Argument types\n+//! # Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted.\n+//!\n+//! ## Width\n+//!\n+//! ```\n+//! // All of these print \"Hello x    !\"\n+//! println!(\"Hello {:5}!\", \"x\");\n+//! println!(\"Hello {:1$}!\", \"x\", 5);\n+//! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n+//! ```\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space (see below).\n+//!\n+//! The value for the width can also be provided as a [`usize`] in the list of\n+//! parameters by adding a postfix `$`, indicating that the second argument is\n+//! a [`usize`] specifying the width.\n+//!\n+//! Referring to an argument with the dollar syntax does not affect the \"next\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n+//!\n+//! ## Fill/Alignment\n+//!\n+//! ```\n+//! assert_eq!(format!(\"Hello {:<5}!\", \"x\"),  \"Hello x    !\");\n+//! assert_eq!(format!(\"Hello {:-<5}!\", \"x\"), \"Hello x----!\");\n+//! assert_eq!(format!(\"Hello {:^5}!\", \"x\"),  \"Hello   x  !\");\n+//! assert_eq!(format!(\"Hello {:>5}!\", \"x\"),  \"Hello     x!\");\n+//! ```\n+//!\n+//! The optional fill character and alignment is provided normally in conjunction with the\n+//! [`width`](#width) parameter. It must be defined before `width`, right after the `:`.\n+//! This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it.\n+//! Filling comes in the following variants for different alignments:\n+//!\n+//! * `[fill]<` - the argument is left-aligned in `width` columns\n+//! * `[fill]^` - the argument is center-aligned in `width` columns\n+//! * `[fill]>` - the argument is right-aligned in `width` columns\n+//!\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the `0` flag (see below) is specified for numerics, then the implicit fill character is\n+//! `0`.\n+//!\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then pad this resulting string\n+//! to obtain your output:\n+//!\n+//! ```\n+//! println!(\"Hello {:^15}!\", format!(\"{:?}\", Some(\"hi\"))); // => \"Hello   Some(\"hi\")   !\"\n+//! ```\n+//!\n+//! ## Sign/`#`/`0`\n+//!\n+//! ```\n+//! assert_eq!(format!(\"Hello {:+}!\", 5), \"Hello +5!\");\n+//! assert_eq!(format!(\"{:#x}!\", 27), \"0x1b!\");\n+//! assert_eq!(format!(\"Hello {:05}!\", 5),  \"Hello 00005!\");\n+//! assert_eq!(format!(\"Hello {:05}!\", -5), \"Hello -0005!\");\n+//! assert_eq!(format!(\"{:#010x}!\", 27), \"0x0000001b!\");\n+//! ```\n+//!\n+//! These are all flags altering the behavior of the formatter.\n+//!\n+//! * `+` - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n+//!         should always be printed.\n+//! * `-` - Currently not used\n+//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n+//!     * `#x` - precedes the argument with a `0x`\n+//!     * `#X` - precedes the argument with a `0x`\n+//!     * `#b` - precedes the argument with a `0b`\n+//!     * `#o` - precedes the argument with a `0o`\n+//! * `0` - This is used to indicate for integer formats that the padding to `width` should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits. The prefix is included in the total width.\n+//!\n+//! ## Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n+//!\n+//! For integral types, this is ignored.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer or name followed by dollar sign `.N$`:\n+//!\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! 3. An asterisk `.*`:\n+//!\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n+//!\n+//! ```\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+//! ```\n //!\n-//! Each argument's type is dictated by the format string.\n-//! There are various parameters which require a particular type, however.\n-//! An example is the `{:.*}` syntax, which sets the number of decimal places\n-//! in floating-point types:\n+//! While these:\n //!\n //! ```\n-//! let formatted_number = format!(\"{:.*}\", 2, 1.234567);\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n //!\n-//! assert_eq!(\"1.23\", formatted_number)\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n-//! If this syntax is used, then the number of characters to print precedes the\n-//! actual object being formatted, and the number of characters must have the\n-//! type [`usize`].\n+//! # Escaping\n+//!\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n //!\n-//! ## Formatting traits\n+//! ```\n+//! assert_eq!(format!(\"Hello {{}}\"), \"Hello {}\");\n+//! assert_eq!(format!(\"{{ Hello\"), \"{ Hello\");\n+//! ```\n+//!\n+//! # Syntax\n+//!\n+//! To summarize, here you can find the full grammar of format strings.\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with Python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ maybe-format <text> ] *\n+//! maybe-format := '{' '{' | '}' '}' | <format>\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | '?' | ''\n+//! count := parameter | integer\n+//! parameter := argument '$'\n+//! ```\n+//!\n+//! # Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -220,7 +406,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ## Related macros\n+//! # Related macros\n //!\n //! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n@@ -300,185 +486,6 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! # Syntax\n-//!\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with Python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ maybe-format <text> ] *\n-//! maybe-format := '{' '{' | '}' '}' | <format>\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | '?' | ''\n-//! count := parameter | integer\n-//! parameter := argument '$'\n-//! ```\n-//!\n-//! # Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted.\n-//!\n-//! ## Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the\n-//! [`width`](#width)\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of the\n-//! following options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! Note that alignment may not be implemented by some types. In particular, it\n-//! is not generally implemented for the `Debug` trait.  A good way to ensure\n-//! padding is applied is to format your input, then use this resulting string\n-//! to pad your output.\n-//!\n-//! ## Sign/`#`/`0`\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * `+` - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n-//!         should always be printed.\n-//! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the [`Debug`] formatting\n-//!     * `#x` - precedes the argument with a `0x`\n-//!     * `#X` - precedes the argument with a `0x`\n-//!     * `#b` - precedes the argument with a `0b`\n-//!     * `#o` - precedes the argument with a `0o`\n-//! * `0` - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n-//!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n-//!         the digits.\n-//!\n-//! ## Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n-//! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the `0` flag is specified for numerics, then the implicit fill character is\n-//! `0`.\n-//!\n-//! The value for the width can also be provided as a [`usize`] in the list of\n-//! parameters by using the dollar syntax indicating that the second argument is\n-//! a [`usize`] specifying the width, for example:\n-//!\n-//! ```\n-//! // All of these print \"Hello x    !\"\n-//! println!(\"Hello {:5}!\", \"x\");\n-//! println!(\"Hello {:1$}!\", \"x\", 5);\n-//! println!(\"Hello {1:0$}!\", 5, \"x\");\n-//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n-//! ```\n-//!\n-//! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to arguments by\n-//! position, or use named arguments.\n-//!\n-//! ## Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and that truncated\n-//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n-//!\n-//! For integral types, this is ignored.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal point should be\n-//! printed.\n-//!\n-//! There are three possible ways to specify the desired `precision`:\n-//!\n-//! 1. An integer `.N`:\n-//!\n-//!    the integer `N` itself is the precision.\n-//!\n-//! 2. An integer or name followed by dollar sign `.N$`:\n-//!\n-//!    use format *argument* `N` (which must be a `usize`) as the precision.\n-//!\n-//! 3. An asterisk `.*`:\n-//!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n-//!\n-//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n-//!\n-//! ```\n-//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n-//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n-//!\n-//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n-//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n-//!\n-//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n-//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n-//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n-//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n-//! //                          in arg \"prec\" (5)}\n-//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n-//! ```\n-//!\n-//! While these:\n-//!\n-//! ```\n-//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n-//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n-//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n-//! ```\n-//!\n-//! print two significantly different things:\n-//!\n-//! ```text\n-//! Hello, `1234.560` has 3 fractional digits\n-//! Hello, `123` has 3 characters\n-//! Hello, `     123` has 3 right-aligned characters\n-//! ```\n-//!\n-//! # Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-//!\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}, {"sha": "94379afc2bd454e1071243647cbd7b77c790f279", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n+#![feature(cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(container_error_extra)]\n@@ -121,7 +122,6 @@\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n \n // Allow testing this library\n@@ -154,7 +154,7 @@ mod boxed {\n #[cfg(test)]\n mod tests;\n pub mod collections;\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "f1c4c32e116ea74dcc59bec6eb349841517662b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 76, "deletions": 65, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -3,8 +3,9 @@\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n-//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n-//! given value is destroyed, the pointed-to value is also destroyed.\n+//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n+//! given allocation is destroyed, the value stored in that allocation (often\n+//! referred to as \"inner value\") is also dropped.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,8 +22,10 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the value has\n-//! already been dropped.\n+//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n+//! already been dropped. In other words, `Weak` pointers do not keep the value\n+//! inside the allocation alive; however, they *do* keep the allocation\n+//! (the backing store for the inner value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -41,13 +44,13 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n-//! already been destroyed.\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n+//! already been dropped.\n //!\n //! # Cloning references\n //!\n-//! Creating a new reference from an existing reference counted pointer is done using the\n-//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//! Creating a new reference to the same allocation as an existing reference counted pointer\n+//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -93,7 +96,7 @@\n //!     );\n //!\n //!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n-//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n@@ -110,8 +113,8 @@\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n //!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n-//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n+//!     // live. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -124,9 +127,9 @@\n //!\n //! If our requirements change, and we also need to be able to traverse from\n //! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n-//! to `Gadget` introduces a cycle between the values. This means that their\n-//! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n+//! to `Gadget` introduces a cycle. This means that their\n+//! reference counts can never reach 0, and the allocation will never be destroyed:\n+//! a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n@@ -193,10 +196,10 @@\n //!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n-//!         // guarantee the value is still allocated, we need to call\n+//!         // guarantee the allocation still exists, we need to call\n //!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n //!         //\n-//!         // In this case we know the value still exists, so we simply\n+//!         // In this case we know the allocation still exists, so we simply\n //!         // `unwrap` the `Option`. In a more complicated program, you might\n //!         // need graceful error handling for a `None` result.\n //!\n@@ -365,7 +368,7 @@ impl<T> Rc<T> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n-    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n     /// passed in.\n@@ -446,7 +449,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -485,7 +488,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -604,7 +607,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -625,7 +628,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -645,7 +648,7 @@ impl<T: ?Sized> Rc<T> {\n         this.weak() - 1\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -664,22 +667,22 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n-    /// this inner value.\n+    /// this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Rc`, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -710,7 +713,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Rc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -719,7 +722,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Rc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Rc::new`.\n@@ -745,8 +748,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Rc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -760,6 +763,8 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -768,12 +773,12 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n-    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// If there are other `Rc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be dissassociated.\n+    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n+    /// pointers to this allocation will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -794,12 +799,12 @@ impl<T: Clone> Rc<T> {\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n     ///\n-    /// [`Weak`] pointers will be dissassociated:\n+    /// [`Weak`] pointers will be disassociated:\n     ///\n     /// ```\n     /// use std::rc::Rc;\n@@ -837,7 +842,7 @@ impl<T: Clone> Rc<T> {\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // reference to the allocation.\n         unsafe {\n             &mut this.ptr.as_mut().value\n         }\n@@ -861,11 +866,9 @@ impl Rc<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Rc::new(my_string));\n-    ///     print_if_string(Rc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Rc::new(my_string));\n+    /// print_if_string(Rc::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n@@ -880,7 +883,7 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n@@ -910,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n-    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -1113,7 +1116,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n impl<T: ?Sized> Clone for Rc<T> {\n     /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -1174,6 +1177,8 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1191,9 +1196,11 @@ impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are equal if their inner values are equal.\n+    /// Two `Rc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// always equal.\n     ///\n     /// # Examples\n@@ -1214,7 +1221,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// never unequal.\n     ///\n     /// # Examples\n@@ -1543,17 +1551,18 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n }\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Rc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Rc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Rc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -1752,10 +1761,10 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1789,7 +1798,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1803,11 +1812,11 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of `Weak` pointers pointing to this value.\n+    /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return `None`. If\n     /// not, the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1832,14 +1841,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1871,6 +1880,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1920,7 +1931,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "08243ef7c519f1fdb500347d8249169fe183c120", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -411,25 +411,16 @@ impl<T> [T] {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(repeat_generic_slice)]\n-    ///\n-    /// fn main() {\n-    ///     assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n-    /// }\n+    /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n     /// ```\n     ///\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n-    /// #![feature(repeat_generic_slice)]\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     b\"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n-    #[unstable(feature = \"repeat_generic_slice\",\n-               reason = \"it's on str, why not on slice?\",\n-               issue = \"48784\")]\n+    #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n         if n == 0 {\n             return Vec::new();"}, {"sha": "83816d8b954c4dbbd7e3e0ccf3c76185319a5fc8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -456,7 +456,7 @@ impl str {\n                 }\n             }\n         }\n-        return s;\n+        s\n     }\n \n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n@@ -500,10 +500,8 @@ impl str {\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     \"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// \"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "d9927c642b2d8528cc012de950ace36fdbcdafa6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -164,10 +164,8 @@ use crate::vec::Vec;\n ///\n /// fn example_func<A: TraitExample>(example_arg: A) {}\n ///\n-/// fn main() {\n-///     let example_string = String::from(\"example_string\");\n-///     example_func(&example_string);\n-/// }\n+/// let example_string = String::from(\"example_string\");\n+/// example_func(&example_string);\n /// ```\n ///\n /// There are two options that would work instead. The first would be to\n@@ -198,20 +196,21 @@ use crate::vec::Vec;\n ///\n /// let story = String::from(\"Once upon a time...\");\n ///\n-/// let ptr = story.as_ptr();\n+// FIXME Update this when vec_into_raw_parts is stabilized\n+/// // Prevent automatically dropping the String's data\n+/// let mut story = mem::ManuallyDrop::new(story);\n+///\n+/// let ptr = story.as_mut_ptr();\n /// let len = story.len();\n /// let capacity = story.capacity();\n ///\n /// // story has nineteen bytes\n /// assert_eq!(19, len);\n ///\n-/// // Now that we have our parts, we throw the story away.\n-/// mem::forget(story);\n-///\n /// // We can re-build a String out of ptr, len, and capacity. This is all\n /// // unsafe because we are responsible for making sure the components are\n /// // valid:\n-/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n+/// let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n ///\n /// assert_eq!(String::from(\"Once upon a time...\"), s);\n /// ```\n@@ -649,6 +648,37 @@ impl String {\n         decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n     }\n \n+    /// Decomposes a `String` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the string (in bytes), and the allocated capacity of the data\n+    /// (in bytes). These are the same arguments in the same order as\n+    /// the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `String`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `String` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let s = String::from(\"hello\");\n+    ///\n+    /// let (ptr, len, cap) = s.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };\n+    /// assert_eq!(rebuilt, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut u8, usize, usize) {\n+        self.vec.into_raw_parts()\n+    }\n+\n     /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n     /// # Safety\n@@ -679,13 +709,16 @@ impl String {\n     ///\n     /// unsafe {\n     ///     let s = String::from(\"hello\");\n-    ///     let ptr = s.as_ptr();\n+    ///\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    ///     // Prevent automatically dropping the String's data\n+    ///     let mut s = mem::ManuallyDrop::new(s);\n+    ///\n+    ///     let ptr = s.as_mut_ptr();\n     ///     let len = s.len();\n     ///     let capacity = s.capacity();\n     ///\n-    ///     mem::forget(s);\n-    ///\n-    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n+    ///     let s = String::from_raw_parts(ptr, len, capacity);\n     ///\n     ///     assert_eq!(String::from(\"hello\"), s);\n     /// }"}, {"sha": "80d6c6e0d43907bbdf936a9e8f1a34a7b5efaa3f", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -45,10 +45,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new `Arc` instance, which points to the same value on the heap as the\n+/// a new `Arc` instance, which points to the same allocation on the heap as the\n /// source `Arc`, while increasing a reference count. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is also\n-/// destroyed.\n+/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n+/// referred to as \"inner value\") is also dropped.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n /// exception: you cannot generally obtain a mutable reference to something\n@@ -61,7 +61,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n /// counting. This means that it is thread-safe. The disadvantage is that\n /// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n+/// are not sharing reference-counted allocations between threads, consider using\n /// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n /// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n /// However, a library might choose `Arc<T>` in order to give library consumers\n@@ -85,8 +85,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n+/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n+/// already been dropped. In other words, `Weak` pointers do not keep the value\n+/// inside the allocation alive; however, they *do* keep the allocation\n+/// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n /// [`Weak`][weak] is used to break cycles. For example, a tree could have\n@@ -121,8 +123,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// already been dropped.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n@@ -221,17 +223,18 @@ impl<T: ?Sized> Arc<T> {\n }\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Arc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Arc`] pointers, since mutual owning references\n /// would never allow either [`Arc`] to be dropped. For example, a tree could\n /// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -345,7 +348,7 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n     /// passed in.\n@@ -426,7 +429,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -465,7 +468,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -584,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -628,7 +631,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -659,7 +662,7 @@ impl<T: ?Sized> Arc<T> {\n         if cnt == usize::MAX { 0 } else { cnt - 1 }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -710,8 +713,8 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Arc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -725,14 +728,16 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n@@ -761,7 +766,7 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n-    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -903,7 +908,7 @@ impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -965,15 +970,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n+    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n+    /// any remaining `Weak` pointers.\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     /// [get_mut]: struct.Arc.html#method.get_mut\n+    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n     ///\n     /// # Examples\n     ///\n@@ -988,7 +997,7 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -1048,14 +1057,14 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Arc`, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`][option] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [option]: ../../std/option/enum.Option.html\n@@ -1091,7 +1100,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Arc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -1100,7 +1109,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Arc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Arc::new`.\n@@ -1244,11 +1253,9 @@ impl Arc<dyn Any + Send + Sync> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Arc::new(my_string));\n-    ///     print_if_string(Arc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Arc::new(my_string));\n+    /// print_if_string(Arc::new(0i8));\n     /// ```\n     pub fn downcast<T>(self) -> Result<Arc<T>, Self>\n     where\n@@ -1426,10 +1433,10 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Arc`]: struct.Arc.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1484,7 +1491,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1499,17 +1506,17 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n-    /// value.\n+    /// allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0. If not,\n     /// the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// # Accuracy\n     ///\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n-    /// `Weak`s pointing to the same value.\n+    /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1550,14 +1557,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1589,6 +1596,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Arc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1598,7 +1607,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1629,7 +1638,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { ptr: self.ptr };\n+        Weak { ptr: self.ptr }\n     }\n }\n \n@@ -1728,6 +1737,8 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n@@ -1745,10 +1756,11 @@ impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n+    /// Two `Arc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// always equal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same allocation are always equal.\n     ///\n     /// # Examples\n     ///\n@@ -1768,8 +1780,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// never unequal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same value are never unequal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a44cf1eaf6df0310471d4e6d8e67050c6c9aca95", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,10 +1,6 @@\n-use std::cmp;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n-use std::panic::{self, AssertUnwindSafe};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-use rand::{thread_rng, seq::SliceRandom};\n+use std::iter::TrustedLen;\n \n #[test]\n fn test_iterator() {\n@@ -19,7 +15,7 @@ fn test_iterator() {\n }\n \n #[test]\n-fn test_iterator_reverse() {\n+fn test_iter_rev_cloned_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -29,7 +25,7 @@ fn test_iterator_reverse() {\n }\n \n #[test]\n-fn test_move_iter() {\n+fn test_into_iter_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![9, 5, 3];\n     let pq = BinaryHeap::from(data);\n@@ -39,7 +35,7 @@ fn test_move_iter() {\n }\n \n #[test]\n-fn test_move_iter_size_hint() {\n+fn test_into_iter_size_hint() {\n     let data = vec![5, 9];\n     let pq = BinaryHeap::from(data);\n \n@@ -56,7 +52,7 @@ fn test_move_iter_size_hint() {\n }\n \n #[test]\n-fn test_move_iter_reverse() {\n+fn test_into_iter_rev_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -65,6 +61,65 @@ fn test_move_iter_reverse() {\n     assert_eq!(v, iterout);\n }\n \n+#[test]\n+fn test_into_iter_sorted_collect() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.into_iter_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+#[test]\n+fn test_drain_sorted_collect() {\n+    let mut heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.drain_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+fn check_exact_size_iterator<I: ExactSizeIterator>(len: usize, it: I) {\n+    let mut it = it;\n+\n+    for i in 0..it.len() {\n+        let (lower, upper) = it.size_hint();\n+        assert_eq!(Some(lower), upper);\n+        assert_eq!(lower, len - i);\n+        assert_eq!(it.len(), len - i);\n+        it.next();\n+    }\n+    assert_eq!(it.len(), 0);\n+    assert!(it.is_empty());\n+}\n+\n+#[test]\n+fn test_exact_size_iterator() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_exact_size_iterator(heap.len(), heap.iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter_sorted());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain_sorted());\n+}\n+\n+fn check_trusted_len<I: TrustedLen>(len: usize, it: I) {\n+    let mut it = it;\n+    for i in 0..len {\n+        let (lower, upper) = it.size_hint();\n+        if upper.is_some() {\n+            assert_eq!(Some(lower), upper);\n+            assert_eq!(lower, len - i);\n+        }\n+        it.next();\n+    }\n+}\n+\n+#[test]\n+fn test_trusted_len() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_trusted_len(heap.len(), heap.clone().into_iter_sorted());\n+    check_trusted_len(heap.len(), heap.clone().drain_sorted());\n+}\n+\n #[test]\n fn test_peek_and_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n@@ -211,6 +266,15 @@ fn test_drain() {\n     assert!(q.is_empty());\n }\n \n+#[test]\n+fn test_drain_sorted() {\n+    let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+    assert_eq!(q.drain_sorted().take(5).collect::<Vec<_>>(), vec![9, 8, 7, 6, 5]);\n+\n+    assert!(q.is_empty());\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = BinaryHeap::new();\n@@ -281,9 +345,15 @@ fn assert_covariance() {\n // even if the order may not be correct.\n //\n // Destructors must be called exactly once per element.\n+// FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(miri))] // Miri does not support catching panics\n+#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n fn panic_safe() {\n+    use std::cmp;\n+    use std::panic::{self, AssertUnwindSafe};\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n+    use rand::{thread_rng, seq::SliceRandom};\n+\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n \n     #[derive(Eq, PartialEq, Ord, Clone, Debug)]"}, {"sha": "bc3d53bf30da37446fac708800e0abe71cd25962", "filename": "src/liballoc/tests/boxed.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,18 @@\n+use std::ptr::NonNull;\n+use std::mem::MaybeUninit;\n+\n+#[test]\n+fn unitialized_zero_size_box() {\n+    assert_eq!(\n+        &*Box::<()>::new_uninit() as *const _,\n+        NonNull::<MaybeUninit<()>>::dangling().as_ptr(),\n+    );\n+    assert_eq!(\n+        Box::<[()]>::new_uninit_slice(4).as_ptr(),\n+        NonNull::<MaybeUninit<()>>::dangling().as_ptr(),\n+    );\n+    assert_eq!(\n+        Box::<[String]>::new_uninit_slice(0).as_ptr(),\n+        NonNull::<MaybeUninit<String>>::dangling().as_ptr(),\n+    );\n+}"}, {"sha": "e4883abc8b56c3362d1fd4726f0d73746f430971", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 117, "deletions": 19, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -48,7 +48,9 @@ fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n     f(&set_a,\n       &set_b,\n       &mut |&x| {\n-          assert_eq!(x, expected[i]);\n+          if i < expected.len() {\n+              assert_eq!(x, expected[i]);\n+          }\n           i += 1;\n           true\n       });\n@@ -74,31 +76,36 @@ fn test_intersection() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n     check_intersection(&[-1], &large, &[]);\n     check_intersection(&large, &[-1], &[]);\n     check_intersection(&[0], &large, &[0]);\n     check_intersection(&large, &[0], &[0]);\n-    check_intersection(&[999], &large, &[999]);\n-    check_intersection(&large, &[999], &[999]);\n-    check_intersection(&[1000], &large, &[]);\n-    check_intersection(&large, &[1000], &[]);\n-    check_intersection(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_intersection(&[99], &large, &[99]);\n+    check_intersection(&large, &[99], &[99]);\n+    check_intersection(&[100], &large, &[]);\n+    check_intersection(&large, &[100], &[]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924],\n                        &large,\n-                       &[1, 3, 11, 77, 103]);\n+                       &[1, 3, 11, 77]);\n }\n \n #[test]\n fn test_intersection_size_hint() {\n     let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n     let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n     let mut iter = x.intersection(&y);\n-    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n     assert_eq!(iter.next(), Some(&3));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n+\n+    iter = y.intersection(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n }\n \n #[test]\n@@ -111,6 +118,9 @@ fn test_difference() {\n     check_difference(&[1, 12], &[], &[1, 12]);\n     check_difference(&[], &[1, 2, 3, 9], &[]);\n     check_difference(&[1, 3, 5, 9, 11], &[3, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[3, 6, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[0, 1], &[3, 5, 9, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[11, 12], &[1, 3, 5, 9]);\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n@@ -119,18 +129,82 @@ fn test_difference() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n     check_difference(&[0], &large, &[]);\n-    check_difference(&[999], &large, &[]);\n-    check_difference(&[1000], &large, &[1000]);\n-    check_difference(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_difference(&[99], &large, &[]);\n+    check_difference(&[100], &large, &[100]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924],\n                      &large,\n                      &[5000, 8924]);\n     check_difference(&large, &[], &large);\n     check_difference(&large, &[-1], &large);\n-    check_difference(&large, &[1000], &large);\n+    check_difference(&large, &[100], &large);\n+}\n+\n+#[test]\n+fn test_difference_size_hint() {\n+    let s246: BTreeSet<i32> = [2, 4, 6].iter().copied().collect();\n+    let s23456: BTreeSet<i32> = (2..=6).collect();\n+    let mut iter = s246.difference(&s23456);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s12345: BTreeSet<i32> = (1..=5).collect();\n+    iter = s246.difference(&s12345);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s34567: BTreeSet<i32> = (3..=7).collect();\n+    iter = s246.difference(&s34567);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s1: BTreeSet<i32> = (-9..=1).collect();\n+    iter = s246.difference(&s1);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n+\n+    let s2: BTreeSet<i32> = (-9..=2).collect();\n+    iter = s246.difference(&s2);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s23: BTreeSet<i32> = (2..=3).collect();\n+    iter = s246.difference(&s23);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s4: BTreeSet<i32> = (4..=4).collect();\n+    iter = s246.difference(&s4);\n+    assert_eq!(iter.size_hint(), (2, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s56: BTreeSet<i32> = (5..=6).collect();\n+    iter = s246.difference(&s56);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+\n+    let s6: BTreeSet<i32> = (6..=19).collect();\n+    iter = s246.difference(&s6);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s7: BTreeSet<i32> = (7..=19).collect();\n+    iter = s246.difference(&s7);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n }\n \n #[test]\n@@ -147,6 +221,18 @@ fn test_symmetric_difference() {\n                                &[-2, 1, 5, 11, 14, 22]);\n }\n \n+#[test]\n+fn test_symmetric_difference_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.symmetric_difference(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(4)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(1)));\n+}\n+\n #[test]\n fn test_union() {\n     fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n@@ -161,6 +247,18 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+fn test_union_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.union(&y);\n+    assert_eq!(iter.size_hint(), (3, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (2, Some(4)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+}\n+\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n@@ -170,7 +268,7 @@ fn test_is_disjoint() {\n }\n \n #[test]\n-// Also tests the trivial function definition of is_superset\n+// Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n         let set_a = a.iter().collect::<BTreeSet<_>>();\n@@ -188,23 +286,23 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 11, 34, 22, 38, 33, 42, 39, 40]),\n+                         &[-12, -5, 11, 14, 22, 23, 33, 34, 38, 39, 40, 42]),\n                true);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 34, 38, 22, 11]),\n+                         &[-12, -5, 11, 14, 22, 23, 34, 38]),\n                false);\n \n     if cfg!(miri) { // Miri is too slow\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n     assert_eq!(is_subset(&[-1], &large), false);\n     assert_eq!(is_subset(&[0], &large), true);\n     assert_eq!(is_subset(&[1, 2], &large), true);\n-    assert_eq!(is_subset(&[999, 1000], &large), false);\n+    assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n #[test]"}, {"sha": "3273feb7b5dd4b291e1250386f4b1acce1427dba", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2,19 +2,21 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n-#![feature(option_flattening)]\n+#![feature(new_uninit)]\n #![feature(pattern)]\n-#![feature(repeat_generic_slice)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(associated_type_bounds)]\n+#![feature(binary_heap_into_iter_sorted)]\n+#![feature(binary_heap_drain_sorted)]\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n mod arc;\n mod binary_heap;\n+mod boxed;\n mod btree;\n mod cow_str;\n mod fmt;"}, {"sha": "cb73c7c179cbf2edba72a0337199e1bbd55f092c", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -483,7 +483,7 @@ mod slice_index {\n     }\n \n     #[test]\n-    #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n+    #[cfg(not(target_os = \"emscripten\"))] // hits an OOM\n     #[cfg(not(miri))] // Miri is too slow\n     fn simple_big() {\n         fn a_million_letter_x() -> String {"}, {"sha": "80537217697adebedb4e1c31fd3b3f79869e2ab6", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -944,8 +944,10 @@ fn drain_filter_complex() {\n     }\n }\n \n+// Miri does not support catching panics\n+// FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(miri))] // Miri does not support catching panics\n+#[cfg(not(any(miri, target_os = \"emscripten\")))]\n fn drain_filter_consumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n@@ -995,8 +997,9 @@ fn drain_filter_consumed_panic() {\n     }\n }\n \n+// FIXME: Re-enable emscripten once it can catch panics\n #[test]\n-#[cfg(not(miri))] // Miri does not support catching panics\n+#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n fn drain_filter_unconsumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n@@ -1281,3 +1284,51 @@ fn test_stable_push_pop() {\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n }\n+\n+// https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:\n+//\n+// ```\n+// unsafe impl<T: ?Sized> IsZero for *mut T {\n+//     fn is_zero(&self) -> bool {\n+//         (*self).is_null()\n+//     }\n+// }\n+// ```\n+//\n+// \u2026 to call `RawVec::with_capacity_zeroed` for creating `Vec<*mut T>`,\n+// which is incorrect for fat pointers since `<*mut T>::is_null` only looks at the data component.\n+// That is, a fat pointer can be \u201cnull\u201d without being made entirely of zero bits.\n+#[test]\n+fn vec_macro_repeating_null_raw_fat_pointer() {\n+    let raw_dyn = &mut (|| ()) as &mut dyn Fn() as *mut dyn Fn();\n+    let vtable = dbg!(ptr_metadata(raw_dyn));\n+    let null_raw_dyn = ptr_from_raw_parts(std::ptr::null_mut(), vtable);\n+    assert!(null_raw_dyn.is_null());\n+\n+    let vec = vec![null_raw_dyn; 1];\n+    dbg!(ptr_metadata(vec[0]));\n+    assert!(vec[0] == null_raw_dyn);\n+\n+    // Polyfill for https://github.com/rust-lang/rfcs/pull/2580\n+\n+    fn ptr_metadata(ptr: *mut dyn Fn()) -> *mut () {\n+        unsafe {\n+            std::mem::transmute::<*mut dyn Fn(), DynRepr>(ptr).vtable\n+        }\n+    }\n+\n+    fn ptr_from_raw_parts(data: *mut (), vtable: *mut()) -> *mut dyn Fn() {\n+        unsafe {\n+            std::mem::transmute::<DynRepr, *mut dyn Fn()>(DynRepr {\n+                data,\n+                vtable\n+            })\n+        }\n+    }\n+\n+    #[repr(C)]\n+    struct DynRepr {\n+        data: *mut (),\n+        vtable: *mut (),\n+    }\n+}"}, {"sha": "5b53a6a2899581c72aacd751ce12a29fd298dd82", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 95, "deletions": 29, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -154,8 +154,8 @@ use crate::raw_vec::RawVec;\n /// println!(\"{}\", v[6]); // it will panic!\n /// ```\n ///\n-/// In conclusion: always check if the index you want to get really exists\n-/// before doing it.\n+/// Use [`get`] and [`get_mut`] if you want to check whether the index is in\n+/// the `Vec`.\n ///\n /// # Slicing\n ///\n@@ -277,6 +277,8 @@ use crate::raw_vec::RawVec;\n /// The order has changed in the past and may change again.\n ///\n /// [`vec!`]: ../../std/macro.vec.html\n+/// [`get`]: ../../std/vec/struct.Vec.html#method.get\n+/// [`get_mut`]: ../../std/vec/struct.Vec.html#method.get_mut\n /// [`Index`]: ../../std/ops/trait.Index.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`&str`]: ../../std/primitive.str.html\n@@ -358,6 +360,44 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Decomposes a `Vec<T>` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the vector (in elements), and the allocated capacity of the\n+    /// data (in elements). These are the same arguments in the same\n+    /// order as the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Vec`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let v: Vec<i32> = vec![-1, 0, 1];\n+    ///\n+    /// let (ptr, len, cap) = v.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe {\n+    ///     // We can now make changes to the components, such as\n+    ///     // transmuting the raw pointer to a compatible type.\n+    ///     let ptr = ptr as *mut u32;\n+    ///\n+    ///     Vec::from_raw_parts(ptr, len, cap)\n+    /// };\n+    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n+        let mut me = mem::ManuallyDrop::new(self);\n+        (me.as_mut_ptr(), me.len(), me.capacity())\n+    }\n+\n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n     /// # Safety\n@@ -373,7 +413,11 @@ impl<T> Vec<T> {\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n     /// internal data structures. For example it is **not** safe\n-    /// to build a `Vec<u8>` from a pointer to a C `char` array and a `size_t`.\n+    /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n+    /// It's also not safe to build one from a `Vec<u16>` and its length, because\n+    /// the allocator cares about the alignment, and these two types have different\n+    /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n+    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n     ///\n     /// The ownership of `ptr` is effectively transferred to the\n     /// `Vec<T>` which may then deallocate, reallocate or change the\n@@ -389,28 +433,27 @@ impl<T> Vec<T> {\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let mut v = vec![1, 2, 3];\n-    ///\n-    ///     // Pull out the various important pieces of information about `v`\n-    ///     let p = v.as_mut_ptr();\n-    ///     let len = v.len();\n-    ///     let cap = v.capacity();\n+    /// let v = vec![1, 2, 3];\n     ///\n-    ///     unsafe {\n-    ///         // Cast `v` into the void: no destructor run, so we are in\n-    ///         // complete control of the allocation to which `p` points.\n-    ///         mem::forget(v);\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    /// // Prevent running `v`'s destructor so we are in complete control\n+    /// // of the allocation.\n+    /// let mut v = mem::ManuallyDrop::new(v);\n     ///\n-    ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in 0..len as isize {\n-    ///             ptr::write(p.offset(i), 4 + i);\n-    ///         }\n+    /// // Pull out the various important pieces of information about `v`\n+    /// let p = v.as_mut_ptr();\n+    /// let len = v.len();\n+    /// let cap = v.capacity();\n     ///\n-    ///         // Put everything back together into a Vec\n-    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, [4, 5, 6]);\n+    /// unsafe {\n+    ///     // Overwrite memory with 4, 5, 6\n+    ///     for i in 0..len as isize {\n+    ///         ptr::write(p.offset(i), 4 + i);\n     ///     }\n+    ///\n+    ///     // Put everything back together into a Vec\n+    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n+    ///     assert_eq!(rebuilt, [4, 5, 6]);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1391,12 +1434,10 @@ impl<T> Vec<T> {\n     /// ```\n     /// #![feature(vec_leak)]\n     ///\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3];\n-    ///     let static_ref: &'static mut [usize] = Vec::leak(x);\n-    ///     static_ref[0] += 1;\n-    ///     assert_eq!(static_ref, &[2, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3];\n+    /// let static_ref: &'static mut [usize] = Vec::leak(x);\n+    /// static_ref[0] += 1;\n+    /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n     #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n     #[inline]\n@@ -1734,20 +1775,45 @@ impl_is_zero!(char, |x| x == '\\0');\n impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n \n-unsafe impl<T: ?Sized> IsZero for *const T {\n+unsafe impl<T> IsZero for *const T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for *mut T {\n+unsafe impl<T> IsZero for *mut T {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         (*self).is_null()\n     }\n }\n \n+// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n+// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec"}, {"sha": "66d27a275192e69e16c9b292387f5f60df69b591", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -500,7 +500,7 @@ impl DroplessArena {\n                 // though it was supposed to give us `len`\n                 return slice::from_raw_parts_mut(mem, i);\n             }\n-            ptr::write(mem.offset(i as isize), value.unwrap());\n+            ptr::write(mem.add(i), value.unwrap());\n             i += 1;\n         }\n     }"}, {"sha": "e2704e807d104bd42378db2b496e5d5abf1fdd7a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 48, "deletions": 61, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2,14 +2,14 @@\n //! of any `'static` type through runtime reflection.\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n-//! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n-//! `downcast_ref` methods, to test if the contained value is of a given type,\n-//! and to get a reference to the inner value as a type. As `&mut Any`, there\n+//! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n+//! and `downcast_ref` methods, to test if the contained value is of a given type,\n+//! and to get a reference to the inner value as a type. As `&mut dyn Any`, there\n //! is also the `downcast_mut` method, for getting a mutable reference to the\n-//! inner value. `Box<Any>` adds the `downcast` method, which attempts to\n+//! inner value. `Box<dyn Any>` adds the `downcast` method, which attempts to\n //! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n //!\n-//! Note that &Any is limited to testing whether a value is of a specified\n+//! Note that `&dyn Any` is limited to testing whether a value is of a specified\n //! concrete type, and cannot be used to test whether a type implements a trait.\n //!\n //! [`Box`]: ../../std/boxed/struct.Box.html\n@@ -87,10 +87,8 @@ pub trait Any: 'static {\n     ///     TypeId::of::<String>() == s.type_id()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n     fn type_id(&self) -> TypeId;\n@@ -145,10 +143,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -179,10 +175,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -210,16 +204,14 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -250,10 +242,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -276,10 +266,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -300,16 +288,14 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -334,10 +320,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -360,10 +344,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -384,16 +366,14 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -437,10 +417,8 @@ impl TypeId {\n     ///     TypeId::of::<String>() == TypeId::of::<T>()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature=\"const_type_id\")]\n@@ -467,6 +445,15 @@ impl TypeId {\n ///\n /// The current implementation uses the same infrastructure as compiler\n /// diagnostics and debuginfo, but this is not guaranteed.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// assert_eq!(\n+///     std::any::type_name::<Option<String>>(),\n+///     \"core::option::Option<alloc::string::String>\",\n+/// );\n+/// ```\n #[stable(feature = \"type_name\", since = \"1.38.0\")]\n #[rustc_const_unstable(feature = \"const_type_name\")]\n pub const fn type_name<T: ?Sized>() -> &'static str {"}, {"sha": "11803238407c8d5522fc0739300cd197c2d38d67", "filename": "src/libcore/array/iter.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,266 @@\n+//! Defines the `IntoIter` owned iterator for arrays.\n+\n+use crate::{\n+    fmt,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+    mem::{self, MaybeUninit},\n+    ops::Range,\n+    ptr,\n+};\n+use super::LengthAtMost32;\n+\n+\n+/// A by-value [array] iterator.\n+///\n+/// [array]: ../../std/primitive.array.html\n+#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n+pub struct IntoIter<T, const N: usize>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// This is the array we are iterating over.\n+    ///\n+    /// Elements with index `i` where `alive.start <= i < alive.end` have not\n+    /// been yielded yet and are valid array entries. Elements with indices `i\n+    /// < alive.start` or `i >= alive.end` have been yielded already and must\n+    /// not be accessed anymore! Those dead elements might even be in a\n+    /// completely uninitialized state!\n+    ///\n+    /// So the invariants are:\n+    /// - `data[alive]` is alive (i.e. contains valid elements)\n+    /// - `data[..alive.start]` and `data[alive.end..]` are dead (i.e. the\n+    ///   elements were already read and must not be touched anymore!)\n+    data: [MaybeUninit<T>; N],\n+\n+    /// The elements in `data` that have not been yielded yet.\n+    ///\n+    /// Invariants:\n+    /// - `alive.start <= alive.end`\n+    /// - `alive.end <= N`\n+    alive: Range<usize>,\n+}\n+\n+impl<T, const N: usize> IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Creates a new iterator over the given `array`.\n+    ///\n+    /// *Note*: this method might never get stabilized and/or removed in the\n+    /// future as there will likely be another, preferred way of obtaining this\n+    /// iterator (either via `IntoIterator` for arrays or via another way).\n+    #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n+    pub fn new(array: [T; N]) -> Self {\n+        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // promise:\n+        //\n+        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n+        // > as `T`.\n+        //\n+        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n+        // an array of `T`.\n+        //\n+        // With that, this initialization satisfies the invariants.\n+\n+        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n+        // works with const generics:\n+        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //\n+        // Until then, we do it manually here. We first create a bitwise copy\n+        // but cast the pointer so that it is treated as a different type. Then\n+        // we forget `array` so that it is not dropped.\n+        let data = unsafe {\n+            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+            mem::forget(array);\n+            data\n+        };\n+\n+        Self {\n+            data,\n+            alive: 0..N,\n+        }\n+    }\n+\n+    /// Returns an immutable slice of all elements that have not been yielded\n+    /// yet.\n+    fn as_slice(&self) -> &[T] {\n+        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        // the size and alignment of `T`. Furthermore, we know that all\n+        // elements within `alive` are properly initialized.\n+        let slice = &self.data[self.alive.clone()];\n+        unsafe {\n+            mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Bump start index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n+        // maintains the invariant regarding `alive`. However, due to this\n+        // change, for a short time, the alive zone is not `data[alive]`\n+        // anymore, but `data[idx..alive.end]`.\n+        let idx = self.alive.start;\n+        self.alive.start += 1;\n+\n+        // Read the element from the array. This is safe: `idx` is an index\n+        // into the \"alive\" region of the array. Reading this element means\n+        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n+        // `idx` was the start of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(idx).read() };\n+\n+        Some(out)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Decrease end index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n+        // `alive.end` is at least 1, meaning that we can safely decrement it\n+        // by one. This also maintains the invariant `alive.start <=\n+        // alive.end`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n+        // + 1]`.\n+        self.alive.end -= 1;\n+\n+        // Read the element from the array. This is safe: `alive.end` is an\n+        // index into the \"alive\" region of the array. Compare the previous\n+        // comment that states that the alive region is\n+        // `data[alive.start..alive.end + 1]`. Reading this element means that\n+        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n+        // `alive.end` was the end of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n+\n+        Some(out)\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T, const N: usize> Drop for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn drop(&mut self) {\n+        // We simply drop each element via `for_each`. This should not incur\n+        // any significant runtime overhead and avoids adding another `unsafe`\n+        // block.\n+        self.by_ref().for_each(drop);\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn len(&self) -> usize {\n+        // Will never underflow due to the invariant `alive.start <=\n+        // alive.end`.\n+        self.alive.end - self.alive.start\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.alive.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+// The iterator indeed reports the correct length. The number of \"alive\"\n+// elements (that will still be yielded) is the length of the range `alive`.\n+// This range is decremented in length in either `next` or `next_back`. It is\n+// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            // This creates a new uninitialized array. Note that the `assume_init`\n+            // refers to the array, not the individual elements. And it is Ok if\n+            // the array is in an uninitialized state as all elements may be\n+            // uninitialized (all bit patterns are valid). Compare the\n+            // `MaybeUninit` docs for more information.\n+            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n+\n+            // Clone all alive elements.\n+            for idx in self.alive.clone() {\n+                // The element at `idx` in the old array is alive, so we can\n+                // safely call `get_ref()`. We then clone it, and write the\n+                // clone into the new array.\n+                let clone = self.data.get_unchecked(idx).get_ref().clone();\n+                new_data.get_unchecked_mut(idx).write(clone);\n+            }\n+\n+            Self {\n+                data: new_data,\n+                alive: self.alive.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Only print the elements that were not yielded yet: we cannot\n+        // access the yielded elements anymore.\n+        f.debug_tuple(\"IntoIter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}"}, {"sha": "e1ec8b795d04c6bfa467efba3549851c35919355", "filename": "src/libcore/array/mod.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -14,6 +14,13 @@ use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n+#[cfg(not(bootstrap))]\n+mod iter;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n+pub use iter::IntoIter;\n+\n /// Utility trait implemented only on arrays of fixed size\n ///\n /// This trait can be used to implement other traits on fixed-size arrays", "previous_filename": "src/libcore/array.rs"}, {"sha": "fda103a52d8bc851b8fa4d07f277eb27302d425f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -229,52 +229,6 @@ pub struct Cell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-impl<T:Copy> Cell<T> {\n-    /// Returns a copy of the contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let five = c.get();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> T {\n-        unsafe{ *self.value.get() }\n-    }\n-\n-    /// Updates the contained value using a function and returns the new value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(cell_update)]\n-    ///\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    /// let new = c.update(|x| x + 1);\n-    ///\n-    /// assert_eq!(new, 6);\n-    /// assert_eq!(c.get(), 6);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n-    pub fn update<F>(&self, f: F) -> T\n-    where\n-        F: FnOnce(T) -> T,\n-    {\n-        let old = self.get();\n-        let new = f(old);\n-        self.set(new);\n-        new\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n \n@@ -448,6 +402,52 @@ impl<T> Cell<T> {\n     }\n }\n \n+impl<T:Copy> Cell<T> {\n+    /// Returns a copy of the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let five = c.get();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> T {\n+        unsafe{ *self.value.get() }\n+    }\n+\n+    /// Updates the contained value using a function and returns the new value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_update)]\n+    ///\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let new = c.update(|x| x + 1);\n+    ///\n+    /// assert_eq!(new, 6);\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n+    pub fn update<F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(T) -> T,\n+    {\n+        let old = self.get();\n+        let new = f(old);\n+        self.set(new);\n+        new\n+    }\n+}\n+\n impl<T: ?Sized> Cell<T> {\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///"}, {"sha": "c456e14db12d4f311f43177458301a9c316dd2a1", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -111,11 +111,9 @@ impl From<char> for u32 {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let c = 'c';\n-    ///     let u = u32::from(c);\n-    ///     assert!(4 == mem::size_of_val(&u))\n-    /// }\n+    /// let c = 'c';\n+    /// let u = u32::from(c);\n+    /// assert!(4 == mem::size_of_val(&u))\n     /// ```\n     #[inline]\n     fn from(c: char) -> Self {\n@@ -150,11 +148,9 @@ impl From<u8> for char {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let u = 32 as u8;\n-    ///     let c = char::from(u);\n-    ///     assert!(4 == mem::size_of_val(&c))\n-    /// }\n+    /// let u = 32 as u8;\n+    /// let c = char::from(u);\n+    /// assert!(4 == mem::size_of_val(&c))\n     /// ```\n     #[inline]\n     fn from(i: u8) -> Self {"}, {"sha": "b71c9c2c40b37878c3253e1469f367218b1d062d", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -31,39 +31,41 @@ pub struct DecodeUtf16Error {\n /// ```\n /// use std::char::decode_utf16;\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///                            .collect::<Vec<_>>(),\n-///                vec![Ok('\ud834\udd1e'),\n-///                     Ok('m'), Ok('u'), Ok('s'),\n-///                     Err(0xDD1E),\n-///                     Ok('i'), Ok('c'),\n-///                     Err(0xD834)]);\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///         .collect::<Vec<_>>(),\n+///     vec![\n+///         Ok('\ud834\udd1e'),\n+///         Ok('m'), Ok('u'), Ok('s'),\n+///         Err(0xDD1E),\n+///         Ok('i'), Ok('c'),\n+///         Err(0xD834)\n+///     ]\n+/// );\n /// ```\n ///\n /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n ///\n /// ```\n /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///                    .collect::<String>(),\n-///                \"\ud834\udd1emus\ufffdic\ufffd\");\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///        .collect::<String>(),\n+///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+/// );\n /// ```\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]"}, {"sha": "971d89e004446e306a1ad424c43375e36f6d07b4", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 109, "deletions": 63, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -116,9 +116,9 @@ impl char {\n \n         // the code is split up here to improve execution speed for cases where\n         // the `radix` is constant and 10 or smaller\n-        let val = if radix <= 10  {\n+        let val = if radix <= 10 {\n             match self {\n-                '0' ..= '9' => self as u32 - '0' as u32,\n+                '0'..='9' => self as u32 - '0' as u32,\n                 _ => return None,\n             }\n         } else {\n@@ -130,8 +130,11 @@ impl char {\n             }\n         };\n \n-        if val < radix { Some(val) }\n-        else { None }\n+        if val < radix {\n+            Some(val)\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -303,8 +306,8 @@ impl char {\n             '\\r' => EscapeDefaultState::Backslash('r'),\n             '\\n' => EscapeDefaultState::Backslash('n'),\n             '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ..= '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+            '\\x20'..='\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n         };\n         EscapeDefault { state: init_state }\n     }\n@@ -436,30 +439,31 @@ impl char {\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n         unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n+            let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n                 1\n             } else if code < MAX_TWO_B && dst.len() >= 2 {\n                 *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                 *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                 2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+            } else if code < MAX_THREE_B && dst.len() >= 3 {\n                 *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(1) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                 3\n             } else if dst.len() >= 4 {\n                 *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                 *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                 4\n             } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf8(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             };\n             from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n         }\n@@ -515,15 +519,24 @@ impl char {\n                 *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                 slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n             } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf16(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             }\n         }\n     }\n \n-    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` has the `Alphabetic` property.\n+    ///\n+    /// `Alphabetic` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -547,10 +560,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is lowercase.\n+    /// Returns `true` if this `char` has the `Lowercase` property.\n     ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n+    /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -575,10 +592,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is uppercase.\n+    /// Returns `true` if this `char` has the `Uppercase` property.\n+    ///\n+    /// `Uppercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n     ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -603,10 +624,12 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is whitespace.\n+    /// Returns `true` if this `char` has the `White_Space` property.\n     ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n-    /// Property `White_Space`.\n+    /// `White_Space` is specified in the [Unicode Character Database][ucd] [`PropList.txt`].\n+    ///\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`PropList.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n     ///\n     /// # Examples\n     ///\n@@ -630,10 +653,10 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is alphanumeric.\n+    /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].\n     ///\n-    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No` and the Derived Core Property `Alphabetic`.\n+    /// [`is_alphabetic()`]: #method.is_alphabetic\n+    /// [`is_numeric()`]: #method.is_numeric\n     ///\n     /// # Examples\n     ///\n@@ -655,10 +678,15 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns `true` if this `char` is a control code point.\n+    /// Returns `true` if this `char` has the general category for control codes.\n+    ///\n+    /// Control codes (code points with the general category of `Cc`) are described in Chapter 4\n+    /// (Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Control code point' is defined in terms of the Unicode General\n-    /// Category `Cc`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -675,19 +703,29 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns `true` if this `char` is an extended grapheme character.\n+    /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n     ///\n-    /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n-    /// Category `Grapheme_Extend`.\n+    /// `Grapheme_Extend` is described in [Unicode Standard Annex #29 (Unicode Text\n+    /// Segmentation)][uax29] and specified in the [Unicode Character Database][ucd]\n+    /// [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [uax29]: https://www.unicode.org/reports/tr29/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns `true` if this `char` is numeric.\n+    /// Returns `true` if this `char` has one of the general categories for numbers.\n+    ///\n+    /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n+    /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -713,25 +751,29 @@ impl char {\n         }\n     }\n \n-    /// Returns an iterator that yields the lowercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the lowercase mapping of this `char` as one or more\n+    /// `char`s.\n     ///\n-    /// If a character does not have a lowercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// If this `char` does not have a lowercase mapping, the iterator yields the same `char`.\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its lowercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` has a one-to-one lowercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n+    ///\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///\n@@ -774,25 +816,29 @@ impl char {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Returns an iterator that yields the uppercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n+    /// `char`s.\n+    ///\n+    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n+    ///\n+    /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// If a character does not have an uppercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its uppercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///"}, {"sha": "1ac51291b93d790b8bfaa76c3b6a358da43254e5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -211,7 +211,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// Derive macro generating an impl of the trait `PartialEq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics)]\n+#[allow_internal_unstable(core_intrinsics, structural_match)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n \n /// Trait for equality comparisons which are [equivalence relations](\n@@ -273,7 +273,7 @@ pub trait Eq: PartialEq<Self> {\n /// Derive macro generating an impl of the trait `Eq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics, derive_eq)]\n+#[allow_internal_unstable(core_intrinsics, derive_eq, structural_match)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n \n // FIXME: this struct is used solely by #[derive] to"}, {"sha": "569c667ac0a54b534064d8a4c590edcbf482f58d", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -18,8 +18,13 @@ use crate::ops::{Deref, DerefMut};\n /// stabilized, it is recommended to use a newtype wrapper around an empty\n /// byte array. See the [Nomicon] for details.\n ///\n+/// One could use `std::os::raw::c_void` if they want to support old Rust\n+/// compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n+/// this definition. For more information, please read [RFC 2521].\n+///\n /// [pointer]: ../../std/primitive.pointer.html\n /// [Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n+/// [RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md\n // N.B., for LLVM to recognize the void pointer type and by extension\n //     functions like malloc(), we need to have it represented as i8* in\n //     LLVM bitcode. The enum used here ensures this and prevents misuse\n@@ -29,7 +34,7 @@ use crate::ops::{Deref, DerefMut};\n //     would be uninhabited and at least dereferencing such pointers would\n //     be UB.\n #[repr(u8)]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+#[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {\n     #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n                issue = \"0\")]\n@@ -49,8 +54,10 @@ impl fmt::Debug for c_void {\n /// Basic implementation of a `va_list`.\n // The name is WIP, using `VaListImpl` for now.\n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+              not(target_arch = \"x86_64\")),\n           all(target_arch = \"aarch64\", target_os = \"ios\"),\n+          target_arch = \"wasm32\",\n+          target_arch = \"asmjs\",\n           windows))]\n #[repr(transparent)]\n #[unstable(feature = \"c_variadic\",\n@@ -67,8 +74,10 @@ pub struct VaListImpl<'f> {\n }\n \n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+              not(target_arch = \"x86_64\")),\n           all(target_arch = \"aarch64\", target_os = \"ios\"),\n+          target_arch = \"wasm32\",\n+          target_arch = \"asmjs\",\n           windows))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n@@ -137,38 +146,6 @@ pub struct VaListImpl<'f> {\n     _marker: PhantomData<&'f mut &'f c_void>,\n }\n \n-/// asm.js ABI implementation of a `va_list`.\n-// asm.js uses the PNaCl ABI, which specifies that a `va_list` is\n-// an array of 4 32-bit integers, according to the old PNaCl docs at\n-// https://web.archive.org/web/20130518054430/https://www.chromium.org/nativeclient/pnacl/bitcode-abi#TOC-Derived-Types\n-// and clang does the same in `CreatePNaClABIBuiltinVaListDecl` from `lib/AST/ASTContext.cpp`\n-#[cfg(all(target_arch = \"asmjs\", not(windows)))]\n-#[repr(C)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n-#[lang = \"va_list\"]\n-pub struct VaListImpl<'f> {\n-    inner: [crate::mem::MaybeUninit<i32>; 4],\n-    _marker: PhantomData<&'f mut &'f c_void>,\n-}\n-\n-#[cfg(all(target_arch = \"asmjs\", not(windows)))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n-impl<'f> fmt::Debug for VaListImpl<'f> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unsafe {\n-            write!(f, \"va_list* [{:#x}, {:#x}, {:#x}, {:#x}]\",\n-                   self.inner[0].read(), self.inner[1].read(),\n-                   self.inner[2].read(), self.inner[3].read())\n-        }\n-    }\n-}\n-\n /// A wrapper for a `va_list`\n #[repr(transparent)]\n #[derive(Debug)]\n@@ -178,23 +155,29 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n            issue = \"44930\")]\n pub struct VaList<'a, 'f: 'a> {\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                  not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+                  not(target_arch = \"x86_64\")),\n               all(target_arch = \"aarch64\", target_os = \"ios\"),\n+              target_arch = \"wasm32\",\n+              target_arch = \"asmjs\",\n               windows))]\n     inner: VaListImpl<'f>,\n \n     #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-                  target_arch = \"x86_64\", target_arch = \"asmjs\"),\n+                  target_arch = \"x86_64\"),\n               any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+              not(target_arch = \"wasm32\"),\n+              not(target_arch = \"asmjs\"),\n               not(windows)))]\n     inner: &'a mut VaListImpl<'f>,\n \n     _marker: PhantomData<&'a mut VaListImpl<'f>>,\n }\n \n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+              not(target_arch = \"x86_64\")),\n           all(target_arch = \"aarch64\", target_os = \"ios\"),\n+          target_arch = \"wasm32\",\n+          target_arch = \"asmjs\",\n           windows))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n@@ -212,8 +195,10 @@ impl<'f> VaListImpl<'f> {\n }\n \n #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-              target_arch = \"x86_64\", target_arch = \"asmjs\"),\n+              target_arch = \"x86_64\"),\n           any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+          not(target_arch = \"wasm32\"),\n+          not(target_arch = \"asmjs\"),\n           not(windows)))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\"}, {"sha": "e6e3454b36f810bb96cf2c525059182aa3eb69c9", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -775,10 +775,10 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n                reason = \"recently added\",\n                issue = \"62482\")]\n     pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n-        assert!(!self.has_key, \"attempted to begin a new map entry \\\n-                                without completing the previous one\");\n-\n         self.result = self.result.and_then(|_| {\n+            assert!(!self.has_key, \"attempted to begin a new map entry \\\n+                                    without completing the previous one\");\n+\n             if self.is_pretty() {\n                 if !self.has_fields {\n                     self.fmt.write_str(\"\\n\")?;\n@@ -839,9 +839,9 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n                reason = \"recently added\",\n                issue = \"62482\")]\n     pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n-        assert!(self.has_key, \"attempted to format a map value before its key\");\n-\n         self.result = self.result.and_then(|_| {\n+            assert!(self.has_key, \"attempted to format a map value before its key\");\n+\n             if self.is_pretty() {\n                 let mut slot = None;\n                 let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n@@ -924,9 +924,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n-        assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n+        self.result.and_then(|_| {\n+            assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n \n-        self.result.and_then(|_| self.fmt.write_str(\"}\"))\n+            self.fmt.write_str(\"}\")\n+        })\n     }\n \n     fn is_pretty(&self) -> bool {"}, {"sha": "0e83a282b18f717d056b70a3efbccc24b2e56da4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -108,10 +108,10 @@ pub struct Error;\n /// [`io::Write`]: ../../std/io/trait.Write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n-    /// Writes a slice of bytes into this writer, returning whether the write\n+    /// Writes a string slice into this writer, returning whether the write\n     /// succeeded.\n     ///\n-    /// This method can only succeed if the entire byte slice was successfully\n+    /// This method can only succeed if the entire string slice was successfully\n     /// written, and this method will not return until all data has been\n     /// written or an error occurs.\n     ///\n@@ -1532,12 +1532,10 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n-    ///     assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n-    ///     assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n-    ///     assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n-    /// }\n+    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n+    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n+    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n+    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n     /// ```\n     #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n     pub fn align(&self) -> Option<Alignment> {\n@@ -2027,7 +2025,7 @@ impl<T: ?Sized> Pointer for *const T {\n         if f.alternate() {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n-            if let None = f.width {\n+            if f.width.is_none() {\n                 f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n             }\n         }"}, {"sha": "368a2f16b281e726530a25285c057e5daf80093f", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -114,24 +114,8 @@ pub fn black_box<T>(dummy: T) -> T {\n     // this. LLVM's intepretation of inline assembly is that it's, well, a black\n     // box. This isn't the greatest implementation since it probably deoptimizes\n     // more than we want, but it's so far good enough.\n-    #[cfg(not(any(\n-        target_arch = \"asmjs\",\n-        all(\n-            target_arch = \"wasm32\",\n-            target_os = \"emscripten\"\n-        )\n-    )))]\n     unsafe {\n         asm!(\"\" : : \"r\"(&dummy));\n         return dummy;\n     }\n-\n-    // Not all platforms support inline assembly so try to do something without\n-    // inline assembly which in theory still hinders at least some optimizations\n-    // on those targets. This is the \"best effort\" scenario.\n-    unsafe {\n-        let ret = crate::ptr::read_volatile(&dummy);\n-        crate::mem::forget(dummy);\n-        ret\n-    }\n }"}, {"sha": "4e0f18b88fe0a45e256638704c64e7d135ef2d35", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -696,6 +696,10 @@ extern \"rust-intrinsic\" {\n     /// This will statically either panic, or do nothing.\n     pub fn panic_if_uninhabited<T>();\n \n+    /// Gets a reference to a static `Location` indicating where it was called.\n+    #[cfg(not(bootstrap))]\n+    pub fn caller_location() -> &'static crate::panic::Location<'static>;\n+\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n@@ -874,6 +878,7 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n     ///     // Ensure the original vector is not dropped.\n     ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n     ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,"}, {"sha": "fac6ff0f06b6d86c750d2f680fa83e2fee29476a", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -118,26 +118,16 @@\n //!\n //! let mut counter = Counter::new();\n //!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n-//!\n-//! let x = counter.next().unwrap();\n-//! println!(\"{}\", x);\n+//! assert_eq!(counter.next(), Some(1));\n+//! assert_eq!(counter.next(), Some(2));\n+//! assert_eq!(counter.next(), Some(3));\n+//! assert_eq!(counter.next(), Some(4));\n+//! assert_eq!(counter.next(), Some(5));\n+//! assert_eq!(counter.next(), None);\n //! ```\n //!\n-//! This will print `1` through `5`, each on their own line.\n-//!\n-//! Calling `next()` this way gets repetitive. Rust has a construct which can\n-//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n+//! Calling [`next`] this way gets repetitive. Rust has a construct which can\n+//! call [`next`] on your iterator, until it reaches `None`. Let's go over that\n //! next.\n //!\n //! Also note that `Iterator` provides a default implementation of methods such as `nth` and `fold`\n@@ -253,20 +243,23 @@\n //! ```\n //!\n //! The idiomatic way to write a [`map`] for its side effects is to use a\n-//! `for` loop instead:\n+//! `for` loop or call the [`for_each`] method:\n //!\n //! ```\n //! let v = vec![1, 2, 3, 4, 5];\n //!\n+//! v.iter().for_each(|x| println!(\"{}\", x));\n+//! // or\n //! for x in &v {\n //!     println!(\"{}\", x);\n //! }\n //! ```\n //!\n //! [`map`]: trait.Iterator.html#method.map\n+//! [`for_each`]: trait.Iterator.html#method.for_each\n //!\n-//! The two most common ways to evaluate an iterator are to use a `for` loop\n-//! like this, or using the [`collect`] method to produce a new collection.\n+//! Another common way to evaluate an iterator is to use the [`collect`]\n+//! method to produce a new collection.\n //!\n //! [`collect`]: trait.Iterator.html#method.collect\n //!"}, {"sha": "00a864170583efb921a8e3b6ddc29eca3ae6b269", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -167,7 +167,7 @@ pub trait FromIterator<A>: Sized {\n /// // and we'll implement IntoIterator\n /// impl IntoIterator for MyCollection {\n ///     type Item = i32;\n-///     type IntoIter = ::std::vec::IntoIter<Self::Item>;\n+///     type IntoIter = std::vec::IntoIter<Self::Item>;\n ///\n ///     fn into_iter(self) -> Self::IntoIter {\n ///         self.0.into_iter()"}, {"sha": "7ffc8b3729cb490c1e149b97d5b98bc971df1ef9", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -384,6 +384,9 @@ pub trait Iterator {\n     ///\n     /// In other words, it links two iterators together, in a chain. \ud83d\udd17\n     ///\n+    /// [`once`] is commonly used to adapt a single value into a chain of\n+    /// other kinds of iteration.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -408,9 +411,6 @@ pub trait Iterator {\n     /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n     /// [`IntoIterator`], and so can be passed to `chain()` directly:\n     ///\n-    /// [`IntoIterator`]: trait.IntoIterator.html\n-    /// [`Iterator`]: trait.Iterator.html\n-    ///\n     /// ```\n     /// let s1 = &[1, 2, 3];\n     /// let s2 = &[4, 5, 6];\n@@ -425,6 +425,21 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(&6));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n+    ///\n+    /// If you work with Windows API, you may wish to convert [`OsStr`] to `Vec<u16>`:\n+    ///\n+    /// ```\n+    /// #[cfg(windows)]\n+    /// fn os_str_to_utf16(s: &std::ffi::OsStr) -> Vec<u16> {\n+    ///     use std::os::windows::ffi::OsStrExt;\n+    ///     s.encode_wide().chain(std::iter::once(0)).collect()\n+    /// }\n+    /// ```\n+    ///\n+    /// [`once`]: fn.once.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n@@ -1859,14 +1874,13 @@ pub trait Iterator {\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n-            move |x| {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+            move |(), x| {\n                 if f(x) { LoopState::Continue(()) }\n                 else { LoopState::Break(()) }\n             }\n         }\n-\n-        self.try_for_each(check(f)) == LoopState::Continue(())\n+        self.try_fold((), check(f)) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1913,14 +1927,14 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n-            move |x| {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> LoopState<(), ()> {\n+            move |(), x| {\n                 if f(x) { LoopState::Break(()) }\n                 else { LoopState::Continue(()) }\n             }\n         }\n \n-        self.try_for_each(check(f)) == LoopState::Break(())\n+        self.try_fold((), check(f)) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1972,14 +1986,16 @@ pub trait Iterator {\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> LoopState<(), T> {\n-            move |x| {\n+        fn check<T>(\n+            mut predicate: impl FnMut(&T) -> bool\n+        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+            move |(), x| {\n                 if predicate(&x) { LoopState::Break(x) }\n                 else { LoopState::Continue(()) }\n             }\n         }\n \n-        self.try_for_each(check(predicate)).break_value()\n+        self.try_fold((), check(predicate)).break_value()\n     }\n \n     /// Applies function to the elements of iterator and returns\n@@ -2004,14 +2020,14 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         #[inline]\n-        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut(T) -> LoopState<(), B> {\n-            move |x| match f(x) {\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> LoopState<(), B> {\n+            move |(), x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n                 None => LoopState::Continue(()),\n             }\n         }\n \n-        self.try_for_each(check(f)).break_value()\n+        self.try_fold((), check(f)).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index."}, {"sha": "1b67b05c73021de024b6f38612dffc6f088cb470", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -121,19 +121,19 @@\n #![feature(hexagon_target_feature)]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n-#![feature(mem_take)]\n #![feature(associated_type_bounds)]\n \n #[prelude_import]\n #[allow(unused)]\n use prelude::v1::*;\n \n+#[cfg(not(test))] // See #65860\n #[macro_use]\n mod macros;\n \n@@ -181,40 +181,51 @@ pub mod hint;\n \n /* Core language traits */\n \n+#[cfg(not(test))] // See #65860\n pub mod marker;\n pub mod ops;\n+#[cfg(not(test))] // See #65860\n pub mod cmp;\n+#[cfg(not(test))] // See #65860\n pub mod clone;\n+#[cfg(not(test))] // See #65860\n pub mod default;\n pub mod convert;\n pub mod borrow;\n \n /* Core types and methods on primitives */\n \n pub mod any;\n+#[cfg(not(test))] // See #65860\n pub mod array;\n pub mod ascii;\n pub mod sync;\n pub mod cell;\n pub mod char;\n pub mod panic;\n pub mod panicking;\n+#[cfg(not(test))] // See #65860\n pub mod pin;\n+#[cfg(not(test))] // See #65860\n pub mod iter;\n pub mod option;\n pub mod raw;\n pub mod result;\n pub mod ffi;\n \n pub mod slice;\n+#[cfg(not(test))] // See #65860\n pub mod str;\n+#[cfg(not(test))] // See #65860\n pub mod hash;\n+#[cfg(not(test))] // See #65860\n pub mod fmt;\n pub mod time;\n \n pub mod unicode;\n \n /* Async */\n+#[cfg(not(test))] // See #65860\n pub mod future;\n pub mod task;\n "}, {"sha": "8ccd31c95d51030dd88acd71ffc0bdf662457965", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 103, "deletions": 22, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,8 +1,9 @@\n /// Panics the current thread.\n ///\n /// For details, see `std::macros`.\n+#[cfg(bootstrap)]\n #[macro_export]\n-#[allow_internal_unstable(core_panic)]\n+#[allow_internal_unstable(core_panic, panic_internals)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -20,6 +21,38 @@ macro_rules! panic {\n     });\n }\n \n+/// Panics the current thread.\n+///\n+/// For details, see `std::macros`.\n+#[cfg(not(bootstrap))]\n+#[macro_export]\n+#[allow_internal_unstable(core_panic, panic_internals)]\n+#[stable(feature = \"core\", since = \"1.6.0\")]\n+macro_rules! panic {\n+    () => (\n+        $crate::panic!(\"explicit panic\")\n+    );\n+    ($msg:expr) => ({\n+        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n+            $crate::file!(),\n+            $crate::line!(),\n+            $crate::column!(),\n+        );\n+        $crate::panicking::panic($msg, LOC)\n+    });\n+    ($msg:expr,) => (\n+        $crate::panic!($msg)\n+    );\n+    ($fmt:expr, $($arg:tt)+) => ({\n+        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n+            $crate::file!(),\n+            $crate::line!(),\n+            $crate::column!(),\n+        );\n+        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+), LOC)\n+    });\n+}\n+\n /// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their\n@@ -238,6 +271,33 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n+/// Returns whether the given expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(matches_macro)]\n+///\n+/// let foo = 'f';\n+/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n+///\n+/// let bar = Some(4);\n+/// assert!(matches!(bar, Some(x) if x > 2));\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"matches_macro\", issue = \"65721\")]\n+macro_rules! matches {\n+    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n+        match $expression {\n+            $( $pattern )|+ $( if $guard )? => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n /// Unwraps a result or propagates its error.\n ///\n /// The `?` operator was added to replace `try!` and should be used instead.\n@@ -465,7 +525,7 @@ macro_rules! writeln {\n /// The unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\n /// will cause undefined behavior if the code is reached.\n ///\n-/// [`panic!`]:  ../std/macro.panic.html\n+/// [`panic!`]: ../std/macro.panic.html\n /// [`unreachable_unchecked`]: ../std/hint/fn.unreachable_unchecked.html\n /// [`std::hint`]: ../std/hint/index.html\n ///\n@@ -474,6 +534,7 @@ macro_rules! writeln {\n /// This will always [`panic!`]\n ///\n /// [`panic!`]: ../std/macro.panic.html\n+///\n /// # Examples\n ///\n /// Match arms:\n@@ -519,54 +580,74 @@ macro_rules! unreachable {\n     });\n }\n \n-/// Indicates unfinished code.\n+/// Indicates unfinished code by panicking with a message of \"not yet implemented\".\n ///\n-/// This can be useful if you are prototyping and are just looking to have your\n-/// code type-check, or if you're implementing a trait that requires multiple\n-/// methods, and you're only planning on using one of them.\n+/// This allows the your code to type-check, which is useful if you are prototyping or\n+/// implementing a trait that requires multiple methods which you don't plan of using all of.\n+///\n+/// There is no difference between `unimplemented!` and `todo!` apart from the\n+/// name.\n ///\n /// # Panics\n ///\n-/// This will always [panic!](macro.panic.html)\n+/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n+/// shorthand for `panic!` with a fixed, specific message.\n+///\n+/// Like `panic!`, this macro has a second form for displaying custom values.\n ///\n /// # Examples\n ///\n /// Here's an example of some in-progress code. We have a trait `Foo`:\n ///\n /// ```\n /// trait Foo {\n-///     fn bar(&self);\n+///     fn bar(&self) -> u8;\n ///     fn baz(&self);\n+///     fn qux(&self) -> Result<u64, ()>;\n /// }\n /// ```\n ///\n-/// We want to implement `Foo` on one of our types, but we also want to work on\n-/// just `bar()` first. In order for our code to compile, we need to implement\n-/// `baz()`, so we can use `unimplemented!`:\n+/// We want to implement `Foo` for 'MyStruct', but so far we only know how to\n+/// implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n+/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n+/// to allow our code to compile.\n+///\n+/// In the meantime, we want to have our program stop running once these\n+/// unimplemented functions are reached.\n ///\n /// ```\n /// # trait Foo {\n-/// #     fn bar(&self);\n+/// #     fn bar(&self) -> u8;\n /// #     fn baz(&self);\n+/// #     fn qux(&self) -> Result<u64, ()>;\n /// # }\n /// struct MyStruct;\n ///\n /// impl Foo for MyStruct {\n-///     fn bar(&self) {\n-///         // implementation goes here\n+///     fn bar(&self) -> u8 {\n+///         1 + 1\n ///     }\n ///\n ///     fn baz(&self) {\n-///         // let's not worry about implementing baz() for now\n+///         // We aren't sure how to even start writing baz yet,\n+///         // so we have no logic here at all.\n+///         // This will display \"thread 'main' panicked at 'not yet implemented'\".\n ///         unimplemented!();\n ///     }\n+///\n+///     fn qux(&self) -> Result<u64, ()> {\n+///         let n = self.bar();\n+///         // We have some logic here,\n+///         // so we can use unimplemented! to display what we have so far.\n+///         // This will display:\n+///         // \"thread 'main' panicked at 'not yet implemented: we need to divide by 2'\".\n+///         unimplemented!(\"we need to divide by {}\", n);\n+///     }\n /// }\n ///\n /// fn main() {\n ///     let s = MyStruct;\n ///     s.bar();\n-///\n-///     // we aren't even using baz() yet, so this is fine.\n /// }\n /// ```\n #[macro_export]\n@@ -579,8 +660,10 @@ macro_rules! unimplemented {\n /// Indicates unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck. `todo!` works exactly like `unimplemented!`. The only\n-/// difference between the two macros is the name.\n+/// code typecheck.\n+///\n+/// There is no difference between `unimplemented!` and `todo!` apart from the\n+/// name.\n ///\n /// # Panics\n ///\n@@ -602,8 +685,6 @@ macro_rules! unimplemented {\n /// `baz()`, so we can use `todo!`:\n ///\n /// ```\n-/// #![feature(todo_macro)]\n-///\n /// # trait Foo {\n /// #     fn bar(&self);\n /// #     fn baz(&self);\n@@ -629,7 +710,7 @@ macro_rules! unimplemented {\n /// }\n /// ```\n #[macro_export]\n-#[unstable(feature = \"todo_macro\", issue = \"59277\")]\n+#[stable(feature = \"todo_macro\", since = \"1.39.0\")]\n macro_rules! todo {\n     () => (panic!(\"not yet implemented\"));\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));"}, {"sha": "a25573feabb2bb02b7366d52d04f886b39ac56cd", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -126,6 +126,85 @@ pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `PartialEq` automatically implements this trait,\n+/// *regardless* of whether its type-parameters implement `Eq`.\n+///\n+/// If a `const` item contains some type that does not implement this trait,\n+/// then that type either (1.) does not implement `PartialEq` (which means the\n+/// constant will not provide that comparison method, which code generation\n+/// assumes is available), or (2.) it implements *its own* version of\n+/// `PartialEq` (which we assume does not conform to a structural-equality\n+/// comparison).\n+///\n+/// In either of the two scenarios above, we reject usage of such a constant in\n+/// a pattern match.\n+///\n+/// See also the [structural match RFC][RFC1445], and [issue 63438][] which\n+/// motivated migrating from attribute-based design to this trait.\n+///\n+/// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n+/// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {\n+    // Empty.\n+}\n+\n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `Eq` automatically implements this trait, *regardless*\n+/// of whether its type-parameters implement `Eq`.\n+///\n+/// This is a hack to workaround a limitation in our type-system.\n+///\n+/// Background:\n+///\n+/// We want to require that types of consts used in pattern matches\n+/// have the attribute `#[derive(PartialEq, Eq)]`.\n+///\n+/// In a more ideal world, we could check that requirement by just checking that\n+/// the given type implements both (1.) the `StructuralPartialEq` trait *and*\n+/// (2.) the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n+/// and be a case that we want the compiler to accept, and yet the constant's\n+/// type fails to implement `Eq`.\n+///\n+/// Namely, a case like this:\n+///\n+/// ```rust\n+/// #[derive(PartialEq, Eq)]\n+/// struct Wrap<X>(X);\n+/// fn higher_order(_: &()) { }\n+/// const CFN: Wrap<fn(&())> = Wrap(higher_order);\n+/// fn main() {\n+///     match CFN {\n+///         CFN => {}\n+///         _ => {}\n+///     }\n+/// }\n+/// ```\n+///\n+/// (The problem in the above code is that `Wrap<fn(&())>` does not implement\n+/// `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those\n+/// traits.)\n+///\n+/// Therefore, we cannot rely on naive check for `StructuralPartialEq` and\n+/// mere `Eq`.\n+///\n+/// As a hack to work around this, we use two separate traits injected by each\n+/// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n+/// that both of them are present as part of structural-match checking.\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(Eq)]`\")]\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {\n+    // Empty.\n+}\n+\n /// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n@@ -437,6 +516,14 @@ macro_rules! impls{\n                 $t\n             }\n         }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralPartialEq for $t<T> { }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralEq for $t<T> { }\n         )\n }\n "}, {"sha": "792ce9dfad419b0770094bef9c5af8c02c081130", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -5,12 +5,12 @@ use crate::mem::ManuallyDrop;\n ///\n /// # Initialization invariant\n ///\n-/// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type. For example, a variable of reference type must\n-/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n-/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n-/// ever gets used to access memory:\n+/// The compiler, in general, assumes that a variable is properly initialized\n+/// according to the requirements of the variable's type. For example, a variable of\n+/// reference type must be aligned and non-NULL. This is an invariant that must\n+/// *always* be upheld, even in unsafe code. As a consequence, zero-initializing a\n+/// variable of reference type causes instantaneous [undefined behavior][ub],\n+/// no matter whether that reference ever gets used to access memory:\n ///\n /// ```rust,no_run\n /// # #![allow(invalid_value)]"}, {"sha": "c7da56aad309a976f9291effb656acda9364a1dc", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -236,7 +236,7 @@ pub fn forget_unsized<T: ?Sized>(t: T) {\n /// ```\n ///\n /// [alignment]: ./fn.align_of.html\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn size_of<T>() -> usize {\n@@ -328,7 +328,7 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n ///\n /// assert_eq!(4, mem::align_of::<i32>());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn align_of<T>() -> usize {\n@@ -368,15 +368,17 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n /// make a difference in release builds (where a loop that has no side-effects\n /// is easily detected and eliminated), but is often a big win for debug builds.\n ///\n-/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n-/// can be reduced to some small number of drop_in_place calls, using this is\n-/// unnecessary. In particular note that you can drop_in_place a slice, and that\n+/// Note that [`drop_in_place`] already performs this check, so if your workload\n+/// can be reduced to some small number of [`drop_in_place`] calls, using this is\n+/// unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n /// will do a single needs_drop check for all the values.\n ///\n /// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n-/// needs_drop explicitly. Types like `HashMap`, on the other hand, have to drop\n+/// `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n /// values one at a time and should use this API.\n ///\n+/// [`drop_in_place`]: ../ptr/fn.drop_in_place.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n ///\n /// # Examples\n ///\n@@ -518,8 +520,6 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// A simple example:\n ///\n /// ```\n-/// #![feature(mem_take)]\n-///\n /// use std::mem;\n ///\n /// let mut v: Vec<i32> = vec![1, 2];\n@@ -550,8 +550,6 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// `self`, allowing it to be returned:\n ///\n /// ```\n-/// #![feature(mem_take)]\n-///\n /// use std::mem;\n ///\n /// # struct Buffer<T> { buf: Vec<T> }\n@@ -570,7 +568,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n ///\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n-#[unstable(feature = \"mem_take\", issue = \"61129\")]\n+#[stable(feature = \"mem_take\", since = \"1.40.0\")]\n pub fn take<T: Default>(dest: &mut T) -> T {\n     replace(dest, T::default())\n }"}, {"sha": "ed89852dc48da63010be52885842dbac543a2a82", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -143,13 +143,12 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n /// > not a bound for the true error, but bounds the difference between the approximation z and\n /// > the best possible approximation that uses p bits of significand.)\n pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n-    let slop;\n-    if f <= &Big::from_u64(T::MAX_SIG) {\n+    let slop = if f <= &Big::from_u64(T::MAX_SIG) {\n         // The cases abs(e) < log5(2^N) are in fast_path()\n-        slop = if e >= 0 { 0 } else { 3 };\n+        if e >= 0 { 0 } else { 3 }\n     } else {\n-        slop = if e >= 0 { 1 } else { 4 };\n-    }\n+        if e >= 0 { 1 } else { 4 }\n+    };\n     let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n     let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n     let lowbits: i64 = (z.f % exp_p_n) as i64;"}, {"sha": "5730088c4d9a95a9f21f48609074c677138385f6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -466,11 +466,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_be_bytes();\n     /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 4] {\n         self.to_bits().to_be_bytes()\n@@ -482,11 +481,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_le_bytes();\n     /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 4] {\n         self.to_bits().to_le_bytes()\n@@ -504,7 +502,6 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f32.to_ne_bytes();\n     /// assert_eq!(\n     ///     bytes,\n@@ -515,7 +512,7 @@ impl f32 {\n     ///     }\n     /// );\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_ne_bytes(self) -> [u8; 4] {\n         self.to_bits().to_ne_bytes()\n@@ -526,11 +523,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_be_bytes(bytes))\n@@ -541,11 +537,10 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_le_bytes(bytes))\n@@ -563,15 +558,14 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     ///     [0x41, 0x48, 0x00, 0x00]\n     /// } else {\n     ///     [0x00, 0x00, 0x48, 0x41]\n     /// });\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))"}, {"sha": "2bdeda340dce01c19d7d60c2aaa08c1c5a6baaea", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -479,11 +479,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_be_bytes();\n     /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_be_bytes(self) -> [u8; 8] {\n         self.to_bits().to_be_bytes()\n@@ -495,11 +494,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_le_bytes();\n     /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_le_bytes(self) -> [u8; 8] {\n         self.to_bits().to_le_bytes()\n@@ -517,7 +515,6 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let bytes = 12.5f64.to_ne_bytes();\n     /// assert_eq!(\n     ///     bytes,\n@@ -528,7 +525,7 @@ impl f64 {\n     ///     }\n     /// );\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn to_ne_bytes(self) -> [u8; 8] {\n         self.to_bits().to_ne_bytes()\n@@ -539,11 +536,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_be_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_be_bytes(bytes))\n@@ -554,11 +550,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_le_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_le_bytes(bytes))\n@@ -576,15 +571,14 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(float_to_from_bytes)]\n     /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n     /// } else {\n     ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n     /// });\n     /// assert_eq!(value, 12.5);\n     /// ```\n-    #[unstable(feature = \"float_to_from_bytes\", issue = \"60446\")]\n+    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n     #[inline]\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))"}, {"sha": "b4ade70414462cd45704c47623b16fb9134751b6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -252,7 +252,7 @@ Basic usage:\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n+            #[inline(always)]\n             #[rustc_promotable]\n             pub const fn min_value() -> Self {\n                 !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n@@ -271,7 +271,7 @@ Basic usage:\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline]\n+            #[inline(always)]\n             #[rustc_promotable]\n             pub const fn max_value() -> Self {\n                 !Self::min_value()\n@@ -938,7 +938,9 @@ Basic usage:\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n-\"::max_value());\",\n+\"::max_value());\n+assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_add(-1), \", stringify!($SelfT),\n+\"::min_value());\",\n $EndFeature, \"\n ```\"),\n \n@@ -952,7 +954,6 @@ $EndFeature, \"\n             }\n         }\n \n-\n         doc_comment! {\n             concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n numeric bounds instead of overflowing.\n@@ -964,7 +965,9 @@ Basic usage:\n ```\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n-\"::min_value());\",\n+\"::min_value());\n+assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_sub(-1), \", stringify!($SelfT),\n+\"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1055,7 +1058,7 @@ $EndFeature, \"\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or_else(|| {\n-                    if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n+                    if (self < 0) == (rhs < 0) {\n                         Self::max_value()\n                     } else {\n                         Self::min_value()\n@@ -1861,7 +1864,7 @@ if `self < 0`, this is equal to round towards +/- infinity.\n \n # Panics\n \n-This function will panic if `rhs` is 0.\n+This function will panic if `rhs` is 0 or the division results in overflow.\n \n # Examples\n \n@@ -1900,7 +1903,7 @@ This is done as if by the Euclidean division algorithm -- given\n \n # Panics\n \n-This function will panic if `rhs` is 0.\n+This function will panic if `rhs` is 0 or the division results in overflow.\n \n # Examples\n \n@@ -2308,7 +2311,7 @@ Basic usage:\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_promotable]\n-            #[inline]\n+            #[inline(always)]\n             pub const fn min_value() -> Self { 0 }\n         }\n \n@@ -2325,7 +2328,7 @@ stringify!($MaxV), \");\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_promotable]\n-            #[inline]\n+            #[inline(always)]\n             pub const fn max_value() -> Self { !0 }\n         }\n \n@@ -3691,6 +3694,10 @@ Since, for the positive integers, all common\n definitions of division are equal, this\n is exactly equal to `self / rhs`.\n \n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n # Examples\n \n Basic usage:\n@@ -3716,6 +3723,10 @@ Since, for the positive integers, all common\n definitions of division are equal, this\n is exactly equal to `self % rhs`.\n \n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n # Examples\n \n Basic usage:\n@@ -3746,8 +3757,8 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n-            pub fn is_power_of_two(self) -> bool {\n-                (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n+            pub const fn is_power_of_two(self) -> bool {\n+                self.count_ones() == 1\n             }\n         }\n "}, {"sha": "5fe9895d8d24f94543955286541f66ae464ec06f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -437,7 +437,7 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the end of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as the `>>` shifting\n+            /// Please note this isn't the same operation as the `<<` shifting\n             /// operator!\n             ///\n             /// # Examples\n@@ -463,7 +463,7 @@ assert_eq!(n.trailing_zeros(), 3);\n             /// wrapping the truncated bits to the beginning of the resulting\n             /// integer.\n             ///\n-            /// Please note this isn't the same operation as the `<<` shifting\n+            /// Please note this isn't the same operation as the `>>` shifting\n             /// operator!\n             ///\n             /// # Examples"}, {"sha": "e8f35f8cf245025925decf4771c869b8213923d6", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -5,7 +5,7 @@\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n-#[rustc_on_unimplemented(\n+#[cfg_attr(bootstrap, rustc_on_unimplemented(\n    on(all(\n        any(from_method=\"from_error\", from_method=\"from_ok\"),\n        from_desugaring=\"QuestionMark\"),\n@@ -17,7 +17,20 @@\n       message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\",\n       label=\"the `?` operator cannot be applied to type `{Self}`\")\n-)]\n+))]\n+#[cfg_attr(not(bootstrap), rustc_on_unimplemented(\n+on(all(\n+any(from_method=\"from_error\", from_method=\"from_ok\"),\n+from_desugaring=\"QuestionMark\"),\n+message=\"the `?` operator can only be used in {ItemContext} \\\n+               that returns `Result` or `Option` \\\n+               (or another type that implements `{Try}`)\",\n+label=\"cannot use the `?` operator in {ItemContext} that returns `{Self}`\"),\n+on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n+message=\"the `?` operator can only be applied to values \\\n+               that implement `{Try}`\",\n+label=\"the `?` operator cannot be applied to type `{Self}`\")\n+))]\n #[doc(alias = \"?\")]\n pub trait Try {\n     /// The type of this value when viewed as successful."}, {"sha": "d29147645f7ef8d7bfbf30442b194b23c80790f3", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -76,7 +76,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n /// ```\n /// # #![feature(dispatch_from_dyn, unsize)]\n /// # use std::{ops::DispatchFromDyn, marker::Unsize};\n-/// # struct Rc<T: ?Sized>(::std::rc::Rc<T>);\n+/// # struct Rc<T: ?Sized>(std::rc::Rc<T>);\n /// impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T>\n /// where\n ///     T: Unsize<U>,"}, {"sha": "f0ac5e749f6b3825d00e01d71dc61914e11856ff", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -46,7 +46,7 @@\n //! # Options and pointers (\"nullable\" pointers)\n //!\n //! Rust's pointer types must always point to a valid location; there are\n-//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n+//! no \"null\" references. Instead, Rust has *optional* pointers, like\n //! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n //! The following example uses [`Option`] to create an optional box of\n@@ -64,7 +64,7 @@\n //!\n //! fn check_optional(optional: Option<Box<i32>>) {\n //!     match optional {\n-//!         Some(ref p) => println!(\"has value {}\", p),\n+//!         Some(p) => println!(\"has value {}\", p),\n //!         None => println!(\"has no value\"),\n //!     }\n //! }\n@@ -83,7 +83,7 @@\n //! let msg = Some(\"howdy\");\n //!\n //! // Take a reference to the contained string\n-//! if let Some(ref m) = msg {\n+//! if let Some(m) = &msg {\n //!     println!(\"{}\", *m);\n //! }\n //!\n@@ -395,10 +395,10 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, def: T) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Some(x) => x,\n-            None => def,\n+            None => default,\n         }\n     }\n \n@@ -837,9 +837,8 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n     pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n-        match *self {\n-            None => *self = Some(f()),\n-            _ => (),\n+        if let None = *self {\n+            *self = Some(f());\n         }\n \n         match *self {\n@@ -1102,7 +1101,6 @@ impl<T: Default> Option<T> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref> Option<T> {\n     /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n     ///\n@@ -1114,20 +1112,18 @@ impl<T: Deref> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n-    ///\n     /// let x: Option<String> = Some(\"hey\".to_owned());\n     /// assert_eq!(x.as_deref(), Some(\"hey\"));\n     ///\n     /// let x: Option<String> = None;\n     /// assert_eq!(x.as_deref(), None);\n     /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n     pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: DerefMut> Option<T> {\n     /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n     ///\n@@ -1137,14 +1133,13 @@ impl<T: DerefMut> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inner_deref)]\n-    ///\n     /// let mut x: Option<String> = Some(\"hey\".to_owned());\n     /// assert_eq!(x.as_deref_mut().map(|x| {\n     ///     x.make_ascii_uppercase();\n     ///     x\n     /// }), Some(\"HEY\".to_owned().as_mut_str()));\n     /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n     pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n@@ -1572,7 +1567,6 @@ impl<T> Option<Option<T>> {\n     /// # Examples\n     /// Basic usage:\n     /// ```\n-    /// #![feature(option_flattening)]\n     /// let x: Option<Option<u32>> = Some(Some(6));\n     /// assert_eq!(Some(6), x.flatten());\n     ///\n@@ -1584,13 +1578,12 @@ impl<T> Option<Option<T>> {\n     /// ```\n     /// Flattening once only removes one level of nesting:\n     /// ```\n-    /// #![feature(option_flattening)]\n     /// let x: Option<Option<Option<u32>>> = Some(Some(Some(6)));\n     /// assert_eq!(Some(Some(6)), x.flatten());\n     /// assert_eq!(Some(6), x.flatten().flatten());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"option_flattening\", issue = \"60258\")]\n+    #[stable(feature = \"option_flattening\", since = \"1.40.0\")]\n     pub fn flatten(self) -> Option<T> {\n         self.and_then(convert::identity)\n     }"}, {"sha": "51bbf3a8fd221bf4cb2f120a6db4f45a9550433b", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -35,7 +35,7 @@ use crate::fmt;\n pub struct PanicInfo<'a> {\n     payload: &'a (dyn Any + Send),\n     message: Option<&'a fmt::Arguments<'a>>,\n-    location: Location<'a>,\n+    location: &'a Location<'a>,\n }\n \n impl<'a> PanicInfo<'a> {\n@@ -45,11 +45,16 @@ impl<'a> PanicInfo<'a> {\n                 issue = \"0\")]\n     #[doc(hidden)]\n     #[inline]\n-    pub fn internal_constructor(message: Option<&'a fmt::Arguments<'a>>,\n-                                location: Location<'a>)\n-                                -> Self {\n+    pub fn internal_constructor(\n+        message: Option<&'a fmt::Arguments<'a>>,\n+        location: &'a Location<'a>,\n+    ) -> Self {\n         struct NoPayload;\n-        PanicInfo { payload: &NoPayload, location, message }\n+        PanicInfo {\n+            location,\n+            message,\n+            payload: &NoPayload,\n+        }\n     }\n \n     #[doc(hidden)]\n@@ -162,6 +167,7 @@ impl fmt::Display for PanicInfo<'_> {\n ///\n /// panic!(\"Normal panic\");\n /// ```\n+#[cfg_attr(not(bootstrap), lang = \"panic_location\")]\n #[derive(Debug)]\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct Location<'a> {\n@@ -176,7 +182,7 @@ impl<'a> Location<'a> {\n                           and related macros\",\n                 issue = \"0\")]\n     #[doc(hidden)]\n-    pub fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n+    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n         Location { file, line, col }\n     }\n "}, {"sha": "685b749776b1dcca7567903dde3a2083b1f212b9", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -29,6 +29,7 @@\n use crate::fmt;\n use crate::panic::{Location, PanicInfo};\n \n+#[cfg(bootstrap)]\n #[cold]\n // never inline unless panic_immediate_abort to avoid code\n // bloat at the call sites as much as possible\n@@ -49,6 +50,27 @@ pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n }\n \n+#[cfg(not(bootstrap))]\n+#[cold]\n+// never inline unless panic_immediate_abort to avoid code\n+// bloat at the call sites as much as possible\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[lang = \"panic\"]\n+pub fn panic(expr: &str, location: &Location<'_>) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n+    // reduce size overhead. The format_args! macro uses str's Display trait to\n+    // write expr, which calls Formatter::pad, which must accommodate string\n+    // truncation and padding (even though none is used here). Using\n+    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n+    // output binary, saving up to a few kilobytes.\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), location)\n+}\n+\n+#[cfg(bootstrap)]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[lang = \"panic_bounds_check\"]\n@@ -62,6 +84,22 @@ fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n                            len, index), file_line_col)\n }\n \n+#[cfg(not(bootstrap))]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[lang = \"panic_bounds_check\"]\n+fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    panic_fmt(\n+        format_args!(\"index out of bounds: the len is {} but the index is {}\", len, index),\n+        location\n+    )\n+}\n+\n+#[cfg(bootstrap)]\n #[cold]\n #[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n #[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n@@ -77,9 +115,26 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u3\n     }\n \n     let (file, line, col) = *file_line_col;\n-    let pi = PanicInfo::internal_constructor(\n-        Some(&fmt),\n-        Location::internal_constructor(file, line, col),\n-    );\n+    let location = Location::internal_constructor(file, line, col);\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), &location);\n+    unsafe { panic_impl(&pi) }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[cold]\n+#[cfg_attr(not(feature=\"panic_immediate_abort\"),inline(never))]\n+#[cfg_attr(    feature=\"panic_immediate_abort\" ,inline)]\n+pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        unsafe { super::intrinsics::abort() }\n+    }\n+\n+    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    extern \"Rust\" {\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n+    }\n+\n+    let pi = PanicInfo::internal_constructor(Some(&fmt), location);\n     unsafe { panic_impl(&pi) }\n }"}, {"sha": "3cc0a1cd75e88f393dafa92680dcb0b807e048f3", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -188,7 +188,7 @@ unsafe fn real_drop_in_place<T: ?Sized>(to_drop: &mut T) {\n /// let p: *const i32 = ptr::null();\n /// assert!(p.is_null());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn null<T>() -> *const T { 0 as *const T }\n@@ -203,7 +203,7 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n /// let p: *mut i32 = ptr::null_mut();\n /// assert!(p.is_null());\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_promotable]\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n@@ -2732,31 +2732,29 @@ impl<T: ?Sized> Eq for *mut T {}\n /// impl Trait for Wrapper {}\n /// impl Trait for i32 {}\n ///\n-/// fn main() {\n-///     let wrapper = Wrapper { member: 10 };\n-///\n-///     // Pointers have equal addresses.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as *const Wrapper as *const u8,\n-///         &wrapper.member as *const i32 as *const u8\n-///     ));\n-///\n-///     // Objects have equal addresses, but `Trait` has different implementations.\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait,\n-///         &wrapper.member as &dyn Trait,\n-///     ));\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait,\n-///     ));\n-///\n-///     // Converting the reference to a `*const u8` compares by address.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n-///     ));\n-/// }\n+/// let wrapper = Wrapper { member: 10 };\n+///\n+/// // Pointers have equal addresses.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as *const Wrapper as *const u8,\n+///     &wrapper.member as *const i32 as *const u8\n+/// ));\n+///\n+/// // Objects have equal addresses, but `Trait` has different implementations.\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait,\n+///     &wrapper.member as &dyn Trait,\n+/// ));\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait,\n+/// ));\n+///\n+/// // Converting the reference to a `*const u8` compares by address.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n+/// ));\n /// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n #[inline]"}, {"sha": "cdada1252d2bfc656e353eccc742cad5e2a2fcf1", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 82, "deletions": 68, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -28,7 +28,7 @@ use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub, is_aligned_and_not_null};\n use crate::isize;\n use crate::iter::*;\n-use crate::ops::{FnMut, Try, self};\n+use crate::ops::{FnMut, Range, self};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::result::Result;\n@@ -63,6 +63,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n+    #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n         unsafe {\n@@ -406,6 +407,86 @@ impl<T> [T] {\n         self as *mut [T] as *mut T\n     }\n \n+    /// Returns the two raw pointers spanning the slice.\n+    ///\n+    /// The returned range is half-open, which means that the end pointer\n+    /// points *one past* the last element of the slice. This way, an empty\n+    /// slice is represented by two equal pointers, and the difference between\n+    /// the two pointers represents the size of the size.\n+    ///\n+    /// See [`as_ptr`] for warnings on using these pointers. The end pointer\n+    /// requires extra caution, as it does not point to a valid element in the\n+    /// slice.\n+    ///\n+    /// This function is useful for interacting with foreign interfaces which\n+    /// use two pointers to refer to a range of elements in memory, as is\n+    /// common in C++.\n+    ///\n+    /// It can also be useful to check if a pointer to an element refers to an\n+    /// element of this slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_range)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let x = &a[1] as *const _;\n+    /// let y = &5 as *const _;\n+    ///\n+    /// assert!(a.as_ptr_range().contains(&x));\n+    /// assert!(!a.as_ptr_range().contains(&y));\n+    /// ```\n+    ///\n+    /// [`as_ptr`]: #method.as_ptr\n+    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[inline]\n+    pub fn as_ptr_range(&self) -> Range<*const T> {\n+        // The `add` here is safe, because:\n+        //\n+        //   - Both pointers are part of the same object, as pointing directly\n+        //     past the object also counts.\n+        //\n+        //   - The size of the slice is never larger than isize::MAX bytes, as\n+        //     noted here:\n+        //       - https://github.com/rust-lang/unsafe-code-guidelines/issues/102#issuecomment-473340447\n+        //       - https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+        //       - https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#safety\n+        //     (This doesn't seem normative yet, but the very same assumption is\n+        //     made in many places, including the Index implementation of slices.)\n+        //\n+        //   - There is no wrapping around involved, as slices do not wrap past\n+        //     the end of the address space.\n+        //\n+        // See the documentation of pointer::add.\n+        let start = self.as_ptr();\n+        let end = unsafe { start.add(self.len()) };\n+        start..end\n+    }\n+\n+    /// Returns the two unsafe mutable pointers spanning the slice.\n+    ///\n+    /// The returned range is half-open, which means that the end pointer\n+    /// points *one past* the last element of the slice. This way, an empty\n+    /// slice is represented by two equal pointers, and the difference between\n+    /// the two pointers represents the size of the size.\n+    ///\n+    /// See [`as_mut_ptr`] for warnings on using these pointers. The end\n+    /// pointer requires extra caution, as it does not point to a valid element\n+    /// in the slice.\n+    ///\n+    /// This function is useful for interacting with foreign interfaces which\n+    /// use two pointers to refer to a range of elements in memory, as is\n+    /// common in C++.\n+    ///\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[inline]\n+    pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n+        // See as_ptr_range() above for why `add` here is safe.\n+        let start = self.as_mut_ptr();\n+        let end = unsafe { start.add(self.len()) };\n+        start..end\n+    }\n+\n     /// Swaps two elements in the slice.\n     ///\n     /// # Arguments\n@@ -3180,39 +3261,6 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n-            #[inline]\n-            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // manual unrolling is needed when there are conditional exits from the loop\n-                let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n-                let mut accum = init;\n-                while let Some(x) = self.next() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n-\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -3283,40 +3331,6 @@ macro_rules! iterator {\n                     Some(next_back_unchecked!(self))\n                 }\n             }\n-\n-            #[inline]\n-            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // manual unrolling is needed when there are conditional exits from the loop\n-                let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                    // inlining is_empty everywhere makes a huge performance difference\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n-                let mut accum = init;\n-                while let Some(x) = self.next_back() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n         }\n \n         #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "f67012d8f2fceb72abe0ce67b0242296b255392b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -176,15 +176,15 @@ Section: Creating a string\n /// ```\n /// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n ///     loop {\n-///         match ::std::str::from_utf8(input) {\n+///         match std::str::from_utf8(input) {\n ///             Ok(valid) => {\n ///                 push(valid);\n ///                 break\n ///             }\n ///             Err(error) => {\n ///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n ///                 unsafe {\n-///                     push(::std::str::from_utf8_unchecked(valid))\n+///                     push(std::str::from_utf8_unchecked(valid))\n ///                 }\n ///                 push(\"\\u{FFFD}\");\n ///\n@@ -2167,6 +2167,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n     // SAFETY: const sound because we transmute two types with the same layout\n+    #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n         #[repr(C)]"}, {"sha": "73d5abf1aed2378a27c50a8c56fbc271a9cfb889", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 119, "deletions": 95, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -18,11 +18,11 @@\n //!\n //! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n-//! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n+//! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n //!\n //! [`Ordering`]: enum.Ordering.html\n //!\n-//! [1]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n+//! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n //! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n@@ -113,8 +113,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n \n@@ -160,14 +160,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -177,14 +177,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -193,7 +193,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -202,10 +202,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -217,8 +217,8 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// operations synchronize other memory while additionally preserving a total order of such\n /// operations across all threads.\n ///\n-/// Rust's memory orderings are [the same as\n-/// LLVM's](https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n+/// Rust's memory orderings are [the same as those of\n+/// C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n ///\n /// For more information see the [nomicon].\n ///\n@@ -231,9 +231,9 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n     ///\n-    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    /// Corresponds to [`memory_order_relaxed`] in C++20.\n     ///\n-    /// [`Monotonic`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous operations become ordered\n@@ -246,11 +246,12 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a store.\n     ///\n-    /// Corresponds to LLVM's [`Release`] ordering.\n+    /// Corresponds to [`memory_order_release`] in C++20.\n     ///\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Release`]: #variant.Release\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, if the loaded value was written by a store operation with\n@@ -263,48 +264,49 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a load.\n     ///\n-    /// Corresponds to LLVM's [`Acquire`] ordering.\n+    /// Corresponds to [`memory_order_acquire`] in C++20.\n     ///\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// Has the effects of both [`Acquire`] and [`Release`] together:\n     /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n     ///\n     /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n     /// not performing any store and hence it has just [`Acquire`] ordering. However,\n-    /// [`AcqRel`][`AcquireRelease`] will never perform [`Relaxed`] accesses.\n+    /// `AcqRel` will never perform [`Relaxed`] accesses.\n     ///\n     /// This ordering is only applicable for operations that combine both loads and stores.\n     ///\n-    /// Corresponds to LLVM's [`AcquireRelease`] ordering.\n+    /// Corresponds to [`memory_order_acq_rel`] in C++20.\n     ///\n-    /// [`AcquireRelease`]: https://llvm.org/docs/Atomics.html#acquirerelease\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n     /// operations, respectively) with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n     ///\n-    /// Corresponds to LLVM's [`SequentiallyConsistent`] ordering.\n+    /// Corresponds to [`memory_order_seq_cst`] in C++20.\n     ///\n-    /// [`SequentiallyConsistent`]: https://llvm.org/docs/Atomics.html#sequentiallyconsistent\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`AcqRel`]: https://llvm.org/docs/Atomics.html#acquirerelease\n+    /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`AcqRel`]: #variant.AcqRel\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -313,7 +315,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -462,7 +464,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -500,7 +502,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -551,7 +553,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -607,7 +609,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -658,7 +660,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -700,7 +702,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -753,7 +755,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -794,13 +796,13 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -951,7 +953,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -987,7 +989,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1029,7 +1031,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1089,7 +1091,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1110,7 +1112,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1126,16 +1128,17 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n-    ($stable:meta,\n+    ($cfg_cas:meta,\n+     $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1356,7 +1359,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1396,7 +1399,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1454,7 +1457,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1506,7 +1509,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1544,7 +1547,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1576,7 +1579,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1611,7 +1614,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1647,7 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1682,7 +1685,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1717,7 +1720,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1767,7 +1770,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1828,7 +1831,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1880,7 +1883,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1890,8 +1893,9 @@ assert_eq!(min_foo, 12);\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1906,8 +1910,9 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1922,8 +1927,9 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1938,8 +1944,9 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1954,8 +1961,9 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1970,8 +1978,9 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1986,8 +1995,12 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2002,8 +2015,12 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2018,8 +2035,9 @@ atomic_int! {\n     \"AtomicU64::new(0)\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2034,8 +2052,9 @@ atomic_int! {\n     \"AtomicI128::new(0)\",\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2050,20 +2069,24 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2078,8 +2101,9 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2096,7 +2120,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -2130,7 +2154,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -2143,7 +2167,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -2156,7 +2180,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2168,7 +2192,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n@@ -2193,7 +2217,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2218,7 +2242,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2230,7 +2254,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2242,7 +2266,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2254,7 +2278,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2267,7 +2291,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2280,7 +2304,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2293,7 +2317,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2306,7 +2330,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),\n@@ -2504,23 +2528,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "6f841bd2adf41a9be45c16512042475952e85512", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -217,7 +217,7 @@ impl fmt::Debug for Context<'_> {\n /// This handle encapsulates a [`RawWaker`] instance, which defines the\n /// executor-specific wakeup behavior.\n ///\n-/// Implements [`Clone`], [`trait@Send`], and [`trait@Sync`].\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n ///\n /// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]"}, {"sha": "4f3b79c78b66c58d6d604800134a9173af9b1df5", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,4 +1,4 @@\n-use core::array::FixedSizeArray;\n+use core::array::{FixedSizeArray, IntoIter};\n use core::convert::TryFrom;\n \n #[test]\n@@ -40,3 +40,208 @@ fn array_try_from() {\n         30 31 32\n     }\n }\n+\n+\n+#[test]\n+fn iterator_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).collect();\n+    assert_eq!(&arr[..], &v[..]);\n+}\n+\n+#[test]\n+fn iterator_rev_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).rev().collect();\n+    assert_eq!(&v[..], &[9, 5, 2, 1, 0]);\n+}\n+\n+#[test]\n+fn iterator_nth() {\n+    let v = [0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(IntoIter::new(v.clone()).nth(i).unwrap(), v[i]);\n+    }\n+    assert_eq!(IntoIter::new(v.clone()).nth(v.len()), None);\n+\n+    let mut iter = IntoIter::new(v);\n+    assert_eq!(iter.nth(2).unwrap(), v[2]);\n+    assert_eq!(iter.nth(1).unwrap(), v[4]);\n+}\n+\n+#[test]\n+fn iterator_last() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v).last().unwrap(), 4);\n+    assert_eq!(IntoIter::new([0]).last().unwrap(), 0);\n+\n+    let mut it = IntoIter::new([0, 9, 2, 4]);\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(it.last(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_clone() {\n+    let mut it = IntoIter::new([0, 2, 4, 6, 8]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let mut clone = it.clone();\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(clone.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(clone.next_back(), Some(4));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(clone.next(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_fused() {\n+    let mut it = IntoIter::new([0, 9, 2]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(9));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn iterator_len() {\n+    let mut it = IntoIter::new([0, 1, 2, 5, 9]);\n+    assert_eq!(it.size_hint(), (5, Some(5)));\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.is_empty(), false);\n+\n+    // Empty\n+    let it = IntoIter::new([] as [String; 0]);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.is_empty(), true);\n+}\n+\n+#[test]\n+fn iterator_count() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v.clone()).count(), 5);\n+\n+    let mut iter2 = IntoIter::new(v);\n+    iter2.next();\n+    iter2.next();\n+    assert_eq!(iter2.count(), 3);\n+}\n+\n+#[test]\n+fn iterator_flat_map() {\n+    assert!((0..5).flat_map(|i| IntoIter::new([2 * i, 2 * i + 1])).eq(0..10));\n+}\n+\n+#[test]\n+fn iterator_debug() {\n+    let arr = [0, 1, 2, 5, 9];\n+    assert_eq!(\n+        format!(\"{:?}\", IntoIter::new(arr)),\n+        \"IntoIter([0, 1, 2, 5, 9])\",\n+    );\n+}\n+\n+#[test]\n+fn iterator_drops() {\n+    use core::cell::Cell;\n+\n+    // This test makes sure the correct number of elements are dropped. The `R`\n+    // type is just a reference to a `Cell` that is incremented when an `R` is\n+    // dropped.\n+\n+    #[derive(Clone)]\n+    struct Foo<'a>(&'a Cell<usize>);\n+\n+    impl Drop for Foo<'_> {\n+       fn drop(&mut self) {\n+            self.0.set(self.0.get() + 1);\n+        }\n+    }\n+\n+    fn five(i: &Cell<usize>) -> [Foo<'_>; 5] {\n+        // This is somewhat verbose because `Foo` does not implement `Copy`\n+        // since it implements `Drop`. Consequently, we cannot write\n+        // `[Foo(i); 5]`.\n+        [Foo(i), Foo(i), Foo(i), Foo(i), Foo(i)]\n+    }\n+\n+    // Simple: drop new iterator.\n+    let i = Cell::new(0);\n+    {\n+        IntoIter::new(five(&i));\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Call `next()` once.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.next();\n+        assert_eq!(i.get(), 0);\n+        assert_eq!(iter.count(), 4);\n+        assert_eq!(i.get(), 4);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check `clone` and calling `next`/`next_back`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        iter.next();\n+        assert_eq!(i.get(), 1);\n+        iter.next_back();\n+        assert_eq!(i.get(), 2);\n+\n+        let mut clone = iter.clone();\n+        assert_eq!(i.get(), 2);\n+\n+        iter.next();\n+        assert_eq!(i.get(), 3);\n+\n+        clone.next();\n+        assert_eq!(i.get(), 4);\n+\n+        assert_eq!(clone.count(), 2);\n+        assert_eq!(i.get(), 6);\n+    }\n+    assert_eq!(i.get(), 8);\n+\n+    // Check via `nth`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.nth(2);\n+        assert_eq!(i.get(), 2);\n+        let _y = iter.last();\n+        assert_eq!(i.get(), 3);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check every element.\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).rev().enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+}"}, {"sha": "255724432816d99ea2d96ebe5dd036ad9bc6c1b3", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -319,6 +319,46 @@ mod debug_map {\n                    format!(\"{:#?}\", Bar));\n     }\n \n+    #[test]\n+    fn test_entry_err() {\n+        // Ensure errors in a map entry don't trigger panics (#65231)\n+        use std::fmt::Write;\n+\n+        struct ErrorFmt;\n+\n+        impl fmt::Debug for ErrorFmt {\n+            fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                Err(fmt::Error)\n+            }\n+        }\n+\n+        struct KeyValue<K, V>(usize, K, V);\n+\n+        impl<K, V> fmt::Debug for KeyValue<K, V>\n+        where\n+            K: fmt::Debug,\n+            V: fmt::Debug,\n+        {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                let mut map = fmt.debug_map();\n+\n+                for _ in 0..self.0 {\n+                    map.entry(&self.1, &self.2);\n+                }\n+\n+                map.finish()\n+            }\n+        }\n+\n+        let mut buf = String::new();\n+\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, ErrorFmt, \"bar\")).is_err());\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(1, \"foo\", ErrorFmt)).is_err());\n+\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, ErrorFmt, \"bar\")).is_err());\n+        assert!(write!(&mut buf, \"{:?}\", KeyValue(2, \"foo\", ErrorFmt)).is_err());\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn test_invalid_key_when_entry_is_incomplete() {"}, {"sha": "b28ed2eaa0876ad6af9fb264eed6cc736b2cadb6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -31,6 +31,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n #![feature(const_fn)]\n+#![feature(array_value_iter)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]"}, {"sha": "d22420e76dcd4966916949b1cce9dc5972386a81", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -410,7 +410,7 @@ impl<'a> Parser<'a> {\n         &self.input[start..self.input.len()]\n     }\n \n-    /// Parses an Argument structure, or what's contained within braces inside the format string\n+    /// Parses an `Argument` structure, or what's contained within braces inside the format string.\n     fn argument(&mut self) -> Argument<'a> {\n         let pos = self.position();\n         let format = self.format();\n@@ -464,7 +464,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a format specifier at the current position, returning all of the\n-    /// relevant information in the FormatSpec struct.\n+    /// relevant information in the `FormatSpec` struct.\n     fn format(&mut self) -> FormatSpec<'a> {\n         let mut spec = FormatSpec {\n             fill: None,\n@@ -571,7 +571,7 @@ impl<'a> Parser<'a> {\n         spec\n     }\n \n-    /// Parses a Count parameter at the current position. This does not check\n+    /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n     fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {"}, {"sha": "5509f47bc8858ccdc5a668f71cf9f4f001ab32ff", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -54,7 +54,8 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n         core::intrinsics::abort();\n     }\n \n-    #[cfg(all(target_vendor=\"fortanix\", target_env=\"sgx\"))]\n+    #[cfg(any(target_os = \"hermit\",\n+              all(target_vendor=\"fortanix\", target_env=\"sgx\")))]\n     unsafe fn abort() -> ! {\n         // call std::sys::abort_internal\n         extern \"C\" { pub fn __rust_abort() -> !; }"}, {"sha": "a35847c85fc206476f78174e406781cca340c90b", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -156,21 +156,21 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n             EHAction::None |\n-            EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+            EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n         }\n     } else {\n         match eh_action {\n-            EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::None => uw::_URC_CONTINUE_UNWIND,\n             EHAction::Cleanup(lpad) |\n             EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n-                return uw::_URC_INSTALL_CONTEXT;\n+                uw::_URC_INSTALL_CONTEXT\n             }\n-            EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n+            EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n         }\n     }\n }"}, {"sha": "8bee6ff09e551ef56f5a65a57a7e27530d209c2a", "filename": "src/libpanic_unwind/hermit.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -0,0 +1,21 @@\n+//! Unwinding for *hermit* target.\n+//!\n+//! Right now we don't support this, so this is just stubs.\n+\n+use alloc::boxed::Box;\n+use core::ptr;\n+use core::any::Any;\n+\n+pub fn payload() -> *mut u8 {\n+    ptr::null_mut()\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}\n+\n+pub unsafe fn panic(_data: Box<dyn Any + Send>) -> u32 {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}"}, {"sha": "2089a02083c59a4d1855950d6d0e531231a21614", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -43,6 +43,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        #[path = \"hermit.rs\"]\n+        mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n         #[path = \"dummy.rs\"]\n         mod imp;"}, {"sha": "16b699a44379979f7eda4031937e072e7b8d4d8c", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -46,7 +46,7 @@ pub fn payload() -> *mut u8 {\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n-    return panic_ctx.data;\n+    panic_ctx.data\n }\n \n // SEH doesn't support resuming unwinds after calling a landing pad like"}, {"sha": "9643dba997aa475213b5a4556f077ce72b1582a9", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 28, "deletions": 54, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -15,8 +15,9 @@ macro_rules! define_handles {\n         }\n \n         impl HandleCounters {\n-            // FIXME(#53451) public to work around `Cannot create local mono-item` ICE.\n-            pub extern \"C\" fn get() -> &'static Self {\n+            // FIXME(eddyb) use a reference to the `static COUNTERS`, intead of\n+            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n+            extern \"C\" fn get() -> &'static Self {\n                 static COUNTERS: HandleCounters = HandleCounters {\n                     $($oty: AtomicUsize::new(1),)*\n                     $($ity: AtomicUsize::new(1),)*\n@@ -333,29 +334,32 @@ impl Bridge<'_> {\n #[repr(C)]\n #[derive(Copy, Clone)]\n pub struct Client<F> {\n+    // FIXME(eddyb) use a reference to the `static COUNTERS`, intead of\n+    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n     pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n     pub(super) f: F,\n }\n \n-// FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n-// affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n-pub extern \"C\" fn __run_expand1(\n+/// Client-side helper for handling client panics, entering the bridge,\n+/// deserializing input and serializing output.\n+// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n+fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     mut bridge: Bridge<'_>,\n-    f: fn(crate::TokenStream) -> crate::TokenStream,\n+    f: impl FnOnce(A) -> R,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n \n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n         bridge.enter(|| {\n             let reader = &mut &b[..];\n-            let input = TokenStream::decode(reader, &mut ());\n+            let input = A::decode(reader, &mut ());\n \n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(crate::TokenStream(input)).0;\n+            let output = f(input);\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -383,65 +387,35 @@ pub extern \"C\" fn __run_expand1(\n \n impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+        }\n         Client {\n             get_handle_counters: HandleCounters::get,\n-            run: __run_expand1,\n+            run,\n             f,\n         }\n     }\n }\n \n-// FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n-// affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n-pub extern \"C\" fn __run_expand2(\n-    mut bridge: Bridge<'_>,\n-    f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n-) -> Buffer<u8> {\n-    // The initial `cached_buffer` contains the input.\n-    let mut b = bridge.cached_buffer.take();\n-\n-    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        bridge.enter(|| {\n-            let reader = &mut &b[..];\n-            let input = TokenStream::decode(reader, &mut ());\n-            let input2 = TokenStream::decode(reader, &mut ());\n-\n-            // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n-\n-            let output = f(crate::TokenStream(input), crate::TokenStream(input2)).0;\n-\n-            // Take the `cached_buffer` back out, for the output value.\n-            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-            // having handles outside the `bridge.enter(|| ...)` scope, and\n-            // to catch panics that could happen while encoding the success.\n-            //\n-            // Note that panics should be impossible beyond this point, but\n-            // this is defensively trying to avoid any accidental panicking\n-            // reaching the `extern \"C\"` (which should `abort` but may not\n-            // at the moment, so this is also potentially preventing UB).\n-            b.clear();\n-            Ok::<_, ()>(output).encode(&mut b, &mut ());\n-        })\n-    }))\n-    .map_err(PanicMessage::from)\n-    .unwrap_or_else(|e| {\n-        b.clear();\n-        Err::<(), _>(e).encode(&mut b, &mut ());\n-    });\n-    b\n-}\n-\n impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n     pub const fn expand2(\n         f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream\n     ) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |(input, input2)| {\n+                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+            })\n+        }\n         Client {\n             get_handle_counters: HandleCounters::get,\n-            run: __run_expand2,\n+            run,\n             f,\n         }\n     }"}, {"sha": "c26b59f473c36d5ebe13b87e9cd9c51341637ab5", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -148,6 +148,7 @@ macro_rules! with_api {\n                 fn debug($self: $S::Span) -> String;\n                 fn def_site() -> $S::Span;\n                 fn call_site() -> $S::Span;\n+                fn mixed_site() -> $S::Span;\n                 fn source_file($self: $S::Span) -> $S::SourceFile;\n                 fn parent($self: $S::Span) -> Option<$S::Span>;\n                 fn source($self: $S::Span) -> $S::Span;"}, {"sha": "6166561d87f15a8ef4075a2338a49cd79ab091b3", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -25,8 +25,7 @@\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n-#![feature(mem_take)]\n-#![feature(non_exhaustive)]\n+#![cfg_attr(bootstrap, feature(non_exhaustive))]\n #![feature(rustc_attrs)]\n #![feature(specialization)]\n \n@@ -271,6 +270,15 @@ impl Span {\n         Span(bridge::client::Span::call_site())\n     }\n \n+    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n+    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n+    /// call site (everything else).\n+    /// The span location is taken from the call-site.\n+    #[unstable(feature = \"proc_macro_mixed_site\", issue = \"65049\")]\n+    pub fn mixed_site() -> Span {\n+        Span(bridge::client::Span::mixed_site())\n+    }\n+\n     /// The original source file into which this span points.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn source_file(&self) -> SourceFile {"}, {"sha": "de67f46eba643c9c06f03c6432d465a139ec7fc6", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -10,29 +10,34 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n+# Prevent cc from upgrading all the way to 1.0.46,\n+# which fails the build (see e.g. #65445.)\n+cc = \"=1.0.37\"\n+\n arena = { path = \"../libarena\" }\n-bitflags = \"1.0\"\n+bitflags = \"1.2.1\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n-rustc-rayon = \"0.2.0\"\n-rustc-rayon-core = \"0.2.0\"\n+rustc-rayon = \"0.3.0\"\n+rustc-rayon-core = \"0.3.0\"\n polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_index = { path = \"../librustc_index\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-backtrace = \"0.3.3\"\n+backtrace = \"0.3.40\"\n parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.3\"\n+smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n+measureme = \"0.4\""}, {"sha": "3daf0fc9df7a06606cd090f84ca7d1d29cdcbaf9", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -26,12 +26,12 @@ macro_rules! arena_types {\n             [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n             [] mir: rustc::mir::Body<$tcx>,\n             [] steal_promoted: rustc::ty::steal::Steal<\n-                rustc_data_structures::indexed_vec::IndexVec<\n+                rustc_index::vec::IndexVec<\n                     rustc::mir::Promoted,\n                     rustc::mir::Body<$tcx>\n                 >\n             >,\n-            [] promoted: rustc_data_structures::indexed_vec::IndexVec<\n+            [] promoted: rustc_index::vec::IndexVec<\n                 rustc::mir::Promoted,\n                 rustc::mir::Body<$tcx>\n             >,\n@@ -45,7 +45,7 @@ macro_rules! arena_types {\n             [decode] specialization_graph: rustc::traits::specialization_graph::Graph,\n             [] region_scope_tree: rustc::middle::region::ScopeTree,\n             [] item_local_set: rustc::util::nodemap::ItemLocalSet,\n-            [decode] mir_const_qualif: rustc_data_structures::bit_set::BitSet<rustc::mir::Local>,\n+            [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc::mir::Local>,\n             [] trait_impls_of: rustc::ty::trait_def::TraitImpls,\n             [] dropck_outlives:\n                 rustc::infer::canonical::Canonical<'tcx,\n@@ -98,7 +98,6 @@ macro_rules! arena_types {\n                 rustc::hir::def_id::DefId,\n             >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n-            [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n             [few] stability_index: rustc::middle::stability::Index<'tcx>,\n             [few] features: syntax::feature_gate::Features,"}, {"sha": "dea8d70aaf4e6a4a0c6ebd855bacf8e5bf294991", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -59,7 +59,7 @@ use crate::ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::Symbol;\n use crate::traits;\n use crate::traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n@@ -114,7 +114,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepKind {\n             #[allow(unreachable_code)]\n-            #[inline]\n             pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n                 match *self {\n                     $(\n@@ -150,7 +149,6 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -199,7 +197,6 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n-            #[inline(always)]\n             pub fn new<'tcx>(tcx: TyCtxt<'tcx>,\n                                        dep: DepConstructor<'tcx>)\n                                        -> DepNode\n@@ -219,14 +216,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        arg.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            arg.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -242,14 +241,16 @@ macro_rules! define_dep_nodes {\n                                     hash\n                                 };\n \n-                                if cfg!(debug_assertions) &&\n-                                   !dep_node.kind.can_reconstruct_query_key() &&\n-                                   (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                    tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                #[cfg(debug_assertions)]\n                                 {\n-                                    tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n-                                    });\n+                                    if !dep_node.kind.can_reconstruct_query_key() &&\n+                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n+                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n+                                    {\n+                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                            tupled_args.to_debug_str(tcx)\n+                                        });\n+                                    }\n                                 }\n \n                                 return dep_node;\n@@ -267,7 +268,6 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n@@ -281,7 +281,6 @@ macro_rules! define_dep_nodes {\n             /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n                 debug_assert!(!kind.has_params());\n                 DepNode {\n@@ -300,7 +299,6 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            #[inline]\n             pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n@@ -386,14 +384,12 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }\n@@ -430,7 +426,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     [anon] TraitSelect,\n \n-    [] CompileCodegenUnit(InternedString),\n+    [] CompileCodegenUnit(Symbol),\n \n     [eval_always] Analysis(CrateNum),\n ]);"}, {"sha": "0104507f7020ff30b940af4ffe85eaf85492f33e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 92, "deletions": 97, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,15 +1,16 @@\n use errors::Diagnostic;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n-use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n+use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, AtomicU64, Ordering};\n+use rustc_data_structures::sharded::{self, Sharded};\n+use std::sync::atomic::Ordering::SeqCst;\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use std::mem;\n use crate::ty::{self, TyCtxt};\n-use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n@@ -26,15 +27,15 @@ pub struct DepGraph {\n     data: Option<Lrc<DepGraphData>>,\n }\n \n-newtype_index! {\n+rustc_index::newtype_index! {\n     pub struct DepNodeIndex { .. }\n }\n \n impl DepNodeIndex {\n-    const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n+    pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(PartialEq)]\n pub enum DepNodeColor {\n     Red,\n     Green(DepNodeIndex)\n@@ -54,7 +55,7 @@ struct DepGraphData {\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: Lock<CurrentDepGraph>,\n+    current: CurrentDepGraph,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n@@ -75,9 +76,6 @@ struct DepGraphData {\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n     dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n-\n-    // Used for testing, only populated when -Zquery-dep-graph is specified.\n-    loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n@@ -99,12 +97,11 @@ impl DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n+                current: CurrentDepGraph::new(prev_graph_node_count),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n-                loaded_from_cache: Default::default(),\n             })),\n         }\n     }\n@@ -122,13 +119,12 @@ impl DepGraph {\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n-        let nodes: Vec<_> = current_dep_graph.data.iter().map(|n| n.node).collect();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n+        let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n-        for (from, edge_targets) in current_dep_graph.data.iter()\n-                                                           .map(|d| (d.node, &d.edges)) {\n+        for (from, edge_targets) in data.iter().map(|d| (d.node, &d.edges)) {\n             for &edge_target in edge_targets.iter() {\n-                let to = current_dep_graph.data[edge_target].node;\n+                let to = data[edge_target].node;\n                 edges.push((from, to));\n             }\n         }\n@@ -207,7 +203,7 @@ impl DepGraph {\n                 read_set: Default::default(),\n             }),\n             |data, key, fingerprint, task| {\n-                data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n+                data.complete_task(key, task.unwrap(), fingerprint)\n             },\n             hash_result)\n     }\n@@ -228,7 +224,7 @@ impl DepGraph {\n         self.with_task_impl(key, cx, input, true, identity_fn,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n+                data.alloc_node(key, SmallVec::new(), fingerprint)\n             },\n             hash_result::<R>)\n     }\n@@ -241,7 +237,7 @@ impl DepGraph {\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n         create_task: fn(DepNode) -> Option<TaskDeps>,\n-        finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n+        finish_task_and_alloc_depnode: fn(&CurrentDepGraph,\n                                           DepNode,\n                                           Fingerprint,\n                                           Option<TaskDeps>) -> DepNodeIndex,\n@@ -260,10 +256,6 @@ impl DepGraph {\n             //  - we can get an idea of the runtime cost.\n             let mut hcx = cx.get_stable_hashing_context();\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n-\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n@@ -279,10 +271,6 @@ impl DepGraph {\n                 })\n             };\n \n-            if cfg!(debug_assertions) {\n-                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n-            };\n-\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode(\n@@ -363,7 +351,6 @@ impl DepGraph {\n                 (r, task_deps.into_inner())\n             });\n             let dep_node_index = data.current\n-                                     .borrow_mut()\n                                      .complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -387,18 +374,17 @@ impl DepGraph {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n             |data, key, fingerprint, _| {\n-                let mut current = data.borrow_mut();\n-                current.alloc_node(key, smallvec![], fingerprint)\n+                data.alloc_node(key, smallvec![], fingerprint)\n             },\n             hash_result)\n     }\n \n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let current = data.current.borrow_mut();\n-            if let Some(&dep_node_index) = current.node_to_node_index.get(&v) {\n-                std::mem::drop(current);\n+            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n+            if let Some(dep_node_index) = map.get(&v).copied() {\n+                std::mem::drop(map);\n                 data.read_index(dep_node_index);\n             } else {\n                 bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n@@ -419,8 +405,9 @@ impl DepGraph {\n             .as_ref()\n             .unwrap()\n             .current\n-            .borrow_mut()\n             .node_to_node_index\n+            .get_shard_by_value(dep_node)\n+            .lock()\n             .get(dep_node)\n             .cloned()\n             .unwrap()\n@@ -429,16 +416,20 @@ impl DepGraph {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n         if let Some(ref data) = self.data {\n-            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+            data.current\n+                .node_to_node_index\n+                .get_shard_by_value(&dep_node)\n+                .lock()\n+                .contains_key(dep_node)\n         } else {\n             false\n         }\n     }\n \n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let current = self.data.as_ref().expect(\"dep graph enabled\").current.borrow_mut();\n-        current.data[dep_node_index].fingerprint\n+        let data = self.data.as_ref().expect(\"dep graph enabled\").current.data.lock();\n+        data[dep_node_index].fingerprint\n     }\n \n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n@@ -492,32 +483,29 @@ impl DepGraph {\n \n     pub fn edge_deduplication_data(&self) -> Option<(u64, u64)> {\n         if cfg!(debug_assertions) {\n-            let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+            let current_dep_graph = &self.data.as_ref().unwrap().current;\n \n-            Some((current_dep_graph.total_read_count,\n-                  current_dep_graph.total_duplicate_read_count))\n+            Some((current_dep_graph.total_read_count.load(SeqCst),\n+                  current_dep_graph.total_duplicate_read_count.load(SeqCst)))\n         } else {\n             None\n         }\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n-        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+        let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.fingerprint).collect();\n+            data.iter().map(|d| d.fingerprint).collect();\n         let nodes: IndexVec<SerializedDepNodeIndex, _> =\n-            current_dep_graph.data.iter().map(|d| d.node).collect();\n+            data.iter().map(|d| d.node).collect();\n \n-        let total_edge_count: usize = current_dep_graph.data.iter()\n-                                                            .map(|d| d.edges.len())\n-                                                            .sum();\n+        let total_edge_count: usize = data.iter().map(|d| d.edges.len()).sum();\n \n         let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n         let mut edge_list_data = Vec::with_capacity(total_edge_count);\n \n-        for (current_dep_node_index, edges) in current_dep_graph.data.iter_enumerated()\n-                                                                .map(|(i, d)| (i, &d.edges)) {\n+        for (current_dep_node_index, edges) in data.iter_enumerated().map(|(i, d)| (i, &d.edges)) {\n             let start = edge_list_data.len() as u32;\n             // This should really just be a memcpy :/\n             edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex::new(i.index())));\n@@ -613,7 +601,11 @@ impl DepGraph {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n+            debug_assert!(!data.current\n+                               .node_to_node_index\n+                               .get_shard_by_value(dep_node)\n+                               .lock()\n+                               .contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -746,15 +738,13 @@ impl DepGraph {\n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n         let dep_node_index = {\n-            let mut current = data.current.borrow_mut();\n-\n             // Copy the fingerprint from the previous graph,\n             // so we don't have to recompute it\n             let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n \n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            current.intern_node(*dep_node, current_deps, fingerprint)\n+            data.current.intern_node(*dep_node, current_deps, fingerprint)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -858,6 +848,8 @@ impl DepGraph {\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n     pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n+        let _prof_timer = tcx.prof.generic_activity(\"incr_comp_query_cache_promotion\");\n+\n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n@@ -874,25 +866,6 @@ impl DepGraph {\n             }\n         }\n     }\n-\n-    pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n-        debug!(\"mark_loaded_from_cache({:?}, {})\",\n-               self.data.as_ref().unwrap().current.borrow().data[dep_node_index].node,\n-               state);\n-\n-        self.data\n-            .as_ref()\n-            .unwrap()\n-            .loaded_from_cache\n-            .borrow_mut()\n-            .insert(dep_node_index, state);\n-    }\n-\n-    pub fn was_loaded_from_cache(&self, dep_node: &DepNode) -> Option<bool> {\n-        let data = self.data.as_ref().unwrap();\n-        let dep_node_index = data.current.borrow().node_to_node_index[dep_node];\n-        data.loaded_from_cache.borrow().get(&dep_node_index).cloned()\n-    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -947,9 +920,27 @@ struct DepNodeData {\n     fingerprint: Fingerprint,\n }\n \n+/// `CurrentDepGraph` stores the dependency graph for the current session.\n+/// It will be populated as we run queries or tasks.\n+///\n+/// The nodes in it are identified by an index (`DepNodeIndex`).\n+/// The data for each node is stored in its `DepNodeData`, found in the `data` field.\n+///\n+/// We never remove nodes from the graph: they are only added.\n+///\n+/// This struct uses two locks internally. The `data` and `node_to_node_index` fields are\n+/// locked separately. Operations that take a `DepNodeIndex` typically just access\n+/// the data field.\n+///\n+/// The only operation that must manipulate both locks is adding new nodes, in which case\n+/// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n+/// acquire the lock on `data.`\n pub(super) struct CurrentDepGraph {\n-    data: IndexVec<DepNodeIndex, DepNodeData>,\n-    node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n+\n+    /// Used to trap when a specific edge is added to the graph.\n+    /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n@@ -966,8 +957,10 @@ pub(super) struct CurrentDepGraph {\n     /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n-    total_read_count: u64,\n-    total_duplicate_read_count: u64,\n+    /// These are simple counters that are for profiling and\n+    /// debugging and only active with `debug_assertions`.\n+    total_read_count: AtomicU64,\n+    total_duplicate_read_count: AtomicU64,\n }\n \n impl CurrentDepGraph {\n@@ -1001,28 +994,28 @@ impl CurrentDepGraph {\n         let new_node_count_estimate = (prev_graph_node_count * 102) / 100 + 200;\n \n         CurrentDepGraph {\n-            data: IndexVec::with_capacity(new_node_count_estimate),\n-            node_to_node_index: FxHashMap::with_capacity_and_hasher(\n-                new_node_count_estimate,\n+            data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n+            node_to_node_index: Sharded::new(|| FxHashMap::with_capacity_and_hasher(\n+                new_node_count_estimate / sharded::SHARDS,\n                 Default::default(),\n-            ),\n+            )),\n             anon_id_seed: stable_hasher.finish(),\n             forbidden_edge,\n-            total_read_count: 0,\n-            total_duplicate_read_count: 0,\n+            total_read_count: AtomicU64::new(0),\n+            total_duplicate_read_count: AtomicU64::new(0),\n         }\n     }\n \n     fn complete_task(\n-        &mut self,\n+        &self,\n         node: DepNode,\n         task_deps: TaskDeps,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&mut self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1047,28 +1040,30 @@ impl CurrentDepGraph {\n     }\n \n     fn alloc_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        debug_assert!(!self.node_to_node_index\n+                           .get_shard_by_value(&dep_node)\n+                           .lock()\n+                           .contains_key(&dep_node));\n         self.intern_node(dep_node, edges, fingerprint)\n     }\n \n     fn intern_node(\n-        &mut self,\n+        &self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert_eq!(self.node_to_node_index.len(), self.data.len());\n-\n-        match self.node_to_node_index.entry(dep_node) {\n+        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let dep_node_index = DepNodeIndex::new(self.data.len());\n-                self.data.push(DepNodeData {\n+                let mut data = self.data.lock();\n+                let dep_node_index = DepNodeIndex::new(data.len());\n+                data.push(DepNodeData {\n                     node: dep_node,\n                     edges,\n                     fingerprint\n@@ -1087,17 +1082,17 @@ impl DepGraphData {\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n                 if cfg!(debug_assertions) {\n-                    self.current.lock().total_read_count += 1;\n+                    self.current.total_read_count.fetch_add(1, SeqCst);\n                 }\n                 if task_deps.read_set.insert(source) {\n                     task_deps.reads.push(source);\n \n                     #[cfg(debug_assertions)]\n                     {\n                         if let Some(target) = task_deps.node {\n-                            let graph = self.current.lock();\n-                            if let Some(ref forbidden_edge) = graph.forbidden_edge {\n-                                let source = graph.data[source].node;\n+                            let data = self.current.data.lock();\n+                            if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n+                                let source = data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n                                     bug!(\"forbidden edge {:?} -> {:?} created\",\n                                         source,\n@@ -1107,7 +1102,7 @@ impl DepGraphData {\n                         }\n                     }\n                 } else if cfg!(debug_assertions) {\n-                    self.current.lock().total_duplicate_read_count += 1;\n+                    self.current.total_duplicate_read_count.fetch_add(1, SeqCst);\n                 }\n             }\n         })"}, {"sha": "4302195755ea5ef5cce99f653990e2fd3fa30943", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2,9 +2,9 @@\n \n use crate::dep_graph::DepNode;\n use crate::ich::Fingerprint;\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_index::vec::{IndexVec, Idx};\n \n-newtype_index! {\n+rustc_index::newtype_index! {\n     pub struct SerializedDepNodeIndex { .. }\n }\n "}, {"sha": "3e35add9616bd676144310764dc1e8af0b4e9c1b", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 268, "deletions": 201, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -259,8 +259,8 @@ trait Foo {\n This is similar to the second sub-error, but subtler. It happens in situations\n like the following:\n \n-```compile_fail\n-trait Super<A> {}\n+```compile_fail,E0038\n+trait Super<A: ?Sized> {}\n \n trait Trait: Super<Self> {\n }\n@@ -270,17 +270,21 @@ struct Foo;\n impl Super<Foo> for Foo{}\n \n impl Trait for Foo {}\n+\n+fn main() {\n+    let x: Box<dyn Trait>;\n+}\n ```\n \n Here, the supertrait might have methods as follows:\n \n ```\n-trait Super<A> {\n-    fn get_a(&self) -> A; // note that this is object safe!\n+trait Super<A: ?Sized> {\n+    fn get_a(&self) -> &A; // note that this is object safe!\n }\n ```\n \n-If the trait `Foo` was deriving from something like `Super<String>` or\n+If the trait `Trait` was deriving from something like `Super<String>` or\n `Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n `get_a()` will definitely return an object of that type.\n \n@@ -466,67 +470,6 @@ fn main() {\n ```\n \"##,\n \n-// This shouldn't really ever trigger since the repeated value error comes first\n-E0136: r##\"\n-A binary can only have one entry point, and by default that entry point is the\n-function `main()`. If there are multiple such functions, please rename one.\n-\"##,\n-\n-E0137: r##\"\n-More than one function was declared with the `#[main]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0137\n-#![feature(main)]\n-\n-#[main]\n-fn foo() {}\n-\n-#[main]\n-fn f() {} // error: multiple functions with a `#[main]` attribute\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[main]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(main)]\n-\n-#[main]\n-fn f() {} // ok!\n-```\n-\"##,\n-\n-E0138: r##\"\n-More than one function was declared with the `#[start]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0138\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n-\n-#[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n-// error: multiple 'start' functions\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[start]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n-```\n-\"##,\n-\n E0139: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -1580,8 +1523,51 @@ where\n ```\n \"##,\n \n+E0495: r##\"\n+A lifetime cannot be determined in the given situation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0495\n+fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // error!\n+        ((u,),) => u,\n+    }\n+}\n+\n+let y = Box::new((42,));\n+let x = transmute_lifetime(&y);\n+```\n+\n+In this code, you have two ways to solve this issue:\n+ 1. Enforce that `'a` lives at least as long as `'b`.\n+ 2. Use the same lifetime requirement for both input and output values.\n+\n+So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n+\n+```\n+fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\n+In the second you can do it by simply removing `'b` so they both use `'a`:\n+\n+```\n+fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\"##,\n+\n E0496: r##\"\n-A lifetime name is shadowing another lifetime name. Erroneous code example:\n+A lifetime name is shadowing another lifetime name.\n+\n+Erroneous code example:\n \n ```compile_fail,E0496\n struct Foo<'a> {\n@@ -1613,8 +1599,11 @@ fn main() {\n \"##,\n \n E0497: r##\"\n-A stability attribute was used outside of the standard library. Erroneous code\n-example:\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A stability attribute was used outside of the standard library.\n+\n+Erroneous code example:\n \n ```compile_fail\n #[stable] // error: stability attributes may not be used outside of the\n@@ -1626,33 +1615,6 @@ It is not possible to use stability attributes outside of the standard library.\n Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail,E0512\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: cannot transmute between types of different sizes,\n-    //        or dependently-sized types\n-}\n-```\n-\n-Please use types with same size or use the expected type directly. Example:\n-\n-```\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n-}\n-```\n-\"##,\n-\n E0517: r##\"\n This error indicates that a `#[repr(..)]` attribute was placed on an\n unsupported item.\n@@ -1787,6 +1749,27 @@ To understand better how closures work in Rust, read:\n https://doc.rust-lang.org/book/ch13-01-closures.html\n \"##,\n \n+E0566: r##\"\n+Conflicting representation hints have been used on a same item.\n+\n+Erroneous code example:\n+\n+```\n+#[repr(u32, u64)] // warning!\n+enum Repr { A }\n+```\n+\n+In most cases (if not all), using just one representation hint is more than\n+enough. If you want to have a representation hint depending on the current\n+architecture, use `cfg_attr`. Example:\n+\n+```\n+#[cfg_attr(linux, repr(u32))]\n+#[cfg_attr(not(linux), repr(u64))]\n+enum Repr { A }\n+```\n+\"##,\n+\n E0580: r##\"\n The `main` function was incorrectly declared.\n \n@@ -1847,84 +1830,6 @@ See [RFC 1522] for more details.\n [RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n \"##,\n \n-E0591: r##\"\n-Per [RFC 401][rfc401], if you have a function declaration `foo`:\n-\n-```\n-// For the purposes of this explanation, all of these\n-// different kinds of `fn` declarations are equivalent:\n-struct S;\n-fn foo(x: S) { /* ... */ }\n-# #[cfg(for_demonstration_only)]\n-extern \"C\" { fn foo(x: S); }\n-# #[cfg(for_demonstration_only)]\n-impl S { fn foo(self) { /* ... */ } }\n-```\n-\n-the type of `foo` is **not** `fn(S)`, as one might expect.\n-Rather, it is a unique, zero-sized marker type written here as `typeof(foo)`.\n-However, `typeof(foo)` can be _coerced_ to a function pointer `fn(S)`,\n-so you rarely notice this:\n-\n-```\n-# struct S;\n-# fn foo(_: S) {}\n-let x: fn(S) = foo; // OK, coerces\n-```\n-\n-The reason that this matter is that the type `fn(S)` is not specific to\n-any particular function: it's a function _pointer_. So calling `x()` results\n-in a virtual call, whereas `foo()` is statically dispatched, because the type\n-of `foo` tells us precisely what function is being called.\n-\n-As noted above, coercions mean that most code doesn't have to be\n-concerned with this distinction. However, you can tell the difference\n-when using **transmute** to convert a fn item into a fn pointer.\n-\n-This is sometimes done as part of an FFI:\n-\n-```compile_fail,E0591\n-extern \"C\" fn foo(userdata: Box<i32>) {\n-    /* ... */\n-}\n-\n-# fn callback(_: extern \"C\" fn(*mut i32)) {}\n-# use std::mem::transmute;\n-# unsafe {\n-let f: extern \"C\" fn(*mut i32) = transmute(foo);\n-callback(f);\n-# }\n-```\n-\n-Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n-is a function pointer, which is not zero-sized.\n-This pattern should be rewritten. There are a few possible ways to do this:\n-\n-- change the original fn declaration to match the expected signature,\n-  and do the cast in the fn body (the preferred option)\n-- cast the fn item fo a fn pointer before calling transmute, as shown here:\n-\n-    ```\n-    # extern \"C\" fn foo(_: Box<i32>) {}\n-    # use std::mem::transmute;\n-    # unsafe {\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as extern \"C\" fn(_));\n-    let f: extern \"C\" fn(*mut i32) = transmute(foo as usize); // works too\n-    # }\n-    ```\n-\n-The same applies to transmutes to `*mut fn()`, which were observed in practice.\n-Note though that use of this type is generally incorrect.\n-The intention is typically to describe a function pointer, but just `fn()`\n-alone suffices for that. `*mut fn()` is a pointer to a fn pointer.\n-(Since these values are typically just passed to C code, however, this rarely\n-makes a difference in practice.)\n-\n-[rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n-\"##,\n-\n E0593: r##\"\n You tried to supply an `Fn`-based type with an incorrect number of arguments\n than what was expected.\n@@ -1941,21 +1846,6 @@ fn main() {\n ```\n \"##,\n \n-E0601: r##\"\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n-\n-```\n-fn main() {\n-    // Your program will start here.\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-If you don't know the basics of Rust, you can go look to the Rust Book to get\n-started: https://doc.rust-lang.org/book/\n-\"##,\n-\n E0602: r##\"\n An unknown lint was used on the command line.\n \n@@ -2115,6 +2005,24 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0697: r##\"\n+A closure has been used as `static`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0697\n+fn main() {\n+    static || {}; // used as `static`\n+}\n+```\n+\n+Closures cannot be used as `static`. They \"save\" the environment,\n+and as such a static closure would save only a static environment\n+which would consist only of variables with a static lifetime. Given\n+this it would be better to use a proper function. The easiest fix\n+is to remove the `static` keyword.\n+\"##,\n+\n E0698: r##\"\n When using generators (or async) all type variables must be bound so a\n generator can be constructed.\n@@ -2137,8 +2045,8 @@ so that a generator can then be constructed:\n async fn bar<T>() -> () {}\n \n async fn foo() {\n-  bar::<String>().await;\n-  //   ^^^^^^^^ specify type explicitly\n+    bar::<String>().await;\n+    //   ^^^^^^^^ specify type explicitly\n }\n ```\n \"##,\n@@ -2197,8 +2105,6 @@ on something other than a struct or enum.\n Examples of erroneous code:\n \n ```compile_fail,E0701\n-# #![feature(non_exhaustive)]\n-\n #[non_exhaustive]\n trait Foo { }\n ```\n@@ -2217,6 +2123,171 @@ Examples of erroneous code:\n static X: u32 = 42;\n ```\n \"##,\n+\n+E0728: r##\"\n+[`await`] has been used outside [`async`] function or block.\n+\n+Erroneous code examples:\n+\n+```edition2018,compile_fail,E0728\n+# use std::pin::Pin;\n+# use std::future::Future;\n+# use std::task::{Context, Poll};\n+#\n+# struct WakeOnceThenComplete(bool);\n+#\n+# fn wake_and_yield_once() -> WakeOnceThenComplete {\n+#     WakeOnceThenComplete(false)\n+# }\n+#\n+# impl Future for WakeOnceThenComplete {\n+#     type Output = ();\n+#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+#         if self.0 {\n+#             Poll::Ready(())\n+#         } else {\n+#             cx.waker().wake_by_ref();\n+#             self.0 = true;\n+#             Poll::Pending\n+#         }\n+#     }\n+# }\n+#\n+fn foo() {\n+    wake_and_yield_once().await // `await` is used outside `async` context\n+}\n+```\n+\n+[`await`] is used to suspend the current computation until the given\n+future is ready to produce a value. So it is legal only within\n+an [`async`] context, like an `async fn` or an `async` block.\n+\n+```edition2018\n+# use std::pin::Pin;\n+# use std::future::Future;\n+# use std::task::{Context, Poll};\n+#\n+# struct WakeOnceThenComplete(bool);\n+#\n+# fn wake_and_yield_once() -> WakeOnceThenComplete {\n+#     WakeOnceThenComplete(false)\n+# }\n+#\n+# impl Future for WakeOnceThenComplete {\n+#     type Output = ();\n+#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+#         if self.0 {\n+#             Poll::Ready(())\n+#         } else {\n+#             cx.waker().wake_by_ref();\n+#             self.0 = true;\n+#             Poll::Pending\n+#         }\n+#     }\n+# }\n+#\n+async fn foo() {\n+    wake_and_yield_once().await // `await` is used within `async` function\n+}\n+\n+fn bar(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        wake_and_yield_once().await; // `await` is used within `async` block\n+        x\n+    }\n+}\n+```\n+\n+[`async`]: https://doc.rust-lang.org/std/keyword.async.html\n+[`await`]: https://doc.rust-lang.org/std/keyword.await.html\n+\"##,\n+\n+E0734: r##\"\n+A stability attribute has been used outside of the standard library.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0734\n+#[rustc_deprecated(since = \"b\", reason = \"text\")] // invalid\n+#[stable(feature = \"a\", since = \"b\")] // invalid\n+#[unstable(feature = \"b\", issue = \"0\")] // invalid\n+fn foo(){}\n+```\n+\n+These attributes are meant to only be used by the standard library and are\n+rejected in your own crates.\n+\"##,\n+\n+E0736: r##\"\n+`#[track_caller]` and `#[naked]` cannot both be applied to the same function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0736\n+#![feature(track_caller)]\n+\n+#[naked]\n+#[track_caller]\n+fn foo() {}\n+```\n+\n+This is primarily due to ABI incompatibilities between the two attributes.\n+See [RFC 2091] for details on this and other limitations.\n+\n+[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n+\"##,\n+\n+E0738: r##\"\n+`#[track_caller]` cannot be used in traits yet. This is due to limitations in\n+the compiler which are likely to be temporary. See [RFC 2091] for details on\n+this and other restrictions.\n+\n+Erroneous example with a trait method implementation:\n+\n+```compile_fail,E0738\n+#![feature(track_caller)]\n+\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+impl Foo for u64 {\n+    #[track_caller]\n+    fn bar(&self) {}\n+}\n+```\n+\n+Erroneous example with a blanket trait method implementation:\n+\n+```compile_fail,E0738\n+#![feature(track_caller)]\n+\n+trait Foo {\n+    #[track_caller]\n+    fn bar(&self) {}\n+    fn baz(&self);\n+}\n+```\n+\n+Erroneous example with a trait method declaration:\n+\n+```compile_fail,E0738\n+#![feature(track_caller)]\n+\n+trait Foo {\n+    fn bar(&self) {}\n+\n+    #[track_caller]\n+    fn baz(&self);\n+}\n+```\n+\n+Note that while the compiler may be able to support the attribute in traits in\n+the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n+\n+[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n+\"##,\n+\n ;\n //  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n@@ -2226,7 +2297,7 @@ static X: u32 = 42;\n //  E0272, // on_unimplemented #0\n //  E0273, // on_unimplemented #1\n //  E0274, // on_unimplemented #2\n-    E0278, // requirement is not satisfied\n+//  E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n //  E0285, // overflow evaluation builtin bounds\n@@ -2258,25 +2329,21 @@ static X: u32 = 42;\n     E0488, // lifetime of variable does not enclose its declaration\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0495, // cannot infer an appropriate lifetime due to conflicting\n-           // requirements\n-    E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n     E0628, // generators cannot have explicit parameters\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0697, // closures cannot be static\n-    E0707, // multiple elided lifetimes used in arguments of `async fn`\n+//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported\n-    E0709, // multiple different lifetimes used in arguments of `async fn`\n+//  E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n //  E0702, // replaced with a generic attribute input check\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n     E0727, // `async` generators are not yet supported\n-    E0728, // `await` must be in an `async` function or block\n+    E0739, // invalid track_caller application/syntax\n }"}, {"sha": "96562002aa070240c1cffeee6b91d7bf7e91fe5a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 225, "deletions": 64, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -4,16 +4,24 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::hir;\n+use crate::hir::{self, HirId, HirVec, Attribute, Item, ItemKind, TraitItem, TraitItemKind};\n+use crate::hir::DUMMY_HIR_ID;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::lint::builtin::UNUSED_ATTRIBUTES;\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n \n use std::fmt::{self, Display};\n-use syntax::symbol::sym;\n+use syntax::{attr, symbol::sym};\n use syntax_pos::Span;\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub(crate) enum MethodKind {\n+    Trait { body: bool },\n+    Inherent,\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n pub(crate) enum Target {\n     ExternCrate,\n@@ -35,6 +43,12 @@ pub(crate) enum Target {\n     Impl,\n     Expression,\n     Statement,\n+    AssocConst,\n+    Method(MethodKind),\n+    AssocTy,\n+    ForeignFn,\n+    ForeignStatic,\n+    ForeignTy,\n }\n \n impl Display for Target {\n@@ -59,29 +73,76 @@ impl Display for Target {\n             Target::Impl => \"item\",\n             Target::Expression => \"expression\",\n             Target::Statement => \"statement\",\n+            Target::AssocConst => \"associated const\",\n+            Target::Method(_) => \"method\",\n+            Target::AssocTy => \"associated type\",\n+            Target::ForeignFn => \"foreign function\",\n+            Target::ForeignStatic => \"foreign static item\",\n+            Target::ForeignTy => \"foreign type\",\n         })\n     }\n }\n \n impl Target {\n-    pub(crate) fn from_item(item: &hir::Item) -> Target {\n+    pub(crate) fn from_item(item: &Item) -> Target {\n         match item.kind {\n-            hir::ItemKind::ExternCrate(..) => Target::ExternCrate,\n-            hir::ItemKind::Use(..) => Target::Use,\n-            hir::ItemKind::Static(..) => Target::Static,\n-            hir::ItemKind::Const(..) => Target::Const,\n-            hir::ItemKind::Fn(..) => Target::Fn,\n-            hir::ItemKind::Mod(..) => Target::Mod,\n-            hir::ItemKind::ForeignMod(..) => Target::ForeignMod,\n-            hir::ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n-            hir::ItemKind::TyAlias(..) => Target::TyAlias,\n-            hir::ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n-            hir::ItemKind::Enum(..) => Target::Enum,\n-            hir::ItemKind::Struct(..) => Target::Struct,\n-            hir::ItemKind::Union(..) => Target::Union,\n-            hir::ItemKind::Trait(..) => Target::Trait,\n-            hir::ItemKind::TraitAlias(..) => Target::TraitAlias,\n-            hir::ItemKind::Impl(..) => Target::Impl,\n+            ItemKind::ExternCrate(..) => Target::ExternCrate,\n+            ItemKind::Use(..) => Target::Use,\n+            ItemKind::Static(..) => Target::Static,\n+            ItemKind::Const(..) => Target::Const,\n+            ItemKind::Fn(..) => Target::Fn,\n+            ItemKind::Mod(..) => Target::Mod,\n+            ItemKind::ForeignMod(..) => Target::ForeignMod,\n+            ItemKind::GlobalAsm(..) => Target::GlobalAsm,\n+            ItemKind::TyAlias(..) => Target::TyAlias,\n+            ItemKind::OpaqueTy(..) => Target::OpaqueTy,\n+            ItemKind::Enum(..) => Target::Enum,\n+            ItemKind::Struct(..) => Target::Struct,\n+            ItemKind::Union(..) => Target::Union,\n+            ItemKind::Trait(..) => Target::Trait,\n+            ItemKind::TraitAlias(..) => Target::TraitAlias,\n+            ItemKind::Impl(..) => Target::Impl,\n+        }\n+    }\n+\n+    fn from_trait_item(trait_item: &TraitItem) -> Target {\n+        match trait_item.kind {\n+            TraitItemKind::Const(..) => Target::AssocConst,\n+            TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n+                Target::Method(MethodKind::Trait { body: false })\n+            }\n+            TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n+                Target::Method(MethodKind::Trait { body: true })\n+            }\n+            TraitItemKind::Type(..) => Target::AssocTy,\n+        }\n+    }\n+\n+    fn from_foreign_item(foreign_item: &hir::ForeignItem) -> Target {\n+        match foreign_item.kind {\n+            hir::ForeignItemKind::Fn(..) => Target::ForeignFn,\n+            hir::ForeignItemKind::Static(..) => Target::ForeignStatic,\n+            hir::ForeignItemKind::Type => Target::ForeignTy,\n+        }\n+    }\n+\n+    fn from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem) -> Target {\n+        match impl_item.kind {\n+            hir::ImplItemKind::Const(..) => Target::AssocConst,\n+            hir::ImplItemKind::Method(..) => {\n+                let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n+                let containing_item = tcx.hir().expect_item(parent_hir_id);\n+                let containing_impl_is_for_trait = match &containing_item.kind {\n+                    hir::ItemKind::Impl(_, _, _, _, tr, _, _) => tr.is_some(),\n+                    _ => bug!(\"parent of an ImplItem must be an Impl\"),\n+                };\n+                if containing_impl_is_for_trait {\n+                    Target::Method(MethodKind::Trait { body: true })\n+                } else {\n+                    Target::Method(MethodKind::Inherent)\n+                }\n+            }\n+            hir::ImplItemKind::TyAlias(..) | hir::ImplItemKind::OpaqueTy(..) => Target::AssocTy,\n         }\n     }\n }\n@@ -92,17 +153,26 @@ struct CheckAttrVisitor<'tcx> {\n \n impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n-    fn check_attributes(&self, item: &hir::Item, target: Target) {\n+    fn check_attributes(\n+        &self,\n+        hir_id: HirId,\n+        attrs: &HirVec<Attribute>,\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item>,\n+    ) {\n         let mut is_valid = true;\n-        for attr in &item.attrs {\n+        for attr in attrs {\n             is_valid &= if attr.check_name(sym::inline) {\n-                self.check_inline(attr, &item.span, target)\n+                self.check_inline(hir_id, attr, span, target)\n             } else if attr.check_name(sym::non_exhaustive) {\n-                self.check_non_exhaustive(attr, item, target)\n+                self.check_non_exhaustive(attr, span, target)\n             } else if attr.check_name(sym::marker) {\n-                self.check_marker(attr, item, target)\n+                self.check_marker(attr, span, target)\n             } else if attr.check_name(sym::target_feature) {\n-                self.check_target_feature(attr, item, target)\n+                self.check_target_feature(attr, span, target)\n+            } else if attr.check_name(sym::track_caller) {\n+                self.check_track_caller(&attr.span, attrs, span, target)\n             } else {\n                 true\n             };\n@@ -113,33 +183,105 @@ impl CheckAttrVisitor<'tcx> {\n         }\n \n         if target == Target::Fn {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n \n-        self.check_repr(item, target);\n-        self.check_used(item, target);\n+        self.check_repr(attrs, span, target, item);\n+        self.check_used(attrs, target);\n     }\n \n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n-    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) -> bool {\n-        if target != Target::Fn && target != Target::Closure {\n-            struct_span_err!(self.tcx.sess,\n-                             attr.span,\n-                             E0518,\n-                             \"attribute should be applied to function or closure\")\n-                .span_label(*span, \"not a function or closure\")\n+    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Fn | Target::Closure | Target::Method(MethodKind::Trait { body: true })\n+            | Target::Method(MethodKind::Inherent) => true,\n+            Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n+                self.tcx.struct_span_lint_hir(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    \"`#[inline]` is ignored on function prototypes\",\n+                ).emit();\n+                true\n+            }\n+            // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n+            // just a lint, because we previously erroneously allowed it and some crates used it\n+            // accidentally, to to be compatible with crates depending on them, we can't throw an\n+            // error here.\n+            Target::AssocConst => {\n+                self.tcx.struct_span_lint_hir(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    \"`#[inline]` is ignored on constants\",\n+                ).warn(\"this was previously accepted by the compiler but is \\\n+                       being phased out; it will become a hard error in \\\n+                       a future release!\")\n+                .note(\"for more information, see issue #65833 \\\n+                       <https://github.com/rust-lang/rust/issues/65833>\")\n                 .emit();\n-            false\n-        } else {\n-            true\n+                true\n+            }\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    attr.span,\n+                    E0518,\n+                    \"attribute should be applied to function or closure\",\n+                ).span_label(*span, \"not a function or closure\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n+    fn check_track_caller(\n+        &self,\n+        attr_span: &Span,\n+        attrs: &HirVec<Attribute>,\n+        span: &Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Fn if attr::contains_name(attrs, sym::naked) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0736,\n+                    \"cannot use `#[track_caller]` with `#[naked]`\",\n+                ).emit();\n+                false\n+            }\n+            Target::Fn | Target::Method(MethodKind::Inherent) => true,\n+            Target::Method(_) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0738,\n+                    \"`#[track_caller]` may not be used on trait methods\",\n+                ).emit();\n+                false\n+            }\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0739,\n+                    \"attribute should be applied to function\"\n+                )\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+                false\n+            }\n         }\n     }\n \n     /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n     fn check_non_exhaustive(\n         &self,\n-        attr: &hir::Attribute,\n-        item: &hir::Item,\n+        attr: &Attribute,\n+        span: &Span,\n         target: Target,\n     ) -> bool {\n         match target {\n@@ -149,54 +291,56 @@ impl CheckAttrVisitor<'tcx> {\n                                  attr.span,\n                                  E0701,\n                                  \"attribute can only be applied to a struct or enum\")\n-                    .span_label(item.span, \"not a struct or enum\")\n+                    .span_label(*span, \"not a struct or enum\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) -> bool {\n+    fn check_marker(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n             Target::Trait => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(item.span, \"not a trait\")\n+                    .span_label(*span, \"not a trait\")\n                     .emit();\n                 false\n             }\n         }\n     }\n \n     /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n-    fn check_target_feature(\n-        &self,\n-        attr: &hir::Attribute,\n-        item: &hir::Item,\n-        target: Target,\n-    ) -> bool {\n+    fn check_target_feature(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n-            Target::Fn => true,\n+            Target::Fn | Target::Method(MethodKind::Trait { body: true })\n+            | Target::Method(MethodKind::Inherent) => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(item.span, \"not a function\")\n+                    .span_label(*span, \"not a function\")\n                     .emit();\n                 false\n             },\n         }\n     }\n \n     /// Checks if the `#[repr]` attributes on `item` are valid.\n-    fn check_repr(&self, item: &hir::Item, target: Target) {\n+    fn check_repr(\n+        &self,\n+        attrs: &HirVec<Attribute>,\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item>,\n+    ) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n         // #[repr(foo)]\n         // #[repr(bar, align(8))]\n         // ```\n-        let hints: Vec<_> = item.attrs\n+        let hints: Vec<_> = attrs\n             .iter()\n             .filter(|attr| attr.check_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n@@ -254,7 +398,7 @@ impl CheckAttrVisitor<'tcx> {\n             };\n             self.emit_repr_error(\n                 hint.span(),\n-                item.span,\n+                *span,\n                 &format!(\"attribute should be applied to {}\", allowed_targets),\n                 &format!(\"not {} {}\", article, allowed_targets),\n             )\n@@ -273,7 +417,7 @@ impl CheckAttrVisitor<'tcx> {\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n            || (is_simd && is_c)\n-           || (int_reprs == 1 && is_c && is_c_like_enum(item)) {\n+           || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item))) {\n             let hint_spans: Vec<_> = hint_spans.collect();\n             span_warn!(self.tcx.sess, hint_spans, E0566,\n                        \"conflicting representation hints\");\n@@ -297,7 +441,7 @@ impl CheckAttrVisitor<'tcx> {\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n                 if attr.check_name(sym::inline) {\n-                    self.check_inline(attr, &stmt.span, Target::Statement);\n+                    self.check_inline(DUMMY_HIR_ID, attr, &stmt.span, Target::Statement);\n                 }\n                 if attr.check_name(sym::repr) {\n                     self.emit_repr_error(\n@@ -318,7 +462,7 @@ impl CheckAttrVisitor<'tcx> {\n         };\n         for attr in expr.attrs.iter() {\n             if attr.check_name(sym::inline) {\n-                self.check_inline(attr, &expr.span, target);\n+                self.check_inline(DUMMY_HIR_ID, attr, &expr.span, target);\n             }\n             if attr.check_name(sym::repr) {\n                 self.emit_repr_error(\n@@ -331,8 +475,8 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_used(&self, item: &hir::Item, target: Target) {\n-        for attr in &item.attrs {\n+    fn check_used(&self, attrs: &HirVec<Attribute>, target: Target) {\n+        for attr in attrs {\n             if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n@@ -346,12 +490,29 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n         let target = Target::from_item(item);\n-        self.check_attributes(item, target);\n+        self.check_attributes(item.hir_id, &item.attrs, &item.span, target, Some(item));\n         intravisit::walk_item(self, item)\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem) {\n+        let target = Target::from_trait_item(trait_item);\n+        self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);\n+        intravisit::walk_trait_item(self, trait_item)\n+    }\n+\n+    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem) {\n+        let target = Target::from_foreign_item(f_item);\n+        self.check_attributes(f_item.hir_id, &f_item.attrs, &f_item.span, target, None);\n+        intravisit::walk_foreign_item(self, f_item)\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        let target = Target::from_impl_item(self.tcx, impl_item);\n+        self.check_attributes(impl_item.hir_id, &impl_item.attrs, &impl_item.span, target, None);\n+        intravisit::walk_impl_item(self, impl_item)\n+    }\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         self.check_stmt_attributes(stmt);\n@@ -364,12 +525,12 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     }\n }\n \n-fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemKind::Enum(ref def, _) = item.kind {\n+fn is_c_like_enum(item: &Item) -> bool {\n+    if let ItemKind::Enum(ref def, _) = item.kind {\n         for variant in &def.variants {\n             match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n-                _ => { return false; }\n+                _ => return false,\n             }\n         }\n         true"}, {"sha": "d4d7af92fe359593f9516d83011d45ea74be5ce1", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -6,8 +6,8 @@ use crate::ty;\n use crate::util::nodemap::DefIdMap;\n \n use syntax::ast;\n-use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n+use syntax_pos::hygiene::MacroKind;\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n "}, {"sha": "13200b38f2cdae131c80ef933f7026748956d6cc", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,9 +1,9 @@\n use crate::ty::{self, TyCtxt};\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_index::vec::Idx;\n use std::fmt;\n use std::u32;\n \n-newtype_index! {\n+rustc_index::newtype_index! {\n     pub struct CrateId {\n         ENCODABLE = custom\n     }\n@@ -87,7 +87,7 @@ impl fmt::Display for CrateNum {\n impl rustc_serialize::UseSpecializedEncodable for CrateNum {}\n impl rustc_serialize::UseSpecializedDecodable for CrateNum {}\n \n-newtype_index! {\n+rustc_index::newtype_index! {\n     /// A DefIndex is an index into the hir-map for a crate, identifying a\n     /// particular definition. It should really be considered an interned\n     /// shorthand for a particular DefPath."}, {"sha": "920635d838738f2e96fa63c6fef8ef44b38c77a0", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -203,7 +203,7 @@ pub trait Visitor<'v>: Sized {\n \n     /// Invoked to visit the body of a function, method or closure. Like\n     /// visit_nested_item, does nothing by default unless you override\n-    /// `nested_visit_map` to return other htan `None`, in which case it will walk\n+    /// `nested_visit_map` to return other than `None`, in which case it will walk\n     /// the body.\n     fn visit_nested_body(&mut self, id: BodyId) {\n         let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n@@ -633,9 +633,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n-        TyKind::CVarArgs(ref lt) => {\n-            visitor.visit_lifetime(lt)\n-        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }"}, {"sha": "12ab44515c38d03b6e21102c743714b04b38908c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -52,7 +52,7 @@ use crate::util::common::FN_OUTPUT_NAME;\n use crate::util::nodemap::{DefIdMap, NodeMap};\n use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_index::vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n@@ -64,14 +64,15 @@ use syntax::ast;\n use syntax::ptr::P as AstP;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::base::SpecialDerives;\n-use syntax::ext::hygiene::ExpnId;\n+use syntax::expand::SpecialDerives;\n use syntax::print::pprust;\n+use syntax::parse::token::{self, Nonterminal, Token};\n+use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::sess::ParseSess;\n use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n+use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n@@ -82,10 +83,13 @@ pub struct LoweringContext<'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    cstore: &'a dyn CrateStore,\n-\n     resolver: &'a mut dyn Resolver,\n \n+    /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n+    /// if we don't have this function pointer. To avoid that dependency so that\n+    /// librustc is independent of the parser, we use dynamic dispatch here.\n+    nt_to_tokenstream: NtToTokenstream,\n+\n     /// The items being lowered are collected here.\n     items: BTreeMap<hir::HirId, hir::Item>,\n \n@@ -154,6 +158,8 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n+    fn cstore(&self) -> &dyn CrateStore;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -180,6 +186,8 @@ pub trait Resolver {\n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n }\n \n+type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n+\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -232,21 +240,23 @@ impl<'a> ImplTraitContext<'a> {\n \n pub fn lower_crate(\n     sess: &Session,\n-    cstore: &dyn CrateStore,\n     dep_graph: &DepGraph,\n     krate: &Crate,\n     resolver: &mut dyn Resolver,\n+    nt_to_tokenstream: NtToTokenstream,\n ) -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n+    let _prof_timer = sess.prof.generic_activity(\"hir_lowering\");\n+\n     LoweringContext {\n         crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n-        cstore,\n         resolver,\n+        nt_to_tokenstream,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -780,15 +790,15 @@ impl<'a> LoweringContext<'a> {\n         // really show up for end-user.\n         let (str_name, kind) = match hir_name {\n             ParamName::Plain(ident) => (\n-                ident.as_interned_str(),\n+                ident.name,\n                 hir::LifetimeParamKind::InBand,\n             ),\n             ParamName::Fresh(_) => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Elided,\n             ),\n             ParamName::Error => (\n-                kw::UnderscoreLifetime.as_interned_str(),\n+                kw::UnderscoreLifetime,\n                 hir::LifetimeParamKind::Error,\n             ),\n         };\n@@ -844,7 +854,7 @@ impl<'a> LoweringContext<'a> {\n     /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n-        let index = self.lifetimes_to_define.len();\n+        let index = self.lifetimes_to_define.len() + self.in_scope_lifetimes.len();\n         let hir_name = ParamName::Fresh(index);\n         self.lifetimes_to_define.push((span, hir_name));\n         hir_name\n@@ -968,7 +978,7 @@ impl<'a> LoweringContext<'a> {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n         } else {\n-            self.cstore.def_key(id)\n+            self.resolver.cstore().def_key(id)\n         }\n     }\n \n@@ -988,10 +998,12 @@ impl<'a> LoweringContext<'a> {\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n         Attribute {\n+            item: AttrItem {\n+                path: attr.path.clone(),\n+                tokens: self.lower_token_stream(attr.tokens.clone()),\n+            },\n             id: attr.id,\n             style: attr.style,\n-            path: attr.path.clone(),\n-            tokens: self.lower_token_stream(attr.tokens.clone()),\n             is_sugared_doc: attr.is_sugared_doc,\n             span: attr.span,\n         }\n@@ -1018,7 +1030,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n             token::Interpolated(nt) => {\n-                let tts = nt.to_tokenstream(&self.sess.parse_sess, token.span);\n+                let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }\n             _ => TokenTree::Token(token).into(),\n@@ -1335,13 +1347,8 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now\"),\n-            TyKind::CVarArgs => {\n-                // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n-                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n-                let lt = self.new_implicit_lifetime(span);\n-                hir::TyKind::CVarArgs(lt)\n-            },\n+            TyKind::Mac(_) => bug!(\"`TyKind::Mac` should have been expanded by now\"),\n+            TyKind::CVarArgs => bug!(\"`TyKind::CVarArgs` should have been handled elsewhere\"),\n         };\n \n         hir::Ty {\n@@ -1581,7 +1588,7 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().as_interned_str()),\n+                        DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),\n                         lifetime.span);\n \n@@ -1718,8 +1725,8 @@ impl<'a> LoweringContext<'a> {\n                             return n;\n                         }\n                         assert!(!def_id.is_local());\n-                        let item_generics =\n-                            self.cstore.item_generics_cloned_untracked(def_id, self.sess);\n+                        let item_generics = self.resolver.cstore()\n+                            .item_generics_cloned_untracked(def_id, self.sess);\n                         let n = item_generics.own_counts().lifetimes;\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n\n@@ -2093,7 +2100,14 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n-        decl.inputs\n+        // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n+        // as they are not explicit in HIR/Ty function signatures.\n+        // (instead, the `c_variadic` flag is set to `true`)\n+        let mut inputs = &decl.inputs[..];\n+        if decl.c_variadic() {\n+            inputs = &inputs[..inputs.len() - 1];\n+        }\n+        inputs\n             .iter()\n             .map(|param| match param.pat.kind {\n                 PatKind::Ident(_, ident, _) => ident,\n@@ -2130,10 +2144,19 @@ impl<'a> LoweringContext<'a> {\n             self.anonymous_lifetime_mode\n         };\n \n+        let c_variadic = decl.c_variadic();\n+\n         // Remember how many lifetimes were already around so that we can\n         // only look at the lifetime parameters introduced by the arguments.\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n-            decl.inputs\n+            // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n+            // as they are not explicit in HIR/Ty function signatures.\n+            // (instead, the `c_variadic` flag is set to `true`)\n+            let mut inputs = &decl.inputs[..];\n+            if c_variadic {\n+                inputs = &inputs[..inputs.len() - 1];\n+            }\n+            inputs\n                 .iter()\n                 .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n@@ -2168,7 +2191,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::FnDecl {\n             inputs,\n             output,\n-            c_variadic: decl.c_variadic,\n+            c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {\n@@ -3266,10 +3289,14 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.sess.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-\n-            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n+            // `PassThrough` is the normal case.\n+            // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n+            // is unsuitable here, as these can occur from missing lifetime parameters in a\n+            // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n+            // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n+            // later, at which point a suitable error will be emitted.\n+          | AnonymousLifetimeMode::PassThrough\n+          | AnonymousLifetimeMode::ReportError => self.new_implicit_lifetime(span),\n         }\n     }\n "}, {"sha": "73db762a64bda22d905ddb23135b1bedef35b723", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 71, "deletions": 40, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -89,9 +89,14 @@ impl LoweringContext<'_> {\n                 hir::MatchSource::Normal,\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n-                self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n-                    this.with_new_scopes(|this| this.lower_block_expr(block))\n-                })\n+                self.make_async_expr(\n+                    capture_clause,\n+                    closure_node_id,\n+                    None,\n+                    block.span,\n+                    hir::AsyncGeneratorKind::Block,\n+                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                )\n             }\n             ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n             ExprKind::Closure(\n@@ -230,11 +235,20 @@ impl LoweringContext<'_> {\n     /// ```\n     fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n-        self.sess\n-            .struct_span_err(span, \"`let` expressions are not supported here\")\n-            .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-            .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n-            .emit();\n+\n+        if self.sess.opts.unstable_features.is_nightly_build() {\n+            self.sess\n+                .struct_span_err(span, \"`let` expressions are not supported here\")\n+                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                .emit();\n+        }\n+        else {\n+            self.sess\n+                .struct_span_err(span, \"expected expression, found statement (`let`)\")\n+                .note(\"variable declaration using `let` is a statement\")\n+                .emit();\n+        }\n \n         // For better recovery, we emit:\n         // ```\n@@ -392,32 +406,49 @@ impl LoweringContext<'_> {\n         )\n     }\n \n+    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n+    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n+    /// and save the block id to use it as a break target for desugaring of the `?` operator.\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n         self.with_catch_scope(body.id, |this| {\n-            let unstable_span = this.mark_span_with_reason(\n+            let mut block = this.lower_block(body, true).into_inner();\n+\n+            let try_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n                 body.span,\n                 this.allow_try_trait.clone(),\n             );\n-            let mut block = this.lower_block(body, true).into_inner();\n-            let tail = block.expr.take().map_or_else(\n-                || this.expr_unit(this.sess.source_map().end_point(unstable_span)),\n+\n+            // Final expression of the block (if present) or `()` with span at the end of block\n+            let tail_expr = block.expr.take().map_or_else(\n+                || this.expr_unit(this.sess.source_map().end_point(try_span)),\n                 |x: P<hir::Expr>| x.into_inner(),\n             );\n-            block.expr = Some(this.wrap_in_try_constructor(sym::from_ok, tail, unstable_span));\n+\n+            let ok_wrapped_span = this.mark_span_with_reason(\n+                DesugaringKind::TryBlock,\n+                tail_expr.span,\n+                None\n+            );\n+\n+            // `::std::ops::Try::from_ok($tail_expr)`\n+            block.expr = Some(this.wrap_in_try_constructor(\n+                sym::from_ok, try_span, tail_expr, ok_wrapped_span));\n+\n             hir::ExprKind::Block(P(block), None)\n         })\n     }\n \n     fn wrap_in_try_constructor(\n         &mut self,\n         method: Symbol,\n-        e: hir::Expr,\n-        unstable_span: Span,\n+        method_span: Span,\n+        expr: hir::Expr,\n+        overall_span: Span,\n     ) -> P<hir::Expr> {\n         let path = &[sym::ops, sym::Try, method];\n-        let from_err = P(self.expr_std_path(unstable_span, path, None, ThinVec::new()));\n-        P(self.expr_call(e.span, from_err, hir_vec![e]))\n+        let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+        P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -440,6 +471,7 @@ impl LoweringContext<'_> {\n         closure_node_id: NodeId,\n         ret_ty: Option<AstP<Ty>>,\n         span: Span,\n+        async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n         let capture_clause = self.lower_capture_clause(capture_clause);\n@@ -450,11 +482,10 @@ impl LoweringContext<'_> {\n         let ast_decl = FnDecl {\n             inputs: vec![],\n             output,\n-            c_variadic: false\n         };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n-            this.generator_kind = Some(hir::GeneratorKind::Async);\n+            this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n             body(this)\n         });\n \n@@ -506,7 +537,7 @@ impl LoweringContext<'_> {\n     /// ```\n     fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind {\n         match self.generator_kind {\n-            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Async(_)) => {},\n             Some(hir::GeneratorKind::Gen) |\n             None => {\n                 let mut err = struct_span_err!(\n@@ -711,7 +742,7 @@ impl LoweringContext<'_> {\n                     Movability::Static => hir::GeneratorMovability::Static,\n                 })\n             },\n-            Some(hir::GeneratorKind::Async) => {\n+            Some(hir::GeneratorKind::Async(_)) => {\n                 bug!(\"non-`async` closure body turned `async` during lowering\");\n             },\n             None => {\n@@ -739,7 +770,6 @@ impl LoweringContext<'_> {\n         let outer_decl = FnDecl {\n             inputs: decl.inputs.clone(),\n             output: FunctionRetTy::Default(fn_decl_span),\n-            c_variadic: false,\n         };\n         // We need to lower the declaration outside the new scope, because we\n         // have to conserve the state of being inside a loop condition for the\n@@ -771,10 +801,12 @@ impl LoweringContext<'_> {\n                     None\n                 };\n                 let async_body = this.make_async_expr(\n-                    capture_clause, closure_id, async_ret_ty, body.span,\n-                    |this| {\n-                        this.with_new_scopes(|this| this.lower_expr(body))\n-                    }\n+                    capture_clause,\n+                    closure_id,\n+                    async_ret_ty,\n+                    body.span,\n+                    hir::AsyncGeneratorKind::Closure,\n+                    |this| this.with_new_scopes(|this| this.lower_expr(body)),\n                 );\n                 this.expr(fn_decl_span, async_body, ThinVec::new())\n             });\n@@ -990,7 +1022,7 @@ impl LoweringContext<'_> {\n     fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {},\n-            Some(hir::GeneratorKind::Async) => {\n+            Some(hir::GeneratorKind::Async(_)) => {\n                 span_err!(\n                     self.sess,\n                     span,\n@@ -1039,10 +1071,9 @@ impl LoweringContext<'_> {\n     ) -> hir::Expr {\n         // expand <head>\n         let mut head = self.lower_expr(head);\n-        let head_sp = head.span;\n         let desugared_span = self.mark_span_with_reason(\n             DesugaringKind::ForLoop,\n-            head_sp,\n+            head.span,\n             None,\n         );\n         head.span = desugared_span;\n@@ -1088,21 +1119,21 @@ impl LoweringContext<'_> {\n \n         // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n-            let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n+            let iter = P(self.expr_ident(desugared_span, iter, iter_pat_nid));\n+            let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n             let next_path = &[sym::iter, sym::Iterator, sym::next];\n             let next_expr = P(self.expr_call_std_path(\n-                head_sp,\n+                desugared_span,\n                 next_path,\n                 hir_vec![ref_mut_iter],\n             ));\n             let arms = hir_vec![pat_arm, break_arm];\n \n-            self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+            self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n-        let match_stmt = self.stmt_expr(head_sp, match_expr);\n+        let match_stmt = self.stmt_expr(desugared_span, match_expr);\n \n-        let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n+        let next_expr = P(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n@@ -1117,7 +1148,7 @@ impl LoweringContext<'_> {\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n             ThinVec::new(),\n-            head_sp,\n+            desugared_span,\n             Some(next_expr),\n             pat,\n             hir::LocalSource::ForLoopDesugar,\n@@ -1154,14 +1185,14 @@ impl LoweringContext<'_> {\n             let into_iter_path =\n                 &[sym::iter, sym::IntoIterator, sym::into_iter];\n             P(self.expr_call_std_path(\n-                head_sp,\n+                desugared_span,\n                 into_iter_path,\n                 hir_vec![head],\n             ))\n         };\n \n         let match_expr = P(self.expr_match(\n-            head_sp,\n+            desugared_span,\n             into_iter_expr,\n             hir_vec![iter_arm],\n             hir::MatchSource::ForLoopDesugar,\n@@ -1173,7 +1204,7 @@ impl LoweringContext<'_> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n+        self.expr_drop_temps(desugared_span, match_expr, e.attrs.clone())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1247,7 +1278,7 @@ impl LoweringContext<'_> {\n                 self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n             };\n             let from_err_expr =\n-                self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n+                self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().map(|x| *x);\n             let ret_expr = if let Some(catch_node) = catch_scope {"}, {"sha": "9da87090c79bb75bdfb17ca2b3449045ca78dfe4", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -18,7 +18,7 @@ use smallvec::SmallVec;\n use syntax::attr;\n use syntax::ast::*;\n use syntax::visit::{self, Visitor};\n-use syntax::ext::base::SpecialDerives;\n+use syntax::expand::SpecialDerives;\n use syntax::source_map::{respan, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n@@ -1222,7 +1222,11 @@ impl LoweringContext<'_> {\n             }\n \n             let async_expr = this.make_async_expr(\n-                CaptureBy::Value, closure_id, None, body.span,\n+                CaptureBy::Value,\n+                closure_id,\n+                None,\n+                body.span,\n+                hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n                     let user_body = this.lower_block_expr(body);"}, {"sha": "b0fa844c81881a01710696d6f1594ec4f1fdabdb", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -5,7 +5,7 @@ use crate::hir::map::HirEntryMap;\n use crate::hir::def_id::{LOCAL_CRATE, CrateNum};\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_index::vec::IndexVec;\n use crate::ich::Fingerprint;\n use crate::middle::cstore::CrateStore;\n use crate::session::CrateDisambiguator;\n@@ -17,7 +17,7 @@ use syntax_pos::Span;\n use std::iter::repeat;\n \n use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n@@ -149,7 +149,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let mut collector = NodeCollector {\n             krate,\n             source_map: sess.source_map(),\n-            map: vec![None; definitions.def_index_count()],\n+            map: IndexVec::from_elem_n(IndexVec::new(), definitions.def_index_count()),\n             parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -186,13 +186,13 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum).as_interned_str();\n+            let name = cstore.crate_name_untracked(cnum);\n             let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n         }).collect();\n \n-        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name, dis));\n+        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name.as_str(), dis));\n \n         // We hash the final, remapped names of all local source files so we\n         // don't have to include the path prefix remapping commandline args.\n@@ -227,12 +227,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        let local_map = &mut self.map[id.owner.index()];\n+        let local_map = &mut self.map[id.owner];\n         let i = id.local_id.as_u32() as usize;\n-        if local_map.is_none() {\n-            *local_map = Some(IndexVec::with_capacity(i + 1));\n-        }\n-        let local_map = local_map.as_mut().unwrap();\n         let len = local_map.len();\n         if i >= len {\n             local_map.extend(repeat(None).take(i - len + 1));\n@@ -602,9 +598,7 @@ impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n where\n     T: HashStable<StableHashingContext<'hir>>,\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n             self.item_like.hash_stable(hcx, hasher);\n         });"}, {"sha": "e9970e30bf9e5d716a33eff2839567be8dc61324", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -2,10 +2,10 @@ use crate::hir::map::definitions::*;\n use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n-use syntax::ext::hygiene::ExpnId;\n use syntax::visit;\n use syntax::symbol::{kw, sym};\n use syntax::parse::token::{self, Token};\n+use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n \n /// Creates `DefId`s for nodes in the AST.\n@@ -57,7 +57,7 @@ impl<'a> DefCollector<'a> {\n \n         // For async functions, we need to create their inner defs inside of a\n         // closure to match their desugared representation.\n-        let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n+        let fn_def_data = DefPathData::ValueNs(name);\n         let fn_def = self.create_def(id, fn_def_data, span);\n         return self.with_parent(fn_def, |this| {\n             this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n@@ -83,14 +83,13 @@ impl<'a> DefCollector<'a> {\n                 .unwrap_or_else(|| {\n                     let node_id = NodeId::placeholder_from_expn_id(self.expansion);\n                     sym::integer(self.definitions.placeholder_field_indices[&node_id])\n-                })\n-                .as_interned_str();\n+                });\n             let def = self.create_def(field.id, DefPathData::ValueNs(name), field.span);\n             self.with_parent(def, |this| visit::walk_struct_field(this, field));\n         }\n     }\n \n-    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n+    fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }\n@@ -109,7 +108,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) | ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::OpaqueTy(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n-            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.as_interned_str()),\n+            ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             ItemKind::Fn(\n                 ref decl,\n                 ref header,\n@@ -127,8 +126,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 )\n             }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.as_interned_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.as_interned_str()),\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::MacroDef(..) => DefPathData::MacroNs(i.ident.name),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n@@ -162,7 +161,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n \n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.as_interned_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.name),\n                                   foreign_item.span);\n \n         self.with_parent(def, |this| {\n@@ -175,7 +174,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             return self.visit_macro_invoc(v.id);\n         }\n         let def = self.create_def(v.id,\n-                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n+                                  DefPathData::TypeNs(v.ident.name),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n@@ -202,7 +201,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             self.visit_macro_invoc(param.id);\n             return;\n         }\n-        let name = param.ident.as_interned_str();\n+        let name = param.ident.name;\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeNs(name),\n@@ -216,9 +215,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.kind {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.as_interned_str()),\n+                DefPathData::ValueNs(ti.ident.name),\n             TraitItemKind::Type(..) => {\n-                DefPathData::TypeNs(ti.ident.as_interned_str())\n+                DefPathData::TypeNs(ti.ident.name)\n             },\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n@@ -243,12 +242,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     body,\n                 )\n             }\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.as_interned_str()),\n+            ImplItemKind::Method(..) |\n+            ImplItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n             ImplItemKind::TyAlias(..) |\n-            ImplItemKind::OpaqueTy(..) => {\n-                DefPathData::TypeNs(ii.ident.as_interned_str())\n-            },\n+            ImplItemKind::OpaqueTy(..) => DefPathData::TypeNs(ii.ident.name),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n "}, {"sha": "be8d82173e481e87a19e4252ec85c78e0ec05421", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -11,14 +11,14 @@ use crate::session::CrateDisambiguator;\n use crate::util::nodemap::NodeMap;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::{IndexVec};\n+use rustc_index::vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n-use syntax::ext::hygiene::ExpnId;\n-use syntax::symbol::{Symbol, sym, InternedString};\n+use syntax_pos::symbol::{Symbol, sym};\n+use syntax_pos::hygiene::ExpnId;\n use syntax_pos::{Span, DUMMY_SP};\n \n /// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n@@ -27,8 +27,8 @@ use syntax_pos::{Span, DUMMY_SP};\n /// There is one `DefPathTable` for each crate.\n #[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n pub struct DefPathTable {\n-    index_to_key: Vec<DefKey>,\n-    def_path_hashes: Vec<DefPathHash>,\n+    index_to_key: IndexVec<DefIndex, DefKey>,\n+    def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n }\n \n impl DefPathTable {\n@@ -53,14 +53,14 @@ impl DefPathTable {\n \n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.index_to_key[index.index()].clone()\n+        self.index_to_key[index]\n     }\n \n     #[inline(always)]\n     pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        let ret = self.def_path_hashes[index.index()];\n-        debug!(\"def_path_hash({:?}) = {:?}\", index, ret);\n-        return ret\n+        let hash = self.def_path_hashes[index];\n+        debug!(\"def_path_hash({:?}) = {:?}\", index, hash);\n+        hash\n     }\n \n     pub fn add_def_path_hashes_to(&self,\n@@ -92,7 +92,7 @@ impl DefPathTable {\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: Vec<ast::NodeId>,\n+    def_index_to_node: IndexVec<DefIndex, ast::NodeId>,\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n     /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n@@ -111,7 +111,7 @@ pub struct Definitions {\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n-#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n     /// The parent path.\n     pub parent: Option<DefIndex>,\n@@ -136,7 +136,9 @@ impl DefKey {\n \n         ::std::mem::discriminant(data).hash(&mut hasher);\n         if let Some(name) = data.get_opt_name() {\n-            name.hash(&mut hasher);\n+            // Get a stable hash by considering the symbol chars rather than\n+            // the symbol index.\n+            name.as_str().hash(&mut hasher);\n         }\n \n         disambiguator.hash(&mut hasher);\n@@ -162,13 +164,13 @@ impl DefKey {\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n-#[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n     pub disambiguator: u32\n }\n \n-#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n@@ -218,7 +220,7 @@ impl DefPath {\n         for component in &self.data {\n             write!(s,\n                    \"::{}[{}]\",\n-                   component.data.as_interned_str(),\n+                   component.data.as_symbol(),\n                    component.disambiguator)\n                 .unwrap();\n         }\n@@ -238,11 +240,11 @@ impl DefPath {\n \n         for component in &self.data {\n             if component.disambiguator == 0 {\n-                write!(s, \"::{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"::{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -262,11 +264,11 @@ impl DefPath {\n             opt_delimiter.map(|d| s.push(d));\n             opt_delimiter = Some('-');\n             if component.disambiguator == 0 {\n-                write!(s, \"{}\", component.data.as_interned_str()).unwrap();\n+                write!(s, \"{}\", component.data.as_symbol()).unwrap();\n             } else {\n                 write!(s,\n                        \"{}[{}]\",\n-                       component.data.as_interned_str(),\n+                       component.data.as_symbol(),\n                        component.disambiguator)\n                        .unwrap();\n             }\n@@ -275,7 +277,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n@@ -290,13 +292,13 @@ pub enum DefPathData {\n     /// An impl.\n     Impl,\n     /// Something in the type namespace.\n-    TypeNs(InternedString),\n+    TypeNs(Symbol),\n     /// Something in the value namespace.\n-    ValueNs(InternedString),\n+    ValueNs(Symbol),\n     /// Something in the macro namespace.\n-    MacroNs(InternedString),\n+    MacroNs(Symbol),\n     /// Something in the lifetime namespace.\n-    LifetimeNs(InternedString),\n+    LifetimeNs(Symbol),\n     /// A closure expression.\n     ClosureExpr,\n \n@@ -311,7 +313,7 @@ pub enum DefPathData {\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n     /// supposed to show up right below the crate root.\n-    GlobalMetaData(InternedString),\n+    GlobalMetaData(Symbol),\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -357,7 +359,7 @@ impl Definitions {\n \n     #[inline]\n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_to_def_index.get(&node).cloned()\n+        self.node_to_def_index.get(&node).copied()\n     }\n \n     #[inline]\n@@ -373,7 +375,7 @@ impl Definitions {\n     #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            let node_id = self.def_index_to_node[def_id.index.index()];\n+            let node_id = self.def_index_to_node[def_id.index];\n             if node_id != ast::DUMMY_NODE_ID {\n                 return Some(node_id);\n             }\n@@ -402,7 +404,7 @@ impl Definitions {\n \n     #[inline]\n     pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n-        let node_id = self.def_index_to_node[def_index.index()];\n+        let node_id = self.def_index_to_node[def_index];\n         self.node_to_hir_id[node_id]\n     }\n \n@@ -411,7 +413,7 @@ impl Definitions {\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n-            self.def_index_to_span.get(&def_id.index).cloned()\n+            self.def_index_to_span.get(&def_id.index).copied()\n         } else {\n             None\n         }\n@@ -470,7 +472,7 @@ impl Definitions {\n \n         // Find the next free disambiguator for this key.\n         let disambiguator = {\n-            let next_disamb = self.next_disambiguator.entry((parent, data.clone())).or_insert(0);\n+            let next_disamb = self.next_disambiguator.entry((parent, data)).or_insert(0);\n             let disambiguator = *next_disamb;\n             *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n             disambiguator\n@@ -523,7 +525,7 @@ impl Definitions {\n     }\n \n     pub fn expansion_that_defined(&self, index: DefIndex) -> ExpnId {\n-        self.expansions_that_defined.get(&index).cloned().unwrap_or(ExpnId::root())\n+        self.expansions_that_defined.get(&index).copied().unwrap_or(ExpnId::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, expn_id: ExpnId) -> DefId {\n@@ -545,7 +547,7 @@ impl Definitions {\n }\n \n impl DefPathData {\n-    pub fn get_opt_name(&self) -> Option<InternedString> {\n+    pub fn get_opt_name(&self) -> Option<Symbol> {\n         use self::DefPathData::*;\n         match *self {\n             TypeNs(name) |\n@@ -564,15 +566,15 @@ impl DefPathData {\n         }\n     }\n \n-    pub fn as_interned_str(&self) -> InternedString {\n+    pub fn as_symbol(&self) -> Symbol {\n         use self::DefPathData::*;\n-        let s = match *self {\n+        match *self {\n             TypeNs(name) |\n             ValueNs(name) |\n             MacroNs(name) |\n             LifetimeNs(name) |\n             GlobalMetaData(name) => {\n-                return name\n+                name\n             }\n             // Note that this does not show up in user print-outs.\n             CrateRoot => sym::double_braced_crate,\n@@ -582,13 +584,11 @@ impl DefPathData {\n             Ctor => sym::double_braced_constructor,\n             AnonConst => sym::double_braced_constant,\n             ImplTrait => sym::double_braced_opaque,\n-        };\n-\n-        s.as_interned_str()\n+        }\n     }\n \n     pub fn to_string(&self) -> String {\n-        self.as_interned_str().to_string()\n+        self.as_symbol().to_string()\n     }\n }\n \n@@ -599,7 +599,6 @@ macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n     }) => (\n-        #[derive(Clone, Copy, Debug, Hash, RustcEncodable, RustcDecodable)]\n         pub enum GlobalMetaDataKind {\n             $($variant),*\n         }\n@@ -611,7 +610,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n+                        DefPathData::GlobalMetaData(instance.name()),\n                         ExpnId::root(),\n                         DUMMY_SP\n                     );\n@@ -625,7 +624,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name().as_interned_str()),\n+                        data: DefPathData::GlobalMetaData(self.name()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "acadd77cc36c08872c87ffdd2a63dc4aaa5912eb", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -17,10 +17,10 @@ use crate::util::common::time;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_index::vec::IndexVec;\n use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n-use syntax::ext::base::MacroKind;\n+use syntax_pos::hygiene::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub mod blocks;\n@@ -156,9 +156,9 @@ impl Forest {\n \n /// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n /// but it is implemented as 2 layers of arrays.\n-/// - first we have `A = Vec<Option<B>>` mapping a `DefIndex`'s index to an inner value\n+/// - first we have `A = IndexVec<DefIndex, B>` mapping `DefIndex`s to an inner value\n /// - which is `B = IndexVec<ItemLocalId, Option<Entry<'hir>>` which gives you the `Entry`.\n-pub(super) type HirEntryMap<'hir> = Vec<Option<IndexVec<ItemLocalId, Option<Entry<'hir>>>>>;\n+pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Option<Entry<'hir>>>>;\n \n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n@@ -222,8 +222,8 @@ impl<'map> Iterator for ParentHirIterator<'map> {\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n-        let local_map = self.map.get(id.owner.index())?;\n-        local_map.as_ref()?.get(id.local_id)?.as_ref()\n+        let local_map = self.map.get(id.owner)?;\n+        local_map.get(id.local_id)?.as_ref()\n     }\n \n     /// Registers a read in the dependency graph of the AST node with\n@@ -818,6 +818,32 @@ impl<'hir> Map<'hir> {\n         CRATE_HIR_ID\n     }\n \n+    /// When on a match arm tail expression or on a match arm, give back the enclosing `match`\n+    /// expression.\n+    ///\n+    /// Used by error reporting when there's a type error in a match arm caused by the `match`\n+    /// expression needing to be unit.\n+    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&Expr> {\n+        for (_, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => break,\n+                Node::Expr(expr) => match expr.kind {\n+                    ExprKind::Match(_, _, _) => return Some(expr),\n+                    _ => {}\n+                },\n+                Node::Stmt(stmt) => match stmt.kind {\n+                    StmtKind::Local(_) => break,\n+                    _ => {}\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+\n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n         for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n@@ -1005,14 +1031,12 @@ impl<'hir> Map<'hir> {\n         // see the comment on `HirEntryMap`.\n         // Iterate over all the indices and return a reference to\n         // local maps and their index given that they exist.\n-        self.map.iter().enumerate().filter_map(|(i, local_map)| {\n-            local_map.as_ref().map(|m| (i, m))\n-        }).flat_map(move |(array_index, local_map)| {\n+        self.map.iter_enumerated().flat_map(move |(owner, local_map)| {\n             // Iterate over each valid entry in the local map.\n             local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n                 // Reconstruct the `HirId` based on the 3 indices we used to find it.\n                 HirId {\n-                    owner: DefIndex::from(array_index),\n+                    owner,\n                     local_id: i,\n                 }\n             }))\n@@ -1196,6 +1220,8 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n+    let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n+\n     // Build the reverse mapping of `node_to_hir_id`.\n     let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n         .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();"}, {"sha": "0edc41e6b4881390b8134d6244c73fc01ebbeea9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 92, "deletions": 21, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -19,7 +19,7 @@ use crate::ty::query::Providers;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n-use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n@@ -122,9 +122,9 @@ impl fmt::Display for HirId {\n \n // Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module.\n mod item_local_id_inner {\n-    use rustc_data_structures::indexed_vec::Idx;\n+    use rustc_index::vec::Idx;\n     use rustc_macros::HashStable;\n-    newtype_index! {\n+    rustc_index::newtype_index! {\n         /// An `ItemLocalId` uniquely identifies something within a given \"item-like\";\n         /// that is, within a `hir::Item`, `hir::TraitItem`, or `hir::ImplItem`. There is no\n         /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n@@ -628,9 +628,9 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: InternedString) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam> {\n         for param in &self.params {\n-            if name == param.name.ident().as_interned_str() {\n+            if name == param.name.ident().name {\n                 return Some(param);\n             }\n         }\n@@ -669,6 +669,12 @@ impl WhereClause {\n             Some(self.span)\n         }\n     }\n+\n+    /// The `WhereClause` under normal circumstances points at either the predicates or the empty\n+    /// space where the `where` clause should be. Only of use for diagnostic suggestions.\n+    pub fn span_for_predicates_or_empty_place(&self) -> Span {\n+        self.span\n+    }\n }\n \n /// A single predicate in a where-clause.\n@@ -861,7 +867,7 @@ pub struct Block {\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n     /// break out of this block early.\n-    /// Used by `'label: {}` blocks and by `catch` statements.\n+    /// Used by `'label: {}` blocks and by `try {}` blocks.\n     pub targeted_by_break: bool,\n }\n \n@@ -989,6 +995,15 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n+impl fmt::Display for RangeEnd {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            RangeEnd::Included => \"..=\",\n+            RangeEnd::Excluded => \"..\",\n+        })\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n@@ -1053,9 +1068,16 @@ impl Mutability {\n             MutImmutable => MutImmutable,\n         }\n     }\n+\n+    pub fn invert(self) -> Self {\n+        match self {\n+            MutMutable => MutImmutable,\n+            MutImmutable => MutMutable,\n+        }\n+    }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1189,7 +1211,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1359,24 +1381,54 @@ impl Body {\n             hir_id: self.value.hir_id,\n         }\n     }\n+\n+    pub fn generator_kind(&self) -> Option<GeneratorKind> {\n+        self.generator_kind\n+    }\n }\n \n /// The type of source expression that caused this generator to be created.\n-// Not `IsAsync` because we want to eventually add support for `AsyncGen`\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum GeneratorKind {\n-    /// An `async` block or function.\n-    Async,\n+    /// An explicit `async` block or the body of an async function.\n+    Async(AsyncGeneratorKind),\n+\n     /// A generator literal created via a `yield` inside a closure.\n     Gen,\n }\n \n impl fmt::Display for GeneratorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            GeneratorKind::Async(k) => fmt::Display::fmt(k, f),\n+            GeneratorKind::Gen => f.write_str(\"generator\"),\n+        }\n+    }\n+}\n+\n+/// In the case of a generator created as part of an async construct,\n+/// which kind of async construct caused it to be created?\n+///\n+/// This helps error messages but is also used to drive coercions in\n+/// type-checking (see #60424).\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub enum AsyncGeneratorKind {\n+    /// An explicit `async` block written by the user.\n+    Block,\n+\n+    /// An explicit `async` block written by the user.\n+    Closure,\n+\n+    /// The `async` block generated as the body of an async function.\n+    Fn,\n+}\n+\n+impl fmt::Display for AsyncGeneratorKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match self {\n-            GeneratorKind::Async => \"`async` object\",\n-            GeneratorKind::Gen => \"generator\",\n+            AsyncGeneratorKind::Block => \"`async` block\",\n+            AsyncGeneratorKind::Closure => \"`async` closure body\",\n+            AsyncGeneratorKind::Fn => \"`async fn` body\",\n         })\n     }\n }\n@@ -1520,6 +1572,19 @@ impl Expr {\n             }\n         }\n     }\n+\n+    /// If `Self.kind` is `ExprKind::DropTemps(expr)`, drill down until we get a non-`DropTemps`\n+    /// `Expr`. This is used in suggestions to ignore this `ExprKind` as it is semantically\n+    /// silent, only signaling the ownership system. By doing this, suggestions that check the\n+    /// `ExprKind` of any given `Expr` for presentation don't have to care about `DropTemps`\n+    /// beyond remembering to call this function before doing analysis on it.\n+    pub fn peel_drop_temps(&self) -> &Self {\n+        let mut expr = self;\n+        while let ExprKind::DropTemps(inner) = &expr.kind {\n+            expr = inner;\n+        }\n+        expr\n+    }\n }\n \n impl fmt::Debug for Expr {\n@@ -1758,6 +1823,7 @@ pub struct Destination {\n pub enum GeneratorMovability {\n     /// May contain self-references, `!Unpin`.\n     Static,\n+\n     /// Must not contain self-references, `Unpin`.\n     Movable,\n }\n@@ -2016,9 +2082,6 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n-    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaListImpl` created\n-    /// from the variadic arguments. This type is only valid up to typeck.\n-    CVarArgs(Lifetime),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2449,7 +2512,7 @@ pub enum ItemKind {\n     Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n     /// A module.\n     Mod(Mod),\n-    /// An external module.\n+    /// An external module, e.g. `extern { .. }`.\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(P<GlobalAsm>),\n@@ -2643,6 +2706,11 @@ pub struct CodegenFnAttrs {\n     /// probably isn't set when this is set, this is for foreign items while\n     /// `#[export_name]` is for Rust-defined functions.\n     pub link_name: Option<Symbol>,\n+    /// The `#[link_ordinal = \"...\"]` attribute, indicating an ordinal an\n+    /// imported function has in the dynamic library. Note that this must not\n+    /// be set when `link_name` is set. This is for foreign items with the\n+    /// \"raw-dylib\" kind.\n+    pub link_ordinal: Option<usize>,\n     /// The `#[target_feature(enable = \"...\")]` attribute and the enabled\n     /// features (only enabled features are supported right now).\n     pub target_features: Vec<Symbol>,\n@@ -2688,9 +2756,11 @@ bitflags! {\n         /// `#[used]`: indicates that LLVM can't eliminate this function (but the\n         /// linker can!).\n         const USED                      = 1 << 9;\n-        /// #[ffi_returns_twice], indicates that an extern function can return\n+        /// `#[ffi_returns_twice]`, indicates that an extern function can return\n         /// multiple times\n-        const FFI_RETURNS_TWICE = 1 << 10;\n+        const FFI_RETURNS_TWICE         = 1 << 10;\n+        /// `#[track_caller]`: allow access to the caller location\n+        const TRACK_CALLER              = 1 << 11;\n     }\n }\n \n@@ -2702,6 +2772,7 @@ impl CodegenFnAttrs {\n             optimize: OptimizeAttr::None,\n             export_name: None,\n             link_name: None,\n+            link_ordinal: None,\n             target_features: vec![],\n             linkage: None,\n             link_section: None,"}, {"sha": "64b355f6ec9d1b6693526181b691324037daa932", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -1,10 +1,10 @@\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::{SourceMap, Spanned};\n-use syntax::parse::ParseSess;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self, Comments, PrintState};\n+use syntax::sess::ParseSess;\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n@@ -361,9 +361,6 @@ impl<'a> State<'a> {\n                 self.s.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n-            hir::TyKind::CVarArgs(_) => {\n-                self.s.word(\"...\");\n-            }\n         }\n         self.end()\n     }\n@@ -1526,9 +1523,17 @@ impl<'a> State<'a> {\n                                         colons_before_params)\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n-                self.s.word(\"<\");\n-                self.print_type(qself);\n-                self.s.word(\">\");\n+                // If we've got a compound-qualified-path, let's push an additional pair of angle\n+                // brackets, so that we pretty-print `<<A::B>::C>` as `<A::B>::C`, instead of just\n+                // `A::B::C` (since the latter could be ambiguous to the user)\n+                if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = &qself.kind {\n+                    self.print_type(qself);\n+                } else {\n+                    self.s.word(\"<\");\n+                    self.print_type(qself);\n+                    self.s.word(\">\");\n+                }\n+\n                 self.s.word(\"::\");\n                 self.print_ident(item_segment.ident);\n                 self.print_generic_args(item_segment.generic_args(),"}, {"sha": "7ee461a859bd6b4e78f93589f406370110e29602", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -9,10 +9,9 @@ use std::{slice, vec};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n-                                           HashStable};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq)]\n+#[derive(PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }\n@@ -133,9 +132,7 @@ impl<T: Decodable> Decodable for P<[T]> {\n impl<CTX, T> HashStable<CTX> for P<T>\n     where T: ?Sized + HashStable<CTX>\n {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut CTX,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         (**self).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "957dab39414f04e4790e6edbd5cde05e424deb3e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d", "patch": "@@ -13,14 +13,13 @@ use std::cell::RefCell;\n \n use syntax::ast;\n use syntax::source_map::SourceMap;\n-use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene;\n+use syntax_pos::hygiene::{self, SyntaxContext};\n \n use rustc_data_structures::stable_hasher::{\n-    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+    HashStable, StableHasher, ToStableHashKey,\n };\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n@@ -219,9 +218,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n@@ -230,9 +227,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -263,9 +258,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n@@ -298,9 +291,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n     /// codepoint offsets. For the purpose of the hash that's sufficient.\n     /// Also, hashing filenames is expensive so we avoid doing it twice when the\n     /// span starts and ends in the same file, which is almost always the case.\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n         const TAG_EXPANSION: u8 = 0;\n@@ -379,24 +370,18 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for DelimSpan {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>,\n-    ) {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.open.hash_stable(hcx, hasher);\n         self.close.hash_stable(hcx, hasher);\n     }\n }\n \n-pub fn hash_stable_trait_impls<'a, W>(\n+pub fn hash_stable_trait_impls<'a>(\n     hcx: &mut StableHashingContext<'a>,\n-    hasher: &mut StableHasher<W>,\n+    hasher: &mut StableHasher,\n     blanket_impls: &[DefId],\n     non_blanket_impls: &FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n-) where\n-    W: StableHasherResult,\n-{\n+) {\n     {\n         let mut blanket_impls: SmallVec<[_; 8]> = blanket_impls\n             .iter()"}, {"sha": "c0255e5b8a48165b585d8c381322ac288bf2cbd6", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4fd4e25f641108cbaac4b06ec3b679b4f8877998", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "c643baf11254c8178a9edee5d39e41edbc755576", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 15, "deletions": 52, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "49a2c90bdbf603e37bf28edbafbb3c68781892f0", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d833feeeb09d615f6187e69300cd2cd4cab17780", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "7ad6006012f49cafecf02430b776414e90ee9f0a", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "51ae4e49493f7c17565b5224cc218f7f7086f487", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "a50cc86862e57903983608ab6aa4cb5db1958244", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "b89731273f7e22465ef00dc17e361a563d3970b8", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f4751e591bf3ce65984531014a7df239a0a133eb", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "cd003aa8dab708cc570b9e6800de28146af9f3f4", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "0194300c507214356bbf9203e3f15176d29796a4", "filename": "src/librustc/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "1841bd9ea6423e9a4e3d8c390fa348389275b186", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "c26b5625a90b636082a3c31001c0460cd040cd11", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 4, "deletions": 265, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f30f19d41509dae6fc66849778fd9e27185437b5", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e385d576b8ceb025049ab85a86e1057d3bc28777", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d6f76e9ee346c6f669308872cfae6a54f59e13f2", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "bd19a002fe8b7bf676e185b527bd5a034eaa574c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "3d069425685c7761dd67a7f10e127297e238e54b", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "8c6a7c9a376a79900eabcada996a0681fce73777", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "7c3a338366c9af3f3edf3ab291006e33411875b3", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f79a30c7ae8f3cdbbf04631b209c3818cfe2ebac", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "b0b6d971c6087e572ece48f73b846fb4121c80b8", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "996f5b1241263e7397e29ee93cc2c95c0e5a9aac", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5c871bb6b698899bf904e31a7a15aa130bea2b3a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 158, "deletions": 31, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "1cb53d754dcd3891357e0b48e63dadc7ba3336f0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 85, "deletions": 155, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4c60492e470c2ebd12694a9da05e69db30155719", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4da146b1e5d57dedd77167ee25ab2fe7fba9eb7b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 67, "deletions": 40, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "256a08d7e90c34dcaef83589afa345ba8fa9b036", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "1f4086227327e2af7111e594112e3b17a363b43b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4d14299751c3d177ade6f19f3381fb8092806c04", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "bb7ac5d8dbe1a75c79af0ac5e89fabb49dd5d390", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 79, "deletions": 394, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "72fb1fd3561f01b6f92d446ad505fb03902ad087", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "cbf336fdbe2f3cd69627c81f94a8f689644e2a6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 63, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "9ff205228a566375bdeb17d20b5610bc69c04d5b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "a122d84a5aa7ec84481f8a675d758075cb36723c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e65f17c79497e169c6375153ba836883c1183ce7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "9b4136674187660019feec9c1a7af61459f5fcc6", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "aa8ac4902a8947bc758d8404fe771a490ef73480", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d918b9ee67347e8ef4be0409e75c1c35a78da0e4", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "6c31d54e081c42b9ee62c787ff815eb7e58f02c8", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "ac16b8b884c450f9b51b8729e2c051087d056b84", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f7e0d0131dea29cd45cd5dc13c6300702bc45836", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 74, "deletions": 88, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "58f99667cb3a417d6dd7606d787600b83c371a81", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e87aabf9a0566498cbe1cd615819a20a58c1a2b6", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f129dd3abeff7b1d6431fb82818b1a3aca0408ed", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "6a41b843e5794dd2ee0b2eadd57b75cfb8112379", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 144, "deletions": 83, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "86ed2419e048b0a5934a95c43b55d97388f0e795", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "33b9ddaa622303f2c553810f0f686e29699a28ca", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 326, "deletions": 263, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "81f0853201c08b5f5afba7b9b6f5ad9e9115a4f6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "949dad751a101f69c3d1a8c9cddedc14df31f507", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "49a4d17d88d03d926ed87bead20a3fbd2d87d134", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 85, "deletions": 24, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "1f7bce1c644c51ab5c0cfed709ed6aff3eda5480", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 576, "deletions": 71, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "b8275299562ce59164c1ef99e5714e90a28a2202", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "8ded1417ee570985e8d32d1cb62c9e70a735dd45", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "b39c00a56e349ad13c5933b9f6e55c9f69d1b176", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d88bbe145d1fd7be647528ec025f91e8e2a78c60", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e84c91daf293f39fbbea8dfc04592a1384406264", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "0d426cab9b751381f3106051b92e97ca269acdc2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f6ea77dc5cc684562944f209750988f6cbcd7135", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "eee084b78963cf1cfb27b8425b063ca846001493", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "7aa98703411b28e2881a5b962d448160e393055c", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "86a32d68fc09eca78d414b9f393028e39db53cae", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d8a27f1e04051726e1c3c86f5936f9bf8b74ab61", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "c1c6eb850f591158a4a53fd63a053f7fc73b3261", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "c64d6748ea97d563e47b7de484320192875c4415", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "109e884f8bd164f6d372f8edbeff7aa4a76cb30c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d8b1effe09bf41de6cff5796c3e2856f2365991d", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5570144489cdf315bfb783698df01ab386adab05", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d5e7ac19263a0c13f2080b3d3a93f7619f790eb1", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "676916f530a4d9cbe0ae7c450cd442059ed569ea", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "3d28beefb3413f0dea2b38ed691f6ac822ca92d5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 209, "deletions": 102, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "77613b548cfdb438b55b6f9796dd71abc4d82934", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "27a09b394b8fa32b8923140e5ff6f2219fad90fc", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "d4b7f37b120e76e722cc4f119b8565ede87f17ad", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "bacf3d42f043130fd47b040df8f40720ba5710a9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5139c8085a583d7021a0b13fede6e04cdc590e34", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e82232ac10f7bbc1f15f6eb9b1687629666b9606", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 33, "deletions": 85, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "60028f2488a337dfe4048f76854e77eff7ed8481", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "80e77cdfad0b6ec97f5eaa990f2e3e88bb97eaf1", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e72916de6a9c7a0311c6d3065084b79d27dfba36", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "8a98a5d83615fbf4e2d8985afd7f0ffbf6adc4c7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 138, "deletions": 135, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "c1c6a655d96a9132fe1e366f24b356a2582e1681", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "391ea762a083b003f3b71442b9694e2599aeb75b", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "a9e0a5d6ab564b4a1f8247e4e96cf0b26ef6f9b0", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "9b15ad560b5d25f751eea19788be91b410aafbae", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "21a7cf00b283f54c43d5783e440697a090527d0f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "538154b035ac6567e1e2cf01574a161537445579", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 43, "deletions": 112, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f0d1639f72f59cf3cafbb826c9419703e41dcd8a", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "1da65f4b51d36d083e7697d5cc6c135c61e3ba7c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5d78d563e9a4b0aa53fb473489d6948b7817477c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "cdf5734f5a50673e4d0bf5eab1674c7932ebb535", "filename": "src/librustc/ty/structural_match.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_match.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "3a9994ac64c77e9d2c0bdcb16e11cf01a08c5824", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "29721979099d59e0c7635b92f5a8d3a936e6cf19", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "49ec908231548de6f6b6e123a7814323f6b52304", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5555dace45bfa63e750d01875875fc367ad86f2d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "f5b1902e3cc8c5ab0085125d7c51f4c61351db96", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4ea01bf96476a8cde90efd60641ebbe3f04dc3fe", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 169, "deletions": 30, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "3e52a6aa50850c12901e0f9b8c5cac6e418a5374", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5a1b7f3aa4cb851343bee4e033c4d0d6edf91ea1", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 162, "deletions": 94, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4fc15f99e484e3d282f48d7285e0f3e7d92f6688", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "4abb86a5251a5e997e915f1d904a0dbeaa9b72d4", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "5efe4fda8ccf85f47f5764b5be18d9413d144769", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "867bbd22cfbbb1246fa71b32c133979b7f3d69d2", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "ae5cfc4d97b599705da9180c0974d090d26ffbd1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "11b6e0befa1b10fb28c35c3f1297a1d419ded267", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "6a36a4a50cbf3f2210b81c9dbfd244d8778a5dcb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "e169cfc4cc829c08f234f766c48502bea3c53aa0", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "b3be3d09f17da9c06748786d74244af39edfcffb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 69, "deletions": 52, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "52f3a1cbb5c30b06959ddd66d120f79557fe2b4a", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "edd34b52eade7703687020c9a5f97ad7e693dd71", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "312c41b88b0924601c3620b121e5ebf648ed7a65", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}, {"sha": "08fa23f2a7c9e31b09b539309692a655f9384926", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31fc42b7f778accb21db8daaf0f0e725948c9d6d/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=31fc42b7f778accb21db8daaf0f0e725948c9d6d"}]}