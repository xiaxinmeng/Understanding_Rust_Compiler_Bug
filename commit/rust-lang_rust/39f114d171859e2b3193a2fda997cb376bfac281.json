{"sha": "39f114d171859e2b3193a2fda997cb376bfac281", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjExNGQxNzE4NTllMmIzMTkzYTJmZGE5OTdjYjM3NmJmYWMyODE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T23:36:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T00:27:56Z"}, "message": "De-export iter and result. Part of #3583.", "tree": {"sha": "32fc15b7943620a97be8b0c1caa7c1689b6151bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32fc15b7943620a97be8b0c1caa7c1689b6151bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f114d171859e2b3193a2fda997cb376bfac281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f114d171859e2b3193a2fda997cb376bfac281", "html_url": "https://github.com/rust-lang/rust/commit/39f114d171859e2b3193a2fda997cb376bfac281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f114d171859e2b3193a2fda997cb376bfac281/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24fbf88230f37d63bb236569d6a9600ad9560f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/24fbf88230f37d63bb236569d6a9600ad9560f6f", "html_url": "https://github.com/rust-lang/rust/commit/24fbf88230f37d63bb236569d6a9600ad9560f6f"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "3606245d449c74a609f43be4535578c8881e4720", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=39f114d171859e2b3193a2fda997cb376bfac281", "patch": "@@ -185,7 +185,6 @@ mod cmp;\n mod num;\n mod hash;\n mod either;\n-#[legacy_exports]\n mod iter;\n mod logging;\n mod option;\n@@ -194,7 +193,6 @@ mod option_iter {\n     #[path = \"option.rs\"]\n     mod inst;\n }\n-#[legacy_exports]\n mod result;\n mod to_str;\n mod to_bytes;"}, {"sha": "5271555d299f94ae8a742479f1abbbbbf06a1acd", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=39f114d171859e2b3193a2fda997cb376bfac281", "patch": "@@ -7,48 +7,49 @@ The iteration traits and common implementation\n use cmp::{Eq, Ord};\n \n /// A function used to initialize the elements of a sequence\n-type InitOp<T> = &fn(uint) -> T;\n+pub type InitOp<T> = &fn(uint) -> T;\n \n-trait BaseIter<A> {\n+pub trait BaseIter<A> {\n     pure fn each(blk: fn(v: &A) -> bool);\n     pure fn size_hint() -> Option<uint>;\n }\n \n-trait ExtendedIter<A> {\n+pub trait ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, v: &A) -> bool);\n     pure fn all(blk: fn(&A) -> bool) -> bool;\n     pure fn any(blk: fn(&A) -> bool) -> bool;\n     pure fn foldl<B>(+b0: B, blk: fn(&B, &A) -> B) -> B;\n     pure fn position(f: fn(&A) -> bool) -> Option<uint>;\n }\n \n-trait EqIter<A:Eq> {\n+pub trait EqIter<A:Eq> {\n     pure fn contains(x: &A) -> bool;\n     pure fn count(x: &A) -> uint;\n }\n \n-trait Times {\n+pub trait Times {\n     pure fn times(it: fn() -> bool);\n }\n-trait TimesIx{\n+\n+pub trait TimesIx{\n     pure fn timesi(it: fn(uint) -> bool);\n }\n \n-trait CopyableIter<A:Copy> {\n+pub trait CopyableIter<A:Copy> {\n     pure fn filter_to_vec(pred: fn(+a: A) -> bool) -> ~[A];\n     pure fn map_to_vec<B>(op: fn(+v: A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n     pure fn find(p: fn(+a: A) -> bool) -> Option<A>;\n }\n \n-trait CopyableOrderedIter<A:Copy Ord> {\n+pub trait CopyableOrderedIter<A:Copy Ord> {\n     pure fn min() -> A;\n     pure fn max() -> A;\n }\n \n // A trait for sequences that can be by imperatively pushing elements\n // onto them.\n-trait Buildable<A> {\n+pub trait Buildable<A> {\n     /**\n      * Builds a buildable sequence by calling a provided function with\n      * an argument function that pushes an element onto the back of\n@@ -66,38 +67,42 @@ trait Buildable<A> {\n                                 builder: fn(push: pure fn(+v: A))) -> self;\n }\n \n-pure fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: fn(uint, v: &A) -> bool) {\n+pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n+                                    blk: fn(uint, v: &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n         i += 1;\n     }\n }\n \n-pure fn all<A,IA:BaseIter<A>>(self: &IA, blk: fn(&A) -> bool) -> bool {\n+pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n+                                  blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n-pure fn any<A,IA:BaseIter<A>>(self: &IA, blk: fn(&A) -> bool) -> bool {\n+pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n+                                  blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n-pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                         prd: fn(+a: A) -> bool) -> ~[A] {\n+pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n+    self: &IA, prd: fn(+a: A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(*a) { push(*a); }\n         }\n     }\n }\n \n-pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA, op: fn(+v: A) -> B)\n+pub pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA,\n+                                                op: fn(+v: A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -106,7 +111,7 @@ pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA, op: fn(+v: A) -> B)\n     }\n }\n \n-pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n+pub pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     self: &IA, op: fn(+a: A) -> IB) -> ~[B] {\n \n     do vec::build |push| {\n@@ -118,7 +123,8 @@ pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     }\n }\n \n-pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, +b0: B, blk: fn(&B, &A) -> B)\n+pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, +b0: B,\n+                                      blk: fn(&B, &A) -> B)\n     -> B {\n     let mut b <- b0;\n     for self.each |a| {\n@@ -127,18 +133,18 @@ pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, +b0: B, blk: fn(&B, &A) -> B)\n     move b\n }\n \n-pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n+pub pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy (*r), ~[*a]))\n }\n \n-pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n+pub pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n     for self.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n-pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n+pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     do foldl(self, 0) |count, value| {\n         if *value == *x {\n             *count + 1\n@@ -148,7 +154,7 @@ pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     }\n }\n \n-pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n+pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n     -> Option<uint>\n {\n     let mut i = 0;\n@@ -163,15 +169,15 @@ pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n // iter interface, such as would provide \"reach\" in addition to \"each\". as is,\n // it would have to be implemented with foldr, which is too inefficient.\n \n-pure fn repeat(times: uint, blk: fn() -> bool) {\n+pub pure fn repeat(times: uint, blk: fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n         i += 1;\n     }\n }\n \n-pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n@@ -185,7 +191,7 @@ pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     }\n }\n \n-pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n@@ -199,7 +205,7 @@ pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     }\n }\n \n-pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n+pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n                                      p: fn(+a: A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if p(*i) { return Some(*i) }\n@@ -220,7 +226,8 @@ pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n+pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A)))\n+    -> B {\n     build_sized(4, builder)\n }\n \n@@ -238,7 +245,7 @@ pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A,B: Buildable<A>>(\n+pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n     builder: fn(push: pure fn(+v: A))) -> B {\n \n@@ -248,7 +255,8 @@ pure fn build_sized_opt<A,B: Buildable<A>>(\n // Functions that combine iteration and building\n \n /// Apply a function to each element of an iterable and return the results\n-fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U) -> BU {\n+pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n+    -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each() |elem| {\n             push(f(elem));\n@@ -262,7 +270,8 @@ fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U) -> BU {\n  * Creates a generic sequence of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n+pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n+                                        op: InitOp<T>) -> BT {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -275,7 +284,8 @@ pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint, +t: T) -> BT {\n+pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n+                                                +t: T) -> BT {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n         while i < n_elts { push(t); i += 1; }\n@@ -284,7 +294,7 @@ pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint, +t: T) -> BT {\n \n /// Appending two generic sequences\n #[inline(always)]\n-pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pub pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     lhs: &IT, rhs: &IT) -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n@@ -297,7 +307,7 @@ pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pub pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(*x); }"}, {"sha": "e454c068d47b5b1e3d545880bd60cacb3adacfda", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f114d171859e2b3193a2fda997cb376bfac281/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=39f114d171859e2b3193a2fda997cb376bfac281", "patch": "@@ -8,7 +8,7 @@ use cmp::Eq;\n use either::Either;\n \n /// The result type\n-enum Result<T, U> {\n+pub enum Result<T, U> {\n     /// Contains the successful result value\n     Ok(T),\n     /// Contains the error value\n@@ -22,7 +22,7 @@ enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n-pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n+pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n       Err(ref the_err) => unsafe {\n@@ -38,7 +38,7 @@ pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n-pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n+pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n@@ -54,23 +54,23 @@ pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n  *\n  * If the result is not an error\n  */\n-pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n+pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(copy u) => u,\n       Ok(_) => fail ~\"get_err called on ok result\"\n     }\n }\n \n /// Returns true if the result is `ok`\n-pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n+pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n       Err(_) => false\n     }\n }\n \n /// Returns true if the result is `err`\n-pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n+pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n@@ -80,7 +80,8 @@ pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>) -> Either<T, U> {\n+pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n+    -> Either<T, U> {\n     match *res {\n       Ok(copy res) => either::Right(res),\n       Err(copy fail_) => either::Left(fail_)\n@@ -101,7 +102,7 @@ pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>) -> Either<T, U> {\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-fn chain<T, U: Copy, V: Copy>(+res: Result<T, V>, op: fn(+t: T)\n+pub fn chain<T, U: Copy, V: Copy>(+res: Result<T, V>, op: fn(+t: T)\n     -> Result<U, V>) -> Result<U, V> {\n     // XXX: Should be writable with move + match\n     if res.is_ok() {\n@@ -119,7 +120,7 @@ fn chain<T, U: Copy, V: Copy>(+res: Result<T, V>, op: fn(+t: T)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn chain_err<T: Copy, U: Copy, V: Copy>(\n+pub fn chain_err<T: Copy, U: Copy, V: Copy>(\n     +res: Result<T, V>,\n     op: fn(+t: V) -> Result<T, U>)\n     -> Result<T, U> {\n@@ -143,7 +144,7 @@ fn chain_err<T: Copy, U: Copy, V: Copy>(\n  *         print_buf(buf)\n  *     }\n  */\n-fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n+pub fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -158,7 +159,7 @@ fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n+pub fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -179,7 +180,7 @@ fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n+pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -195,7 +196,7 @@ fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn((&E)) -> F)\n+pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn((&E)) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -274,7 +275,7 @@ impl<T: Copy, E: Copy> Result<T, E> {\n  *         assert incd == ~[2u, 3u, 4u];\n  *     }\n  */\n-fn map_vec<T,U:Copy,V:Copy>(\n+pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n@@ -287,7 +288,7 @@ fn map_vec<T,U:Copy,V:Copy>(\n     return Ok(move vs);\n }\n \n-fn map_opt<T,U:Copy,V:Copy>(\n+pub fn map_opt<T,U:Copy,V:Copy>(\n     o_t: &Option<T>, op: fn((&T)) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match *o_t {\n@@ -308,7 +309,7 @@ fn map_opt<T,U:Copy,V:Copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n+pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: fn((&S),(&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n@@ -330,7 +331,7 @@ fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map2()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n+pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: fn((&S),(&T)) -> Result<(),U>) -> Result<(),U> {\n \n     assert vec::same_length(ss, ts);\n@@ -347,15 +348,15 @@ fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-fn unwrap<T, U>(+res: Result<T, U>) -> T {\n+pub fn unwrap<T, U>(+res: Result<T, U>) -> T {\n     match move res {\n       Ok(move t) => move t,\n       Err(_) => fail ~\"unwrap called on an err result\"\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n+pub fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n     match move res {\n       Err(move u) => move u,\n       Ok(_) => fail ~\"unwrap called on an ok result\""}]}