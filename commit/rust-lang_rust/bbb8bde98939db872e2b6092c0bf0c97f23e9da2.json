{"sha": "bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "node_id": "C_kwDOAAsO6NoAKGJiYjhiZGU5ODkzOWRiODcyZTJiNjA5MmMwYmYwYzk3ZjIzZTlkYTI", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-28T04:18:17Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-28T17:58:31Z"}, "message": "Slight cleanup", "tree": {"sha": "60a9a908b0a7679c2d593fe9a83561d15c6a65aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60a9a908b0a7679c2d593fe9a83561d15c6a65aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "html_url": "https://github.com/rust-lang/rust/commit/bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "555119fa146640c24104e79ec32beeec9d5f738a", "url": "https://api.github.com/repos/rust-lang/rust/commits/555119fa146640c24104e79ec32beeec9d5f738a", "html_url": "https://github.com/rust-lang/rust/commit/555119fa146640c24104e79ec32beeec9d5f738a"}], "stats": {"total": 78, "additions": 43, "deletions": 35}, "files": [{"sha": "eea8f40635d74a416ee51b9f6159c164b4222737", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "patch": "@@ -496,7 +496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::DontTupleArguments,\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             call_expr.span,\n             call_expr,\n             fn_sig.inputs(),\n-            &expected_arg_tys,\n+            expected_arg_tys,\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::TupleArguments,"}, {"sha": "e796fe58170d2e2bddaa87b7fdd111b248455c34", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 sp,\n                 expr,\n                 &err_inputs,\n-                &[],\n+                vec![],\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sp,\n             expr,\n             &method.sig.inputs()[1..],\n-            &expected_input_tys[..],\n+            expected_input_tys,\n             args_no_rcvr,\n             method.sig.c_variadic,\n             tuple_arguments,\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Types (as defined in the *signature* of the target function)\n         formal_input_tys: &[Ty<'tcx>],\n         // More specific expected types, after unifying with caller output types\n-        expected_input_tys: &[Ty<'tcx>],\n+        expected_input_tys: Vec<Ty<'tcx>>,\n         // The expressions for each provided argument\n         provided_args: &'tcx [hir::Expr<'tcx>],\n         // Whether the function is variadic, for example when imported from C\n@@ -249,25 +249,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n         };\n \n-        let mut expected_input_tys = expected_input_tys.to_vec();\n-\n-        let formal_input_tys = if tuple_arguments == TupleArguments {\n+        let (formal_input_tys, expected_input_tys) = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n                 ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n                     param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n-                    expected_input_tys = vec![];\n-                    self.err_args(provided_args.len())\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n                 ty::Tuple(arg_types) => {\n-                    expected_input_tys = match expected_input_tys.get(0) {\n+                    let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n                         },\n                         None => vec![],\n                     };\n-                    arg_types.iter().map(|k| k.expect_ty()).collect()\n+                    (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n                 }\n                 _ => {\n                     struct_span_err!(\n@@ -278,19 +275,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                          for the function trait is neither a tuple nor unit\"\n                     )\n                     .emit();\n-                    expected_input_tys = vec![];\n-                    self.err_args(provided_args.len())\n+                    (self.err_args(provided_args.len()), vec![])\n                 }\n             }\n         } else if expected_arg_count == supplied_arg_count {\n-            formal_input_tys.to_vec()\n+            (formal_input_tys.to_vec(), expected_input_tys)\n         } else if c_variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                formal_input_tys.to_vec()\n+                (formal_input_tys.to_vec(), expected_input_tys)\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_input_tys = vec![];\n-                self.err_args(supplied_arg_count)\n+                (self.err_args(supplied_arg_count), vec![])\n             }\n         } else {\n             // is the missing argument of type `()`?\n@@ -303,8 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n \n-            expected_input_tys = vec![];\n-            self.err_args(supplied_arg_count)\n+            (self.err_args(supplied_arg_count), vec![])\n         };\n \n         debug!(\n@@ -319,6 +313,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             formal_input_tys.clone()\n         };\n \n+        assert_eq!(expected_input_tys.len(), formal_input_tys.len());\n+\n+        // Keep track of the fully coerced argument types\n         let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n         // We introduce a helper function to demand that a given argument satisfy a given input\n@@ -376,8 +373,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for check_closures in [false, true] {\n-            debug!(\"check_closures={}\", check_closures);\n-\n             // More awful hacks: before we check argument types, try to do\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n@@ -394,31 +389,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 })\n             }\n \n-            // For C-variadic functions, we don't have a declared type for all of\n-            // the arguments hence we only do our usual type checking with\n-            // the arguments who's types we do know.\n-            let t = if c_variadic {\n-                expected_arg_count\n-            } else if tuple_arguments == TupleArguments {\n-                provided_args.len()\n-            } else {\n-                supplied_arg_count\n-            };\n-            for (i, arg) in provided_args.iter().take(t).enumerate() {\n+            let minimum_input_count = formal_input_tys.len();\n+            for (idx, arg) in provided_args.iter().enumerate() {\n                 // Warn only for the first loop (the \"no closures\" one).\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n                     self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n-                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n+                // For C-variadic functions, we don't have a declared type for all of\n+                // the arguments hence we only do our usual type checking with\n+                // the arguments who's types we do know. However, we *can* check\n+                // for unreachable expressions (see above).\n+                // FIXME: unreachable warning current isn't emitted\n+                if idx >= minimum_input_count {\n+                    continue;\n+                }\n \n+                let is_closure = matches!(arg.kind, ExprKind::Closure(..));\n                 if is_closure != check_closures {\n                     continue;\n                 }\n \n-                demand_compatible(i, &mut final_arg_types);\n+                demand_compatible(idx, &mut final_arg_types);\n             }\n         }\n "}, {"sha": "f60f6f3e808725d447f21d0c551d3cda1f1376c3", "filename": "src/test/ui/c-variadic/variadic-unreachable-arg-error.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb8bde98939db872e2b6092c0bf0c97f23e9da2/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-unreachable-arg-error.rs?ref=bbb8bde98939db872e2b6092c0bf0c97f23e9da2", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(c_variadic)]\n+\n+extern \"C\" {\n+    fn foo(f: isize, x: u8, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        // FIXME: Ideally we could give an unreachable warning\n+        foo(1, loop {}, 1usize);\n+    }\n+}"}]}