{"sha": "99407584161510e5ab3c6453700537bf6123e158", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDA3NTg0MTYxNTEwZTVhYjNjNjQ1MzcwMDUzN2JmNjEyM2UxNTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-08-26T14:18:03Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-09-02T11:14:38Z"}, "message": "expand: Treat more macro calls as statement macro calls", "tree": {"sha": "031bd5802f68726a120ea7a166841fa8c40ebb04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/031bd5802f68726a120ea7a166841fa8c40ebb04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99407584161510e5ab3c6453700537bf6123e158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99407584161510e5ab3c6453700537bf6123e158", "html_url": "https://github.com/rust-lang/rust/commit/99407584161510e5ab3c6453700537bf6123e158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99407584161510e5ab3c6453700537bf6123e158/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7", "html_url": "https://github.com/rust-lang/rust/commit/b27ccbc7e1e6a04d749e244a3c13f72ca38e80e7"}], "stats": {"total": 163, "additions": 108, "deletions": 55}, "files": [{"sha": "3c6ea56799e08165de29a72cbef49decab334e9b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=99407584161510e5ab3c6453700537bf6123e158", "patch": "@@ -1380,7 +1380,17 @@ pub fn noop_flat_map_stmt<T: MutVisitor>(\n ) -> SmallVec<[Stmt; 1]> {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n-    noop_flat_map_stmt_kind(kind, vis).into_iter().map(|kind| Stmt { id, kind, span }).collect()\n+    let stmts: SmallVec<_> = noop_flat_map_stmt_kind(kind, vis)\n+        .into_iter()\n+        .map(|kind| Stmt { id, kind, span })\n+        .collect();\n+    if stmts.len() > 1 {\n+        panic!(\n+            \"cloning statement `NodeId`s is prohibited by default, \\\n+             the visitor should implement custom statement visiting\"\n+        );\n+    }\n+    stmts\n }\n \n pub fn noop_flat_map_stmt_kind<T: MutVisitor>("}, {"sha": "3ccf9f446a63efa3b556902307568db60fad73e7", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 67, "deletions": 33, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=99407584161510e5ab3c6453700537bf6123e158", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, Block, Inline, ItemKind, Local, MacArgs, MacCall};\n+use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs, MacCall};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n@@ -559,7 +559,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.force_mode = orig_force_mode;\n \n         // Finally incorporate all the expanded macros into the input AST fragment.\n-        let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n+        let mut placeholder_expander = PlaceholderExpander::default();\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n             for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n                 placeholder_expander\n@@ -1061,13 +1061,51 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr\n     }\n \n+    fn take_stmt_bang(\n+        &mut self,\n+        stmt: ast::Stmt,\n+    ) -> Result<(bool, MacCall, Vec<ast::Attribute>), ast::Stmt> {\n+        match stmt.kind {\n+            StmtKind::MacCall(mac) => {\n+                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n+                Ok((style == MacStmtStyle::Semicolon, mac, attrs.into()))\n+            }\n+            StmtKind::Item(ref item) if matches!(item.kind, ItemKind::MacCall(..)) => {\n+                match stmt.kind {\n+                    StmtKind::Item(item) => match item.into_inner() {\n+                        ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n+                            Ok((mac.args.need_semicolon(), mac, attrs))\n+                        }\n+                        _ => unreachable!(),\n+                    },\n+                    _ => unreachable!(),\n+                }\n+            }\n+            StmtKind::Semi(ref expr) if matches!(expr.kind, ast::ExprKind::MacCall(..)) => {\n+                match stmt.kind {\n+                    StmtKind::Semi(expr) => match expr.into_inner() {\n+                        ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n+                            Ok((mac.args.need_semicolon(), mac, attrs.into()))\n+                        }\n+                        _ => unreachable!(),\n+                    },\n+                    _ => unreachable!(),\n+                }\n+            }\n+            StmtKind::Local(..) | StmtKind::Empty | StmtKind::Item(..) | StmtKind::Semi(..) => {\n+                Err(stmt)\n+            }\n+            StmtKind::Expr(..) => unreachable!(),\n+        }\n+    }\n+\n     fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n-    fn check_attributes(&mut self, attrs: &[ast::Attribute], call: &MacCall) {\n+    fn check_attributes(&self, attrs: &[ast::Attribute], call: &MacCall) {\n         let features = self.cx.ecfg.features.unwrap();\n         let mut attrs = attrs.iter().peekable();\n         let mut span: Option<Span> = None;\n@@ -1177,11 +1215,6 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         });\n     }\n \n-    // This is needed in order to set `lint_node_id` for `let` statements\n-    fn visit_local(&mut self, local: &mut P<Local>) {\n-        assign_id!(self, &mut local.id, || noop_visit_local(local, self));\n-    }\n-\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         let mut arm = configure!(self, arm);\n \n@@ -1299,31 +1332,39 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         let mut stmt = configure!(self, stmt);\n \n-        // we'll expand attributes on expressions separately\n-        if !stmt.is_expr() {\n+        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n+        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+        // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n+        // changing that requires some compatibility measures.\n+        let mut stmt = if !stmt.is_expr() {\n             if let Some(attr) = self.take_first_attr(&mut stmt) {\n                 return self\n                     .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n-        }\n \n-        if let StmtKind::MacCall(mac) = stmt.kind {\n-            let MacCallStmt { mac, style, attrs, tokens: _ } = mac.into_inner();\n-            self.check_attributes(&attrs, &mac);\n-            let mut placeholder =\n-                self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts).make_stmts();\n-\n-            // If this is a macro invocation with a semicolon, then apply that\n-            // semicolon to the final statement produced by expansion.\n-            if style == MacStmtStyle::Semicolon {\n-                if let Some(stmt) = placeholder.pop() {\n-                    placeholder.push(stmt.add_trailing_semicolon());\n+            let span = stmt.span;\n+            match self.take_stmt_bang(stmt) {\n+                Ok((add_semicolon, mac, attrs)) => {\n+                    self.check_attributes(&attrs, &mac);\n+                    let mut stmts =\n+                        self.collect_bang(mac, span, AstFragmentKind::Stmts).make_stmts();\n+\n+                    // If this is a macro invocation with a semicolon, then apply that\n+                    // semicolon to the final statement produced by expansion.\n+                    if add_semicolon {\n+                        if let Some(stmt) = stmts.pop() {\n+                            stmts.push(stmt.add_trailing_semicolon());\n+                        }\n+                    }\n+\n+                    return stmts;\n                 }\n+                Err(stmt) => stmt,\n             }\n-\n-            return placeholder;\n-        }\n+        } else {\n+            stmt\n+        };\n \n         // The only way that we can end up with a `MacCall` expression statement,\n         // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n@@ -1338,14 +1379,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             }\n         }\n \n-        // The placeholder expander gives ids to statements, so we avoid folding the id here.\n-        // We don't use `assign_id!` - it will be called when we visit statement's contents\n-        // (e.g. an expression, item, or local)\n-        let ast::Stmt { id, kind, span } = stmt;\n-        let res = noop_flat_map_stmt_kind(kind, self)\n-            .into_iter()\n-            .map(|kind| ast::Stmt { id, kind, span })\n-            .collect();\n+        let res = assign_id!(self, &mut stmt.id, || noop_flat_map_stmt(stmt, self));\n \n         self.cx.current_expansion.is_trailing_mac = false;\n         res"}, {"sha": "c6dc66e99fe940d137ae81b14e213d08e652b5d3", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=99407584161510e5ab3c6453700537bf6123e158", "patch": "@@ -10,6 +10,7 @@\n #![feature(proc_macro_span)]\n #![feature(try_blocks)]\n #![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n+#![recursion_limit = \"256\"]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "8e78fcbb8dbc14a40110def4bda0c03506a63947", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99407584161510e5ab3c6453700537bf6123e158/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=99407584161510e5ab3c6453700537bf6123e158", "patch": "@@ -1,4 +1,3 @@\n-use crate::base::ExtCtxt;\n use crate::expand::{AstFragment, AstFragmentKind};\n \n use rustc_ast as ast;\n@@ -175,17 +174,12 @@ pub fn placeholder(\n     }\n }\n \n-pub struct PlaceholderExpander<'a, 'b> {\n+#[derive(Default)]\n+pub struct PlaceholderExpander {\n     expanded_fragments: FxHashMap<ast::NodeId, AstFragment>,\n-    cx: &'a mut ExtCtxt<'b>,\n-    monotonic: bool,\n }\n \n-impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n-    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n-        PlaceholderExpander { cx, expanded_fragments: FxHashMap::default(), monotonic }\n-    }\n-\n+impl PlaceholderExpander {\n     pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment) {\n         fragment.mut_visit_with(self);\n         self.expanded_fragments.insert(id, fragment);\n@@ -196,7 +190,7 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n+impl MutVisitor for PlaceholderExpander {\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         if arm.is_placeholder {\n             self.remove(arm.id).make_arms()\n@@ -360,15 +354,4 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n             _ => noop_visit_ty(ty, self),\n         }\n     }\n-\n-    fn visit_block(&mut self, block: &mut P<ast::Block>) {\n-        noop_visit_block(block, self);\n-\n-        for stmt in block.stmts.iter_mut() {\n-            if self.monotonic {\n-                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                stmt.id = self.cx.resolver.next_node_id();\n-            }\n-        }\n-    }\n }"}, {"sha": "a40e2c5f9705a0102c1ec16af1feccef39466d75", "filename": "src/test/ui/macros/issue-87877.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99407584161510e5ab3c6453700537bf6123e158/src%2Ftest%2Fui%2Fmacros%2Fissue-87877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99407584161510e5ab3c6453700537bf6123e158/src%2Ftest%2Fui%2Fmacros%2Fissue-87877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-87877.rs?ref=99407584161510e5ab3c6453700537bf6123e158", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+macro_rules! two_items {\n+    () => {\n+        extern \"C\" {}\n+        extern \"C\" {}\n+    };\n+}\n+\n+macro_rules! single_expr_funneler {\n+    ($expr:expr) => {\n+        $expr; // note the semicolon, it changes the statement kind during parsing\n+    };\n+}\n+\n+macro_rules! single_item_funneler {\n+    ($item:item) => {\n+        $item\n+    };\n+}\n+\n+fn main() {\n+    single_expr_funneler! { two_items! {} }\n+    single_item_funneler! { two_items! {} }\n+}"}]}