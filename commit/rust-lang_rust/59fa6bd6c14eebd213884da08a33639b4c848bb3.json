{"sha": "59fa6bd6c14eebd213884da08a33639b4c848bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZmE2YmQ2YzE0ZWViZDIxMzg4NGRhMDhhMzM2MzliNGM4NDhiYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-03T14:28:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-03T14:28:12Z"}, "message": "Auto merge of #52712 - oli-obk:const_eval_cleanups, r=RalfJung\n\nReintroduce `Undef` and properly check constant value sizes\n\nr? @RalfJung\n\ncc @eddyb\n\nbasically all kinds of silent failures that never occurred are assertions now", "tree": {"sha": "a12f6001031c408981f49beef67e350422ac3f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a12f6001031c408981f49beef67e350422ac3f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59fa6bd6c14eebd213884da08a33639b4c848bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59fa6bd6c14eebd213884da08a33639b4c848bb3", "html_url": "https://github.com/rust-lang/rust/commit/59fa6bd6c14eebd213884da08a33639b4c848bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59fa6bd6c14eebd213884da08a33639b4c848bb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88e0ff14a81a2122222e32cf7c285f585c516cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e0ff14a81a2122222e32cf7c285f585c516cfd", "html_url": "https://github.com/rust-lang/rust/commit/88e0ff14a81a2122222e32cf7c285f585c516cfd"}, {"sha": "828aebfe3a2a4beef1dd149f61ce26057d52ce70", "url": "https://api.github.com/repos/rust-lang/rust/commits/828aebfe3a2a4beef1dd149f61ce26057d52ce70", "html_url": "https://github.com/rust-lang/rust/commit/828aebfe3a2a4beef1dd149f61ce26057d52ce70"}], "stats": {"total": 1244, "additions": 627, "deletions": 617}, "files": [{"sha": "f13e26fee3ee460aa80a5c1201ea50dd86094af3", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -392,6 +392,11 @@ for ::mir::interpret::ConstValue<'gcx> {\n     }\n }\n \n+impl_stable_hash_for!(enum mir::interpret::ScalarMaybeUndef {\n+    Scalar(v),\n+    Undef\n+});\n+\n impl_stable_hash_for!(enum mir::interpret::Value {\n     Scalar(v),\n     ScalarPair(a, b),\n@@ -466,9 +471,9 @@ for ::mir::interpret::Scalar {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            Bits { bits, defined } => {\n+            Bits { bits, size } => {\n                 bits.hash_stable(hcx, hasher);\n-                defined.hash_stable(hcx, hasher);\n+                size.hash_stable(hcx, hasher);\n             },\n             Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n         }"}, {"sha": "a0980b06230c8a05b4bdf5428e7962b1934ee81a", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -13,7 +13,7 @@ pub use self::error::{\n     FrameInfo, ConstEvalResult,\n };\n \n-pub use self::value::{Scalar, Value, ConstValue};\n+pub use self::value::{Scalar, Value, ConstValue, ScalarMaybeUndef};\n \n use std::fmt;\n use mir;"}, {"sha": "f569f4def143f8dd6af8c2b71b4cbc27ae4a6219", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 104, "deletions": 86, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -15,41 +15,38 @@ pub enum ConstValue<'tcx> {\n     /// to allow HIR creation to happen for everything before needing to be able to run constant\n     /// evaluation\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs which use Scalar::undef()\n+    /// Used only for types with layout::abi::Scalar ABI and ZSTs\n     Scalar(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n-    ScalarPair(Scalar, Scalar),\n+    ///\n+    /// The second field may be undef in case of `Option<usize>::None`\n+    ScalarPair(Scalar, ScalarMaybeUndef),\n     /// Used only for the remaining cases. An allocation + offset into the allocation\n     ByRef(&'tcx Allocation, Size),\n }\n \n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n-    pub fn from_byval_value(val: Value) -> Self {\n-        match val {\n+    pub fn from_byval_value(val: Value) -> EvalResult<'static, Self> {\n+        Ok(match val {\n             Value::ByRef(..) => bug!(),\n-            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n-            Value::Scalar(val) => ConstValue::Scalar(val),\n-        }\n+            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n+            Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n+        })\n     }\n \n     #[inline]\n     pub fn to_byval_value(&self) -> Option<Value> {\n         match *self {\n             ConstValue::Unevaluated(..) |\n             ConstValue::ByRef(..) => None,\n-            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a, b)),\n-            ConstValue::Scalar(val) => Some(Value::Scalar(val)),\n+            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a.into(), b)),\n+            ConstValue::Scalar(val) => Some(Value::Scalar(val.into())),\n         }\n     }\n \n     #[inline]\n-    pub fn from_scalar(val: Scalar) -> Self {\n-        ConstValue::Scalar(val)\n-    }\n-\n-    #[inline]\n-    pub fn to_scalar(&self) -> Option<Scalar> {\n+    pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n             ConstValue::Unevaluated(..) |\n             ConstValue::ByRef(..) |\n@@ -60,12 +57,12 @@ impl<'tcx> ConstValue<'tcx> {\n \n     #[inline]\n     pub fn to_bits(&self, size: Size) -> Option<u128> {\n-        self.to_scalar()?.to_bits(size).ok()\n+        self.try_to_scalar()?.to_bits(size).ok()\n     }\n \n     #[inline]\n     pub fn to_ptr(&self) -> Option<Pointer> {\n-        self.to_scalar()?.to_ptr().ok()\n+        self.try_to_scalar()?.to_ptr().ok()\n     }\n }\n \n@@ -81,8 +78,8 @@ impl<'tcx> ConstValue<'tcx> {\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n     ByRef(Scalar, Align),\n-    Scalar(Scalar),\n-    ScalarPair(Scalar, Scalar),\n+    Scalar(ScalarMaybeUndef),\n+    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n }\n \n impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n@@ -98,23 +95,27 @@ impl<'tcx> Scalar {\n     pub fn ptr_null<C: HasDataLayout>(cx: C) -> Self {\n         Scalar::Bits {\n             bits: 0,\n-            defined: cx.data_layout().pointer_size.bits() as u8,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n+    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n+        ScalarMaybeUndef::Scalar(self).to_value_with_len(len, cx)\n+    }\n+\n+    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n+        ScalarMaybeUndef::Scalar(self).to_value_with_vtable(vtable)\n+    }\n+\n     pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, defined } => {\n-                let pointer_size = layout.pointer_size.bits() as u8;\n-                if defined < pointer_size {\n-                    err!(ReadUndefBytes)\n-                } else {\n-                    Ok(Scalar::Bits {\n-                        bits: layout.signed_offset(bits as u64, i)? as u128,\n-                        defined: pointer_size,\n-                    })\n-            }\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                Ok(Scalar::Bits {\n+                    bits: layout.signed_offset(bits as u64, i)? as u128,\n+                    size,\n+                })\n             }\n             Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Scalar::Ptr),\n         }\n@@ -123,65 +124,43 @@ impl<'tcx> Scalar {\n     pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, defined } => {\n-                let pointer_size = layout.pointer_size.bits() as u8;\n-                if defined < pointer_size {\n-                    err!(ReadUndefBytes)\n-                } else {\n-                    Ok(Scalar::Bits {\n-                        bits: layout.offset(bits as u64, i.bytes())? as u128,\n-                        defined: pointer_size,\n-                    })\n-            }\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                Ok(Scalar::Bits {\n+                    bits: layout.offset(bits as u64, i.bytes())? as u128,\n+                    size,\n+                })\n             }\n             Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Scalar::Ptr),\n         }\n     }\n \n-    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, defined } => {\n-                let pointer_size = layout.pointer_size.bits() as u8;\n-                if defined < pointer_size {\n-                    err!(ReadUndefBytes)\n-                } else {\n-                    Ok(Scalar::Bits {\n-                        bits: layout.wrapping_signed_offset(bits as u64, i) as u128,\n-                        defined: pointer_size,\n-                    })\n-            }\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, layout.pointer_size.bytes());\n+                Scalar::Bits {\n+                    bits: layout.wrapping_signed_offset(bits as u64, i) as u128,\n+                    size,\n+                }\n             }\n-            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(ptr.wrapping_signed_offset(i, layout))),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, layout)),\n         }\n     }\n \n-    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> EvalResult<'tcx, bool> {\n+    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> bool {\n         match self {\n-            Scalar::Bits {\n-                bits, defined,\n-            } => if defined < cx.data_layout().pointer_size.bits() as u8 {\n-                err!(ReadUndefBytes)\n-            } else {\n-                Ok(bits == 0)\n+            Scalar::Bits { bits, size } =>  {\n+                assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n+                bits == 0\n             },\n-            Scalar::Ptr(_) => Ok(false),\n+            Scalar::Ptr(_) => false,\n         }\n     }\n \n-    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n-        Value::ScalarPair(self, Scalar::Bits {\n-            bits: len as u128,\n-            defined: cx.data_layout().pointer_size.bits() as u8,\n-        })\n-    }\n-\n-    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n-        Value::ScalarPair(self, Scalar::Ptr(vtable))\n-    }\n-\n     pub fn to_value(self) -> Value {\n-        Value::Scalar(self)\n+        Value::Scalar(ScalarMaybeUndef::Scalar(self))\n     }\n }\n \n@@ -199,8 +178,9 @@ impl From<Pointer> for Scalar {\n pub enum Scalar {\n     /// The raw bytes of a simple value.\n     Bits {\n-        /// The first `defined` number of bits are valid\n-        defined: u8,\n+        /// The first `size` bytes are the value.\n+        /// Do not try to read less or more bytes that that\n+        size: u8,\n         bits: u128,\n     },\n \n@@ -210,25 +190,63 @@ pub enum Scalar {\n     Ptr(Pointer),\n }\n \n-impl<'tcx> Scalar {\n-    pub fn undef() -> Self {\n-        Scalar::Bits { bits: 0, defined: 0 }\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+pub enum ScalarMaybeUndef {\n+    Scalar(Scalar),\n+    Undef,\n+}\n+\n+impl From<Scalar> for ScalarMaybeUndef {\n+    fn from(s: Scalar) -> Self {\n+        ScalarMaybeUndef::Scalar(s)\n+    }\n+}\n+\n+impl ScalarMaybeUndef {\n+    pub fn unwrap_or_err(self) -> EvalResult<'static, Scalar> {\n+        match self {\n+            ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n+            ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n+        Value::ScalarPair(self, Scalar::Bits {\n+            bits: len as u128,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n+        }.into())\n     }\n \n+    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n+        Value::ScalarPair(self, Scalar::Ptr(vtable).into())\n+    }\n+\n+    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n+        match self {\n+            ScalarMaybeUndef::Scalar(scalar) => {\n+                scalar.ptr_offset(i, cx).map(ScalarMaybeUndef::Scalar)\n+            },\n+            ScalarMaybeUndef::Undef => Ok(ScalarMaybeUndef::Undef)\n+        }\n+    }\n+}\n+\n+impl<'tcx> Scalar {\n     pub fn from_bool(b: bool) -> Self {\n-        // FIXME: can we make defined `1`?\n-        Scalar::Bits { bits: b as u128, defined: 8 }\n+        Scalar::Bits { bits: b as u128, size: 1 }\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, defined: 32 }\n+        Scalar::Bits { bits: c as u128, size: 4 }\n     }\n \n-    pub fn to_bits(self, size: Size) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            Scalar::Bits { .. } if size.bits() == 0 => bug!(\"to_bits cannot be used with zsts\"),\n-            Scalar::Bits { bits, defined } if size.bits() <= defined as u64 => Ok(bits),\n-            Scalar::Bits { .. } => err!(ReadUndefBytes),\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n+                Ok(bits)\n+            }\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n     }\n@@ -256,8 +274,8 @@ impl<'tcx> Scalar {\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self {\n-            Scalar::Bits { bits: 0, defined: 8 } => Ok(false),\n-            Scalar::Bits { bits: 1, defined: 8 } => Ok(true),\n+            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n+            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }"}, {"sha": "dae5709ba114a3721f86bdb41ee2fcb9ae1594e7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -17,7 +17,7 @@ use hir::def::CtorKind;\n use hir::def_id::DefId;\n use hir::{self, HirId, InlineAsm};\n use middle::region;\n-use mir::interpret::{EvalErrorKind, Scalar, Value};\n+use mir::interpret::{EvalErrorKind, Scalar, Value, ScalarMaybeUndef};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -1465,10 +1465,10 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .map(|&u| {\n                         let mut s = String::new();\n                         print_miri_value(\n-                            Value::Scalar(Scalar::Bits {\n+                            Scalar::Bits {\n                                 bits: u,\n-                                defined: size.bits() as u8,\n-                            }),\n+                                size: size.bytes() as u8,\n+                            }.to_value(),\n                             switch_ty,\n                             &mut s,\n                         ).unwrap();\n@@ -2225,45 +2225,58 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n \n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n-    match (value, &ty.sty) {\n-        (Value::Scalar(Scalar::Bits { bits: 0, .. }), &TyBool) => write!(f, \"false\"),\n-        (Value::Scalar(Scalar::Bits { bits: 1, .. }), &TyBool) => write!(f, \"true\"),\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F32)) => {\n-            write!(f, \"{}f32\", Single::from_bits(bits))\n-        }\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F64)) => {\n-            write!(f, \"{}f64\", Double::from_bits(bits))\n-        }\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyUint(ui)) => write!(f, \"{:?}{}\", bits, ui),\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyInt(i)) => {\n-            let bit_width = ty::tls::with(|tcx| {\n-                let ty = tcx.lift_to_global(&ty).unwrap();\n-                tcx.layout_of(ty::ParamEnv::empty().and(ty))\n-                    .unwrap()\n-                    .size\n-                    .bits()\n-            });\n-            let shift = 128 - bit_width;\n-            write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i)\n-        }\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyChar) => {\n-            write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap())\n+    // print some primitives\n+    if let Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. })) = value {\n+        match ty.sty {\n+            TyBool if bits == 0 => return write!(f, \"false\"),\n+            TyBool if bits == 1 => return write!(f, \"true\"),\n+            TyFloat(ast::FloatTy::F32) => return write!(f, \"{}f32\", Single::from_bits(bits)),\n+            TyFloat(ast::FloatTy::F64) => return write!(f, \"{}f64\", Double::from_bits(bits)),\n+            TyUint(ui) => return write!(f, \"{:?}{}\", bits, ui),\n+            TyInt(i) => {\n+                let bit_width = ty::tls::with(|tcx| {\n+                    let ty = tcx.lift_to_global(&ty).unwrap();\n+                    tcx.layout_of(ty::ParamEnv::empty().and(ty))\n+                        .unwrap()\n+                        .size\n+                        .bits()\n+                });\n+                let shift = 128 - bit_width;\n+                return write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i);\n+            }\n+            TyChar => return write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n+            _ => {},\n         }\n-        (_, &TyFnDef(did, _)) => write!(f, \"{}\", item_path_str(did)),\n-        (\n-            Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: len, .. }),\n-            &TyRef(_, &ty::TyS { sty: TyStr, .. }, _),\n-        ) => ty::tls::with(|tcx| match tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(interpret::AllocType::Memory(alloc)) => {\n-                assert_eq!(len as usize as u128, len);\n-                let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-                write!(f, \"{:?}\", s)\n+    }\n+    // print function definitons\n+    if let TyFnDef(did, _) = ty.sty {\n+        return write!(f, \"{}\", item_path_str(did));\n+    }\n+    // print string literals\n+    if let Value::ScalarPair(ptr, len) = value {\n+        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = ptr {\n+            if let ScalarMaybeUndef::Scalar(Scalar::Bits { bits: len, .. }) = len {\n+                if let TyRef(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n+                    return ty::tls::with(|tcx| {\n+                        let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        if let Some(interpret::AllocType::Memory(alloc)) = alloc {\n+                            assert_eq!(len as usize as u128, len);\n+                            let slice = &alloc\n+                                .bytes\n+                                    [(ptr.offset.bytes() as usize)..]\n+                                    [..(len as usize)];\n+                            let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                            write!(f, \"{:?}\", s)\n+                        } else {\n+                             write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len)\n+                        }\n+                    });\n+                }\n             }\n-            _ => write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len),\n-        }),\n-        _ => write!(f, \"{:?}:{}\", value, ty),\n+        }\n     }\n+    // just raw dump everything else\n+    write!(f, \"{:?}:{}\", value, ty)\n }\n \n fn item_path_str(def_id: DefId) -> String {"}, {"sha": "96b4edce86b30f5603b33af3f259b4bd62ce213e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1887,22 +1887,13 @@ impl<'tcx> Const<'tcx> {\n         })\n     }\n \n-    #[inline]\n-    pub fn from_byval_value(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: Value,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n-        Self::from_const_value(tcx, ConstValue::from_byval_value(val), ty)\n-    }\n-\n     #[inline]\n     pub fn from_scalar(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         val: Scalar,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n-        Self::from_const_value(tcx, ConstValue::from_scalar(val), ty)\n+        Self::from_const_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n@@ -1918,12 +1909,12 @@ impl<'tcx> Const<'tcx> {\n         let shift = 128 - size.bits();\n         let truncated = (bits << shift) >> shift;\n         assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(tcx, Scalar::Bits { bits, defined: size.bits() as u8 }, ty.value)\n+        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::undef(), ty)\n+        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n     }\n \n     #[inline]\n@@ -1960,11 +1951,6 @@ impl<'tcx> Const<'tcx> {\n         self.val.to_byval_value()\n     }\n \n-    #[inline]\n-    pub fn to_scalar(&self) -> Option<Scalar> {\n-        self.val.to_scalar()\n-    }\n-\n     #[inline]\n     pub fn assert_bits(\n         &self,"}, {"sha": "267db4467c21a23e376e7c89c9099404c000628d", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -39,10 +39,12 @@ pub fn scalar_to_llvm(\n ) -> &'ll Value {\n     let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n-        Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n-            C_undef(Type::ix(cx, bitsize))\n+        Scalar::Bits { size: 0, .. } => {\n+            assert_eq!(0, layout.value.size(cx).bytes());\n+            C_undef(Type::ix(cx, 0))\n         },\n-        Scalar::Bits { bits, .. } => {\n+        Scalar::Bits { bits, size } => {\n+            assert_eq!(size as u64, layout.value.size(cx).bytes());\n             let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n@@ -192,7 +194,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         mir::Field::new(field as usize),\n                         c,\n                     )?;\n-                    if let Some(prim) = field.to_scalar() {\n+                    if let Some(prim) = field.val.try_to_scalar() {\n                         let layout = bx.cx.layout_of(field_ty);\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,"}, {"sha": "f8166ee6491472afcb6275a28ca2882193b377f6", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::mir::interpret::ConstValue;\n+use rustc::mir::interpret::{ConstValue, ScalarMaybeUndef};\n use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -110,12 +110,16 @@ impl OperandRef<'ll, 'tcx> {\n                     a_scalar,\n                     layout.scalar_pair_element_llvm_type(bx.cx, 0, true),\n                 );\n-                let b_llval = scalar_to_llvm(\n-                    bx.cx,\n-                    b,\n-                    b_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx, 1, true),\n-                );\n+                let b_layout = layout.scalar_pair_element_llvm_type(bx.cx, 1, true);\n+                let b_llval = match b {\n+                    ScalarMaybeUndef::Scalar(b) => scalar_to_llvm(\n+                        bx.cx,\n+                        b,\n+                        b_scalar,\n+                        b_layout,\n+                    ),\n+                    ScalarMaybeUndef::Undef => C_undef(b_layout),\n+                };\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n             ConstValue::ByRef(alloc, offset) => {"}, {"sha": "70148fc91760443bb6d31b18de8988fa5eb6ac21", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -151,14 +151,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n         let trunc = |n| {\n             let param_ty = self.param_env.and(self.tcx.lift_to_global(&ty).unwrap());\n-            let bit_width = self.tcx.layout_of(param_ty).unwrap().size.bits();\n-            trace!(\"trunc {} with size {} and shift {}\", n, bit_width, 128 - bit_width);\n-            let shift = 128 - bit_width;\n+            let width = self.tcx.layout_of(param_ty).unwrap().size;\n+            trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+            let shift = 128 - width.bits();\n             let result = (n << shift) >> shift;\n             trace!(\"trunc result: {}\", result);\n             ConstValue::Scalar(Scalar::Bits {\n                 bits: result,\n-                defined: bit_width as u8,\n+                size: width.bytes() as u8,\n             })\n         };\n \n@@ -168,15 +168,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n                 let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, self.tcx);\n-                ConstValue::from_byval_value(value)\n+                ConstValue::from_byval_value(value).unwrap()\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n                 ConstValue::Scalar(Scalar::Ptr(id.into()))\n             },\n             LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n                 bits: n as u128,\n-                defined: 8,\n+                size: 1,\n             }),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n@@ -194,14 +194,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n-                bits: b as u128,\n-                defined: 8,\n-            }),\n-            LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n-                bits: c as u128,\n-                defined: 32,\n-            }),\n+            LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n+            LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n         };\n         ty::Const::from_const_value(self.tcx, lit, ty)\n     }"}, {"sha": "d614131c526837623dbcae21965fb572b157206b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -19,7 +19,7 @@ pub(crate) use self::check_match::check_match;\n use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, Value};\n+use rustc::mir::interpret::{Scalar, GlobalId, ConstValue};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -1080,8 +1080,9 @@ pub fn compare_const_vals<'a, 'tcx>(\n                 l.partial_cmp(&r)\n             },\n             ty::TyInt(_) => {\n-                let a = interpret::sign_extend(tcx, a, ty.value).expect(\"layout error for TyInt\");\n-                let b = interpret::sign_extend(tcx, b, ty.value).expect(\"layout error for TyInt\");\n+                let layout = tcx.layout_of(ty).ok()?;\n+                let a = interpret::sign_extend(a, layout);\n+                let b = interpret::sign_extend(b, layout);\n                 Some((a as i128).cmp(&(b as i128)))\n             },\n             _ => Some(a.cmp(&b)),\n@@ -1090,17 +1091,24 @@ pub fn compare_const_vals<'a, 'tcx>(\n \n     if let ty::TyRef(_, rty, _) = ty.value.sty {\n         if let ty::TyStr = rty.sty {\n-            match (a.to_byval_value(), b.to_byval_value()) {\n+            match (a.val, b.val) {\n                 (\n-                    Some(Value::ScalarPair(\n+                    ConstValue::ScalarPair(\n                         Scalar::Ptr(ptr_a),\n                         len_a,\n-                    )),\n-                    Some(Value::ScalarPair(\n+                    ),\n+                    ConstValue::ScalarPair(\n                         Scalar::Ptr(ptr_b),\n                         len_b,\n-                    ))\n+                    ),\n                 ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n+                    let len_a = len_a.unwrap_or_err().ok();\n+                    let len_b = len_b.unwrap_or_err().ok();\n+                    if len_a.is_none() || len_b.is_none() {\n+                        tcx.sess.struct_err(\"str slice len is undef\").delay_as_bug();\n+                    }\n+                    let len_a = len_a?;\n+                    let len_b = len_b?;\n                     if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n                         if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n                             if len_a == len_b {\n@@ -1142,15 +1150,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n             let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, tcx);\n-            ConstValue::from_byval_value(value)\n+            ConstValue::from_byval_value(value).unwrap()\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n         LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n             bits: n as u128,\n-            defined: 8,\n+            size: 1,\n         }),\n         LitKind::Int(n, _) => {\n             enum Int {\n@@ -1188,10 +1196,10 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            let defined = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits() as u8;\n+            let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bytes() as u8;\n             ConstValue::Scalar(Scalar::Bits {\n                 bits: n,\n-                defined,\n+                size,\n             })\n         },\n         LitKind::Float(n, fty) => {\n@@ -1204,14 +1212,8 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n         }\n-        LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n-            bits: b as u128,\n-            defined: 8,\n-        }),\n-        LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n-            bits: c as u128,\n-            defined: 32,\n-        }),\n+        LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n+        LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n     };\n     Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n@@ -1224,7 +1226,7 @@ pub fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let (bits, defined) = match fty {\n+    let (bits, size) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -1233,7 +1235,7 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            (f.to_bits(), 32)\n+            (f.to_bits(), 4)\n         }\n         ast::FloatTy::F64 => {\n             num.parse::<f64>().map_err(|_| ())?;\n@@ -1243,9 +1245,9 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            (f.to_bits(), 64)\n+            (f.to_bits(), 8)\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::Bits { bits, defined }))\n+    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n }"}, {"sha": "4e705254331a2f08a2d1eec5c724912ae5e58b71", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n@@ -18,11 +18,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n         dest: Place,\n     ) -> EvalResult<'tcx> {\n+        let src_layout = self.layout_of(src.ty)?;\n+        let dst_layout = self.layout_of(dest_ty)?;\n         use rustc::mir::CastKind::*;\n         match kind {\n             Unsize => {\n-                let src_layout = self.layout_of(src.ty)?;\n-                let dst_layout = self.layout_of(dest_ty)?;\n                 self.unsize_into(src.value, src_layout, dest, dst_layout)?;\n             }\n \n@@ -57,16 +57,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n-                                let defined = self\n-                                    .layout_of(dest_ty)\n-                                    .unwrap()\n-                                    .size\n-                                    .bits() as u8;\n                                 return self.write_scalar(\n                                     dest,\n                                     Scalar::Bits {\n                                         bits: discr_val,\n-                                        defined,\n+                                        size: dst_layout.size.bytes() as u8,\n                                     },\n                                     dest_ty);\n                             }\n@@ -76,9 +71,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n \n                     let src_val = self.value_to_scalar(src)?;\n-                    let dest_val = self.cast_scalar(src_val, src.ty, dest_ty)?;\n+                    let dest_val = self.cast_scalar(src_val, src_layout, dst_layout)?;\n                     let valty = ValTy {\n-                        value: Value::Scalar(dest_val),\n+                        value: Value::Scalar(dest_val.into()),\n                         ty: dest_ty,\n                     };\n                     self.write_value(valty, dest)?;\n@@ -100,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n                         let fn_ptr = self.memory.create_fn_alloc(instance?);\n                         let valty = ValTy {\n-                            value: Value::Scalar(fn_ptr.into()),\n+                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n                             ty: dest_ty,\n                         };\n                         self.write_value(valty, dest)?;\n@@ -136,7 +131,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(instance);\n                         let valty = ValTy {\n-                            value: Value::Scalar(fn_ptr.into()),\n+                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n                             ty: dest_ty,\n                         };\n                         self.write_value(valty, dest)?;\n@@ -151,20 +146,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(super) fn cast_scalar(\n         &self,\n         val: Scalar,\n-        src_ty: Ty<'tcx>,\n-        dest_ty: Ty<'tcx>,\n+        src_layout: TyLayout<'tcx>,\n+        dest_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n         match val {\n-            Scalar::Bits { defined: 0, .. } => Ok(val),\n-            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            Scalar::Bits { bits, .. } => {\n-                // TODO(oli-obk): check defined bits here\n-                match src_ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_ty),\n-                    _ => self.cast_from_int(bits, src_ty, dest_ty),\n+            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, src_layout.size.bytes());\n+                match src_layout.ty.sty {\n+                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty),\n+                    _ => self.cast_from_int(bits, src_layout, dest_layout),\n                 }\n             }\n         }\n@@ -173,56 +167,58 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn cast_from_int(\n         &self,\n         v: u128,\n-        src_ty: Ty<'tcx>,\n-        dest_ty: Ty<'tcx>,\n+        src_layout: TyLayout<'tcx>,\n+        dest_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Scalar> {\n-        let signed = self.layout_of(src_ty)?.abi.is_signed();\n+        let signed = src_layout.abi.is_signed();\n         let v = if signed {\n-            self.sign_extend(v, src_ty)?\n+            self.sign_extend(v, src_layout)\n         } else {\n             v\n         };\n-        trace!(\"cast_from_int: {}, {}, {}\", v, src_ty, dest_ty);\n+        trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n         use rustc::ty::TypeVariants::*;\n-        match dest_ty.sty {\n+        match dest_layout.ty.sty {\n             TyInt(_) | TyUint(_) => {\n-                let v = self.truncate(v, dest_ty)?;\n+                let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::Bits {\n                     bits: v,\n-                    defined: self.layout_of(dest_ty).unwrap().size.bits() as u8,\n+                    size: dest_layout.size.bytes() as u8,\n                 })\n             }\n \n             TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bits {\n                 bits: Single::from_i128(v as i128).value.to_bits(),\n-                defined: 32,\n+                size: 4,\n             }),\n             TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bits {\n                 bits: Double::from_i128(v as i128).value.to_bits(),\n-                defined: 64,\n+                size: 8,\n             }),\n             TyFloat(FloatTy::F32) => Ok(Scalar::Bits {\n                 bits: Single::from_u128(v).value.to_bits(),\n-                defined: 32,\n+                size: 4,\n             }),\n             TyFloat(FloatTy::F64) => Ok(Scalar::Bits {\n                 bits: Double::from_u128(v).value.to_bits(),\n-                defined: 64,\n+                size: 8,\n             }),\n \n-            TyChar if v as u8 as u128 == v => Ok(Scalar::Bits { bits: v, defined: 32 }),\n-            TyChar => err!(InvalidChar(v)),\n+            TyChar => {\n+                assert_eq!(v as u8 as u128, v);\n+                Ok(Scalar::Bits { bits: v, size: 4 })\n+            },\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n                 Ok(Scalar::Bits {\n                     bits: self.memory.truncate_to_ptr(v).0 as u128,\n-                    defined: self.memory.pointer_size().bits() as u8,\n+                    size: self.memory.pointer_size().bytes() as u8,\n                 })\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_ty))),\n+            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n \n@@ -236,11 +232,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_u128(width).value,\n-                        defined: width as u8,\n+                        size: (width / 8) as u8,\n                     }),\n                     FloatTy::F64 => Ok(Scalar::Bits {\n                         bits: Double::from_bits(bits).to_u128(width).value,\n-                        defined: width as u8,\n+                        size: (width / 8) as u8,\n                     }),\n                 }\n             },\n@@ -250,36 +246,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_i128(width).value as u128,\n-                        defined: width as u8,\n+                        size: (width / 8) as u8,\n                     }),\n                     FloatTy::F64 => Ok(Scalar::Bits {\n                         bits: Double::from_bits(bits).to_i128(width).value as u128,\n-                        defined: width as u8,\n+                        size: (width / 8) as u8,\n                     }),\n                 }\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n                 Ok(Scalar::Bits {\n                     bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n-                    defined: 32,\n+                    size: 4,\n                 })\n             },\n             // f32 -> f64\n             TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n                 Ok(Scalar::Bits {\n                     bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n-                    defined: 64,\n+                    size: 8,\n                 })\n             },\n             // identity cast\n             TyFloat(FloatTy:: F64) => Ok(Scalar::Bits {\n                 bits,\n-                defined: 64,\n+                size: 8,\n             }),\n             TyFloat(FloatTy:: F32) => Ok(Scalar::Bits {\n                 bits,\n-                defined: 32,\n+                size: 4,\n             }),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }"}, {"sha": "9d66a0b396b640fe7d3498aa75dc7b9caedb9bc2", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -2,11 +2,12 @@ use std::fmt;\n use std::error::Error;\n \n use rustc::hir;\n-use rustc::mir::interpret::{ConstEvalErr};\n+use rustc::mir::interpret::{ConstEvalErr, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout};\n use rustc::ty::subst::Subst;\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n@@ -28,13 +29,16 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     let param_env = tcx.param_env(instance.def_id());\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     // insert a stack frame so any queries have the correct substs\n-    ecx.push_stack_frame(\n+    ecx.stack.push(super::eval_context::Frame {\n+        block: mir::START_BLOCK,\n+        locals: IndexVec::new(),\n         instance,\n         span,\n         mir,\n-        Place::undef(),\n-        StackPopCleanup::None,\n-    )?;\n+        return_place: Place::undef(),\n+        return_to_block: StackPopCleanup::None,\n+        stmt: 0,\n+    });\n     Ok(ecx)\n }\n \n@@ -72,48 +76,30 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n pub fn value_to_const_value<'tcx>(\n     ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n     val: Value,\n-    ty: Ty<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    let layout = ecx.layout_of(ty).unwrap();\n+    layout: TyLayout<'tcx>,\n+) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n     match (val, &layout.abi) {\n-        (Value::Scalar(Scalar::Bits { defined: 0, ..}), _) if layout.is_zst() => {},\n+        (Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size: 0, ..})), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n         (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n         (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n         _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n     }\n-    let val = (|| {\n-        match val {\n-            Value::Scalar(val) => Ok(ConstValue::Scalar(val)),\n-            Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n-            Value::ByRef(ptr, align) => {\n-                let ptr = ptr.to_ptr().unwrap();\n-                let alloc = ecx.memory.get(ptr.alloc_id)?;\n-                assert!(alloc.align.abi() >= align.abi());\n-                assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n-                let mut alloc = alloc.clone();\n-                alloc.align = align;\n-                let alloc = ecx.tcx.intern_const_alloc(alloc);\n-                Ok(ConstValue::ByRef(alloc, ptr.offset))\n-            }\n-        }\n-    })();\n-    match val {\n-        Ok(val) => ty::Const::from_const_value(ecx.tcx.tcx, val, ty),\n-        Err(err) => {\n-            let (frames, span) = ecx.generate_stacktrace(None);\n-            let err = ConstEvalErr {\n-                span,\n-                error: err,\n-                stacktrace: frames,\n-            };\n-            err.report_as_error(\n-                ecx.tcx,\n-                \"failed to convert Value to ConstValue, this is a bug\",\n-            );\n-            span_bug!(span, \"miri error occured when converting Value to ConstValue\")\n+    let val = match val {\n+        Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n+        Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n+        Value::ByRef(ptr, align) => {\n+            let ptr = ptr.to_ptr().unwrap();\n+            let alloc = ecx.memory.get(ptr.alloc_id)?;\n+            assert!(alloc.align.abi() >= align.abi());\n+            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n+            let mut alloc = alloc.clone();\n+            alloc.align = align;\n+            let alloc = ecx.tcx.intern_const_alloc(alloc);\n+            ConstValue::ByRef(alloc, ptr.offset)\n         }\n-    }\n+    };\n+    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, layout.ty))\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n@@ -307,7 +293,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n                 let align_val = Scalar::Bits {\n                     bits: elem_align as u128,\n-                    defined: dest_layout.size.bits() as u8,\n+                    size: dest_layout.size.bytes() as u8,\n                 };\n                 ecx.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n@@ -317,7 +303,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n                 let size_val = Scalar::Bits {\n                     bits: size,\n-                    defined: dest_layout.size.bits() as u8,\n+                    size: dest_layout.size.bytes() as u8,\n                 };\n                 ecx.write_scalar(dest, size_val, dest_layout.ty)?;\n             }\n@@ -327,7 +313,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n                 let id_val = Scalar::Bits {\n                     bits: type_id,\n-                    defined: dest_layout.size.bits() as u8,\n+                    size: dest_layout.size.bytes() as u8,\n                 };\n                 ecx.write_scalar(dest, id_val, dest_layout.ty)?;\n             }\n@@ -437,7 +423,7 @@ pub fn const_val_field<'a, 'tcx>(\n         let place = ecx.allocate_place_for_value(value, layout, variant)?;\n         let (place, layout) = ecx.place_field(place, field, layout)?;\n         let (ptr, align) = place.to_ptr_align();\n-        let mut new_value = Value::ByRef(ptr, align);\n+        let mut new_value = Value::ByRef(ptr.unwrap_or_err()?, align);\n         new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n         use rustc_data_structures::indexed_vec::Idx;\n         match (value, new_value) {\n@@ -451,7 +437,7 @@ pub fn const_val_field<'a, 'tcx>(\n             ),\n             _ => {},\n         }\n-        Ok(value_to_const_value(&ecx, new_value, layout.ty))\n+        value_to_const_value(&ecx, new_value, layout)\n     })();\n     result.map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n@@ -481,7 +467,7 @@ pub fn const_variant_index<'a, 'tcx>(\n         },\n         Value::ByRef(ptr, align) => (ptr, align),\n     };\n-    let place = Place::from_scalar_ptr(ptr, align);\n+    let place = Place::from_scalar_ptr(ptr.into(), align);\n     ecx.read_discriminant_as_variant_index(place, layout)\n }\n \n@@ -552,7 +538,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n         if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n             val = ecx.try_read_by_ref(val, layout.ty)?;\n         }\n-        Ok(value_to_const_value(&ecx, val, layout.ty))\n+        value_to_const_value(&ecx, val, layout)\n     }).map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n         let err = ConstEvalErr {\n@@ -562,6 +548,9 @@ pub fn const_eval_provider<'a, 'tcx>(\n         };\n         if tcx.is_static(def_id).is_some() {\n             err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+            if tcx.sess.err_count() == 0 {\n+                span_bug!(span, \"static eval failure didn't emit an error: {:#?}\", err);\n+            }\n         }\n         err.into()\n     })\n@@ -572,17 +561,17 @@ fn numeric_intrinsic<'tcx>(\n     bits: u128,\n     kind: Primitive,\n ) -> EvalResult<'tcx, Scalar> {\n-    let defined = match kind {\n-        Primitive::Int(integer, _) => integer.size().bits() as u8,\n+    let size = match kind {\n+        Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n     };\n-    let extra = 128 - defined as u128;\n+    let extra = 128 - size.bits() as u128;\n     let bits_out = match name {\n         \"ctpop\" => bits.count_ones() as u128,\n         \"ctlz\" => bits.leading_zeros() as u128 - extra,\n         \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n         \"bswap\" => (bits << extra).swap_bytes(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n-    Ok(Scalar::Bits { bits: bits_out, defined })\n+    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n }"}, {"sha": "52305be5facef18c2b762c7ffe754320921c53d7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 142, "deletions": 155, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::mir::interpret::{\n     GlobalId, Value, Scalar, FrameInfo, AllocType,\n     EvalResult, EvalErrorKind, Pointer, ConstValue,\n+    ScalarMaybeUndef,\n };\n \n use syntax::codemap::{self, Span};\n@@ -105,9 +106,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n-    ///\n-    /// Before being initialized, arguments are `Value::Scalar(Scalar::undef())` and other locals are `None`.\n-    pub locals: IndexVec<mir::Local, Option<Value>>,\n+    pub locals: IndexVec<mir::Local, LocalValue>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -120,6 +119,21 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum LocalValue {\n+    Dead,\n+    Live(Value),\n+}\n+\n+impl LocalValue {\n+    pub fn access(self) -> EvalResult<'static, Value> {\n+        match self {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(val) => Ok(val),\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> Eq for Frame<'mir, 'tcx> {}\n \n impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n@@ -395,8 +409,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n                 Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n-            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n-            ConstValue::Scalar(val) => Ok(Value::Scalar(val)),\n+            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a.into(), b.into())),\n+            ConstValue::Scalar(val) => Ok(Value::Scalar(val.into())),\n         }\n     }\n \n@@ -452,7 +466,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     /// Note that the value does not matter if the type is sized. For unsized types,\n     /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n     pub fn size_and_align_of_dst(\n-        &mut self,\n+        &self,\n         ty: Ty<'tcx>,\n         value: Value,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n@@ -480,7 +494,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let field_ty = layout.field(&self, layout.fields.count() - 1)?.ty;\n+                    let field_ty = layout.field(self, layout.fields.count() - 1)?.ty;\n                     let (unsized_size, unsized_align) =\n                         self.size_and_align_of_dst(field_ty, value)?;\n \n@@ -518,7 +532,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n-                    let (elem_size, align) = layout.field(&self, 0)?.size_and_align();\n+                    let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n                     let (_, len) = self.into_slice(value)?;\n                     Ok((elem_size * len, align))\n                 }\n@@ -538,8 +552,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n-        let locals = if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(Some(Value::Scalar(Scalar::undef())), &mir.local_decls);\n+        // first push a stack frame so we have access to the local substs\n+        self.stack.push(Frame {\n+            mir,\n+            block: mir::START_BLOCK,\n+            return_to_block,\n+            return_place,\n+            // empty local array, we fill it in below, after we are inside the stack frame and\n+            // all methods actually know about the frame\n+            locals: IndexVec::new(),\n+            span,\n+            instance,\n+            stmt: 0,\n+        });\n+\n+        // don't allocate at all for trivial constants\n+        if mir.local_decls.len() > 1 {\n+            let mut locals = IndexVec::from_elem(LocalValue::Dead, &mir.local_decls);\n+            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n+                *local = LocalValue::Live(self.init_value(decl.ty)?);\n+            }\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -550,29 +582,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             use rustc::mir::StatementKind::{StorageDead, StorageLive};\n                             match stmt.kind {\n                                 StorageLive(local) |\n-                                StorageDead(local) => locals[local] = None,\n+                                StorageDead(local) => locals[local] = LocalValue::Dead,\n                                 _ => {}\n                             }\n                         }\n                     }\n                 },\n             }\n-            locals\n-        } else {\n-            // don't allocate at all for trivial constants\n-            IndexVec::new()\n-        };\n-\n-        self.stack.push(Frame {\n-            mir,\n-            block: mir::START_BLOCK,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            span,\n-            instance,\n-            stmt: 0,\n-        });\n+            self.frame_mut().locals = locals;\n+        }\n \n         self.memory.cur_frame = self.cur_frame();\n \n@@ -598,7 +616,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n-                        ptr.to_ptr()?.alloc_id,\n+                        ptr.unwrap_or_err()?.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n                 } else {\n@@ -616,8 +634,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr, _align)) = local {\n+    pub fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n+        // FIXME: should we tell the user that there was a local which was never written to?\n+        if let LocalValue::Live(Value::ByRef(ptr, _align)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -637,6 +656,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         let dest = self.eval_place(place)?;\n         let dest_ty = self.place_ty(place);\n+        let dest_layout = self.layout_of(dest_ty)?;\n \n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n@@ -675,7 +695,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_scalar(operand)?;\n-                let val = self.unary_op(un_op, val, dest_ty)?;\n+                let val = self.unary_op(un_op, val, dest_layout)?;\n                 self.write_scalar(\n                     dest,\n                     val,\n@@ -724,6 +744,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n                 if length > 0 {\n+                    let dest = dest.unwrap_or_err()?;\n                     //write the first value\n                     self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n \n@@ -739,12 +760,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n-                let defined = self.memory.pointer_size().bits() as u8;\n+                let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n                         bits: len as u128,\n-                        defined,\n+                        size,\n                     },\n                     dest_ty,\n                 )?;\n@@ -757,7 +778,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (ptr, _align, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n \n                 let val = match extra {\n-                    PlaceExtra::None => ptr.to_value(),\n+                    PlaceExtra::None => Value::Scalar(ptr),\n                     PlaceExtra::Length(len) => ptr.to_value_with_len(len, self.tcx.tcx),\n                     PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     PlaceExtra::DowncastVariant(..) => {\n@@ -781,12 +802,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                let defined = self.memory.pointer_size().bits() as u8;\n+                let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n                         bits: layout.size.bytes() as u128,\n-                        defined,\n+                        size,\n                     },\n                     dest_ty,\n                 )?;\n@@ -803,10 +824,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, layout)?;\n-                let defined = self.layout_of(dest_ty).unwrap().size.bits() as u8;\n+                let size = self.layout_of(dest_ty).unwrap().size.bytes() as u8;\n                 self.write_scalar(dest, Scalar::Bits {\n                     bits: discr_val,\n-                    defined,\n+                    size,\n                 }, dest_ty)?;\n             }\n         }\n@@ -957,10 +978,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n                     },\n-                    Scalar::Bits { bits: raw_discr, defined } => {\n-                        if defined < discr.size.bits() as u8 {\n-                            return err!(ReadUndefBytes);\n-                        }\n+                    Scalar::Bits { bits: raw_discr, size } => {\n+                        assert_eq!(size as u64, discr.size.bytes());\n                         let discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= discr && discr <= variants_end {\n@@ -1002,14 +1021,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = tag.value.size(self.tcx.tcx).bits();\n-                let shift = 128 - size;\n+                let size = tag.value.size(self.tcx.tcx);\n+                let shift = 128 - size.bits();\n                 let discr_val = (discr_val << shift) >> shift;\n \n                 let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n                 self.write_scalar(discr_dest, Scalar::Bits {\n                     bits: discr_val,\n-                    defined: size as u8,\n+                    size: size.bytes() as u8,\n                 }, tag.ty)?;\n             }\n             layout::Variants::NicheFilling {\n@@ -1025,7 +1044,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         .wrapping_add(niche_start);\n                     self.write_scalar(niche_dest, Scalar::Bits {\n                         bits: niche_value,\n-                        defined: niche.size.bits() as u8,\n+                        size: niche.size.bytes() as u8,\n                     }, niche.ty)?;\n                 }\n             }\n@@ -1063,7 +1082,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             },\n         };\n         Ok(Place::Ptr {\n-            ptr,\n+            ptr: ptr.into(),\n             align,\n             extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n         })\n@@ -1072,22 +1091,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local] {\n-                    None => return err!(DeadLocal),\n-                    Some(Value::ByRef(ptr, align)) => {\n+                match self.stack[frame].locals[local].access()? {\n+                    Value::ByRef(ptr, align) => {\n                         Place::Ptr {\n-                            ptr,\n+                            ptr: ptr.into(),\n                             align,\n                             extra: PlaceExtra::None,\n                         }\n                     }\n-                    Some(val) => {\n+                    val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(layout)?;\n                         self.stack[frame].locals[local] =\n-                            Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n+                            LocalValue::Live(Value::ByRef(ptr.into(), layout.align)); // it stays live\n+\n                         let place = Place::from_ptr(ptr, layout.align);\n                         self.write_value(ValTy { value: val, ty }, place)?;\n                         place\n@@ -1120,7 +1139,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n-            Value::Scalar(scalar) => Ok(scalar),\n+            Value::Scalar(scalar) => scalar.unwrap_or_err(),\n \n             Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n         }\n@@ -1137,11 +1156,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn write_scalar(\n         &mut self,\n         dest: Place,\n-        val: Scalar,\n+        val: impl Into<ScalarMaybeUndef>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let valty = ValTy {\n-            value: Value::Scalar(val),\n+            value: Value::Scalar(val.into()),\n             ty: dest_ty,\n         };\n         self.write_value(valty, dest)\n@@ -1160,15 +1179,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match dest {\n             Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                self.write_value_to_ptr(src_val, ptr, align, dest_ty)\n+                self.write_value_to_ptr(src_val, ptr.unwrap_or_err()?, align, dest_ty)\n             }\n \n             Place::Local { frame, local } => {\n-                let dest = self.stack[frame].get_local(local)?;\n+                let old_val = self.stack[frame].locals[local].access()?;\n                 self.write_value_possibly_by_val(\n                     src_val,\n                     |this, val| this.stack[frame].set_local(local, val),\n-                    dest,\n+                    old_val,\n                     dest_ty,\n                 )\n             }\n@@ -1183,6 +1202,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n+        // FIXME: this should be a layout check, not underlying value\n         if let Value::ByRef(dest_ptr, align) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n@@ -1239,12 +1259,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         layout::Primitive::Int(_, signed) => signed,\n                         _ => false,\n                     },\n-                    _ => match scalar {\n-                        Scalar::Bits { defined: 0, .. } => false,\n-                        _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout),\n-                    }\n+                    _ => false,\n                 };\n-                self.memory.write_scalar(dest, dest_align, scalar, layout.size, signed)\n+                self.memory.write_scalar(dest, dest_align, scalar, layout.size, layout.align, signed)\n             }\n             Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n@@ -1253,12 +1270,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let (a_align, b_align) = (a.align(&self), b.align(&self));\n                 let a_ptr = dest;\n-                let b_offset = a_size.abi_align(b.align(&self));\n+                let b_offset = a_size.abi_align(b_align);\n                 let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n-                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, false)\n+                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, a_align, false)?;\n+                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, b_align, false)\n             }\n         }\n     }\n@@ -1271,38 +1289,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub(crate) fn read_ptr(\n-        &self,\n-        ptr: Pointer,\n-        ptr_align: Align,\n-        pointee_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        let ptr_size = self.memory.pointer_size();\n-        let p: Scalar = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n-        if self.type_is_sized(pointee_ty) {\n-            Ok(p.to_value())\n-        } else {\n-            trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(ptr_size, self)?;\n-            match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n-                )),\n-                ty::TySlice(..) | ty::TyStr => {\n-                    let len = self\n-                        .memory\n-                        .read_ptr_sized(extra, ptr_align)?\n-                        .to_bits(ptr_size)?;\n-                    Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n-                },\n-                _ => bug!(\"unsized scalar ptr read from {:?}\", pointee_ty),\n-            }\n-        }\n-    }\n-\n     fn validate_scalar(\n         &self,\n-        value: Scalar,\n+        value: ScalarMaybeUndef,\n         size: Size,\n         scalar: &layout::Scalar,\n         path: &str,\n@@ -1311,8 +1300,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n         let (lo, hi) = scalar.valid_range.clone().into_inner();\n \n-        let (bits, defined) = match value {\n-            Scalar::Bits { bits, defined } => (bits, defined),\n+        let value = match value {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n+        };\n+\n+        let bits = match value {\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            },\n             Scalar::Ptr(_) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n@@ -1346,7 +1343,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         // has no special checks for chars\n         match ty.sty {\n             ty::TyChar => {\n-                assert_eq!(size.bytes(), 4);\n+                debug_assert_eq!(size.bytes(), 4);\n                 if ::std::char::from_u32(bits as u32).is_none() {\n                     return err!(InvalidChar(bits));\n                 }\n@@ -1355,32 +1352,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n \n         use std::ops::RangeInclusive;\n-        let in_range = |bound: RangeInclusive<u128>| {\n-            defined as u64 >= size.bits() && bound.contains(&bits)\n-        };\n+        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n         if lo > hi {\n             if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n                 Ok(())\n-            } else if defined as u64 >= size.bits() {\n+            } else {\n                 validation_failure!(\n                     bits,\n                     path,\n                     format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n                 )\n-            } else {\n-                validation_failure!(\"undefined bytes\", path)\n             }\n         } else {\n             if in_range(scalar.valid_range.clone()) {\n                 Ok(())\n-            } else if defined as u64 >= size.bits() {\n+            } else {\n                 validation_failure!(\n                     bits,\n                     path,\n                     format!(\"something in the range {:?}\", scalar.valid_range)\n                 )\n-            } else {\n-                validation_failure!(\"undefined bytes\", path)\n             }\n         }\n     }\n@@ -1410,10 +1401,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     mir::Field::new(0),\n                     layout,\n                 )?;\n-                let tag_value = self.value_to_scalar(ValTy {\n-                    value: tag_value,\n-                    ty: tag_layout.ty,\n-                })?;\n+                let tag_value = match self.follow_by_ref_value(tag_value, tag_layout.ty)? {\n+                    Value::Scalar(val) => val,\n+                    _ => bug!(\"tag must be scalar\"),\n+                };\n                 let path = format!(\"{}.TAG\", path);\n                 self.validate_scalar(tag_value, size, tag, &path, tag_layout.ty)?;\n                 let variant_index = self.read_discriminant_as_variant_index(\n@@ -1440,7 +1431,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n                         if scalar.value == Primitive::Pointer {\n                             // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = value {\n+                            if let Scalar::Ptr(ptr) = value.unwrap_or_err()? {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n                                     // statics from other crates are already checked\n@@ -1534,7 +1525,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::Scalar(Scalar::undef())));\n+            return Ok(Some(Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 }))));\n         }\n \n         let ptr = ptr.to_ptr()?;\n@@ -1670,7 +1661,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     }\n                     let (src_f_value, src_field) = match src {\n                         Value::ByRef(ptr, align) => {\n-                            let src_place = Place::from_scalar_ptr(ptr, align);\n+                            let src_place = Place::from_scalar_ptr(ptr.into(), align);\n                             let (src_f_place, src_field) =\n                                 self.place_field(src_place, mir::Field::new(i), src_layout)?;\n                             (self.read_place(src_f_place)?, src_field)\n@@ -1717,7 +1708,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].get_local(local) {\n+                match self.stack[frame].locals[local].access() {\n                     Err(err) => {\n                         if let EvalErrorKind::DeadLocal = err.kind {\n                             write!(msg, \" is dead\").unwrap();\n@@ -1736,16 +1727,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     }\n                     Ok(Value::Scalar(val)) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n-                        if let Scalar::Ptr(ptr) = val {\n+                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     Ok(Value::ScalarPair(val1, val2)) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                        if let Scalar::Ptr(ptr) = val1 {\n+                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        if let Scalar::Ptr(ptr) = val2 {\n+                        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val2 {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n@@ -1756,7 +1747,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             Place::Ptr { ptr, align, .. } => {\n                 match ptr {\n-                    Scalar::Ptr(ptr) => {\n+                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n@@ -1766,21 +1757,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    /// Convenience function to ensure correct usage of locals\n-    pub fn modify_local<F>(&mut self, frame: usize, local: mir::Local, f: F) -> EvalResult<'tcx>\n-    where\n-        F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n-    {\n-        let val = self.stack[frame].get_local(local)?;\n-        let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, new_val)?;\n-        // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n-        // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n-        //     self.memory.deallocate(ptr)?;\n-        // }\n-        Ok(())\n-    }\n-\n     pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> (Vec<FrameInfo>, Span) {\n         let mut last_span = None;\n         let mut frames = Vec::new();\n@@ -1819,12 +1795,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         (frames, self.tcx.span)\n     }\n \n-    pub fn sign_extend(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n-        super::sign_extend(self.tcx.tcx, value, ty)\n+    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        super::sign_extend(value, ty)\n     }\n \n-    pub fn truncate(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n-        super::truncate(self.tcx.tcx, value, ty)\n+    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        super::truncate(value, ty)\n     }\n \n     fn write_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n@@ -1893,34 +1869,45 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n         }\n     }\n-}\n \n-impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n-    pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n-        self.locals[local].ok_or_else(|| EvalErrorKind::DeadLocal.into())\n+    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n+        trace!(\"{:?} is now live\", local);\n+\n+        let ty = self.frame().mir.local_decls[local].ty;\n+        let init = self.init_value(ty)?;\n+        // StorageLive *always* kills the value that's currently stored\n+        Ok(mem::replace(&mut self.frame_mut().locals[local], LocalValue::Live(init)))\n     }\n \n+    fn init_value(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        let ty = self.monomorphize(ty, self.substs());\n+        let layout = self.layout_of(ty)?;\n+        Ok(match layout.abi {\n+            layout::Abi::Scalar(..) => Value::Scalar(ScalarMaybeUndef::Undef),\n+            layout::Abi::ScalarPair(..) => Value::ScalarPair(\n+                ScalarMaybeUndef::Undef,\n+                ScalarMaybeUndef::Undef,\n+            ),\n+            _ => Value::ByRef(self.alloc_ptr(layout)?.into(), layout.align),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n     fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n         match self.locals[local] {\n-            None => err!(DeadLocal),\n-            Some(ref mut local) => {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref mut local) => {\n                 *local = value;\n                 Ok(())\n             }\n         }\n     }\n \n-    pub fn storage_live(&mut self, local: mir::Local) -> Option<Value> {\n-        trace!(\"{:?} is now live\", local);\n-\n-        // StorageLive *always* kills the value that's currently stored\n-        mem::replace(&mut self.locals[local], Some(Value::Scalar(Scalar::undef())))\n-    }\n-\n     /// Returns the old value of the local\n-    pub fn storage_dead(&mut self, local: mir::Local) -> Option<Value> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n         trace!(\"{:?} is now dead\", local);\n \n-        self.locals[local].take()\n+        mem::replace(&mut self.locals[local], LocalValue::Dead)\n     }\n }"}, {"sha": "b62add8a559b41b3d9dc152f5327416e1190ae7e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::Instance;\n use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value, ScalarMaybeUndef,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n@@ -272,10 +272,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 (ptr.offset.bytes(), alloc.align)\n             }\n-            Scalar::Bits { bits, defined } => {\n-                if (defined as u64) < self.pointer_size().bits() {\n-                    return err!(ReadUndefBytes);\n-                }\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, self.pointer_size().bytes());\n                 // FIXME: what on earth does this line do? docs or fix needed!\n                 let v = ((bits as u128) % (1 << self.pointer_size().bytes())) as u64;\n                 if v == 0 {\n@@ -756,15 +754,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, Scalar> {\n+    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n             // this inflates undefined bytes to the entire scalar, even if only a few bytes are undefined\n-            return Ok(Scalar::undef().into());\n+            return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n         let bits = read_target_uint(endianness, bytes).unwrap();\n@@ -776,44 +774,60 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into()),\n+                Some(&alloc_id) => return Ok(ScalarMaybeUndef::Scalar(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into())),\n                 None => {},\n             }\n         }\n         // We don't. Just return the bits.\n-        Ok(Scalar::Bits {\n+        Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n             bits,\n-            defined: size.bits() as u8,\n-        })\n+            size: size.bytes() as u8,\n+        }))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n+    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_scalar(&mut self, ptr: Scalar, ptr_align: Align, val: Scalar, size: Size, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_scalar(\n+        &mut self,\n+        ptr: Scalar,\n+        ptr_align: Align,\n+        val: ScalarMaybeUndef,\n+        type_size: Size,\n+        type_align: Align,\n+        signed: bool,\n+    ) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n+        self.check_align(ptr, ptr_align)?;\n+\n+        let val = match val {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n+        };\n \n         let bytes = match val {\n             Scalar::Ptr(val) => {\n-                assert_eq!(size, self.pointer_size());\n+                assert_eq!(type_size, self.pointer_size());\n                 val.offset.bytes() as u128\n             }\n \n-            Scalar::Bits { bits, defined } if defined as u64 >= size.bits() && size.bits() != 0 => bits,\n-\n-            Scalar::Bits { .. } => {\n-                self.check_align(ptr.into(), ptr_align)?;\n-                self.mark_definedness(ptr, size, false)?;\n+            Scalar::Bits { size: 0, .. } => {\n+                // nothing to do for ZSTs\n+                assert_eq!(type_size.bytes(), 0);\n                 return Ok(());\n             }\n+\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, type_size.bytes());\n+                bits\n+            },\n         };\n \n         let ptr = ptr.to_ptr()?;\n \n         {\n-            let align = self.int_align(size);\n-            let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n+            let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n             if signed {\n                 write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n@@ -835,9 +849,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: Scalar) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, false)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align, false)\n     }\n \n     fn int_align(&self, size: Size) -> Align {\n@@ -984,7 +998,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n         Ok(match value {\n             Value::ByRef(ptr, align) => {\n                 self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n@@ -997,40 +1011,40 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr_vtable_pair(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Scalar, Pointer)> {\n+    ) -> EvalResult<'tcx, (ScalarMaybeUndef, Pointer)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let vtable = mem.read_ptr_sized(\n                     ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.to_ptr()?;\n+                )?.unwrap_or_err()?.to_ptr()?;\n                 Ok((ptr, vtable))\n             }\n \n-            Value::ScalarPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n+            Value::ScalarPair(ptr, vtable) => Ok((ptr, vtable.unwrap_or_err()?.to_ptr()?)),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n \n     fn into_slice(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Scalar, u64)> {\n+    ) -> EvalResult<'tcx, (ScalarMaybeUndef, u64)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let len = mem.read_ptr_sized(\n                     ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.to_bits(mem.pointer_size())? as u64;\n+                )?.unwrap_or_err()?.to_bits(mem.pointer_size())? as u64;\n                 Ok((ptr, len))\n             }\n             Value::ScalarPair(ptr, val) => {\n-                let len = val.to_bits(self.memory().pointer_size())?;\n-                Ok((ptr.into(), len as u64))\n+                let len = val.unwrap_or_err()?.to_bits(self.memory().pointer_size())?;\n+                Ok((ptr, len as u64))\n             }\n             Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n         }"}, {"sha": "bc77f6e29d271dd61d7b21585f9c7b3ce75466da", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -11,8 +11,10 @@ mod step;\n mod terminator;\n mod traits;\n \n-pub use self::eval_context::{EvalContext, Frame, StackPopCleanup,\n-                             TyAndPacked, ValTy};\n+pub use self::eval_context::{\n+    EvalContext, Frame, StackPopCleanup,\n+    TyAndPacked, ValTy,\n+};\n \n pub use self::place::{Place, PlaceExtra};\n \n@@ -34,26 +36,21 @@ pub use self::machine::Machine;\n \n pub use self::memory::{write_target_uint, write_target_int, read_target_uint};\n \n-use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n-use rustc::ty::{Ty, TyCtxt, ParamEnv};\n+use rustc::ty::layout::TyLayout;\n \n-pub fn sign_extend<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n-    let param_env = ParamEnv::empty();\n-    let layout = tcx.layout_of(param_env.and(ty)).map_err(|layout| EvalErrorKind::Layout(layout))?;\n+pub fn sign_extend(value: u128, layout: TyLayout<'_>) -> u128 {\n     let size = layout.size.bits();\n     assert!(layout.abi.is_signed());\n     // sign extend\n     let shift = 128 - size;\n     // shift the unsigned value to the left\n     // and back to the right as signed (essentially fills with FF on the left)\n-    Ok((((value << shift) as i128) >> shift) as u128)\n+    (((value << shift) as i128) >> shift) as u128\n }\n \n-pub fn truncate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n-    let param_env = ParamEnv::empty();\n-    let layout = tcx.layout_of(param_env.and(ty)).map_err(|layout| EvalErrorKind::Layout(layout))?;\n+pub fn truncate(value: u128, layout: TyLayout<'_>) -> u128 {\n     let size = layout.size.bits();\n     let shift = 128 - size;\n     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n-    Ok((value << shift) >> shift)\n+    (value << shift) >> shift\n }"}, {"sha": "732c85bd0147a18ab56342c2bef097a5c10d8999", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1,7 +1,7 @@\n use rustc::mir;\n use rustc::ty::{self, Ty, layout};\n use syntax::ast::FloatTy;\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n \n@@ -11,7 +11,7 @@ use rustc::mir::interpret::{EvalResult, Scalar, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n-        &mut self,\n+        &self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ScalarPair(val, Scalar::from_bool(overflowed));\n+        let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         let valty = ValTy {\n             value: val,\n             ty: dest_ty,\n@@ -97,13 +97,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             let signed = left_layout.abi.is_signed();\n             let mut oflo = (r as u32 as u128) != r;\n             let mut r = r as u32;\n-            let size = left_layout.size.bits() as u32;\n-            oflo |= r >= size;\n+            let size = left_layout.size;\n+            oflo |= r >= size.bits() as u32;\n             if oflo {\n-                r %= size;\n+                r %= size.bits() as u32;\n             }\n             let result = if signed {\n-                let l = self.sign_extend(l, left_ty)? as i128;\n+                let l = self.sign_extend(l, left_layout) as i128;\n                 let result = match bin_op {\n                     Shl => l << r,\n                     Shr => l >> r,\n@@ -117,10 +117,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     _ => bug!(\"it has already been checked that this is a shift op\"),\n                 }\n             };\n-            let truncated = self.truncate(result, left_ty)?;\n+            let truncated = self.truncate(result, left_layout);\n             return Ok((Scalar::Bits {\n                 bits: truncated,\n-                defined: size as u8,\n+                size: size.bytes() as u8,\n             }, oflo));\n         }\n \n@@ -145,8 +145,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 _ => None,\n             };\n             if let Some(op) = op {\n-                let l = self.sign_extend(l, left_ty)? as i128;\n-                let r = self.sign_extend(r, right_ty)? as i128;\n+                let l = self.sign_extend(l, left_layout) as i128;\n+                let r = self.sign_extend(r, right_layout) as i128;\n                 return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n@@ -160,42 +160,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 _ => None,\n             };\n             if let Some(op) = op {\n-                let l128 = self.sign_extend(l, left_ty)? as i128;\n-                let r = self.sign_extend(r, right_ty)? as i128;\n-                let size = left_layout.size.bits();\n+                let l128 = self.sign_extend(l, left_layout) as i128;\n+                let r = self.sign_extend(r, right_layout) as i128;\n+                let size = left_layout.size;\n                 match bin_op {\n                     Rem | Div => {\n                         // int_min / -1\n-                        if r == -1 && l == (1 << (size - 1)) {\n-                            return Ok((Scalar::Bits { bits: l, defined: size as u8 }, true));\n+                        if r == -1 && l == (1 << (size.bits() - 1)) {\n+                            return Ok((Scalar::Bits { bits: l, size: size.bytes() as u8 }, true));\n                         }\n                     },\n                     _ => {},\n                 }\n                 trace!(\"{}, {}, {}\", l, l128, r);\n                 let (result, mut oflo) = op(l128, r);\n                 trace!(\"{}, {}\", result, oflo);\n-                if !oflo && size != 128 {\n-                    let max = 1 << (size - 1);\n+                if !oflo && size.bits() != 128 {\n+                    let max = 1 << (size.bits() - 1);\n                     oflo = result >= max || result < -max;\n                 }\n                 let result = result as u128;\n-                let truncated = self.truncate(result, left_ty)?;\n+                let truncated = self.truncate(result, left_layout);\n                 return Ok((Scalar::Bits {\n                     bits: truncated,\n-                    defined: size as u8,\n+                    size: size.bytes() as u8,\n                 }, oflo));\n             }\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n             macro_rules! float_math {\n-                ($ty:path, $bitsize:expr) => {{\n+                ($ty:path, $size:expr) => {{\n                     let l = <$ty>::from_bits(l);\n                     let r = <$ty>::from_bits(r);\n                     let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n                         bits: res.value.to_bits(),\n-                        defined: $bitsize,\n+                        size: $size,\n                     };\n                     let val = match bin_op {\n                         Eq => Scalar::from_bool(l == r),\n@@ -215,12 +215,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }};\n             }\n             match fty {\n-                FloatTy::F32 => float_math!(Single, 32),\n-                FloatTy::F64 => float_math!(Double, 64),\n+                FloatTy::F32 => float_math!(Single, 4),\n+                FloatTy::F64 => float_math!(Double, 8),\n             }\n         }\n \n-        let bit_width = self.layout_of(left_ty).unwrap().size.bits() as u8;\n+        let size = self.layout_of(left_ty).unwrap().size.bytes() as u8;\n \n         // only ints left\n         let val = match bin_op {\n@@ -232,9 +232,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Gt => Scalar::from_bool(l > r),\n             Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => Scalar::Bits { bits: l | r, defined: bit_width },\n-            BitAnd => Scalar::Bits { bits: l & r, defined: bit_width },\n-            BitXor => Scalar::Bits { bits: l ^ r, defined: bit_width },\n+            BitOr => Scalar::Bits { bits: l | r, size },\n+            BitAnd => Scalar::Bits { bits: l & r, size },\n+            BitXor => Scalar::Bits { bits: l ^ r, size },\n \n             Add | Sub | Mul | Rem | Div => {\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n@@ -248,10 +248,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     _ => bug!(),\n                 };\n                 let (result, oflo) = op(l, r);\n-                let truncated = self.truncate(result, left_ty)?;\n+                let truncated = self.truncate(result, left_layout);\n                 return Ok((Scalar::Bits {\n                     bits: truncated,\n-                    defined: bit_width,\n+                    size,\n                 }, oflo || truncated != result));\n             }\n \n@@ -275,17 +275,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         un_op: mir::UnOp,\n         val: Scalar,\n-        ty: Ty<'tcx>,\n+        layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Scalar> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n-        let size = self.layout_of(ty)?.size;\n+        let size = layout.size;\n         let bytes = val.to_bits(size)?;\n-        let size = size.bits();\n \n-        let result_bytes = match (un_op, &ty.sty) {\n+        let result_bytes = match (un_op, &layout.ty.sty) {\n \n             (Not, ty::TyBool) => !val.to_bool()? as u128,\n \n@@ -294,13 +293,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n             (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n-            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowNeg),\n+            (Neg, _) if bytes == (1 << (size.bits() - 1)) => return err!(OverflowNeg),\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n \n         Ok(Scalar::Bits {\n-            bits: self.truncate(result_bytes, ty)?,\n-            defined: size as u8,\n+            bits: self.truncate(result_bytes, layout),\n+            size: size.bytes() as u8,\n         })\n     }\n }"}, {"sha": "91c2519230695a08c8b621c53b387029312a417e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer};\n+use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer, ScalarMaybeUndef};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -14,7 +14,7 @@ pub enum Place {\n         /// A place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: Scalar,\n+        ptr: ScalarMaybeUndef,\n         align: Align,\n         extra: PlaceExtra,\n     },\n@@ -35,10 +35,10 @@ pub enum PlaceExtra {\n impl<'tcx> Place {\n     /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_scalar_ptr(Scalar::undef().into(), Align::from_bytes(1, 1).unwrap())\n+        Self::from_scalar_ptr(ScalarMaybeUndef::Undef, Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: ScalarMaybeUndef, align: Align) -> Self {\n         Place::Ptr {\n             ptr,\n             align,\n@@ -47,26 +47,26 @@ impl<'tcx> Place {\n     }\n \n     pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n-        Self::from_scalar_ptr(ptr.into(), align)\n+        Self::from_scalar_ptr(ScalarMaybeUndef::Scalar(ptr.into()), align)\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (Scalar, Align, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (ScalarMaybeUndef, Align, PlaceExtra) {\n         match self {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> (Scalar, Align) {\n+    pub fn to_ptr_align(self) -> (ScalarMaybeUndef, Align) {\n         let (ptr, align, _extra) = self.to_ptr_align_extra();\n         (ptr, align)\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n-        self.to_ptr_align().0.to_ptr()\n+        self.to_ptr_align().0.unwrap_or_err()?.to_ptr()\n     }\n \n     pub(super) fn elem_ty_and_len(\n@@ -106,7 +106,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // Might allow this in the future, right now there's no way to do this from Rust code anyway\n             Local(mir::RETURN_PLACE) => err!(ReadFromReturnPointer),\n             // Directly reading a local will always succeed\n-            Local(local) => self.frame().get_local(local).map(Some),\n+            Local(local) => self.frame().locals[local].access().map(Some),\n             // No fast path for statics. Reading from statics is rare and would require another\n             // Machine function to handle differently in miri.\n             Promoted(_) |\n@@ -129,7 +129,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n             return Ok((\n-                Value::Scalar(Scalar::undef()),\n+                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 })),\n                 field,\n             ));\n         }\n@@ -197,9 +197,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match place {\n             Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr, align))\n+                Ok(Value::ByRef(ptr.unwrap_or_err()?, align))\n             }\n-            Place::Local { frame, local } => self.stack[frame].get_local(local),\n+            Place::Local { frame, local } => self.stack[frame].locals[local].access(),\n         }\n     }\n \n@@ -220,7 +220,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 })?;\n                 if let Value::ByRef(ptr, align) = val {\n                     Place::Ptr {\n-                        ptr,\n+                        ptr: ptr.into(),\n                         align,\n                         extra: PlaceExtra::None,\n                     }\n@@ -238,7 +238,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n                 Place::Ptr {\n-                    ptr: Scalar::Ptr(alloc.into()),\n+                    ptr: ScalarMaybeUndef::Scalar(Scalar::Ptr(alloc.into())),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }\n@@ -276,14 +276,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (base_ptr, base_align, base_extra) = match base {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             Place::Local { frame, local } => {\n-                match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n+                match (self.stack[frame].locals[local].access()?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n-                    (&Value::Scalar(_), &layout::Abi::Scalar(_)) |\n-                    (&Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n-                        if offset.bytes() == 0 && field.size == base_layout.size =>\n-                    {\n-                        return Ok((base, field));\n-                    }\n+                    (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n+                    (Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n+                    if offset.bytes() == 0 && field.size == base_layout.size => {\n+                        return Ok((base, field))\n+                    },\n                     _ => self.force_allocation(base)?.to_ptr_align_extra(),\n                 }\n             }\n@@ -413,7 +412,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n \n             Index(local) => {\n-                let value = self.frame().get_local(local)?;\n+                let value = self.frame().locals[local].access()?;\n                 let ty = self.tcx.types.usize;\n                 let n = self\n                     .value_to_scalar(ValTy { value, ty })?"}, {"sha": "57b56db14bb4b719e00a19560a35120108d78211", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.frame_mut().storage_live(local);\n+                let old_val = self.storage_live(local)?;\n                 self.deallocate_local(old_val)?;\n             }\n "}, {"sha": "fe8071897c34874bd2b4ecc7178f6f3bd08af670", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -2,7 +2,7 @@ use rustc::mir::BasicBlock;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n+use rustc::mir::interpret::{EvalResult, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -33,7 +33,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ptr,\n                 align: _,\n                 extra: PlaceExtra::None,\n-            } => ptr.to_value(),\n+            } => Value::Scalar(ptr),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span, target)\n@@ -51,17 +51,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n-                let vtable = match arg {\n-                    Value::ScalarPair(_, Scalar::Ptr(vtable)) => vtable,\n-                    _ => bug!(\"expected fat ptr, got {:?}\", arg),\n-                };\n-                match self.read_drop_type_from_vtable(vtable)? {\n-                    Some(func) => func,\n-                    // no drop fn -> bail out\n-                    None => {\n-                        self.goto_block(target);\n-                        return Ok(())\n-                    },\n+                if let Value::ScalarPair(_, vtable) = arg {\n+                    self.read_drop_type_from_vtable(vtable.unwrap_or_err()?.to_ptr()?)?\n+                } else {\n+                    bug!(\"expected fat ptr, got {:?}\", arg);\n                 }\n             }\n             _ => instance,"}, {"sha": "682e384da3936eb6caae8af7039e019d40805556", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::{LayoutOf, Size};\n use syntax::codemap::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -47,7 +47,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits { bits: const_int, defined: 128 };\n+                    let const_int = Scalar::Bits { bits: const_int, size: discr_layout.size.bytes() as u8 };\n                     let res = self.binary_op(mir::BinOp::Eq,\n                         discr_prim, discr_val.ty,\n                         const_int, discr_val.ty\n@@ -392,12 +392,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n-                )?.to_ptr()?;\n+                )?.unwrap_or_err()?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n                 args[0].ty = ty;\n-                args[0].value = ptr.to_value();\n+                args[0].value = Value::Scalar(ptr);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, destination, &args, span, sig)\n             }"}, {"sha": "84583680988b7c093c368eeb93cfd8d3c2aad59e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Value, Pointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Pointer, EvalResult};\n \n use syntax::ast::Mutability;\n \n@@ -36,25 +36,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n         self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n             bits: size as u128,\n-            defined: ptr_size.bits() as u8,\n-        })?;\n+            size: ptr_size.bytes() as u8,\n+        }.into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n         self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n             bits: align as u128,\n-            defined: ptr_size.bits() as u8,\n-        })?;\n+            size: ptr_size.bytes() as u8,\n+        }.into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n \n@@ -69,16 +69,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Pointer,\n-    ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n+    ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let pointer_size = self.tcx.data_layout.pointer_size.bits() as u8;\n-        match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n-            // some values don't need to call a drop impl, so the value is null\n-            Value::Scalar(Scalar::Bits { bits: 0, defined} ) if defined == pointer_size => Ok(None),\n-            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n-            _ => err!(ReadBytesAsPointer),\n-        }\n+        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.unwrap_or_err()?.to_ptr()?;\n+        self.memory.get_fn(drop_fn)\n     }\n \n     pub fn read_size_and_align_from_vtable(\n@@ -87,11 +82,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.to_bits(pointer_size)? as u64;\n+        )?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "97f1f2a76ca2b71ef2b346aafa812604ecdd5ed5", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -193,7 +193,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{AllocId, ConstValue};\n+use rustc::mir::interpret::{AllocId, ConstValue, ScalarMaybeUndef};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n@@ -1264,11 +1264,11 @@ fn collect_const<'a, 'tcx>(\n     };\n     match val {\n         ConstValue::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n-        ConstValue::ScalarPair(Scalar::Ptr(a), Scalar::Ptr(b)) => {\n+        ConstValue::ScalarPair(Scalar::Ptr(a), ScalarMaybeUndef::Scalar(Scalar::Ptr(b))) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);\n         }\n-        ConstValue::ScalarPair(_, Scalar::Ptr(ptr)) |\n+        ConstValue::ScalarPair(_, ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr))) |\n         ConstValue::ScalarPair(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),"}, {"sha": "05e51c5430d7fe5aafd0f4b9741974e09722dc70", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext};\n-use rustc::mir::interpret::{ConstEvalErr, EvalErrorKind};\n+use rustc::mir::interpret::{ConstEvalErr, EvalErrorKind, ScalarMaybeUndef};\n use rustc::ty::{TyCtxt, self, Instance};\n use rustc::mir::interpret::{Value, Scalar, GlobalId, EvalResult};\n use interpret::EvalContext;\n@@ -368,8 +368,8 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n                     Value::Scalar(Scalar::Bits {\n                         bits: n as u128,\n-                        defined: self.tcx.data_layout.pointer_size.bits() as u8,\n-                    }),\n+                        size: self.tcx.data_layout.pointer_size.bytes() as u8,\n+                    }.into()),\n                     self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     span,\n                 )))\n@@ -390,8 +390,8 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 let prim = self.use_ecx(source_info, |this| {\n                     this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1.ty })\n                 })?;\n-                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1.ty))?;\n-                Some((Value::Scalar(val), place_layout, span))\n+                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1))?;\n+                Some((Value::Scalar(val.into()), place_layout, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -449,16 +449,16 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n-                        val,\n-                        Scalar::from_bool(overflow),\n+                        val.into(),\n+                        Scalar::from_bool(overflow).into(),\n                     )\n                 } else {\n                     if overflow {\n                         let err = EvalErrorKind::Overflow(op).into();\n                         let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n                         return None;\n                     }\n-                    Value::Scalar(val)\n+                    Value::Scalar(val.into())\n                 };\n                 Some((val, place_layout, span))\n             },\n@@ -576,7 +576,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::Scalar(Scalar::from_bool(*expected)) != value.0 {\n+                if Value::Scalar(Scalar::from_bool(*expected).into()) != value.0 {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -613,14 +613,18 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n                             let len = match len.0 {\n-                                Value::Scalar(Scalar::Bits { bits, ..}) => bits,\n+                                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                    bits, ..\n+                                })) => bits,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n                             };\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n                             let index = match index.0 {\n-                                Value::Scalar(Scalar::Bits { bits, .. }) => bits,\n+                                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                    bits, ..\n+                                })) => bits,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),\n                             };\n                             format!("}, {"sha": "10376d5780908d6ed1f16050b09d2823450f10f8", "filename": "src/test/compile-fail/const-err4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -16,7 +16,7 @@ union Foo {\n \n enum Bar {\n     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-    //~^ ERROR constant evaluation of enum discriminant resulted in non-integer\n+    //~^ ERROR could not evaluate enum discriminant\n }\n \n fn main() {"}, {"sha": "d18059fafd5ff16c2abd03826a2655992bfdb315", "filename": "src/test/ui/const-eval/simple_with_undef.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Fsimple_with_undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Fsimple_with_undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fsimple_with_undef.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+const PARSE_BOOL: Option<&'static str> = None;\n+static FOO: (Option<&str>, u32) = (PARSE_BOOL, 42);\n+\n+fn main() {}"}, {"sha": "5723f4a4159aa5170a8020efe2404afd09398fd8", "filename": "src/test/ui/const-eval/union-const-eval-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -34,7 +34,7 @@ const fn read_field2() -> Field2 {\n }\n \n const fn read_field3() -> Field3 {\n-    const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR exhibits undefined behavior\n+    const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR cannot be used\n     FIELD3\n }\n "}, {"sha": "811450c8cba4757afc3b52765633e357a00aec7c", "filename": "src/test/ui/const-eval/union-const-eval-field.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1,11 +1,10 @@\n-error[E0080]: this constant likely exhibits undefined behavior\n+error: this constant cannot be used\n   --> $DIR/union-const-eval-field.rs:37:5\n    |\n-LL |     const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR exhibits undefined behavior\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined bytes\n+LL |     const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR cannot be used\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   = note: #[deny(const_err)] on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "0cdb78c97803c7f80cf3ef89614173154971812f", "filename": "src/test/ui/const-eval/union-ice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -20,9 +20,9 @@ union DummyUnion {\n \n const UNION: DummyUnion = DummyUnion { field1: 1065353216 };\n \n-const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant likely exhibits undefined\n+const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant cannot be used\n \n-const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibits undefined behavior\n+const FIELD_PATH: Struct = Struct { //~ ERROR this constant cannot be used\n     a: 42,\n     b: unsafe { UNION.field3 },\n };"}, {"sha": "e8a7b2f500561e31cbee5926bd8b7d8893e1d003", "filename": "src/test/ui/const-eval/union-ice.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59fa6bd6c14eebd213884da08a33639b4c848bb3/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr?ref=59fa6bd6c14eebd213884da08a33639b4c848bb3", "patch": "@@ -1,21 +1,19 @@\n-error[E0080]: this constant likely exhibits undefined behavior\n+error: this constant cannot be used\n   --> $DIR/union-ice.rs:23:1\n    |\n-LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant likely exhibits undefined\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined bytes\n+LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant cannot be used\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   = note: #[deny(const_err)] on by default\n \n-error[E0080]: this constant likely exhibits undefined behavior\n+error: this constant cannot be used\n   --> $DIR/union-ice.rs:25:1\n    |\n-LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibits undefined behavior\n+LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant cannot be used\n LL | |     a: 42,\n LL | |     b: unsafe { UNION.field3 },\n LL | | };\n-   | |__^ type validation failed: encountered undefined bytes at .b\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   | |__^ attempted to read undefined bytes\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ice.rs:35:1"}]}