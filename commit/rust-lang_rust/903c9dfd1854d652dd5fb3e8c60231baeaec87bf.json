{"sha": "903c9dfd1854d652dd5fb3e8c60231baeaec87bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwM2M5ZGZkMTg1NGQ2NTJkZDVmYjNlOGM2MDIzMWJhZWFlYzg3YmY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T08:04:36Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:41:28Z"}, "message": "extract should_continue_as_assoc_expr", "tree": {"sha": "dd625a0f5d1a9a47e5a0eeef30f4fdc932b27474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd625a0f5d1a9a47e5a0eeef30f4fdc932b27474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/903c9dfd1854d652dd5fb3e8c60231baeaec87bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/903c9dfd1854d652dd5fb3e8c60231baeaec87bf", "html_url": "https://github.com/rust-lang/rust/commit/903c9dfd1854d652dd5fb3e8c60231baeaec87bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/903c9dfd1854d652dd5fb3e8c60231baeaec87bf/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be463cbc2b3470717df4dd3f698c98f495b19033", "url": "https://api.github.com/repos/rust-lang/rust/commits/be463cbc2b3470717df4dd3f698c98f495b19033", "html_url": "https://github.com/rust-lang/rust/commit/be463cbc2b3470717df4dd3f698c98f495b19033"}], "stats": {"total": 100, "additions": 55, "deletions": 45}, "files": [{"sha": "f20d0aa2236376acdfecd01685fe9c9f2ef87306", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/903c9dfd1854d652dd5fb3e8c60231baeaec87bf/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/903c9dfd1854d652dd5fb3e8c60231baeaec87bf/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=903c9dfd1854d652dd5fb3e8c60231baeaec87bf", "patch": "@@ -155,53 +155,13 @@ impl<'a> Parser<'a> {\n         };\n         let last_type_ascription_set = self.last_type_ascription.is_some();\n \n-        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n-            (true, None) => {\n-                self.last_type_ascription = None;\n-                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n-                return Ok(lhs);\n-            }\n-            (false, _) => {} // continue parsing the expression\n-            // An exhaustive check is done in the following block, but these are checked first\n-            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n-            // want to keep their span info to improve diagnostics in these cases in a later stage.\n-            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n-            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n-            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n-            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n-            // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n-                self.last_type_ascription = None;\n-                // These cases are ambiguous and can't be identified in the parser alone\n-                let sp = self.sess.source_map().start_point(self.token.span);\n-                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n-                return Ok(lhs);\n-            }\n-            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n-                self.last_type_ascription = None;\n-                return Ok(lhs);\n-            }\n-            (true, Some(_)) => {\n-                // We've found an expression that would be parsed as a statement, but the next\n-                // token implies this should be parsed as an expression.\n-                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.struct_span_err(self.token.span, &format!(\n-                    \"expected expression, found `{}`\",\n-                    pprust::token_to_string(&self.token),\n-                ));\n-                err.span_label(self.token.span, \"expected expression\");\n-                self.sess.expr_parentheses_needed(\n-                    &mut err,\n-                    lhs.span,\n-                    Some(pprust::expr_to_string(&lhs),\n-                ));\n-                err.emit();\n-            }\n+        if !self.should_continue_as_assoc_expr(&lhs) {\n+            self.last_type_ascription = None;\n+            return Ok(lhs);\n         }\n-        self.expected_tokens.push(TokenType::Operator);\n-        while let Some(op) = AssocOp::from_token(&self.token) {\n \n+        self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n             // it refers to. Interpolated identifiers are unwrapped early and never show up here\n             // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n@@ -338,6 +298,56 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n+    fn should_continue_as_assoc_expr(&mut self, lhs: &Expr) -> bool {\n+        match (self.expr_is_complete(lhs), self.check_assoc_op()) {\n+            // Semi-statement forms are odd:\n+            // See https://github.com/rust-lang/rust/issues/29071\n+            (true, None) => false,\n+            (false, _) => true, // Continue parsing the expression.\n+            // An exhaustive check is done in the following block, but these are checked first\n+            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n+            // want to keep their span info to improve diagnostics in these cases in a later stage.\n+            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n+            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n+            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n+            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n+            // `if x { a } else { b } && if y { c } else { d }`\n+            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n+                // These cases are ambiguous and can't be identified in the parser alone.\n+                let sp = self.sess.source_map().start_point(self.token.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                false\n+            }\n+            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => false,\n+            (true, Some(_)) => {\n+                self.error_found_expr_would_be_stmt(lhs);\n+                true\n+            }\n+        }\n+    }\n+\n+    /// We've found an expression that would be parsed as a statement,\n+    /// but the next token implies this should be parsed as an expression.\n+    /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n+    fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n+        let mut err = self.struct_span_err(self.token.span, &format!(\n+            \"expected expression, found `{}`\",\n+            pprust::token_to_string(&self.token),\n+        ));\n+        err.span_label(self.token.span, \"expected expression\");\n+        self.sess.expr_parentheses_needed(&mut err, lhs.span, Some(pprust::expr_to_string(&lhs)));\n+        err.emit();\n+    }\n+\n+    /// Possibly translate the current token to an associative operator.\n+    /// The method does not advance the current token.\n+    ///\n+    /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n+    fn check_assoc_op(&self) -> Option<AssocOp> {\n+        AssocOp::from_token(&self.token)\n+    }\n+\n     /// Checks if this expression is a successfully parsed statement.\n     fn expr_is_complete(&self, e: &Expr) -> bool {\n         self.restrictions.contains(Restrictions::STMT_EXPR) &&"}]}