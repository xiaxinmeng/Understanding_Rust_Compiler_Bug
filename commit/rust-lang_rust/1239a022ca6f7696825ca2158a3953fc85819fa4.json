{"sha": "1239a022ca6f7696825ca2158a3953fc85819fa4", "node_id": "C_kwDOAAsO6NoAKDEyMzlhMDIyY2E2Zjc2OTY4MjVjYTIxNThhMzk1M2ZjODU4MTlmYTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T14:00:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T14:00:53Z"}, "message": "Auto merge of #100999 - nnethercote:shrink-FnAbi, r=bjorn3\n\nShrink `FnAbi`\n\nBecause they can take up a lot of memory in debug and release builds.\n\nr? `@bjorn3`", "tree": {"sha": "c8d75cff1cd8e11765f3bad05ea8e20180b94d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8d75cff1cd8e11765f3bad05ea8e20180b94d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1239a022ca6f7696825ca2158a3953fc85819fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1239a022ca6f7696825ca2158a3953fc85819fa4", "html_url": "https://github.com/rust-lang/rust/commit/1239a022ca6f7696825ca2158a3953fc85819fa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1239a022ca6f7696825ca2158a3953fc85819fa4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9bbac069b1c8f235bcf2415a47b783fb945b4a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9bbac069b1c8f235bcf2415a47b783fb945b4a7", "html_url": "https://github.com/rust-lang/rust/commit/d9bbac069b1c8f235bcf2415a47b783fb945b4a7"}, {"sha": "2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2a3be651db8da69c391e0bdfe0189fe1d504d5", "html_url": "https://github.com/rust-lang/rust/commit/2d2a3be651db8da69c391e0bdfe0189fe1d504d5"}], "stats": {"total": 35, "additions": 21, "deletions": 14}, "files": [{"sha": "7f4619b5c940b12f3701ca2aebba46e92808a163", "filename": "src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=1239a022ca6f7696825ca2158a3953fc85819fa4", "patch": "@@ -24,7 +24,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n-    arg_abi_mode: PassMode,\n+    arg_abi_mode: &PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n     if !fx.clif_comments.enabled() {"}, {"sha": "96e25d3a8d4c9423ba85eea5de2006e4db2a6cd4", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=1239a022ca6f7696825ca2158a3953fc85819fa4", "patch": "@@ -38,7 +38,7 @@ fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -\n     param\n }\n \n-fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+fn cast_target_to_abi_params(cast: &CastTarget) -> SmallVec<[AbiParam; 2]> {\n     let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n         (0, 0)\n     } else {\n@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Cast(ref cast, _) => {\n+                (None, cast_target_to_abi_params(cast).into_iter().collect())\n+            }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n                 (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n@@ -160,7 +165,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n pub(super) fn to_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> SmallVec<[Value; 2]> {\n     let (ptr, meta) = arg.force_stack(fx);\n     assert!(meta.is_none());\n@@ -179,7 +184,7 @@ pub(super) fn from_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n@@ -224,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -268,7 +273,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         &block_params,\n-        arg_abi.mode,\n+        &arg_abi.mode,\n         arg_abi.layout,\n     );\n \n@@ -282,7 +287,9 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Cast(ref cast, _) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n             Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "src/abi/returning.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1239a022ca6f7696825ca2158a3953fc85819fa4/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=1239a022ca6f7696825ca2158a3953fc85819fa4", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -44,7 +44,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         &ret_param,\n-        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        &fx.fn_abi.as_ref().unwrap().ret.mode,\n         fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}]}