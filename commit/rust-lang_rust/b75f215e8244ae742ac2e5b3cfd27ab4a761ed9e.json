{"sha": "b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NWYyMTVlODI0NGFlNzQyYWMyZTViM2NmZDI3YWI0YTc2MWVkOWU=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-07-13T08:49:13Z"}, "committer": {"name": "Jared Roesch", "email": "jroesch@MacBook.home", "date": "2015-07-26T02:57:58Z"}, "message": "Remove second transaction", "tree": {"sha": "d9687203c9fb69ef5e96aa33c63768a8fffbc93b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9687203c9fb69ef5e96aa33c63768a8fffbc93b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e", "html_url": "https://github.com/rust-lang/rust/commit/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee4392041073795f479365f34d40777eff69c378", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4392041073795f479365f34d40777eff69c378", "html_url": "https://github.com/rust-lang/rust/commit/ee4392041073795f479365f34d40777eff69c378"}], "stats": {"total": 124, "additions": 67, "deletions": 57}, "files": [{"sha": "42b28dcbc1b54584df0c523deced87be35b15411", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b75f215e8244ae742ac2e5b3cfd27ab4a761ed9e", "patch": "@@ -1784,43 +1784,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // variable would only be in `unbound_tyvars` and have a concrete value if\n             // it had been solved by previously applying a default.\n \n-            // We take a snapshot for use in error reporting.\n-            let snapshot = self.infcx().start_snapshot();\n-\n-            for ty in &unbound_tyvars {\n-                if self.infcx().type_var_diverges(ty) {\n-                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n-                } else {\n-                    match self.infcx().type_is_unconstrained_numeric(ty) {\n-                        UnconstrainedInt => {\n-                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n-                        },\n-                        UnconstrainedFloat => {\n-                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n-                        }\n-                        Neither => {\n-                            if let Some(default) = default_map.get(ty) {\n-                                let default = default.clone();\n-                                match infer::mk_eqty(self.infcx(), false,\n-                                                     infer::Misc(default.origin_span),\n-                                                     ty, default.ty) {\n-                                    Ok(()) => {}\n-                                    Err(_) => {\n-                                        conflicts.push((*ty, default));\n+            // We wrap this in a transaction for error reporting, if we detect a conflict\n+            // we will rollback the inference context to its prior state so we can probe\n+            // for conflicts and correctly report them.\n+            let _ = self.infcx().commit_if_ok(|_: &infer::CombinedSnapshot| {\n+                for ty in &unbound_tyvars {\n+                    if self.infcx().type_var_diverges(ty) {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                    } else {\n+                        match self.infcx().type_is_unconstrained_numeric(ty) {\n+                            UnconstrainedInt => {\n+                                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                            },\n+                            UnconstrainedFloat => {\n+                                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                            }\n+                            Neither => {\n+                                if let Some(default) = default_map.get(ty) {\n+                                    let default = default.clone();\n+                                    match infer::mk_eqty(self.infcx(), false,\n+                                                         infer::Misc(default.origin_span),\n+                                                         ty, default.ty) {\n+                                        Ok(()) => {}\n+                                        Err(_) => {\n+                                            conflicts.push((*ty, default));\n+                                        }\n                                     }\n                                 }\n                             }\n                         }\n                     }\n                 }\n-            }\n \n-            // There are some errors to report\n-            if conflicts.len() > 0 {\n-                self.infcx().rollback_to(snapshot);\n+                // If there are conflicts we rollback, otherwise commit\n+                if conflicts.len() > 0 {\n+                    Err(())\n+                } else {\n+                    Ok(())\n+                }\n+            });\n \n-                // Loop through each conflicting default compute the conflict\n-                // and then report the error.\n+            if conflicts.len() > 0 {\n+                // Loop through each conflicting default, figuring out the default that caused\n+                // a unification failure and then report an error for each.\n                 for (conflict, default) in conflicts {\n                     let conflicting_default =\n                         self.find_conflicting_default(\n@@ -1832,13 +1838,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 definition_span: codemap::DUMMY_SP\n                             });\n \n-                            self.infcx().report_conflicting_default_types(\n-                                conflicting_default.origin_span,\n-                                conflicting_default,\n-                                default)\n+                    self.infcx().report_conflicting_default_types(\n+                        conflicting_default.origin_span,\n+                        conflicting_default,\n+                        default)\n                 }\n-            } else {\n-                self.infcx().commit_from(snapshot)\n             }\n         }\n \n@@ -1856,41 +1860,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 -> Option<type_variable::Default<'tcx>> {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n \n-        // Ensure that the conflicting default is applied first\n+        // Ensure that we apply the conflicting default first\n         let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n         unbound_tyvars.push(conflict);\n         unbound_tyvars.extend(unbound_vars.iter());\n \n         let mut result = None;\n         // We run the same code as above applying defaults in order, this time when\n         // we find the conflict we just return it for error reporting above.\n-        for ty in &unbound_tyvars {\n-            if self.infcx().type_var_diverges(ty) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n-            } else {\n-                match self.infcx().type_is_unconstrained_numeric(ty) {\n-                    UnconstrainedInt => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n-                    },\n-                    Neither => {\n-                        if let Some(default) = default_map.get(ty) {\n-                            let default = default.clone();\n-                            match infer::mk_eqty(self.infcx(), false,\n-                                                 infer::Misc(default.origin_span),\n-                                                 ty, default.ty) {\n-                                Ok(()) => {}\n-                                Err(_) => {\n-                                    result = Some(default);\n+\n+        // We also run this inside snapshot that never commits so we can do error\n+        // reporting for more then one conflict.\n+        //let _ = self.infcx().commit_if_ok(|_: &infer::CombinedSnapshot| {\n+            for ty in &unbound_tyvars {\n+                if self.infcx().type_var_diverges(ty) {\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                } else {\n+                    match self.infcx().type_is_unconstrained_numeric(ty) {\n+                        UnconstrainedInt => {\n+                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                        },\n+                        UnconstrainedFloat => {\n+                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                        },\n+                        Neither => {\n+                            if let Some(default) = default_map.get(ty) {\n+                                let default = default.clone();\n+                                match infer::mk_eqty(self.infcx(), false,\n+                                                     infer::Misc(default.origin_span),\n+                                                     ty, default.ty) {\n+                                    Ok(()) => {}\n+                                    Err(_) => {\n+                                        result = Some(default);\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n+            // let result: Result<(), ()> = Err(()); result\n+        //});\n \n         return result;\n     }"}]}