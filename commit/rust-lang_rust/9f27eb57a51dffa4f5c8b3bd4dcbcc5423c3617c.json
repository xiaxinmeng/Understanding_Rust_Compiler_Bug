{"sha": "9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c", "node_id": "C_kwDOAAsO6NoAKDlmMjdlYjU3YTUxZGZmYTRmNWM4YjNiZDRkY2JjYzU0MjNjMzYxN2M", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-26T12:39:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-05-01T17:57:08Z"}, "message": "Implement boolean aliases", "tree": {"sha": "af07d0b54ccc9d325fcdac9914f21b62ce32f96f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af07d0b54ccc9d325fcdac9914f21b62ce32f96f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c", "html_url": "https://github.com/rust-lang/rust/commit/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd18936d51c88e3f5452f6fe70bd137afbc0bd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd18936d51c88e3f5452f6fe70bd137afbc0bd88", "html_url": "https://github.com/rust-lang/rust/commit/bd18936d51c88e3f5452f6fe70bd137afbc0bd88"}], "stats": {"total": 121, "additions": 100, "deletions": 21}, "files": [{"sha": "413cb91af2a922e225955f9aa78ef8622be7d22c", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 100, "deletions": 21, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=9f27eb57a51dffa4f5c8b3bd4dcbcc5423c3617c", "patch": "@@ -39,10 +39,7 @@ use crate::{\n //  - Toggles (be it binary true/false or with more options in-between) should almost always suffix as `_enable`\n //  - In general be wary of using the namespace of something verbatim, it prevents us from adding subkeys in the future\n //  - Don't use abbreviations unless really necessary\n-//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting\n-//    - We could in theory only use `command` and have it change behavior depending on whether its a string or array?\n-// - TODO: conventions regarding config keys for commands and their args\n-// - TODO: conventions regarding config polarity\n+//  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command\n \n // Defines the server-side configuration of the rust-analyzer. We generate\n // *parts* of VS Code's `package.json` config from this.\n@@ -108,7 +105,7 @@ config_data! {\n         /// with `self` prefixed to them when inside a method.\n         completion_autoself_enable: bool        = \"true\",\n         /// Whether to add parenthesis and argument snippets when completing function.\n-        completion_callable_snippets: CallableCompletionDef  = \"fillArguments\",\n+        completion_callable_snippets: Option<CallableCompletionDef>  = \"\\\"fill_arguments\\\"\",\n         /// Whether to show postfix snippets like `dbg`, `if`, `not`, etc.\n         completion_postfix_enable: bool         = \"true\",\n         /// Enables completions of private items and fields that are defined in the current workspace even if they are not visible at the current position.\n@@ -217,13 +214,11 @@ config_data! {\n         /// Use markdown syntax for links in hover.\n         hover_links_enable: bool = \"true\",\n \n-        // TODO: this should be in granulatiry?\n         /// Whether to enforce the import granularity setting for all files. If set to false rust-analyzer will try to keep import styles consistent per file.\n         imports_enforceGranularity: bool              = \"false\",\n         /// How imports should be grouped into use statements.\n         imports_granularity: ImportGranularityDef  = \"\\\"crate\\\"\",\n         /// Group inserted imports by the https://rust-analyzer.github.io/manual.html#auto-import[following order]. Groups are separated by newlines.\n-        // TODO: Shouldn't be a bool\n         imports_group: bool                           = \"true\",\n         /// Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n         imports_mergeIntoGlob: bool           = \"true\",\n@@ -353,7 +348,6 @@ config_data! {\n \n         /// Show documentation.\n         signatureInfo_documentation_enable: bool                       = \"true\",\n-        // TODO: needs a better name\n         /// Show full signature of the callable. Only shows parameters if disabled.\n         signatureInfo_signature_enable: bool                           = \"true\",\n \n@@ -1007,11 +1001,11 @@ impl Config {\n             enable_private_editable: self.data.completion_privateEditable_enable,\n             add_call_parenthesis: matches!(\n                 self.data.completion_callable_snippets,\n-                CallableCompletionDef::AddParentheses\n+                Some(CallableCompletionDef::AddParentheses)\n             ),\n             add_call_argument_snippets: matches!(\n                 self.data.completion_callable_snippets,\n-                CallableCompletionDef::FillArguments\n+                Some(CallableCompletionDef::FillArguments)\n             ),\n             insert_use: self.insert_use_config(),\n             snippet_cap: SnippetCap::new(try_or_def!(\n@@ -1175,9 +1169,76 @@ impl Config {\n         }\n     }\n }\n-\n // Deserialization definitions\n \n+macro_rules! create_bool_or_string_de {\n+    ($ident:ident<$bool:literal, $string:literal>) => {\n+        fn $ident<'de, D>(d: D) -> Result<(), D::Error>\n+        where\n+            D: serde::Deserializer<'de>,\n+        {\n+            struct V;\n+            impl<'de> serde::de::Visitor<'de> for V {\n+                type Value = ();\n+\n+                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                    formatter.write_str(concat!(\n+                        stringify!($bool),\n+                        \" or \\\"\",\n+                        stringify!($string),\n+                        \"\\\"\"\n+                    ))\n+                }\n+\n+                fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n+                where\n+                    E: serde::de::Error,\n+                {\n+                    match v {\n+                        $bool => Ok(()),\n+                        _ => Err(serde::de::Error::invalid_value(\n+                            serde::de::Unexpected::Bool(v),\n+                            &self,\n+                        )),\n+                    }\n+                }\n+\n+                fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n+                where\n+                    E: serde::de::Error,\n+                {\n+                    match v {\n+                        $string => Ok(()),\n+                        _ => Err(serde::de::Error::invalid_value(\n+                            serde::de::Unexpected::Str(v),\n+                            &self,\n+                        )),\n+                    }\n+                }\n+\n+                fn visit_enum<A>(self, a: A) -> Result<Self::Value, A::Error>\n+                where\n+                    A: serde::de::EnumAccess<'de>,\n+                {\n+                    use serde::de::VariantAccess;\n+                    let (variant, va) = a.variant::<&'de str>()?;\n+                    va.unit_variant()?;\n+                    match variant {\n+                        $string => Ok(()),\n+                        _ => Err(serde::de::Error::invalid_value(\n+                            serde::de::Unexpected::Str(variant),\n+                            &self,\n+                        )),\n+                    }\n+                }\n+            }\n+            d.deserialize_any(V)\n+        }\n+    };\n+}\n+create_bool_or_string_de!(true_or_always<true, \"always\">);\n+create_bool_or_string_de!(false_or_never<false, \"never\">);\n+\n #[derive(Deserialize, Debug, Clone, Copy)]\n #[serde(rename_all = \"snake_case\")]\n enum SnippetScopeDef {\n@@ -1248,21 +1309,16 @@ enum ManifestOrProjectJson {\n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n pub enum ExprFillDefaultDef {\n-    #[serde(alias = \"todo\")]\n     Todo,\n-    #[serde(alias = \"default\")]\n     Default,\n }\n \n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n enum ImportGranularityDef {\n     Preserve,\n-    #[serde(alias = \"none\")]\n     Item,\n-    #[serde(alias = \"full\")]\n     Crate,\n-    #[serde(alias = \"last\")]\n     Module,\n }\n \n@@ -1271,8 +1327,6 @@ enum ImportGranularityDef {\n enum CallableCompletionDef {\n     FillArguments,\n     AddParentheses,\n-    #[serde(alias = \"false\")]\n-    None,\n }\n \n #[derive(Deserialize, Debug, Clone)]\n@@ -1285,10 +1339,11 @@ enum CargoFeatures {\n \n #[derive(Deserialize, Debug, Clone)]\n #[serde(rename_all = \"snake_case\")]\n+#[serde(untagged)]\n enum LifetimeElisionDef {\n-    #[serde(alias = \"true\")]\n+    #[serde(deserialize_with = \"true_or_always\")]\n     Always,\n-    #[serde(alias = \"false\")]\n+    #[serde(deserialize_with = \"false_or_never\")]\n     Never,\n     SkipTrivial,\n }\n@@ -1550,14 +1605,38 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n             \"maximum\": 255\n         },\n         \"LifetimeElisionDef\" => set! {\n-            \"type\": \"string\",\n+            \"type\": [\"string\", \"boolean\"],\n             \"enum\": [\"always\", \"never\", \"skip_trivial\"],\n             \"enumDescriptions\": [\n                 \"Always show lifetime elision hints.\",\n                 \"Never show lifetime elision hints.\",\n                 \"Only show lifetime elision hints if a return type is involved.\"\n             ],\n         },\n+        \"CargoFeatures\" => set! {\n+            \"type\": [\"string\", \"array\"],\n+            \"items\": { \"type\": \"string\" },\n+            \"enum\": [\"all\"],\n+            \"enumDescriptions\": [\n+                \"Pass `--all-features` to cargo\",\n+            ],\n+        },\n+        \"Option<CargoFeatures>\" => set! {\n+            \"type\": [\"string\", \"array\", \"null\"],\n+            \"items\": { \"type\": \"string\" },\n+            \"enum\": [\"all\"],\n+            \"enumDescriptions\": [\n+                \"Pass `--all-features` to cargo\",\n+            ],\n+        },\n+        \"Option<CallableCompletionDef>\" => set! {\n+            \"type\": [\"string\", \"null\"],\n+            \"enum\": [\"fill_arguments\", \"add_parentheses\"],\n+            \"enumDescriptions\": [\n+                \"Add call parentheses and pre-fill arguments\",\n+                \"Add call parentheses\",\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}]}