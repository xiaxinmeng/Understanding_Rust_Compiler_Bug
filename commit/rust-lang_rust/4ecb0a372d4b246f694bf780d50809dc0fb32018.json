{"sha": "4ecb0a372d4b246f694bf780d50809dc0fb32018", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlY2IwYTM3MmQ0YjI0NmY2OTRiZjc4MGQ1MDgwOWRjMGZiMzIwMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T08:50:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-15T08:50:50Z"}, "message": "auto merge of #9153 : alexcrichton/rust/simplify-format, r=huonw\n\nThis follows from the discussion in #9012.\r\n\r\n* All macros are now defined in terms of `format_args!` allowing for removal of a good bit of code in the syntax extension\r\n* The syntax extension is now in a more aptly-named file, `format.rs`\r\n* Documentation was added for the `format!`-related macros.", "tree": {"sha": "187f30d8b9ae662bc385558473e1c9c1fa5b6424", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/187f30d8b9ae662bc385558473e1c9c1fa5b6424"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ecb0a372d4b246f694bf780d50809dc0fb32018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecb0a372d4b246f694bf780d50809dc0fb32018", "html_url": "https://github.com/rust-lang/rust/commit/4ecb0a372d4b246f694bf780d50809dc0fb32018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ecb0a372d4b246f694bf780d50809dc0fb32018/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36872e4180331e4a7f00329abe7972488ce216cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/36872e4180331e4a7f00329abe7972488ce216cf", "html_url": "https://github.com/rust-lang/rust/commit/36872e4180331e4a7f00329abe7972488ce216cf"}, {"sha": "640613892fc5ab055853b48934b6e4ecf895c2dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/640613892fc5ab055853b48934b6e4ecf895c2dd", "html_url": "https://github.com/rust-lang/rust/commit/640613892fc5ab055853b48934b6e4ecf895c2dd"}], "stats": {"total": 314, "additions": 172, "deletions": 142}, "files": [{"sha": "cad9f14bda734bd9164ecd23b5b431544e61bf3c", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -133,7 +133,7 @@ is `?` which is defined for all types by default.\n When implementing a format trait for your own time, you will have to implement a\n method of the signature:\n \n-~~~\n+~~~{.rust}\n fn fmt(value: &T, f: &mut std::fmt::Formatter);\n ~~~\n \n@@ -144,6 +144,78 @@ values of these parameters will be listed in the fields of the `Formatter`\n struct. In order to help with this, the `Formatter` struct also provides some\n helper methods.\n \n+### Related macros\n+\n+There are a number of related macros in the `format!` family. The ones that are\n+currently implemented are:\n+\n+~~~{.rust}\n+format!      // described above\n+write!       // first argument is a &mut rt::io::Writer, the destination\n+writeln!     // same as write but appends a newline\n+print!       // the format string is printed to the standard output\n+println!     // same as print but appends a newline\n+format_args! // described below.\n+~~~\n+\n+\n+#### `write!`\n+\n+This and `writeln` are two macros which are used to emit the format string to a\n+specified stream. This is used to prevent intermediate allocations of format\n+strings and instead directly write the output. Under the hood, this function is\n+actually invoking the `write` function defined in this module. Example usage is:\n+\n+~~~{.rust}\n+use std::rt::io;\n+\n+let mut w = io::mem::MemWriter::new();\n+write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n+~~~\n+\n+#### `print!`\n+\n+This and `println` emit their output to stdout. Similarly to the `write!` macro,\n+the goal of these macros is to avoid intermediate allocations when printing\n+output. Example usage is:\n+\n+~~~{.rust}\n+print!(\"Hello {}!\", \"world\");\n+println!(\"I have a newline {}\", \"character at the end\");\n+~~~\n+\n+#### `format_args!`\n+This is a curious macro which is used to safely pass around\n+an opaque object describing the format string. This object\n+does not require any heap allocations to create, and it only\n+references information on the stack. Under the hood, all of\n+the related macros are implemented in terms of this. First\n+off, some example usage is:\n+\n+~~~{.rust}\n+use std::fmt;\n+\n+format_args!(fmt::format, \"this returns {}\", \"~str\");\n+format_args!(|args| { fmt::write(my_writer, args) }, \"some {}\", \"args\");\n+format_args!(my_fn, \"format {}\", \"string\");\n+~~~\n+\n+The first argument of the `format_args!` macro is a function (or closure) which\n+takes one argument of type `&fmt::Arguments`. This structure can then be\n+passed to the `write` and `format` functions inside this module in order to\n+process the format string. The goal of this macro is to even further prevent\n+intermediate allocations when dealing formatting strings.\n+\n+For example, a logging library could use the standard formatting syntax, but it\n+would internally pass around this structure until it has been determined where\n+output should go to.\n+\n+It is unsafe to programmatically create an instance of `fmt::Arguments` because\n+the operations performed when executing a format string require the compile-time\n+checks provided by the compiler. The `format_args!` macro is the only method of\n+safely creating these structures, but they can be unsafely created with the\n+constructor provided.\n+\n ## Internationalization\n \n The formatting syntax supported by the `format!` extension supports\n@@ -163,7 +235,7 @@ Furthermore, whenever a case is running, the special character `#` can be used\n to reference the string value of the argument which was selected upon. As an\n example:\n \n-~~~\n+~~~{.rust}\n format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n ~~~\n \n@@ -452,6 +524,13 @@ pub fn write(output: &mut io::Writer, args: &Arguments) {\n     unsafe { write_unsafe(output, args.fmt, args.args) }\n }\n \n+/// The `writeln` function takes the same arguments as `write`, except that it\n+/// will also write a newline (`\\n`) character at the end of the format string.\n+pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n+    unsafe { write_unsafe(output, args.fmt, args.args) }\n+    output.write(['\\n' as u8]);\n+}\n+\n /// The `write_unsafe` function takes an output stream, a precompiled format\n /// string, and a list of arguments. The arguments will be formatted according\n /// to the specified format string into the output stream provided."}, {"sha": "2bcfafc3bb483ffb62c4501760f020c26d766ff7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -155,14 +155,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                             @SE(IdentTT(ext::tt::macro_rules::add_new_extension, None)));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(intern(&\"format\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format));\n-    syntax_expanders.insert(intern(&\"write\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_write));\n-    syntax_expanders.insert(intern(&\"writeln\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(intern(&\"format_args\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format_args));\n+                            builtin_normal_tt_no_ctxt(ext::format::expand_args));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "ac094c27a8119780debbf58de5afefbd413d7dd4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -81,20 +81,10 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // be the root of the call stack. That's the most\n                             // relevant span and it's the actual invocation of\n                             // the macro.\n-                            let mut relevant_info = cx.backtrace();\n-                            let mut einfo = relevant_info.unwrap();\n-                            loop {\n-                                match relevant_info {\n-                                    None => { break }\n-                                    Some(e) => {\n-                                        einfo = e;\n-                                        relevant_info = einfo.call_site.expn_info;\n-                                    }\n-                                }\n-                            }\n+                            let mac_span = original_span(cx);\n \n                             let expanded =\n-                                match expandfun(cx, einfo.call_site,\n+                                match expandfun(cx, mac_span.call_site,\n                                                 marked_before, marked_ctxt) {\n                                     MRExpr(e) => e,\n                                     MRAny(expr_maker,_,_) => expr_maker(),\n@@ -400,11 +390,11 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 -> (Option<Stmt_>, Span) {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n-    let (mac, pth, tts, semi, ctxt) = match *s {\n+    let (pth, tts, semi, ctxt) = match *s {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n-                    ((*mac).clone(), pth, (*tts).clone(), semi, ctxt)\n+                    (pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n         }\n@@ -431,7 +421,13 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            let expanded = match expandfun(cx, mac.span, marked_tts, marked_ctxt) {\n+\n+            // See the comment in expand_expr for why we want the original span,\n+            // not the current mac.span.\n+            let mac_span = original_span(cx);\n+\n+            let expanded = match expandfun(cx, mac_span.call_site,\n+                                           marked_tts, marked_ctxt) {\n                 MRExpr(e) =>\n                     @codemap::Spanned { node: StmtExpr(e, ast::DUMMY_NODE_ID),\n                                         span: e.span},\n@@ -715,11 +711,11 @@ pub fn std_macros() -> @str {\n             }\n         })\n     )\n-    macro_rules! error( ($($arg:tt)+) => (log!(1u32, $($arg)+)) )\n-    macro_rules! warn ( ($($arg:tt)+) => (log!(2u32, $($arg)+)) )\n-    macro_rules! info ( ($($arg:tt)+) => (log!(3u32, $($arg)+)) )\n-    macro_rules! debug( ($($arg:tt)+) => (\n-        if cfg!(debug) { log!(4u32, $($arg)+) }\n+    macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n+    macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n+    macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n+    macro_rules! debug( ($($arg:tt)*) => (\n+        if cfg!(debug) { log!(4u32, $($arg)*) }\n     ))\n \n     macro_rules! log2(\n@@ -730,11 +726,11 @@ pub fn std_macros() -> @str {\n             }\n         })\n     )\n-    macro_rules! error2( ($($arg:tt)+) => (log2!(1u32, $($arg)+)) )\n-    macro_rules! warn2 ( ($($arg:tt)+) => (log2!(2u32, $($arg)+)) )\n-    macro_rules! info2 ( ($($arg:tt)+) => (log2!(3u32, $($arg)+)) )\n-    macro_rules! debug2( ($($arg:tt)+) => (\n-        if cfg!(debug) { log2!(4u32, $($arg)+) }\n+    macro_rules! error2( ($($arg:tt)*) => (log2!(1u32, $($arg)*)) )\n+    macro_rules! warn2 ( ($($arg:tt)*) => (log2!(2u32, $($arg)*)) )\n+    macro_rules! info2 ( ($($arg:tt)*) => (log2!(3u32, $($arg)*)) )\n+    macro_rules! debug2( ($($arg:tt)*) => (\n+        if cfg!(debug) { log2!(4u32, $($arg)*) }\n     ))\n \n     macro_rules! fail(\n@@ -753,8 +749,8 @@ pub fn std_macros() -> @str {\n         () => (\n             fail!(\\\"explicit failure\\\")\n         );\n-        ($($arg:tt)+) => (\n-            ::std::sys::FailWithCause::fail_with(format!($($arg)+), file!(), line!())\n+        ($($arg:tt)*) => (\n+            ::std::sys::FailWithCause::fail_with(format!($($arg)*), file!(), line!())\n         )\n     )\n \n@@ -958,17 +954,25 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    macro_rules! format(($($arg:tt)*) => (\n+        format_args!(::std::fmt::format, $($arg)*)\n+    ))\n+    macro_rules! write(($dst:expr, $($arg:tt)*) => (\n+        format_args!(|args| { ::std::fmt::write($dst, args) }, $($arg)*)\n+    ))\n+    macro_rules! writeln(($dst:expr, $($arg:tt)*) => (\n+        format_args!(|args| { ::std::fmt::writeln($dst, args) }, $($arg)*)\n+    ))\n     // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n     //              allocation but should rather delegate to an invocation of\n     //              write! instead of format!\n     macro_rules! print (\n-        ($($arg:tt)+) => (::std::io::print(format!($($arg)+)))\n+        ($($arg:tt)*) => (::std::io::print(format!($($arg)*)))\n     )\n-\n     // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n     //              allocation but should rather delegate to an io::Writer\n     macro_rules! println (\n-        ($($arg:tt)+) => (::std::io::println(format!($($arg)+)))\n+        ($($arg:tt)*) => (::std::io::println(format!($($arg)*)))\n     )\n \n     // NOTE: use this after a snapshot lands to abstract the details\n@@ -1262,6 +1266,20 @@ pub fn mtwt_cancel_outer_mark(tts: &[ast::token_tree], ctxt: ast::SyntaxContext)\n     mark_tts(tts,outer_mark)\n }\n \n+fn original_span(cx: @ExtCtxt) -> @codemap::ExpnInfo {\n+    let mut relevant_info = cx.backtrace();\n+    let mut einfo = relevant_info.unwrap();\n+    loop {\n+        match relevant_info {\n+            None => { break }\n+            Some(e) => {\n+                einfo = e;\n+                relevant_info = einfo.call_site.expn_info;\n+            }\n+        }\n+    }\n+    return einfo;\n+}\n \n #[cfg(test)]\n mod test {"}, {"sha": "9f4e55b1a92cef6258d983a922d1bea669aca24e", "filename": "src/libsyntax/ext/format.rs", "status": "renamed", "additions": 37, "deletions": 99, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -54,21 +54,16 @@ impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n     fn parse_args(&mut self, sp: Span,\n-                  leading_expr: bool,\n-                  tts: &[ast::token_tree]) -> (Option<@ast::Expr>,\n-                                               Option<@ast::Expr>) {\n+                  tts: &[ast::token_tree]) -> (@ast::Expr, Option<@ast::Expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n-        // If we want a leading expression, parse it here\n-        let extra = if leading_expr {\n-            let e = Some(p.parse_expr());\n-            if !p.eat(&token::COMMA) {\n-                self.ecx.span_err(sp, \"expected token: `,`\");\n-                return (e, None);\n-            }\n-            e\n-        } else { None };\n+        // Parse the leading function expression (maybe a block, maybe a path)\n+        let extra = p.parse_expr();\n+        if !p.eat(&token::COMMA) {\n+            self.ecx.span_err(sp, \"expected token: `,`\");\n+            return (extra, None);\n+        }\n \n         if *p.token == token::EOF {\n             self.ecx.span_err(sp, \"requires at least a format string argument\");\n@@ -547,7 +542,7 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: Option<@ast::Expr>, f: Option<&str>) -> @ast::Expr {\n+    fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n@@ -614,68 +609,33 @@ impl Context {\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n+        // Now create the fmt::Arguments struct with all our locals we created.\n         let args = names.move_iter().map(|a| a.unwrap());\n         let mut args = locals.move_iter().chain(args);\n-\n-        let result = match f {\n-            // Invocation of write!()/format!(), call the function and we're\n-            // done.\n-            Some(f) => {\n-                let mut fmt_args = match extra {\n-                    Some(e) => ~[e], None => ~[]\n-                };\n-                fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n-                fmt_args.push(self.ecx.expr_vec_slice(self.fmtsp,\n-                                                      args.collect()));\n-\n-                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(f),\n-                    ], fmt_args);\n-\n-                // sprintf is unsafe, but we just went through a lot of work to\n-                // validate that our call is save, so inject the unsafe block\n-                // for the user.\n-                self.ecx.expr_block(ast::Block {\n-                   view_items: ~[],\n-                   stmts: ~[],\n-                   expr: Some(result),\n-                   id: ast::DUMMY_NODE_ID,\n-                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-                   span: self.fmtsp,\n-                })\n-            }\n-\n-            // Invocation of format_args!()\n-            None => {\n-                let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n-                let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n-                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"Arguments\"),\n-                        self.ecx.ident_of(\"new\"),\n-                    ], ~[fmt, args]);\n-\n-                // We did all the work of making sure that the arguments\n-                // structure is safe, so we can safely have an unsafe block.\n-                let result = self.ecx.expr_block(ast::Block {\n-                   view_items: ~[],\n-                   stmts: ~[],\n-                   expr: Some(result),\n-                   id: ast::DUMMY_NODE_ID,\n-                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-                   span: self.fmtsp,\n-                });\n-                let extra = extra.unwrap();\n-                let resname = self.ecx.ident_of(\"__args\");\n-                lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n-                let res = self.ecx.expr_ident(self.fmtsp, resname);\n-                self.ecx.expr_call(extra.span, extra, ~[\n-                        self.ecx.expr_addr_of(extra.span, res)])\n-            }\n-        };\n+        let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n+        let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"Arguments\"),\n+                self.ecx.ident_of(\"new\"),\n+            ], ~[fmt, args]);\n+\n+        // We did all the work of making sure that the arguments\n+        // structure is safe, so we can safely have an unsafe block.\n+        let result = self.ecx.expr_block(ast::Block {\n+           view_items: ~[],\n+           stmts: ~[],\n+           expr: Some(result),\n+           id: ast::DUMMY_NODE_ID,\n+           rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+           span: self.fmtsp,\n+        });\n+        let resname = self.ecx.ident_of(\"__args\");\n+        lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n+        let res = self.ecx.expr_ident(self.fmtsp, resname);\n+        let result = self.ecx.expr_call(extra.span, extra, ~[\n+                            self.ecx.expr_addr_of(extra.span, res)]);\n         self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                            Some(result)))\n     }\n@@ -740,29 +700,8 @@ impl Context {\n     }\n }\n \n-pub fn expand_format(ecx: @ExtCtxt, sp: Span,\n-                     tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, false, false, Some(\"format_unsafe\"))\n-}\n-\n-pub fn expand_write(ecx: @ExtCtxt, sp: Span,\n-                    tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, false, Some(\"write_unsafe\"))\n-}\n-\n-pub fn expand_writeln(ecx: @ExtCtxt, sp: Span,\n-                      tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, true, Some(\"write_unsafe\"))\n-}\n-\n-pub fn expand_format_args(ecx: @ExtCtxt, sp: Span,\n-                          tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, false, None)\n-}\n-\n-fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n-               leading_arg: bool, append_newline: bool,\n-               function: Option<&str>) -> base::MacResult {\n+pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n+                   tts: &[ast::token_tree]) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],\n@@ -776,14 +715,13 @@ fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let (extra, efmt) = match cx.parse_args(sp, leading_arg, tts) {\n+    let (extra, efmt) = match cx.parse_args(sp, tts) {\n         (extra, Some(e)) => (extra, e),\n         (_, None) => { return MRExpr(ecx.expr_uint(sp, 2)); }\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n                           \"format argument must be a string literal.\");\n-    let fmt = if append_newline { fmt + \"\\n\" } else { fmt.to_owned() };\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {\n@@ -814,5 +752,5 @@ fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n         }\n     }\n \n-    MRExpr(cx.to_expr(extra, function))\n+    MRExpr(cx.to_expr(extra))\n }", "previous_filename": "src/libsyntax/ext/ifmt.rs"}, {"sha": "48270702e0dd51230748db4e9b6c13cc2422a4b6", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -72,7 +72,7 @@ pub mod ext {\n \n     pub mod cfg;\n     pub mod fmt;\n-    pub mod ifmt;\n+    pub mod format;\n     pub mod env;\n     pub mod bytes;\n     pub mod concat_idents;"}, {"sha": "f9552725af345f4f9e45f8c909ded2503ab1f7a2", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb0a372d4b246f694bf780d50809dc0fb32018/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=4ecb0a372d4b246f694bf780d50809dc0fb32018", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     // bad arguments to the format! call\n \n-    format!();                //~ ERROR: requires at least a format string\n     format!(\"{}\");            //~ ERROR: invalid reference to argument\n \n     format!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n@@ -30,8 +29,6 @@ fn main() {\n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"#\");                      //~ ERROR: `#` reference used\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n-    format!(\"\" 1);                     //~ ERROR: expected token: `,`\n-    format!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n \n     format!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n     format!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n@@ -74,4 +71,8 @@ fn main() {\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+\n+    format!();          //~ ERROR: requires at least a format string argument\n+    format!(\"\" 1);      //~ ERROR: expected token: `,`\n+    format!(\"\", 1 1);   //~ ERROR: expected token: `,`\n }"}]}