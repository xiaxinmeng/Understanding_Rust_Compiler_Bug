{"sha": "3f717bbe96014c04c4c439ed0b0975ca36a73e53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNzE3YmJlOTYwMTRjMDRjNGM0MzllZDBiMDk3NWNhMzZhNzNlNTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T20:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T20:21:51Z"}, "message": "auto merge of #12267 : alexcrichton/rust/rollup, r=alexcrichton\n\nThe last commit has the closed PRs", "tree": {"sha": "8efaf70dc83bb23098e7d0e47a65cdeb963bba8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8efaf70dc83bb23098e7d0e47a65cdeb963bba8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f717bbe96014c04c4c439ed0b0975ca36a73e53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f717bbe96014c04c4c439ed0b0975ca36a73e53", "html_url": "https://github.com/rust-lang/rust/commit/3f717bbe96014c04c4c439ed0b0975ca36a73e53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f717bbe96014c04c4c439ed0b0975ca36a73e53/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "994747022a45b5c2b03f38dddbe8b43bf09679f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/994747022a45b5c2b03f38dddbe8b43bf09679f3", "html_url": "https://github.com/rust-lang/rust/commit/994747022a45b5c2b03f38dddbe8b43bf09679f3"}, {"sha": "2f8dbf210215039f39a80424d9c43f96ff79dad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8dbf210215039f39a80424d9c43f96ff79dad4", "html_url": "https://github.com/rust-lang/rust/commit/2f8dbf210215039f39a80424d9c43f96ff79dad4"}], "stats": {"total": 704, "additions": 415, "deletions": 289}, "files": [{"sha": "8af8f966e30f414e80deb008a4a26ab19bd90876", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -60,9 +60,9 @@ DEPS_extra := std term sync serialize getopts collections\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n-DEPS_syntax := std extra term serialize collections\n+DEPS_syntax := std term serialize collections\n DEPS_rustc := syntax native:rustllvm flate arena serialize sync getopts \\\n-              collections\n+              collections extra\n DEPS_rustdoc := rustc native:sundown serialize sync getopts collections\n DEPS_flate := std native:miniz\n DEPS_arena := std collections"}, {"sha": "673e6684f69d959f5eb732210f5490fbeebe5787", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -236,7 +236,7 @@ COMPRT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n COMPRT_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(COMPRT_NAME_$(1))\n COMPRT_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/compiler-rt\n \n-$$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS)\n+$$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: compiler-rt)\n \t$$(Q)$$(MAKE) -C \"$(S)src/compiler-rt\" \\\n \t\tProjSrcRoot=\"$(S)src/compiler-rt\" \\"}, {"sha": "38c1162f6368563866f43952d6c5cb65342ab9c3", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -30,6 +30,8 @@ pub struct TestProps {\n     check_lines: ~[~str],\n     // Flag to force a crate to be built with the host architecture\n     force_host: bool,\n+    // Check stdout for error-pattern output as well as stderr\n+    check_stdout: bool,\n }\n \n // Load any test directives embedded in the file\n@@ -42,6 +44,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut debugger_cmds = ~[];\n     let mut check_lines = ~[];\n     let mut force_host = false;\n+    let mut check_stdout = false;\n     iter_header(testfile, |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n@@ -60,6 +63,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             force_host = parse_force_host(ln);\n         }\n \n+        if !check_stdout {\n+            check_stdout = parse_check_stdout(ln);\n+        }\n+\n         match parse_aux_build(ln) {\n             Some(ab) => { aux_builds.push(ab); }\n             None => {}\n@@ -91,6 +98,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         debugger_cmds: debugger_cmds,\n         check_lines: check_lines,\n         force_host: force_host,\n+        check_stdout: check_stdout,\n     };\n }\n \n@@ -155,6 +163,10 @@ fn parse_force_host(line: &str) -> bool {\n     parse_name_directive(line, \"force-host\")\n }\n \n+fn parse_check_stdout(line: &str) -> bool {\n+    parse_name_directive(line, \"check-stdout\")\n+}\n+\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     parse_name_value_directive(line, ~\"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "8b45d98786445da3c6b552f48bfad5e7ff47587d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -452,7 +452,12 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for line in ProcRes.stderr.lines() {\n+    let output_to_check = if props.check_stdout {\n+        ProcRes.stdout + ProcRes.stderr\n+    } else {\n+        ProcRes.stderr.clone()\n+    };\n+    for line in output_to_check.lines() {\n         if line.contains(*next_err_pat) {\n             debug!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;"}, {"sha": "d620ed0b54f37d1bd4fde49b17b3eaa86dd73e56", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -57,8 +57,8 @@ they don't contain references to names that aren't actually defined.\n \n # Getting started\n \n-> **NOTE**: The tarball and installer links are for the most recent release,\n-> not master.\n+> **WARNING**: The tarball and installer links are for the most recent\n+> release, not master. To use master, you **must** build from [git].\n \n The Rust compiler currently must be built from a [tarball] or [git], unless\n you are on Windows, in which case using the [installer][win-exe] is"}, {"sha": "bee9ec6240b1665b53c155c5c31c6a7bda43cb3e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1561,6 +1561,7 @@ mod tests {\n         let mut bitv = 0 as uint;\n         b.iter(|| {\n             bitv |= (1 << ((r.next_u32() as uint) % uint::BITS));\n+            &bitv\n         })\n     }\n \n@@ -1570,6 +1571,7 @@ mod tests {\n         let mut bitv = SmallBitv::new(uint::BITS);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n+            &bitv\n         })\n     }\n \n@@ -1579,6 +1581,7 @@ mod tests {\n         let mut bitv = BigBitv::new(~[0]);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n+            &bitv\n         })\n     }\n \n@@ -1590,6 +1593,7 @@ mod tests {\n         let mut bitv = BigBitv::new(storage);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+            &bitv\n         })\n     }\n \n@@ -1599,6 +1603,7 @@ mod tests {\n         let mut bitv = Bitv::new(BENCH_BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+            &bitv\n         })\n     }\n \n@@ -1608,6 +1613,7 @@ mod tests {\n         let mut bitv = Bitv::new(uint::BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n+            &bitv\n         })\n     }\n \n@@ -1617,6 +1623,7 @@ mod tests {\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % uint::BITS);\n+            &bitv\n         })\n     }\n \n@@ -1626,6 +1633,7 @@ mod tests {\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n+            &bitv\n         })\n     }\n "}, {"sha": "14c6bc5ce281abd87ca3440e4a8d4ab4ace7cdb5", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -115,8 +115,9 @@ pub mod bench {\n         // measure\n         let mut i = 0;\n         bh.iter(|| {\n-            map.find(&i);\n+            let x = map.find(&i);\n             i = (i + 1) % n;\n+            x\n         })\n      }\n }"}, {"sha": "df13538b4bcc3dcdb69efb4528f840e312a77acd", "filename": "src/libextra/test.rs", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -26,12 +26,11 @@ use stats;\n use time::precise_time_ns;\n use collections::TreeMap;\n \n-use std::clone::Clone;\n use std::cmp;\n use std::io;\n-use std::io::File;\n-use std::io::Writer;\n+use std::io::{File, PortReader, ChanWriter};\n use std::io::stdio::StdWriter;\n+use std::str;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -358,7 +357,7 @@ struct ConsoleTestState<T> {\n     ignored: uint,\n     measured: uint,\n     metrics: MetricMap,\n-    failures: ~[TestDesc],\n+    failures: ~[(TestDesc, ~[u8])],\n     max_name_len: uint, // number of columns to fill when aligning names\n }\n \n@@ -498,9 +497,23 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_failures(&mut self) -> io::IoResult<()> {\n         if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = ~[];\n-        for f in self.failures.iter() {\n+        let mut fail_out  = ~\"\";\n+        for &(ref f, ref stdout) in self.failures.iter() {\n             failures.push(f.name.to_str());\n+            if stdout.len() > 0 {\n+                fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n+                                  f.name.to_str()));\n+                let output = str::from_utf8_lossy(*stdout);\n+                fail_out.push_str(output.as_slice().replace(\"\\n\", \"\\n\\t\"));\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if fail_out.len() > 0 {\n+            if_ok!(self.write_plain(\"\\n\"));\n+            if_ok!(self.write_plain(fail_out));\n         }\n+\n+        if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.sort();\n         for name in failures.iter() {\n             if_ok!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n@@ -632,7 +645,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n-            TeResult(test, result) => {\n+            TeResult(test, result, stdout) => {\n                 if_ok!(st.write_log(&test, &result));\n                 if_ok!(st.write_result(&result));\n                 match result {\n@@ -655,7 +668,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                     }\n                     TrFailed => {\n                         st.failed += 1;\n-                        st.failures.push(test);\n+                        st.failures.push((test, stdout));\n                     }\n                 }\n                 Ok(())\n@@ -717,17 +730,17 @@ fn should_sort_failures_before_printing_them() {\n         measured: 0u,\n         max_name_len: 10u,\n         metrics: MetricMap::new(),\n-        failures: ~[test_b, test_a]\n+        failures: ~[(test_b, ~[]), (test_a, ~[])]\n     };\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => str::from_utf8(m.get_ref()).unwrap(),\n+        Raw(ref m) => str::from_utf8_lossy(m.get_ref()),\n         Pretty(_) => unreachable!()\n     };\n \n-    let apos = s.find_str(\"a\").unwrap();\n-    let bpos = s.find_str(\"b\").unwrap();\n+    let apos = s.as_slice().find_str(\"a\").unwrap();\n+    let bpos = s.as_slice().find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n }\n \n@@ -737,11 +750,10 @@ fn use_color() -> bool { return get_concurrency() == 1; }\n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n     TeWait(TestDesc, NamePadding),\n-    TeResult(TestDesc, TestResult),\n+    TeResult(TestDesc, TestResult, ~[u8] /* stdout */),\n }\n \n-/// The message sent to the test monitor from the individual runners.\n-pub type MonitorMsg = (TestDesc, TestResult);\n+pub type MonitorMsg = (TestDesc, TestResult, ~[u8] /* stdout */);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n@@ -783,11 +795,11 @@ fn run_tests(opts: &TestOpts,\n             pending += 1;\n         }\n \n-        let (desc, result) = p.recv();\n+        let (desc, result, stdout) = p.recv();\n         if concurrency != 1 {\n             if_ok!(callback(TeWait(desc.clone(), PadNone)));\n         }\n-        if_ok!(callback(TeResult(desc, result)));\n+        if_ok!(callback(TeResult(desc, result, stdout)));\n         pending -= 1;\n     }\n \n@@ -796,8 +808,8 @@ fn run_tests(opts: &TestOpts,\n     for b in filtered_benchs_and_metrics.move_iter() {\n         if_ok!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n-        let (test, result) = p.recv();\n-        if_ok!(callback(TeResult(test, result)));\n+        let (test, result, stdout) = p.recv();\n+        if_ok!(callback(TeResult(test, result, stdout)));\n     }\n     Ok(())\n }\n@@ -884,7 +896,7 @@ pub fn run_test(force_ignore: bool,\n     let TestDescAndFn {desc, testfn} = test;\n \n     if force_ignore || desc.ignore {\n-        monitor_ch.send((desc, TrIgnored));\n+        monitor_ch.send((desc, TrIgnored, ~[]));\n         return;\n     }\n \n@@ -893,40 +905,47 @@ pub fn run_test(force_ignore: bool,\n                       testfn: proc()) {\n         spawn(proc() {\n             let mut task = task::task();\n-            task.name(match desc.name {\n-                DynTestName(ref name) => name.to_owned().into_maybe_owned(),\n-                StaticTestName(name) => name.into_maybe_owned()\n-            });\n+            let (p, c) = Chan::new();\n+            let mut reader = PortReader::new(p);\n+            let stdout = ChanWriter::new(c.clone());\n+            let stderr = ChanWriter::new(c);\n+            match desc.name {\n+                DynTestName(ref name) => task.name(name.clone()),\n+                StaticTestName(name) => task.name(name),\n+            }\n+            task.opts.stdout = Some(~stdout as ~Writer);\n+            task.opts.stderr = Some(~stderr as ~Writer);\n             let result_future = task.future_result();\n             task.spawn(testfn);\n \n+            let stdout = reader.read_to_end().unwrap();\n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());\n-            monitor_ch.send((desc.clone(), test_result));\n-        });\n+            monitor_ch.send((desc.clone(), test_result, stdout));\n+        })\n     }\n \n     match testfn {\n         DynBenchFn(bencher) => {\n             let bs = ::test::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs)));\n+            monitor_ch.send((desc, TrBench(bs), ~[]));\n             return;\n         }\n         StaticBenchFn(benchfn) => {\n             let bs = ::test::bench::benchmark(|harness| benchfn(harness));\n-            monitor_ch.send((desc, TrBench(bs)));\n+            monitor_ch.send((desc, TrBench(bs), ~[]));\n             return;\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm)));\n+            monitor_ch.send((desc, TrMetrics(mm), ~[]));\n             return;\n         }\n         StaticMetricFn(f) => {\n             let mut mm = MetricMap::new();\n             f(&mut mm);\n-            monitor_ch.send((desc, TrMetrics(mm)));\n+            monitor_ch.send((desc, TrMetrics(mm), ~[]));\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, f),\n@@ -1264,7 +1283,7 @@ mod tests {\n         };\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n-        let (_, res) = p.recv();\n+        let (_, res, _) = p.recv();\n         assert!(res != TrOk);\n     }\n \n@@ -1281,7 +1300,7 @@ mod tests {\n         };\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n-        let (_, res) = p.recv();\n+        let (_, res, _) = p.recv();\n         assert_eq!(res, TrIgnored);\n     }\n \n@@ -1298,7 +1317,7 @@ mod tests {\n         };\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n-        let (_, res) = p.recv();\n+        let (_, res, _) = p.recv();\n         assert_eq!(res, TrOk);\n     }\n \n@@ -1315,7 +1334,7 @@ mod tests {\n         };\n         let (p, ch) = Chan::new();\n         run_test(false, desc, ch);\n-        let (_, res) = p.recv();\n+        let (_, res, _) = p.recv();\n         assert_eq!(res, TrFailed);\n     }\n "}, {"sha": "c76c73dc4325bcab951ee93374537816927ff10f", "filename": "src/libextra/url.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -139,10 +139,19 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n }\n \n /**\n- * Encodes a URI by replacing reserved characters with percent encoded\n+ * Encodes a URI by replacing reserved characters with percent-encoded\n  * character sequences.\n  *\n  * This function is compliant with RFC 3986.\n+ *\n+ * # Example\n+ *\n+ * ```rust\n+ * use extra::url::encode;\n+ *\n+ * let url = encode(&\"https://example.com/Rust (programming language)\");\n+ * println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n+ * ```\n  */\n pub fn encode(s: &str) -> ~str {\n     encode_inner(s, true)\n@@ -206,9 +215,18 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n }\n \n /**\n- * Decode a string encoded with percent encoding.\n+ * Decodes a percent-encoded string representing a URI.\n  *\n- * This will only decode escape sequences generated by encode.\n+ * This will only decode escape sequences generated by `encode`.\n+ *\n+ * # Example\n+ *\n+ * ```rust\n+ * use extra::url::decode;\n+ *\n+ * let url = decode(&\"https://example.com/Rust%20(programming%20language)\");\n+ * println!(\"{}\", url); // https://example.com/Rust (programming language)\n+ * ```\n  */\n pub fn decode(s: &str) -> ~str {\n     decode_inner(s, true)\n@@ -410,7 +428,23 @@ pub fn query_to_str(query: &Query) -> ~str {\n     return strvec.connect(\"&\");\n }\n \n-// returns the scheme and the rest of the url, or a parsing error\n+/**\n+ * Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n+ *\n+ * Does not include the separating `:` character.\n+ *\n+ * # Example\n+ *\n+ * ```rust\n+ * use extra::url::get_scheme;\n+ *\n+ * let scheme = match get_scheme(\"https://example.com/\") {\n+ *     Ok((sch, _)) => sch,\n+ *     Err(_) => ~\"(None)\",\n+ * };\n+ * println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n+ * ```\n+ */\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n     for (i,c) in rawurl.chars().enumerate() {\n         match c {\n@@ -654,18 +688,16 @@ fn get_query_fragment(rawurl: &str) ->\n }\n \n /**\n- * Parse a `str` to a `url`\n+ * Parses a URL, converting it from a string to `Url` representation.\n  *\n  * # Arguments\n  *\n- * `rawurl` - a string representing a full url, including scheme.\n+ * `rawurl` - a string representing the full URL, including scheme.\n  *\n  * # Returns\n  *\n- * a `url` that contains the parsed representation of the url.\n- *\n+ * A `Url` struct type representing the URL.\n  */\n-\n pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n@@ -705,19 +737,18 @@ impl FromStr for Url {\n }\n \n /**\n- * Format a `url` as a string\n+ * Converts a URL from `Url` to string representation.\n  *\n  * # Arguments\n  *\n- * `url` - a url.\n+ * `url` - a URL.\n  *\n  * # Returns\n  *\n- * a `str` that contains the formatted url. Note that this will usually\n- * be an inverse of `from_str` but might strip out unneeded separators.\n+ * A string that contains the formatted URL. Note that this will usually\n+ * be an inverse of `from_str` but might strip out unneeded separators;\n  * for example, \"http://somehost.com?\", when parsed and formatted, will\n  * result in just \"http://somehost.com\".\n- *\n  */\n pub fn to_str(url: &Url) -> ~str {\n     let user = match url.user {"}, {"sha": "590229a6652a29a6a8ca29a38e928783ea724d56", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -831,10 +831,10 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       ast::ExprAssignOp(_, _, dest, _) => {\n         this.check_assignment(dest);\n       }\n-      ast::ExprCall(f, ref args, _) => {\n+      ast::ExprCall(f, ref args) => {\n         this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+      ast::ExprMethodCall(callee_id, _, _, ref args) => {\n         this.check_call(expr, None, callee_id, expr.span, *args);\n       }\n       ast::ExprIndex(callee_id, _, rval) |"}, {"sha": "6ca779906e2d17670ab17c413d234e7c1bb278bf", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -351,11 +351,11 @@ impl CFGBuilder {\n                 self.straightline(expr, pred, *elems)\n             }\n \n-            ast::ExprCall(func, ref args, _) => {\n+            ast::ExprCall(func, ref args) => {\n                 self.call(expr, pred, func, *args)\n             }\n \n-            ast::ExprMethodCall(_, _, _, ref args, _) => {\n+            ast::ExprMethodCall(_, _, _, ref args) => {\n                 self.call(expr, pred, args[0], args.slice_from(1))\n             }\n "}, {"sha": "75337a27a6c4fc9da41da7885bf6cf3330ec7eb4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -160,7 +160,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n               }\n             }\n           }\n-          ExprCall(callee, _, NoSugar) => {\n+          ExprCall(callee, _) => {\n             let def_map = def_map.borrow();\n             match def_map.get().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK."}, {"sha": "60d83d7559e03a0d78bd65329167baf53dea2de2", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -577,12 +577,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n-            ast::ExprCall(f, ref args, _) => {\n+            ast::ExprCall(f, ref args) => {\n                 self.walk_expr(f, in_out, loop_scopes);\n                 self.walk_call(f.id, expr.id, *args, in_out, loop_scopes);\n             }\n \n-            ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+            ast::ExprMethodCall(callee_id, _, _, ref args) => {\n                 self.walk_call(callee_id, expr.id, *args, in_out, loop_scopes);\n             }\n "}, {"sha": "2a40c8148fd6db24e5d0fcaa0bf322f3203273cf", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -120,7 +120,7 @@ impl Visitor<()> for EffectCheckVisitor {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n-            ast::ExprMethodCall(callee_id, _, _, _, _) => {\n+            ast::ExprMethodCall(callee_id, _, _, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, callee_id);\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n@@ -129,7 +129,7 @@ impl Visitor<()> for EffectCheckVisitor {\n                                         \"invocation of unsafe method\")\n                 }\n             }\n-            ast::ExprCall(base, _, _) => {\n+            ast::ExprCall(base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));"}, {"sha": "70b5aab4c934ab011bdacd3978c4a6424c23b77c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1205,7 +1205,7 @@ impl Liveness {\n             })\n           }\n \n-          ExprCall(f, ref args, _) => {\n+          ExprCall(f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n@@ -1215,7 +1215,7 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n-          ExprMethodCall(callee_id, _, _, ref args, _) => {\n+          ExprMethodCall(callee_id, _, _, ref args) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n             let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, callee_id));"}, {"sha": "32cb7ca57dae7d6d4d87785ec6c584e91998a84a", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -382,7 +382,7 @@ impl VisitContext {\n                 }\n             }\n \n-            ExprCall(callee, ref args, _) => {    // callee(args)\n+            ExprCall(callee, ref args) => {    // callee(args)\n                 // Figure out whether the called function is consumed.\n                 let mode = match ty::get(ty::expr_ty(self.tcx, callee)).sty {\n                     ty::ty_closure(ref cty) => {\n@@ -412,7 +412,7 @@ impl VisitContext {\n                 self.use_fn_args(callee.id, *args);\n             }\n \n-            ExprMethodCall(callee_id, _, _, ref args, _) => { // callee.m(args)\n+            ExprMethodCall(callee_id, _, _, ref args) => { // callee.m(args)\n                 self.use_fn_args(callee_id, *args);\n             }\n "}, {"sha": "8c5654d3fcecb0b8a8aec4c018ce7bcb8e7341ac", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -705,7 +705,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                     _ => {}\n                 }\n             }\n-            ast::ExprMethodCall(_, ident, _, ref args, _) => {\n+            ast::ExprMethodCall(_, ident, _, ref args) => {\n                 // see above\n                 let t = ty::type_autoderef(ty::expr_ty(self.tcx, args[0]));\n                 match ty::get(t).sty {"}, {"sha": "cb9e772dcea08dcaeac4119ac18e649f43d3cc91", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -5221,7 +5221,7 @@ impl Resolver {\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @RefCell::new(traits));\n             }\n-            ExprMethodCall(_, ident, _, _, _) => {\n+            ExprMethodCall(_, ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);"}, {"sha": "68be851449a9a8bd47f8089decb04714114cea38", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -647,7 +647,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 }\n             }\n           }\n-          ast::ExprCall(callee, ref args, _) => {\n+          ast::ExprCall(callee, ref args) => {\n               let tcx = cx.tcx;\n               let opt_def = {\n                   let def_map = tcx.def_map.borrow();"}, {"sha": "86f4275cf985700a3ed7c8ff67f64619d1eadd64", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -2624,15 +2624,15 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprCall(fn_exp, ref args, _) => {\n+            ast::ExprCall(fn_exp, ref args) => {\n                 walk_expr(cx, fn_exp, scope_stack, scope_map);\n \n                 for arg_exp in args.iter() {\n                     walk_expr(cx, *arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprMethodCall(node_id, _, _, ref args, _) => {\n+            ast::ExprMethodCall(node_id, _, _, ref args) => {\n                 scope_map.insert(node_id, scope_stack.last().unwrap().scope_metadata);\n \n                 for arg_exp in args.iter() {"}, {"sha": "794964e10540446af369ee3cd9d4e3e4b670c193", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -777,11 +777,11 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n                    expr_to_str(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n-        ast::ExprCall(f, ref args, _) => {\n+        ast::ExprCall(f, ref args) => {\n             callee::trans_call(bcx, expr, f,\n                                callee::ArgExprs(*args), expr.id, dest)\n         }\n-        ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+        ast::ExprMethodCall(callee_id, _, _, ref args) => {\n             callee::trans_method_call(bcx, expr, callee_id, args[0],\n                                       callee::ArgExprs(*args), dest)\n         }"}, {"sha": "27fb9bdb0bb84687ac44edfbb957340b4e12e720", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -353,17 +353,24 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n     // converting to an rvalue.\n     let self_datum = unpack_datum!(\n         bcx, expr::trans(bcx, self_expr));\n-    let self_datum = unpack_datum!(\n-        bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n \n-    // Convert to by-ref since `trans_trait_callee_from_llval` wants it\n-    // that way.\n-    let self_datum = unpack_datum!(\n-        bcx, self_datum.to_ref_datum(bcx));\n+    let llval = if ty::type_needs_drop(bcx.tcx(), self_datum.ty) {\n+        let self_datum = unpack_datum!(\n+            bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n+\n+        // Convert to by-ref since `trans_trait_callee_from_llval` wants it\n+        // that way.\n+        let self_datum = unpack_datum!(\n+            bcx, self_datum.to_ref_datum(bcx));\n \n-    // Arrange cleanup in case something should go wrong before the\n-    // actual call occurs.\n-    let llval = self_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n+        // Arrange cleanup in case something should go wrong before the\n+        // actual call occurs.\n+        self_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n+    } else {\n+        // We don't have to do anything about cleanups for &Trait and &mut Trait.\n+        assert!(self_datum.kind.is_by_ref());\n+        self_datum.val\n+    };\n \n     let callee_ty = node_id_type(bcx, callee_id);\n     trans_trait_callee_from_llval(bcx, callee_ty, n_method, llval)"}, {"sha": "177eba5aa1b1ad0f9a116f6a03a8a2ef9deeea4c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1592,22 +1592,20 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         method_fn_ty: ty::t,\n         callee_expr: &ast::Expr,\n         args: &[@ast::Expr],\n-        sugar: ast::CallSugar,\n-        deref_args: DerefArgs) -> ty::t\n-    {\n+        deref_args: DerefArgs) -> ty::t {\n         // HACK(eddyb) ignore provided self (it has special typeck rules).\n         let args = args.slice_from(1);\n         if ty::type_is_error(method_fn_ty) {\n             let err_inputs = err_args(args.len());\n             check_argument_types(fcx, sp, err_inputs, callee_expr,\n-                                 args, sugar, deref_args, false);\n+                                 args, deref_args, false);\n             method_fn_ty\n         } else {\n             match ty::get(method_fn_ty).sty {\n                 ty::ty_bare_fn(ref fty) => {\n                     // HACK(eddyb) ignore self in the definition (see above).\n                     check_argument_types(fcx, sp, fty.sig.inputs.slice_from(1),\n-                                         callee_expr, args, sugar, deref_args,\n+                                         callee_expr, args, deref_args,\n                                          fty.sig.variadic);\n                     fty.sig.output\n                 }\n@@ -1625,7 +1623,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                             fn_inputs: &[ty::t],\n                             callee_expr: &ast::Expr,\n                             args: &[@ast::Expr],\n-                            sugar: ast::CallSugar,\n                             deref_args: DerefArgs,\n                             variadic: bool) {\n         /*!\n@@ -1659,18 +1656,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 err_args(supplied_arg_count)\n             }\n         } else {\n-            let suffix = match sugar {\n-                ast::NoSugar => \"\",\n-                ast::ForSugar => \" (including the closure passed by \\\n-                                  the `for` keyword)\"\n-            };\n             let msg = format!(\n                 \"this function takes {} parameter{} \\\n-                 but {} parameter{} supplied{}\",\n+                 but {} parameter{} supplied\",\n                  expected_arg_count, if expected_arg_count == 1 {\"\"} else {\"s\"},\n                  supplied_arg_count,\n-                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"},\n-                 suffix);\n+                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n \n             tcx.sess.span_err(sp, msg);\n \n@@ -1783,33 +1774,16 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n-    fn write_call(fcx: @FnCtxt,\n-                  call_expr: &ast::Expr,\n-                  output: ty::t,\n-                  sugar: ast::CallSugar) {\n-        let ret_ty = match sugar {\n-            ast::ForSugar => {\n-                match ty::get(output).sty {\n-                    ty::ty_bool => {}\n-                    _ => fcx.type_error_message(call_expr.span, |actual| {\n-                            format!(\"expected `for` closure to return `bool`, \\\n-                                  but found `{}`\", actual) },\n-                            output, None)\n-                }\n-                ty::mk_nil()\n-            }\n-            _ => output\n-        };\n-        fcx.write_ty(call_expr.id, ret_ty);\n+    fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n+        fcx.write_ty(call_expr.id, output);\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n-                  args: &[@ast::Expr],\n-                  sugar: ast::CallSugar) {\n+                  args: &[@ast::Expr]) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n         check_expr(fcx, f);\n@@ -1857,9 +1831,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n-                             args, sugar, DontDerefArgs, fn_sig.variadic);\n+                             args, DontDerefArgs, fn_sig.variadic);\n \n-        write_call(fcx, call_expr, fn_sig.output, sugar);\n+        write_call(fcx, call_expr, fn_sig.output);\n     }\n \n     // Checks a method call.\n@@ -1868,8 +1842,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n-                         tps: &[ast::P<ast::Ty>],\n-                         sugar: ast::CallSugar) {\n+                         tps: &[ast::P<ast::Ty>]) {\n         let rcvr = args[0];\n         check_expr(fcx, rcvr);\n \n@@ -1915,10 +1888,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // Call the generic checker.\n         let fn_ty = fcx.node_ty(callee_id);\n         let ret_ty = check_method_argument_types(fcx, expr.span,\n-                                                 fn_ty, expr, args, sugar,\n+                                                 fn_ty, expr, args,\n                                                  DontDerefArgs);\n \n-        write_call(fcx, expr, ret_ty, sugar);\n+        write_call(fcx, expr, ret_ty);\n     }\n \n     // A generic function for checking the then and else in an if\n@@ -1985,17 +1958,17 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     method_map.get().insert(op_ex.id, *origin);\n                 }\n                 check_method_argument_types(fcx, op_ex.span,\n-                                            method_ty, op_ex, args,\n-                                            ast::NoSugar, deref_args)\n+                                            method_ty, op_ex,\n+                                            args, deref_args)\n             }\n             _ => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err();\n                 check_method_argument_types(fcx, op_ex.span,\n-                                            expected_ty, op_ex, args,\n-                                            ast::NoSugar, deref_args);\n+                                            expected_ty, op_ex,\n+                                            args, deref_args);\n                 ty::mk_err()\n             }\n         }\n@@ -2948,8 +2921,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         check_block_with_expected(fcx, b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n-      ast::ExprCall(f, ref args, sugar) => {\n-          check_call(fcx, expr.id, expr, f, *args, sugar);\n+      ast::ExprCall(f, ref args) => {\n+          check_call(fcx, expr.id, expr, f, *args);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {\n@@ -2964,8 +2937,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n               fcx.write_bot(id);\n           }\n       }\n-      ast::ExprMethodCall(callee_id, ident, ref tps, ref args, sugar) => {\n-        check_method_call(fcx, callee_id, expr, ident, *args, *tps, sugar);\n+      ast::ExprMethodCall(callee_id, ident, ref tps, ref args) => {\n+        check_method_call(fcx, callee_id, expr, ident, *args, *tps);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n              |(rest_bot, rest_err), a| {"}, {"sha": "384007727780a36768fe87a1fef33ac62d63ed24", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -432,14 +432,14 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n \n     match expr.node {\n-        ast::ExprCall(callee, ref args, _) => {\n+        ast::ExprCall(callee, ref args) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n             constrain_call(rcx, callee.id, expr, None, *args, false);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprMethodCall(callee_id, _, _, ref args, _) => {\n+        ast::ExprMethodCall(callee_id, _, _, ref args) => {\n             constrain_call(rcx, callee_id, expr, Some(args[0]),\n                            args.slice_from(1), false);\n "}, {"sha": "721672ab677aca513af0f365888ea84814ea885f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -702,7 +702,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n       ast::ExprUnary(callee_id, _, _) |\n       ast::ExprAssignOp(callee_id, _, _, _) |\n       ast::ExprIndex(callee_id, _, _) |\n-      ast::ExprMethodCall(callee_id, _, _, _, _) => {\n+      ast::ExprMethodCall(callee_id, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\","}, {"sha": "c05afcf859af52b0dd765f71ebd8d7cd85580dd7", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -307,7 +307,7 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n             maybe_resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n \n-        ast::ExprMethodCall(callee_id, _, _, _, _) => {\n+        ast::ExprMethodCall(callee_id, _, _, _) => {\n             // We must always have written in a callee ID type for these.\n             resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }"}, {"sha": "0c3bf2e01354c1c0a0c616548d5dda6d3d8cac30", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -15,7 +15,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::local_data;\n-use extra;\n+use extra::time;\n \n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     local_data_key!(depth: uint);\n@@ -24,9 +24,9 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     let old = local_data::get(depth, |d| d.map(|a| *a).unwrap_or(0));\n     local_data::set(depth, old + 1);\n \n-    let start = extra::time::precise_time_s();\n+    let start = time::precise_time_s();\n     let rv = f(u);\n-    let end = extra::time::precise_time_s();\n+    let end = time::precise_time_s();\n \n     println!(\"{}time: {:3.3f} s\\t{}\", \"  \".repeat(old), end - start, what);\n     local_data::set(depth, old);"}, {"sha": "46de70c1746e7024d27ac6d99003a1c89c8729db", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -117,7 +117,10 @@ mod test {\n                     match *slot.get() {\n                         (ref mut task, ref mut val) => {\n                             *val = n;\n-                            task.take_unwrap()\n+                            match task.take() {\n+                                Some(t) => t,\n+                                None => return\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "fbed53ee30d6ec18ff18ecd5a7ba46dc30d423ea", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -565,14 +565,14 @@ mod test {\n     #[bench]\n     fn bench_buffered_reader(bh: &mut Harness) {\n         bh.iter(|| {\n-            BufferedReader::new(NullStream);\n+            BufferedReader::new(NullStream)\n         });\n     }\n \n     #[bench]\n     fn bench_buffered_writer(bh: &mut Harness) {\n         bh.iter(|| {\n-            BufferedWriter::new(NullStream);\n+            BufferedWriter::new(NullStream)\n         });\n     }\n "}, {"sha": "bf2c6dbb623f354c270e4a3c32c5b851e260fbae", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -96,6 +96,12 @@ impl ChanWriter {\n     }\n }\n \n+impl Clone for ChanWriter {\n+    fn clone(&self) -> ChanWriter {\n+        ChanWriter { chan: self.chan.clone() }\n+    }\n+}\n+\n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if !self.chan.try_send(buf.to_owned()) {"}, {"sha": "ee05d6a704bedbc063efce390296ea8626cc5b2c", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -292,15 +292,15 @@ mod bench {\n         let s = Struct { field: 10 };\n         let t = &s as &Trait;\n         bh.iter(|| {\n-            t.method();\n+            t.method()\n         });\n     }\n \n     #[bench]\n     fn trait_static_method_call(bh: &mut BenchHarness) {\n         let s = Struct { field: 10 };\n         bh.iter(|| {\n-            s.method();\n+            s.method()\n         });\n     }\n \n@@ -310,21 +310,21 @@ mod bench {\n     fn match_option_some(bh: &mut BenchHarness) {\n         let x = Some(10);\n         bh.iter(|| {\n-            let _q = match x {\n+            match x {\n                 Some(y) => y,\n                 None => 11\n-            };\n+            }\n         });\n     }\n \n     #[bench]\n     fn match_vec_pattern(bh: &mut BenchHarness) {\n         let x = [1,2,3,4,5,6];\n         bh.iter(|| {\n-            let _q = match x {\n+            match x {\n                 [1,2,3,..] => 10,\n                 _ => 11\n-            };\n+            }\n         });\n     }\n }"}, {"sha": "ab279fd3102d219fabee23846d12165d20a618ec", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -112,14 +112,14 @@ mod bench {\n     #[bench]\n     fn alloc_owned_small(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            ~10;\n+            ~10\n         })\n     }\n \n     #[bench]\n     fn alloc_owned_big(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            ~[10, ..1000];\n+            ~[10, ..1000]\n         })\n     }\n }"}, {"sha": "063182ff0e1d9fa1e7dfc69735a9d69720a40cb1", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -4357,7 +4357,7 @@ mod bench {\n \n         assert_eq!(100, s.len());\n         bh.iter(|| {\n-            let _ = is_utf8(s);\n+            is_utf8(s)\n         });\n     }\n \n@@ -4366,7 +4366,7 @@ mod bench {\n         let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n         assert_eq!(100, s.len());\n         bh.iter(|| {\n-            let _ = is_utf8(s);\n+            is_utf8(s)\n         });\n     }\n \n@@ -4409,7 +4409,7 @@ mod bench {\n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            let _ = with_capacity(100);\n+            with_capacity(100)\n         });\n     }\n "}, {"sha": "cfe2ad5a08af439be66c523ef57d28b831388b2c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -4428,22 +4428,23 @@ mod bench {\n         let mut vec: ~[uint] = ~[0u];\n         bh.iter(|| {\n             vec.push(0);\n+            &vec\n         })\n     }\n \n     #[bench]\n     fn starts_with_same_vector(bh: &mut BenchHarness) {\n         let vec: ~[uint] = vec::from_fn(100, |i| i);\n         bh.iter(|| {\n-            vec.starts_with(vec);\n+            vec.starts_with(vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(bh: &mut BenchHarness) {\n         let vec: ~[uint] = ~[0u];\n         bh.iter(|| {\n-            vec.starts_with(vec);\n+            vec.starts_with(vec)\n         })\n     }\n \n@@ -4453,23 +4454,23 @@ mod bench {\n         let mut match_vec: ~[uint] = vec::from_fn(99, |i| i);\n         match_vec.push(0);\n         bh.iter(|| {\n-            vec.starts_with(match_vec);\n+            vec.starts_with(match_vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_same_vector(bh: &mut BenchHarness) {\n         let vec: ~[uint] = vec::from_fn(100, |i| i);\n         bh.iter(|| {\n-            vec.ends_with(vec);\n+            vec.ends_with(vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(bh: &mut BenchHarness) {\n         let vec: ~[uint] = ~[0u];\n         bh.iter(|| {\n-            vec.ends_with(vec);\n+            vec.ends_with(vec)\n         })\n     }\n \n@@ -4479,15 +4480,15 @@ mod bench {\n         let mut match_vec: ~[uint] = vec::from_fn(100, |i| i);\n         match_vec[0] = 200;\n         bh.iter(|| {\n-            vec.starts_with(match_vec);\n+            vec.starts_with(match_vec)\n         })\n     }\n \n     #[bench]\n     fn contains_last_element(bh: &mut BenchHarness) {\n         let vec: ~[uint] = vec::from_fn(100, |i| i);\n         bh.iter(|| {\n-                vec.contains(&99u);\n+            vec.contains(&99u)\n         })\n     }\n \n@@ -4507,13 +4508,14 @@ mod bench {\n                 ptr::set_memory(vp, 0, 1024);\n                 v.set_len(1024);\n             }\n+            v\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_fixed_repeat(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            let _v: ~[u8] = ~[0u8, ..1024];\n+            ~[0u8, ..1024]\n         });\n     }\n \n@@ -4542,6 +4544,7 @@ mod bench {\n             for x in v.mut_iter() {\n                 *x = 0;\n             }\n+            v\n         });\n     }\n "}, {"sha": "132cb396ddd392955c52a77589e7450725f4901e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -519,7 +519,7 @@ pub struct Expr {\n impl Expr {\n     pub fn get_callee_id(&self) -> Option<NodeId> {\n         match self.node {\n-            ExprMethodCall(callee_id, _, _, _, _) |\n+            ExprMethodCall(callee_id, _, _, _) |\n             ExprIndex(callee_id, _, _) |\n             ExprBinary(callee_id, _, _, _) |\n             ExprAssignOp(callee_id, _, _, _) |\n@@ -529,20 +529,14 @@ impl Expr {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum CallSugar {\n-    NoSugar,\n-    ForSugar\n-}\n-\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n     ExprVec(~[@Expr], Mutability),\n-    ExprCall(@Expr, ~[@Expr], CallSugar),\n-    ExprMethodCall(NodeId, Ident, ~[P<Ty>], ~[@Expr], CallSugar),\n+    ExprCall(@Expr, ~[@Expr]),\n+    ExprMethodCall(NodeId, Ident, ~[P<Ty>], ~[@Expr]),\n     ExprTup(~[@Expr]),\n     ExprBinary(NodeId, BinOp, @Expr, @Expr),\n     ExprUnary(NodeId, UnOp, @Expr),"}, {"sha": "d311a542ac689f4074a78cf06eb44c22d80f181a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -525,11 +525,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_call(&self, span: Span, expr: @ast::Expr, args: ~[@ast::Expr]) -> @ast::Expr {\n-        self.expr(span, ast::ExprCall(expr, args, ast::NoSugar))\n+        self.expr(span, ast::ExprCall(expr, args))\n     }\n     fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::Expr]) -> @ast::Expr {\n-        self.expr(span,\n-                  ast::ExprCall(self.expr_ident(span, id), args, ast::NoSugar))\n+        self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n                       args: ~[@ast::Expr]) -> @ast::Expr {\n@@ -541,7 +540,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: ~[@ast::Expr]) -> @ast::Expr {\n         args.unshift(expr);\n-        self.expr(span, ast::ExprMethodCall(ast::DUMMY_NODE_ID, ident, ~[], args, ast::NoSugar))\n+        self.expr(span, ast::ExprMethodCall(ast::DUMMY_NODE_ID, ident, ~[], args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))"}, {"sha": "97766e1a14b487fae56da4fa7b40bad6c3a9a9a2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -203,52 +203,6 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     }\n }\n \n-// This is a secondary mechanism for invoking syntax extensions on items:\n-// \"decorator\" attributes, such as #[auto_encode]. These are invoked by an\n-// attribute prefixing an item, and are interpreted by feeding the item\n-// through the named attribute _as a syntax extension_ and splicing in the\n-// resulting item vec into place in favour of the decorator. Note that\n-// these do _not_ work for macro extensions, just ItemDecorator ones.\n-//\n-// NB: there is some redundancy between this and expand_item, below, and\n-// they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(module_: &ast::Mod, fld: &mut MacroExpander) -> ast::Mod {\n-    // Fold the contents first:\n-    let module_ = noop_fold_mod(module_, fld);\n-\n-    // For each item, look through the attributes.  If any of them are\n-    // decorated with \"item decorators\", then use that function to transform\n-    // the item into a new set of items.\n-    let mut new_items = module_.items.clone();\n-    for item in module_.items.iter() {\n-        for attr in item.attrs.rev_iter() {\n-            let mname = attr.name();\n-\n-            match fld.extsbox.find(&intern(mname.get())) {\n-              Some(&ItemDecorator(dec_fn)) => {\n-                  fld.cx.bt_push(ExpnInfo {\n-                      call_site: attr.span,\n-                      callee: NameAndSpan {\n-                          name: mname.get().to_str(),\n-                          format: MacroAttribute,\n-                          span: None\n-                      }\n-                  });\n-                  dec_fn(fld.cx, attr.span, attr.node.value, *item,\n-                         |item| new_items.push(item));\n-                  fld.cx.bt_pop();\n-              },\n-              _ => {},\n-            }\n-        }\n-    }\n-\n-    ast::Mod {\n-        items: new_items,\n-        ..module_\n-    }\n-}\n-\n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n@@ -263,7 +217,35 @@ macro_rules! with_exts_frame (\n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n                    -> SmallVector<@ast::Item> {\n-    match it.node {\n+    let mut decorator_items = SmallVector::zero();\n+    for attr in it.attrs.rev_iter() {\n+        let mname = attr.name();\n+\n+        match fld.extsbox.find(&intern(mname.get())) {\n+            Some(&ItemDecorator(dec_fn)) => {\n+                fld.cx.bt_push(ExpnInfo {\n+                    call_site: attr.span,\n+                    callee: NameAndSpan {\n+                        name: mname.get().to_str(),\n+                        format: MacroAttribute,\n+                        span: None\n+                    }\n+                });\n+                // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                // but that double-mut-borrows fld\n+                dec_fn(fld.cx, attr.span, attr.node.value, it,\n+                       |item| decorator_items.push(item));\n+                fld.cx.bt_pop();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let decorator_items = decorator_items.move_iter()\n+        .flat_map(|item| expand_item(item, fld).move_iter())\n+        .collect();\n+\n+    let mut new_items = match it.node {\n         ast::ItemMac(..) => expand_item_mac(it, fld),\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n@@ -275,7 +257,10 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n             result\n         },\n         _ => noop_fold_item(it, fld)\n-    }\n+    };\n+\n+    new_items.push_all(decorator_items);\n+    new_items\n }\n \n // does this attribute list contain \"macro_escape\" ?\n@@ -778,10 +763,6 @@ impl<'a> Folder for MacroExpander<'a> {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n-        expand_mod_items(module, self)\n-    }\n-\n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         expand_item(item, self)\n     }"}, {"sha": "e150d1685de24b570fe31243e5a5ca82fe6806c5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -727,19 +727,16 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n         ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n-        ExprCall(f, ref args, blk) => {\n+        ExprCall(f, ref args) => {\n             ExprCall(folder.fold_expr(f),\n-                     args.map(|&x| folder.fold_expr(x)),\n-                     blk)\n+                     args.map(|&x| folder.fold_expr(x)))\n         }\n-        ExprMethodCall(callee_id, i, ref tps, ref args, blk) => {\n+        ExprMethodCall(callee_id, i, ref tps, ref args) => {\n             ExprMethodCall(\n                 folder.new_id(callee_id),\n                 folder.fold_ident(i),\n                 tps.map(|&x| folder.fold_ty(x)),\n-                args.map(|&x| folder.fold_expr(x)),\n-                blk\n-            )\n+                args.map(|&x| folder.fold_expr(x)))\n         }\n         ExprBinary(callee_id, binop, lhs, rhs) => {\n             ExprBinary(folder.new_id(callee_id),"}, {"sha": "78e40a795db1f4bb380f0a1a11887c15102f422c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -32,7 +32,7 @@ This API is completely unstable and subject to change.\n \n #[deny(non_camel_case_types)];\n \n-extern mod extra;\n+#[cfg(test)] extern mod extra;\n extern mod serialize;\n extern mod term;\n extern mod collections;"}, {"sha": "d6dcb956f25c6981df446abe4305ee96648d7109", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -23,15 +23,13 @@ use ast;\n // isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n     match e.node {\n-      ast::ExprIf(..)\n-      | ast::ExprMatch(..)\n-      | ast::ExprBlock(_)\n-      | ast::ExprWhile(..)\n-      | ast::ExprLoop(..)\n-      | ast::ExprForLoop(..)\n-      | ast::ExprCall(_, _, ast::ForSugar)\n-      | ast::ExprMethodCall(_, _, _, _, ast::ForSugar) => false,\n-      _ => true\n+        ast::ExprIf(..)\n+        | ast::ExprMatch(..)\n+        | ast::ExprBlock(_)\n+        | ast::ExprWhile(..)\n+        | ast::ExprLoop(..)\n+        | ast::ExprForLoop(..) => false,\n+        _ => true\n     }\n }\n "}, {"sha": "a02971ae8eaf287246c6ac04290fbe8b5ea62ae7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -13,7 +13,6 @@\n use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n-use ast::{CallSugar, NoSugar};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{Provided, Public, Purity};\n@@ -1690,13 +1689,12 @@ impl Parser {\n         ExprBinary(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr], sugar: CallSugar) -> ast::Expr_ {\n-        ExprCall(f, args, sugar)\n+    pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr]) -> ast::Expr_ {\n+        ExprCall(f, args)\n     }\n \n-    fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr],\n-                      sugar: CallSugar) -> ast::Expr_ {\n-        ExprMethodCall(ast::DUMMY_NODE_ID, ident, tps, args, sugar)\n+    fn mk_method_call(&mut self, ident: Ident, tps: ~[P<Ty>], args: ~[@Expr]) -> ast::Expr_ {\n+        ExprMethodCall(ast::DUMMY_NODE_ID, ident, tps, args)\n     }\n \n     pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n@@ -1997,7 +1995,7 @@ impl Parser {\n                             hi = self.last_span.hi;\n \n                             es.unshift(e);\n-                            let nd = self.mk_method_call(i, tys, es, NoSugar);\n+                            let nd = self.mk_method_call(i, tys, es);\n                             e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n@@ -2022,7 +2020,7 @@ impl Parser {\n                 );\n                 hi = self.last_span.hi;\n \n-                let nd = self.mk_call(e, es, NoSugar);\n+                let nd = self.mk_call(e, es);\n                 e = self.mk_expr(lo, hi, nd);\n               }\n "}, {"sha": "bb2f345ac2883810b708457cfd204dbd752e1905", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1141,33 +1141,10 @@ pub fn print_expr_vstore(s: &mut State, t: ast::ExprVstore) -> io::IoResult<()>\n     }\n }\n \n-pub fn print_call_pre(s: &mut State,\n-                      sugar: ast::CallSugar,\n-                      base_args: &mut ~[@ast::Expr])\n-                   -> io::IoResult<Option<@ast::Expr>> {\n-    match sugar {\n-        ast::ForSugar => {\n-            if_ok!(head(s, \"for\"));\n-            Ok(Some(base_args.pop().unwrap()))\n-        }\n-        ast::NoSugar => Ok(None)\n-    }\n-}\n-\n-pub fn print_call_post(s: &mut State,\n-                       sugar: ast::CallSugar,\n-                       blk: &Option<@ast::Expr>,\n-                       base_args: &mut ~[@ast::Expr]) -> io::IoResult<()> {\n-    if sugar == ast::NoSugar || !base_args.is_empty() {\n-        if_ok!(popen(s));\n-        if_ok!(commasep_exprs(s, Inconsistent, *base_args));\n-        if_ok!(pclose(s));\n-    }\n-    if sugar != ast::NoSugar {\n-        if_ok!(nbsp(s));\n-        // not sure if this can happen\n-        if_ok!(print_expr(s, blk.unwrap()));\n-    }\n+fn print_call_post(s: &mut State, args: &[@ast::Expr]) -> io::IoResult<()> {\n+    if_ok!(popen(s));\n+    if_ok!(commasep_exprs(s, Inconsistent, args));\n+    if_ok!(pclose(s));\n     Ok(())\n }\n \n@@ -1254,15 +1231,12 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n         }\n         if_ok!(pclose(s));\n       }\n-      ast::ExprCall(func, ref args, sugar) => {\n-        let mut base_args = (*args).clone();\n-        let blk = if_ok!(print_call_pre(s, sugar, &mut base_args));\n+      ast::ExprCall(func, ref args) => {\n         if_ok!(print_expr(s, func));\n-        if_ok!(print_call_post(s, sugar, &blk, &mut base_args));\n+        if_ok!(print_call_post(s, *args));\n       }\n-      ast::ExprMethodCall(_, ident, ref tys, ref args, sugar) => {\n-        let mut base_args = args.slice_from(1).to_owned();\n-        let blk = if_ok!(print_call_pre(s, sugar, &mut base_args));\n+      ast::ExprMethodCall(_, ident, ref tys, ref args) => {\n+        let base_args = args.slice_from(1);\n         if_ok!(print_expr(s, args[0]));\n         if_ok!(word(&mut s.s, \".\"));\n         if_ok!(print_ident(s, ident));\n@@ -1271,7 +1245,7 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) -> io::IoResult<()> {\n             if_ok!(commasep(s, Inconsistent, *tys, print_type_ref));\n             if_ok!(word(&mut s.s, \">\"));\n         }\n-        if_ok!(print_call_post(s, sugar, &blk, &mut base_args));\n+        if_ok!(print_call_post(s, base_args));\n       }\n       ast::ExprBinary(_, op, lhs, rhs) => {\n         if_ok!(print_expr(s, lhs));"}, {"sha": "32e5b83ee04b71f6897306b2963e638ba8a17104", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -64,6 +64,12 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n+    pub fn push_all(&mut self, other: SmallVector<T>) {\n+        for v in other.move_iter() {\n+            self.push(v);\n+        }\n+    }\n+\n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match *self {\n             One(ref v) if idx == 0 => v,"}, {"sha": "feab4e0e84df254856d353f2893b81719e8948e2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -652,13 +652,13 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n                 visitor.visit_expr(*subexpression, env.clone())\n             }\n         }\n-        ExprCall(callee_expression, ref arguments, _) => {\n+        ExprCall(callee_expression, ref arguments) => {\n             for argument in arguments.iter() {\n                 visitor.visit_expr(*argument, env.clone())\n             }\n             visitor.visit_expr(callee_expression, env.clone())\n         }\n-        ExprMethodCall(_, _, ref types, ref arguments, _) => {\n+        ExprMethodCall(_, _, ref types, ref arguments) => {\n             walk_exprs(visitor, *arguments, env.clone());\n             for &typ in types.iter() {\n                 visitor.visit_ty(typ, env.clone())"}, {"sha": "003f1d67cdb8a4d418baea92883dc1e028c0ed6b", "filename": "src/test/compile-fail/issue-8727.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Verify the compiler fails with an error on infinite function\n+// recursions.\n+\n+struct Data(~Option<Data>);\n+\n+fn generic<T>( _ : ~[(Data,T)] ) {\n+    //~^ ERROR overly deep expansion of inlined function\n+    let rec : ~[(Data,(bool,T))] = ~[];\n+    generic( rec );\n+}\n+\n+\n+fn main () {\n+    // Use generic<T> at least once to trigger instantiation.\n+    let input : ~[(Data,())] = ~[];\n+    generic(input);\n+}"}, {"sha": "427e606147d50d6a3278829bbce6b3e1c7b00d41", "filename": "src/test/run-fail/run-unexported-tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -10,6 +10,7 @@\n \n // error-pattern:runned an unexported test\n // compile-flags:--test\n+// check-stdout\n \n extern mod extra;\n "}, {"sha": "77d87c22c6f1cfe84a81ef9fbb60920c6f7aa264", "filename": "src/test/run-fail/test-fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-fail%2Ftest-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-fail%2Ftest-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-fail.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// check-stdout\n // error-pattern:task 'test_foo' failed at\n // compile-flags: --test\n "}, {"sha": "7fb7d601b81b953d4d2090a0946da1ed42dc3e59", "filename": "src/test/run-pass/deriving-in-fn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    #[deriving(ToStr)]\n+    struct Foo {\n+        foo: int,\n+    }\n+\n+    let f = Foo { foo: 10 };\n+    let _ = f.to_str();\n+}"}, {"sha": "230dce1615158544dbf8b08ff51bf798e50e35d7", "filename": "src/test/run-pass/issue-8860.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f717bbe96014c04c4c439ed0b0975ca36a73e53/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8860.rs?ref=3f717bbe96014c04c4c439ed0b0975ca36a73e53", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+extern mod green;\n+\n+static mut DROP: int = 0i;\n+static mut DROP_S: int = 0i;\n+static mut DROP_T: int = 0i;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    let ret = green::start(argc, argv, main);\n+    unsafe {\n+        assert_eq!(2, DROP);\n+        assert_eq!(1, DROP_S);\n+        assert_eq!(1, DROP_T);\n+    }\n+    ret\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_S += 1;\n+            DROP += 1;\n+        }\n+    }\n+}\n+fn f(ref _s: S) {}\n+\n+struct T { i: int }\n+impl Drop for T {\n+    fn drop(&mut self) {\n+        unsafe {\n+            DROP_T += 1;\n+            DROP += 1;\n+        }\n+    }\n+}\n+fn g(ref _t: T) {}\n+\n+fn main() {\n+    let s = S;\n+    f(s);\n+    unsafe {\n+        assert_eq!(1, DROP);\n+        assert_eq!(1, DROP_S);\n+    }\n+    let t = T { i: 1 };\n+    g(t);\n+    unsafe { assert_eq!(1, DROP_T); }\n+}"}]}