{"sha": "89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZjZjNGNmZTJmZWUxYmEyYTlhODllMGUwM2Y4ODMwNmRjMzQzZDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T15:26:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T15:28:20Z"}, "message": "allow inference vars in  type_implements_trait", "tree": {"sha": "ad33c95014ed0d057538c842f438efb95593cfe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad33c95014ed0d057538c842f438efb95593cfe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "html_url": "https://github.com/rust-lang/rust/commit/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd0643eb223bbc4236ca1852cb163ce77b4ffc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd0643eb223bbc4236ca1852cb163ce77b4ffc1", "html_url": "https://github.com/rust-lang/rust/commit/7cd0643eb223bbc4236ca1852cb163ce77b4ffc1"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "add487593c6d2a480e220e21dbbe7b7d19bcd72a", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "patch": "@@ -128,7 +128,9 @@ pub fn implements_trait<'tcx>(\n         return false;\n     }\n     let ty_params = cx.tcx.mk_substs(ty_params.iter());\n-    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+    cx.tcx\n+        .type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+        .must_apply_modulo_regions()\n }\n \n /// Checks whether this type implements `Drop`.\n@@ -144,22 +146,26 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n+        ty::Slice(ty)\n+        | ty::Array(ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n+        | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n-        },\n+        }\n         ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder()\n+                {\n                     if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n             }\n             false\n-        },\n+        }\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n@@ -169,7 +175,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        },\n+        }\n         _ => false,\n     }\n }\n@@ -179,7 +185,11 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_normalizable<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> bool {\n     is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n@@ -199,15 +209,14 @@ fn is_normalizable_helper<'tcx>(\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n                 ty::Adt(def, substs) => def.variants.iter().all(|variant| {\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+                    variant.fields.iter().all(|field| {\n+                        is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache)\n+                    })\n                 }),\n                 _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    },\n+                    }\n                     _ => true, // if inner_ty == ty, we've already checked it\n                 }),\n             }\n@@ -225,7 +234,9 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => {\n+            is_recursively_primitive_type(inner_type)\n+        }\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -269,11 +280,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n-        } else {\n-            (ty, count)\n-        }\n+        if let ty::Ref(_, ty, _) = ty.kind() { peel(ty, count + 1) } else { (ty, count) }\n     }\n     peel(ty, 0)\n }\n@@ -328,17 +335,18 @@ pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n                 return false;\n             }\n \n-            substs_a\n-                .iter()\n-                .zip(substs_b.iter())\n-                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n-                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n+            substs_a.iter().zip(substs_b.iter()).all(|(arg_a, arg_b)| {\n+                match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => {\n+                        inner_a == inner_b\n+                    }\n                     (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n                         same_type_and_consts(type_a, type_b)\n-                    },\n+                    }\n                     _ => true,\n-                })\n-        },\n+                }\n+            })\n+        }\n         _ => a == b,\n     }\n }"}]}