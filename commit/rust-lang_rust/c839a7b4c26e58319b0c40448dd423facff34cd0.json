{"sha": "c839a7b4c26e58319b0c40448dd423facff34cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MzlhN2I0YzI2ZTU4MzE5YjBjNDA0NDhkZDQyM2ZhY2ZmMzRjZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T09:37:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T09:37:35Z"}, "message": "Auto merge of #69257 - RalfJung:layout-visitor, r=eddyb\n\nAdjust Miri value visitor, and doc-comment layout components\n\nI realized that I still didn't have quite the right intuition for how our `LayoutDetails` work, so I had to adjust the Miri value visitor to the things I understood better now. I also added some doc-comments to `LayoutDetails` as a hopefully canonical place to note such things.\n\nThe main visitor change is that we *first* look at all the fields (according to `FieldPlacement`), and *then* check the variants and handle `Multiple` appropriately. I did not quite realize how orthogonal \"fields\" and \"variants\" are.\nI also moved the check for the scalar ABI to *after* checking all the fields; this leads to better (more type-driven) error messages.\n\nAnd it looks like we can finally remove that magic hack for `ty::Generator`. :D\n\nr? @oli-obk for the Miri/visitor changes and @eddyb for the layout docs\nThe Miri PR is at: https://github.com/rust-lang/miri/pull/1178", "tree": {"sha": "38c78515839f1574b67c84038dc8241d40a6b7a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38c78515839f1574b67c84038dc8241d40a6b7a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c839a7b4c26e58319b0c40448dd423facff34cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c839a7b4c26e58319b0c40448dd423facff34cd0", "html_url": "https://github.com/rust-lang/rust/commit/c839a7b4c26e58319b0c40448dd423facff34cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c839a7b4c26e58319b0c40448dd423facff34cd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af4fd385ec23145bc3ba08f700c61361ae961c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af4fd385ec23145bc3ba08f700c61361ae961c0", "html_url": "https://github.com/rust-lang/rust/commit/6af4fd385ec23145bc3ba08f700c61361ae961c0"}, {"sha": "12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "html_url": "https://github.com/rust-lang/rust/commit/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c"}], "stats": {"total": 441, "additions": 238, "deletions": 203}, "files": [{"sha": "9b13db2289e7ee25bc7ea0e491f0e8405c4c6e5a", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -187,7 +187,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n         self.walk_aggregate(mplace, fields)\n     }\n \n-    fn visit_primitive(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let ty = mplace.layout.ty;\n@@ -263,8 +263,11 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                     None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n                 }\n             }\n+            Ok(())\n+        } else {\n+            // Not a reference -- proceed recursively.\n+            self.walk_value(mplace)\n         }\n-        Ok(())\n     }\n }\n "}, {"sha": "263883d56399ad4f8d6120700fe8457bf65dbef5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 157, "deletions": 81, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -67,11 +67,12 @@ pub enum PathElem {\n     Field(Symbol),\n     Variant(Symbol),\n     GeneratorState(VariantIdx),\n-    ClosureVar(Symbol),\n+    CapturedVar(Symbol),\n     ArrayElem(usize),\n     TupleElem(usize),\n     Deref,\n-    Tag,\n+    EnumTag,\n+    GeneratorTag,\n     DynDowncast,\n }\n \n@@ -109,17 +110,18 @@ fn write_path(out: &mut String, path: &Vec<PathElem>) {\n     for elem in path.iter() {\n         match elem {\n             Field(name) => write!(out, \".{}\", name),\n-            Variant(name) => write!(out, \".<downcast-variant({})>\", name),\n+            EnumTag => write!(out, \".<enum-tag>\"),\n+            Variant(name) => write!(out, \".<enum-variant({})>\", name),\n+            GeneratorTag => write!(out, \".<generator-tag>\"),\n             GeneratorState(idx) => write!(out, \".<generator-state({})>\", idx.index()),\n-            ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n+            CapturedVar(name) => write!(out, \".<captured-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n             // some of the other items here also are not Rust syntax.  Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n             Deref => write!(out, \".<deref>\"),\n-            Tag => write!(out, \".<enum-tag>\"),\n             DynDowncast => write!(out, \".<dyn-downcast>\"),\n         }\n         .unwrap()\n@@ -170,6 +172,21 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&mut self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n+        // First, check if we are projecting to a variant.\n+        match layout.variants {\n+            layout::Variants::Multiple { discr_index, .. } => {\n+                if discr_index == field {\n+                    return match layout.ty.kind {\n+                        ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n+                        ty::Generator(..) => PathElem::GeneratorTag,\n+                        _ => bug!(\"non-variant type {:?}\", layout.ty),\n+                    };\n+                }\n+            }\n+            layout::Variants::Single { .. } => {}\n+        }\n+\n+        // Now we know we are projecting to a field, so figure out which one.\n         match layout.ty.kind {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n@@ -190,7 +207,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     }\n                 }\n \n-                PathElem::ClosureVar(name.unwrap_or_else(|| {\n+                PathElem::CapturedVar(name.unwrap_or_else(|| {\n                     // Fall back to showing the field index.\n                     sym::integer(field)\n                 }))\n@@ -201,13 +218,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n             // enums\n             ty::Adt(def, ..) if def.is_enum() => {\n-                // we might be projecting *to* a variant, or to a field *in*a variant.\n+                // we might be projecting *to* a variant, or to a field *in* a variant.\n                 match layout.variants {\n                     layout::Variants::Single { index } => {\n                         // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name)\n                     }\n-                    _ => bug!(),\n+                    layout::Variants::Multiple { .. } => bug!(\"we handled variants above\"),\n                 }\n             }\n \n@@ -288,62 +305,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n         Ok(())\n     }\n-}\n-\n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n-    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n-{\n-    type V = OpTy<'tcx, M::PointerTag>;\n-\n-    #[inline(always)]\n-    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n-        &self.ecx\n-    }\n-\n-    #[inline]\n-    fn visit_field(\n-        &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n-        field: usize,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        let elem = self.aggregate_field_path_elem(old_op.layout, field);\n-        self.visit_elem(new_op, elem)\n-    }\n-\n-    #[inline]\n-    fn visit_variant(\n-        &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n-        variant_id: VariantIdx,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        let name = match old_op.layout.ty.kind {\n-            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n-            // Generators also have variants\n-            ty::Generator(..) => PathElem::GeneratorState(variant_id),\n-            _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n-        };\n-        self.visit_elem(new_op, name)\n-    }\n-\n-    #[inline]\n-    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n-        // Translate some possible errors to something nicer.\n-        match self.walk_value(op) {\n-            Ok(()) => Ok(()),\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n-                }\n-                err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n-                }\n-                _ => Err(err),\n-            },\n-        }\n-    }\n \n     fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         let value = self.ecx.read_immediate(value)?;\n@@ -415,25 +376,25 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         );\n                         match err.kind {\n                             err_unsup!(InvalidNullPointerUsage) => {\n-                                throw_validation_failure!(\"NULL reference\", self.path)\n+                                throw_validation_failure!(\"a NULL reference\", self.path)\n                             }\n                             err_unsup!(AlignmentCheckFailed { required, has }) => {\n                                 throw_validation_failure!(\n                                     format_args!(\n-                                        \"unaligned reference \\\n-                                    (required {} byte alignment but found {})\",\n+                                        \"an unaligned reference \\\n+                                         (required {} byte alignment but found {})\",\n                                         required.bytes(),\n                                         has.bytes()\n                                     ),\n                                     self.path\n                                 )\n                             }\n                             err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                                \"dangling reference (created from integer)\",\n+                                \"a dangling reference (created from integer)\",\n                                 self.path\n                             ),\n                             _ => throw_validation_failure!(\n-                                \"dangling reference (not entirely in bounds)\",\n+                                \"a dangling reference (not entirely in bounds)\",\n                                 self.path\n                             ),\n                         }\n@@ -485,24 +446,21 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n                 // FIXME: Check if the signature matches\n             }\n-            // This should be all the primitive types\n+            // This should be all the (inhabited) primitive types\n             _ => bug!(\"Unexpected primitive type {}\", value.layout.ty),\n         }\n         Ok(())\n     }\n \n-    fn visit_uninhabited(&mut self) -> InterpResult<'tcx> {\n-        throw_validation_failure!(\"a value of an uninhabited type\", self.path)\n-    }\n-\n     fn visit_scalar(\n         &mut self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        layout: &layout::Scalar,\n+        scalar_layout: &layout::Scalar,\n     ) -> InterpResult<'tcx> {\n         let value = self.ecx.read_scalar(op)?;\n+        let valid_range = &scalar_layout.valid_range;\n+        let (lo, hi) = valid_range.clone().into_inner();\n         // Determine the allowed range\n-        let (lo, hi) = layout.valid_range.clone().into_inner();\n         // `max_hi` is as big as the size fits\n         let max_hi = u128::max_value() >> (128 - op.layout.size.bits());\n         assert!(hi <= max_hi);\n@@ -516,7 +474,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             value.not_undef(),\n             value,\n             self.path,\n-            format_args!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi),)\n+            format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi),)\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n@@ -528,7 +486,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             self.path,\n                             format_args!(\n                                 \"something that cannot possibly fail to be {}\",\n-                                wrapping_range_format(&layout.valid_range, max_hi)\n+                                wrapping_range_format(valid_range, max_hi)\n                             )\n                         )\n                     }\n@@ -541,23 +499,141 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         self.path,\n                         format_args!(\n                             \"something that cannot possibly fail to be {}\",\n-                            wrapping_range_format(&layout.valid_range, max_hi)\n+                            wrapping_range_format(valid_range, max_hi)\n                         )\n                     )\n                 }\n             }\n             Ok(data) => data,\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n-        if wrapping_range_contains(&layout.valid_range, bits) {\n+        if wrapping_range_contains(&valid_range, bits) {\n             Ok(())\n         } else {\n             throw_validation_failure!(\n                 bits,\n                 self.path,\n-                format_args!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi))\n+                format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi))\n+            )\n+        }\n+    }\n+}\n+\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n+{\n+    type V = OpTy<'tcx, M::PointerTag>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n+        &self.ecx\n+    }\n+\n+    #[inline]\n+    fn visit_field(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        field: usize,\n+        new_op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        let elem = self.aggregate_field_path_elem(old_op.layout, field);\n+        self.visit_elem(new_op, elem)\n+    }\n+\n+    #[inline]\n+    fn visit_variant(\n+        &mut self,\n+        old_op: OpTy<'tcx, M::PointerTag>,\n+        variant_id: VariantIdx,\n+        new_op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        let name = match old_op.layout.ty.kind {\n+            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n+            // Generators also have variants\n+            ty::Generator(..) => PathElem::GeneratorState(variant_id),\n+            _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n+        };\n+        self.visit_elem(new_op, name)\n+    }\n+\n+    #[inline(always)]\n+    fn visit_union(&mut self, _v: Self::V, fields: usize) -> InterpResult<'tcx> {\n+        // Empty unions are not accepted by rustc. That's great, it means we can\n+        // use that as a signal for detecting primitives.  Make sure\n+        // we did not miss any primitive.\n+        assert!(fields > 0);\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n+\n+        if op.layout.abi.is_uninhabited() {\n+            // Uninhabited types do not have sensible layout, stop right here.\n+            throw_validation_failure!(\n+                format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n+                self.path\n             )\n         }\n+\n+        // Check primitive types.  We do this after checking for uninhabited types,\n+        // to exclude fieldless enums (that also appear as fieldless unions here).\n+        // Primitives can have varying layout, so we check them separately and before aggregate\n+        // handling.\n+        // It is CRITICAL that we get this check right, or we might be validating the wrong thing!\n+        let primitive = match op.layout.fields {\n+            // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n+            // (Fieldless enums also appear here, but they are uninhabited and thus handled above.)\n+            layout::FieldPlacement::Union(0) => true,\n+            _ => op.layout.ty.builtin_deref(true).is_some(),\n+        };\n+        if primitive {\n+            // No need to recurse further or check scalar layout, this is a leaf type.\n+            return self.visit_primitive(op);\n+        }\n+\n+        // Recursively walk the type. Translate some possible errors to something nicer.\n+        match self.walk_value(op) {\n+            Ok(()) => {}\n+            Err(err) => match err.kind {\n+                err_ub!(InvalidDiscriminant(val)) => {\n+                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n+                }\n+                err_unsup!(ReadPointerAsBytes) => {\n+                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n+                }\n+                _ => return Err(err),\n+            },\n+        }\n+\n+        // *After* all of this, check the ABI.  We need to check the ABI to handle\n+        // types like `NonNull` where the `Scalar` info is more restrictive than what\n+        // the fields say (`rustc_layout_scalar_valid_range_start`).\n+        // But in most cases, this will just propagate what the fields say,\n+        // and then we want the error to point at the field -- so, first recurse,\n+        // then check ABI.\n+        //\n+        // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n+        // scalars, we do the same check on every \"level\" (e.g., first we check\n+        // MyNewtype and then the scalar in there).\n+        match op.layout.abi {\n+            layout::Abi::Uninhabited => unreachable!(), // checked above\n+            layout::Abi::Scalar(ref scalar_layout) => {\n+                self.visit_scalar(op, scalar_layout)?;\n+            }\n+            layout::Abi::ScalarPair { .. } | layout::Abi::Vector { .. } => {\n+                // These have fields that we already visited above, so we already checked\n+                // all their scalar-level restrictions.\n+                // There is also no equivalent to `rustc_layout_scalar_valid_range_start`\n+                // that would make skipping them here an issue.\n+            }\n+            layout::Abi::Aggregate { .. } => {\n+                // Nothing to do.\n+            }\n+        }\n+\n+        Ok(())\n     }\n \n     fn visit_aggregate("}, {"sha": "8808fc70cf76b05f5a9b9c8f46843e36f5d341a4", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 29, "deletions": 91, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -120,7 +120,7 @@ macro_rules! make_value_visitor {\n             }\n             /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n-            fn visit_union(&mut self, _v: Self::V) -> InterpResult<'tcx>\n+            fn visit_union(&mut self, _v: Self::V, _fields: usize) -> InterpResult<'tcx>\n             {\n                 Ok(())\n             }\n@@ -150,8 +150,9 @@ macro_rules! make_value_visitor {\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n-\n             /// Called when recursing into an enum variant.\n+            /// This gives the visitor the chance to track the stack of nested fields that\n+            /// we are descending through.\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n@@ -162,33 +163,6 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n-            /// Called whenever we reach a value with uninhabited layout.\n-            /// Recursing to fields will *always* continue after this!  This is not meant to control\n-            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n-            /// it is meant to provide the chance for additional checks when a value of uninhabited\n-            /// layout is detected.\n-            #[inline(always)]\n-            fn visit_uninhabited(&mut self) -> InterpResult<'tcx>\n-            { Ok(()) }\n-            /// Called whenever we reach a value with scalar layout.\n-            /// We do NOT provide a `ScalarMaybeUndef` here to avoid accessing memory if the\n-            /// visitor is not even interested in scalars.\n-            /// Recursing to fields will *always* continue after this!  This is not meant to control\n-            /// whether and how we descend recursively/ into the scalar's fields if there are any,\n-            /// it is meant to provide the chance for additional checks when a value of scalar\n-            /// layout is detected.\n-            #[inline(always)]\n-            fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> InterpResult<'tcx>\n-            { Ok(()) }\n-\n-            /// Called whenever we reach a value of primitive type. There can be no recursion\n-            /// below such a value. This is the leaf function.\n-            /// We do *not* provide an `ImmTy` here because some implementations might want\n-            /// to write to the place this primitive lives in.\n-            #[inline(always)]\n-            fn visit_primitive(&mut self, _v: Self::V) -> InterpResult<'tcx>\n-            { Ok(()) }\n-\n             // Default recursors. Not meant to be overloaded.\n             fn walk_aggregate(\n                 &mut self,\n@@ -204,23 +178,10 @@ macro_rules! make_value_visitor {\n             fn walk_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n-                // If this is a multi-variant layout, we have to find the right one and proceed with\n-                // that.\n-                match v.layout().variants {\n-                    layout::Variants::Multiple { .. } => {\n-                        let op = v.to_op(self.ecx())?;\n-                        let idx = self.ecx().read_discriminant(op)?.1;\n-                        let inner = v.project_downcast(self.ecx(), idx)?;\n-                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n-                        // recurse with the inner type\n-                        return self.visit_variant(v, idx, inner);\n-                    }\n-                    layout::Variants::Single { .. } => {}\n-                }\n \n-                // Even for single variants, we might be able to get a more refined type:\n-                // If it is a trait object, switch to the actual type that was used to create it.\n+                // Special treatment for special types, where the (static) layout is not sufficient.\n                 match v.layout().ty.kind {\n+                    // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n                         let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n@@ -229,56 +190,16 @@ macro_rules! make_value_visitor {\n                         // recurse with the inner type\n                         return self.visit_field(v, 0, Value::from_mem_place(inner));\n                     },\n-                    ty::Generator(..) => {\n-                        // FIXME: Generator layout is lying: it claims a whole bunch of fields exist\n-                        // when really many of them can be uninitialized.\n-                        // Just treat them as a union for now, until hopefully the layout\n-                        // computation is fixed.\n-                        return self.visit_union(v);\n-                    }\n+                    // Slices do not need special handling here: they have `Array` field\n+                    // placement with length 0, so we enter the `Array` case below which\n+                    // indirectly uses the metadata to determine the actual length.\n                     _ => {},\n                 };\n \n-                // If this is a scalar, visit it as such.\n-                // Things can be aggregates and have scalar layout at the same time, and that\n-                // is very relevant for `NonNull` and similar structs: We need to visit them\n-                // at their scalar layout *before* descending into their fields.\n-                // FIXME: We could avoid some redundant checks here. For newtypes wrapping\n-                // scalars, we do the same check on every \"level\" (e.g., first we check\n-                // MyNewtype and then the scalar in there).\n-                match v.layout().abi {\n-                    layout::Abi::Uninhabited => {\n-                        self.visit_uninhabited()?;\n-                    }\n-                    layout::Abi::Scalar(ref layout) => {\n-                        self.visit_scalar(v, layout)?;\n-                    }\n-                    // FIXME: Should we do something for ScalarPair? Vector?\n-                    _ => {}\n-                }\n-\n-                // Check primitive types.  We do this after checking the scalar layout,\n-                // just to have that done as well.  Primitives can have varying layout,\n-                // so we check them separately and before aggregate handling.\n-                // It is CRITICAL that we get this check right, or we might be\n-                // validating the wrong thing!\n-                let primitive = match v.layout().fields {\n-                    // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n-                    layout::FieldPlacement::Union(0) => true,\n-                    _ => v.layout().ty.builtin_deref(true).is_some(),\n-                };\n-                if primitive {\n-                    return self.visit_primitive(v);\n-                }\n-\n-                // Proceed into the fields.\n+                // Visit the fields of this value.\n                 match v.layout().fields {\n                     layout::FieldPlacement::Union(fields) => {\n-                        // Empty unions are not accepted by rustc. That's great, it means we can\n-                        // use that as an unambiguous signal for detecting primitives.  Make sure\n-                        // we did not miss any primitive.\n-                        assert!(fields > 0);\n-                        self.visit_union(v)\n+                        self.visit_union(v, fields)?;\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n@@ -288,18 +209,35 @@ macro_rules! make_value_visitor {\n                                 v.project_field(self.ecx(), i as u64)\n                             })\n                             .collect();\n-                        self.visit_aggregate(v, fields.into_iter())\n+                        self.visit_aggregate(v, fields.into_iter())?;\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n                         let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields.\n+                        // This uses the *run-time length*, i.e., if we are a slice,\n+                        // the dynamic info from the metadata is used.\n                         let iter = self.ecx().mplace_array_fields(mplace)?\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n-                        self.visit_aggregate(v, iter)\n+                        self.visit_aggregate(v, iter)?;\n+                    }\n+                }\n+\n+                match v.layout().variants {\n+                    // If this is a multi-variant layout, find the right variant and proceed\n+                    // with *its* fields.\n+                    layout::Variants::Multiple { .. } => {\n+                        let op = v.to_op(self.ecx())?;\n+                        let idx = self.ecx().read_discriminant(op)?.1;\n+                        let inner = v.project_downcast(self.ecx(), idx)?;\n+                        trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n+                        // recurse with the inner type\n+                        self.visit_variant(v, idx, inner)\n                     }\n+                    // For single-variant layouts, we already did anything there is to do.\n+                    layout::Variants::Single { .. } => Ok(())\n                 }\n             }\n         }"}, {"sha": "ffef38cedfc1751548da3f1759754a282a381221", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -871,8 +871,26 @@ impl Niche {\n \n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct LayoutDetails {\n-    pub variants: Variants,\n+    /// Says where the fields are located within the layout.\n+    /// Primitives and fieldless enums appear as unions without fields.\n     pub fields: FieldPlacement,\n+\n+    /// Encodes information about multi-variant layouts.\n+    /// Even with `Multiple` variants, a layout still has its own fields! Those are then\n+    /// shared between all variants. One of them will be the discriminant,\n+    /// but e.g. generators can have more.\n+    ///\n+    /// To access all fields of this layout, both `fields` and the fields of the active variant\n+    /// must be taken into account.\n+    pub variants: Variants,\n+\n+    /// The `abi` defines how this data is passed between functions, and it defines\n+    /// value restrictions via `valid_range`.\n+    ///\n+    /// Note that this is entirely orthogonal to the recursive structure defined by\n+    /// `variants` and `fields`; for example, `ManuallyDrop<Result<isize, isize>>` has\n+    /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants`\n+    /// have to be taken into account to find all fields of this layout.\n     pub abi: Abi,\n \n     /// The leaf scalar with the largest number of invalid values"}, {"sha": "e93a6887ba8f7c06fdb4cf415d342e4738aae6cb", "filename": "src/test/ui/consts/const-eval/transmute-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/transmute-const.rs:5:1\n    |\n LL | static FOO: bool = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "8c47d68e9686b757a7b6a7ec6970d54e0d494681", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -10,15 +10,15 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:26:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:29:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -34,39 +34,39 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:52:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:56:1\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:60:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:71:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<enum-variant(Some)>.0.1, but expected a valid unicode codepoint\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "ec0561870576f763a2c7cb1d2742e06ddd16f09b", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -44,7 +44,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:32:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .0, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "889579ca1ecefabe2f3a9ec62503e946f8256eb5", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -6,7 +6,7 @@ use std::mem;\n \n const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n //~^ ERROR it is undefined behavior to use this value\n-//~^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n+//~^^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n \n const NULL: &u16 = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value"}, {"sha": "5cef0a488ebd7e5c16bc9a4f10d8f44678c95621", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,15 +2,15 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:7:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:11:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -34,7 +34,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:23:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (created from integer)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (created from integer)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "4fef9aa84ea1916c99abedf6a8b202f0418fcbd6", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:15:1\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:18:1\n    |\n LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:21:1\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Bar; 1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "972c9eb38c81e1626197bd22856ad1ea17906c75", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered 0 at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n+   | |__^ type validation failed: encountered a NULL reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "4da9ad6c3327c4ac0ba62fee635c30f1b5cef486", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:86:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -50,7 +50,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -66,23 +66,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:125:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -122,7 +122,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:147:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "9d90d6e8548d886ead73763fca4ebfed9887c684", "filename": "src/test/ui/consts/const-eval/union-ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub.rs:31:1\n    |\n LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something less or equal to 1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "2a338e276402c16408cd9b59312447db58ea3f1d", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -20,7 +20,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_uninhabited_zsts.rs:17:1\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Empty; 3]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "203620a771b8f492c2e4acb3d46fe846765216c9", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c839a7b4c26e58319b0c40448dd423facff34cd0/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=c839a7b4c26e58319b0c40448dd423facff34cd0", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:3:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [!; 1] at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:7:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}