{"sha": "441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MWRmMjZmNWExZjc2ZWQwZWExODVjY2EyMmM2YjJjNmUxMzA3YjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-09T01:53:39Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T23:32:09Z"}, "message": "syntax: add support for #[deriving(Decodable)]", "tree": {"sha": "300393dcf5fcaeb53cf8ed2d38a7786993bc2176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/300393dcf5fcaeb53cf8ed2d38a7786993bc2176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "html_url": "https://github.com/rust-lang/rust/commit/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5841564bf9a9db012fc17d53da514ddf223dfaf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5841564bf9a9db012fc17d53da514ddf223dfaf5", "html_url": "https://github.com/rust-lang/rust/commit/5841564bf9a9db012fc17d53da514ddf223dfaf5"}], "stats": {"total": 517, "additions": 510, "deletions": 7}, "files": [{"sha": "b375adef9263d32bef39ad166d094526f45e4362", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "patch": "@@ -279,10 +279,10 @@ pub fn mk_lambda_(cx: @ext_ctxt,\n     mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n }\n pub fn mk_lambda(cx: @ext_ctxt,\n-                       span: span,\n-                       fn_decl: ast::fn_decl,\n-                       expr: @ast::expr)\n-                    -> @ast::expr {\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 expr: @ast::expr)\n+              -> @ast::expr {\n     let blk = mk_simple_block(cx, span, expr);\n     mk_lambda_(cx, span, fn_decl, blk)\n }\n@@ -294,6 +294,13 @@ pub fn mk_lambda_stmts(cx: @ext_ctxt,\n     let blk = mk_block(cx, span, ~[], stmts, None);\n     mk_lambda(cx, span, fn_decl, blk)\n }\n+pub fn mk_lambda_no_args(cx: @ext_ctxt,\n+                         span: span,\n+                         expr: @ast::expr)\n+                      -> @ast::expr {\n+    let fn_decl = mk_fn_decl(~[], mk_ty_infer(cx, span));\n+    mk_lambda(cx, span, fn_decl, expr)\n+}\n pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n@@ -303,11 +310,20 @@ pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_pat(cx: @ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n+pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n+    mk_pat(cx, span, ast::pat_wild)\n+}\n+pub fn mk_pat_lit(cx: @ext_ctxt,\n+                  span: span,\n+                  expr: @ast::expr) -> @ast::pat {\n+    mk_pat(cx, span, ast::pat_lit(expr))\n+}\n pub fn mk_pat_ident(cx: @ext_ctxt,\n                     span: span,\n                     ident: ast::ident) -> @ast::pat {\n     mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n }\n+\n pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n                                       span: span,\n                                       ident: ast::ident,\n@@ -435,8 +451,38 @@ pub fn mk_ty_param(cx: @ext_ctxt,\n }\n pub fn mk_lifetime(cx: @ext_ctxt,\n                    span: span,\n-                   ident: ast::ident) -> ast::Lifetime\n-{\n+                   ident: ast::ident)\n+                -> ast::Lifetime {\n     ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n }\n-\n+pub fn mk_arm(cx: @ext_ctxt,\n+              span: span,\n+              pats: ~[@ast::pat],\n+              expr: @ast::expr)\n+           -> ast::arm {\n+    ast::arm {\n+        pats: pats,\n+        guard: None,\n+        body: mk_simple_block(cx, span, expr)\n+    }\n+}\n+pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n+    let loc = cx.codemap().lookup_char_pos(span.lo);\n+    mk_call_global(\n+        cx,\n+        span,\n+        ~[\n+            cx.ident_of(~\"core\"),\n+            cx.ident_of(~\"sys\"),\n+            cx.ident_of(~\"begin_unwind\"),\n+        ],\n+        ~[\n+            mk_uniq_str(cx, span, ~\"internal error: entered unreachable code\"),\n+            mk_uniq_str(cx, span, loc.file.name),\n+            mk_uint(cx, span, loc.line),\n+        ]\n+    )\n+}\n+pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n+    mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n+}"}, {"sha": "11f492316e281768bf9f37024d2779c3807950e9", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "patch": "@@ -0,0 +1,454 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::*;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+use opt_vec;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_decodable(\n+    cx: @ext_ctxt,\n+    span: span,\n+    _mitem: @meta_item,\n+    in_items: ~[@item]\n+) -> ~[@item] {\n+    expand_deriving(\n+        cx,\n+        span,\n+        in_items,\n+        expand_deriving_decodable_struct_def,\n+        expand_deriving_decodable_enum_def\n+    )\n+}\n+\n+fn create_derived_decodable_impl(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    generics: &Generics,\n+    method: @method\n+) -> @item {\n+    let decoder_ty_param = build::mk_ty_param(\n+        cx,\n+        cx.ident_of(~\"__D\"),\n+        @opt_vec::with(\n+            build::mk_trait_ty_param_bound_global(\n+                cx,\n+                span,\n+                ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialize\"),\n+                    cx.ident_of(~\"Decoder\"),\n+                ]\n+            )\n+        )\n+    );\n+\n+    // All the type parameters need to bound to the trait.\n+    let generic_ty_params = opt_vec::with(decoder_ty_param);\n+\n+    let methods = [method];\n+    let trait_path = build::mk_raw_path_global_(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Decodable\")\n+        ],\n+        ~[\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\"))\n+        ]\n+    );\n+    create_derived_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        methods,\n+        trait_path,\n+        generic_ty_params\n+    )\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `decodable` method.\n+fn create_decode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ast::ident,\n+    generics: &Generics,\n+    expr: @ast::expr\n+) -> @method {\n+    // Create the `e` parameter.\n+    let d_arg_type = build::mk_ty_rptr(\n+        cx,\n+        span,\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n+        ast::m_imm\n+    );\n+    let d_ident = cx.ident_of(~\"__d\");\n+    let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = create_self_type_with_params(\n+        cx,\n+        span,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the function declaration.\n+    let inputs = ~[d_arg];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, expr);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_static, span: span };\n+    let method_ident = cx.ident_of(~\"decode\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_decode_method(\n+    cx: @ext_ctxt,\n+    span: span\n+) -> @ast::expr {\n+    // Call the substructure method.\n+    build::mk_call_(\n+        cx,\n+        span,\n+        build::mk_path_global(\n+            cx,\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialize\"),\n+                cx.ident_of(~\"Decodable\"),\n+                cx.ident_of(~\"decode\"),\n+            ]\n+        ),\n+        ~[\n+            build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")])\n+        ]\n+    )\n+}\n+\n+fn expand_deriving_decodable_struct_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_decodable_struct_method(\n+        cx,\n+        span,\n+        struct_def,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the implementation.\n+    create_derived_decodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_decodable_enum_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_decodable_enum_method(\n+        cx,\n+        span,\n+        enum_definition,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the implementation.\n+    create_derived_decodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn create_read_struct_field(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    ident: ident\n+) -> build::Field {\n+    // Call the substructure method.\n+    let decode_expr = call_substructure_decode_method(cx, span);\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_struct_field\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(ident)),\n+            build::mk_uint(cx, span, idx),\n+            build::mk_lambda_no_args(cx, span, decode_expr),\n+        ]\n+    );\n+\n+    build::Field { ident: ident, ex: call_expr }\n+}\n+\n+fn create_read_struct_arg(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    ident: ident\n+) -> build::Field {\n+    // Call the substructure method.\n+    let decode_expr = call_substructure_decode_method(cx, span);\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_struct_arg\"),\n+        ~[\n+            build::mk_uint(cx, span, idx),\n+            build::mk_lambda_no_args(cx, span, decode_expr),\n+        ]\n+    );\n+\n+    build::Field { ident: ident, ex: call_expr }\n+}\n+\n+fn expand_deriving_decodable_struct_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @method {\n+    // Create the body of the method.\n+    let mut i = 0;\n+    let mut fields = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                fields.push(create_read_struct_field(cx, span, i, ident));\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(\n+                    span,\n+                    ~\"unnamed fields with `deriving(Decodable)`\"\n+                );\n+            }\n+        }\n+        i += 1;\n+    }\n+\n+    let read_struct_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(\n+            cx,\n+            span,\n+            ~[cx.ident_of(~\"__d\")]\n+        ),\n+        cx.ident_of(~\"read_struct\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_uint(cx, span, fields.len()),\n+            build::mk_lambda_no_args(\n+                cx,\n+                span,\n+                build::mk_struct_e(\n+                    cx,\n+                    span,\n+                    ~[type_ident],\n+                    fields\n+                )\n+            ),\n+        ]\n+    );\n+\n+    // Create the method itself.\n+    create_decode_method(cx, span, type_ident, generics, read_struct_expr)\n+}\n+\n+fn create_read_variant_arg(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    variant: &ast::variant\n+) -> ast::arm {\n+    // Create the matching pattern.\n+    let pat = build::mk_pat_lit(cx, span, build::mk_uint(cx, span, idx));\n+\n+    // Feed each argument in this variant to the decode function\n+    // as well.\n+    let variant_arg_len = variant_arg_count(cx, span, variant);\n+\n+    let expr = if variant_arg_len == 0 {\n+        build::mk_path(cx, span, ~[variant.node.name])\n+    } else {\n+        // Feed the discriminant to the decode function.\n+        let mut args = ~[];\n+\n+        for uint::range(0, variant_arg_len) |j| {\n+            // Call the substructure method.\n+            let expr = call_substructure_decode_method(cx, span);\n+\n+            let call_expr = build::mk_method_call(\n+                cx,\n+                span,\n+                build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+                cx.ident_of(~\"read_enum_variant_arg\"),\n+                ~[\n+                    build::mk_uint(cx, span, j),\n+                    build::mk_lambda_no_args(cx, span, expr),\n+                ]\n+            );\n+\n+            args.push(call_expr);\n+        }\n+\n+        build::mk_call(\n+            cx,\n+            span,\n+            ~[variant.node.name],\n+            args\n+        )\n+    };\n+\n+    // Create the arm.\n+    build::mk_arm(cx, span, ~[pat], expr)\n+}\n+\n+fn create_read_enum_variant(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def\n+) -> @expr {\n+    // Create a vector that contains all the variant names.\n+    let expr_arm_names = build::mk_base_vec_e(\n+        cx,\n+        span,\n+        do enum_definition.variants.map |variant| {\n+            build::mk_base_str(\n+                cx,\n+                span,\n+                cx.str_of(variant.node.name)\n+            )\n+        }\n+    );\n+\n+    // Create the arms of the match in the method body.\n+    let mut arms = do enum_definition.variants.mapi |i, variant| {\n+        create_read_variant_arg(cx, span, i, variant)\n+    };\n+\n+    // Add the impossible case arm.\n+    arms.push(build::mk_unreachable_arm(cx, span));\n+\n+    // Create the read_enum_variant expression.\n+    build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_enum_variant\"),\n+        ~[\n+            expr_arm_names,\n+            build::mk_lambda(\n+                cx,\n+                span,\n+                build::mk_fn_decl(\n+                    ~[\n+                        build::mk_arg(\n+                            cx,\n+                            span,\n+                            cx.ident_of(~\"__i\"),\n+                            build::mk_ty_infer(cx, span)\n+                        )\n+                    ],\n+                    build::mk_ty_infer(cx, span)\n+                ),\n+                build::mk_expr(\n+                    cx,\n+                    span,\n+                    ast::expr_match(\n+                        build::mk_path(cx, span, ~[cx.ident_of(~\"__i\")]),\n+                        arms\n+                    )\n+                )\n+            )\n+        ]\n+    )\n+}\n+\n+fn expand_deriving_decodable_enum_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ast::ident,\n+    generics: &Generics\n+) -> @method {\n+    let read_enum_variant_expr = create_read_enum_variant(\n+        cx,\n+        span,\n+        enum_definition\n+    );\n+\n+    // Create the read_enum expression\n+    let read_enum_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_enum\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_lambda_no_args(cx, span, read_enum_variant_expr),\n+        ]\n+    );\n+\n+    // Create the method.\n+    create_decode_method(cx, span, type_ident, generics, read_enum_expr)\n+}"}, {"sha": "63106eae48ae852d4672f8573d8dd19ab799dcef", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441df26f5a1f76ed0ea185cca22c6b2c6e1307b1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=441df26f5a1f76ed0ea185cca22c6b2c6e1307b1", "patch": "@@ -34,6 +34,7 @@ pub mod clone;\n pub mod eq;\n pub mod iter_bytes;\n pub mod encodable;\n+pub mod decodable;\n \n type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n                                                   span,\n@@ -79,6 +80,8 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                                 titem.span, titem, in_items),\n                             ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n                                 titem.span, titem, in_items),\n+                            ~\"Decodable\" => decodable::expand_deriving_decodable(cx,\n+                                titem.span, titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));"}]}