{"sha": "1f34086e947139d498847dce49ba437748f17c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMzQwODZlOTQ3MTM5ZDQ5ODg0N2RjZTQ5YmE0Mzc3NDhmMTdjMmQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-22T18:20:47Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:35Z"}, "message": "Initial incorporation of specialization:\n\n- Rewrites the overlap checker to instead build up a specialization\n  graph, checking for overlap errors in the process.\n\n- Use the specialization order during impl selection.\n\nThis commit does not yet handle associated types correctly, and assumes\nthat all items are `default` and are overridden.", "tree": {"sha": "41fe1e95d615aee28a05ac32fb9794514371471b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41fe1e95d615aee28a05ac32fb9794514371471b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f34086e947139d498847dce49ba437748f17c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f34086e947139d498847dce49ba437748f17c2d", "html_url": "https://github.com/rust-lang/rust/commit/1f34086e947139d498847dce49ba437748f17c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f34086e947139d498847dce49ba437748f17c2d/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5849e4dff28784ec0c3d5ace090b1da9439ec1f", "html_url": "https://github.com/rust-lang/rust/commit/c5849e4dff28784ec0c3d5ace090b1da9439ec1f"}], "stats": {"total": 473, "additions": 254, "deletions": 219}, "files": [{"sha": "ece5819829baa67b05adbca4f30a3375dfeda7a7", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -51,7 +51,7 @@ could invalidate work done for other items. So, for example:\n    not shared state, because if it changes it does not itself\n    invalidate other functions (though it may be that it causes new\n    monomorphizations to occur, but that's handled independently).\n-   \n+\n Put another way: if the HIR for an item changes, we are going to\n recompile that item for sure. But we need the dep tracking map to tell\n us what *else* we have to recompile. Shared state is anything that is\n@@ -177,7 +177,7 @@ reads from `item`, there would be missing edges in the graph:\n       |                                 ^\n       |                                 |\n       +---------------------------------+ // added by `visit_all_items_in_krate`\n-    \n+\n In particular, the edge from `Hir(X)` to `ItemSignature(X)` is only\n present because we called `read` ourselves when entering the `ItemSignature(X)`\n task.\n@@ -273,8 +273,8 @@ should not exist.  In contrast, using the memoized helper, you get:\n     ... -> MapVariant(key) -> A\n                  |\n                  +----------> B\n-                 \n-which is much cleaner.                 \n+\n+which is much cleaner.\n \n **Be aware though that the closure is executed with `MapVariant(key)`\n pushed onto the stack as the current task!** That means that you must\n@@ -387,4 +387,3 @@ RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n-"}, {"sha": "6a4680ecbaf31a082b4d44b251319afc02e7b792", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -176,6 +176,7 @@ pub trait CrateStore<'tcx> : Any {\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n     fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                          -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n@@ -346,6 +347,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { unimplemented!() }\n     fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                          -> Vec<Rc<ty::AssociatedConst<'tcx>>> { unimplemented!() }\n+    fn impl_parent(&self, def: DefId) -> Option<DefId> { unimplemented!() }\n \n     // trait/impl-item info\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)"}, {"sha": "00c72d0b48ab051f236cf01141f2edc001134b57", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -23,8 +23,8 @@ use syntax::codemap::DUMMY_SP;\n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n-/// If there are types that satisfy both impls, returns an `ImplTy`\n-/// with those types substituted (by updating the given `infcx`)\n+/// If there are types that satisfy both impls, returns a suitably-freshened\n+/// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)\n@@ -85,7 +85,10 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n         return None\n     }\n \n-    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n+    let substituted = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let freshened = selcx.infcx().freshen(substituted);\n+\n+    Some(freshened)\n }\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool"}, {"sha": "cbb0cc5aed70438ed97aca45386314e206220540", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -50,6 +50,7 @@ pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n+pub use self::specialize::{Overlap, SpecializationGraph, specializes};\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n@@ -67,6 +68,7 @@ mod fulfill;\n mod project;\n mod object_safety;\n mod select;\n+mod specialize;\n mod structural_impls;\n mod util;\n "}, {"sha": "a5fe1191d3f0ca744f0aac96c2505163d1f90621", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 72, "deletions": 37, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -40,6 +40,7 @@ use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener, TypeOrigin};\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use middle::traits;\n use middle::ty::fast_reject;\n use middle::ty::relate::TypeRelation;\n \n@@ -224,6 +225,12 @@ struct SelectionCandidateSet<'tcx> {\n     ambiguous: bool,\n }\n \n+#[derive(PartialEq,Eq,Debug,Clone)]\n+struct EvaluatedCandidate<'tcx> {\n+    candidate: SelectionCandidate<'tcx>,\n+    evaluation: EvaluationResult,\n+}\n+\n enum BuiltinBoundConditions<'tcx> {\n     If(ty::Binder<Vec<Ty<'tcx>>>),\n     ParameterBuiltin,\n@@ -746,6 +753,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n+    // Treat negative impls as unimplemented\n+    fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n+                             -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let ImplCandidate(def_id) = candidate {\n+            if self.tcx().trait_impl_polarity(def_id) == Some(hir::ImplPolarity::Negative) {\n+                return Err(Unimplemented)\n+            }\n+        }\n+        Ok(Some(candidate))\n+    }\n+\n     fn candidate_from_obligation_no_cache<'o>(&mut self,\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n@@ -803,12 +821,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // we were to winnow, we'd wind up with zero candidates.\n         // Instead, we select the right impl now but report `Bar does\n         // not implement Clone`.\n-        if candidates.len() > 1 {\n-            candidates.retain(|c| self.evaluate_candidate(stack, c).may_apply())\n-        }\n+        if candidates.len() == 1 {\n+            return self.filter_negative_impls(candidates.pop().unwrap());\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization.\n+        let mut candidates: Vec<_> = candidates.into_iter().filter_map(|c| {\n+            let eval = self.evaluate_candidate(stack, &c);\n+            if eval.may_apply() {\n+                Some(EvaluatedCandidate {\n+                    candidate: c,\n+                    evaluation: eval,\n+                })\n+            } else {\n+                None\n+            }\n+        }).collect();\n \n-        // If there are STILL multiple candidate, we can further reduce\n-        // the list by dropping duplicates.\n+        // If there are STILL multiple candidate, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n@@ -850,19 +883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Just one candidate left.\n-        let candidate = candidates.pop().unwrap();\n-\n-        match candidate {\n-            ImplCandidate(def_id) => {\n-                match self.tcx().trait_impl_polarity(def_id) {\n-                    Some(hir::ImplPolarity::Negative) => return Err(Unimplemented),\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(Some(candidate))\n+        self.filter_negative_impls(candidates.pop().unwrap().candidate)\n     }\n \n     fn is_knowable<'o>(&mut self,\n@@ -1564,41 +1585,55 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// candidates and prefer where-clause candidates.\n     ///\n     /// See the comment for \"SelectionCandidate\" for more details.\n-    fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   victim: &SelectionCandidate<'tcx>,\n-                                                   other: &SelectionCandidate<'tcx>)\n-                                                   -> bool\n+    fn candidate_should_be_dropped_in_favor_of<'o>(\n+        &mut self,\n+        victim: &EvaluatedCandidate<'tcx>,\n+        other: &EvaluatedCandidate<'tcx>)\n+        -> bool\n     {\n-        if victim == other {\n+        if victim.candidate == other.candidate {\n             return true;\n         }\n \n-        match other {\n-            &ObjectCandidate |\n-            &ParamCandidate(_) | &ProjectionCandidate => match victim {\n-                &DefaultImplCandidate(..) => {\n+        match other.candidate {\n+            ObjectCandidate |\n+            ParamCandidate(_) | ProjectionCandidate => match victim.candidate {\n+                DefaultImplCandidate(..) => {\n                     self.tcx().sess.bug(\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\");\n                 }\n-                &ImplCandidate(..) |\n-                &ClosureCandidate(..) |\n-                &FnPointerCandidate |\n-                &BuiltinObjectCandidate |\n-                &BuiltinUnsizeCandidate |\n-                &DefaultImplObjectCandidate(..) |\n-                &BuiltinCandidate(..) => {\n+                ImplCandidate(..) |\n+                ClosureCandidate(..) |\n+                FnPointerCandidate |\n+                BuiltinObjectCandidate |\n+                BuiltinUnsizeCandidate |\n+                DefaultImplObjectCandidate(..) |\n+                BuiltinCandidate(..) => {\n                     // We have a where-clause so don't go around looking\n                     // for impls.\n                     true\n                 }\n-                &ObjectCandidate |\n-                &ProjectionCandidate => {\n+                ObjectCandidate |\n+                ProjectionCandidate => {\n                     // Arbitrarily give param candidates priority\n                     // over projection and object candidates.\n                     true\n                 },\n-                &ParamCandidate(..) => false,\n+                ParamCandidate(..) => false,\n+                ErrorCandidate => false // propagate errors\n+            },\n+            ImplCandidate(other_def) => {\n+                // See if we can toss out `victim` based on specialization.\n+                // This requires us to know *for sure* that the `other` impl applies\n+                // i.e. EvaluatedToOk:\n+                if other.evaluation == EvaluatedToOk {\n+                    if let ImplCandidate(victim_def) = victim.candidate {\n+                        return traits::specializes(self.infcx(), other_def, victim_def);\n+                    }\n+                }\n+\n+                false\n             },\n             _ => false\n         }"}, {"sha": "1e37600bc0449cacec00743c0963f4926539c23b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -381,7 +381,6 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     }\n }\n \n-\n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,"}, {"sha": "c336fd558bd563fa119caccc5dbdd3fd2ee36b9f", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -2456,8 +2456,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n             let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n+\n             // Record the trait->implementation mapping.\n-            def.record_impl(self, impl_def_id, trait_ref);\n+            if let Some(parent) = self.sess.cstore.impl_parent(impl_def_id) {\n+                def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n+            } else {\n+                def.record_remote_impl(self, impl_def_id, trait_ref, trait_id);\n+            }\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate."}, {"sha": "bbc5948f2cac71f5eff6c444a3f5aa29868ea8ba", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -1106,6 +1106,13 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn has_concrete_skeleton(&self) -> bool {\n+        match self.sty {\n+            TyParam(_) | TyInfer(_) | TyError => false,\n+            _ => true,\n+        }\n+    }\n+\n     // Returns the type and mutability of *ty.\n     //\n     // The parameter `explicit` indicates if this is an *explicit* dereference."}, {"sha": "a67b2d9fb1cfcf540e5d29e8420764da2558edd4", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -59,6 +59,9 @@ pub struct TraitDef<'tcx> {\n     /// Blanket impls associated with the trait.\n     blanket_impls: RefCell<Vec<DefId>>,\n \n+    /// The specialization order for impls of this trait.\n+    pub specialization_graph: RefCell<traits::SpecializationGraph>,\n+\n     /// Various flags\n     pub flags: Cell<TraitFlags>\n }\n@@ -78,7 +81,8 @@ impl<'tcx> TraitDef<'tcx> {\n             associated_type_names: associated_type_names,\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n-            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n+            specialization_graph: RefCell::new(traits::SpecializationGraph::new()),\n         }\n     }\n \n@@ -114,42 +118,80 @@ impl<'tcx> TraitDef<'tcx> {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_impl(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       impl_def_id: DefId,\n-                       impl_trait_ref: ty::TraitRef<'tcx>) {\n+    /// Records a basic trait-to-implementation mapping.\n+    ///\n+    /// Returns `true` iff the impl has not previously been recorded.\n+    fn record_impl(&self,\n+                   tcx: &TyCtxt<'tcx>,\n+                   impl_def_id: DefId,\n+                   impl_trait_ref: TraitRef<'tcx>) -> bool {\n         debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n                self, impl_trait_ref);\n \n-        // Record the write into the impl set, but only for local\n-        // impls: external impls are handled differently.\n-        if impl_def_id.is_local() {\n-            self.write_trait_impls(tcx);\n-        }\n-\n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n         if let Some(sty) = fast_reject::simplify_type(tcx,\n                                                       impl_trait_ref.self_ty(), false) {\n             if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n                 if is.contains(&impl_def_id) {\n-                    return // duplicate - skip\n+                    return false; // duplicate - skip\n                 }\n             }\n \n             self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n         } else {\n             if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return // duplicate - skip\n+                return false; // duplicate - skip\n             }\n             self.blanket_impls.borrow_mut().push(impl_def_id)\n         }\n+\n+        true\n+    }\n+\n+    /// Records a trait-to-implementation mapping for a crate-local impl.\n+    pub fn record_local_impl(&self,\n+                             tcx: &TyCtxt<'tcx>,\n+                             impl_def_id: DefId,\n+                             impl_trait_ref: TraitRef<'tcx>) {\n+        self.record_impl(tcx, impl_def_id, impl_trait_ref);\n+    }\n+\n+    /// Records a trait-to-implementation mapping for a non-local impl.\n+    ///\n+    /// The `parent_impl` is the immediately-less-specialized impl, or the\n+    /// trait's def ID if the impl is maximally-specialized -- information that\n+    /// should be pulled from the metadata.\n+    pub fn record_remote_impl(&self,\n+                              tcx: &TyCtxt<'tcx>,\n+                              impl_def_id: DefId,\n+                              impl_trait_ref: TraitRef<'tcx>,\n+                              parent_impl: DefId) {\n+        // if the impl has not previously been recorded\n+        if self.record_impl(tcx, impl_def_id, impl_trait_ref) {\n+            // if the impl is non-local, it's placed directly into the\n+            // specialization graph using parent information drawn from metadata.\n+            self.specialization_graph.borrow_mut()\n+                .record_impl_from_cstore(parent_impl, impl_def_id)\n+        }\n+    }\n+\n+    /// Adds a local impl into the specialization graph, returning an error with\n+    /// overlap information if the impl overlaps but does not specialize an\n+    /// existing impl.\n+    pub fn add_impl_for_specialization(&self,\n+                                       tcx: &ctxt<'tcx>,\n+                                       impl_def_id: DefId,\n+                                       impl_trait_ref: TraitRef<'tcx>)\n+                                       -> Result<(), traits::Overlap<'tcx>> {\n+        assert!(impl_def_id.is_local());\n+\n+        self.specialization_graph.borrow_mut()\n+            .insert(tcx, impl_def_id, impl_trait_ref)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n         self.read_trait_impls(tcx);\n-\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n@@ -223,4 +265,3 @@ bitflags! {\n         const IMPLS_VALID           = 1 << 3,\n     }\n }\n-"}, {"sha": "a0cbba279acc05e3bf88f440f085c425e3a96266", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -243,6 +243,8 @@ pub const tag_items_data_item_deprecation: usize = 0xa7;\n \n pub const tag_items_data_item_defaultness: usize = 0xa8;\n \n+pub const tag_items_data_parent_impl: usize = 0xa9;\n+\n pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!("}, {"sha": "2cd119cfc48be081d444945fe539524976ad2a06", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -225,6 +225,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n+    fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n+        let cdata = self.get_crate_data(impl_def.krate);\n+        decoder::get_parent_impl(&*cdata, impl_def.index)\n+    }\n+\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);"}, {"sha": "cf65d7a522ad1035ad27d0ae7eae084a002e1e69", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -34,6 +34,7 @@ use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n+use middle::traits;\n \n use rustc_const_eval::ConstInt;\n \n@@ -564,6 +565,13 @@ pub fn get_visibility(cdata: Cmd, id: DefIndex) -> hir::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n+pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n+    let item = cdata.lookup_item(id);\n+    reader::maybe_get_doc(item, tag_items_data_parent_impl).map(|doc| {\n+        translated_def_id(cdata, doc)\n+    })\n+}\n+\n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {"}, {"sha": "bbe9d0ea4c6095586b184a21898786b0fb496480", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -884,6 +884,12 @@ fn encode_deprecation(rbml_w: &mut Encoder, depr_opt: Option<attr::Deprecation>)\n     });\n }\n \n+fn encode_parent_impl(rbml_w: &mut Encoder, parent_opt: Option<DefId>) {\n+    parent_opt.map(|parent| {\n+        rbml_w.wr_tagged_u64(tag_items_data_parent_impl, def_to_u64(parent));\n+    });\n+}\n+\n fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n@@ -1161,8 +1167,12 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)) {\n+        let did = ecx.tcx.map.local_def_id(item.id);\n+        if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+            let parent = tcx.lookup_trait_def(trait_ref.def_id).parent_of_impl(did);\n+            encode_parent_impl(rbml_w, parent);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);"}, {"sha": "d62e7dd43f0817d318de35da60379fa27698c6d3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -15,7 +15,6 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-\n use middle::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n@@ -197,7 +196,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref, impl_def_id);\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n+        trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n     // Converts an implementation in the AST to a vector of items."}, {"sha": "47288e33ad615d52cae1bc785ce3b01cd9c9994a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 68, "deletions": 152, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -12,7 +12,7 @@\n //! same type. Likewise, no two inherent impls for a given type\n //! constructor provide a method with the same name.\n \n-use middle::cstore::{CrateStore, LOCAL_CRATE};\n+use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::traits;\n use middle::ty::{self, TyCtxt};\n@@ -50,121 +50,6 @@ struct OverlapChecker<'cx, 'tcx:'cx> {\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_overlapping_impls_of_trait(&mut self, trait_def_id: DefId) {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={:?})\",\n-               trait_def_id);\n-\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n-        if !self.traits_checked.insert(trait_def_id) {\n-            return;\n-        }\n-\n-        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-        self.tcx.populate_implementations_for_trait_if_necessary(\n-            trait_def.trait_ref.def_id);\n-\n-        // We should already know all impls of this trait, so these\n-        // borrows are safe.\n-        let (blanket_impls, nonblanket_impls) = trait_def.borrow_impl_lists(self.tcx);\n-\n-        // Conflicts can only occur between a blanket impl and another impl,\n-        // or between 2 non-blanket impls of the same kind.\n-\n-        for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n-            for &impl2_def_id in &blanket_impls[(i+1)..] {\n-                self.check_if_impls_overlap(impl1_def_id,\n-                                            impl2_def_id);\n-            }\n-\n-            for v in nonblanket_impls.values() {\n-                for &impl2_def_id in v {\n-                    self.check_if_impls_overlap(impl1_def_id,\n-                                                impl2_def_id);\n-                }\n-            }\n-        }\n-\n-        for impl_group in nonblanket_impls.values() {\n-            for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n-                for &impl2_def_id in &impl_group[(i+1)..] {\n-                    self.check_if_impls_overlap(impl1_def_id,\n-                                                impl2_def_id);\n-                }\n-            }\n-        }\n-    }\n-\n-    // We need to coherently pick which impl will be displayed\n-    // as causing the error message, and it must be the in the current\n-    // crate. Just pick the smaller impl in the file.\n-    fn order_impls(&self, impl1_def_id: DefId, impl2_def_id: DefId)\n-            -> Option<(DefId, DefId)> {\n-        if impl1_def_id.krate != LOCAL_CRATE {\n-            if impl2_def_id.krate != LOCAL_CRATE {\n-                // we don't need to check impls if both are external;\n-                // that's the other crate's job.\n-                None\n-            } else {\n-                Some((impl2_def_id, impl1_def_id))\n-            }\n-        } else if impl2_def_id.krate != LOCAL_CRATE {\n-            Some((impl1_def_id, impl2_def_id))\n-        } else if impl1_def_id < impl2_def_id {\n-            Some((impl1_def_id, impl2_def_id))\n-        } else {\n-            Some((impl2_def_id, impl1_def_id))\n-        }\n-    }\n-\n-    fn check_if_impls_overlap(&self,\n-                              impl1_def_id: DefId,\n-                              impl2_def_id: DefId)\n-    {\n-        if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n-            impl1_def_id, impl2_def_id)\n-        {\n-            debug!(\"check_if_impls_overlap({:?}, {:?})\",\n-                   impl1_def_id,\n-                   impl2_def_id);\n-\n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n-            if let Some(header) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                self.report_overlap_error(impl1_def_id, impl2_def_id, header.trait_ref.unwrap());\n-            }\n-        }\n-    }\n-\n-    fn report_overlap_error(&self,\n-                            impl1: DefId,\n-                            impl2: DefId,\n-                            trait_ref: ty::TraitRef)\n-    {\n-        // only print the Self type if it's concrete; otherwise, it's not adding much information.\n-        let self_type = {\n-            trait_ref.substs.self_ty().and_then(|ty| {\n-                if let ty::TyInfer(_) = ty.sty {\n-                    None\n-                } else {\n-                    Some(format!(\" for type `{}`\", ty))\n-                }\n-            }).unwrap_or(String::new())\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess, self.span_of_def_id(impl1), E0119,\n-                                       \"conflicting implementations of trait `{}`{}:\",\n-                                       trait_ref,\n-                                       self_type);\n-\n-        if impl2.is_local() {\n-            span_note!(&mut err, self.span_of_def_id(impl2),\n-                       \"conflicting implementation is here:\");\n-        } else {\n-            let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n-            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-        }\n-        err.emit();\n-    }\n-\n     fn span_of_def_id(&self, did: DefId) -> Span {\n         let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n         self.tcx.map.span(node_id)\n@@ -222,15 +107,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-\n impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemTrait(..) => {\n-                let trait_def_id = self.tcx.map.local_def_id(item.id);\n-                self.check_for_overlapping_impls_of_trait(trait_def_id);\n-            }\n-\n             hir::ItemEnum(..) | hir::ItemStruct(..) => {\n                 let type_def_id = self.tcx.map.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n@@ -246,47 +125,84 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 self.check_for_overlapping_impls_of_trait(trait_ref.def_id);\n \n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n-                match prev_default_impl {\n-                    Some(prev_id) => {\n-                        self.report_overlap_error(impl_def_id,\n-                                                  self.tcx.map.local_def_id(prev_id),\n-                                                  trait_ref);\n-                    }\n-                    None => { }\n+                if let Some(prev_id) = prev_default_impl {\n+                    span_err!(self.tcx.sess,\n+                              self.span_of_def_id(impl_def_id), E0519,\n+                              \"redundant default implementations of trait `{}`:\",\n+                              trait_ref);\n+                    span_note!(self.tcx.sess,\n+                               self.span_of_def_id(self.tcx.map.local_def_id(prev_id)),\n+                               \"redundant implementation is here:\");\n                 }\n             }\n-            hir::ItemImpl(_, _, _, Some(_), _, _) => {\n+            hir::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n-                self.check_for_overlapping_impls_of_trait(trait_def_id);\n-                match trait_ref.self_ty().sty {\n-                    ty::TyTrait(ref data) => {\n-                        // This is something like impl Trait1 for Trait2. Illegal\n-                        // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                        if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n-                            // This is an error, but it will be\n-                            // reported by wfcheck.  Ignore it\n-                            // here. This is tested by\n-                            // `coherence-impl-trait-for-trait-object-safe.rs`.\n-                        } else {\n-                            let mut supertrait_def_ids =\n-                                traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n-                            if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                                span_err!(self.tcx.sess, item.span, E0371,\n-                                          \"the object type `{}` automatically \\\n-                                           implements the trait `{}`\",\n-                                          trait_ref.self_ty(),\n-                                          self.tcx.item_path_str(trait_def_id));\n+                let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+\n+                let def = self.tcx.lookup_trait_def(trait_def_id);\n+\n+                // attempt to insert into the specialization graph\n+                let insert_result = def.add_impl_for_specialization(self.tcx,\n+                                                                    impl_def_id,\n+                                                                    trait_ref);\n+\n+                // insertion failed due to overlap\n+                if let Err(overlap) = insert_result {\n+                    // only print the Self type if it has at least some outer\n+                    // concrete shell; otherwise, it's not adding much\n+                    // information.\n+                    let self_type = {\n+                        overlap.on_trait_ref.substs.self_ty().and_then(|ty| {\n+                            if ty.has_concrete_skeleton() {\n+                                Some(format!(\" for type `{}`\", ty))\n+                            } else {\n+                                None\n                             }\n+                        }).unwrap_or(String::new())\n+                    };\n+\n+                    span_err!(self.tcx.sess, self.span_of_def_id(impl_def_id), E0119,\n+                              \"conflicting implementations of trait `{}`{}:\",\n+                              overlap.on_trait_ref,\n+                              self_type);\n+\n+                    if overlap.with_impl.is_local() {\n+                        span_note!(self.tcx.sess, self.span_of_def_id(overlap.with_impl),\n+                                   \"conflicting implementation is here:\");\n+                    } else {\n+                        let cname = self.tcx.sess.cstore.crate_name(overlap.with_impl.krate);\n+                        self.tcx.sess.note(&format!(\"conflicting implementation in crate `{}`\",\n+                                                    cname));\n+                    }\n+                }\n+\n+                // check for overlap with the automatic `impl Trait for Trait`\n+                if let ty::TyTrait(ref data) = trait_ref.self_ty().sty {\n+                    // This is something like impl Trait1 for Trait2. Illegal\n+                    // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n+\n+                    if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n+                        // This is an error, but it will be\n+                        // reported by wfcheck.  Ignore it\n+                        // here. This is tested by\n+                        // `coherence-impl-trait-for-trait-object-safe.rs`.\n+                    } else {\n+                        let mut supertrait_def_ids =\n+                            traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n+                        if supertrait_def_ids.any(|d| d == trait_def_id) {\n+                            span_err!(self.tcx.sess, item.span, E0371,\n+                                      \"the object type `{}` automatically \\\n+                                       implements the trait `{}`\",\n+                                      trait_ref.self_ty(),\n+                                      self.tcx.item_path_str(trait_def_id));\n                         }\n                     }\n-                    _ => { }\n                 }\n             }\n-            _ => {\n-            }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "4a8ce70ccb9262e1a94d518e2219226c772e7c96", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -69,6 +69,7 @@ use middle::resolve_lifetime;\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n+use middle::traits;\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use middle::ty::{VariantKind};"}, {"sha": "1a33a5a562a9aeb2c26e86dbb3e2605bc4fb30c8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f34086e947139d498847dce49ba437748f17c2d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1f34086e947139d498847dce49ba437748f17c2d", "patch": "@@ -3695,5 +3695,6 @@ register_diagnostics! {\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n     E0436, // functional record update requires a struct\n-    E0513  // no type for local variable ..\n+    E0513, // no type for local variable ..\n+    E0519  // redundant default implementations of trait\n }"}]}