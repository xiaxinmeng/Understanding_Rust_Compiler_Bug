{"sha": "0f98e75b69d16edce9ca60d7961b8440856a3f72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOThlNzViNjlkMTZlZGNlOWNhNjBkNzk2MWI4NDQwODU2YTNmNzI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-09T23:27:28Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:39Z"}, "message": "Runtime removal: refactor process\n\nThis patch continues the runtime removal by moving and refactoring the\nprocess implementation into the new `sys` module.\n\nBecause this eliminates APIs in `libnative` and `librustrt`, it is a:\n\n[breaking-change]\n\nThis functionality is likely to be available publicly, in some form,\nfrom `std` in the future.", "tree": {"sha": "c742de98f63f2ca7d2ac3236a35fcf6cbaa60f01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c742de98f63f2ca7d2ac3236a35fcf6cbaa60f01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f98e75b69d16edce9ca60d7961b8440856a3f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f98e75b69d16edce9ca60d7961b8440856a3f72", "html_url": "https://github.com/rust-lang/rust/commit/0f98e75b69d16edce9ca60d7961b8440856a3f72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f98e75b69d16edce9ca60d7961b8440856a3f72/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d195482a45bf3ed0f12dc9d70d14192262ca711", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d195482a45bf3ed0f12dc9d70d14192262ca711", "html_url": "https://github.com/rust-lang/rust/commit/3d195482a45bf3ed0f12dc9d70d14192262ca711"}], "stats": {"total": 1426, "additions": 1250, "deletions": 176}, "files": [{"sha": "29370dee88b4d6ea6e398f8310ed5a21c6c6031e", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -29,13 +29,6 @@ use std::os;\n use std::rt::rtio::{mod, IoResult, IoError};\n use std::num;\n \n-// Local re-exports\n-pub use self::process::Process;\n-\n-// Native I/O implementations\n-pub mod process;\n-mod util;\n-\n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n@@ -123,19 +116,6 @@ impl rtio::IoFactory for IoFactory {\n     fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n         timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer + Send>)\n     }\n-    fn spawn(&mut self, cfg: rtio::ProcessConfig)\n-            -> IoResult<(Box<rtio::RtioProcess + Send>,\n-                         Vec<Option<Box<rtio::RtioPipe + Send>>>)> {\n-        process::Process::spawn(cfg).map(|(p, io)| {\n-            (box p as Box<rtio::RtioProcess + Send>,\n-             io.into_iter().map(|p| p.map(|p| {\n-                 box p as Box<rtio::RtioPipe + Send>\n-             })).collect())\n-        })\n-    }\n-    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n-        process::Process::kill(pid, signum)\n-    }\n     #[cfg(unix)]\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n                 -> IoResult<Box<rtio::RtioTTY + Send>> {"}, {"sha": "cdcefc2088e7ceb842b794590cdbbfde1f05a430", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -46,61 +46,6 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n-/// Data needed to spawn a process. Serializes the `std::io::process::Command`\n-/// builder.\n-pub struct ProcessConfig<'a> {\n-    /// Path to the program to run.\n-    pub program: &'a CString,\n-\n-    /// Arguments to pass to the program (doesn't include the program itself).\n-    pub args: &'a [CString],\n-\n-    /// Optional environment to specify for the program. If this is None, then\n-    /// it will inherit the current process's environment.\n-    pub env: Option<&'a [(&'a CString, &'a CString)]>,\n-\n-    /// Optional working directory for the new process. If this is None, then\n-    /// the current directory of the running process is inherited.\n-    pub cwd: Option<&'a CString>,\n-\n-    /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// This field defaults to `CreatePipe(true, false)` so the input can be\n-    /// written to.\n-    pub stdin: StdioContainer,\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stdout: StdioContainer,\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 2).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stderr: StdioContainer,\n-\n-    /// Any number of streams/file descriptors/pipes may be attached to this\n-    /// process. This list enumerates the file descriptors and such for the\n-    /// process to be spawned, and the file descriptors inherited will start at\n-    /// 3 and go to the length of this array. The first three file descriptors\n-    /// (stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n-    /// `stderr` fields.\n-    pub extra_io: &'a [StdioContainer],\n-\n-    /// Sets the child process's user id. This translates to a `setuid` call in\n-    /// the child process. Setting this value on windows will cause the spawn to\n-    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n-    /// fail.\n-    pub uid: Option<uint>,\n-\n-    /// Similar to `uid`, but sets the group id of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    pub gid: Option<uint>,\n-\n-    /// If true, the child process is spawned in a detached state. On unix, this\n-    /// means that the child is the leader of a new process group.\n-    pub detach: bool,\n-}\n-\n pub struct LocalIo<'a> {\n     factory: &'a mut IoFactory+'a,\n }\n@@ -170,10 +115,6 @@ impl<'a> LocalIo<'a> {\n \n pub trait IoFactory {\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;\n-    fn spawn(&mut self, cfg: ProcessConfig)\n-            -> IoResult<(Box<RtioProcess + Send>,\n-                         Vec<Option<Box<RtioPipe + Send>>>)>;\n-    fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> IoResult<Box<RtioTTY + Send>>;\n }\n@@ -184,13 +125,6 @@ pub trait RtioTimer {\n     fn period(&mut self, msecs: u64, cb: Box<Callback + Send>);\n }\n \n-pub trait RtioProcess {\n-    fn id(&self) -> libc::pid_t;\n-    fn kill(&mut self, signal: int) -> IoResult<()>;\n-    fn wait(&mut self) -> IoResult<ProcessExit>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-}\n-\n pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n     fn write(&mut self, buf: &[u8]) -> IoResult<()>;"}, {"sha": "d71bab0b48f90724471b02becf21398a06dc530c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 150, "deletions": 78, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -20,14 +20,17 @@ use os;\n use io::{IoResult, IoError};\n use io;\n use libc;\n-use mem;\n-use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n-use rt::rtio;\n use c_str::CString;\n use collections::HashMap;\n use hash::Hash;\n #[cfg(windows)]\n use std::hash::sip::SipState;\n+use io::pipe::{PipeStream, PipePair};\n+use path::BytesContainer;\n+\n+use sys;\n+use sys::fs::FileDesc;\n+use sys::process::Process as ProcessImp;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -62,24 +65,29 @@ use std::hash::sip::SipState;\n /// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n-    handle: Box<RtioProcess + Send>,\n+    handle: ProcessImp,\n     forget: bool,\n \n+    /// None until wait() is called.\n+    exit_code: Option<ProcessExit>,\n+\n+    /// Manually delivered signal\n+    exit_signal: Option<int>,\n+\n+    /// Deadline after which wait() will return\n+    deadline: u64,\n+\n     /// Handle to the child's stdin, if the `stdin` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdin: Option<io::PipeStream>,\n+    pub stdin: Option<PipeStream>,\n \n     /// Handle to the child's stdout, if the `stdout` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdout: Option<io::PipeStream>,\n+    pub stdout: Option<PipeStream>,\n \n     /// Handle to the child's stderr, if the `stderr` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stderr: Option<io::PipeStream>,\n-\n-    /// Extra I/O handles as configured by the original `ProcessConfig` when\n-    /// this process was created. This is by default empty.\n-    pub extra_io: Vec<Option<io::PipeStream>>,\n+    pub stderr: Option<PipeStream>,\n }\n \n /// A representation of environment variable name\n@@ -130,6 +138,13 @@ impl PartialEq for EnvKey {\n     }\n }\n \n+impl BytesContainer for EnvKey {\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        let &EnvKey(ref k) = self;\n+        k.container_as_bytes()\n+    }\n+}\n+\n /// A HashMap representation of environment variables.\n pub type EnvMap = HashMap<EnvKey, CString>;\n \n@@ -160,7 +175,6 @@ pub struct Command {\n     stdin: StdioContainer,\n     stdout: StdioContainer,\n     stderr: StdioContainer,\n-    extra_io: Vec<StdioContainer>,\n     uid: Option<uint>,\n     gid: Option<uint>,\n     detach: bool,\n@@ -194,7 +208,6 @@ impl Command {\n             stdin: CreatePipe(true, false),\n             stdout: CreatePipe(false, true),\n             stderr: CreatePipe(false, true),\n-            extra_io: Vec::new(),\n             uid: None,\n             gid: None,\n             detach: false,\n@@ -281,14 +294,6 @@ impl Command {\n         self.stderr = cfg;\n         self\n     }\n-    /// Attaches a stream/file descriptor/pipe to the child process. Inherited\n-    /// file descriptors are numbered consecutively, starting at 3; the first\n-    /// three file descriptors (stdin/stdout/stderr) are configured with the\n-    /// `stdin`, `stdout`, and `stderr` methods.\n-    pub fn extra_io<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.extra_io.push(cfg);\n-        self\n-    }\n \n     /// Sets the child process's user id. This translates to a `setuid` call in\n     /// the child process. Setting this value on windows will cause the spawn to\n@@ -315,50 +320,23 @@ impl Command {\n \n     /// Executes the command as a child process, which is returned.\n     pub fn spawn(&self) -> IoResult<Process> {\n-        fn to_rtio(p: StdioContainer) -> rtio::StdioContainer {\n-            match p {\n-                Ignored => rtio::Ignored,\n-                InheritFd(fd) => rtio::InheritFd(fd),\n-                CreatePipe(a, b) => rtio::CreatePipe(a, b),\n-            }\n-        }\n-        let extra_io: Vec<rtio::StdioContainer> =\n-            self.extra_io.iter().map(|x| to_rtio(*x)).collect();\n-        LocalIo::maybe_raise(|io| {\n-            let env = match self.env {\n-                None => None,\n-                Some(ref env_map) =>\n-                    Some(env_map.iter()\n-                                .map(|(&EnvKey(ref key), val)| (key, val))\n-                                .collect::<Vec<_>>())\n-            };\n-            let cfg = ProcessConfig {\n-                program: &self.program,\n-                args: self.args.as_slice(),\n-                env: env.as_ref().map(|e| e.as_slice()),\n-                cwd: self.cwd.as_ref(),\n-                stdin: to_rtio(self.stdin),\n-                stdout: to_rtio(self.stdout),\n-                stderr: to_rtio(self.stderr),\n-                extra_io: extra_io.as_slice(),\n-                uid: self.uid,\n-                gid: self.gid,\n-                detach: self.detach,\n-            };\n-            io.spawn(cfg).map(|(p, io)| {\n-                let mut io = io.into_iter().map(|p| {\n-                    p.map(|p| io::PipeStream::new(p))\n-                });\n-                Process {\n-                    handle: p,\n-                    forget: false,\n-                    stdin: io.next().unwrap(),\n-                    stdout: io.next().unwrap(),\n-                    stderr: io.next().unwrap(),\n-                    extra_io: io.collect(),\n-                }\n+        let (their_stdin, our_stdin) = try!(setup_io(self.stdin));\n+        let (their_stdout, our_stdout) = try!(setup_io(self.stdout));\n+        let (their_stderr, our_stderr) = try!(setup_io(self.stderr));\n+\n+        match ProcessImp::spawn(self, their_stdin, their_stdout, their_stderr) {\n+            Err(e) => Err(e),\n+            Ok(handle) => Ok(Process {\n+                handle: handle,\n+                forget: false,\n+                exit_code: None,\n+                exit_signal: None,\n+                deadline: 0,\n+                stdin: our_stdin,\n+                stdout: our_stdout,\n+                stderr: our_stderr,\n             })\n-        }).map_err(IoError::from_rtio_error)\n+        }\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -415,6 +393,58 @@ impl fmt::Show for Command {\n     }\n }\n \n+fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> {\n+    let ours;\n+    let theirs;\n+    match io {\n+        Ignored => {\n+            theirs = None;\n+            ours = None;\n+        }\n+        InheritFd(fd) => {\n+            theirs = Some(PipeStream::from_filedesc(FileDesc::new(fd, false)));\n+            ours = None;\n+        }\n+        CreatePipe(readable, _writable) => {\n+            let PipePair { reader, writer } = try!(PipeStream::pair());\n+            if readable {\n+                theirs = Some(reader);\n+                ours = Some(writer);\n+            } else {\n+                theirs = Some(writer);\n+                ours = Some(reader);\n+            }\n+        }\n+    }\n+    Ok((theirs, ours))\n+}\n+\n+// Allow the sys module to get access to the Command state\n+impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n+    fn program(&self) -> &CString {\n+        &self.program\n+    }\n+    fn args(&self) -> &[CString] {\n+        self.args.as_slice()\n+    }\n+    fn env(&self) -> Option<&EnvMap> {\n+        self.env.as_ref()\n+    }\n+    fn cwd(&self) -> Option<&CString> {\n+        self.cwd.as_ref()\n+    }\n+    fn uid(&self) -> Option<uint> {\n+        self.uid.clone()\n+    }\n+    fn gid(&self) -> Option<uint> {\n+        self.gid.clone()\n+    }\n+    fn detach(&self) -> bool {\n+        self.detach\n+    }\n+\n+}\n+\n /// The output of a finished process.\n #[deriving(PartialEq, Eq, Clone)]\n pub struct ProcessOutput {\n@@ -494,9 +524,7 @@ impl Process {\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n     pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n-        LocalIo::maybe_raise(|io| {\n-            io.kill(id, signal)\n-        }).map_err(IoError::from_rtio_error)\n+        unsafe { ProcessImp::killpid(id, signal) }\n     }\n \n     /// Returns the process id of this child process\n@@ -518,7 +546,42 @@ impl Process {\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n-        self.handle.kill(signal).map_err(IoError::from_rtio_error)\n+        #[cfg(unix)] fn collect_status(p: &mut Process) {\n+            // On Linux (and possibly other unices), a process that has exited will\n+            // continue to accept signals because it is \"defunct\". The delivery of\n+            // signals will only fail once the child has been reaped. For this\n+            // reason, if the process hasn't exited yet, then we attempt to collect\n+            // their status with WNOHANG.\n+            if p.exit_code.is_none() {\n+                match p.handle.try_wait() {\n+                    Some(code) => { p.exit_code = Some(code); }\n+                    None => {}\n+                }\n+            }\n+        }\n+        #[cfg(windows)] fn collect_status(_p: &mut Process) {}\n+\n+        collect_status(self);\n+\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        if self.exit_code.is_some() {\n+            return Err(IoError {\n+                kind: io::InvalidInput,\n+                desc: \"invalid argument: can't kill an exited process\",\n+                detail: None,\n+            })\n+        }\n+\n+        // A successfully delivered signal that isn't 0 (just a poll for being\n+        // alive) is recorded for windows (see wait())\n+        match unsafe { self.handle.kill(signal) } {\n+            Ok(()) if signal == 0 => Ok(()),\n+            Ok(()) => { self.exit_signal = Some(signal); Ok(()) }\n+            Err(e) => Err(e),\n+        }\n+\n     }\n \n     /// Sends a signal to this child requesting that it exits. This is\n@@ -545,10 +608,21 @@ impl Process {\n     /// `set_timeout` and the timeout expires before the child exits.\n     pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n-        match self.handle.wait() {\n-            Ok(rtio::ExitSignal(s)) => Ok(ExitSignal(s)),\n-            Ok(rtio::ExitStatus(s)) => Ok(ExitStatus(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n+        match self.exit_code {\n+            Some(code) => Ok(code),\n+            None => {\n+                let code = try!(self.handle.wait(self.deadline));\n+                // On windows, waitpid will never return a signal. If a signal\n+                // was successfully delivered to the process, however, we can\n+                // consider it as having died via a signal.\n+                let code = match self.exit_signal {\n+                    None => code,\n+                    Some(signal) if cfg!(windows) => ExitSignal(signal),\n+                    Some(..) => code,\n+                };\n+                self.exit_code = Some(code);\n+                Ok(code)\n+            }\n         }\n     }\n \n@@ -594,7 +668,7 @@ impl Process {\n     /// ```\n     #[experimental = \"the type of the timeout is likely to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.handle.set_timeout(timeout_ms)\n+        self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n     }\n \n     /// Simultaneously wait for the child to exit and collect all remaining\n@@ -653,7 +727,6 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        drop(mem::replace(&mut self.extra_io, Vec::new()));\n \n         self.set_timeout(None);\n         let _ = self.wait().unwrap();\n@@ -1109,24 +1182,23 @@ mod tests {\n \n     #[test]\n     fn dont_close_fd_on_command_spawn() {\n-        use std::rt::rtio::{Truncate, Write};\n-        use self::native::io::file;\n+        use sys::fs;\n \n         let path = if cfg!(windows) {\n             Path::new(\"NUL\")\n         } else {\n             Path::new(\"/dev/null\")\n         };\n \n-        let mut fdes = match file::open(&path.to_c_str(), Truncate, Write) {\n+        let mut fdes = match fs::open(&path, Truncate, Write) {\n             Ok(f) => f,\n             Err(_) => panic!(\"failed to open file descriptor\"),\n         };\n \n         let mut cmd = pwd_cmd();\n         let _ = cmd.stdout(InheritFd(fdes.fd()));\n         assert!(cmd.status().unwrap().success());\n-        assert!(fdes.inner_write(\"extra write\\n\".as_bytes()).is_ok());\n+        assert!(fdes.write(\"extra write\\n\".as_bytes()).is_ok());\n     }\n \n     #[test]"}, {"sha": "87907fde2772afcb2a7fb2f64101fbc2f1e00bad", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -20,8 +20,6 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-#![macro_escape]\n-\n use mem;\n use rt::bookkeeping;\n use rt::mutex::StaticNativeMutex;\n@@ -57,15 +55,6 @@ pub struct Helper<M> {\n     pub initialized: UnsafeCell<bool>,\n }\n \n-macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n-        chan: ::std::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::std::cell::UnsafeCell { value: 0 },\n-        initialized: ::std::cell::UnsafeCell { value: false },\n-    };\n-) )\n-\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned."}, {"sha": "3dcd99859e8cf5cfe26801e88bc6313b64a48e14", "filename": "src/libstd/sys/unix/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "previous_filename": "src/libstd/platform_imp/unix/fs.rs"}, {"sha": "b404dc7fdbd299223cc37b983c7185b9990f4a13", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -17,7 +17,6 @@ use prelude::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n \n-\n macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n         lock: ::rt::mutex::NATIVE_MUTEX_INIT,\n@@ -34,6 +33,7 @@ pub mod tcp;\n pub mod udp;\n pub mod pipe;\n pub mod helper_signal;\n+pub mod process;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "0965d98d9b033e33fb1b34a380ad99e6bcbffbf6", "filename": "src/libstd/sys/unix/process.rs", "status": "added", "additions": 587, "deletions": 0, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -0,0 +1,587 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{mod, pid_t, c_void, c_int};\n+use c_str::CString;\n+use io::{mod, IoResult, IoError};\n+use mem;\n+use os;\n+use ptr;\n+use prelude::*;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use collections;\n+use path::BytesContainer;\n+use hash::Hash;\n+\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use sys_common::{AsFileDesc, mkerr_libc, timeout};\n+\n+pub use sys_common::ProcessConfig;\n+\n+helper_init!(static HELPER: Helper<Req>)\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pub pid: pid_t\n+}\n+\n+enum Req {\n+    NewChild(libc::pid_t, Sender<ProcessExit>, u64),\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> pid_t {\n+        self.pid\n+    }\n+\n+    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+        Process::killpid(self.pid, signal)\n+    }\n+\n+    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+        let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+        mkerr_libc(r)\n+    }\n+\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsFileDesc,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+        use libc::funcs::bsd44::getdtablesize;\n+\n+        mod rustrt {\n+            extern {\n+                pub fn rust_unset_sigprocmask();\n+            }\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        unsafe fn set_environ(envp: *const c_void) {\n+            extern { fn _NSGetEnviron() -> *mut *const c_void; }\n+\n+            *_NSGetEnviron() = envp;\n+        }\n+        #[cfg(not(target_os = \"macos\"))]\n+        unsafe fn set_environ(envp: *const c_void) {\n+            extern { static mut environ: *const c_void; }\n+            environ = envp;\n+        }\n+\n+        unsafe fn set_cloexec(fd: c_int) {\n+            let ret = c::ioctl(fd, c::FIOCLEX);\n+            assert_eq!(ret, 0);\n+        }\n+\n+        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        // temporary until unboxed closures land\n+        let cfg = unsafe {\n+            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n+        };\n+\n+        with_envp(cfg.env(), proc(envp) {\n+            with_argv(cfg.program(), cfg.args(), proc(argv) unsafe {\n+                let (input, mut output) = try!(sys::os::pipe());\n+\n+                // We may use this in the child, so perform allocations before the\n+                // fork\n+                let devnull = \"/dev/null\".to_c_str();\n+\n+                set_cloexec(output.fd());\n+\n+                let pid = fork();\n+                if pid < 0 {\n+                    return Err(super::last_error())\n+                } else if pid > 0 {\n+                    drop(output);\n+                    let mut bytes = [0, ..4];\n+                    return match input.read(bytes) {\n+                        Ok(4) => {\n+                            let errno = (bytes[0] as i32 << 24) |\n+                                        (bytes[1] as i32 << 16) |\n+                                        (bytes[2] as i32 <<  8) |\n+                                        (bytes[3] as i32 <<  0);\n+                            Err(super::decode_error(errno))\n+                        }\n+                        Err(..) => Ok(Process { pid: pid }),\n+                        Ok(..) => panic!(\"short read on the cloexec pipe\"),\n+                    };\n+                }\n+\n+                // And at this point we've reached a special time in the life of the\n+                // child. The child must now be considered hamstrung and unable to\n+                // do anything other than syscalls really. Consider the following\n+                // scenario:\n+                //\n+                //      1. Thread A of process 1 grabs the malloc() mutex\n+                //      2. Thread B of process 1 forks(), creating thread C\n+                //      3. Thread C of process 2 then attempts to malloc()\n+                //      4. The memory of process 2 is the same as the memory of\n+                //         process 1, so the mutex is locked.\n+                //\n+                // This situation looks a lot like deadlock, right? It turns out\n+                // that this is what pthread_atfork() takes care of, which is\n+                // presumably implemented across platforms. The first thing that\n+                // threads to *before* forking is to do things like grab the malloc\n+                // mutex, and then after the fork they unlock it.\n+                //\n+                // Despite this information, libnative's spawn has been witnessed to\n+                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+                // all collected backtraces point at malloc/free traffic in the\n+                // child spawned process.\n+                //\n+                // For this reason, the block of code below should contain 0\n+                // invocations of either malloc of free (or their related friends).\n+                //\n+                // As an example of not having malloc/free traffic, we don't close\n+                // this file descriptor by dropping the FileDesc (which contains an\n+                // allocation). Instead we just close it manually. This will never\n+                // have the drop glue anyway because this code never returns (the\n+                // child will either exec() or invoke libc::exit)\n+                let _ = libc::close(input.fd());\n+\n+                fn fail(output: &mut FileDesc) -> ! {\n+                    let errno = sys::os::errno();\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                    ];\n+                    assert!(output.write(bytes).is_ok());\n+                    unsafe { libc::_exit(1) }\n+                }\n+\n+                rustrt::rust_unset_sigprocmask();\n+\n+                // If a stdio file descriptor is set to be ignored (via a -1 file\n+                // descriptor), then we don't actually close it, but rather open\n+                // up /dev/null into that file descriptor. Otherwise, the first file\n+                // descriptor opened up in the child would be numbered as one of the\n+                // stdio file descriptors, which is likely to wreak havoc.\n+                let setup = |src: Option<P>, dst: c_int| {\n+                    let src = match src {\n+                        None => {\n+                            let flags = if dst == libc::STDIN_FILENO {\n+                                libc::O_RDONLY\n+                            } else {\n+                                libc::O_RDWR\n+                            };\n+                            libc::open(devnull.as_ptr(), flags, 0)\n+                        }\n+                        Some(obj) => {\n+                            let fd = obj.as_fd().fd();\n+                            // Leak the memory and the file descriptor. We're in the\n+                            // child now an all our resources are going to be\n+                            // cleaned up very soon\n+                            mem::forget(obj);\n+                            fd\n+                        }\n+                    };\n+                    src != -1 && retry(|| dup2(src, dst)) != -1\n+                };\n+\n+                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n+                // close all other fds\n+                for fd in range(3, getdtablesize()).rev() {\n+                    if fd != output.fd() {\n+                        let _ = close(fd as c_int);\n+                    }\n+                }\n+\n+                match cfg.gid() {\n+                    Some(u) => {\n+                        if libc::setgid(u as libc::gid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                match cfg.uid() {\n+                    Some(u) => {\n+                        // When dropping privileges from root, the `setgroups` call\n+                        // will remove any extraneous groups. If we don't call this,\n+                        // then even though our uid has dropped, we may still have\n+                        // groups that enable us to do super-user things. This will\n+                        // fail if we aren't root, so don't bother checking the\n+                        // return value, this is just done as an optimistic\n+                        // privilege dropping function.\n+                        extern {\n+                            fn setgroups(ngroups: libc::c_int,\n+                                         ptr: *const libc::c_void) -> libc::c_int;\n+                        }\n+                        let _ = setgroups(0, 0 as *const libc::c_void);\n+\n+                        if libc::setuid(u as libc::uid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                if cfg.detach() {\n+                    // Don't check the error of setsid because it fails if we're the\n+                    // process leader already. We just forked so it shouldn't return\n+                    // error, but ignore it anyway.\n+                    let _ = libc::setsid();\n+                }\n+                if !dirp.is_null() && chdir(dirp) == -1 {\n+                    fail(&mut output);\n+                }\n+                if !envp.is_null() {\n+                    set_environ(envp);\n+                }\n+                let _ = execvp(*argv, argv as *mut _);\n+                fail(&mut output);\n+            })\n+        })\n+    }\n+\n+    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n+        use std::cmp;\n+        use std::comm;\n+\n+        static mut WRITE_FD: libc::c_int = 0;\n+\n+        let mut status = 0 as c_int;\n+        if deadline == 0 {\n+            return match retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) }) {\n+                -1 => panic!(\"unknown waitpid error: {}\", super::last_error()),\n+                _ => Ok(translate_status(status)),\n+            }\n+        }\n+\n+        // On unix, wait() and its friends have no timeout parameters, so there is\n+        // no way to time out a thread in wait(). From some googling and some\n+        // thinking, it appears that there are a few ways to handle timeouts in\n+        // wait(), but the only real reasonable one for a multi-threaded program is\n+        // to listen for SIGCHLD.\n+        //\n+        // With this in mind, the waiting mechanism with a timeout barely uses\n+        // waitpid() at all. There are a few times that waitpid() is invoked with\n+        // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n+        // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n+        // that waitpid() is still used to actually reap the child.\n+        //\n+        // Signal handling is super tricky in general, and this is no exception. Due\n+        // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n+        // data out of the signal handler to the rest of the application. The first\n+        // idea would be to have each thread waiting with a timeout to read this\n+        // output file descriptor, but a write() is akin to a signal(), not a\n+        // broadcast(), so it would only wake up one thread, and possibly the wrong\n+        // thread. Hence a helper thread is used.\n+        //\n+        // The helper thread here is responsible for farming requests for a\n+        // waitpid() with a timeout, and then processing all of the wait requests.\n+        // By guaranteeing that only this helper thread is reading half of the\n+        // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n+        // is also responsible for select() to wait for incoming messages or\n+        // incoming SIGCHLD messages, along with passing an appropriate timeout to\n+        // select() to wake things up as necessary.\n+        //\n+        // The ordering of the following statements is also very purposeful. First,\n+        // we must be guaranteed that the helper thread is booted and available to\n+        // receive SIGCHLD signals, and then we must also ensure that we do a\n+        // nonblocking waitpid() at least once before we go ask the sigchld helper.\n+        // This prevents the race where the child exits, we boot the helper, and\n+        // then we ask for the child's exit status (never seeing a sigchld).\n+        //\n+        // The actual communication between the helper thread and this thread is\n+        // quite simple, just a channel moving data around.\n+\n+        unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+\n+        match self.try_wait() {\n+            Some(ret) => return Ok(ret),\n+            None => {}\n+        }\n+\n+        let (tx, rx) = channel();\n+        unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n+        return match rx.recv_opt() {\n+            Ok(e) => Ok(e),\n+            Err(()) => Err(timeout(\"wait timed out\")),\n+        };\n+\n+        // Register a new SIGCHLD handler, returning the reading half of the\n+        // self-pipe plus the old handler registered (return value of sigaction).\n+        //\n+        // Be sure to set up the self-pipe first because as soon as we register a\n+        // handler we're going to start receiving signals.\n+        fn register_sigchld() -> (libc::c_int, c::sigaction) {\n+            unsafe {\n+                let mut pipes = [0, ..2];\n+                assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n+                set_nonblocking(pipes[0], true).ok().unwrap();\n+                set_nonblocking(pipes[1], true).ok().unwrap();\n+                WRITE_FD = pipes[1];\n+\n+                let mut old: c::sigaction = mem::zeroed();\n+                let mut new: c::sigaction = mem::zeroed();\n+                new.sa_handler = sigchld_handler;\n+                new.sa_flags = c::SA_NOCLDSTOP;\n+                assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n+                (pipes[0], old)\n+            }\n+        }\n+\n+        // Helper thread for processing SIGCHLD messages\n+        fn waitpid_helper(input: libc::c_int,\n+                          messages: Receiver<Req>,\n+                          (read_fd, old): (libc::c_int, c::sigaction)) {\n+            set_nonblocking(input, true).ok().unwrap();\n+            let mut set: c::fd_set = unsafe { mem::zeroed() };\n+            let mut tv: libc::timeval;\n+            let mut active = Vec::<(libc::pid_t, Sender<ProcessExit>, u64)>::new();\n+            let max = cmp::max(input, read_fd) + 1;\n+\n+            'outer: loop {\n+                // Figure out the timeout of our syscall-to-happen. If we're waiting\n+                // for some processes, then they'll have a timeout, otherwise we\n+                // wait indefinitely for a message to arrive.\n+                //\n+                // FIXME: sure would be nice to not have to scan the entire array\n+                let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n+                    p.val1()\n+                });\n+                let (p, idx) = match min {\n+                    Some((idx, deadline)) => {\n+                        let now = sys::timer::now();\n+                        let ms = if now < deadline {deadline - now} else {0};\n+                        tv = ms_to_timeval(ms);\n+                        (&mut tv as *mut _, idx)\n+                    }\n+                    None => (ptr::null_mut(), -1),\n+                };\n+\n+                // Wait for something to happen\n+                c::fd_set(&mut set, input);\n+                c::fd_set(&mut set, read_fd);\n+                match unsafe { c::select(max, &mut set, ptr::null_mut(),\n+                                         ptr::null_mut(), p) } {\n+                    // interrupted, retry\n+                    -1 if os::errno() == libc::EINTR as uint => continue,\n+\n+                    // We read something, break out and process\n+                    1 | 2 => {}\n+\n+                    // Timeout, the pending request is removed\n+                    0 => {\n+                        drop(active.remove(idx));\n+                        continue\n+                    }\n+\n+                    n => panic!(\"error in select {} ({})\", os::errno(), n),\n+                }\n+\n+                // Process any pending messages\n+                if drain(input) {\n+                    loop {\n+                        match messages.try_recv() {\n+                            Ok(NewChild(pid, tx, deadline)) => {\n+                                active.push((pid, tx, deadline));\n+                            }\n+                            Err(comm::Disconnected) => {\n+                                assert!(active.len() == 0);\n+                                break 'outer;\n+                            }\n+                            Err(comm::Empty) => break,\n+                        }\n+                    }\n+                }\n+\n+                // If a child exited (somehow received SIGCHLD), then poll all\n+                // children to see if any of them exited.\n+                //\n+                // We also attempt to be responsible netizens when dealing with\n+                // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n+                // ignoring any previous SIGCHLD handler. Note that we don't provide\n+                // a 1:1 mapping of our handler invocations to the previous handler\n+                // invocations because we drain the `read_fd` entirely. This is\n+                // probably OK because the kernel is already allowed to coalesce\n+                // simultaneous signals, we're just doing some extra coalescing.\n+                //\n+                // Another point of note is that this likely runs the signal handler\n+                // on a different thread than the one that received the signal. I\n+                // *think* this is ok at this time.\n+                //\n+                // The main reason for doing this is to allow stdtest to run native\n+                // tests as well. Both libgreen and libnative are running around\n+                // with process timeouts, but libgreen should get there first\n+                // (currently libuv doesn't handle old signal handlers).\n+                if drain(read_fd) {\n+                    let i: uint = unsafe { mem::transmute(old.sa_handler) };\n+                    if i != 0 {\n+                        assert!(old.sa_flags & c::SA_SIGINFO == 0);\n+                        (old.sa_handler)(c::SIGCHLD);\n+                    }\n+\n+                    // FIXME: sure would be nice to not have to scan the entire\n+                    //        array...\n+                    active.retain(|&(pid, ref tx, _)| {\n+                        let pr = Process { pid: pid };\n+                        match pr.try_wait() {\n+                            Some(msg) => { tx.send(msg); false }\n+                            None => true,\n+                        }\n+                    });\n+                }\n+            }\n+\n+            // Once this helper thread is done, we re-register the old sigchld\n+            // handler and close our intermediate file descriptors.\n+            unsafe {\n+                assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::null_mut()), 0);\n+                let _ = libc::close(read_fd);\n+                let _ = libc::close(WRITE_FD);\n+                WRITE_FD = -1;\n+            }\n+        }\n+\n+        // Drain all pending data from the file descriptor, returning if any data\n+        // could be drained. This requires that the file descriptor is in\n+        // nonblocking mode.\n+        fn drain(fd: libc::c_int) -> bool {\n+            let mut ret = false;\n+            loop {\n+                let mut buf = [0u8, ..1];\n+                match unsafe {\n+                    libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n+                               buf.len() as libc::size_t)\n+                } {\n+                    n if n > 0 => { ret = true; }\n+                    0 => return true,\n+                    -1 if wouldblock() => return ret,\n+                    n => panic!(\"bad read {} ({})\", os::last_os_error(), n),\n+                }\n+            }\n+        }\n+\n+        // Signal handler for SIGCHLD signals, must be async-signal-safe!\n+        //\n+        // This function will write to the writing half of the \"self pipe\" to wake\n+        // up the helper thread if it's waiting. Note that this write must be\n+        // nonblocking because if it blocks and the reader is the thread we\n+        // interrupted, then we'll deadlock.\n+        //\n+        // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n+        // it. At that point we're guaranteed that there's something in the pipe\n+        // which will wake up the other end at some point, so we just allow this\n+        // signal to be coalesced with the pending signals on the pipe.\n+        extern fn sigchld_handler(_signum: libc::c_int) {\n+            let msg = 1i;\n+            match unsafe {\n+                libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n+            } {\n+                1 => {}\n+                -1 if wouldblock() => {} // see above comments\n+                n => panic!(\"bad error on write fd: {} {}\", n, os::errno()),\n+            }\n+        }\n+    }\n+\n+    pub fn try_wait(&self) -> Option<ProcessExit> {\n+        let mut status = 0 as c_int;\n+        match retry(|| unsafe {\n+            c::waitpid(self.pid, &mut status, c::WNOHANG)\n+        }) {\n+            n if n == self.pid => Some(translate_status(status)),\n+            0 => None,\n+            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n+                       super::last_error()),\n+        }\n+    }\n+}\n+\n+fn with_argv<T>(prog: &CString, args: &[CString],\n+                cb: proc(*const *const libc::c_char) -> T) -> T {\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n+\n+    // Convert the CStrings into an array of pointers. Note: the\n+    // lifetime of the various CStrings involved is guaranteed to be\n+    // larger than the lifetime of our invocation of cb, but this is\n+    // technically unsafe as the callback could leak these pointers\n+    // out of our scope.\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n+\n+    // Add a terminating null pointer (required by libc).\n+    ptrs.push(ptr::null());\n+\n+    cb(ptrs.as_ptr())\n+}\n+\n+fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: proc(*const c_void) -> T) -> T\n+    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+{\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\0\" strings. Since we must create\n+    // these strings locally, yet expose a raw pointer to them, we\n+    // create a temporary vector to own the CStrings that outlives the\n+    // call to cb.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = Vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.ref0().container_as_bytes());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.ref1().container_as_bytes());\n+                kv.push(0); // terminating null\n+                tmps.push(kv);\n+            }\n+\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*const libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                    .collect();\n+            ptrs.push(ptr::null());\n+\n+            cb(ptrs.as_ptr() as *const c_void)\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+fn translate_status(status: c_int) -> ProcessExit {\n+    #![allow(non_snake_case)]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"freebsd\",\n+              target_os = \"dragonfly\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n+    }\n+\n+    if imp::WIFEXITED(status) {\n+        ExitStatus(imp::WEXITSTATUS(status) as int)\n+    } else {\n+        ExitSignal(imp::WTERMSIG(status) as int)\n+    }\n+}"}, {"sha": "a07688b2fed03e0ece26ff4b01ab742620ec4368", "filename": "src/libstd/sys/windows/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "previous_filename": "src/libstd/platform_imp/windows/fs.rs"}, {"sha": "f50244701e474c2560b24b2ed9c6647ed9121ddc", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -40,6 +40,7 @@ pub mod tcp;\n pub mod udp;\n pub mod pipe;\n pub mod helper_signal;\n+pub mod process;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "67e87841ed24dc56af11dc74bbb57b826b232415", "filename": "src/libstd/sys/windows/process.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f98e75b69d16edce9ca60d7961b8440856a3f72/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=0f98e75b69d16edce9ca60d7961b8440856a3f72", "patch": "@@ -0,0 +1,511 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{pid_t, c_void, c_int};\n+use libc;\n+use c_str::CString;\n+use io;\n+use mem;\n+use os;\n+use ptr;\n+use prelude::*;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use collections;\n+use path::BytesContainer;\n+use hash::Hash;\n+use io::{IoResult, IoError};\n+\n+use sys::fs;\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use sys_common::{AsFileDesc, mkerr_libc, timeout};\n+\n+use io::fs::PathExtensions;\n+use string::String;\n+\n+pub use sys_common::ProcessConfig;\n+\n+/**\n+ * A value representing a child process.\n+ *\n+ * The lifetime of this value is linked to the lifetime of the actual\n+ * process - the Process destructor calls self.finish() which waits\n+ * for the process to terminate.\n+ */\n+pub struct Process {\n+    /// The unique id of the process (this should never be negative).\n+    pid: pid_t,\n+\n+    /// A HANDLE to the process, which will prevent the pid being\n+    /// re-used until the handle is closed.\n+    handle: *mut (),\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        free_handle(self.handle);\n+    }\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> pid_t {\n+        self.pid\n+    }\n+\n+    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+        Process::killpid(self.pid, signal)\n+    }\n+\n+    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+        let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n+                                       libc::PROCESS_QUERY_INFORMATION,\n+                                       libc::FALSE, pid as libc::DWORD);\n+        if handle.is_null() {\n+            return Err(super::last_error())\n+        }\n+        let ret = match signal {\n+            // test for existence on signal 0\n+            0 => {\n+                let mut status = 0;\n+                let ret = libc::GetExitCodeProcess(handle, &mut status);\n+                if ret == 0 {\n+                    Err(super::last_error())\n+                } else if status != libc::STILL_ACTIVE {\n+                    Err(IoError {\n+                        kind: io::InvalidInput,\n+                        desc: \"no process to kill\",\n+                        detail: None,\n+                    })\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+            15 | 9 => { // sigterm or sigkill\n+                let ret = libc::TerminateProcess(handle, 1);\n+                super::mkerr_winbool(ret)\n+            }\n+            _ => Err(IoError {\n+                kind: io::IoUnavailable,\n+                desc: \"unsupported signal on windows\",\n+                detail: None,\n+            })\n+        };\n+        let _ = libc::CloseHandle(handle);\n+        return ret;\n+    }\n+\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsFileDesc,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+        use libc::consts::os::extra::{\n+            TRUE, FALSE,\n+            STARTF_USESTDHANDLES,\n+            INVALID_HANDLE_VALUE,\n+            DUPLICATE_SAME_ACCESS\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            GetCurrentProcess,\n+            DuplicateHandle,\n+            CloseHandle,\n+            CreateProcessW\n+        };\n+        use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+        use mem;\n+        use iter::Iterator;\n+        use str::StrPrelude;\n+\n+        if cfg.gid().is_some() || cfg.uid().is_some() {\n+            return Err(IoError {\n+                kind: io::IoUnavailable,\n+                desc: \"unsupported gid/uid requested on windows\",\n+                detail: None,\n+            })\n+        }\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need to\n+        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        let program = cfg.env().and_then(|env| {\n+            for (key, v) in env.iter() {\n+                if b\"PATH\" != key.container_as_bytes() { continue }\n+\n+                // Split the value and test each path to see if the\n+                // program exists.\n+                for path in os::split_paths(v.container_as_bytes()).into_iter() {\n+                    let path = path.join(cfg.program().as_bytes_no_nul())\n+                                   .with_extension(os::consts::EXE_EXTENSION);\n+                    if path.exists() {\n+                        return Some(path.to_c_str())\n+                    }\n+                }\n+                break\n+            }\n+            None\n+        });\n+\n+        unsafe {\n+            let mut si = zeroed_startupinfo();\n+            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+            si.dwFlags = STARTF_USESTDHANDLES;\n+\n+            let cur_proc = GetCurrentProcess();\n+\n+            // Similarly to unix, we don't actually leave holes for the stdio file\n+            // descriptors, but rather open up /dev/null equivalents. These\n+            // equivalents are drawn from libuv's windows process spawning.\n+            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n+                          is_stdin: bool| {\n+                match *fd {\n+                    None => {\n+                        let access = if is_stdin {\n+                            libc::FILE_GENERIC_READ\n+                        } else {\n+                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                        };\n+                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                        let mut sa = libc::SECURITY_ATTRIBUTES {\n+                            nLength: size as libc::DWORD,\n+                            lpSecurityDescriptor: ptr::null_mut(),\n+                            bInheritHandle: 1,\n+                        };\n+                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                        filename.push(0);\n+                        *slot = libc::CreateFileW(filename.as_ptr(),\n+                                                  access,\n+                                                  libc::FILE_SHARE_READ |\n+                                                      libc::FILE_SHARE_WRITE,\n+                                                  &mut sa,\n+                                                  libc::OPEN_EXISTING,\n+                                                  0,\n+                                                  ptr::null_mut());\n+                        if *slot == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                    Some(ref fd) => {\n+                        let orig = get_osfhandle(fd.as_fd().fd()) as HANDLE;\n+                        if orig == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            };\n+\n+            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n+            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n+            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+\n+            let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program()),\n+                                            cfg.args());\n+            let mut pi = zeroed_process_information();\n+            let mut create_err = None;\n+\n+            // stolen from the libuv code.\n+            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+            if cfg.detach() {\n+                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+            }\n+\n+            with_envp(cfg.env(), |envp| {\n+                with_dirp(cfg.cwd(), |dirp| {\n+                    let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n+                    cmd_str.push(0);\n+                    let created = CreateProcessW(ptr::null(),\n+                                                 cmd_str.as_mut_ptr(),\n+                                                 ptr::null_mut(),\n+                                                 ptr::null_mut(),\n+                                                 TRUE,\n+                                                 flags, envp, dirp,\n+                                                 &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(super::last_error());\n+                    }\n+                })\n+            });\n+\n+            assert!(CloseHandle(si.hStdInput) != 0);\n+            assert!(CloseHandle(si.hStdOutput) != 0);\n+            assert!(CloseHandle(si.hStdError) != 0);\n+\n+            match create_err {\n+                Some(err) => return Err(err),\n+                None => {}\n+            }\n+\n+            // We close the thread handle because we don't care about keeping the\n+            // thread id valid, and we aren't keeping the thread handle around to be\n+            // able to close it later. We don't close the process handle however\n+            // because std::we want the process id to stay valid at least until the\n+            // calling code closes the process handle.\n+            assert!(CloseHandle(pi.hThread) != 0);\n+\n+            Ok(Process {\n+                pid: pi.dwProcessId as pid_t,\n+                handle: pi.hProcess as *mut ()\n+            })\n+        }\n+    }\n+\n+    /**\n+     * Waits for a process to exit and returns the exit code, failing\n+     * if there is no process with the specified id.\n+     *\n+     * Note that this is private to avoid race conditions on unix where if\n+     * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+     * and some_process.destroy() and some_process.finalize() will then either\n+     * operate on a none-existent process or, even worse, on a newer process\n+     * with the same id.\n+     */\n+    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_TIMEOUT,\n+            WAIT_OBJECT_0,\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject,\n+        };\n+\n+        unsafe {\n+            let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n+                                      FALSE,\n+                                      self.pid as DWORD);\n+            if process.is_null() {\n+                return Err(super::last_error())\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(process, &mut status) == FALSE {\n+                    let err = Err(super::last_error());\n+                    assert!(CloseHandle(process) != 0);\n+                    return err;\n+                }\n+                if status != STILL_ACTIVE {\n+                    assert!(CloseHandle(process) != 0);\n+                    return Ok(ExitStatus(status as int));\n+                }\n+                let interval = if deadline == 0 {\n+                    INFINITE\n+                } else {\n+                    let now = timer::now();\n+                    if deadline < now {0} else {(deadline - now) as u32}\n+                };\n+                match WaitForSingleObject(process, interval) {\n+                    WAIT_OBJECT_0 => {}\n+                    WAIT_TIMEOUT => {\n+                        assert!(CloseHandle(process) != 0);\n+                        return Err(timeout(\"process wait timed out\"))\n+                    }\n+                    _ => {\n+                        let err = Err(super::last_error());\n+                        assert!(CloseHandle(process) != 0);\n+                        return err\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::null_mut(),\n+        lpDesktop: ptr::null_mut(),\n+        lpTitle: ptr::null_mut(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::null_mut(),\n+        hStdInput: libc::INVALID_HANDLE_VALUE,\n+        hStdOutput: libc::INVALID_HANDLE_VALUE,\n+        hStdError: libc::INVALID_HANDLE_VALUE,\n+    }\n+}\n+\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::null_mut(),\n+        hThread: ptr::null_mut(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+fn make_command_line(prog: &CString, args: &[CString]) -> String {\n+    let mut cmd = String::new();\n+    append_arg(&mut cmd, prog.as_str()\n+                             .expect(\"expected program name to be utf-8 encoded\"));\n+    for arg in args.iter() {\n+        cmd.push(' ');\n+        append_arg(&mut cmd, arg.as_str()\n+                                .expect(\"expected argument to be utf-8 encoded\"));\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut String, arg: &str) {\n+        // If an argument has 0 characters then we need to quote it to ensure\n+        // that it actually gets passed through on the command line or otherwise\n+        // it will be dropped entirely when parsed on the other end.\n+        let quote = arg.chars().any(|c| c == ' ' || c == '\\t') || arg.len() == 0;\n+        if quote {\n+            cmd.push('\"');\n+        }\n+        let argvec: Vec<char> = arg.chars().collect();\n+        for i in range(0u, argvec.len()) {\n+            append_char_at(cmd, argvec.as_slice(), i);\n+        }\n+        if quote {\n+            cmd.push('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) {\n+        match arg[i] {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool {\n+        while i < s.len() && s[i] == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] == '\"';\n+    }\n+}\n+\n+fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: |*mut c_void| -> T) -> T\n+    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+{\n+    // On Windows we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = Vec::new();\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\",\n+                                 pair.ref0().container_as_str().unwrap(),\n+                                 pair.ref1().container_as_str().unwrap());\n+                blk.extend(kv.as_slice().utf16_units());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            cb(blk.as_mut_ptr() as *mut c_void)\n+        }\n+        _ => cb(ptr::null_mut())\n+    }\n+}\n+\n+fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n+    match d {\n+      Some(dir) => {\n+          let dir_str = dir.as_str()\n+                           .expect(\"expected workingdirectory to be utf-8 encoded\");\n+          let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n+          dir_str.push(0);\n+          cb(dir_str.as_ptr())\n+      },\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+fn free_handle(handle: *mut ()) {\n+    assert!(unsafe {\n+        libc::CloseHandle(mem::transmute(handle)) != 0\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_make_command_line() {\n+        use prelude::*;\n+        use str;\n+        use c_str::CString;\n+        use super::make_command_line;\n+\n+        fn test_wrapper(prog: &str, args: &[&str]) -> String {\n+            make_command_line(&prog.to_c_str(),\n+                              args.iter()\n+                                  .map(|a| a.to_c_str())\n+                                  .collect::<Vec<CString>>()\n+                                  .as_slice())\n+        }\n+\n+        assert_eq!(\n+            test_wrapper(\"prog\", [\"aaa\", \"bbb\", \"ccc\"]),\n+            \"prog aaa bbb ccc\".to_string()\n+        );\n+\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\"]),\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\"]),\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"echo\", [\"a b c\"]),\n+            \"echo \\\"a b c\\\"\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n+            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_string()\n+        );\n+    }\n+}"}]}