{"sha": "d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "node_id": "C_kwDOAAsO6NoAKGQwZDQwZDJhNDA3M2IxN2ExNGYzNjRkYzY2MzhmZWEyZmFlY2JjMmI", "commit": {"author": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-04-19T21:59:36Z"}, "committer": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-04-21T16:04:02Z"}, "message": "Break up long function in trait selection error reporting\n\n- Move blocks of code into their own functions\n- Replace a few function argument types with their type aliases", "tree": {"sha": "7d840a2795c2c2dd6ff576cf82b74aefaba1bd65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d840a2795c2c2dd6ff576cf82b74aefaba1bd65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "html_url": "https://github.com/rust-lang/rust/commit/d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/comments", "author": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "409661936f929b254ffc8adb644cf35d1f9765c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/409661936f929b254ffc8adb644cf35d1f9765c4", "html_url": "https://github.com/rust-lang/rust/commit/409661936f929b254ffc8adb644cf35d1f9765c4"}], "stats": {"total": 1089, "additions": 659, "deletions": 430}, "files": [{"sha": "fab9a8a5f4fbf430cd1da0de3f0de0b193f75f4d", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -300,8 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n-    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n-    {\n+    ) -> (traits::PredicateObligation<'tcx>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>) {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n             match param.kind {"}, {"sha": "8ce8b4e2024eb2686cefc5e6c4af5cb4b6b1da9c", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -123,7 +123,7 @@ pub struct FulfillmentError<'tcx> {\n #[derive(Clone)]\n pub enum FulfillmentErrorCode<'tcx> {\n     /// Inherently impossible to fulfill; this trait is implemented if and only if it is already implemented.\n-    CodeCycle(Vec<Obligation<'tcx, ty::Predicate<'tcx>>>),\n+    CodeCycle(Vec<PredicateObligation<'tcx>>),\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate"}, {"sha": "e82672e83687080eabc730df335dbaeeded1fd4b", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -591,7 +591,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     fn evaluate_nested_obligations(\n         &self,\n         ty: Ty<'_>,\n-        nested: impl Iterator<Item = Obligation<'tcx, ty::Predicate<'tcx>>>,\n+        nested: impl Iterator<Item = PredicateObligation<'tcx>>,\n         computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,"}, {"sha": "87b6092bd5d869fc40badd883300a1b63db82d10", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 653, "deletions": 424, "changes": 1077, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -713,29 +713,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             (message, note, append_const_msg)\n                         };\n \n-                        let err_msg = message\n-                            .and_then(|cannot_do_this| {\n-                                match (predicate_is_const, append_const_msg) {\n-                                    // do nothing if predicate is not const\n-                                    (false, _) => Some(cannot_do_this),\n-                                    // suggested using default post message\n-                                    (true, Some(None)) => {\n-                                        Some(format!(\"{cannot_do_this} in const contexts\"))\n-                                    }\n-                                    // overridden post message\n-                                    (true, Some(Some(post_message))) => {\n-                                        Some(format!(\"{cannot_do_this}{post_message}\"))\n-                                    }\n-                                    // fallback to generic message\n-                                    (true, None) => None,\n-                                }\n-                            })\n-                            .unwrap_or_else(|| {\n-                                format!(\n-                                    \"the trait bound `{}` is not satisfied{}\",\n-                                    trait_predicate, post_message,\n-                                )\n-                            });\n+                        let err_msg = self.get_standard_error_message(\n+                            &trait_predicate,\n+                            message,\n+                            predicate_is_const,\n+                            append_const_msg,\n+                            post_message,\n+                        );\n \n                         let (err_msg, safe_transmute_explanation) = if Some(trait_ref.def_id())\n                             == self.tcx.lang_items().transmute_trait()\n@@ -763,22 +747,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         }\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().tuple_trait() {\n-                            match obligation.cause.code().peel_derives() {\n-                                ObligationCauseCode::RustCall => {\n-                                    err.set_primary_message(\"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\");\n-                                }\n-                                ObligationCauseCode::BindingObligation(def_id, _)\n-                                | ObligationCauseCode::ItemObligation(def_id)\n-                                    if tcx.is_fn_trait(*def_id) =>\n-                                {\n-                                    err.code(rustc_errors::error_code!(E0059));\n-                                    err.set_primary_message(format!(\n-                                        \"type parameter to bare `{}` trait must be a tuple\",\n-                                        tcx.def_path_str(*def_id)\n-                                    ));\n-                                }\n-                                _ => {}\n-                            }\n+                            self.add_tuple_trait_message(\n+                                &obligation.cause.code().peel_derives(),\n+                                &mut err,\n+                            );\n                         }\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().drop_trait()\n@@ -788,33 +760,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             err.note(\"See <https://github.com/rust-lang/rust/pull/94901> for more details\");\n                         }\n \n-                        let explanation = if let ObligationCauseCode::MainFunctionType =\n-                            obligation.cause.code()\n-                        {\n-                            \"consider using `()`, or a `Result`\".to_owned()\n-                        } else {\n-                            let ty_desc = match trait_ref.skip_binder().self_ty().kind() {\n-                                ty::FnDef(_, _) => Some(\"fn item\"),\n-                                ty::Closure(_, _) => Some(\"closure\"),\n-                                _ => None,\n-                            };\n+                        let explanation = get_explanation_based_on_obligation(\n+                            &obligation,\n+                            trait_ref,\n+                            &trait_predicate,\n+                            pre_message,\n+                        );\n \n-                            match ty_desc {\n-                                Some(desc) => format!(\n-                                    \"{}the trait `{}` is not implemented for {} `{}`\",\n-                                    pre_message,\n-                                    trait_predicate.print_modifiers_and_trait_path(),\n-                                    desc,\n-                                    trait_ref.skip_binder().self_ty(),\n-                                ),\n-                                None => format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_predicate.print_modifiers_and_trait_path(),\n-                                    trait_ref.skip_binder().self_ty(),\n-                                ),\n-                            }\n-                        };\n                         self.check_for_binding_assigned_block_without_tail_expression(\n                             &obligation,\n                             &mut err,\n@@ -851,28 +803,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             self.suggest_borrowing_for_object_cast(&mut err, &root_obligation, *concrete_ty, *obj_ty);\n                         }\n \n-                        let mut unsatisfied_const = false;\n-                        if trait_predicate.is_const_if_const() && obligation.param_env.is_const() {\n-                            let non_const_predicate = trait_ref.without_const();\n-                            let non_const_obligation = Obligation {\n-                                cause: obligation.cause.clone(),\n-                                param_env: obligation.param_env.without_const(),\n-                                predicate: non_const_predicate.to_predicate(tcx),\n-                                recursion_depth: obligation.recursion_depth,\n-                            };\n-                            if self.predicate_may_hold(&non_const_obligation) {\n-                                unsatisfied_const = true;\n-                                err.span_note(\n-                                    span,\n-                                    &format!(\n-                                        \"the trait `{}` is implemented for `{}`, \\\n-                                        but that implementation is not `const`\",\n-                                        non_const_predicate.print_modifiers_and_trait_path(),\n-                                        trait_ref.skip_binder().self_ty(),\n-                                    ),\n-                                );\n-                            }\n-                        }\n+                        let UnsatisfiedConst(unsatisfied_const) = self\n+                            .maybe_add_note_for_unsatisfied_const(\n+                                &obligation,\n+                                trait_ref,\n+                                &trait_predicate,\n+                                &mut err,\n+                                span,\n+                            );\n \n                         if let Some((msg, span)) = type_def {\n                             err.span_label(span, &msg);\n@@ -970,137 +908,16 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let body_def_id = obligation.cause.body_id;\n-                        // Try to report a help message\n-                        if is_fn_trait\n-                            && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n-                            obligation.param_env,\n-                            trait_ref.self_ty(),\n-                            trait_predicate.skip_binder().constness,\n-                            trait_predicate.skip_binder().polarity,\n-                        )\n-                        {\n-                            // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n-                            // suggestion to add trait bounds for the type, since we only typically implement\n-                            // these traits once.\n-\n-                            // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n-                            // to implement.\n-                            let selected_kind =\n-                                self.tcx.fn_trait_kind_from_def_id(trait_ref.def_id())\n-                                    .expect(\"expected to map DefId to ClosureKind\");\n-                            if !implemented_kind.extends(selected_kind) {\n-                                err.note(\n-                                    &format!(\n-                                        \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n-                                        trait_ref.skip_binder().self_ty(),\n-                                        implemented_kind,\n-                                        selected_kind\n-                                    )\n-                                );\n-                            }\n-\n-                            // Note any argument mismatches\n-                            let given_ty = params.skip_binder();\n-                            let expected_ty = trait_ref.skip_binder().substs.type_at(1);\n-                            if let ty::Tuple(given) = given_ty.kind()\n-                                && let ty::Tuple(expected) = expected_ty.kind()\n-                            {\n-                                if expected.len() != given.len() {\n-                                    // Note number of types that were expected and given\n-                                    err.note(\n-                                        &format!(\n-                                            \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n-                                            given.len(),\n-                                            pluralize!(given.len()),\n-                                            expected.len(),\n-                                            pluralize!(expected.len()),\n-                                        )\n-                                    );\n-                                } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n-                                    // Print type mismatch\n-                                    let (expected_args, given_args) =\n-                                        self.cmp(given_ty, expected_ty);\n-                                    err.note_expected_found(\n-                                        &\"a closure with arguments\",\n-                                        expected_args,\n-                                        &\"a closure with arguments\",\n-                                        given_args,\n-                                    );\n-                                }\n-                            }\n-                        } else if !trait_ref.has_non_region_infer()\n-                            && self.predicate_can_apply(obligation.param_env, trait_predicate)\n-                        {\n-                            // If a where-clause may be useful, remind the\n-                            // user that they can add it.\n-                            //\n-                            // don't display an on-unimplemented note, as\n-                            // these notes will often be of the form\n-                            //     \"the type `T` can't be frobnicated\"\n-                            // which is somewhat confusing.\n-                            self.suggest_restricting_param_bound(\n-                                &mut err,\n-                                trait_predicate,\n-                                None,\n-                                obligation.cause.body_id,\n-                            );\n-                        } else if !suggested && !unsatisfied_const {\n-                            // Can't show anything else useful, try to find similar impls.\n-                            let impl_candidates = self.find_similar_impl_candidates(trait_predicate);\n-                            if !self.report_similar_impl_candidates(\n-                                &impl_candidates,\n-                                trait_ref,\n-                                body_def_id,\n-                                &mut err,\n-                                true,\n-                            ) {\n-                                // This is *almost* equivalent to\n-                                // `obligation.cause.code().peel_derives()`, but it gives us the\n-                                // trait predicate for that corresponding root obligation. This\n-                                // lets us get a derived obligation from a type parameter, like\n-                                // when calling `string.strip_suffix(p)` where `p` is *not* an\n-                                // implementer of `Pattern<'_>`.\n-                                let mut code = obligation.cause.code();\n-                                let mut trait_pred = trait_predicate;\n-                                let mut peeled = false;\n-                                while let Some((parent_code, parent_trait_pred)) = code.parent() {\n-                                    code = parent_code;\n-                                    if let Some(parent_trait_pred) = parent_trait_pred {\n-                                        trait_pred = parent_trait_pred;\n-                                        peeled = true;\n-                                    }\n-                                }\n-                                let def_id = trait_pred.def_id();\n-                                // Mention *all* the `impl`s for the *top most* obligation, the\n-                                // user might have meant to use one of them, if any found. We skip\n-                                // auto-traits or fundamental traits that might not be exactly what\n-                                // the user might expect to be presented with. Instead this is\n-                                // useful for less general traits.\n-                                if peeled\n-                                    && !self.tcx.trait_is_auto(def_id)\n-                                    && !self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n-                                {\n-                                    let trait_ref = trait_pred.to_poly_trait_ref();\n-                                    let impl_candidates =\n-                                        self.find_similar_impl_candidates(trait_pred);\n-                                    self.report_similar_impl_candidates(\n-                                        &impl_candidates,\n-                                        trait_ref,\n-                                        body_def_id,\n-                                        &mut err,\n-                                        true,\n-                                    );\n-                                }\n-                            }\n-\n-                            self.maybe_suggest_convert_to_slice(\n-                                &mut err,\n-                                trait_ref,\n-                                impl_candidates.as_slice(),\n-                                span,\n-                            );\n-                        }\n+                        self.try_to_add_help_message(\n+                            &obligation,\n+                            trait_ref,\n+                            &trait_predicate,\n+                            &mut err,\n+                            span,\n+                            is_fn_trait,\n+                            suggested,\n+                            unsatisfied_const,\n+                        );\n \n                         // Changing mutability doesn't make a difference to whether we have\n                         // an `Unsize` impl (Fixes ICE in #71036)\n@@ -1195,59 +1012,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                     ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n-                        let closure_span = self.tcx.def_span(closure_def_id);\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            closure_span,\n-                            E0525,\n-                            \"expected a closure that implements the `{}` trait, \\\n-                             but this closure only implements `{}`\",\n-                            kind,\n-                            found_kind\n-                        );\n-\n-                        err.span_label(\n-                            closure_span,\n-                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n-                        );\n-                        err.span_label(\n-                            obligation.cause.span,\n-                            format!(\"the requirement to implement `{}` derives from here\", kind),\n-                        );\n-\n-                        // Additional context information explaining why the closure only implements\n-                        // a particular trait.\n-                        if let Some(typeck_results) = &self.typeck_results {\n-                            let hir_id = self\n-                                .tcx\n-                                .hir()\n-                                .local_def_id_to_hir_id(closure_def_id.expect_local());\n-                            match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, place))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnOnce` because it moves the \\\n-                                         variable `{}` out of its environment\",\n-                                            ty::place_to_string_for_capture(tcx, place)\n-                                        ),\n-                                    );\n-                                }\n-                                (ty::ClosureKind::FnMut, Some((span, place))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnMut` because it mutates the \\\n-                                         variable `{}` here\",\n-                                            ty::place_to_string_for_capture(tcx, place)\n-                                        ),\n-                                    );\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-\n-                        err\n+                        self.report_closure_error(&obligation, closure_def_id, found_kind, kind)\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n@@ -1328,117 +1093,21 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 found_trait_ref,\n                 expected_trait_ref,\n                 terr @ TypeError::CyclicTy(_),\n-            ) => {\n-                let self_ty = found_trait_ref.self_ty().skip_binder();\n-                let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n-                    (\n-                        ObligationCause::dummy_with_span(tcx.def_span(def_id)),\n-                        TypeError::CyclicTy(self_ty),\n-                    )\n-                } else {\n-                    (obligation.cause.clone(), terr)\n-                };\n-                self.report_and_explain_type_error(\n-                    TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n-                    terr,\n-                )\n-            }\n+            ) => self.report_type_parameter_mismatch_cyclic_type_error(\n+                &obligation,\n+                found_trait_ref,\n+                expected_trait_ref,\n+                terr,\n+            ),\n             OutputTypeParameterMismatch(found_trait_ref, expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);\n-\n-                if expected_trait_ref.self_ty().references_error() {\n-                    return;\n-                }\n-\n-                let Some(found_trait_ty) = found_trait_ref.self_ty().no_bound_vars() else {\n-                    return;\n-                };\n-\n-                let found_did = match *found_trait_ty.kind() {\n-                    ty::Closure(did, _)\n-                    | ty::Foreign(did)\n-                    | ty::FnDef(did, _)\n-                    | ty::Generator(did, ..) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did()),\n-                    _ => None,\n-                };\n-\n-                let found_node = found_did.and_then(|did| self.tcx.hir().get_if_local(did));\n-                let found_span = found_did.and_then(|did| self.tcx.hir().span_if_local(did));\n-\n-                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n-                    // We check closures twice, with obligations flowing in different directions,\n-                    // but we want to complain about them only once.\n-                    return;\n-                }\n-\n-                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n-\n-                let mut not_tupled = false;\n-\n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind() {\n-                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n-                    _ => {\n-                        not_tupled = true;\n-                        vec![ArgKind::empty()]\n-                    }\n-                };\n-\n-                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind() {\n-                    ty::Tuple(ref tys) => {\n-                        tys.iter().map(|t| ArgKind::from_expected_ty(t, Some(span))).collect()\n-                    }\n-                    _ => {\n-                        not_tupled = true;\n-                        vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())]\n-                    }\n-                };\n-\n-                // If this is a `Fn` family trait and either the expected or found\n-                // is not tupled, then fall back to just a regular mismatch error.\n-                // This shouldn't be common unless manually implementing one of the\n-                // traits manually, but don't make it more confusing when it does\n-                // happen.\n-                if Some(expected_trait_ref.def_id()) != tcx.lang_items().gen_trait() && not_tupled {\n-                    self.report_and_explain_type_error(\n-                        TypeTrace::poly_trait_refs(\n-                            &obligation.cause,\n-                            true,\n-                            expected_trait_ref,\n-                            found_trait_ref,\n-                        ),\n-                        ty::error::TypeError::Mismatch,\n-                    )\n-                } else if found.len() == expected.len() {\n-                    self.report_closure_arg_mismatch(\n-                        span,\n-                        found_span,\n-                        found_trait_ref,\n-                        expected_trait_ref,\n-                        obligation.cause.code(),\n-                        found_node,\n-                        obligation.param_env,\n-                    )\n-                } else {\n-                    let (closure_span, closure_arg_span, found) = found_did\n-                        .and_then(|did| {\n-                            let node = self.tcx.hir().get_if_local(did)?;\n-                            let (found_span, closure_arg_span, found) =\n-                                self.get_fn_like_arguments(node)?;\n-                            Some((Some(found_span), closure_arg_span, found))\n-                        })\n-                        .unwrap_or((found_span, None, found));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span,\n-                        expected,\n-                        found,\n-                        found_trait_ty.is_closure(),\n-                        closure_arg_span,\n-                    )\n+                match self.report_type_parameter_mismatch_error(\n+                    &obligation,\n+                    span,\n+                    found_trait_ref,\n+                    expected_trait_ref,\n+                ) {\n+                    Some(err) => err,\n+                    None => return,\n                 }\n             }\n \n@@ -1453,45 +1122,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 )\n             }\n             SelectionError::NotConstEvaluatable(NotConstEvaluatable::MentionsParam) => {\n-                if !self.tcx.features().generic_const_exprs {\n-                    let mut err = self.tcx.sess.struct_span_err(\n-                        span,\n-                        \"constant expression depends on a generic parameter\",\n-                    );\n-                    // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                    // issue. However, this is currently not actually possible\n-                    // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                    //\n-                    // Note that with `feature(generic_const_exprs)` this case should not\n-                    // be reachable.\n-                    err.note(\"this may fail depending on what value the parameter takes\");\n-                    err.emit();\n-                    return;\n-                }\n-\n-                match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::ConstEvaluatable(ct) => {\n-                        let ty::ConstKind::Unevaluated(uv) = ct.kind() else {\n-                            bug!(\"const evaluatable failed for non-unevaluated const `{ct:?}`\");\n-                        };\n-                        let mut err =\n-                            self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n-                        let const_span = self.tcx.def_span(uv.def);\n-                        match self.tcx.sess.source_map().span_to_snippet(const_span) {\n-                            Ok(snippet) => err.help(&format!(\n-                                \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n-                                snippet\n-                            )),\n-                            _ => err.help(\"consider adding a `where` bound using this expression\"),\n-                        };\n-                        err\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            span,\n-                            \"unexpected non-ConstEvaluatable predicate, this should not be reachable\"\n-                        )\n-                    }\n+                match self.report_not_const_evaluatable_error(&obligation, span) {\n+                    Some(err) => err,\n+                    None => return,\n                 }\n             }\n \n@@ -1563,6 +1196,14 @@ trait InferCtxtPrivExt<'tcx> {\n         other: bool,\n     ) -> bool;\n \n+    fn report_similar_impl_candidates_for_root_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        body_def_id: LocalDefId,\n+        err: &mut Diagnostic,\n+    );\n+\n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n         &self,\n@@ -1626,12 +1267,86 @@ trait InferCtxtPrivExt<'tcx> {\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool;\n \n+    fn get_standard_error_message(\n+        &self,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        message: Option<String>,\n+        predicate_is_const: bool,\n+        append_const_msg: Option<Option<rustc_span::Symbol>>,\n+        post_message: String,\n+    ) -> String;\n+\n     fn get_safe_transmute_error_and_reason(\n         &self,\n-        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        obligation: PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n     ) -> (String, Option<String>);\n+\n+    fn add_tuple_trait_message(\n+        &self,\n+        obligation_cause_code: &ObligationCauseCode<'tcx>,\n+        err: &mut Diagnostic,\n+    );\n+\n+    fn try_to_add_help_message(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        is_fn_trait: bool,\n+        suggested: bool,\n+        unsatisfied_const: bool,\n+    );\n+\n+    fn add_help_message_for_fn_trait(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        err: &mut Diagnostic,\n+        implemented_kind: ty::ClosureKind,\n+        params: ty::Binder<'tcx, Ty<'tcx>>,\n+    );\n+\n+    fn maybe_add_note_for_unsatisfied_const(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+    ) -> UnsatisfiedConst;\n+\n+    fn report_closure_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        closure_def_id: DefId,\n+        found_kind: ty::ClosureKind,\n+        kind: ty::ClosureKind,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    fn report_type_parameter_mismatch_cyclic_type_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n+\n+    fn report_type_parameter_mismatch_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n+\n+    fn report_not_const_evaluatable_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n }\n \n impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n@@ -2195,6 +1910,51 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         report(normalized_impl_candidates, err)\n     }\n \n+    fn report_similar_impl_candidates_for_root_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_predicate: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+        body_def_id: LocalDefId,\n+        err: &mut Diagnostic,\n+    ) {\n+        // This is *almost* equivalent to\n+        // `obligation.cause.code().peel_derives()`, but it gives us the\n+        // trait predicate for that corresponding root obligation. This\n+        // lets us get a derived obligation from a type parameter, like\n+        // when calling `string.strip_suffix(p)` where `p` is *not* an\n+        // implementer of `Pattern<'_>`.\n+        let mut code = obligation.cause.code();\n+        let mut trait_pred = trait_predicate;\n+        let mut peeled = false;\n+        while let Some((parent_code, parent_trait_pred)) = code.parent() {\n+            code = parent_code;\n+            if let Some(parent_trait_pred) = parent_trait_pred {\n+                trait_pred = parent_trait_pred;\n+                peeled = true;\n+            }\n+        }\n+        let def_id = trait_pred.def_id();\n+        // Mention *all* the `impl`s for the *top most* obligation, the\n+        // user might have meant to use one of them, if any found. We skip\n+        // auto-traits or fundamental traits that might not be exactly what\n+        // the user might expect to be presented with. Instead this is\n+        // useful for less general traits.\n+        if peeled\n+            && !self.tcx.trait_is_auto(def_id)\n+            && !self.tcx.lang_items().iter().any(|(_, id)| id == def_id)\n+        {\n+            let trait_ref = trait_pred.to_poly_trait_ref();\n+            let impl_candidates = self.find_similar_impl_candidates(trait_pred);\n+            self.report_similar_impl_candidates(\n+                &impl_candidates,\n+                trait_ref,\n+                body_def_id,\n+                err,\n+                true,\n+            );\n+        }\n+    }\n+\n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n         &self,\n@@ -2917,10 +2677,38 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         false\n     }\n \n+    fn get_standard_error_message(\n+        &self,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        message: Option<String>,\n+        predicate_is_const: bool,\n+        append_const_msg: Option<Option<rustc_span::Symbol>>,\n+        post_message: String,\n+    ) -> String {\n+        message\n+            .and_then(|cannot_do_this| {\n+                match (predicate_is_const, append_const_msg) {\n+                    // do nothing if predicate is not const\n+                    (false, _) => Some(cannot_do_this),\n+                    // suggested using default post message\n+                    (true, Some(None)) => Some(format!(\"{cannot_do_this} in const contexts\")),\n+                    // overridden post message\n+                    (true, Some(Some(post_message))) => {\n+                        Some(format!(\"{cannot_do_this}{post_message}\"))\n+                    }\n+                    // fallback to generic message\n+                    (true, None) => None,\n+                }\n+            })\n+            .unwrap_or_else(|| {\n+                format!(\"the trait bound `{}` is not satisfied{}\", trait_predicate, post_message,)\n+            })\n+    }\n+\n     fn get_safe_transmute_error_and_reason(\n         &self,\n-        obligation: Obligation<'tcx, ty::Predicate<'tcx>>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        obligation: PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n     ) -> (String, Option<String>) {\n         // Erase regions because layout code doesn't particularly care about regions.\n@@ -2978,8 +2766,449 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             _ => span_bug!(span, \"Unsupported rustc_transmute::Reason variant\"),\n         }\n     }\n+\n+    fn add_tuple_trait_message(\n+        &self,\n+        obligation_cause_code: &ObligationCauseCode<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        match obligation_cause_code {\n+            ObligationCauseCode::RustCall => {\n+                err.set_primary_message(\"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\");\n+            }\n+            ObligationCauseCode::BindingObligation(def_id, _)\n+            | ObligationCauseCode::ItemObligation(def_id)\n+                if self.tcx.is_fn_trait(*def_id) =>\n+            {\n+                err.code(rustc_errors::error_code!(E0059));\n+                err.set_primary_message(format!(\n+                    \"type parameter to bare `{}` trait must be a tuple\",\n+                    self.tcx.def_path_str(*def_id)\n+                ));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn try_to_add_help_message(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        is_fn_trait: bool,\n+        suggested: bool,\n+        unsatisfied_const: bool,\n+    ) {\n+        let body_def_id = obligation.cause.body_id;\n+        // Try to report a help message\n+        if is_fn_trait\n+            && let Ok((implemented_kind, params)) = self.type_implements_fn_trait(\n+            obligation.param_env,\n+            trait_ref.self_ty(),\n+            trait_predicate.skip_binder().constness,\n+            trait_predicate.skip_binder().polarity,\n+        )\n+        {\n+            self.add_help_message_for_fn_trait(trait_ref, err, implemented_kind, params);\n+        } else if !trait_ref.has_non_region_infer()\n+            && self.predicate_can_apply(obligation.param_env, *trait_predicate)\n+        {\n+            // If a where-clause may be useful, remind the\n+            // user that they can add it.\n+            //\n+            // don't display an on-unimplemented note, as\n+            // these notes will often be of the form\n+            //     \"the type `T` can't be frobnicated\"\n+            // which is somewhat confusing.\n+            self.suggest_restricting_param_bound(\n+                err,\n+                *trait_predicate,\n+                None,\n+                obligation.cause.body_id,\n+            );\n+        } else if !suggested && !unsatisfied_const {\n+            // Can't show anything else useful, try to find similar impls.\n+            let impl_candidates = self.find_similar_impl_candidates(*trait_predicate);\n+            if !self.report_similar_impl_candidates(\n+                &impl_candidates,\n+                trait_ref,\n+                body_def_id,\n+                err,\n+                true,\n+            ) {\n+                self.report_similar_impl_candidates_for_root_obligation(&obligation, *trait_predicate, body_def_id, err);\n+            }\n+\n+            self.maybe_suggest_convert_to_slice(\n+                err,\n+                trait_ref,\n+                impl_candidates.as_slice(),\n+                span,\n+            );\n+        }\n+    }\n+\n+    fn add_help_message_for_fn_trait(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        err: &mut Diagnostic,\n+        implemented_kind: ty::ClosureKind,\n+        params: ty::Binder<'tcx, Ty<'tcx>>,\n+    ) {\n+        // If the type implements `Fn`, `FnMut`, or `FnOnce`, suppress the following\n+        // suggestion to add trait bounds for the type, since we only typically implement\n+        // these traits once.\n+\n+        // Note if the `FnMut` or `FnOnce` is less general than the trait we're trying\n+        // to implement.\n+        let selected_kind = self\n+            .tcx\n+            .fn_trait_kind_from_def_id(trait_ref.def_id())\n+            .expect(\"expected to map DefId to ClosureKind\");\n+        if !implemented_kind.extends(selected_kind) {\n+            err.note(&format!(\n+                \"`{}` implements `{}`, but it must implement `{}`, which is more general\",\n+                trait_ref.skip_binder().self_ty(),\n+                implemented_kind,\n+                selected_kind\n+            ));\n+        }\n+\n+        // Note any argument mismatches\n+        let given_ty = params.skip_binder();\n+        let expected_ty = trait_ref.skip_binder().substs.type_at(1);\n+        if let ty::Tuple(given) = given_ty.kind()\n+            && let ty::Tuple(expected) = expected_ty.kind()\n+        {\n+            if expected.len() != given.len() {\n+                // Note number of types that were expected and given\n+                err.note(\n+                    &format!(\n+                        \"expected a closure taking {} argument{}, but one taking {} argument{} was given\",\n+                        given.len(),\n+                        pluralize!(given.len()),\n+                        expected.len(),\n+                        pluralize!(expected.len()),\n+                    )\n+                );\n+            } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n+                // Print type mismatch\n+                let (expected_args, given_args) =\n+                    self.cmp(given_ty, expected_ty);\n+                err.note_expected_found(\n+                    &\"a closure with arguments\",\n+                    expected_args,\n+                    &\"a closure with arguments\",\n+                    given_args,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn maybe_add_note_for_unsatisfied_const(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+        err: &mut Diagnostic,\n+        span: Span,\n+    ) -> UnsatisfiedConst {\n+        let mut unsatisfied_const = UnsatisfiedConst(false);\n+        if trait_predicate.is_const_if_const() && obligation.param_env.is_const() {\n+            let non_const_predicate = trait_ref.without_const();\n+            let non_const_obligation = Obligation {\n+                cause: obligation.cause.clone(),\n+                param_env: obligation.param_env.without_const(),\n+                predicate: non_const_predicate.to_predicate(self.tcx),\n+                recursion_depth: obligation.recursion_depth,\n+            };\n+            if self.predicate_may_hold(&non_const_obligation) {\n+                unsatisfied_const = UnsatisfiedConst(true);\n+                err.span_note(\n+                    span,\n+                    &format!(\n+                        \"the trait `{}` is implemented for `{}`, \\\n+                        but that implementation is not `const`\",\n+                        non_const_predicate.print_modifiers_and_trait_path(),\n+                        trait_ref.skip_binder().self_ty(),\n+                    ),\n+                );\n+            }\n+        }\n+        unsatisfied_const\n+    }\n+\n+    fn report_closure_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        closure_def_id: DefId,\n+        found_kind: ty::ClosureKind,\n+        kind: ty::ClosureKind,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let closure_span = self.tcx.def_span(closure_def_id);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            closure_span,\n+            E0525,\n+            \"expected a closure that implements the `{}` trait, \\\n+                but this closure only implements `{}`\",\n+            kind,\n+            found_kind\n+        );\n+\n+        err.span_label(\n+            closure_span,\n+            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+        );\n+        err.span_label(\n+            obligation.cause.span,\n+            format!(\"the requirement to implement `{}` derives from here\", kind),\n+        );\n+\n+        // Additional context information explaining why the closure only implements\n+        // a particular trait.\n+        if let Some(typeck_results) = &self.typeck_results {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n+                (ty::ClosureKind::FnOnce, Some((span, place))) => {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"closure is `FnOnce` because it moves the \\\n+                            variable `{}` out of its environment\",\n+                            ty::place_to_string_for_capture(self.tcx, place)\n+                        ),\n+                    );\n+                }\n+                (ty::ClosureKind::FnMut, Some((span, place))) => {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"closure is `FnMut` because it mutates the \\\n+                            variable `{}` here\",\n+                            ty::place_to_string_for_capture(self.tcx, place)\n+                        ),\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        err\n+    }\n+\n+    fn report_type_parameter_mismatch_cyclic_type_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let self_ty = found_trait_ref.self_ty().skip_binder();\n+        let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n+            (\n+                ObligationCause::dummy_with_span(self.tcx.def_span(def_id)),\n+                TypeError::CyclicTy(self_ty),\n+            )\n+        } else {\n+            (obligation.cause.clone(), terr)\n+        };\n+        self.report_and_explain_type_error(\n+            TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n+            terr,\n+        )\n+    }\n+\n+    fn report_type_parameter_mismatch_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+        found_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        expected_trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n+        let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);\n+\n+        if expected_trait_ref.self_ty().references_error() {\n+            return None;\n+        }\n+\n+        let Some(found_trait_ty) = found_trait_ref.self_ty().no_bound_vars() else {\n+            return None;\n+        };\n+\n+        let found_did = match *found_trait_ty.kind() {\n+            ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) | ty::Generator(did, ..) => {\n+                Some(did)\n+            }\n+            ty::Adt(def, _) => Some(def.did()),\n+            _ => None,\n+        };\n+\n+        let found_node = found_did.and_then(|did| self.tcx.hir().get_if_local(did));\n+        let found_span = found_did.and_then(|did| self.tcx.hir().span_if_local(did));\n+\n+        if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+            // We check closures twice, with obligations flowing in different directions,\n+            // but we want to complain about them only once.\n+            return None;\n+        }\n+\n+        self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+        let mut not_tupled = false;\n+\n+        let found = match found_trait_ref.skip_binder().substs.type_at(1).kind() {\n+            ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+            _ => {\n+                not_tupled = true;\n+                vec![ArgKind::empty()]\n+            }\n+        };\n+\n+        let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+        let expected = match expected_ty.kind() {\n+            ty::Tuple(ref tys) => {\n+                tys.iter().map(|t| ArgKind::from_expected_ty(t, Some(span))).collect()\n+            }\n+            _ => {\n+                not_tupled = true;\n+                vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())]\n+            }\n+        };\n+\n+        // If this is a `Fn` family trait and either the expected or found\n+        // is not tupled, then fall back to just a regular mismatch error.\n+        // This shouldn't be common unless manually implementing one of the\n+        // traits manually, but don't make it more confusing when it does\n+        // happen.\n+        Some(\n+            if Some(expected_trait_ref.def_id()) != self.tcx.lang_items().gen_trait() && not_tupled\n+            {\n+                self.report_and_explain_type_error(\n+                    TypeTrace::poly_trait_refs(\n+                        &obligation.cause,\n+                        true,\n+                        expected_trait_ref,\n+                        found_trait_ref,\n+                    ),\n+                    ty::error::TypeError::Mismatch,\n+                )\n+            } else if found.len() == expected.len() {\n+                self.report_closure_arg_mismatch(\n+                    span,\n+                    found_span,\n+                    found_trait_ref,\n+                    expected_trait_ref,\n+                    obligation.cause.code(),\n+                    found_node,\n+                    obligation.param_env,\n+                )\n+            } else {\n+                let (closure_span, closure_arg_span, found) = found_did\n+                    .and_then(|did| {\n+                        let node = self.tcx.hir().get_if_local(did)?;\n+                        let (found_span, closure_arg_span, found) =\n+                            self.get_fn_like_arguments(node)?;\n+                        Some((Some(found_span), closure_arg_span, found))\n+                    })\n+                    .unwrap_or((found_span, None, found));\n+\n+                self.report_arg_count_mismatch(\n+                    span,\n+                    closure_span,\n+                    expected,\n+                    found,\n+                    found_trait_ty.is_closure(),\n+                    closure_arg_span,\n+                )\n+            },\n+        )\n+    }\n+\n+    fn report_not_const_evaluatable_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        span: Span,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        if !self.tcx.features().generic_const_exprs {\n+            let mut err = self\n+                .tcx\n+                .sess\n+                .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+            // FIXME(const_generics): we should suggest to the user how they can resolve this\n+            // issue. However, this is currently not actually possible\n+            // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+            //\n+            // Note that with `feature(generic_const_exprs)` this case should not\n+            // be reachable.\n+            err.note(\"this may fail depending on what value the parameter takes\");\n+            err.emit();\n+            return None;\n+        }\n+\n+        match obligation.predicate.kind().skip_binder() {\n+            ty::PredicateKind::ConstEvaluatable(ct) => {\n+                let ty::ConstKind::Unevaluated(uv) = ct.kind() else {\n+                    bug!(\"const evaluatable failed for non-unevaluated const `{ct:?}`\");\n+                };\n+                let mut err = self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n+                let const_span = self.tcx.def_span(uv.def);\n+                match self.tcx.sess.source_map().span_to_snippet(const_span) {\n+                    Ok(snippet) => err.help(&format!(\n+                        \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n+                        snippet\n+                    )),\n+                    _ => err.help(\"consider adding a `where` bound using this expression\"),\n+                };\n+                Some(err)\n+            }\n+            _ => {\n+                span_bug!(\n+                    span,\n+                    \"unexpected non-ConstEvaluatable predicate, this should not be reachable\"\n+                )\n+            }\n+        }\n+    }\n }\n \n+struct UnsatisfiedConst(pub bool);\n+\n+fn get_explanation_based_on_obligation<'tcx>(\n+    obligation: &PredicateObligation<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    trait_predicate: &ty::PolyTraitPredicate<'tcx>,\n+    pre_message: String,\n+) -> String {\n+    if let ObligationCauseCode::MainFunctionType = obligation.cause.code() {\n+        \"consider using `()`, or a `Result`\".to_owned()\n+    } else {\n+        let ty_desc = match trait_ref.skip_binder().self_ty().kind() {\n+            ty::FnDef(_, _) => Some(\"fn item\"),\n+            ty::Closure(_, _) => Some(\"closure\"),\n+            _ => None,\n+        };\n+\n+        match ty_desc {\n+            Some(desc) => format!(\n+                \"{}the trait `{}` is not implemented for {} `{}`\",\n+                pre_message,\n+                trait_predicate.print_modifiers_and_trait_path(),\n+                desc,\n+                trait_ref.skip_binder().self_ty(),\n+            ),\n+            None => format!(\n+                \"{}the trait `{}` is not implemented for `{}`\",\n+                pre_message,\n+                trait_predicate.print_modifiers_and_trait_path(),\n+                trait_ref.skip_binder().self_ty(),\n+            ),\n+        }\n+    }\n+}\n /// Crude way of getting back an `Expr` from a `Span`.\n pub struct FindExprBySpan<'hir> {\n     pub span: Span,"}, {"sha": "193378d76330e796885a608e796e13d93f4f920e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -341,6 +341,7 @@ pub struct OnUnimplementedNote {\n     /// should fallback to a generic message, `Some(None)` suggests using the default\n     /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n     /// default one..\n+    /// FIXME(bryangarza): Change this to an enum with the 3 variants described above.\n     pub append_const_msg: Option<Option<Symbol>>,\n }\n "}, {"sha": "c969e5d4975fc705aa6f405323395b0d7137cda2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d40d2a4073b17a14f364dc6638fea2faecbc2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d0d40d2a4073b17a14f364dc6638fea2faecbc2b", "patch": "@@ -386,7 +386,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn maybe_suggest_convert_to_slice(\n         &self,\n         err: &mut Diagnostic,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         candidate_impls: &[ImplCandidate<'tcx>],\n         span: Span,\n     );\n@@ -3848,7 +3848,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn maybe_suggest_convert_to_slice(\n         &self,\n         err: &mut Diagnostic,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         candidate_impls: &[ImplCandidate<'tcx>],\n         span: Span,\n     ) {"}]}