{"sha": "adb9d0e8a13131ff3efab6dbb1878774588100fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjlkMGU4YTEzMTMxZmYzZWZhYjZkYmIxODc4Nzc0NTg4MTAwZmQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-01T04:23:45Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-01T04:23:45Z"}, "message": "Merge pull request #4733 from thestinger/smallintmap\n\nmodernize smallintmap module", "tree": {"sha": "3da6136f5526c3c45e6a3e0a65f8a14d4c238b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3da6136f5526c3c45e6a3e0a65f8a14d4c238b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb9d0e8a13131ff3efab6dbb1878774588100fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb9d0e8a13131ff3efab6dbb1878774588100fd", "html_url": "https://github.com/rust-lang/rust/commit/adb9d0e8a13131ff3efab6dbb1878774588100fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb9d0e8a13131ff3efab6dbb1878774588100fd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aee79294699153ac7da9d2e5d076192c6eee3238", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee79294699153ac7da9d2e5d076192c6eee3238", "html_url": "https://github.com/rust-lang/rust/commit/aee79294699153ac7da9d2e5d076192c6eee3238"}, {"sha": "74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714", "html_url": "https://github.com/rust-lang/rust/commit/74b317ddc24fb0b5ffcbaafb0983cc5ddfd4a714"}], "stats": {"total": 534, "additions": 381, "deletions": 153}, "files": [{"sha": "daa335fed9379a3a094830a00c0a51fe18da4385", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -34,8 +34,8 @@ use core::uint;\n use core::vec;\n use std::map::{Map, HashMap};\n use std::map;\n-use std::smallintmap::{Map, SmallIntMap};\n-use std::smallintmap;\n+use std::oldsmallintmap::{Map, SmallIntMap};\n+use std::oldsmallintmap;\n use syntax::ast_util::{path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n@@ -248,7 +248,7 @@ pub type lint_settings = {\n };\n \n pub fn mk_lint_settings() -> lint_settings {\n-    {default_settings: smallintmap::mk(),\n+    {default_settings: oldsmallintmap::mk(),\n      settings_map: HashMap()}\n }\n \n@@ -273,7 +273,8 @@ pub fn get_lint_settings_level(settings: lint_settings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n-    smallintmap::SmallIntMap_(@smallintmap::SmallIntMap_ { v: copy modes.v })\n+    oldsmallintmap::SmallIntMap_(@oldsmallintmap::SmallIntMap_\n+    {v: copy modes.v})\n }\n \n type ctxt_ = {dict: lint_dict,\n@@ -393,7 +394,7 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n \n pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n     let cx = ctxt_({dict: get_lint_dict(),\n-                    curr: smallintmap::mk(),\n+                    curr: oldsmallintmap::mk(),\n                     is_default: true,\n                     sess: sess});\n "}, {"sha": "d0f9c9316167520a2fb3d6d046ec36135c993696", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -76,7 +76,7 @@ use core::option::{is_none, is_some};\n use core::option;\n use core::uint;\n use std::map::HashMap;\n-use std::smallintmap;\n+use std::oldsmallintmap;\n use std::{map, time, list};\n use syntax::ast_map::{path, path_elt_to_str, path_mod, path_name};\n use syntax::ast_util::{def_id_of_def, local_def, path_to_ident};"}, {"sha": "b07e3ef7b81744594457542d4ba532476d9fa191", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -42,7 +42,7 @@ use core::to_bytes;\n use core::uint;\n use core::vec;\n use std::map::HashMap;\n-use std::{map, smallintmap};\n+use std::{map, oldsmallintmap};\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n@@ -785,7 +785,7 @@ type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n \n-pub type node_type_table = @smallintmap::SmallIntMap<t>;\n+pub type node_type_table = @oldsmallintmap::SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n@@ -837,7 +837,7 @@ pub fn mk_ctxt(s: session::Session,\n         def_map: dm,\n         region_map: region_map,\n         region_paramd_items: region_paramd_items,\n-        node_types: @smallintmap::mk(),\n+        node_types: @oldsmallintmap::mk(),\n         node_type_substs: map::HashMap(),\n         items: amap,\n         intrinsic_defs: map::HashMap(),\n@@ -2799,7 +2799,7 @@ pub fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n \n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.size()));\n-    match smallintmap::find(*cx.node_types, id as uint) {\n+    match oldsmallintmap::find(*cx.node_types, id as uint) {\n        Some(t) => t,\n        None => cx.sess.bug(\n            fmt!(\"node_id_to_type: no type for node `%s`\",\n@@ -3175,7 +3175,7 @@ pub fn expr_kind(tcx: ctxt,\n         }\n \n         ast::expr_cast(*) => {\n-            match smallintmap::find(*tcx.node_types, expr.id as uint) {\n+            match oldsmallintmap::find(*tcx.node_types, expr.id as uint) {\n                 Some(t) => {\n                     if ty::type_is_immediate(t) {\n                         RvalueDatumExpr"}, {"sha": "2a39022e8d41c08be7ea01fe8904b2fd705c039f", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -281,7 +281,7 @@ use core::result;\n use core::vec;\n use std::list::Nil;\n use std::map::HashMap;\n-use std::smallintmap;\n+use std::oldsmallintmap;\n use syntax::ast::{ret_style, purity};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n@@ -353,7 +353,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n \n fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n-        vals: smallintmap::mk(),\n+        vals: oldsmallintmap::mk(),\n         mut bindings: ~[]\n     }\n }"}, {"sha": "3b38197c51c449f06f27e5d5ed1e820895a37560", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n use core::result;\n-use std::smallintmap::SmallIntMap;\n+use std::oldsmallintmap::SmallIntMap;\n \n use middle::ty::{Vid, expected_found, IntVarValue};\n use middle::ty;"}, {"sha": "5059de1314907f60483ad40cfd2a1f648281377d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -69,7 +69,7 @@ use std::list::{List, Nil, Cons};\n use std::list;\n use std::map::HashMap;\n use std::map;\n-use std::smallintmap;\n+use std::oldsmallintmap;\n use syntax::ast::{provided, required, spanned};\n use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::{local_def, respan, split_trait_methods};\n@@ -212,7 +212,7 @@ pub enum crate_ctxt {\n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n-    smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n+    oldsmallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::node_id,"}, {"sha": "803e75e4cf7a3c034146b2db63267bbb31856b87", "filename": "src/libstd/oldsmallintmap.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A simple map based on a vector for small integer keys. Space requirements\n+ * are O(highest integer key).\n+ */\n+#[forbid(deprecated_mode)];\n+\n+use core::container::{Container, Mutable, Map, Set};\n+use core::dvec::DVec;\n+use core::ops;\n+use core::option::{Some, None};\n+use core::option;\n+use core::prelude::*;\n+\n+// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n+// requires this to be.\n+struct SmallIntMap_<T> {\n+    v: DVec<Option<T>>,\n+}\n+\n+pub enum SmallIntMap<T> {\n+    SmallIntMap_(@SmallIntMap_<T>)\n+}\n+\n+/// Create a smallintmap\n+pub fn mk<T: Copy>() -> SmallIntMap<T> {\n+    let v = DVec();\n+    SmallIntMap_(@SmallIntMap_ { v: v } )\n+}\n+\n+/**\n+ * Add a value to the map. If the map already contains a value for\n+ * the specified key then the original value is replaced.\n+ */\n+#[inline(always)]\n+pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n+    //io::println(fmt!(\"%?\", key));\n+    self.v.grow_set_elt(key, &None, Some(val));\n+}\n+\n+/**\n+ * Get the value for the specified key. If the key does not exist\n+ * in the map then returns none\n+ */\n+pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+    if key < self.v.len() { return self.v.get_elt(key); }\n+    return None::<T>;\n+}\n+\n+/**\n+ * Get the value for the specified key\n+ *\n+ * # Failure\n+ *\n+ * If the key does not exist in the map\n+ */\n+pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n+    match find(self, key) {\n+      None => {\n+        error!(\"smallintmap::get(): key not present\");\n+        die!();\n+      }\n+      Some(move v) => return v\n+    }\n+}\n+\n+/// Returns true if the map contains a value for the specified key\n+pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+    return !find(self, key).is_none();\n+}\n+\n+impl<V> SmallIntMap<V>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint {\n+        let mut sz = 0u;\n+        for self.v.each |item| {\n+            match *item {\n+              Some(_) => sz += 1u,\n+              _ => ()\n+            }\n+        }\n+        sz\n+    }\n+\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<V> SmallIntMap<V>: Mutable {\n+    fn clear(&mut self) { self.v.set(~[]) }\n+}\n+\n+/// Implements the map::map interface for smallintmap\n+impl<V: Copy> SmallIntMap<V> {\n+    #[inline(always)]\n+    fn insert(key: uint, value: V) -> bool {\n+        let exists = contains_key(self, key);\n+        insert(self, key, value);\n+        return !exists;\n+    }\n+    fn remove(key: uint) -> bool {\n+        if key >= self.v.len() {\n+            return false;\n+        }\n+        let old = self.v.get_elt(key);\n+        self.v.set_elt(key, None);\n+        old.is_some()\n+    }\n+    pure fn contains_key(key: uint) -> bool {\n+        contains_key(self, key)\n+    }\n+    pure fn contains_key_ref(key: &uint) -> bool {\n+        contains_key(self, *key)\n+    }\n+    pure fn get(key: uint) -> V { get(self, key) }\n+    pure fn find(key: uint) -> Option<V> { find(self, key) }\n+\n+    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(key) {\n+            None            => return self.insert(key, val),\n+            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+        }\n+    }\n+\n+    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    }\n+\n+    pure fn each(it: fn(key: uint, value: V) -> bool) {\n+        self.each_ref(|k, v| it(*k, *v))\n+    }\n+    pure fn each_key(it: fn(key: uint) -> bool) {\n+        self.each_ref(|k, _v| it(*k))\n+    }\n+    pure fn each_value(it: fn(value: V) -> bool) {\n+        self.each_ref(|_k, v| it(*v))\n+    }\n+    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n+        let mut idx = 0u, l = self.v.len();\n+        while idx < l {\n+            match self.v.get_elt(idx) {\n+              Some(ref elt) => if !it(&idx, elt) { break },\n+              None => ()\n+            }\n+            idx += 1u;\n+        }\n+    }\n+    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n+        self.each_ref(|k, _v| blk(k))\n+    }\n+    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        self.each_ref(|_k, v| blk(v))\n+    }\n+}\n+\n+impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n+    pure fn index(&self, key: uint) -> V {\n+        unsafe {\n+            get(*self, key)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{mk, SmallIntMap};\n+\n+    use core::option::None;\n+\n+    #[test]\n+    fn test_len() {\n+        let mut map = mk();\n+        assert map.len() == 0;\n+        assert map.is_empty();\n+        map.insert(5, 20);\n+        assert map.len() == 1;\n+        assert !map.is_empty();\n+        map.insert(11, 12);\n+        assert map.len() == 2;\n+        assert !map.is_empty();\n+        map.insert(14, 22);\n+        assert map.len() == 3;\n+        assert !map.is_empty();\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut map = mk();\n+        map.insert(5, 20);\n+        map.insert(11, 12);\n+        map.insert(14, 22);\n+        map.clear();\n+        assert map.is_empty();\n+        assert map.find(5).is_none();\n+        assert map.find(11).is_none();\n+        assert map.find(14).is_none();\n+    }\n+\n+    #[test]\n+    fn test_insert_with_key() {\n+        let map: SmallIntMap<uint> = mk();\n+\n+        // given a new key, initialize it with this new count, given\n+        // given an existing key, add more to its count\n+        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        // count integers\n+        map.update(3, 1, addMoreToCount_simple);\n+        map.update_with_key(9, 1, addMoreToCount);\n+        map.update(3, 7, addMoreToCount_simple);\n+        map.update_with_key(5, 3, addMoreToCount);\n+        map.update_with_key(3, 2, addMoreToCount);\n+\n+        // check the total counts\n+        assert map.find(3).get() == 10;\n+        assert map.find(5).get() == 3;\n+        assert map.find(9).get() == 1;\n+\n+        // sadly, no sevens were counted\n+        assert None == map.find(7);\n+    }\n+}"}, {"sha": "a21328b3d6340e671707ef38632bd2593b375033", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 120, "deletions": 130, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -14,171 +14,161 @@\n  */\n #[forbid(deprecated_mode)];\n \n-use map;\n-use map::StdMap;\n-\n-use core::dvec::DVec;\n-use core::ops;\n+use core::container::{Container, Mutable, Map, Set};\n use core::option::{Some, None};\n-use core::option;\n use core::prelude::*;\n \n-// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n-// requires this to be.\n-struct SmallIntMap_<T> {\n-    v: DVec<Option<T>>,\n-}\n-\n-pub enum SmallIntMap<T> {\n-    SmallIntMap_(@SmallIntMap_<T>)\n+pub struct SmallIntMap<T> {\n+    priv v: ~[Option<T>],\n }\n \n-/// Create a smallintmap\n-pub fn mk<T: Copy>() -> SmallIntMap<T> {\n-    let v = DVec();\n-    SmallIntMap_(@SmallIntMap_ { v: v } )\n-}\n+impl<V> SmallIntMap<V>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint {\n+        let mut sz = 0;\n+        for self.v.each |item| {\n+            if item.is_some() {\n+                sz += 1;\n+            }\n+        }\n+        sz\n+    }\n \n-/**\n- * Add a value to the map. If the map already contains a value for\n- * the specified key then the original value is replaced.\n- */\n-#[inline(always)]\n-pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n-    //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, &None, Some(val));\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-/**\n- * Get the value for the specified key. If the key does not exist\n- * in the map then returns none\n- */\n-pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n-    if key < self.v.len() { return self.v.get_elt(key); }\n-    return None::<T>;\n+impl<V> SmallIntMap<V>: Mutable {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) { self.v.clear() }\n }\n \n-/**\n- * Get the value for the specified key\n- *\n- * # Failure\n- *\n- * If the key does not exist in the map\n- */\n-pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n-    match find(self, key) {\n-      None => {\n-        error!(\"smallintmap::get(): key not present\");\n-        die!();\n-      }\n-      Some(move v) => return v\n+impl<V> SmallIntMap<V>: Map<uint, V> {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n     }\n-}\n-\n-/// Returns true if the map contains a value for the specified key\n-pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n-    return !find(self, key).is_none();\n-}\n \n-/// Implements the map::map interface for smallintmap\n-impl<V: Copy> SmallIntMap<V>: map::StdMap<uint, V> {\n-    pure fn size() -> uint {\n-        let mut sz = 0u;\n-        for self.v.each |item| {\n-            match *item {\n-              Some(_) => sz += 1u,\n-              _ => ()\n+    /// Visit all key-value pairs\n+    pure fn each(&self, it: fn(key: &uint, value: &V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n             }\n         }\n-        sz\n-    }\n-    #[inline(always)]\n-    fn insert(key: uint, value: V) -> bool {\n-        let exists = contains_key(self, key);\n-        insert(self, key, value);\n-        return !exists;\n-    }\n-    fn remove(key: uint) -> bool {\n-        if key >= self.v.len() {\n-            return false;\n-        }\n-        let old = self.v.get_elt(key);\n-        self.v.set_elt(key, None);\n-        old.is_some()\n     }\n-    fn clear() {\n-        self.v.set(~[]);\n-    }\n-    pure fn contains_key(key: uint) -> bool {\n-        contains_key(self, key)\n+\n+    /// Visit all keys\n+    pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n+        self.each(|k, _| blk(k))\n     }\n-    pure fn contains_key_ref(key: &uint) -> bool {\n-        contains_key(self, *key)\n+\n+    /// Visit all values\n+    pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+        self.each(|_, v| blk(v))\n     }\n-    pure fn get(key: uint) -> V { get(self, key) }\n-    pure fn find(key: uint) -> Option<V> { find(self, key) }\n \n-    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n-        match self.find(key) {\n-            None            => return self.insert(key, val),\n-            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &uint) -> Option<&self/V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n         }\n     }\n \n-    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n-        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: uint, value: V) -> bool {\n+        let exists = self.contains_key(&key);\n+        let len = self.v.len();\n+        if len <= key {\n+            vec::grow_fn(&mut self.v, key - len + 1, |_| None);\n+        }\n+        self.v[key] = Some(value);\n+        !exists\n     }\n \n-    pure fn each(it: fn(key: uint, value: V) -> bool) {\n-        self.each_ref(|k, v| it(*k, *v))\n-    }\n-    pure fn each_key(it: fn(key: uint) -> bool) {\n-        self.each_ref(|k, _v| it(*k))\n-    }\n-    pure fn each_value(it: fn(value: V) -> bool) {\n-        self.each_ref(|_k, v| it(*v))\n-    }\n-    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n-        let mut idx = 0u, l = self.v.len();\n-        while idx < l {\n-            match self.v.get_elt(idx) {\n-              Some(ref elt) => if !it(&idx, elt) { break },\n-              None => ()\n-            }\n-            idx += 1u;\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &uint) -> bool {\n+        if *key >= self.v.len() {\n+            return false;\n         }\n+        let removed = self.v[*key].is_some();\n+        self.v[*key] = None;\n+        removed\n     }\n-    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n-        self.each_ref(|k, _v| blk(k))\n-    }\n-    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n-        self.each_ref(|_k, v| blk(v))\n+}\n+\n+pub impl<V> SmallIntMap<V> {\n+    /// Create an empty SmallIntMap\n+    static pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+\n+    pure fn get(&self, key: &uint) -> &self/V {\n+        self.find(key).expect(\"key not present\")\n     }\n }\n \n-impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n-    pure fn index(&self, key: uint) -> V {\n-        unsafe {\n-            get(*self, key)\n+pub impl<V: Copy> SmallIntMap<V> {\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update_with_key(&mut self, key: uint, val: V,\n+                       ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(&key) {\n+          None => self.insert(key, val),\n+          Some(orig) => self.insert(key, ff(key, copy *orig, val)),\n         }\n     }\n-}\n \n-/// Cast the given smallintmap to a map::map\n-pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::StdMap<uint, V> {\n-    s as map::StdMap::<uint, V>\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use smallintmap::{mk, SmallIntMap};\n+    use super::SmallIntMap;\n \n-    use core::option::None;\n-    use core::option;\n+    #[test]\n+    fn test_len() {\n+        let mut map = SmallIntMap::new();\n+        assert map.len() == 0;\n+        assert map.is_empty();\n+        assert map.insert(5, 20);\n+        assert map.len() == 1;\n+        assert !map.is_empty();\n+        assert map.insert(11, 12);\n+        assert map.len() == 2;\n+        assert !map.is_empty();\n+        assert map.insert(14, 22);\n+        assert map.len() == 3;\n+        assert !map.is_empty();\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut map = SmallIntMap::new();\n+        assert map.insert(5, 20);\n+        assert map.insert(11, 12);\n+        assert map.insert(14, 22);\n+        map.clear();\n+        assert map.is_empty();\n+        assert map.find(&5).is_none();\n+        assert map.find(&11).is_none();\n+        assert map.find(&14).is_none();\n+    }\n \n     #[test]\n     fn test_insert_with_key() {\n-        let map: SmallIntMap<uint> = mk();\n+        let mut map = SmallIntMap::new();\n \n         // given a new key, initialize it with this new count, given\n         // given an existing key, add more to its count\n@@ -198,11 +188,11 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert 10 == option::get(map.find(3));\n-        assert  3 == option::get(map.find(5));\n-        assert  1 == option::get(map.find(9));\n+        assert map.find(&3).get() == &10;\n+        assert map.find(&5).get() == &3;\n+        assert map.find(&9).get() == &1;\n \n         // sadly, no sevens were counted\n-        assert None == map.find(7);\n+        assert map.find(&7).is_none();\n     }\n }"}, {"sha": "dc73b430099ab23b60904a63f48dcd903c6b65e7", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -83,6 +83,7 @@ pub mod map;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n+pub mod oldsmallintmap;\n pub mod sort;\n pub mod treemap;\n "}, {"sha": "0687799cf288c8c085c2382080a36c8fa668a0ad", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb9d0e8a13131ff3efab6dbb1878774588100fd/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=adb9d0e8a13131ff3efab6dbb1878774588100fd", "patch": "@@ -11,19 +11,18 @@\n // Microbenchmark for the smallintmap library\n \n extern mod std;\n-use std::smallintmap;\n use std::smallintmap::SmallIntMap;\n use io::WriterUtil;\n \n-fn append_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n         map.insert(i, i + 22u);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        assert map.get(i) == i + 22u;\n+        assert *map.get(&i) == i + 22u;\n     }\n }\n \n@@ -43,11 +42,11 @@ fn main() {\n     let mut appendf = 0.0;\n \n     for uint::range(0u, rep) |_r| {\n-        let map = smallintmap::mk();\n+        let mut map = SmallIntMap::new();\n         let start = std::time::precise_time_s();\n-        append_sequential(0u, max, map);\n+        append_sequential(0u, max, &mut map);\n         let mid = std::time::precise_time_s();\n-        check_sequential(0u, max, map);\n+        check_sequential(0u, max, &map);\n         let end = std::time::precise_time_s();\n \n         checkf += (end - mid) as float;"}]}