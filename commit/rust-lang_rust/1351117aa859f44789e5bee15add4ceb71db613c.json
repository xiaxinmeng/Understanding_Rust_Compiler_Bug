{"sha": "1351117aa859f44789e5bee15add4ceb71db613c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNTExMTdhYTg1OWY0NDc4OWU1YmVlMTVhZGQ0Y2ViNzFkYjYxM2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-08T14:26:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-09T03:39:11Z"}, "message": "avoid rooting @ptrs that live in immutable, stable memory", "tree": {"sha": "4564a69aa6158b75b4f8dd19d5e665af20e025c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4564a69aa6158b75b4f8dd19d5e665af20e025c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1351117aa859f44789e5bee15add4ceb71db613c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1351117aa859f44789e5bee15add4ceb71db613c", "html_url": "https://github.com/rust-lang/rust/commit/1351117aa859f44789e5bee15add4ceb71db613c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1351117aa859f44789e5bee15add4ceb71db613c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a628f7f47e2ecd51b11119bef2bc52dd7ab01861", "url": "https://api.github.com/repos/rust-lang/rust/commits/a628f7f47e2ecd51b11119bef2bc52dd7ab01861", "html_url": "https://github.com/rust-lang/rust/commit/a628f7f47e2ecd51b11119bef2bc52dd7ab01861"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "441dfad9c2d5000e50bbb033f2e3dcadf20f7dc6", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1351117aa859f44789e5bee15add4ceb71db613c/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1351117aa859f44789e5bee15add4ceb71db613c/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=1351117aa859f44789e5bee15add4ceb71db613c", "patch": "@@ -16,12 +16,18 @@ impl public_methods for borrowck_ctxt {\n             self.preserve(cmt, opt_scope_id)\n           }\n           cat_local(_) {\n-            // This should never happen.  Local variables are always lendable,\n-            // so either `loan()` should be called or there must be some\n-            // intermediate @ or &---they are not lendable but do not recurse.\n-            self.tcx.sess.span_bug(\n-                cmt.span,\n-                \"preserve() called with local\");\n+            // Normally, local variables are lendable, and so this\n+            // case should never trigged.  However, if we are\n+            // preserving an expression like a.b where the field `b`\n+            // has @ type, then it will recurse to ensure that the `a`\n+            // is stable to try and avoid rooting the value `a.b`.  In\n+            // this case, opt_scope_id will be none.\n+            if opt_scope_id.is_some() {\n+                self.tcx.sess.span_bug(\n+                    cmt.span,\n+                    \"preserve() called with local and non-none opt_scope_id\");\n+            }\n+            ok(())\n           }\n           cat_arg(_) {\n             // This can happen as not all args are lendable (e.g., &&\n@@ -37,11 +43,11 @@ impl public_methods for borrowck_ctxt {\n             // type never changes.\n             self.preserve(cmt_base, opt_scope_id)\n           }\n-          cat_comp(cmt1, comp_variant) {\n-            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_variant)\n+          cat_comp(cmt_base, comp_variant) {\n+            self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_variant)\n           }\n-          cat_deref(cmt1, _, uniq_ptr) {\n-            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_uniq)\n+          cat_deref(cmt_base, _, uniq_ptr) {\n+            self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_uniq)\n           }\n           cat_deref(_, _, region_ptr) {\n             // References are always \"stable\" by induction (when the\n@@ -54,23 +60,18 @@ impl public_methods for borrowck_ctxt {\n             ok(())\n           }\n           cat_deref(base, derefs, gc_ptr) {\n-            // GC'd pointers of type @MT: always stable because we can\n-            // inc the ref count or keep a GC root as necessary.  We\n-            // need to insert this id into the root_map, however.\n-            alt opt_scope_id {\n-              some(scope_id) {\n-                #debug[\"Inserting root map entry for %s: \\\n-                        node %d:%u -> scope %d\",\n-                       self.cmt_to_repr(cmt), base.id,\n-                       derefs, scope_id];\n-\n-                let rk = {id: base.id, derefs: derefs};\n-                self.root_map.insert(rk, scope_id);\n-                ok(())\n-              }\n-              none {\n-                err({cmt:cmt, code:err_preserve_gc})\n-              }\n+            // GC'd pointers of type @MT: if this pointer lives in\n+            // immutable, stable memory, then everything is fine.  But\n+            // otherwise we have no guarantee the pointer will stay\n+            // live, so we must root the pointer (i.e., inc the ref\n+            // count) for the duration of the loan.\n+            if base.mutbl == m_imm {\n+                alt self.preserve(base, none) {\n+                  ok(()) {ok(())}\n+                  err(_) {self.attempt_root(cmt, opt_scope_id, base, derefs)}\n+                }\n+            } else {\n+                self.attempt_root(cmt, opt_scope_id, base, derefs)\n             }\n           }\n           cat_discr(base, alt_id) {\n@@ -138,14 +139,33 @@ impl public_methods for borrowck_ctxt {\n \n impl private_methods for borrowck_ctxt {\n     fn require_imm(cmt: cmt,\n-                   cmt1: cmt,\n+                   cmt_base: cmt,\n                    opt_scope_id: option<ast::node_id>,\n                    code: bckerr_code) -> bckres<()> {\n         // Variant contents and unique pointers: must be immutably\n         // rooted to a preserved address.\n-        alt cmt1.mutbl {\n+        alt cmt_base.mutbl {\n           m_mutbl | m_const { err({cmt:cmt, code:code}) }\n-          m_imm { self.preserve(cmt1, opt_scope_id) }\n+          m_imm { self.preserve(cmt_base, opt_scope_id) }\n+        }\n+    }\n+\n+    fn attempt_root(cmt: cmt, opt_scope_id: option<ast::node_id>,\n+                    base: cmt, derefs: uint) -> bckres<()> {\n+        alt opt_scope_id {\n+          some(scope_id) {\n+            #debug[\"Inserting root map entry for %s: \\\n+                    node %d:%u -> scope %d\",\n+                   self.cmt_to_repr(cmt), base.id,\n+                   derefs, scope_id];\n+\n+            let rk = {id: base.id, derefs: derefs};\n+            self.root_map.insert(rk, scope_id);\n+            ok(())\n+          }\n+          none {\n+            err({cmt:cmt, code:err_preserve_gc})\n+          }\n         }\n     }\n }"}]}