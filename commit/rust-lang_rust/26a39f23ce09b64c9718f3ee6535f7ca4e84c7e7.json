{"sha": "26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YTM5ZjIzY2UwOWI2NGM5NzE4ZjNlZTY1MzVmN2NhNGU4NGM3ZTc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-07-25T19:00:33Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-07-29T10:31:53Z"}, "message": "Refactored syntax::fold.\n\nPrior to this, the code there had a few issues:\n\n- Default implementations inconsistently either had the prefix `noop_` or\n  not.\n- Some default methods where implemented in terms of a public noop function\n  for user code to call, others where implemented directly on the trait\n  and did not allow users of the trait to reuse the code.\n- Some of the default implementations where private, and thus not reusable\n  for other implementors.\n- There where some bugs where default implementations called other default\n  implementations directly, rather than to the underlying Folder, with the\n  result of some AST nodes never being visited even if the user implemented that\n  method. (For example, the current Folder never folded struct fields)\n\nThis commit solves this situation somewhat radically by making _all_\n`fold_...` functions in the module into Folder methods, and implementing\nthem all in terms of public `noop_...` functions for other implementors to\ncall out to.\n\nSome public functions had to be renamed to fit the new system, so this is a\nbreaking change.\n\n[breaking-change]", "tree": {"sha": "b54eabb2937ee9571f13f55edde2712d285f6e29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b54eabb2937ee9571f13f55edde2712d285f6e29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "html_url": "https://github.com/rust-lang/rust/commit/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7375f4d842884b255be33c267651da48dac961f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7375f4d842884b255be33c267651da48dac961f6", "html_url": "https://github.com/rust-lang/rust/commit/7375f4d842884b255be33c267651da48dac961f6"}], "stats": {"total": 715, "additions": 420, "deletions": 295}, "files": [{"sha": "ab363a88db2d9dfb1cd76d7deb5b2065136e2b97", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "patch": "@@ -44,7 +44,7 @@ impl<'a> fold::Folder for Context<'a> {\n         fold_expr(self, expr)\n     }\n     fn fold_mac(&mut self, mac: &ast::Mac) -> ast::Mac {\n-        fold::fold_mac(mac, self)\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n "}, {"sha": "34de81008711e40ca0c351bd282336159436b4e0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "patch": "@@ -961,15 +961,15 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub node: Method_,\n }\n \n-#[deriving(PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Method_ {\n     /// Represents a method declaration\n     MethDecl(Ident,"}, {"sha": "67de8e7aba10207cc4a8ee58de7605523beead53", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "patch": "@@ -606,7 +606,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n     }\n \n     fn fold_mac(&mut self, mac: &Mac) -> Mac {\n-        fold::fold_mac(mac, self)\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n "}, {"sha": "3b098ea8a3dfd5278bda47a061e579cf31592d9f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "patch": "@@ -341,7 +341,7 @@ fn expand_item_underscore(item: &ast::Item_, fld: &mut MacroExpander) -> ast::It\n         ast::ItemFn(decl, fn_style, abi, ref generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(&*decl, body, fld);\n-            let expanded_generics = fold::fold_generics(generics,fld);\n+            let expanded_generics = fold::noop_fold_generics(generics,fld);\n             ast::ItemFn(rewritten_fn_decl, fn_style, abi, expanded_generics, rewritten_body)\n         }\n         _ => noop_fold_item_underscore(&*item, fld)\n@@ -792,7 +792,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n         }\n     }\n     fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n-        fold::fold_mac(macro, self)\n+        fold::noop_fold_mac(macro, self)\n     }\n }\n \n@@ -824,7 +824,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n         }\n     }\n     fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n-        fold::fold_mac(macro, self)\n+        fold::noop_fold_mac(macro, self)\n     }\n }\n \n@@ -847,7 +847,7 @@ fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> SmallVector<Gc<ast\n                     id: id,\n                     span: fld.new_span(m.span),\n                     node: ast::MethDecl(fld.fold_ident(ident),\n-                                        fold_generics(generics, fld),\n+                                        noop_fold_generics(generics, fld),\n                                         abi,\n                                         fld.fold_explicit_self(explicit_self),\n                                         fn_style,\n@@ -1014,7 +1014,7 @@ impl Folder for Marker {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n-                           fold_tts(tts.as_slice(), self),\n+                           self.fold_tts(tts.as_slice()),\n                            mtwt::apply_mark(self.mark, ctxt))\n             }\n         };\n@@ -1027,7 +1027,7 @@ impl Folder for Marker {\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n-    fold_tts(tts, &mut Marker{mark:m})\n+    noop_fold_tts(tts, &mut Marker{mark:m})\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro."}, {"sha": "f3e6cf77e797252b73c2cad96fff63b63c90396c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 410, "deletions": 285, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=26a39f23ce09b64c9718f3ee6535f7ca4e84c7e7", "patch": "@@ -29,52 +29,29 @@ use util::small_vector::SmallVector;\n use std::rc::Rc;\n use std::gc::{Gc, GC};\n \n-// We may eventually want to be able to fold over type parameters, too.\n pub trait Folder {\n+    // Any additions to this trait should happen in form\n+    // of a call to a public `noop_*` function that only calls\n+    // out to the folder again, not other `noop_*` functions.\n+    //\n+    // This is a necessary API workaround to the problem of not\n+    // being able to call out to the super default method\n+    // in an overridden default method.\n+\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n     fn fold_meta_items(&mut self, meta_items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n-        meta_items.iter().map(|x| fold_meta_item_(*x, self)).collect()\n+        noop_fold_meta_items(meta_items, self)\n+    }\n+\n+    fn fold_meta_item(&mut self, meta_item: &MetaItem) -> MetaItem {\n+        noop_fold_meta_item(meta_item, self)\n     }\n \n     fn fold_view_path(&mut self, view_path: Gc<ViewPath>) -> Gc<ViewPath> {\n-        let inner_view_path = match view_path.node {\n-            ViewPathSimple(ref ident, ref path, node_id) => {\n-                let id = self.new_id(node_id);\n-                ViewPathSimple(ident.clone(),\n-                               self.fold_path(path),\n-                               id)\n-            }\n-            ViewPathGlob(ref path, node_id) => {\n-                let id = self.new_id(node_id);\n-                ViewPathGlob(self.fold_path(path), id)\n-            }\n-            ViewPathList(ref path, ref path_list_idents, node_id) => {\n-                let id = self.new_id(node_id);\n-                ViewPathList(self.fold_path(path),\n-                             path_list_idents.iter().map(|path_list_ident| {\n-                                Spanned {\n-                                    node: match path_list_ident.node {\n-                                        PathListIdent { id, name } =>\n-                                            PathListIdent {\n-                                                id: self.new_id(id),\n-                                                name: name.clone()\n-                                            },\n-                                        PathListMod { id } =>\n-                                            PathListMod { id: self.new_id(id) }\n-                                    },\n-                                    span: self.new_span(path_list_ident.span)\n-                                }\n-                             }).collect(),\n-                             id)\n-            }\n-        };\n-        box(GC) Spanned {\n-            node: inner_view_path,\n-            span: self.new_span(view_path.span),\n-        }\n+        noop_fold_view_path(view_path, self)\n     }\n \n     fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n@@ -89,17 +66,12 @@ pub trait Folder {\n         noop_fold_item(&*i, self)\n     }\n \n+    fn fold_item_simple(&mut self, i: &Item) -> Item {\n+        noop_fold_item_simple(i, self)\n+    }\n+\n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n-        let id = self.new_id(sf.node.id);\n-        Spanned {\n-            node: ast::StructField_ {\n-                kind: sf.node.kind,\n-                id: id,\n-                ty: self.fold_ty(sf.node.ty),\n-                attrs: sf.node.attrs.iter().map(|e| self.fold_attribute(*e)).collect()\n-            },\n-            span: self.new_span(sf.span)\n-        }\n+        noop_fold_struct_field(sf, self)\n     }\n \n     fn fold_item_underscore(&mut self, i: &Item_) -> Item_ {\n@@ -127,186 +99,47 @@ pub trait Folder {\n     }\n \n     fn fold_arm(&mut self, a: &Arm) -> Arm {\n-        Arm {\n-            attrs: a.attrs.iter().map(|x| self.fold_attribute(*x)).collect(),\n-            pats: a.pats.iter().map(|x| self.fold_pat(*x)).collect(),\n-            guard: a.guard.map(|x| self.fold_expr(x)),\n-            body: self.fold_expr(a.body),\n-        }\n+        noop_fold_arm(a, self)\n     }\n \n     fn fold_pat(&mut self, p: Gc<Pat>) -> Gc<Pat> {\n         noop_fold_pat(p, self)\n     }\n \n     fn fold_decl(&mut self, d: Gc<Decl>) -> SmallVector<Gc<Decl>> {\n-        let node = match d.node {\n-            DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n-            DeclItem(it) => {\n-                self.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n-            }\n-        };\n-\n-        node.move_iter().map(|node| {\n-            box(GC) Spanned {\n-                node: node,\n-                span: self.new_span(d.span),\n-            }\n-        }).collect()\n+        noop_fold_decl(d, self)\n     }\n \n     fn fold_expr(&mut self, e: Gc<Expr>) -> Gc<Expr> {\n         noop_fold_expr(e, self)\n     }\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        let id = self.new_id(t.id);\n-        let node = match t.node {\n-            TyNil | TyBot | TyInfer => t.node.clone(),\n-            TyBox(ty) => TyBox(self.fold_ty(ty)),\n-            TyUniq(ty) => TyUniq(self.fold_ty(ty)),\n-            TyVec(ty) => TyVec(self.fold_ty(ty)),\n-            TyPtr(ref mt) => TyPtr(fold_mt(mt, self)),\n-            TyRptr(ref region, ref mt) => {\n-                TyRptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n-            }\n-            TyClosure(ref f, ref region) => {\n-                TyClosure(box(GC) ClosureTy {\n-                    fn_style: f.fn_style,\n-                    onceness: f.onceness,\n-                    bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(&*f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n-                }, fold_opt_lifetime(region, self))\n-            }\n-            TyProc(ref f) => {\n-                TyProc(box(GC) ClosureTy {\n-                    fn_style: f.fn_style,\n-                    onceness: f.onceness,\n-                    bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: self.fold_fn_decl(&*f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n-                })\n-            }\n-            TyBareFn(ref f) => {\n-                TyBareFn(box(GC) BareFnTy {\n-                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n-                    fn_style: f.fn_style,\n-                    abi: f.abi,\n-                    decl: self.fold_fn_decl(&*f.decl)\n-                })\n-            }\n-            TyUnboxedFn(ref f) => {\n-                TyUnboxedFn(box(GC) UnboxedFnTy {\n-                    decl: self.fold_fn_decl(&*f.decl),\n-                })\n-            }\n-            TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n-            TyParen(ref ty) => TyParen(self.fold_ty(*ty)),\n-            TyPath(ref path, ref bounds, id) => {\n-                let id = self.new_id(id);\n-                TyPath(self.fold_path(path),\n-                       fold_opt_bounds(bounds, self),\n-                       id)\n-            }\n-            TyFixedLengthVec(ty, e) => {\n-                TyFixedLengthVec(self.fold_ty(ty), self.fold_expr(e))\n-            }\n-            TyTypeof(expr) => TyTypeof(self.fold_expr(expr)),\n-        };\n-        P(Ty {\n-            id: id,\n-            span: self.new_span(t.span),\n-            node: node,\n-        })\n+        noop_fold_ty(t, self)\n     }\n \n     fn fold_mod(&mut self, m: &Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n \n     fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n-        ast::ForeignMod {\n-            abi: nm.abi,\n-            view_items: nm.view_items\n-                          .iter()\n-                          .map(|x| self.fold_view_item(x))\n-                          .collect(),\n-            items: nm.items\n-                     .iter()\n-                     .map(|x| self.fold_foreign_item(*x))\n-                     .collect(),\n-        }\n+        noop_fold_foreign_mod(nm, self)\n     }\n \n     fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n-        let id = self.new_id(v.node.id);\n-        let kind;\n-        match v.node.kind {\n-            TupleVariantKind(ref variant_args) => {\n-                kind = TupleVariantKind(variant_args.iter().map(|x|\n-                    fold_variant_arg_(x, self)).collect())\n-            }\n-            StructVariantKind(ref struct_def) => {\n-                kind = StructVariantKind(box(GC) ast::StructDef {\n-                    fields: struct_def.fields.iter()\n-                        .map(|f| self.fold_struct_field(f)).collect(),\n-                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(c)),\n-                    super_struct: match struct_def.super_struct {\n-                        Some(t) => Some(self.fold_ty(t)),\n-                        None => None\n-                    },\n-                    is_virtual: struct_def.is_virtual,\n-                })\n-            }\n-        }\n-\n-        let attrs = v.node.attrs.iter().map(|x| self.fold_attribute(*x)).collect();\n-\n-        let de = match v.node.disr_expr {\n-          Some(e) => Some(self.fold_expr(e)),\n-          None => None\n-        };\n-        let node = ast::Variant_ {\n-            name: v.node.name,\n-            attrs: attrs,\n-            kind: kind,\n-            id: id,\n-            disr_expr: de,\n-            vis: v.node.vis,\n-        };\n-        P(Spanned {\n-            node: node,\n-            span: self.new_span(v.span),\n-        })\n+        noop_fold_variant(v, self)\n     }\n \n     fn fold_ident(&mut self, i: Ident) -> Ident {\n-        i\n+        noop_fold_ident(i, self)\n     }\n \n     fn fold_path(&mut self, p: &Path) -> Path {\n-        ast::Path {\n-            span: self.new_span(p.span),\n-            global: p.global,\n-            segments: p.segments.iter().map(|segment| ast::PathSegment {\n-                identifier: self.fold_ident(segment.identifier),\n-                lifetimes: segment.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n-                types: segment.types.iter().map(|&typ| self.fold_ty(typ)).collect(),\n-            }).collect()\n-        }\n+        noop_fold_path(p, self)\n     }\n \n     fn fold_local(&mut self, l: Gc<Local>) -> Gc<Local> {\n-        let id = self.new_id(l.id); // Needs to be first, for ast_map.\n-        box(GC) Local {\n-            id: id,\n-            ty: self.fold_ty(l.ty),\n-            pat: self.fold_pat(l.pat),\n-            init: l.init.map(|e| self.fold_expr(e)),\n-            span: self.new_span(l.span),\n-            source: l.source,\n-        }\n+        noop_fold_local(l, self)\n     }\n \n     fn fold_mac(&mut self, _macro: &Mac) -> Mac {\n@@ -315,9 +148,96 @@ pub trait Folder {\n         // if you really want a folder that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // fold::fold_mac(_macro, self)\n+        // fold::noop_fold_mac(_macro, self)\n+    }\n+\n+    fn fold_explicit_self(&mut self, es: &ExplicitSelf) -> ExplicitSelf {\n+        noop_fold_explicit_self(es, self)\n+    }\n+\n+    fn fold_explicit_self_underscore(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n+        noop_fold_explicit_self_underscore(es, self)\n+    }\n+\n+    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n+        noop_fold_lifetime(l, self)\n+    }\n+\n+    fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n+        noop_fold_attribute(at, self)\n+    }\n+\n+    fn fold_arg(&mut self, a: &Arg) -> Arg {\n+        noop_fold_arg(a, self)\n+    }\n+\n+    fn fold_generics(&mut self, generics: &Generics) -> Generics {\n+        noop_fold_generics(generics, self)\n+    }\n+\n+    fn fold_trait_ref(&mut self, p: &TraitRef) -> TraitRef {\n+        noop_fold_trait_ref(p, self)\n+    }\n+\n+    fn fold_struct_def(&mut self, struct_def: Gc<StructDef>) -> Gc<StructDef> {\n+        noop_fold_struct_def(struct_def, self)\n+    }\n+\n+    fn fold_lifetimes(&mut self, lts: &[Lifetime]) -> Vec<Lifetime> {\n+        noop_fold_lifetimes(lts, self)\n+    }\n+\n+    fn fold_ty_param(&mut self, tp: &TyParam) -> TyParam {\n+        noop_fold_ty_param(tp, self)\n+    }\n+\n+    fn fold_ty_params(&mut self, tps: &[TyParam]) -> OwnedSlice<TyParam> {\n+        noop_fold_ty_params(tps, self)\n+    }\n+\n+    fn fold_tt(&mut self, tt: &TokenTree) -> TokenTree {\n+        noop_fold_tt(tt, self)\n+    }\n+\n+    fn fold_tts(&mut self, tts: &[TokenTree]) -> Vec<TokenTree> {\n+        noop_fold_tts(tts, self)\n+    }\n+\n+    fn fold_token(&mut self, t: &token::Token) -> token::Token {\n+        noop_fold_token(t, self)\n+    }\n+\n+    fn fold_interpolated(&mut self, nt : &token::Nonterminal) -> token::Nonterminal {\n+        noop_fold_interpolated(nt, self)\n+    }\n+\n+    fn fold_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<Lifetime> {\n+        noop_fold_opt_lifetime(o_lt, self)\n+    }\n+\n+    fn fold_variant_arg(&mut self, va: &VariantArg) -> VariantArg {\n+        noop_fold_variant_arg(va, self)\n+    }\n+\n+    fn fold_ty_param_bound(&mut self, tpb: &TyParamBound) -> TyParamBound {\n+        noop_fold_ty_param_bound(tpb, self)\n+    }\n+\n+    fn fold_opt_bounds(&mut self, b: &Option<OwnedSlice<TyParamBound>>)\n+                       -> Option<OwnedSlice<TyParamBound>> {\n+        noop_fold_opt_bounds(b, self)\n+    }\n+\n+    fn fold_mt(&mut self, mt: &MutTy) -> MutTy {\n+        noop_fold_mt(mt, self)\n     }\n \n+    fn fold_field(&mut self, field: Field) -> Field {\n+        noop_fold_field(field, self)\n+    }\n+\n+// Helper methods:\n+\n     fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n                  es: &[Gc<Expr>]) -> Vec<Gc<Expr>> {\n         es.iter().map(|x| f(*x)).collect()\n@@ -330,68 +250,275 @@ pub trait Folder {\n     fn new_span(&mut self, sp: Span) -> Span {\n         sp\n     }\n+}\n \n-    fn fold_explicit_self(&mut self, es: &ExplicitSelf) -> ExplicitSelf {\n-        Spanned {\n-            span: self.new_span(es.span),\n-            node: self.fold_explicit_self_(&es.node)\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: &[Gc<MetaItem>], fld: &mut T)\n+                                       -> Vec<Gc<MetaItem>> {\n+    meta_items.iter().map(|x| box (GC) fld.fold_meta_item(&**x)).collect()\n+}\n+\n+pub fn noop_fold_view_path<T: Folder>(view_path: Gc<ViewPath>, fld: &mut T) -> Gc<ViewPath> {\n+    let inner_view_path = match view_path.node {\n+        ViewPathSimple(ref ident, ref path, node_id) => {\n+            let id = fld.new_id(node_id);\n+            ViewPathSimple(ident.clone(),\n+                        fld.fold_path(path),\n+                        id)\n+        }\n+        ViewPathGlob(ref path, node_id) => {\n+            let id = fld.new_id(node_id);\n+            ViewPathGlob(fld.fold_path(path), id)\n         }\n+        ViewPathList(ref path, ref path_list_idents, node_id) => {\n+            let id = fld.new_id(node_id);\n+            ViewPathList(fld.fold_path(path),\n+                        path_list_idents.iter().map(|path_list_ident| {\n+                            Spanned {\n+                                node: match path_list_ident.node {\n+                                    PathListIdent { id, name } =>\n+                                        PathListIdent {\n+                                            id: fld.new_id(id),\n+                                            name: name.clone()\n+                                        },\n+                                    PathListMod { id } =>\n+                                        PathListMod { id: fld.new_id(id) }\n+                                },\n+                                span: fld.new_span(path_list_ident.span)\n+                            }\n+                        }).collect(),\n+                        id)\n+        }\n+    };\n+    box(GC) Spanned {\n+        node: inner_view_path,\n+        span: fld.new_span(view_path.span),\n     }\n+}\n \n-    fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n-        match *es {\n-            SelfStatic | SelfValue(_) => *es,\n-            SelfRegion(ref lifetime, m, id) => {\n-                SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n-            }\n-            SelfExplicit(ref typ, id) => SelfExplicit(self.fold_ty(*typ), id),\n+pub fn noop_fold_arm<T: Folder>(a: &Arm, fld: &mut T) -> Arm {\n+    Arm {\n+        attrs: a.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n+        pats: a.pats.iter().map(|x| fld.fold_pat(*x)).collect(),\n+        guard: a.guard.map(|x| fld.fold_expr(x)),\n+        body: fld.fold_expr(a.body),\n+    }\n+}\n+\n+pub fn noop_fold_decl<T: Folder>(d: Gc<Decl>, fld: &mut T) -> SmallVector<Gc<Decl>> {\n+    let node = match d.node {\n+        DeclLocal(ref l) => SmallVector::one(DeclLocal(fld.fold_local(*l))),\n+        DeclItem(it) => {\n+            fld.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n+        }\n+    };\n+\n+    node.move_iter().map(|node| {\n+        box(GC) Spanned {\n+            node: node,\n+            span: fld.new_span(d.span),\n+        }\n+    }).collect()\n+}\n+\n+pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n+    let id = fld.new_id(t.id);\n+    let node = match t.node {\n+        TyNil | TyBot | TyInfer => t.node.clone(),\n+        TyBox(ty) => TyBox(fld.fold_ty(ty)),\n+        TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n+        TyVec(ty) => TyVec(fld.fold_ty(ty)),\n+        TyPtr(ref mt) => TyPtr(fld.fold_mt(mt)),\n+        TyRptr(ref region, ref mt) => {\n+            TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+        }\n+        TyClosure(ref f, ref region) => {\n+            TyClosure(box(GC) ClosureTy {\n+                fn_style: f.fn_style,\n+                onceness: f.onceness,\n+                bounds: fld.fold_opt_bounds(&f.bounds),\n+                decl: fld.fold_fn_decl(&*f.decl),\n+                lifetimes: f.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n+            }, fld.fold_opt_lifetime(region))\n+        }\n+        TyProc(ref f) => {\n+            TyProc(box(GC) ClosureTy {\n+                fn_style: f.fn_style,\n+                onceness: f.onceness,\n+                bounds: fld.fold_opt_bounds(&f.bounds),\n+                decl: fld.fold_fn_decl(&*f.decl),\n+                lifetimes: f.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n+            })\n+        }\n+        TyBareFn(ref f) => {\n+            TyBareFn(box(GC) BareFnTy {\n+                lifetimes: f.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n+                fn_style: f.fn_style,\n+                abi: f.abi,\n+                decl: fld.fold_fn_decl(&*f.decl)\n+            })\n+        }\n+        TyUnboxedFn(ref f) => {\n+            TyUnboxedFn(box(GC) UnboxedFnTy {\n+                decl: fld.fold_fn_decl(&*f.decl),\n+            })\n+        }\n+        TyTup(ref tys) => TyTup(tys.iter().map(|&ty| fld.fold_ty(ty)).collect()),\n+        TyParen(ref ty) => TyParen(fld.fold_ty(*ty)),\n+        TyPath(ref path, ref bounds, id) => {\n+            let id = fld.new_id(id);\n+            TyPath(fld.fold_path(path),\n+                    fld.fold_opt_bounds(bounds),\n+                    id)\n+        }\n+        TyFixedLengthVec(ty, e) => {\n+            TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+        }\n+        TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n+    };\n+    P(Ty {\n+        id: id,\n+        span: fld.new_span(t.span),\n+        node: node,\n+    })\n+}\n+\n+pub fn noop_fold_foreign_mod<T: Folder>(nm: &ForeignMod, fld: &mut T) -> ForeignMod {\n+    ast::ForeignMod {\n+        abi: nm.abi,\n+        view_items: nm.view_items\n+                        .iter()\n+                        .map(|x| fld.fold_view_item(x))\n+                        .collect(),\n+        items: nm.items\n+                    .iter()\n+                    .map(|x| fld.fold_foreign_item(*x))\n+                    .collect(),\n+    }\n+}\n+\n+pub fn noop_fold_variant<T: Folder>(v: &Variant, fld: &mut T) -> P<Variant> {\n+    let id = fld.new_id(v.node.id);\n+    let kind;\n+    match v.node.kind {\n+        TupleVariantKind(ref variant_args) => {\n+            kind = TupleVariantKind(variant_args.iter().map(|x|\n+                fld.fold_variant_arg(x)).collect())\n+        }\n+        StructVariantKind(ref struct_def) => {\n+            kind = StructVariantKind(box(GC) ast::StructDef {\n+                fields: struct_def.fields.iter()\n+                    .map(|f| fld.fold_struct_field(f)).collect(),\n+                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(c)),\n+                super_struct: match struct_def.super_struct {\n+                    Some(t) => Some(fld.fold_ty(t)),\n+                    None => None\n+                },\n+                is_virtual: struct_def.is_virtual,\n+            })\n         }\n     }\n \n-    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n+    let attrs = v.node.attrs.iter().map(|x| fld.fold_attribute(*x)).collect();\n+\n+    let de = match v.node.disr_expr {\n+        Some(e) => Some(fld.fold_expr(e)),\n+        None => None\n+    };\n+    let node = ast::Variant_ {\n+        name: v.node.name,\n+        attrs: attrs,\n+        kind: kind,\n+        id: id,\n+        disr_expr: de,\n+        vis: v.node.vis,\n+    };\n+    P(Spanned {\n+        node: node,\n+        span: fld.new_span(v.span),\n+    })\n+}\n+\n+pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n+    i\n+}\n+\n+pub fn noop_fold_path<T: Folder>(p: &Path, fld: &mut T) -> Path {\n+    ast::Path {\n+        span: fld.new_span(p.span),\n+        global: p.global,\n+        segments: p.segments.iter().map(|segment| ast::PathSegment {\n+            identifier: fld.fold_ident(segment.identifier),\n+            lifetimes: segment.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n+            types: segment.types.iter().map(|&typ| fld.fold_ty(typ)).collect(),\n+        }).collect()\n     }\n+}\n \n-    //used in noop_fold_item and noop_fold_crate\n-    fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n-        Spanned {\n-            span: self.new_span(at.span),\n-            node: ast::Attribute_ {\n-                id: at.node.id,\n-                style: at.node.style,\n-                value: fold_meta_item_(at.node.value, self),\n-                is_sugared_doc: at.node.is_sugared_doc\n-            }\n+pub fn noop_fold_local<T: Folder>(l: Gc<Local>, fld: &mut T) -> Gc<Local> {\n+    let id = fld.new_id(l.id); // Needs to be first, for ast_map.\n+    box(GC) Local {\n+        id: id,\n+        ty: fld.fold_ty(l.ty),\n+        pat: fld.fold_pat(l.pat),\n+        init: l.init.map(|e| fld.fold_expr(e)),\n+        span: fld.new_span(l.span),\n+        source: l.source,\n+    }\n+}\n+\n+pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n+    Spanned {\n+        span: fld.new_span(at.span),\n+        node: ast::Attribute_ {\n+            id: at.node.id,\n+            style: at.node.style,\n+            value: box (GC) fld.fold_meta_item(&*at.node.value),\n+            is_sugared_doc: at.node.is_sugared_doc\n         }\n     }\n+}\n \n+pub fn noop_fold_explicit_self_underscore<T: Folder>(es: &ExplicitSelf_, fld: &mut T)\n+                                                     -> ExplicitSelf_ {\n+    match *es {\n+        SelfStatic | SelfValue(_) => *es,\n+        SelfRegion(ref lifetime, m, id) => {\n+            SelfRegion(fld.fold_opt_lifetime(lifetime), m, id)\n+        }\n+        SelfExplicit(ref typ, id) => SelfExplicit(fld.fold_ty(*typ), id),\n+    }\n+}\n \n+pub fn noop_fold_explicit_self<T: Folder>(es: &ExplicitSelf, fld: &mut T) -> ExplicitSelf {\n+    Spanned {\n+        span: fld.new_span(es.span),\n+        node: fld.fold_explicit_self_underscore(&es.node)\n+    }\n }\n \n \n-pub fn fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n+pub fn noop_fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: match macro.node {\n             MacInvocTT(ref p, ref tts, ctxt) => {\n                 MacInvocTT(fld.fold_path(p),\n-                           fold_tts(tts.as_slice(), fld),\n+                           fld.fold_tts(tts.as_slice()),\n                            ctxt)\n             }\n         },\n         span: fld.new_span(macro.span)\n     }\n }\n \n-/* some little folds that probably aren't useful to have in Folder itself*/\n-\n-//used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T: Folder>(mi: Gc<MetaItem>, fld: &mut T) -> Gc<MetaItem> {\n-    box(GC) Spanned {\n+pub fn noop_fold_meta_item<T: Folder>(mi: &MetaItem, fld: &mut T) -> MetaItem {\n+    Spanned {\n         node:\n             match mi.node {\n                 MetaWord(ref id) => MetaWord((*id).clone()),\n                 MetaList(ref id, ref mis) => {\n-                    MetaList((*id).clone(), mis.iter().map(|e| fold_meta_item_(*e, fld)).collect())\n+                    MetaList((*id).clone(),\n+                             mis.iter()\n+                                .map(|e| box (GC) fld.fold_meta_item(&**e)).collect())\n                 }\n                 MetaNameValue(ref id, ref s) => {\n                     MetaNameValue((*id).clone(), (*s).clone())\n@@ -400,8 +527,7 @@ fn fold_meta_item_<T: Folder>(mi: Gc<MetaItem>, fld: &mut T) -> Gc<MetaItem> {\n         span: fld.new_span(mi.span) }\n }\n \n-//used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n+pub fn noop_fold_arg<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n     Arg {\n         id: id,\n@@ -410,39 +536,38 @@ fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n     }\n }\n \n-pub fn fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n+pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n     match *tt {\n         TTTok(span, ref tok) =>\n-            TTTok(span, fold_token(tok,fld)),\n-        TTDelim(ref tts) => TTDelim(Rc::new(fold_tts(tts.as_slice(), fld))),\n+            TTTok(span, fld.fold_token(tok)),\n+        TTDelim(ref tts) => TTDelim(Rc::new(fld.fold_tts(tts.as_slice()))),\n         TTSeq(span, ref pattern, ref sep, is_optional) =>\n             TTSeq(span,\n-                  Rc::new(fold_tts(pattern.as_slice(), fld)),\n-                  sep.as_ref().map(|tok| fold_token(tok,fld)),\n+                  Rc::new(fld.fold_tts(pattern.as_slice())),\n+                  sep.as_ref().map(|tok| fld.fold_token(tok)),\n                   is_optional),\n         TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n     }\n }\n \n-pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n-    tts.iter().map(|tt| fold_tt(tt,fld)).collect()\n+pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n+    tts.iter().map(|tt| fld.fold_tt(tt)).collect()\n }\n \n-\n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n-fn fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n+pub fn noop_fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n         }\n         token::LIFETIME(id) => token::LIFETIME(fld.fold_ident(id)),\n-        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fold_interpolated(nt,fld)),\n+        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fld.fold_interpolated(nt)),\n         _ => (*t).clone()\n     }\n }\n \n-// apply folder to elements of interpolated nodes\n+/// apply folder to elements of interpolated nodes\n //\n // NB: this can occur only when applying a fold to partially expanded code, where\n // parsed pieces have gotten implanted ito *other* macro invocations. This is relevant\n@@ -462,7 +587,8 @@ fn fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n // BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n // multiple items, but decided against it when I looked at parse_item_or_view_item and\n // tried to figure out what I would do with multiple items there....\n-fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token::Nonterminal {\n+pub fn noop_fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T)\n+                                         -> token::Nonterminal {\n     match *nt {\n         token::NtItem(item) =>\n             token::NtItem(fld.fold_item(item)\n@@ -482,27 +608,27 @@ fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token:\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n         token::NtIdent(ref id, is_mod_name) =>\n             token::NtIdent(box fld.fold_ident(**id),is_mod_name),\n-        token::NtMeta(meta_item) => token::NtMeta(fold_meta_item_(meta_item,fld)),\n+        token::NtMeta(meta_item) => token::NtMeta(box (GC) fld.fold_meta_item(&*meta_item)),\n         token::NtPath(ref path) => token::NtPath(box fld.fold_path(&**path)),\n-        token::NtTT(tt) => token::NtTT(box (GC) fold_tt(&*tt,fld)),\n+        token::NtTT(tt) => token::NtTT(box (GC) fld.fold_tt(&*tt)),\n         // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n         _ => (*nt).clone()\n     }\n }\n \n pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n     P(FnDecl {\n-        inputs: decl.inputs.iter().map(|x| fold_arg_(x, fld)).collect(), // bad copy\n+        inputs: decl.inputs.iter().map(|x| fld.fold_arg(x)).collect(), // bad copy\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n         variadic: decl.variadic\n     })\n }\n \n-fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n-                                    -> TyParamBound {\n+pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n+                                           -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n         StaticRegionTyParamBound => StaticRegionTyParamBound,\n         UnboxedFnTyParamBound(ref unboxed_function_type) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n@@ -513,21 +639,21 @@ fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n     }\n }\n \n-pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n+pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n     let id = fld.new_id(tp.id);\n     TyParam {\n         ident: tp.ident,\n         id: id,\n-        bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n-        unbound: tp.unbound.as_ref().map(|x| fold_ty_param_bound(x, fld)),\n+        bounds: tp.bounds.map(|x| fld.fold_ty_param_bound(x)),\n+        unbound: tp.unbound.as_ref().map(|x| fld.fold_ty_param_bound(x)),\n         default: tp.default.map(|x| fld.fold_ty(x)),\n         span: tp.span\n     }\n }\n \n-pub fn fold_ty_params<T: Folder>(tps: &OwnedSlice<TyParam>, fld: &mut T)\n-                                   -> OwnedSlice<TyParam> {\n-    tps.map(|tp| fold_ty_param(tp, fld))\n+pub fn noop_fold_ty_params<T: Folder>(tps: &[TyParam], fld: &mut T)\n+                                      -> OwnedSlice<TyParam> {\n+    tps.iter().map(|tp| fld.fold_ty_param(tp)).collect()\n }\n \n pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n@@ -539,25 +665,24 @@ pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     }\n }\n \n-pub fn fold_lifetimes<T: Folder>(lts: &Vec<Lifetime>, fld: &mut T)\n-                                   -> Vec<Lifetime> {\n+pub fn noop_fold_lifetimes<T: Folder>(lts: &[Lifetime], fld: &mut T) -> Vec<Lifetime> {\n     lts.iter().map(|l| fld.fold_lifetime(l)).collect()\n }\n \n-pub fn fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n+pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                       -> Option<Lifetime> {\n     o_lt.as_ref().map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n-    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n-              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n+pub fn noop_fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n+    Generics {ty_params: fld.fold_ty_params(generics.ty_params.as_slice()),\n+              lifetimes: fld.fold_lifetimes(generics.lifetimes.as_slice())}\n }\n \n-fn fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n                               fld: &mut T) -> Gc<StructDef> {\n     box(GC) ast::StructDef {\n-        fields: struct_def.fields.iter().map(|f| fold_struct_field(f, fld)).collect(),\n+        fields: struct_def.fields.iter().map(|f| fld.fold_struct_field(f)).collect(),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n         super_struct: match struct_def.super_struct {\n             Some(t) => Some(fld.fold_ty(t)),\n@@ -567,15 +692,15 @@ fn fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n     }\n }\n \n-fn fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n+pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n     let id = fld.new_id(p.ref_id);\n     ast::TraitRef {\n         path: fld.fold_path(&p.path),\n         ref_id: id,\n     }\n }\n \n-fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n+pub fn noop_fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n     let id = fld.new_id(f.node.id);\n     Spanned {\n         node: ast::StructField_ {\n@@ -588,31 +713,31 @@ fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n     }\n }\n \n-fn fold_field_<T: Folder>(field: Field, folder: &mut T) -> Field {\n+pub fn noop_fold_field<T: Folder>(field: Field, folder: &mut T) -> Field {\n     ast::Field {\n         ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n         expr: folder.fold_expr(field.expr),\n         span: folder.new_span(field.span),\n     }\n }\n \n-fn fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n+pub fn noop_fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n     MutTy {\n         ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n \n-fn fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+pub fn noop_fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n                               -> Option<OwnedSlice<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n-            fold_ty_param_bound(bound, folder)\n+            folder.fold_ty_param_bound(bound)\n         })\n     })\n }\n \n-fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n+pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n     let id = folder.new_id(va.id);\n     ast::VariantArg {\n         ty: folder.fold_ty(va.ty),\n@@ -664,14 +789,14 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n                 folder.fold_fn_decl(&*decl),\n                 fn_style,\n                 abi,\n-                fold_generics(generics, folder),\n+                folder.fold_generics(generics),\n                 folder.fold_block(body)\n             )\n         }\n         ItemMod(ref m) => ItemMod(folder.fold_mod(m)),\n         ItemForeignMod(ref nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n         ItemTy(t, ref generics) => {\n-            ItemTy(folder.fold_ty(t), fold_generics(generics, folder))\n+            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n         ItemEnum(ref enum_definition, ref generics) => {\n             ItemEnum(\n@@ -680,15 +805,15 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n                         folder.fold_variant(&*x)\n                     }).collect(),\n                 },\n-                fold_generics(generics, folder))\n+                folder.fold_generics(generics))\n         }\n         ItemStruct(ref struct_def, ref generics) => {\n-            let struct_def = fold_struct_def(*struct_def, folder);\n-            ItemStruct(struct_def, fold_generics(generics, folder))\n+            let struct_def = folder.fold_struct_def(*struct_def);\n+            ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemImpl(ref generics, ref ifce, ty, ref methods) => {\n-            ItemImpl(fold_generics(generics, folder),\n-                     ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n+            ItemImpl(folder.fold_generics(generics),\n+                     ifce.as_ref().map(|p| folder.fold_trait_ref(p)),\n                      folder.fold_ty(ty),\n                      methods.iter().flat_map(|x| folder.fold_method(*x).move_iter()).collect()\n             )\n@@ -711,9 +836,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n                 };\n                 r\n             }).collect();\n-            ItemTrait(fold_generics(generics, folder),\n+            ItemTrait(folder.fold_generics(generics),\n                       unbound.clone(),\n-                      traits.iter().map(|p| fold_trait_ref(p, folder)).collect(),\n+                      traits.iter().map(|p| folder.fold_trait_ref(p)).collect(),\n                       methods)\n         }\n         ItemMac(ref m) => ItemMac(folder.fold_mac(m)),\n@@ -729,7 +854,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n         fn_style: m.fn_style,\n         abi: m.abi,\n         decl: fld.fold_fn_decl(&*m.decl),\n-        generics: fold_generics(&m.generics, fld),\n+        generics: fld.fold_generics(&m.generics),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         span: fld.new_span(m.span),\n         vis: m.vis,\n@@ -750,7 +875,7 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     Crate {\n         module: folder.fold_mod(&c.module),\n         attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n-        config: c.config.iter().map(|x| fold_meta_item_(*x, folder)).collect(),\n+        config: c.config.iter().map(|x| box (GC) folder.fold_meta_item(&**x)).collect(),\n         span: folder.new_span(c.span),\n         exported_macros: c.exported_macros\n     }\n@@ -759,12 +884,12 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n // fold one item into possibly many items\n pub fn noop_fold_item<T: Folder>(i: &Item,\n                                  folder: &mut T) -> SmallVector<Gc<Item>> {\n-    SmallVector::one(box(GC) noop_fold_item_(i,folder))\n+    SmallVector::one(box(GC) folder.fold_item_simple(i))\n }\n \n \n // fold one item into exactly one item\n-pub fn noop_fold_item_<T: Folder>(i: &Item, folder: &mut T) -> Item {\n+pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {\n     let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n     let node = folder.fold_item_underscore(&i.node);\n     let ident = match node {\n@@ -795,11 +920,11 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n         node: match ni.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 ForeignItemFn(P(FnDecl {\n-                    inputs: fdec.inputs.iter().map(|a| fold_arg_(a, folder)).collect(),\n+                    inputs: fdec.inputs.iter().map(|a| folder.fold_arg(a)).collect(),\n                     output: folder.fold_ty(fdec.output),\n                     cf: fdec.cf,\n                     variadic: fdec.variadic\n-                }), fold_generics(generics, folder))\n+                }), folder.fold_generics(generics))\n             }\n             ForeignItemStatic(t, m) => {\n                 ForeignItemStatic(folder.fold_ty(t), m)\n@@ -828,7 +953,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc\n                      body,\n                      vis) => {\n                 MethDecl(folder.fold_ident(ident),\n-                         fold_generics(generics, folder),\n+                         folder.fold_generics(generics),\n                          abi,\n                          folder.fold_explicit_self(explicit_self),\n                          fn_style,\n@@ -998,7 +1123,7 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n         ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(folder.fold_path(path),\n-                       fields.iter().map(|x| fold_field_(*x, folder)).collect(),\n+                       fields.iter().map(|x| folder.fold_field(*x)).collect(),\n                        maybe_expr.map(|x| folder.fold_expr(x)))\n         },\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n@@ -1061,7 +1186,7 @@ mod test {\n             token::str_to_ident(\"zz\")\n         }\n         fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n-            fold::fold_mac(macro, self)\n+            fold::noop_fold_mac(macro, self)\n         }\n     }\n "}]}