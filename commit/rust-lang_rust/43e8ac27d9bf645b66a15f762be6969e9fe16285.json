{"sha": "43e8ac27d9bf645b66a15f762be6969e9fe16285", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZThhYzI3ZDliZjY0NWI2NmExNWY3NjJiZTY5NjllOWZlMTYyODU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-02-12T16:38:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-02-12T17:11:06Z"}, "message": "rustc: Persist LLVM's `Linker` in Fat LTO\n\nThis commit updates our Fat LTO logic to tweak our custom wrapper around LLVM's\n\"link modules\" functionality. Previously whenever the\n`LLVMRustLinkInExternalBitcode` function was called it would call LLVM's\n`Linker::linkModules` wrapper. Internally this would crate an instance of a\n`Linker` which internally creates an instance of an `IRMover`. Unfortunately for\nus the creation of `IRMover` is somewhat O(n) with the input module. This means\nthat every time we linked a module it was O(n) with respect to the entire module\nwe had built up!\n\nNow the modules we build up during LTO are quite large, so this quickly started\ncreating an O(n^2) problem for us! Discovered in #48025 it turns out this has\nalways been a problem and we just haven't noticed it. It became particularly\nworse recently though due to most libraries having 16x more object files than\nthey previously did (1 -> 16).\n\nThis commit fixes this performance issue by preserving the `Linker` instance\nacross all links into the main LLVM module. This means we only create one\n`IRMover` and allows LTO to progress much speedier.\n\nFrom the `cargo-cache` project in #48025 a **full build** locally when from\n5m15s to 2m24s. Looking at the timing logs each object file was linked in in\nsingle-digit millisecond rather than hundreds, clearly being a nice improvement!\n\nCloses #48025", "tree": {"sha": "aa05f7271eb13b1697ef21e27b0fa8dba7a16483", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa05f7271eb13b1697ef21e27b0fa8dba7a16483"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e8ac27d9bf645b66a15f762be6969e9fe16285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e8ac27d9bf645b66a15f762be6969e9fe16285", "html_url": "https://github.com/rust-lang/rust/commit/43e8ac27d9bf645b66a15f762be6969e9fe16285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e8ac27d9bf645b66a15f762be6969e9fe16285/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16362c737fe740f630ada06349fa9004e2a51bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/16362c737fe740f630ada06349fa9004e2a51bb7", "html_url": "https://github.com/rust-lang/rust/commit/16362c737fe740f630ada06349fa9004e2a51bb7"}], "stats": {"total": 163, "additions": 114, "deletions": 49}, "files": [{"sha": "54e3f544acb68b0258186b0729245a02b324070a", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=43e8ac27d9bf645b66a15f762be6969e9fe16285", "patch": "@@ -155,6 +155,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+       .file(\"../rustllvm/Linker.cpp\")\n        .cpp(true)\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"rustllvm\");"}, {"sha": "e71bef512cf067c84956d197d93394565fac9476", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=43e8ac27d9bf645b66a15f762be6969e9fe16285", "patch": "@@ -444,6 +444,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Linker_opaque {}\n+pub type LinkerRef = *mut Linker_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -1608,7 +1611,6 @@ extern \"C\" {\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef, bc: *const c_char, len: size_t) -> bool;\n     pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n@@ -1724,4 +1726,10 @@ extern \"C\" {\n                                            CU2: *mut *mut c_void);\n     pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n     pub fn LLVMRustThinLTORemoveAvailableExternally(M: ModuleRef);\n+\n+    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n+    pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n+                             bytecode: *const c_char,\n+                             bytecode_len: usize) -> bool;\n+    pub fn LLVMRustLinkerFree(linker: LinkerRef);\n }"}, {"sha": "a33270380196f5ec9ec5774eeecbd55ad5922029", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=43e8ac27d9bf645b66a15f762be6969e9fe16285", "patch": "@@ -247,22 +247,20 @@ fn fat_lto(cgcx: &CodegenContext,\n     // know much about the memory management here so we err on the side of being\n     // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n+    let mut linker = Linker::new(llmod);\n     for (bc_decoded, name) in serialized_modules {\n         info!(\"linking {:?}\", name);\n-        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || unsafe {\n+        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n             let data = bc_decoded.data();\n-            if llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                   data.as_ptr() as *const libc::c_char,\n-                                                   data.len() as libc::size_t) {\n-                Ok(())\n-            } else {\n+            linker.add(&data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n-                Err(write::llvm_err(&diag_handler, msg))\n-            }\n+                write::llvm_err(&diag_handler, msg)\n+            })\n         })?;\n         timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n+    drop(linker);\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n     // Internalize everything that *isn't* in our whitelist to help strip out\n@@ -289,6 +287,32 @@ fn fat_lto(cgcx: &CodegenContext,\n     }])\n }\n \n+struct Linker(llvm::LinkerRef);\n+\n+impl Linker {\n+    fn new(llmod: ModuleRef) -> Linker {\n+        unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n+    }\n+\n+    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+        unsafe {\n+            if llvm::LLVMRustLinkerAdd(self.0,\n+                                       bytecode.as_ptr() as *const libc::c_char,\n+                                       bytecode.len()) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Linker {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMRustLinkerFree(self.0); }\n+    }\n+}\n+\n /// Prepare \"thin\" LTO to get run on these modules.\n ///\n /// The general structure of ThinLTO is quite different from the structure of"}, {"sha": "534e4b910902e89ce567eb364a3bf4b5e2b3600f", "filename": "src/rustllvm/Linker.cpp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Frustllvm%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Frustllvm%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FLinker.cpp?ref=43e8ac27d9bf645b66a15f762be6969e9fe16285", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"llvm/Linker/Linker.h\"\n+\n+#include \"rustllvm.h\"\n+\n+using namespace llvm;\n+\n+struct RustLinker {\n+  Linker L;\n+  LLVMContext &Ctx;\n+\n+  RustLinker(Module &M) :\n+    L(M),\n+    Ctx(M.getContext())\n+  {}\n+};\n+\n+extern \"C\" RustLinker*\n+LLVMRustLinkerNew(LLVMModuleRef DstRef) {\n+  Module *Dst = unwrap(DstRef);\n+\n+  auto Ret = llvm::make_unique<RustLinker>(*Dst);\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustLinkerFree(RustLinker *L) {\n+  delete L;\n+}\n+\n+extern \"C\" bool\n+LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), L->Ctx);\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n+\n+  auto Src = std::move(*SrcOrError);\n+#else\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(Buf), L->Ctx);\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n+#endif\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  if (L->L.linkInModule(std::move(Src))) {\n+#else\n+  if (L->L.linkInModule(std::move(Src.get()))) {\n+#endif\n+    LLVMRustSetLastError(\"\");\n+    return false;\n+  }\n+  return true;\n+}"}, {"sha": "27d5496f57628c4c7d6c05c41a6fee03f12357c3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/43e8ac27d9bf645b66a15f762be6969e9fe16285/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=43e8ac27d9bf645b66a15f762be6969e9fe16285", "patch": "@@ -916,46 +916,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n-                                              size_t Len) {\n-  Module *Dst = unwrap(DstRef);\n-\n-  std::unique_ptr<MemoryBuffer> Buf =\n-      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n-\n-#if LLVM_VERSION_GE(4, 0)\n-  Expected<std::unique_ptr<Module>> SrcOrError =\n-      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), Dst->getContext());\n-  if (!SrcOrError) {\n-    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-    return false;\n-  }\n-\n-  auto Src = std::move(*SrcOrError);\n-#else\n-  ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(Buf), Dst->getContext());\n-  if (!Src) {\n-    LLVMRustSetLastError(Src.getError().message().c_str());\n-    return false;\n-  }\n-#endif\n-\n-  std::string Err;\n-\n-  raw_string_ostream Stream(Err);\n-  DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_GE(4, 0)\n-  if (Linker::linkModules(*Dst, std::move(Src))) {\n-#else\n-  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n-#endif\n-    LLVMRustSetLastError(Err.c_str());\n-    return false;\n-  }\n-  return true;\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The"}]}