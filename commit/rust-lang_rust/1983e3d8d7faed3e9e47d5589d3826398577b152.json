{"sha": "1983e3d8d7faed3e9e47d5589d3826398577b152", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ODNlM2Q4ZDdmYWVkM2U5ZTQ3ZDU1ODlkMzgyNjM5ODU3N2IxNTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-20T19:29:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-20T21:04:38Z"}, "message": "Make + mode by-value if the type is immediate, by-ref otherwise\n\nFixes #3523", "tree": {"sha": "883cc4d62a9d630eb380c1cb2daecdbe00ac6c7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/883cc4d62a9d630eb380c1cb2daecdbe00ac6c7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1983e3d8d7faed3e9e47d5589d3826398577b152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1983e3d8d7faed3e9e47d5589d3826398577b152", "html_url": "https://github.com/rust-lang/rust/commit/1983e3d8d7faed3e9e47d5589d3826398577b152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1983e3d8d7faed3e9e47d5589d3826398577b152/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9f997f8e2a1511b11ef910084af71b25336a96", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9f997f8e2a1511b11ef910084af71b25336a96", "html_url": "https://github.com/rust-lang/rust/commit/6e9f997f8e2a1511b11ef910084af71b25336a96"}], "stats": {"total": 291, "additions": 199, "deletions": 92}, "files": [{"sha": "db590774370733e50c898585798ab5db71203de8", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -37,6 +37,15 @@ trait IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: Cb);\n }\n \n+impl bool: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n+        f([\n+            self as u8\n+        ]);\n+    }\n+}\n+\n impl u8: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(_lsb0: bool, f: Cb) {"}, {"sha": "1601d583f00d9ea15ce29b9c6601042c96fe270a", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 58, "deletions": 46, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -1437,10 +1437,9 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n-                             args: ~[ast::arg]) {\n+                             args: ~[ast::arg]) -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n-    // Skip the implicit arguments 0, and 1.\n-    let mut arg_n = first_real_arg;\n+\n     match ty_self {\n       impl_self(tt) => {\n         cx.llself = Some(ValSelfData {\n@@ -1459,28 +1458,22 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n       no_self => ()\n     }\n \n-    // Populate the llargs field of the function context with the ValueRefs\n-    // that we get from llvm::LLVMGetParam for each argument.\n-    for vec::each(args) |arg| {\n-        let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n-        assert (llarg as int != 0);\n-        // Note that this uses local_mem even for things passed by value.\n-        // copy_args_to_allocas will overwrite the table entry with local_imm\n-        // before it's actually used.\n-        cx.llargs.insert(arg.id, local_mem(llarg));\n-        arg_n += 1u;\n-    }\n+    // Return an array containing the ValueRefs that we get from\n+    // llvm::LLVMGetParam for each argument.\n+    vec::from_fn(args.len(), |i| {\n+        let arg_n = first_real_arg + i;\n+        llvm::LLVMGetParam(cx.llfn, arg_n as c_uint)\n+    })\n }\n \n-fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n-                        arg_tys: ~[ty::arg]) -> block {\n+fn copy_args_to_allocas(fcx: fn_ctxt,\n+                        bcx: block,\n+                        args: &[ast::arg],\n+                        raw_llargs: &[ValueRef],\n+                        arg_tys: &[ty::arg]) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n-    let mut arg_n: uint = 0u, bcx = bcx;\n-    let epic_fail = fn@() -> ! {\n-        tcx.sess.bug(~\"someone forgot\\\n-                to document an invariant in copy_args_to_allocas!\");\n-    };\n+    let mut bcx = bcx;\n \n     match fcx.llself {\n       Some(copy slf) => {\n@@ -1496,31 +1489,50 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n       _ => {}\n     }\n \n-    for vec::each(arg_tys) |arg| {\n-        let id = args[arg_n].id;\n-        let argval = match fcx.llargs.get(id) {\n-          local_mem(v) => v,\n-          _ => epic_fail()\n-        };\n-        match ty::resolved_mode(tcx, arg.mode) {\n-          ast::by_mutbl_ref => (),\n-          ast::by_move | ast::by_copy => add_clean(bcx, argval, arg.ty),\n-          ast::by_val => {\n-            if !ty::type_is_immediate(arg.ty) {\n-                let alloc = alloc_ty(bcx, arg.ty);\n-                Store(bcx, argval, alloc);\n-                fcx.llargs.insert(id, local_mem(alloc));\n-            } else {\n-                fcx.llargs.insert(id, local_imm(argval));\n+    for uint::range(0, arg_tys.len()) |arg_n| {\n+        let arg_ty = &arg_tys[arg_n];\n+        let raw_llarg = raw_llargs[arg_n];\n+        let arg_id = args[arg_n].id;\n+\n+        // For certain mode/type combinations, the raw llarg values are passed\n+        // by value.  However, within the fn body itself, we want to always\n+        // have all locals and argumenst be by-ref so that we can cancel the\n+        // cleanup and for better interaction with LLVM's debug info.  So, if\n+        // the argument would be passed by value, we store it into an alloca.\n+        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n+        // the event it's not truly needed.\n+        let llarg;\n+        match ty::resolved_mode(tcx, arg_ty.mode) {\n+            ast::by_ref | ast::by_mutbl_ref => {\n+                llarg = raw_llarg;\n+            }\n+            ast::by_move | ast::by_copy => {\n+                // only by value if immediate:\n+                if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n+                    let alloc = alloc_ty(bcx, arg_ty.ty);\n+                    Store(bcx, raw_llarg, alloc);\n+                    llarg = alloc;\n+                } else {\n+                    llarg = raw_llarg;\n+                }\n+\n+                add_clean(bcx, llarg, arg_ty.ty);\n+            }\n+            ast::by_val => {\n+                // always by value, also not owned, so don't add a cleanup:\n+                let alloc = alloc_ty(bcx, arg_ty.ty);\n+                Store(bcx, raw_llarg, alloc);\n+                llarg = alloc;\n             }\n-          }\n-          ast::by_ref => ()\n         }\n+\n+        fcx.llargs.insert(arg_id, local_mem(llarg));\n+\n         if fcx.ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n         }\n-        arg_n += 1u;\n     }\n+\n     return bcx;\n }\n \n@@ -1558,7 +1570,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n                                   Some(body.span));\n-    create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n \n     // Set GC for function.\n     if ccx.sess.opts.gc {\n@@ -1576,7 +1588,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     let block_ty = node_id_type(bcx, body.node.id);\n \n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n+    bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n \n     maybe_load_env(fcx);\n \n@@ -1648,14 +1660,14 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n          id: varg.id});\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n                                param_substs, None);\n-    create_llargs_for_fn_args(fcx, no_self, fn_args);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let ty_param_substs = match param_substs {\n       Some(substs) => substs.tys,\n       None => ~[]\n     };\n     let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n+    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     // Cast the enum to a type we can GEP into.\n     let llblobptr = if is_degen {\n@@ -1705,11 +1717,11 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // Make the fn context\n     let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n                                Some(psubsts), Some(sp));\n-    create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n     let mut bcx_top = top_scope_block(fcx, body.info());\n     let lltop = bcx_top.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx_top, ctor_id));\n-    bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs, arg_tys);\n+    bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs, raw_llargs, arg_tys);\n \n     // Create a temporary for `self` that we will return at the end\n     let selfdatum = datum::scratch_datum(bcx_top, rslt_ty, true);"}, {"sha": "946a55318ebb3fdf2c7545967c2b3b501ff5fa6a", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -548,6 +548,7 @@ fn trans_arg_expr(bcx: block,\n         let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n         val = llvm::LLVMGetUndef(llformal_ty);\n     } else {\n+        // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => { val = arg_datum.to_ref_llval(bcx); }\n             DontAutorefArg => {\n@@ -583,8 +584,16 @@ fn trans_arg_expr(bcx: block,\n                         // callee is actually invoked.\n                         scratch.add_clean(bcx);\n                         vec::push(*temp_cleanups, scratch.val);\n-                        val = scratch.val;\n-                  }\n+\n+                        match arg_datum.appropriate_mode() {\n+                            ByValue => {\n+                                val = Load(bcx, scratch.val);\n+                            }\n+                            ByRef => {\n+                                val = scratch.val;\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "7896cbbcb5644def777eca962ed7324f2acc5ea4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -1125,7 +1125,10 @@ fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n enum mono_param_id {\n     mono_precise(ty::t, Option<~[mono_id]>),\n     mono_any,\n-    mono_repr(uint /* size */, uint /* align */),\n+    mono_repr(uint /* size */,\n+              uint /* align */,\n+              bool /* is_float */,\n+              datum::DatumMode),\n }\n \n type mono_id_ = {def: ast::def_id, params: ~[mono_param_id]};\n@@ -1140,8 +1143,10 @@ impl mono_param_id: cmp::Eq {\n                 ty_a == ty_b && ids_a == ids_b\n             }\n             (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a), mono_repr(size_b, align_b)) => {\n-                size_a == size_b && align_a == align_b\n+            (mono_repr(size_a, align_a, is_float_a, mode_a),\n+             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n+                size_a == size_b && align_a == align_b &&\n+                    is_float_a == is_float_b && mode_a == mode_b\n             }\n             (mono_precise(*), _) => false,\n             (mono_any, _) => false,\n@@ -1159,8 +1164,10 @@ impl mono_param_id : cmp::Eq {\n                 ty_a == ty_b && ids_a == ids_b\n             }\n             (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a), mono_repr(size_b, align_b)) => {\n-                size_a == size_b && align_a == align_b\n+            (mono_repr(size_a, align_a, is_float_a, mode_a),\n+             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n+                size_a == size_b && align_a == align_b &&\n+                    is_float_a == is_float_b && mode_a == mode_b\n             }\n             (mono_precise(*), _) => false,\n             (mono_any, _) => false,\n@@ -1194,8 +1201,8 @@ impl mono_param_id : to_bytes::IterBytes {\n \n           mono_any => 1u8.iter_bytes(lsb0, f),\n \n-          mono_repr(a,b) =>\n-          to_bytes::iter_bytes_3(&2u8, &a, &b, lsb0, f)\n+          mono_repr(ref a, ref b, ref c, ref d) =>\n+          to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n         }\n     }\n }"}, {"sha": "730f068cbb21cdd8e914f5e67f6170ebd898a29d", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -138,6 +138,29 @@ impl DatumMode {\n     }\n }\n \n+#[cfg(stage0)]\n+impl DatumMode: cmp::Eq {\n+    pure fn eq(&&other: DatumMode) -> bool {\n+        (self as uint) == (other as uint)\n+    }\n+    pure fn ne(&&other: DatumMode) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl DatumMode: cmp::Eq {\n+    pure fn eq(other: &DatumMode) -> bool {\n+        self as uint == (*other as uint)\n+    }\n+    pure fn ne(other: &DatumMode) -> bool { !self.eq(other) }\n+}\n+\n+impl DatumMode: to_bytes::IterBytes {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n /// See `Datum Sources` section at the head of this module.\n enum DatumSource {\n     FromRvalue,\n@@ -186,6 +209,22 @@ fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     Datum { val: scratch, ty: ty, mode: ByRef, source: FromRvalue }\n }\n \n+fn appropriate_mode(ty: ty::t) -> DatumMode {\n+    /*!\n+    *\n+    * Indicates the \"appropriate\" mode for this value,\n+    * which is either by ref or by value, depending\n+    * on whether type is iimmediate or what. */\n+\n+    if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+        ByValue\n+    } else if ty::type_is_immediate(ty) {\n+        ByValue\n+    } else {\n+        ByRef\n+    }\n+}\n+\n impl Datum {\n     fn store_will_move() -> bool {\n         match self.source {\n@@ -446,19 +485,9 @@ impl Datum {\n     }\n \n     fn appropriate_mode() -> DatumMode {\n-        /*!\n-         *\n-         * Indicates the \"appropriate\" mode for this value,\n-         * which is either by ref or by value, depending\n-         * on whether type is iimmediate or what. */\n+        /*! See the `appropriate_mode()` function */\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n-            ByValue\n-        } else if ty::type_is_immediate(self.ty) {\n-            ByValue\n-        } else {\n-            ByRef\n-        }\n+        appropriate_mode(self.ty)\n     }\n \n     fn to_appropriate_llval(bcx: block) -> ValueRef {"}, {"sha": "55d4c8fcd9adba266f63ebb545366f7bcec86fc1", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -877,16 +877,28 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                   fcx.llretptr);\n         }\n         ~\"move_val\" => {\n+            // Create a datum reflecting the value being moved:\n+            //\n+            // - the datum will be by ref if the value is non-immediate;\n+            //\n+            // - the datum has a FromRvalue source because, that way,\n+            //   the `move_to()` method does not feel compelled to\n+            //   zero out the memory where the datum resides.  Zeroing\n+            //   is not necessary since, for intrinsics, there is no\n+            //   cleanup to concern ourselves with.\n             let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: ByRef, source: FromLvalue};\n+                             ty: tp_ty, mode: mode, source: FromRvalue};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n         }\n         ~\"move_val_init\" => {\n+            // See comments for `\"move_val\"`.\n             let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: ByRef, source: FromLvalue};\n+                             ty: tp_ty, mode: mode, source: FromRvalue};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n         }\n         ~\"min_align_of\" => {"}, {"sha": "7ce79fefa9fd32634838ba0181e9ac8927180fb5", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -264,20 +264,37 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         vec::map2(precise_param_ids, uses, |id, uses| {\n             match id {\n                 (a, b@Some(_)) => mono_precise(a, b),\n-              (subst, None) => {\n-                if uses == 0u { mono_any }\n-                else if uses == type_use::use_repr &&\n-                        !ty::type_needs_drop(ccx.tcx, subst) {\n-                    let llty = type_of::type_of(ccx, subst);\n-                    let size = shape::llsize_of_real(ccx, llty);\n-                    let align = shape::llalign_of_pref(ccx, llty);\n-                    // Special value for nil to prevent problems with undef\n-                    // return pointers.\n-                    if size == 1u && ty::type_is_nil(subst) {\n-                        mono_repr(0u, 0u)\n-                    } else { mono_repr(size, align) }\n-                } else { mono_precise(subst, None) }\n-              }\n+                (subst, None) => {\n+                    if uses == 0u {\n+                        mono_any\n+                    } else if uses == type_use::use_repr &&\n+                        !ty::type_needs_drop(ccx.tcx, subst)\n+                    {\n+                        let llty = type_of::type_of(ccx, subst);\n+                        let size = shape::llsize_of_real(ccx, llty);\n+                        let align = shape::llalign_of_pref(ccx, llty);\n+                        let mode = datum::appropriate_mode(subst);\n+\n+                        // FIXME(#3547)---scalars and floats are\n+                        // treated differently in most ABIs.  But we\n+                        // should be doing something more detailed\n+                        // here.\n+                        let is_float = match ty::get(subst).sty {\n+                            ty::ty_float(_) => true,\n+                            _ => false\n+                        };\n+\n+                        // Special value for nil to prevent problems\n+                        // with undef return pointers.\n+                        if size == 1u && ty::type_is_nil(subst) {\n+                            mono_repr(0u, 0u, is_float, mode)\n+                        } else {\n+                            mono_repr(size, align, is_float, mode)\n+                        }\n+                    } else {\n+                        mono_precise(subst, None)\n+                    }\n+                }\n             }\n         })\n       }"}, {"sha": "ac1692d6c33c0f9ae46ceb65a8afa50408864eb9", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -16,10 +16,16 @@ export type_of_non_gc_box;\n export type_of_rooted;\n \n fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n-    let arg_ty = arg.ty;\n-    let llty = type_of(ccx, arg_ty);\n+    let llty = type_of(ccx, arg.ty);\n     match ty::resolved_mode(ccx.tcx, arg.mode) {\n         ast::by_val => llty,\n+        ast::by_copy | ast::by_move => {\n+            if ty::type_is_immediate(arg.ty) {\n+                llty\n+            } else {\n+                T_ptr(llty)\n+            }\n+        }\n         _ => T_ptr(llty)\n     }\n }"}, {"sha": "48bea3e1e056324ea13742392dc9439fb729fcf3", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1983e3d8d7faed3e9e47d5589d3826398577b152/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1983e3d8d7faed3e9e47d5589d3826398577b152", "patch": "@@ -27,8 +27,9 @@ use syntax::ast_map;\n use common::*;\n \n type type_uses = uint; // Bitmask\n-const use_repr: uint = 1u; // Dependency on size/alignment and take/drop glue\n-const use_tydesc: uint = 2u; // Takes the tydesc, or compares\n+const use_repr: uint = 1u;             /* Dependency on size/alignment/mode and\n+                                          take/drop glue */\n+const use_tydesc: uint = 2u;           /* Takes the tydesc, or compares */\n \n type ctx = {ccx: @crate_ctxt,\n             uses: ~[mut type_uses]};\n@@ -46,12 +47,17 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n-      ty::ty_fn(ref fn_ty) => {\n-        for vec::each(fn_ty.sig.inputs) |arg| {\n-            if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n+        ty::ty_fn(ref fn_ty) => {\n+            for vec::each(fn_ty.sig.inputs) |arg| {\n+                match ty::resolved_mode(ccx.tcx, arg.mode) {\n+                    by_val | by_move | by_copy => {\n+                        type_needs(cx, use_repr, arg.ty);\n+                    }\n+                    by_ref | by_mutbl_ref => {}\n+                }\n+            }\n         }\n-      }\n-      _ => ()\n+        _ => ()\n     }\n \n     if fn_id_loc.crate != local_crate {"}]}