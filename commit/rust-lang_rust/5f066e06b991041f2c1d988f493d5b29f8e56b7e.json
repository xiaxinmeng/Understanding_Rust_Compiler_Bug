{"sha": "5f066e06b991041f2c1d988f493d5b29f8e56b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMDY2ZTA2Yjk5MTA0MWYyYzFkOTg4ZjQ5M2Q1YjI5ZjhlNTZiN2U=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-09-23T23:13:14Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-09-23T23:53:06Z"}, "message": "Update to libuv commit 3ca382.\n\nThis patch changes libuv's gyp build system to\nmake it's own makefiles. To generate them for rust,\nrun these commands. They requires python 2.x to\nwork:\n\n$ mkdir -p src/rt/libuv/build\n$ svn co http://gyp.googlecode.com/svn src/rt/libuv/build/gyp\n$ ./etc/src/gyp_uv", "tree": {"sha": "aef6b030f5e3567693ab2cf02f9f9858fd7642ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef6b030f5e3567693ab2cf02f9f9858fd7642ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f066e06b991041f2c1d988f493d5b29f8e56b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f066e06b991041f2c1d988f493d5b29f8e56b7e", "html_url": "https://github.com/rust-lang/rust/commit/5f066e06b991041f2c1d988f493d5b29f8e56b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f066e06b991041f2c1d988f493d5b29f8e56b7e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8f6e9f23736f6a12dfa028d22557d1360648234", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8f6e9f23736f6a12dfa028d22557d1360648234", "html_url": "https://github.com/rust-lang/rust/commit/d8f6e9f23736f6a12dfa028d22557d1360648234"}], "stats": {"total": 37763, "additions": 30554, "deletions": 7209}, "files": [{"sha": "2517b30ae924b24f83382e0de5e59f4e3e03ec9b", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -52,7 +52,7 @@ rustc\n TAGS\n version.ml\n version.texi\n-Makefile\n+./Makefile\n config.mk\n /rt/\n /rustllvm/"}, {"sha": "10c4d7df32cb768ca9350df06cc4e48f99f62529", "filename": "configure", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -406,8 +406,4 @@ done\n \n copy ${CFG_SRC_DIR}Makefile.in ./Makefile\n \n-copy ${CFG_SRC_DIR}src/rt/libuv/Makefile rt/libuv/Makefile\n-copy ${CFG_SRC_DIR}src/rt/libuv/config-unix.mk rt/libuv/config-unix.mk\n-copy ${CFG_SRC_DIR}src/rt/libuv/config-mingw.mk rt/libuv/config-mingw.mk\n-\n step_msg \"complete\""}, {"sha": "682b536ed9bd866eed9f9b47fcd649954cbf9bca", "filename": "mk/clean.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -54,3 +54,4 @@ clean:\n                  aux cp fn ky log pdf html pg toc tp vr cps, \\\n                  $(wildcard doc/*.$(ext)))\n \t$(Q)rm -Rf doc/version.texi\n+\t$(Q)rm -rf rt/libuv"}, {"sha": "b1e21e5f93e4a845d041bf98bd66dfd685771671", "filename": "mk/libuv/mac/Makefile", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2FMakefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,359 @@\n+# We borrow heavily from the kernel build setup, though we are simpler since\n+# we don't have Kconfig tweaking settings on us.\n+\n+# The implicit make rules have it looking for RCS files, among other things.\n+# We instead explicitly write all the rules we care about.\n+# It's even quicker (saves ~200ms) to pass -r on the command line.\n+MAKEFLAGS=-r\n+\n+# The source directory tree.\n+srcdir := ../../..\n+\n+# The name of the builddir.\n+builddir_name ?= out\n+\n+# The V=1 flag on command line makes us verbosely print command lines.\n+ifdef V\n+  quiet=\n+else\n+  quiet=quiet_\n+endif\n+\n+# Specify BUILDTYPE=Release on the command line for a release build.\n+BUILDTYPE ?= Default\n+\n+# Directory all our build output goes into.\n+# Note that this must be two directories beneath src/ for unit tests to pass,\n+# as they reach into the src/ directory for data with relative paths.\n+builddir ?= $(builddir_name)/$(BUILDTYPE)\n+abs_builddir := $(abspath $(builddir))\n+depsdir := $(builddir)/.deps\n+\n+# Object output directory.\n+obj := $(builddir)/obj\n+abs_obj := $(abspath $(obj))\n+\n+# We build up a list of every single one of the targets so we can slurp in the\n+# generated dependency rule Makefiles in one pass.\n+all_deps :=\n+\n+# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+#\n+# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# process so running parallel links can often lead to thrashing.  To disable\n+# the serialization, override FLOCK via an envrionment variable as follows:\n+#\n+#   export FLOCK=\n+#\n+# This will allow make to invoke N linker processes as specified in -jN.\n+FLOCK ?= ./gyp-mac-tool flock $(builddir)/linker.lock\n+\n+\n+\n+LINK ?= $(FLOCK) $(CXX)\n+CC.target ?= $(CC)\n+CFLAGS.target ?= $(CFLAGS)\n+CXX.target ?= $(CXX)\n+CXXFLAGS.target ?= $(CXXFLAGS)\n+LINK.target ?= $(LINK)\n+LDFLAGS.target ?= $(LDFLAGS) \n+AR.target ?= $(AR)\n+ARFLAGS.target ?= crs\n+\n+# N.B.: the logic of which commands to run should match the computation done\n+# in gyp's make.py where ARFLAGS.host etc. is computed.\n+# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n+# to replicate this environment fallback in make as well.\n+CC.host ?= gcc\n+CFLAGS.host ?=\n+CXX.host ?= g++\n+CXXFLAGS.host ?=\n+LINK.host ?= g++\n+LDFLAGS.host ?=\n+AR.host ?= ar\n+ARFLAGS.host := crs\n+\n+# Define a dir function that can handle spaces.\n+# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n+# \"leading spaces cannot appear in the text of the first argument as written.\n+# These characters can be put into the argument value by variable substitution.\"\n+empty :=\n+space := $(empty) $(empty)\n+\n+# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n+replace_spaces = $(subst $(space),?,$1)\n+unreplace_spaces = $(subst ?,$(space),$1)\n+dirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n+\n+# Flags to make gcc output dependency info.  Note that you need to be\n+# careful here to use the flags that ccache and distcc can understand.\n+# We write to a dep file on the side first and then rename at the end\n+# so we can't end up with a broken dep file.\n+depfile = $(depsdir)/$(call replace_spaces,$@).d\n+DEPFLAGS = -MMD -MF $(depfile).raw\n+\n+# We have to fixup the deps output in a few ways.\n+# (1) the file output should mention the proper .o file.\n+# ccache or distcc lose the path to the target, so we convert a rule of\n+# the form:\n+#   foobar.o: DEP1 DEP2\n+# into\n+#   path/to/foobar.o: DEP1 DEP2\n+# (2) we want missing files not to cause us to fail to build.\n+# We want to rewrite\n+#   foobar.o: DEP1 DEP2 \\\n+#               DEP3\n+# to\n+#   DEP1:\n+#   DEP2:\n+#   DEP3:\n+# so if the files are missing, they're just considered phony rules.\n+# We have to do some pretty insane escaping to get those backslashes\n+# and dollar signs past make, the shell, and sed at the same time.\n+# Doesn't work with spaces, but that's fine: .d files have spaces in\n+# their names replaced with other characters.\n+define fixup_dep\n+# The depfile may not exist if the input file didn't have any #includes.\n+touch $(depfile).raw\n+# Fixup path as in (1).\n+sed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n+# Add extra rules as in (2).\n+# We remove slashes and replace spaces with new lines;\n+# remove blank lines;\n+# delete the first line and append a colon to the remaining lines.\n+sed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n+  grep -v '^$$'                             |\\\n+  sed -e 1d -e 's|$$|:|'                     \\\n+    >> $(depfile)\n+rm $(depfile).raw\n+endef\n+\n+# Command definitions:\n+# - cmd_foo is the actual command to run;\n+# - quiet_cmd_foo is the brief-output summary of the command.\n+\n+quiet_cmd_cc = CC($(TOOLSET)) $@\n+cmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_cxx = CXX($(TOOLSET)) $@\n+cmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_objc = CXX($(TOOLSET)) $@\n+cmd_objc = $(CC.$(TOOLSET)) $(GYP_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\n+\n+quiet_cmd_objcxx = CXX($(TOOLSET)) $@\n+cmd_objcxx = $(CXX.$(TOOLSET)) $(GYP_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n+\n+# Commands for precompiled header files.\n+quiet_cmd_pch_c = CXX($(TOOLSET)) $@\n+cmd_pch_c = $(CC.$(TOOLSET)) $(GYP_PCH_CFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+quiet_cmd_pch_cc = CXX($(TOOLSET)) $@\n+cmd_pch_cc = $(CC.$(TOOLSET)) $(GYP_PCH_CCFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+quiet_cmd_pch_m = CXX($(TOOLSET)) $@\n+cmd_pch_m = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCFLAGS) $(DEPFLAGS) -c -o $@ $<\n+quiet_cmd_pch_mm = CXX($(TOOLSET)) $@\n+cmd_pch_mm = $(CC.$(TOOLSET)) $(GYP_PCH_OBJCXXFLAGS) $(DEPFLAGS) -c -o $@ $<\n+\n+# gyp-mac-tool is written next to the root Makefile by gyp.\n+# Use $(4) for the command, since $(2) and $(3) are used as flag by do_cmd\n+# already.\n+quiet_cmd_mac_tool = MACTOOL $(4) $<\n+cmd_mac_tool = ./gyp-mac-tool $(4) $< \"$@\"\n+\n+quiet_cmd_mac_package_framework = PACKAGE FRAMEWORK $@\n+cmd_mac_package_framework = ./gyp-mac-tool package-framework \"$@\" $(4)\n+\n+quiet_cmd_touch = TOUCH $@\n+cmd_touch = touch $@\n+\n+quiet_cmd_copy = COPY $@\n+# send stderr to /dev/null to ignore messages when linking directories.\n+cmd_copy = ln -f \"$<\" \"$@\" 2>/dev/null || (rm -rf \"$@\" && cp -af \"$<\" \"$@\")\n+\n+quiet_cmd_alink = LIBTOOL-STATIC $@\n+cmd_alink = rm -f $@ && libtool -static -o $@ $(filter %.o,$^)\n+\n+quiet_cmd_link = LINK($(TOOLSET)) $@\n+cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n+\n+# TODO(thakis): Find out and document the difference between shared_library and\n+# loadable_module on mac.\n+quiet_cmd_solink = SOLINK($(TOOLSET)) $@\n+cmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o \"$@\" $(LD_INPUTS) $(LIBS)\n+\n+# TODO(thakis): The solink_module rule is likely wrong. Xcode seems to pass\n+# -bundle -single_module here (for osmesa.so).\n+quiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\n+cmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ $(filter-out FORCE_DO_CMD, $^) $(LIBS)\n+\n+\n+# Define an escape_quotes function to escape single quotes.\n+# This allows us to handle quotes properly as long as we always use\n+# use single quotes and escape_quotes.\n+escape_quotes = $(subst ','\\'',$(1))\n+# This comment is here just to include a ' to unconfuse syntax highlighting.\n+# Define an escape_vars function to escape '$' variable syntax.\n+# This allows us to read/write command lines with shell variables (e.g.\n+# $LD_LIBRARY_PATH), without triggering make substitution.\n+escape_vars = $(subst $$,$$$$,$(1))\n+# Helper that expands to a shell command to echo a string exactly as it is in\n+# make. This uses printf instead of echo because printf's behaviour with respect\n+# to escape sequences is more portable than echo's across different shells\n+# (e.g., dash, bash).\n+exact_echo = printf '%s\\n' '$(call escape_quotes,$(1))'\n+\n+# Helper to compare the command we're about to run against the command\n+# we logged the last time we ran the command.  Produces an empty\n+# string (false) when the commands match.\n+# Tricky point: Make has no string-equality test function.\n+# The kernel uses the following, but it seems like it would have false\n+# positives, where one string reordered its arguments.\n+#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\n+#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n+# We instead substitute each for the empty string into the other, and\n+# say they're equal if both substitutions produce the empty string.\n+# .d files contain ? instead of spaces, take that into account.\n+command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n+                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n+\n+# Helper that is non-empty when a prerequisite changes.\n+# Normally make does this implicitly, but we force rules to always run\n+# so we can check their command lines.\n+#   $? -- new prerequisites\n+#   $| -- order-only dependencies\n+prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n+\n+# do_cmd: run a command via the above cmd_foo names, if necessary.\n+# Should always run for a given target to handle command-line changes.\n+# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n+# Third argument, if non-zero, makes it do POSTBUILDS processing.\n+# Note: We intentionally do NOT call dirx for depfile, since it contains ? for\n+# spaces already and dirx strips the ? characters.\n+define do_cmd\n+$(if $(or $(command_changed),$(prereq_changed)),\n+  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n+  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n+  $(if $(findstring flock,$(word 2,$(cmd_$1))),\n+    @$(cmd_$(1))\n+    @echo \"  $(quiet_cmd_$(1)): Finished\",\n+    @$(cmd_$(1))\n+  )\n+  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n+  @$(if $(2),$(fixup_dep))\n+  $(if $(and $(3), $(POSTBUILDS)),\n+    @for p in $(POSTBUILDS); do eval $$p; done\n+  )\n+)\n+endef\n+\n+# Declare \"all\" target first so it is the default, even though we don't have the\n+# deps yet.\n+.PHONY: all\n+all:\n+\n+# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n+# do_cmd.\n+.PHONY: FORCE_DO_CMD\n+FORCE_DO_CMD:\n+\n+TOOLSET := target\n+# Suffix rules, putting all outputs into $(obj).\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.m FORCE_DO_CMD\n+\t@$(call do_cmd,objc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.mm FORCE_DO_CMD\n+\t@$(call do_cmd,objcxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.m FORCE_DO_CMD\n+\t@$(call do_cmd,objc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.mm FORCE_DO_CMD\n+\t@$(call do_cmd,objcxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.m FORCE_DO_CMD\n+\t@$(call do_cmd,objc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.mm FORCE_DO_CMD\n+\t@$(call do_cmd,objcxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-benchmarks.target.mk)))),)\n+  include src/rt/libuv/run-benchmarks.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-tests.target.mk)))),)\n+  include src/rt/libuv/run-tests.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/uv.target.mk)))),)\n+  include src/rt/libuv/uv.target.mk\n+endif\n+\n+quiet_cmd_regen_makefile = ACTION Regenerating $@\n+cmd_regen_makefile = ./src/rt/libuv/build/gyp/gyp -fmake --ignore-environment \"--toplevel-dir=.\" \"--depth=.\" \"--generator-output=mk/libuv/mac\" \"-Dlibrary=static_library\" \"-Dtarget_arch=ia32\" \"-DOS=mac\" src/rt/libuv/uv.gyp\n+#Makefile: $(srcdir)/src/rt/libuv/uv.gyp\n+#\t$(call do_cmd,regen_makefile)\n+\n+# \"all\" is a concatenation of the \"all\" targets from all the included\n+# sub-makefiles. This is just here to clarify.\n+all:\n+\n+# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n+# target in our tree. Only consider the ones with .d (dependency) info:\n+d_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\n+ifneq ($(d_files),)\n+  # Rather than include each individual .d file, concatenate them into a\n+  # single file which make is able to load faster.  We split this into\n+  # commands that take 1000 files at a time to avoid overflowing the\n+  # command line.\n+  $(shell cat $(wordlist 1,1000,$(d_files)) > $(depsdir)/all.deps)\n+\n+  ifneq ($(word 1001,$(d_files)),)\n+    $(error Found unprocessed dependency files (gyp didn't generate enough rules!))\n+  endif\n+\n+  # make looks for ways to re-generate included makefiles, but in our case, we\n+  # don't have a direct way. Explicitly telling make that it has nothing to do\n+  # for them makes it go faster.\n+  $(depsdir)/all.deps: ;\n+\n+  include $(depsdir)/all.deps\n+endif"}, {"sha": "7eb894b23ef66b97de39288e0fa4d5794b5e2a97", "filename": "mk/libuv/mac/gyp-mac-tool", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fgyp-mac-tool", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fgyp-mac-tool", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fgyp-mac-tool?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,188 @@\n+#!/usr/bin/python\n+# Generated by gyp. Do not edit.\n+# Copyright (c) 2011 Google Inc. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file.\n+\n+\"\"\"Utility functions to perform Xcode-style build steps.\n+\n+These functions are executed via gyp-mac-tool when using the Makefile generator.\n+\"\"\"\n+\n+import os\n+import fcntl\n+import plistlib\n+import shutil\n+import string\n+import subprocess\n+import sys\n+\n+def main(args):\n+  executor = MacTool()\n+  executor.Dispatch(args)\n+\n+class MacTool(object):\n+  \"\"\"This class performs all the Mac tooling steps. The methods can either be\n+  executed directly, or dispatched from an argument list.\"\"\"\n+\n+  def Dispatch(self, args):\n+    \"\"\"Dispatches a string command to a method.\"\"\"\n+    if len(args) < 1:\n+      raise Exception(\"Not enough arguments\")\n+\n+    method = \"Exec%s\" % self._CommandifyName(args[0])\n+    getattr(self, method)(*args[1:])\n+\n+  def _CommandifyName(self, name_string):\n+    \"\"\"Transforms a tool name like copy-info-plist to CopyInfoPlist\"\"\"\n+    return name_string.title().replace('-', '')\n+\n+  def ExecFlock(self, lockfile, *cmd_list):\n+    \"\"\"Emulates the most basic behavior of Linux's flock(1).\"\"\"\n+    # Rely on exception handling to report errors.\n+    fd = os.open(lockfile, os.O_RDONLY|os.O_NOCTTY|os.O_CREAT, 0o666)\n+    fcntl.flock(fd, fcntl.LOCK_EX)\n+    return subprocess.call(cmd_list)\n+\n+  def ExecCopyInfoPlist(self, source, dest):\n+    \"\"\"Copies the |source| Info.plist to the destination directory |dest|.\"\"\"\n+    # Read the source Info.plist into memory.\n+    fd = open(source, 'r')\n+    lines = fd.read()\n+    fd.close()\n+\n+    # Go through all the environment variables and replace them as variables in\n+    # the file.\n+    for key in os.environ:\n+      if key.startswith('_'):\n+        continue\n+      evar = '${%s}' % key\n+      lines = string.replace(lines, evar, os.environ[key])\n+\n+    # Write out the file with variables replaced.\n+    fd = open(dest, 'w')\n+    fd.write(lines)\n+    fd.close()\n+\n+    # Now write out PkgInfo file now that the Info.plist file has been\n+    # \"compiled\".\n+    self._WritePkgInfo(dest)\n+\n+  def _WritePkgInfo(self, info_plist):\n+    \"\"\"This writes the PkgInfo file from the data stored in Info.plist.\"\"\"\n+    plist = plistlib.readPlist(info_plist)\n+    if not plist:\n+      return\n+\n+    # The format of PkgInfo is eight characters, representing the bundle type\n+    # and bundle signature, each four characters. If either is missing, four\n+    # '?' characters are used instead.\n+    package_type = plist['CFBundlePackageType']\n+    if len(package_type) != 4:\n+      package_type = '?' * 4\n+    signature_code = plist['CFBundleSignature']\n+    if len(signature_code) != 4:\n+      signature_code = '?' * 4\n+\n+    dest = os.path.join(os.path.dirname(info_plist), 'PkgInfo')\n+    fp = open(dest, 'w')\n+    fp.write('%s%s' % (package_type, signature_code))\n+    fp.close()\n+\n+  def ExecPackageFramework(self, framework, version):\n+    \"\"\"Takes a path to Something.framework and the Current version of that and\n+    sets up all the symlinks.\"\"\"\n+    # Find the name of the binary based on the part before the \".framework\".\n+    binary = os.path.basename(framework).split('.')[0]\n+\n+    CURRENT = 'Current'\n+    RESOURCES = 'Resources'\n+    VERSIONS = 'Versions'\n+\n+    if not os.path.exists(os.path.join(framework, VERSIONS, version, binary)):\n+      # Binary-less frameworks don't seem to contain symlinks (see e.g.\n+      # chromium's out/Debug/org.chromium.Chromium.manifest/ bundle).\n+      return\n+\n+    # Move into the framework directory to set the symlinks correctly.\n+    pwd = os.getcwd()\n+    os.chdir(framework)\n+\n+    # Set up the Current version.\n+    self._Relink(version, os.path.join(VERSIONS, CURRENT))\n+\n+    # Set up the root symlinks.\n+    self._Relink(os.path.join(VERSIONS, CURRENT, binary), binary)\n+    self._Relink(os.path.join(VERSIONS, CURRENT, RESOURCES), RESOURCES)\n+\n+    # Back to where we were before!\n+    os.chdir(pwd)\n+\n+  def _Relink(self, dest, link):\n+    \"\"\"Creates a symlink to |dest| named |link|. If |link| already exists,\n+    it is overwritten.\"\"\"\n+    if os.path.lexists(link):\n+      os.remove(link)\n+    os.symlink(dest, link)\n+\n+  def ExecCopyBundleResource(self, source, dest):\n+    \"\"\"Copies a resource file to the bundle/Resources directory, performing any\n+    necessary compilation on each resource.\"\"\"\n+    extension = os.path.splitext(source)[1].lower()\n+    if os.path.isdir(source):\n+      # Copy tree.\n+      if os.path.exists(dest):\n+        shutil.rmtree(dest)\n+      shutil.copytree(source, dest)\n+    elif extension == '.xib':\n+      self._CopyXIBFile(source, dest)\n+    elif extension == '.strings':\n+      self._CopyStringsFile(source, dest)\n+    # TODO: Given that files with arbitrary extensions can be copied to the\n+    # bundle, we will want to get rid of this whitelist eventually.\n+    elif extension in [\n+        '.icns', '.manifest', '.pak', '.pdf', '.png', '.sb', '.sh',\n+        '.ttf', '.sdef']:\n+      shutil.copyfile(source, dest)\n+    else:\n+      raise NotImplementedError(\n+          \"Don't know how to copy bundle resources of type %s while copying \"\n+          \"%s to %s)\" % (extension, source, dest))\n+\n+  def _CopyXIBFile(self, source, dest):\n+    \"\"\"Compiles a XIB file with ibtool into a binary plist in the bundle.\"\"\"\n+    args = ['/Developer/usr/bin/ibtool', '--errors', '--warnings',\n+        '--notices', '--output-format', 'human-readable-text', '--compile',\n+        dest, source]\n+    subprocess.call(args)\n+\n+  def _CopyStringsFile(self, source, dest):\n+    \"\"\"Copies a .strings file using iconv to reconvert the input into UTF-16.\"\"\"\n+    input_code = self._DetectInputEncoding(source) or \"UTF-8\"\n+    fp = open(dest, 'w')\n+    args = ['/usr/bin/iconv', '--from-code', input_code, '--to-code',\n+        'UTF-16', source]\n+    subprocess.call(args, stdout=fp)\n+    fp.close()\n+\n+  def _DetectInputEncoding(self, file_name):\n+    \"\"\"Reads the first few bytes from file_name and tries to guess the text\n+    encoding. Returns None as a guess if it can't detect it.\"\"\"\n+    fp = open(file_name, 'rb')\n+    try:\n+      header = fp.read(3)\n+    except e:\n+      fp.close()\n+      return None\n+    fp.close()\n+    if header.startswith(\"\\xFE\\xFF\"):\n+      return \"UTF-16BE\"\n+    elif header.startswith(\"\\xFF\\xFE\"):\n+      return \"UTF-16LE\"\n+    elif header.startswith(\"\\xEF\\xBB\\xBF\"):\n+      return \"UTF-8\"\n+    else:\n+      return None\n+\n+if __name__ == '__main__':\n+  sys.exit(main(sys.argv[1:]))"}, {"sha": "df9853a504085a61faec2fc28b1ecb78aa3f0dc4", "filename": "mk/libuv/mac/src/rt/libuv/run-benchmarks.target.mk", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,91 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-benchmarks\n+DEFS_Default := '-D_GNU_SOURCE'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -fasm-blocks \\\n+\t-mpascal-strings \\\n+\t-gdwarf-2 \\\n+\t-arch i386\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+# Flags passed to only ObjC files.\n+CFLAGS_OBJC_Default := \n+\n+# Flags passed to only ObjC++ files.\n+CFLAGS_OBJCC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ping-pongs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pound.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(builddir)/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := -arch i386 \\\n+\t-L$(builddir)\n+\n+LIBS := -framework Carbon \\\n+\t-framework CoreServices\n+\n+$(builddir)/run-benchmarks: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-benchmarks: LIBS := $(LIBS)\n+$(builddir)/run-benchmarks: LD_INPUTS := $(OBJS) $(builddir)/libuv.a\n+$(builddir)/run-benchmarks: TOOLSET := $(TOOLSET)\n+$(builddir)/run-benchmarks: $(OBJS) $(builddir)/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-benchmarks\n+# Add target alias\n+.PHONY: run-benchmarks\n+run-benchmarks: $(builddir)/run-benchmarks\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-benchmarks\n+"}, {"sha": "bb40dc55de6841b41e948f9c195267a02576add8", "filename": "mk/libuv/mac/src/rt/libuv/run-tests.target.mk", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,114 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-tests\n+DEFS_Default := '-D_GNU_SOURCE'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -fasm-blocks \\\n+\t-mpascal-strings \\\n+\t-gdwarf-2 \\\n+\t-arch i386\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+# Flags passed to only ObjC files.\n+CFLAGS_OBJC_Default := \n+\n+# Flags passed to only ObjC++ files.\n+CFLAGS_OBJCC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(builddir)/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := -arch i386 \\\n+\t-L$(builddir)\n+\n+LIBS := -framework Carbon \\\n+\t-framework CoreServices\n+\n+$(builddir)/run-tests: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-tests: LIBS := $(LIBS)\n+$(builddir)/run-tests: LD_INPUTS := $(OBJS) $(builddir)/libuv.a\n+$(builddir)/run-tests: TOOLSET := $(TOOLSET)\n+$(builddir)/run-tests: $(OBJS) $(builddir)/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-tests\n+# Add target alias\n+.PHONY: run-tests\n+run-tests: $(builddir)/run-tests\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-tests\n+"}, {"sha": "fd944e922e5f8b14b6879e24862557dfa1856042", "filename": "mk/libuv/mac/src/rt/libuv/uv.Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,6 @@\n+# This file is generated by gyp; do not edit.\n+\n+export builddir_name ?= mk/libuv/mac/./src/rt/libuv/out\n+.PHONY: all\n+all:\n+\t$(MAKE) -C ../../.. uv run-tests run-benchmarks"}, {"sha": "dce473cf2f7820dc60b6c4ae3e3745fd7b65f8dd", "filename": "mk/libuv/mac/src/rt/libuv/uv.target.mk", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,141 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := uv\n+DEFS_Default := '-DHAVE_CONFIG_H' \\\n+\t'-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144' \\\n+\t'-DEV_CONFIG_H=\"config_darwin.h\"' \\\n+\t'-DEIO_CONFIG_H=\"config_darwin.h\"'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -fasm-blocks \\\n+\t-mpascal-strings \\\n+\t-gdwarf-2 \\\n+\t-arch i386\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+# Flags passed to only ObjC files.\n+CFLAGS_OBJC_Default := \n+\n+# Flags passed to only ObjC++ files.\n+CFLAGS_OBJCC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n+\t-I$(srcdir)/src/rt/libuv/include/uv-private \\\n+\t-I$(srcdir)/src/rt/libuv/src \\\n+\t-I$(srcdir)/src/rt/libuv/src/unix/ev \\\n+\t-I$(srcdir)/src/rt/libuv/src/ares/config_darwin\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_fds.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_library_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_llist.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/core.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/uv-eio.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/udp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tcp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/pipe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/ev/ev.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/darwin.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE)) $(CFLAGS_OBJC_$(BUILDTYPE))\n+$(OBJS): GYP_OBJCXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE)) $(CFLAGS_OBJCC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := -arch i386 \\\n+\t-L$(builddir)\n+\n+LIBS := -lm\n+\n+$(builddir)/libuv.a: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/libuv.a: LIBS := $(LIBS)\n+$(builddir)/libuv.a: TOOLSET := $(TOOLSET)\n+$(builddir)/libuv.a: $(OBJS) FORCE_DO_CMD\n+\t$(call do_cmd,alink)\n+\n+all_deps += $(builddir)/libuv.a\n+# Add target alias\n+.PHONY: uv\n+uv: $(builddir)/libuv.a\n+\n+# Add target alias to \"all\" target.\n+.PHONY: all\n+all: uv\n+"}, {"sha": "89d244fc025f9e810e2c5ea4d5781a5eb3f3ad0c", "filename": "mk/libuv/unix/Makefile", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2FMakefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,337 @@\n+# We borrow heavily from the kernel build setup, though we are simpler since\n+# we don't have Kconfig tweaking settings on us.\n+\n+# The implicit make rules have it looking for RCS files, among other things.\n+# We instead explicitly write all the rules we care about.\n+# It's even quicker (saves ~200ms) to pass -r on the command line.\n+MAKEFLAGS=-r\n+\n+# The source directory tree.\n+srcdir := ../../..\n+\n+# The name of the builddir.\n+builddir_name ?= out\n+\n+# The V=1 flag on command line makes us verbosely print command lines.\n+ifdef V\n+  quiet=\n+else\n+  quiet=quiet_\n+endif\n+\n+# Specify BUILDTYPE=Release on the command line for a release build.\n+BUILDTYPE ?= Default\n+\n+# Directory all our build output goes into.\n+# Note that this must be two directories beneath src/ for unit tests to pass,\n+# as they reach into the src/ directory for data with relative paths.\n+builddir ?= $(builddir_name)/$(BUILDTYPE)\n+abs_builddir := $(abspath $(builddir))\n+depsdir := $(builddir)/.deps\n+\n+# Object output directory.\n+obj := $(builddir)/obj\n+abs_obj := $(abspath $(obj))\n+\n+# We build up a list of every single one of the targets so we can slurp in the\n+# generated dependency rule Makefiles in one pass.\n+all_deps :=\n+\n+# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+#\n+# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# process so running parallel links can often lead to thrashing.  To disable\n+# the serialization, override FLOCK via an envrionment variable as follows:\n+#\n+#   export FLOCK=\n+#\n+# This will allow make to invoke N linker processes as specified in -jN.\n+FLOCK ?= flock $(builddir)/linker.lock\n+\n+\n+\n+LINK ?= $(FLOCK) $(CXX)\n+CC.target ?= $(CC)\n+CFLAGS.target ?= $(CFLAGS)\n+CXX.target ?= $(CXX)\n+CXXFLAGS.target ?= $(CXXFLAGS)\n+LINK.target ?= $(LINK)\n+LDFLAGS.target ?= $(LDFLAGS) \n+AR.target ?= $(AR)\n+ARFLAGS.target ?= crsT\n+\n+# N.B.: the logic of which commands to run should match the computation done\n+# in gyp's make.py where ARFLAGS.host etc. is computed.\n+# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n+# to replicate this environment fallback in make as well.\n+CC.host ?= gcc\n+CFLAGS.host ?=\n+CXX.host ?= g++\n+CXXFLAGS.host ?=\n+LINK.host ?= g++\n+LDFLAGS.host ?=\n+AR.host ?= ar\n+ARFLAGS.host := crsT\n+\n+# Define a dir function that can handle spaces.\n+# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n+# \"leading spaces cannot appear in the text of the first argument as written.\n+# These characters can be put into the argument value by variable substitution.\"\n+empty :=\n+space := $(empty) $(empty)\n+\n+# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n+replace_spaces = $(subst $(space),?,$1)\n+unreplace_spaces = $(subst ?,$(space),$1)\n+dirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n+\n+# Flags to make gcc output dependency info.  Note that you need to be\n+# careful here to use the flags that ccache and distcc can understand.\n+# We write to a dep file on the side first and then rename at the end\n+# so we can't end up with a broken dep file.\n+depfile = $(depsdir)/$(call replace_spaces,$@).d\n+DEPFLAGS = -MMD -MF $(depfile).raw\n+\n+# We have to fixup the deps output in a few ways.\n+# (1) the file output should mention the proper .o file.\n+# ccache or distcc lose the path to the target, so we convert a rule of\n+# the form:\n+#   foobar.o: DEP1 DEP2\n+# into\n+#   path/to/foobar.o: DEP1 DEP2\n+# (2) we want missing files not to cause us to fail to build.\n+# We want to rewrite\n+#   foobar.o: DEP1 DEP2 \\\n+#               DEP3\n+# to\n+#   DEP1:\n+#   DEP2:\n+#   DEP3:\n+# so if the files are missing, they're just considered phony rules.\n+# We have to do some pretty insane escaping to get those backslashes\n+# and dollar signs past make, the shell, and sed at the same time.\n+# Doesn't work with spaces, but that's fine: .d files have spaces in\n+# their names replaced with other characters.\n+define fixup_dep\n+# The depfile may not exist if the input file didn't have any #includes.\n+touch $(depfile).raw\n+# Fixup path as in (1).\n+sed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n+# Add extra rules as in (2).\n+# We remove slashes and replace spaces with new lines;\n+# remove blank lines;\n+# delete the first line and append a colon to the remaining lines.\n+sed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n+  grep -v '^$$'                             |\\\n+  sed -e 1d -e 's|$$|:|'                     \\\n+    >> $(depfile)\n+rm $(depfile).raw\n+endef\n+\n+# Command definitions:\n+# - cmd_foo is the actual command to run;\n+# - quiet_cmd_foo is the brief-output summary of the command.\n+\n+quiet_cmd_cc = CC($(TOOLSET)) $@\n+cmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_cxx = CXX($(TOOLSET)) $@\n+cmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_touch = TOUCH $@\n+cmd_touch = touch $@\n+\n+quiet_cmd_copy = COPY $@\n+# send stderr to /dev/null to ignore messages when linking directories.\n+cmd_copy = ln -f \"$<\" \"$@\" 2>/dev/null || (rm -rf \"$@\" && cp -af \"$<\" \"$@\")\n+\n+quiet_cmd_alink = AR($(TOOLSET)) $@\n+cmd_alink = rm -f $@ && $(AR.$(TOOLSET)) $(ARFLAGS.$(TOOLSET)) $@ $(filter %.o,$^)\n+\n+# Due to circular dependencies between libraries :(, we wrap the\n+# special \"figure out circular dependencies\" flags around the entire\n+# input list during linking.\n+quiet_cmd_link = LINK($(TOOLSET)) $@\n+cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\n+\n+# We support two kinds of shared objects (.so):\n+# 1) shared_library, which is just bundling together many dependent libraries\n+# into a link line.\n+# 2) loadable_module, which is generating a module intended for dlopen().\n+#\n+# They differ only slightly:\n+# In the former case, we want to package all dependent code into the .so.\n+# In the latter case, we want to package just the API exposed by the\n+# outermost module.\n+# This means shared_library uses --whole-archive, while loadable_module doesn't.\n+# (Note that --whole-archive is incompatible with the --start-group used in\n+# normal linking.)\n+\n+# Other shared-object link notes:\n+# - Set SONAME to the library filename so our binaries don't reference\n+# the local, absolute paths used on the link command-line.\n+quiet_cmd_solink = SOLINK($(TOOLSET)) $@\n+cmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n+\n+quiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\n+cmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n+\n+\n+# Define an escape_quotes function to escape single quotes.\n+# This allows us to handle quotes properly as long as we always use\n+# use single quotes and escape_quotes.\n+escape_quotes = $(subst ','\\'',$(1))\n+# This comment is here just to include a ' to unconfuse syntax highlighting.\n+# Define an escape_vars function to escape '$' variable syntax.\n+# This allows us to read/write command lines with shell variables (e.g.\n+# $LD_LIBRARY_PATH), without triggering make substitution.\n+escape_vars = $(subst $$,$$$$,$(1))\n+# Helper that expands to a shell command to echo a string exactly as it is in\n+# make. This uses printf instead of echo because printf's behaviour with respect\n+# to escape sequences is more portable than echo's across different shells\n+# (e.g., dash, bash).\n+exact_echo = printf '%s\\n' '$(call escape_quotes,$(1))'\n+\n+# Helper to compare the command we're about to run against the command\n+# we logged the last time we ran the command.  Produces an empty\n+# string (false) when the commands match.\n+# Tricky point: Make has no string-equality test function.\n+# The kernel uses the following, but it seems like it would have false\n+# positives, where one string reordered its arguments.\n+#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\n+#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n+# We instead substitute each for the empty string into the other, and\n+# say they're equal if both substitutions produce the empty string.\n+# .d files contain ? instead of spaces, take that into account.\n+command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n+                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n+\n+# Helper that is non-empty when a prerequisite changes.\n+# Normally make does this implicitly, but we force rules to always run\n+# so we can check their command lines.\n+#   $? -- new prerequisites\n+#   $| -- order-only dependencies\n+prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n+\n+# do_cmd: run a command via the above cmd_foo names, if necessary.\n+# Should always run for a given target to handle command-line changes.\n+# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n+# Third argument, if non-zero, makes it do POSTBUILDS processing.\n+# Note: We intentionally do NOT call dirx for depfile, since it contains ? for\n+# spaces already and dirx strips the ? characters.\n+define do_cmd\n+$(if $(or $(command_changed),$(prereq_changed)),\n+  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n+  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n+  $(if $(findstring flock,$(word 1,$(cmd_$1))),\n+    @$(cmd_$(1))\n+    @echo \"  $(quiet_cmd_$(1)): Finished\",\n+    @$(cmd_$(1))\n+  )\n+  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n+  @$(if $(2),$(fixup_dep))\n+  $(if $(and $(3), $(POSTBUILDS)),\n+    @for p in $(POSTBUILDS); do eval $$p; done\n+  )\n+)\n+endef\n+\n+# Declare \"all\" target first so it is the default, even though we don't have the\n+# deps yet.\n+.PHONY: all\n+all:\n+\n+# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n+# do_cmd.\n+.PHONY: FORCE_DO_CMD\n+FORCE_DO_CMD:\n+\n+TOOLSET := target\n+# Suffix rules, putting all outputs into $(obj).\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-benchmarks.target.mk)))),)\n+  include src/rt/libuv/run-benchmarks.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-tests.target.mk)))),)\n+  include src/rt/libuv/run-tests.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/uv.target.mk)))),)\n+  include src/rt/libuv/uv.target.mk\n+endif\n+\n+quiet_cmd_regen_makefile = ACTION Regenerating $@\n+cmd_regen_makefile = ./src/rt/libuv/build/gyp/gyp -fmake --ignore-environment \"--toplevel-dir=.\" \"--depth=.\" \"--generator-output=mk/libuv/unix\" \"-Dlibrary=static_library\" \"-Dtarget_arch=ia32\" \"-DOS=linux\" src/rt/libuv/uv.gyp\n+#Makefile: $(srcdir)/src/rt/libuv/uv.gyp\n+#\t$(call do_cmd,regen_makefile)\n+\n+# \"all\" is a concatenation of the \"all\" targets from all the included\n+# sub-makefiles. This is just here to clarify.\n+all:\n+\n+# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n+# target in our tree. Only consider the ones with .d (dependency) info:\n+d_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\n+ifneq ($(d_files),)\n+  # Rather than include each individual .d file, concatenate them into a\n+  # single file which make is able to load faster.  We split this into\n+  # commands that take 1000 files at a time to avoid overflowing the\n+  # command line.\n+  $(shell cat $(wordlist 1,1000,$(d_files)) > $(depsdir)/all.deps)\n+\n+  ifneq ($(word 1001,$(d_files)),)\n+    $(error Found unprocessed dependency files (gyp didn't generate enough rules!))\n+  endif\n+\n+  # make looks for ways to re-generate included makefiles, but in our case, we\n+  # don't have a direct way. Explicitly telling make that it has nothing to do\n+  # for them makes it go faster.\n+  $(depsdir)/all.deps: ;\n+\n+  include $(depsdir)/all.deps\n+endif"}, {"sha": "ad3900cea632d01358f08395df6671a9b15c8abc", "filename": "mk/libuv/unix/src/rt/libuv/run-benchmarks.target.mk", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,78 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-benchmarks\n+DEFS_Default := '-D_GNU_SOURCE'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := \n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ping-pongs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pound.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/rt/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := -pthread\n+\n+LIBS := -lrt\n+\n+$(builddir)/run-benchmarks: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-benchmarks: LIBS := $(LIBS)\n+$(builddir)/run-benchmarks: LD_INPUTS := $(OBJS) $(obj).target/src/rt/libuv/libuv.a\n+$(builddir)/run-benchmarks: TOOLSET := $(TOOLSET)\n+$(builddir)/run-benchmarks: $(OBJS) $(obj).target/src/rt/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-benchmarks\n+# Add target alias\n+.PHONY: run-benchmarks\n+run-benchmarks: $(builddir)/run-benchmarks\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-benchmarks\n+"}, {"sha": "605892fea05dc8ca7ba79ad2da8b04b03e795647", "filename": "mk/libuv/unix/src/rt/libuv/run-tests.target.mk", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,101 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-tests\n+DEFS_Default := '-D_GNU_SOURCE'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := \n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/rt/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := -pthread\n+\n+LIBS := -lrt\n+\n+$(builddir)/run-tests: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-tests: LIBS := $(LIBS)\n+$(builddir)/run-tests: LD_INPUTS := $(OBJS) $(obj).target/src/rt/libuv/libuv.a\n+$(builddir)/run-tests: TOOLSET := $(TOOLSET)\n+$(builddir)/run-tests: $(OBJS) $(obj).target/src/rt/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-tests\n+# Add target alias\n+.PHONY: run-tests\n+run-tests: $(builddir)/run-tests\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-tests\n+"}, {"sha": "579a591578274b511ca20af64efeb2b7019ad8d1", "filename": "mk/libuv/unix/src/rt/libuv/uv.Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,6 @@\n+# This file is generated by gyp; do not edit.\n+\n+export builddir_name ?= mk/libuv/unix/./src/rt/libuv/out\n+.PHONY: all\n+all:\n+\t$(MAKE) -C ../../.. uv run-tests run-benchmarks"}, {"sha": "dc5264341b7d07cf1aa2cc590af5c72ab86e5776", "filename": "mk/libuv/unix/src/rt/libuv/uv.target.mk", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,134 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := uv\n+DEFS_Default := '-DHAVE_CONFIG_H' \\\n+\t'-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144' \\\n+\t'-DEV_CONFIG_H=\"config_linux.h\"' \\\n+\t'-DEIO_CONFIG_H=\"config_linux.h\"'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -g \\\n+\t--std=gnu89 \\\n+\t-pedantic \\\n+\t-Wall \\\n+\t-Wextra \\\n+\t-Wno-unused-parameter\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n+\t-I$(srcdir)/src/rt/libuv/include/uv-private \\\n+\t-I$(srcdir)/src/rt/libuv/src \\\n+\t-I$(srcdir)/src/rt/libuv/src/unix/ev \\\n+\t-I$(srcdir)/src/rt/libuv/src/ares/config_linux\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_fds.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_library_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_llist.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/core.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/uv-eio.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/udp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tcp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/pipe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/ev/ev.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/linux.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := -lm\n+\n+$(obj).target/src/rt/libuv/libuv.a: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(obj).target/src/rt/libuv/libuv.a: LIBS := $(LIBS)\n+$(obj).target/src/rt/libuv/libuv.a: TOOLSET := $(TOOLSET)\n+$(obj).target/src/rt/libuv/libuv.a: $(OBJS) FORCE_DO_CMD\n+\t$(call do_cmd,alink)\n+\n+all_deps += $(obj).target/src/rt/libuv/libuv.a\n+# Add target alias\n+.PHONY: uv\n+uv: $(obj).target/src/rt/libuv/libuv.a\n+\n+# Add target alias to \"all\" target.\n+.PHONY: all\n+all: uv\n+"}, {"sha": "5808ed4c3fcb9754da148973b669160f1631ba32", "filename": "mk/libuv/win/Makefile", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2FMakefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,337 @@\n+# We borrow heavily from the kernel build setup, though we are simpler since\n+# we don't have Kconfig tweaking settings on us.\n+\n+# The implicit make rules have it looking for RCS files, among other things.\n+# We instead explicitly write all the rules we care about.\n+# It's even quicker (saves ~200ms) to pass -r on the command line.\n+MAKEFLAGS=-r\n+\n+# The source directory tree.\n+srcdir := ../../..\n+\n+# The name of the builddir.\n+builddir_name ?= out\n+\n+# The V=1 flag on command line makes us verbosely print command lines.\n+ifdef V\n+  quiet=\n+else\n+  quiet=quiet_\n+endif\n+\n+# Specify BUILDTYPE=Release on the command line for a release build.\n+BUILDTYPE ?= Default\n+\n+# Directory all our build output goes into.\n+# Note that this must be two directories beneath src/ for unit tests to pass,\n+# as they reach into the src/ directory for data with relative paths.\n+builddir ?= $(builddir_name)/$(BUILDTYPE)\n+abs_builddir := $(abspath $(builddir))\n+depsdir := $(builddir)/.deps\n+\n+# Object output directory.\n+obj := $(builddir)/obj\n+abs_obj := $(abspath $(obj))\n+\n+# We build up a list of every single one of the targets so we can slurp in the\n+# generated dependency rule Makefiles in one pass.\n+all_deps :=\n+\n+# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+#\n+# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# process so running parallel links can often lead to thrashing.  To disable\n+# the serialization, override FLOCK via an envrionment variable as follows:\n+#\n+#   export FLOCK=\n+#\n+# This will allow make to invoke N linker processes as specified in -jN.\n+FLOCK ?= flock $(builddir)/linker.lock\n+\n+\n+\n+LINK ?= $(FLOCK) $(CXX)\n+CC.target ?= $(CC)\n+CFLAGS.target ?= $(CFLAGS)\n+CXX.target ?= $(CXX)\n+CXXFLAGS.target ?= $(CXXFLAGS)\n+LINK.target ?= $(LINK)\n+LDFLAGS.target ?= $(LDFLAGS) \n+AR.target ?= $(AR)\n+ARFLAGS.target ?= crsT\n+\n+# N.B.: the logic of which commands to run should match the computation done\n+# in gyp's make.py where ARFLAGS.host etc. is computed.\n+# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n+# to replicate this environment fallback in make as well.\n+CC.host ?= gcc\n+CFLAGS.host ?=\n+CXX.host ?= g++\n+CXXFLAGS.host ?=\n+LINK.host ?= g++\n+LDFLAGS.host ?=\n+AR.host ?= ar\n+ARFLAGS.host := crsT\n+\n+# Define a dir function that can handle spaces.\n+# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n+# \"leading spaces cannot appear in the text of the first argument as written.\n+# These characters can be put into the argument value by variable substitution.\"\n+empty :=\n+space := $(empty) $(empty)\n+\n+# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n+replace_spaces = $(subst $(space),?,$1)\n+unreplace_spaces = $(subst ?,$(space),$1)\n+dirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n+\n+# Flags to make gcc output dependency info.  Note that you need to be\n+# careful here to use the flags that ccache and distcc can understand.\n+# We write to a dep file on the side first and then rename at the end\n+# so we can't end up with a broken dep file.\n+depfile = $(depsdir)/$(call replace_spaces,$@).d\n+DEPFLAGS = -MMD -MF $(depfile).raw\n+\n+# We have to fixup the deps output in a few ways.\n+# (1) the file output should mention the proper .o file.\n+# ccache or distcc lose the path to the target, so we convert a rule of\n+# the form:\n+#   foobar.o: DEP1 DEP2\n+# into\n+#   path/to/foobar.o: DEP1 DEP2\n+# (2) we want missing files not to cause us to fail to build.\n+# We want to rewrite\n+#   foobar.o: DEP1 DEP2 \\\n+#               DEP3\n+# to\n+#   DEP1:\n+#   DEP2:\n+#   DEP3:\n+# so if the files are missing, they're just considered phony rules.\n+# We have to do some pretty insane escaping to get those backslashes\n+# and dollar signs past make, the shell, and sed at the same time.\n+# Doesn't work with spaces, but that's fine: .d files have spaces in\n+# their names replaced with other characters.\n+define fixup_dep\n+# The depfile may not exist if the input file didn't have any #includes.\n+touch $(depfile).raw\n+# Fixup path as in (1).\n+sed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n+# Add extra rules as in (2).\n+# We remove slashes and replace spaces with new lines;\n+# remove blank lines;\n+# delete the first line and append a colon to the remaining lines.\n+sed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n+  grep -v '^$$'                             |\\\n+  sed -e 1d -e 's|$$|:|'                     \\\n+    >> $(depfile)\n+rm $(depfile).raw\n+endef\n+\n+# Command definitions:\n+# - cmd_foo is the actual command to run;\n+# - quiet_cmd_foo is the brief-output summary of the command.\n+\n+quiet_cmd_cc = CC($(TOOLSET)) $@\n+cmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_cxx = CXX($(TOOLSET)) $@\n+cmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_touch = TOUCH $@\n+cmd_touch = touch $@\n+\n+quiet_cmd_copy = COPY $@\n+# send stderr to /dev/null to ignore messages when linking directories.\n+cmd_copy = ln -f \"$<\" \"$@\" 2>/dev/null || (rm -rf \"$@\" && cp -af \"$<\" \"$@\")\n+\n+quiet_cmd_alink = AR($(TOOLSET)) $@\n+cmd_alink = rm -f $@ && $(AR.$(TOOLSET)) $(ARFLAGS.$(TOOLSET)) $@ $(filter %.o,$^)\n+\n+# Due to circular dependencies between libraries :(, we wrap the\n+# special \"figure out circular dependencies\" flags around the entire\n+# input list during linking.\n+quiet_cmd_link = LINK($(TOOLSET)) $@\n+cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\n+\n+# We support two kinds of shared objects (.so):\n+# 1) shared_library, which is just bundling together many dependent libraries\n+# into a link line.\n+# 2) loadable_module, which is generating a module intended for dlopen().\n+#\n+# They differ only slightly:\n+# In the former case, we want to package all dependent code into the .so.\n+# In the latter case, we want to package just the API exposed by the\n+# outermost module.\n+# This means shared_library uses --whole-archive, while loadable_module doesn't.\n+# (Note that --whole-archive is incompatible with the --start-group used in\n+# normal linking.)\n+\n+# Other shared-object link notes:\n+# - Set SONAME to the library filename so our binaries don't reference\n+# the local, absolute paths used on the link command-line.\n+quiet_cmd_solink = SOLINK($(TOOLSET)) $@\n+cmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n+\n+quiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\n+cmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n+\n+\n+# Define an escape_quotes function to escape single quotes.\n+# This allows us to handle quotes properly as long as we always use\n+# use single quotes and escape_quotes.\n+escape_quotes = $(subst ','\\'',$(1))\n+# This comment is here just to include a ' to unconfuse syntax highlighting.\n+# Define an escape_vars function to escape '$' variable syntax.\n+# This allows us to read/write command lines with shell variables (e.g.\n+# $LD_LIBRARY_PATH), without triggering make substitution.\n+escape_vars = $(subst $$,$$$$,$(1))\n+# Helper that expands to a shell command to echo a string exactly as it is in\n+# make. This uses printf instead of echo because printf's behaviour with respect\n+# to escape sequences is more portable than echo's across different shells\n+# (e.g., dash, bash).\n+exact_echo = printf '%s\\n' '$(call escape_quotes,$(1))'\n+\n+# Helper to compare the command we're about to run against the command\n+# we logged the last time we ran the command.  Produces an empty\n+# string (false) when the commands match.\n+# Tricky point: Make has no string-equality test function.\n+# The kernel uses the following, but it seems like it would have false\n+# positives, where one string reordered its arguments.\n+#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\n+#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n+# We instead substitute each for the empty string into the other, and\n+# say they're equal if both substitutions produce the empty string.\n+# .d files contain ? instead of spaces, take that into account.\n+command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n+                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n+\n+# Helper that is non-empty when a prerequisite changes.\n+# Normally make does this implicitly, but we force rules to always run\n+# so we can check their command lines.\n+#   $? -- new prerequisites\n+#   $| -- order-only dependencies\n+prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n+\n+# do_cmd: run a command via the above cmd_foo names, if necessary.\n+# Should always run for a given target to handle command-line changes.\n+# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n+# Third argument, if non-zero, makes it do POSTBUILDS processing.\n+# Note: We intentionally do NOT call dirx for depfile, since it contains ? for\n+# spaces already and dirx strips the ? characters.\n+define do_cmd\n+$(if $(or $(command_changed),$(prereq_changed)),\n+  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n+  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n+  $(if $(findstring flock,$(word 1,$(cmd_$1))),\n+    @$(cmd_$(1))\n+    @echo \"  $(quiet_cmd_$(1)): Finished\",\n+    @$(cmd_$(1))\n+  )\n+  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n+  @$(if $(2),$(fixup_dep))\n+  $(if $(and $(3), $(POSTBUILDS)),\n+    @for p in $(POSTBUILDS); do eval $$p; done\n+  )\n+)\n+endef\n+\n+# Declare \"all\" target first so it is the default, even though we don't have the\n+# deps yet.\n+.PHONY: all\n+all:\n+\n+# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n+# do_cmd.\n+.PHONY: FORCE_DO_CMD\n+FORCE_DO_CMD:\n+\n+TOOLSET := target\n+# Suffix rules, putting all outputs into $(obj).\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-benchmarks.target.mk)))),)\n+  include src/rt/libuv/run-benchmarks.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/run-tests.target.mk)))),)\n+  include src/rt/libuv/run-tests.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/rt/libuv/uv.target.mk)))),)\n+  include src/rt/libuv/uv.target.mk\n+endif\n+\n+quiet_cmd_regen_makefile = ACTION Regenerating $@\n+cmd_regen_makefile = ./src/rt/libuv/build/gyp/gyp -fmake --ignore-environment \"--toplevel-dir=.\" \"--depth=.\" \"--generator-output=mk/libuv/win\" \"-Dlibrary=static_library\" \"-Dtarget_arch=ia32\" \"-DOS=win\" src/rt/libuv/uv.gyp\n+#Makefile: $(srcdir)/src/rt/libuv/uv.gyp\n+#\t$(call do_cmd,regen_makefile)\n+\n+# \"all\" is a concatenation of the \"all\" targets from all the included\n+# sub-makefiles. This is just here to clarify.\n+all:\n+\n+# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n+# target in our tree. Only consider the ones with .d (dependency) info:\n+d_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\n+ifneq ($(d_files),)\n+  # Rather than include each individual .d file, concatenate them into a\n+  # single file which make is able to load faster.  We split this into\n+  # commands that take 1000 files at a time to avoid overflowing the\n+  # command line.\n+  $(shell cat $(wordlist 1,1000,$(d_files)) > $(depsdir)/all.deps)\n+\n+  ifneq ($(word 1001,$(d_files)),)\n+    $(error Found unprocessed dependency files (gyp didn't generate enough rules!))\n+  endif\n+\n+  # make looks for ways to re-generate included makefiles, but in our case, we\n+  # don't have a direct way. Explicitly telling make that it has nothing to do\n+  # for them makes it go faster.\n+  $(depsdir)/all.deps: ;\n+\n+  include $(depsdir)/all.deps\n+endif"}, {"sha": "0a3cbf31b5b5884bf1af34014cf927e91277b44b", "filename": "mk/libuv/win/src/rt/libuv/run-benchmarks.target.mk", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,79 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-benchmarks\n+DEFS_Default := \n+\n+# Flags passed to all source files.\n+CFLAGS_Default := \n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ping-pongs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pound.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-win.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/rt/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := ws2_32.lib \\\n+\t-lws2_32.lib\n+\n+$(builddir)/run-benchmarks: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-benchmarks: LIBS := $(LIBS)\n+$(builddir)/run-benchmarks: LD_INPUTS := $(OBJS) $(obj).target/src/rt/libuv/libuv.a\n+$(builddir)/run-benchmarks: TOOLSET := $(TOOLSET)\n+$(builddir)/run-benchmarks: $(OBJS) $(obj).target/src/rt/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-benchmarks\n+# Add target alias\n+.PHONY: run-benchmarks\n+run-benchmarks: $(builddir)/run-benchmarks\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-benchmarks\n+"}, {"sha": "438b41ea520f53f03cdd9bac0d229229a9187ae2", "filename": "mk/libuv/win/src/rt/libuv/run-tests.target.mk", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,102 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-tests\n+DEFS_Default := \n+\n+# Flags passed to all source files.\n+CFLAGS_Default := \n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-win.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/rt/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := ws2_32.lib \\\n+\t-lws2_32.lib\n+\n+$(builddir)/run-tests: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-tests: LIBS := $(LIBS)\n+$(builddir)/run-tests: LD_INPUTS := $(OBJS) $(obj).target/src/rt/libuv/libuv.a\n+$(builddir)/run-tests: TOOLSET := $(TOOLSET)\n+$(builddir)/run-tests: $(OBJS) $(obj).target/src/rt/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-tests\n+# Add target alias\n+.PHONY: run-tests\n+run-tests: $(builddir)/run-tests\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-tests\n+"}, {"sha": "f7bfa935ff39f59f50b7346bd3fb2967a811813a", "filename": "mk/libuv/win/src/rt/libuv/uv.Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.Makefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,6 @@\n+# This file is generated by gyp; do not edit.\n+\n+export builddir_name ?= mk/libuv/win/./src/rt/libuv/out\n+.PHONY: all\n+all:\n+\t$(MAKE) -C ../../.. uv run-tests run-benchmarks"}, {"sha": "e8f7a135ac513f184fed4a58cbbfea0d2cb5364c", "filename": "mk/libuv/win/src/rt/libuv/uv.target.mk", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,135 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := uv\n+DEFS_Default := '-DHAVE_CONFIG_H' \\\n+\t'-D_WIN32_WINNT=0x0502' \\\n+\t'-DEIO_STACKSIZE=262144' \\\n+\t'-D_GNU_SOURCE'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := \n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n+\t-I$(srcdir)/src/rt/libuv/include/uv-private \\\n+\t-I$(srcdir)/src/rt/libuv/src \\\n+\t-I$(srcdir)/src/rt/libuv/src/ares/config_win32\n+\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_fds.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_library_init.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_llist.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/windows_port.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/core.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs-event.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/handle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/loop-watcher.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/pipe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/process.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/req.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/stdio.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/stream.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/tcp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/tty.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/threadpool.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/threads.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/timer.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/udp.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/util.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/winapi.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/winsock.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := \n+\n+$(obj).target/src/rt/libuv/libuv.a: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(obj).target/src/rt/libuv/libuv.a: LIBS := $(LIBS)\n+$(obj).target/src/rt/libuv/libuv.a: TOOLSET := $(TOOLSET)\n+$(obj).target/src/rt/libuv/libuv.a: $(OBJS) FORCE_DO_CMD\n+\t$(call do_cmd,alink)\n+\n+all_deps += $(obj).target/src/rt/libuv/libuv.a\n+# Add target alias\n+.PHONY: uv\n+uv: $(obj).target/src/rt/libuv/libuv.a\n+\n+# Add target alias to \"all\" target.\n+.PHONY: all\n+all: uv\n+"}, {"sha": "a74c4017fec1f9903feaceb791c307b0fe11aacd", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -50,7 +50,7 @@ ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n   CFG_LIB_NAME=lib$(1).dylib\n   CFG_UNIXY := 1\n   CFG_LDENV := DYLD_LIBRARY_PATH\n-  CFG_GCCISH_LINK_FLAGS += -dynamiclib -lpthread\n+  CFG_GCCISH_LINK_FLAGS += -dynamiclib -lpthread -framework CoreServices\n   CFG_GCCISH_DEF_FLAG := -Wl,-exported_symbols_list,\n   # Darwin has a very blurry notion of \"64 bit\", and claims it's running\n   # \"on an i386\" when the whole userspace is 64-bit and the compiler"}, {"sha": "41fa5eb988007c259f133992076a628e7678f8e2", "filename": "mk/rt.mk", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -68,11 +68,22 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/test/rust_test_util.h \\\n                rt/arch/i386/context.h \\\n \n+ifeq ($(CFG_WINDOWSY), 1)\n+  LIBUV_OSTYPE := win\n+  LIBUV_LIB := rt/libuv/Default/obj.target/src/rt/libuv/libuv.a\n+else ifeq ($(CFG_OSTYPE), apple-darwin)\n+  LIBUV_OSTYPE := mac\n+  LIBUV_LIB := rt/libuv/Default/libuv.a\n+else\n+  LIBUV_OSTYPE := unix\n+  LIBUV_LIB := rt/libuv/Default/obj.target/src/rt/libuv/libuv.a\n+endif\n+\n RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash \\\n                 -I $(S)src/rt/arch/i386 -I $(S)src/rt/libuv/include\n RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o) $(RUNTIME_LL:.ll=.o) $(RUNTIME_S:.S=.o)\n-RUNTIME_LIBS := rt/libuv/uv.a\n+RUNTIME_LIBS := $(LIBUV_LIB)\n \n rt/%.o: rt/%.cpp $(MKFILES)\n \t@$(call E, compile: $@)\n@@ -105,12 +116,18 @@ rt/$(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR) $(RUNTIME_DEF) $(RU\n # FIXME: For some reason libuv's makefiles can't figure out the correct definition\n # of CC on the mingw I'm using, so we are explicitly using gcc. Also, we\n # have to list environment variables first on windows... mysterious\n-rt/libuv/uv.a: $(wildcard \\\n+$(LIBUV_LIB): $(wildcard \\\n                      $(S)src/rt/libuv/* \\\n                      $(S)src/rt/libuv/*/* \\\n                      $(S)src/rt/libuv/*/*/* \\\n                      $(S)src/rt/libuv/*/*/*/*)\n-\t$(Q)CFLAGS=\\\"-m32\\\" LDFLAGS=\\\"-m32\\\" CC=$(CC) $(MAKE) -C rt/libuv\n+\t$(Q)$(MAKE) -C $(S)mk/libuv/$(LIBUV_OSTYPE) \\\n+\t\tCFLAGS=\"-m32\" LDFLAGS=\"-m32\" \\\n+\t\tCC=\"$(CFG_GCCISH_CROSS)$(CC)\" \\\n+\t\tCXX=\"$(CFG_GCCISH_CROSS)$(CXX)\" \\\n+\t\tAR=\"$(CFG_GCCISH_CROSS)$(AR)\" \\\n+\t\tbuilddir_name=\"$(CFG_BUILD_DIR)/rt/libuv\" \\\n+\t\tV=$(VERBOSE) FLOCK= uv\n \n # These could go in rt.mk or rustllvm.mk, they're needed for both.\n "}, {"sha": "1e24f5eaa3715503b4b6c270bdc03b201cd12eba", "filename": "src/etc/gyp-uv", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Fetc%2Fgyp-uv", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Fetc%2Fgyp-uv", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgyp-uv?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,36 @@\n+#!/bin/sh\n+\n+set -e\n+\n+cd `dirname $0`\n+cd ../..\n+\n+args=\"--depth . -Dlibrary=static_library -Dtarget_arch=ia32\"\n+\n+./src/rt/libuv/build/gyp/gyp src/rt/libuv/uv.gyp $args \\\n+  -f make-mac \\\n+  --generator-output mk/libuv/mac \\\n+  -DOS=mac\n+\n+./src/rt/libuv/build/gyp/gyp src/rt/libuv/uv.gyp $args \\\n+  -f make-linux \\\n+  --generator-output mk/libuv/unix \\\n+  -DOS=linux\n+\n+./src/rt/libuv/build/gyp/gyp src/rt/libuv/uv.gyp $args \\\n+  -f make-linux \\\n+  --generator-output mk/libuv/win \\\n+  -DOS=win\n+\n+# Comment out the gyp auto regeneration\n+for os in mac unix win; do\n+  sed -i \".save\" \\\n+    -e 's/^\\(Makefile: $(srcdir)\\/src\\/rt\\/libuv\\/uv\\.gyp\\)/#\\1/' \\\n+    mk/libuv/$os/Makefile\n+\n+  sed -i \".save\" \\\n+    -e 's/^\\(\t$(call do_cmd,regen_makefile)\\)/#\\1/' \\\n+    mk/libuv/$os/Makefile\n+\n+  rm mk/libuv/$os/Makefile.save\n+done"}, {"sha": "09164c65eb0799d6ef1d7faa20ed305da5711127", "filename": "src/rt/libuv/.gitignore", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.gitignore?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -7,37 +7,23 @@\n *.orig\n *.sdf\n *.suo\n-*.vcxproj.filters\n-*.vcxproj.user\n-ev/.deps/\n-ev/.libs/\n-ev/Makefile\n-ev/config.h\n-ev/config.log\n-ev/config.status\n-ev/libtool\n-ev/stamp-h1\n-ev/autom4te.cache\n-/msvs/ipch/\n-/build/\n-test/run-tests\n-test/run-benchmarks\n-test/run-tests.exe\n-test/run-benchmarks.exe\n-test/run-benchmarks.dSYM/\n-test/run-tests.dSYM/\n+/out/\n+/build/gyp\n \n+/test/run-tests\n+/test/run-tests.exe\n+/test/run-tests.dSYM\n+/test/run-benchmarks\n+/test/run-benchmarks.exe\n+/test/run-benchmarks.dSYM\n \n-c-ares/.deps/\n-c-ares/.libs/\n-c-ares/Makefile\n-c-ares/acountry\n-c-ares/adig\n-c-ares/ahost\n-c-ares/ares_config.h\n-c-ares/config.log\n-c-ares/config.status\n-c-ares/libcares.pc\n-c-ares/libtool\n-c-ares/stamp-h1\n-c-ares/stamp-h2\n+*.sln\n+*.vcproj\n+*.vcxproj\n+*.vcxproj.filters\n+*.vcxproj.user\n+_UpgradeReport_Files/\n+UpgradeLog*.XML\n+Debug\n+Release\n+ipch"}, {"sha": "520f71be68f08d08544107d71884155cbda1d912", "filename": "src/rt/libuv/.mailmap", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2F.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2F.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.mailmap?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,8 @@\n+# update AUTHORS with:\n+#   git log --all --reverse --format='%aN <%aE>' | perl -ne 'BEGIN{print \"# Authors ordered by first contribution.\\n\"} print unless $h{$_}; $h{$_} = 1' > AUTHORS\n+<rm@joyent.com> <rm@fingolfin.org>\n+<ryan@joyent.com> <ry@tinyclouds.org>\n+<bertbelder@gmail.com> <info@2bs.nl>\n+<alan@prettyrobots.com> <alan@blogometer.com>\n+San-Tai Hsu <vanilla@fatpipi.com>\n+Isaac Z. Schlueter <i@izs.me>"}, {"sha": "eefcd7dc1ee1b848f20c4de2750036e0a59393a3", "filename": "src/rt/libuv/AUTHORS", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FAUTHORS?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -3,9 +3,24 @@ Ryan Dahl <ryan@joyent.com>\n Bert Belder <bertbelder@gmail.com>\n Josh Roesslein <jroesslein@gmail.com>\n Alan Gutierrez <alan@prettyrobots.com>\n+Joshua Peek <josh@joshpeek.com>\n Igor Zinkovsky <igorzi@microsoft.com>\n-Vanilla Hsu <vanilla@fatpipi.com>\n+San-Tai Hsu <vanilla@fatpipi.com>\n Ben Noordhuis <info@bnoordhuis.nl>\n Henry Rawas <henryr@schakra.com>\n Robert Mustacchi <rm@joyent.com>\n Matt Stevens <matt@alloysoft.com>\n+Paul Querna <pquerna@apache.org>\n+Shigeki Ohtsu <ohtsu@iij.ad.jp>\n+Tom Hughes <tom.hughes@palm.com>\n+Peter Bright <drpizza@quiscalusmexicanus.org>\n+Jeroen Janssen <jeroen.janssen@gmail.com>\n+Andrea Lattuada <ndr.lattuada@gmail.com>\n+Augusto Henrique Hentz <ahhentz@gmail.com>\n+Clifford Heath <clifford.heath@gmail.com>\n+Jorge Chamorro Bieling <jorge@jorgechamorro.com>\n+Luis Lavena <luislavena@gmail.com>\n+Matthew Sporleder <msporleder@gmail.com>\n+Erick Tryzelaar <erick.tryzelaar@gmail.com>\n+Isaac Z. Schlueter <i@izs.me>\n+Pieter Noordhuis <pcnoordhuis@gmail.com>"}, {"sha": "f079f65776527a1a85745d34350e0bafeb8e81f4", "filename": "src/rt/libuv/LIBUV_REVISION", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2FLIBUV_REVISION", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2FLIBUV_REVISION", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FLIBUV_REVISION?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,5 +0,0 @@\n-This subtree is pulled from:\n-ee599ec1141cc48f895de1f9d148033babdf9c2a\n-\n-When pulling in a new version of libuv, please update this file to ensure that\n-everyone correctly rebuilds libuv."}, {"sha": "59be3de08f327bbea53246e3599ca710f09e1750", "filename": "src/rt/libuv/Makefile", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FMakefile?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -18,30 +18,13 @@\n # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n # IN THE SOFTWARE.\n \n-include ../../config.mk\n-CFLAGS=-m32\n-LDFLAGS=-m32\n-CC=gcc \n-\n-S:=$(shell cd ../../; cd $(CFG_SRC_DIR)src/rt/libuv; pwd)\n-\n-ifdef VERBOSE\n-  Q :=\n-  EE =\n-else\n-  Q := @\n-  EE = echo $(1)\n-endif\n-\n-VPATH:=$(S)\n-\n uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n \n ifdef MSVC\n uname_S := MINGW\n endif\n \n-CPPFLAGS += -I$(S)/include\n+CPPFLAGS += -Iinclude -Iinclude/uv-private\n \n CARES_OBJS =\n CARES_OBJS += src/ares/ares__close_sockets.o\n@@ -94,8 +77,43 @@ else\n include config-unix.mk\n endif\n \n-all: uv.a\n+TESTS=test/echo-server.c test/test-*.c\n+BENCHMARKS=test/echo-server.c test/dns-server.c test/benchmark-*.c\n+\n+all: uv.a test/run-tests$(E) test/run-benchmarks$(E)\n \n $(CARES_OBJS): %.o: %.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) -o $*.o -c $(CFLAGS) $(CPPFLAGS) $< -DHAVE_CONFIG_H\n+\t$(CC) -o $*.o -c $(CFLAGS) $(CPPFLAGS) $< -DHAVE_CONFIG_H\n+\n+test/run-tests$(E): test/*.h test/run-tests.c $(RUNNER_SRC) test/runner-unix.c $(TESTS) uv.a\n+\t$(CC) $(CPPFLAGS) $(RUNNER_CFLAGS) -o test/run-tests test/run-tests.c \\\n+\t\ttest/runner.c $(RUNNER_SRC) $(TESTS) uv.a $(RUNNER_LIBS) $(RUNNER_LINKFLAGS)\n+\n+test/run-benchmarks$(E): test/*.h test/run-benchmarks.c test/runner.c $(RUNNER_SRC) $(BENCHMARKS) uv.a\n+\t$(CC) $(CPPFLAGS) $(RUNNER_CFLAGS) -o test/run-benchmarks test/run-benchmarks.c \\\n+\t\t test/runner.c $(RUNNER_SRC) $(BENCHMARKS) uv.a $(RUNNER_LIBS) $(RUNNER_LINKFLAGS)\n+\n+test/echo.o: test/echo.c test/echo.h\n+\t$(CC) $(CPPFLAGS) $(CFLAGS) -c test/echo.c -o test/echo.o\n+\n+\n+.PHONY: clean clean-platform distclean distclean-platform test bench\n+\n+\n+test: test/run-tests$(E)\n+\ttest/run-tests\n+\n+#test-%:\ttest/run-tests$(E)\n+#\ttest/run-tests $(@:test-%=%)\n+\n+bench: test/run-benchmarks$(E)\n+\ttest/run-benchmarks\n+\n+#bench-%:\ttest/run-benchmarks$(E)\n+#\ttest/run-benchmarks $(@:bench-%=%)\n+\n+clean: clean-platform\n+\t$(RM) -f src/*.o *.a test/run-tests$(E) test/run-benchmarks$(E)\n+\n+distclean: distclean-platform\n+\t$(RM) -f src/*.o *.a test/run-tests$(E) test/run-benchmarks$(E)"}, {"sha": "4e2c2cd2614e160eed5ebe4ea31d6b8e9d843b3d", "filename": "src/rt/libuv/README", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FREADME?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,16 +0,0 @@\n-This is the new networking layer for Node. Its purpose is to abstract\n-IOCP on windows and libev on Unix systems. We intend to eventually contain\n-all platform differences in this library.\n-\n-http://nodejs.org/\n-\n-(This was previously called liboio)\n-\n-Supported Platforms:\n-\n-Microsoft Windows operating systems since Windows XP sp2. It can be built\n-with either Visual Studio or MinGW.\n-\n-Linux 2.6 and MacOS using the GCC toolchain.\n-\n-Solaris 121 and later using GCC toolchain."}, {"sha": "9fc4ae62ebdd10ef49c8bc1212a2eff9f73e7507", "filename": "src/rt/libuv/README.md", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FREADME.md?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,92 @@\n+# libuv\n+\n+libuv is a new platform layer for Node. Its purpose is to abstract IOCP on\n+windows and libev on Unix systems. We intend to eventually contain all\n+platform differences in this library.\n+\n+http://nodejs.org/\n+\n+## Features\n+\n+Implemented:\n+\n+ * Non-blocking TCP sockets\n+\n+ * Non-blocking named pipes\n+\n+ * UDP\n+\n+ * Timers\n+\n+ * Child process spawning\n+\n+ * Asynchronous DNS via c-ares or `uv_getaddrinfo`.\n+\n+ * Asynchronous file system APIs `uv_fs_*`\n+\n+ * High resolution time `uv_hrtime`\n+\n+ * Current executable path look up `uv_exepath`\n+\n+ * Thread pool scheduling `uv_queue_work`\n+\n+In-progress:\n+\n+ * File system events (Currently supports inotify, `ReadDirectoryChangesW`\n+   and will support kqueue and event ports in the near future.)\n+   `uv_fs_event_t`\n+\n+ * VT100 TTY `uv_tty_t`\n+\n+ * Socket sharing between processes `uv_ipc_t`\n+\n+\n+## Documentation\n+\n+See `include/uv.h`.\n+\n+\n+## Build Instructions\n+\n+For GCC (including MinGW) there are two methods building: via normal\n+makefiles or via GYP. GYP is a meta-build system which can generate MSVS,\n+Makefile, and XCode backends. It is best used for integration into other\n+projects.  The old (more stable) system is using Makefiles.\n+\n+To build via Makefile simply execute:\n+\n+    make\n+\n+To build with Visual Studio run the vcbuilds.bat file which will\n+checkout the GYP code into build/gyp and generate the uv.sln and\n+related files.\n+\n+Windows users can also build from cmd-line using msbuild.  This is\n+done by running vcbuild.bat from Visual Studio command prompt.\n+\n+To have GYP generate build script for another system you will need to\n+checkout GYP into the project tree manually:\n+\n+    svn co http://gyp.googlecode.com/svn/trunk build/gyp\n+\n+Unix users run\n+\n+    ./gyp_uv -f make\n+    make\n+\n+Macintosh users run\n+\n+    ./gyp_uv -f xcode\n+    xcodebuild -project uv.xcodeproj -configuration Release -target All\n+\n+\n+## Supported Platforms\n+\n+Microsoft Windows operating systems since Windows XP SP2. It can be built\n+with either Visual Studio or MinGW.\n+\n+Linux 2.6 using the GCC toolchain.\n+\n+MacOS using the GCC or XCode toolchain.\n+\n+Solaris 121 and later using GCC toolchain."}, {"sha": "9a0be4dc394bd98d5805fae72bebab67e3e96690", "filename": "src/rt/libuv/common.gypi", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fcommon.gypi", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fcommon.gypi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fcommon.gypi?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,164 @@\n+{\n+  'variables': {\n+    'visibility%': 'hidden',         # V8's visibility setting\n+    'target_arch%': 'ia32',          # set v8's target architecture\n+    'host_arch%': 'ia32',            # set v8's host architecture\n+    'library%': 'static_library',    # allow override to 'shared_library' for DLL/.so builds\n+    'component%': 'static_library',  # NB. these names match with what V8 expects\n+    'msvs_multi_core_compile': '0',  # we do enable multicore compiles, but not using the V8 way\n+  },\n+\n+  'target_defaults': {\n+    'default_configuration': 'Debug',\n+    'configurations': {\n+      'Debug': {\n+        'defines': [ 'DEBUG', '_DEBUG' ],\n+        'cflags': [ '-g', '-O0' ],\n+        'msvs_settings': {\n+          'VCCLCompilerTool': {\n+            'target_conditions': [\n+              ['library==\"static_library\"', {\n+                'RuntimeLibrary': 1, # static debug\n+              }, {\n+                'RuntimeLibrary': 3, # DLL debug\n+              }],\n+            ],\n+            'Optimization': 0, # /Od, no optimization\n+            'MinimalRebuild': 'true',\n+            'OmitFramePointers': 'false',\n+            'BasicRuntimeChecks': 3, # /RTC1\n+          },\n+          'VCLinkerTool': {\n+            'LinkIncremental': 2, # enable incremental linking\n+          },\n+        },\n+      },\n+      'Release': {\n+        'defines': [ 'NDEBUG' ],\n+        'cflags': [ '-O3', '-fomit-frame-pointer', '-fdata-sections', '-ffunction-sections' ],\n+        'msvs_settings': {\n+          'VCCLCompilerTool': {\n+            'target_conditions': [\n+              ['library==\"static_library\"', {\n+                'RuntimeLibrary': 0, # static release\n+              }, {\n+                'RuntimeLibrary': 2, # debug release\n+              }],\n+            ],\n+            'Optimization': 3, # /Ox, full optimization\n+            'FavorSizeOrSpeed': 1, # /Ot, favour speed over size\n+            'InlineFunctionExpansion': 2, # /Ob2, inline anything eligible\n+            'WholeProgramOptimization': 'true', # /GL, whole program optimization, needed for LTCG\n+            'OmitFramePointers': 'true',\n+            'EnableFunctionLevelLinking': 'true',\n+            'EnableIntrinsicFunctions': 'true',\n+            'AdditionalOptions': [\n+              '/MP', # compile across multiple CPUs\n+            ],\n+          },\n+          'VCLibrarianTool': {\n+            'AdditionalOptions': [\n+              '/LTCG', # link time code generation\n+            ],\n+          },\n+          'VCLinkerTool': {\n+            'LinkTimeCodeGeneration': 1, # link-time code generation\n+            'OptimizeReferences': 2, # /OPT:REF\n+            'EnableCOMDATFolding': 2, # /OPT:ICF\n+            'LinkIncremental': 1, # disable incremental linking\n+          },\n+        },\n+      }\n+    },\n+    'msvs_settings': {\n+      'VCCLCompilerTool': {\n+        'StringPooling': 'true', # pool string literals\n+        'DebugInformationFormat': 3, # Generate a PDB\n+        'WarningLevel': 3,\n+        'BufferSecurityCheck': 'true',\n+        'ExceptionHandling': 1, # /EHsc\n+        'SuppressStartupBanner': 'true',\n+        'WarnAsError': 'false',\n+      },\n+      'VCLibrarianTool': {\n+      },\n+      'VCLinkerTool': {\n+        'GenerateDebugInformation': 'true',\n+        'RandomizedBaseAddress': 2, # enable ASLR\n+        'DataExecutionPrevention': 2, # enable DEP\n+        'AllowIsolation': 'true',\n+        'SuppressStartupBanner': 'true',\n+        'target_conditions': [\n+          ['_type==\"executable\"', {\n+            'SubSystem': 1, # console executable\n+          }],\n+        ],\n+      },\n+    },\n+    'conditions': [\n+      ['OS == \"win\"', {\n+        'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin\n+        'defines': [\n+          'WIN32',\n+          # we don't really want VC++ warning us about\n+          # how dangerous C functions are...\n+          '_CRT_SECURE_NO_DEPRECATE',\n+          # ... or that C implementations shouldn't use\n+          # POSIX names\n+          '_CRT_NONSTDC_NO_DEPRECATE',\n+        ],\n+      }],\n+      [ 'OS==\"linux\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"solaris\"', {\n+        'cflags': [ '-Wall', '-pthread', ],\n+        'cflags_cc': [ '-fno-rtti', '-fno-exceptions' ],\n+        'ldflags': [ '-pthread', ],\n+        'conditions': [\n+          [ 'host_arch != target_arch and target_arch==\"ia32\"', {\n+            'cflags': [ '-m32' ],\n+            'ldflags': [ '-m32' ],\n+          }],\n+          [ 'OS==\"linux\"', {\n+            'cflags': [ '-ansi' ],\n+          }],\n+          [ 'visibility==\"hidden\"', {\n+            'cflags': [ '-fvisibility=hidden' ],\n+          }],\n+        ],\n+      }],\n+      ['OS==\"mac\"', {\n+        'xcode_settings': {\n+          'ALWAYS_SEARCH_USER_PATHS': 'NO',\n+          'GCC_CW_ASM_SYNTAX': 'NO',                # No -fasm-blocks\n+          'GCC_DYNAMIC_NO_PIC': 'NO',               # No -mdynamic-no-pic\n+                                                    # (Equivalent to -fPIC)\n+          'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',        # -fno-exceptions\n+          'GCC_ENABLE_CPP_RTTI': 'NO',              # -fno-rtti\n+          'GCC_ENABLE_PASCAL_STRINGS': 'NO',        # No -mpascal-strings\n+          # GCC_INLINES_ARE_PRIVATE_EXTERN maps to -fvisibility-inlines-hidden\n+          'GCC_INLINES_ARE_PRIVATE_EXTERN': 'YES',\n+          'GCC_SYMBOLS_PRIVATE_EXTERN': 'YES',      # -fvisibility=hidden\n+          'GCC_THREADSAFE_STATICS': 'NO',           # -fno-threadsafe-statics\n+          'GCC_VERSION': '4.2',\n+          'GCC_WARN_ABOUT_MISSING_NEWLINE': 'YES',  # -Wnewline-eof\n+          'MACOSX_DEPLOYMENT_TARGET': '10.4',       # -mmacosx-version-min=10.4\n+          'PREBINDING': 'NO',                       # No -Wl,-prebind\n+          'USE_HEADERMAP': 'NO',\n+          'OTHER_CFLAGS': [\n+            '-fno-strict-aliasing',\n+          ],\n+          'WARNING_CFLAGS': [\n+            '-Wall',\n+            '-Wendif-labels',\n+            '-W',\n+            '-Wno-unused-parameter',\n+          ],\n+        },\n+        'target_conditions': [\n+          ['_type!=\"static_library\"', {\n+            'xcode_settings': {'OTHER_LDFLAGS': ['-Wl,-search_paths_first']},\n+          }],\n+        ],\n+      }],\n+    ],\n+  },\n+}"}, {"sha": "d4daca8a1ff79ce908fd018742d25231f095f8d2", "filename": "src/rt/libuv/config-mingw.mk", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-mingw.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -20,37 +20,41 @@\n \n # Use make -f Makefile.gcc PREFIX=i686-w64-mingw32-\n # for cross compilation\n-CC ?= $(PREFIX)gcc\n-AR ?= $(PREFIX)ar\n+CC = $(PREFIX)gcc\n+AR = $(PREFIX)ar\n E=.exe\n \n-CFLAGS+=$(CPPFLAGS) -g --std=gnu89 -D_WIN32_WINNT=0x0501 -I$(S)/src/ares/config_win32\n+CFLAGS=$(CPPFLAGS) -g --std=gnu89 -D_WIN32_WINNT=0x0501 -Isrc/ares/config_win32\n LINKFLAGS=-lm\n \n CARES_OBJS += src/ares/windows_port.o\n+WIN_SRCS=$(wildcard src/win/*.c)\n+WIN_OBJS=$(WIN_SRCS:.c=.o)\n \n-uv.a: src/uv-win.o src/uv-common.o src/uv-eio.o src/eio/eio.o $(CARES_OBJS)\n-\t@$(call EE, ar: $@)\n-\t$(Q)$(AR) rcs uv.a $^\n+RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE # Need _GNU_SOURCE for strdup?\n+RUNNER_LINKFLAGS=$(LINKFLAGS)\n+RUNNER_LIBS=-lws2_32\n+RUNNER_SRC=test/runner-win.c\n \n-src/uv-win.o: src/uv-win.c include/uv.h include/uv-win.h\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CFLAGS) -c $< -o $@\n+uv.a: $(WIN_OBJS) src/uv-common.o $(CARES_OBJS)\n+\t$(AR) rcs uv.a src/win/*.o src/uv-common.o $(CARES_OBJS)\n \n-src/uv-common.o: src/uv-common.c include/uv.h include/uv-win.h\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CFLAGS) -c $< -o $@\n+src/win/%.o: src/win/%.c src/win/internal.h\n+\t$(CC) $(CFLAGS) -o $@ -c $<\n+\n+src/uv-common.o: src/uv-common.c include/uv.h include/uv-private/uv-win.h\n+\t$(CC) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n \n EIO_CPPFLAGS += $(CPPFLAGS)\n-EIO_CPPFLAGS += -DEIO_CONFIG_H=\\\"$(EIO_CONFIG)\\\"\n EIO_CPPFLAGS += -DEIO_STACKSIZE=65536\n EIO_CPPFLAGS += -D_GNU_SOURCE\n \n-src/eio/eio.o: src/eio/eio.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c $< -o $@\n-\n-src/uv-eio.o: src/uv-eio.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CPPFLAGS) -I$(S)src/eio/ $(CFLAGS) -c $< -o $@\n+clean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/eio/*.o\n+\t-rm -f src/win/*.o\n \n+distclean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/eio/*.o\n+\t-rm -f src/win/*.o"}, {"sha": "59bf8f17f8f4984b9b826d259543cf8b8f1266b2", "filename": "src/rt/libuv/config-unix.mk", "status": "modified", "additions": 72, "deletions": 40, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -18,95 +18,127 @@\n # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n # IN THE SOFTWARE.\n \n-CC ?= $(PREFIX)gcc\n-AR ?= $(PREFIX)ar\n+CC = $(PREFIX)gcc\n+AR = $(PREFIX)ar\n E=\n-CSTDFLAG=--std=c89 -pedantic\n-CFLAGS+=-g\n-CPPFLAGS += -I$(S)/src/ev\n+CSTDFLAG=--std=c89 -pedantic -Wall -Wextra -Wno-unused-parameter\n+CFLAGS += -g\n+CPPFLAGS += -Isrc/unix/ev\n LINKFLAGS=-lm\n \n CPPFLAGS += -D_LARGEFILE_SOURCE\n CPPFLAGS += -D_FILE_OFFSET_BITS=64\n \n+OBJS += src/unix/core.o\n+OBJS += src/unix/fs.o\n+OBJS += src/unix/cares.o\n+OBJS += src/unix/udp.o\n+OBJS += src/unix/error.o\n+OBJS += src/unix/process.o\n+OBJS += src/unix/tcp.o\n+OBJS += src/unix/pipe.o\n+OBJS += src/unix/tty.o\n+OBJS += src/unix/stream.o\n+\n ifeq (SunOS,$(uname_S))\n EV_CONFIG=config_sunos.h\n EIO_CONFIG=config_sunos.h\n-CPPFLAGS += -I$(S)/src/ares/config_sunos\n+CPPFLAGS += -Isrc/ares/config_sunos -D__EXTENSIONS__ -D_XOPEN_SOURCE=500\n LINKFLAGS+=-lsocket -lnsl\n-UV_OS_FILE=uv-sunos.c\n+OBJS += src/unix/sunos.o\n endif\n \n ifeq (Darwin,$(uname_S))\n EV_CONFIG=config_darwin.h\n EIO_CONFIG=config_darwin.h\n-CPPFLAGS += -I$(S)/src/ares/config_darwin\n+CPPFLAGS += -Isrc/ares/config_darwin\n LINKFLAGS+=-framework CoreServices\n-UV_OS_FILE=uv-darwin.c\n+OBJS += src/unix/darwin.o\n endif\n \n ifeq (Linux,$(uname_S))\n EV_CONFIG=config_linux.h\n EIO_CONFIG=config_linux.h\n-CSTDFLAG += -D_XOPEN_SOURCE=600\n-CPPFLAGS += -I$(S)/src/ares/config_linux\n+CSTDFLAG += -D_GNU_SOURCE\n+CPPFLAGS += -Isrc/ares/config_linux\n LINKFLAGS+=-lrt\n-UV_OS_FILE=uv-linux.c\n+OBJS += src/unix/linux.o\n endif\n \n ifeq (FreeBSD,$(uname_S))\n EV_CONFIG=config_freebsd.h\n EIO_CONFIG=config_freebsd.h\n-CPPFLAGS += -I$(S)/src/ares/config_freebsd\n+CPPFLAGS += -Isrc/ares/config_freebsd\n+LINKFLAGS+=\n+OBJS += src/unix/freebsd.o\n+endif\n+\n+ifeq (NetBSD,$(uname_S))\n+EV_CONFIG=config_netbsd.h\n+EIO_CONFIG=config_netbsd.h\n+CPPFLAGS += -Isrc/ares/config_netbsd\n LINKFLAGS+=\n-UV_OS_FILE=uv-freebsd.c\n+OBJS += src/unix/netbsd.o\n endif\n \n ifneq (,$(findstring CYGWIN,$(uname_S)))\n EV_CONFIG=config_cygwin.h\n EIO_CONFIG=config_cygwin.h\n-CPPFLAGS += -I$(S)/src/ares/config_cygwin\n+# We drop the --std=c89, it hides CLOCK_MONOTONIC on cygwin\n+CSTDFLAG = -D_GNU_SOURCE\n+CPPFLAGS += -Isrc/ares/config_cygwin\n LINKFLAGS+=\n-UV_OS_FILE=uv-cygwin.c\n+OBJS += src/unix/cygwin.o\n endif\n \n # Need _GNU_SOURCE for strdup?\n RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE\n+RUNNER_LINKFLAGS=$(LINKFLAGS)\n+\n+ifeq (SunOS,$(uname_S))\n+RUNNER_LINKFLAGS += -pthreads\n+else\n+RUNNER_LINKFLAGS += -pthread\n+endif\n \n-RUNNER_LINKFLAGS=$(LINKFLAGS) -pthread\n RUNNER_LIBS=\n RUNNER_SRC=test/runner-unix.c\n \n-uv.a: src/uv-unix.o src/uv-common.o src/uv-platform.o src/ev/ev.o src/uv-eio.o src/eio/eio.o $(CARES_OBJS)\n-\t@$(call EE, ar: $@)\n-\t$(Q)$(AR) rcs uv.a $^\n-\n-src/uv-platform.o: src/$(UV_OS_FILE) include/uv.h include/uv-unix.h\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c $< -o $@\n+uv.a: $(OBJS) src/uv-common.o src/unix/ev/ev.o src/unix/uv-eio.o src/unix/eio/eio.o $(CARES_OBJS)\n+\t$(AR) rcs uv.a $(OBJS) src/uv-common.o src/unix/uv-eio.o src/unix/ev/ev.o src/unix/eio/eio.o $(CARES_OBJS)\n \n-src/uv-unix.o: src/uv-unix.c include/uv.h include/uv-unix.h\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CSTDFLAG) $(CPPFLAGS) -I$(S)/eio $(CFLAGS) -c $< -o $@\n+src/unix/%.o: src/unix/%.c include/uv.h include/uv-private/uv-unix.h src/unix/internal.h\n+\t$(CC) $(CSTDFLAG) $(CPPFLAGS) -Isrc  $(CFLAGS) -c $< -o $@\n \n-src/uv-common.o: src/uv-common.c include/uv.h include/uv-unix.h\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c $< -o $@\n+src/uv-common.o: src/uv-common.c include/uv.h include/uv-private/uv-unix.h\n+\t$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n \n-src/ev/ev.o: src/ev/ev.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@ -DEV_CONFIG_H=\\\"$(EV_CONFIG)\\\"\n+src/unix/ev/ev.o: src/unix/ev/ev.c\n+\t$(CC) $(CPPFLAGS) $(CFLAGS) -c src/unix/ev/ev.c -o src/unix/ev/ev.o -DEV_CONFIG_H=\\\"$(EV_CONFIG)\\\"\n \n \n EIO_CPPFLAGS += $(CPPFLAGS)\n EIO_CPPFLAGS += -DEIO_CONFIG_H=\\\"$(EIO_CONFIG)\\\"\n-EIO_CPPFLAGS += -DEIO_STACKSIZE=65536\n+EIO_CPPFLAGS += -DEIO_STACKSIZE=262144\n EIO_CPPFLAGS += -D_GNU_SOURCE\n \n-src/eio/eio.o: src/eio/eio.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c $< -o $@\n+src/unix/eio/eio.o: src/unix/eio/eio.c\n+\t$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c src/unix/eio/eio.c -o src/unix/eio/eio.o\n+\n+src/unix/uv-eio.o: src/unix/uv-eio.c\n+\t$(CC) $(CPPFLAGS) -Isrc/unix/eio/ $(CSTDFLAG) $(CFLAGS) -c src/unix/uv-eio.c -o src/unix/uv-eio.o\n+\n+\n+clean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/unix/ev/*.o\n+\t-rm -f src/unix/eio/*.o\n+\t-rm -f src/unix/*.o\n+\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM\n \n-src/uv-eio.o: src/uv-eio.c\n-\t@$(call EE, compile: $@)\n-\t$(Q)$(CC) $(CPPFLAGS) -I$(S)/src/eio/ $(CSTDFLAG) $(CFLAGS) -c $< -o $@\n+distclean-platform:\n+\t-rm -f src/ares/*.o\n+\t-rm -f src/unix/ev/*.o\n+\t-rm -f src/unix/*.o\n+\t-rm -f src/unix/eio/*.o\n+\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM"}, {"sha": "9faa57591e943b2b9e58371f6147af5a0986a0f9", "filename": "src/rt/libuv/doc/desired-api.md", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fdoc%2Fdesired-api.md?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,159 +0,0 @@\n-Warning: this is not actual API but desired API.\n-\n-# `uv_handle_t`\n-\n-This is the abstract base class of all types of handles. All handles have in\n-common:\n-\n-* When handles are initialized, the reference count to the event loop is\n-  increased by one.\n-\n-* The user owns the `uv_handle_t` memory and is in charge of freeing it.\n-\n-* In order to free resources associated with a handle, one must `uv_close()`\n-  and wait for the `uv_close_cb` callback. After the close callback has been\n-  made, the user is allowed to the `uv_handle_t` object.\n-\n-* The `uv_close_cb` is always made directly off the event loop. That is, it\n-  is not called from `uv_close()`.\n-\n-\n-\n-# `uv_tcp_server_t`\n-\n-A TCP server class that is a subclass of `uv_handle_t`. This can be bound to\n-an address and begin accepting new TCP sockets.\n-\n-    int uv_bind4(uv_tcp_server_t* tcp_server, struct sockaddr_in* address);\n-    int uv_bind6(uv_tcp_server_t* tcp_server, struct sockaddr_in6* address);\n-\n-Binds the TCP server to an address. The `address` can be created with\n-`uv_ip4_addr()`. Call this before `uv_listen()`\n-\n-Returns zero on success, -1 on failure. Errors in order of least-seriousness:\n-\n-* `UV_EADDRINUSE` There is already another socket bound to the specified\n-  address.\n-\n-* `UV_EADDRNOTAVAIL` The `address` parameter is an IP address that is not \n-\n-* `UV_EINVAL` The server is already bound to an address.\n-\n-* `UV_EFAULT` Memory of `address` parameter is unintelligible.\n-\n-\n-    int uv_listen(uv_tcp_server_t*, int backlog, uv_connection_cb cb);\n-\n-Begins listening for connections. The accept callback is level-triggered.\n-\n-\n-    int uv_accept(uv_tcp_server_t* server,\n-                  uv_tcp_t* client);\n-\n-Accepts a connection. This should be called after the accept callback is\n-made. The `client` parameter should be uninitialized memory; `uv_accept` is\n-used instead of `uv_tcp_init` for server-side `uv_tcp_t` initialization.\n-\n-Return value 0 indicates success, -1 failure. Possible errors:\n-\n-* `UV_EAGAIN` There are no connections. Wait for the `uv_connection_cb` callback\n-  to be called again.\n-\n-* `UV_EFAULT` The memory of either `server` is unintelligible.\n-\n-\n-\n-# `uv_stream_t`\n-\n-An abstract subclass of `uv_handle_t`. Streams represent something that\n-reads and/or writes data. Streams can be half or full-duplex. TCP sockets\n-are streams, files are streams with offsets.\n-\n-    int uv_read_start(uv_stream_t* stream,\n-                      uv_alloc_cb alloc_cb,\n-                      uv_read_cb read_cb);\n-\n-Starts the stream reading continuously. The `alloc_cb` is used to allow the\n-user to implement various means of supplying the stream with buffers to\n-fill. The `read_cb` returns buffers to the user filled with data.\n-\n-Sometimes the buffers returned to the user do not contain data. This does\n-not indicate EOF as in other systems. EOF is made via the `uv_eof_cb` which\n-can be set like this `uv_set_eof_cb(stream, eof_cb);`\n-\n-\n-    int uv_read_stop(uv_stream_t* stream);\n-\n-Stops reading from the stream.\n-\n-    int uv_write_req_init(uv_write_req_t*,\n-                          uv_stream_t*,\n-                          uv_buf_t bufs[],\n-                          int butcnf);\n-\n-Initiates a write request on a stream.\n-\n-    int uv_shutdown_req_init(uv_shutdown_req_t*, uv_stream_t*)\n-\n-Initiates a shutdown of outgoing data once the write queue drains.\n-\n-\n-\n-# `uv_tcp_t`\n-\n-The TCP handle class represents one endpoint of a duplex TCP stream.\n-`uv_tcp_t` is a subclass of `uv_stream_t`. A TCP handle can represent a\n-client side connection (one that has been used with uv_connect_req_init`)\n-or a server-side connection (one that was initialized with `uv_accept`)\n-\n-    int uv_connect_req_init(uv_connect_req_t* req,\n-                            uv_tcp_t* socket,\n-                            struct sockaddr* addr);\n-\n-Initiates a request to open a connection.\n-\n-\n-\n-# `uv_req_t`\n-\n-Abstract class represents an asynchronous request. This is a subclass of `uv_handle_t`.\n-\n-\n-# `uv_connect_req_t`\n-\n-Subclass of `uv_req_t`. Represents a request for a TCP connection. Operates\n-on `uv_tcp_t` handles. Like other types of requests the `close_cb` indicates\n-completion of the request.\n-\n-    int uv_connect_req_init(uv_connect_req_t* req,\n-                            uv_tcp_t* socket,\n-                            struct sockaddr* addr);\n-\n-Initializes the connection request. Returning 0 indicates success, -1 if\n-there was an error. The following values can be retrieved from\n-`uv_last_error` in the case of an error:\n-\n-* ???\n-\n-\n-# `uv_shutdown_req_t`\n-\n-Subclass of `uv_req_t`. Represents an ongoing shutdown request. Once the\n-write queue of the parent `uv_stream_t` is drained, the outbound data\n-channel is shutdown. Once a shutdown request is initiated on a stream, the\n-stream will allow no more writes.\n-\n-    int uv_shutdown_req_init(uv_shutdown_req_t*,\n-                             uv_stream_t* parent);\n-\n-Initializes the shutdown request.\n-\n-\n-# `uv_write_req_t`\n-\n-    int uv_write_req_init(uv_write_req_t*,\n-                          uv_stream_t*,\n-                          uv_buf_t bufs[],\n-                          int butcnf);\n-\n-Initiates a write request on a stream."}, {"sha": "a7a9689c265b29c87c1932bd7ce616afd32ee546", "filename": "src/rt/libuv/gyp_uv", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fgyp_uv", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fgyp_uv", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fgyp_uv?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,60 @@\n+#!/usr/bin/env python\n+import glob\n+import os\n+import shlex\n+import sys\n+\n+script_dir = os.path.dirname(__file__)\n+uv_root = os.path.normpath(script_dir)\n+\n+sys.path.insert(0, os.path.join(uv_root, 'build', 'gyp', 'pylib'))\n+import gyp\n+\n+# Directory within which we want all generated files (including Makefiles)\n+# to be written.\n+output_dir = os.path.join(os.path.abspath(uv_root), 'out')\n+\n+def run_gyp(args):\n+  rc = gyp.main(args)\n+  if rc != 0:\n+    print 'Error running GYP'\n+    sys.exit(rc)\n+\n+if __name__ == '__main__':\n+  args = sys.argv[1:]\n+\n+  # GYP bug.\n+  # On msvs it will crash if it gets an absolute path.\n+  # On Mac/make it will crash if it doesn't get an absolute path.\n+  if sys.platform == 'win32':\n+    args.append(os.path.join(uv_root, 'uv.gyp'))\n+    common_fn  = os.path.join(uv_root, 'common.gypi')\n+    options_fn = os.path.join(uv_root, 'options.gypi')\n+  else:\n+    args.append(os.path.join(os.path.abspath(uv_root), 'uv.gyp'))\n+    common_fn  = os.path.join(os.path.abspath(uv_root), 'common.gypi')\n+    options_fn = os.path.join(os.path.abspath(uv_root), 'options.gypi')\n+\n+  if os.path.exists(common_fn):\n+    args.extend(['-I', common_fn])\n+\n+  if os.path.exists(options_fn):\n+    args.extend(['-I', options_fn])\n+\n+  args.append('--depth=' + uv_root)\n+\n+  # There's a bug with windows which doesn't allow this feature.\n+  if sys.platform != 'win32':\n+\n+    # Tell gyp to write the Makefiles into output_dir\n+    args.extend(['--generator-output', output_dir])\n+\n+    # Tell make to write its output into the same dir\n+    args.extend(['-Goutput_dir=' + output_dir])\n+\n+  args.append('-Dtarget_arch=ia32')\n+  args.append('-Dcomponent=static_library')\n+  args.append('-Dlibrary=static_library')\n+  gyp_args = list(args)\n+  print gyp_args\n+  run_gyp(gyp_args)"}, {"sha": "450df6ba299789e4f7b2984b1503d1b28744a81f", "filename": "src/rt/libuv/include/uv-private/eio.h", "status": "renamed", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -1,7 +1,7 @@\n /*\n  * libeio API header\n  *\n- * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libeio@schmorp.de>\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libeio@schmorp.de>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without modifica-\n@@ -45,17 +45,9 @@ extern \"C\" {\n #endif\n \n #include <stddef.h>\n+#include <signal.h>\n #include <sys/types.h>\n \n-#ifdef __OpenBSD__\n-# include <inttypes.h>\n-#endif\n-\n-#ifdef _WIN32\n-# define uid_t int\n-# define gid_t int\n-#endif\n-\n typedef struct eio_req    eio_req;\n typedef struct eio_dirent eio_dirent;\n \n@@ -67,12 +59,35 @@ typedef int (*eio_cb)(eio_req *req);\n \n #ifndef EIO_STRUCT_STAT\n # ifdef _WIN32\n-#   define EIO_STRUCT_STAT struct _stati64\n+#  define EIO_STRUCT_STAT struct _stati64\n+#  define EIO_STRUCT_STATI64\n # else\n-#   define EIO_STRUCT_STAT struct stat\n+#  define EIO_STRUCT_STAT struct stat\n # endif\n #endif\n \n+#ifdef _WIN32\n+  typedef int      eio_uid_t;\n+  typedef int      eio_gid_t;\n+  typedef int      eio_mode_t;\n+  #ifdef __MINGW32__ /* no intptr_t */\n+    typedef ssize_t  eio_ssize_t;\n+  #else\n+    typedef intptr_t eio_ssize_t; /* or SSIZE_T */\n+  #endif\n+  #if __GNUC__\n+    typedef long long eio_ino_t;\n+  #else\n+    typedef __int64   eio_ino_t; /* unsigned not supported by msvc */\n+  #endif\n+#else\n+  typedef uid_t    eio_uid_t;\n+  typedef gid_t    eio_gid_t;\n+  typedef ssize_t  eio_ssize_t;\n+  typedef ino_t    eio_ino_t;\n+  typedef mode_t   eio_mode_t;\n+#endif\n+\n #ifndef EIO_STRUCT_STATVFS\n # define EIO_STRUCT_STATVFS struct statvfs\n #endif\n@@ -119,7 +134,7 @@ struct eio_dirent\n   unsigned short namelen; /* size of filename without trailing 0 */\n   unsigned char type; /* one of EIO_DT_* */\n   signed char score; /* internal use */\n-  ino_t inode; /* the inode number, if available, otherwise unspecified */\n+  eio_ino_t inode; /* the inode number, if available, otherwise unspecified */\n };\n \n /* eio_msync flags */\n@@ -131,25 +146,29 @@ enum\n };\n \n /* eio_mtouch flags */\n-\n enum\n {\n   EIO_MT_MODIFY     = 1\n };\n \n /* eio_sync_file_range flags */\n-\n enum\n {\n   EIO_SYNC_FILE_RANGE_WAIT_BEFORE = 1,\n   EIO_SYNC_FILE_RANGE_WRITE       = 2,\n   EIO_SYNC_FILE_RANGE_WAIT_AFTER  = 4\n };\n \n-typedef double eio_tstamp; /* feel free to use double in your code directly */\n+/* eio_fallocate flags */\n+enum\n+{\n+  EIO_FALLOC_FL_KEEP_SIZE = 1 /* MUST match the value in linux/falloc.h */\n+};\n \n-/* the eio request structure */\n+/* timestamps and differences - feel free to use double in your code directly */\n+typedef double eio_tstamp;\n \n+/* the eio request structure */\n enum\n {\n   EIO_CUSTOM,\n@@ -162,12 +181,12 @@ enum\n   EIO_UTIME, EIO_FUTIME,\n   EIO_CHMOD, EIO_FCHMOD,\n   EIO_CHOWN, EIO_FCHOWN,\n-  EIO_SYNC, EIO_FSYNC, EIO_FDATASYNC,\n-  EIO_MSYNC, EIO_MTOUCH, EIO_SYNC_FILE_RANGE,\n+  EIO_SYNC, EIO_FSYNC, EIO_FDATASYNC, EIO_SYNCFS,\n+  EIO_MSYNC, EIO_MTOUCH, EIO_SYNC_FILE_RANGE, EIO_FALLOCATE,\n   EIO_MLOCK, EIO_MLOCKALL,\n   EIO_UNLINK, EIO_RMDIR, EIO_MKDIR, EIO_RENAME,\n   EIO_MKNOD, EIO_READDIR,\n-  EIO_LINK, EIO_SYMLINK, EIO_READLINK,\n+  EIO_LINK, EIO_SYMLINK, EIO_READLINK, EIO_REALPATH,\n   EIO_GROUP, EIO_NOP,\n   EIO_BUSY\n };\n@@ -194,26 +213,32 @@ struct eio_req\n {\n   eio_req volatile *next; /* private ETP */\n \n-  ssize_t result;  /* result of syscall, e.g. result = read (... */\n-  off_t offs;      /* read, write, truncate, readahead, sync_file_range: file offset */\n-  size_t size;     /* read, write, readahead, sendfile, msync, mlock, sync_file_range: length */\n+  eio_ssize_t result;  /* result of syscall, e.g. result = read (... */\n+  off_t offs;      /* read, write, truncate, readahead, sync_file_range, fallocate: file offset, mknod: dev_t */\n+  size_t size;     /* read, write, readahead, sendfile, msync, mlock, sync_file_range, fallocate: length */\n   void *ptr1;      /* all applicable requests: pathname, old name; readdir: optional eio_dirents */\n   void *ptr2;      /* all applicable requests: new name or memory buffer; readdir: name strings */\n   eio_tstamp nv1;  /* utime, futime: atime; busy: sleep time */\n   eio_tstamp nv2;  /* utime, futime: mtime */\n \n   int type;        /* EIO_xxx constant ETP */\n   int int1;        /* all applicable requests: file descriptor; sendfile: output fd; open, msync, mlockall, readdir: flags */\n-  long int2;       /* chown, fchown: uid; sendfile: input fd; open, chmod, mkdir, mknod: file mode, sync_file_range: flags */\n-  long int3;       /* chown, fchown: gid; mknod: dev_t */\n+  long int2;       /* chown, fchown: uid; sendfile: input fd; open, chmod, mkdir, mknod: file mode, sync_file_range, fallocate: flags */\n+  long int3;       /* chown, fchown: gid */\n   int errorno;     /* errno value on syscall return */\n \n+#if __i386 || __amd64\n+  unsigned char cancelled;\n+#else\n+  sig_atomic_t cancelled;\n+#endif\n+\n   unsigned char flags; /* private */\n   signed char pri;     /* the priority */\n \n   void *data;\n   eio_cb finish;\n-  void (*destroy)(eio_req *req); /* called when requets no longer needed */\n+  void (*destroy)(eio_req *req); /* called when request no longer needed */\n   void (*feed)(eio_req *req);    /* only used for group requests */\n \n   EIO_REQ_MEMBERS\n@@ -223,10 +248,9 @@ struct eio_req\n \n /* _private_ request flags */\n enum {\n-  EIO_FLAG_CANCELLED = 0x01, /* request was cancelled */\n-  EIO_FLAG_PTR1_FREE = 0x02, /* need to free(ptr1) */\n-  EIO_FLAG_PTR2_FREE = 0x04, /* need to free(ptr2) */\n-  EIO_FLAG_GROUPADD  = 0x08  /* some request was added to the group */\n+  EIO_FLAG_PTR1_FREE = 0x01, /* need to free(ptr1) */\n+  EIO_FLAG_PTR2_FREE = 0x02, /* need to free(ptr2) */\n+  EIO_FLAG_GROUPADD  = 0x04  /* some request was added to the group */\n };\n \n /* undocumented/unsupported/private helper */\n@@ -254,26 +278,29 @@ void eio_set_max_poll_reqs (unsigned int nreqs);\n void eio_set_min_parallel (unsigned int nthreads);\n void eio_set_max_parallel (unsigned int nthreads);\n void eio_set_max_idle     (unsigned int nthreads);\n+void eio_set_idle_timeout (unsigned int seconds);\n \n unsigned int eio_nreqs    (void); /* number of requests in-flight */\n unsigned int eio_nready   (void); /* number of not-yet handled requests */\n-unsigned int eio_npending (void); /* numbe rof finished but unhandled requests */\n+unsigned int eio_npending (void); /* number of finished but unhandled requests */\n unsigned int eio_nthreads (void); /* number of worker threads in use currently */\n \n /*****************************************************************************/\n-/* convinience wrappers */\n+/* convenience wrappers */\n \n #ifndef EIO_NO_WRAPPERS\n eio_req *eio_nop       (int pri, eio_cb cb, void *data); /* does nothing except go through the whole process */\n eio_req *eio_busy      (eio_tstamp delay, int pri, eio_cb cb, void *data); /* ties a thread for this long, simulating busyness */\n eio_req *eio_sync      (int pri, eio_cb cb, void *data);\n eio_req *eio_fsync     (int fd, int pri, eio_cb cb, void *data);\n eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data);\n+eio_req *eio_syncfs    (int fd, int pri, eio_cb cb, void *data);\n eio_req *eio_msync     (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n eio_req *eio_mtouch    (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n eio_req *eio_mlock     (void *addr, size_t length, int pri, eio_cb cb, void *data);\n eio_req *eio_mlockall  (int flags, int pri, eio_cb cb, void *data);\n eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data);\n+eio_req *eio_fallocate (int fd, int mode, off_t offset, size_t len, int pri, eio_cb cb, void *data);\n eio_req *eio_close     (int fd, int pri, eio_cb cb, void *data);\n eio_req *eio_readahead (int fd, off_t offset, size_t length, int pri, eio_cb cb, void *data);\n eio_req *eio_read      (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data);\n@@ -282,28 +309,29 @@ eio_req *eio_fstat     (int fd, int pri, eio_cb cb, void *data); /* stat buffer=\n eio_req *eio_fstatvfs  (int fd, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n eio_req *eio_futime    (int fd, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n eio_req *eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_fchmod    (int fd, mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_fchown    (int fd, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data);\n+eio_req *eio_fchmod    (int fd, eio_mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_fchown    (int fd, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data);\n eio_req *eio_dup2      (int fd, int fd2, int pri, eio_cb cb, void *data);\n eio_req *eio_sendfile  (int out_fd, int in_fd, off_t in_offset, size_t length, int pri, eio_cb cb, void *data);\n-eio_req *eio_open      (const char *path, int flags, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_open      (const char *path, int flags, eio_mode_t mode, int pri, eio_cb cb, void *data);\n eio_req *eio_utime     (const char *path, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n eio_req *eio_truncate  (const char *path, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_chown     (const char *path, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data);\n-eio_req *eio_chmod     (const char *path, mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_mkdir     (const char *path, mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_chown     (const char *path, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data);\n+eio_req *eio_chmod     (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data);\n+eio_req *eio_mkdir     (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data);\n eio_req *eio_readdir   (const char *path, int flags, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n eio_req *eio_rmdir     (const char *path, int pri, eio_cb cb, void *data);\n eio_req *eio_unlink    (const char *path, int pri, eio_cb cb, void *data);\n eio_req *eio_readlink  (const char *path, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n+eio_req *eio_realpath  (const char *path, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n eio_req *eio_stat      (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n eio_req *eio_lstat     (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n eio_req *eio_statvfs   (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_mknod     (const char *path, mode_t mode, dev_t dev, int pri, eio_cb cb, void *data);\n+eio_req *eio_mknod     (const char *path, eio_mode_t mode, dev_t dev, int pri, eio_cb cb, void *data);\n eio_req *eio_link      (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n eio_req *eio_symlink   (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n eio_req *eio_rename    (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n-eio_req *eio_custom    (eio_cb execute, int pri, eio_cb cb, void *data);\n+eio_req *eio_custom    (void (*execute)(eio_req *), int pri, eio_cb cb, void *data);\n #endif\n \n /*****************************************************************************/\n@@ -319,7 +347,7 @@ void eio_grp_cancel    (eio_req *grp); /* cancels all sub requests but not the g\n /* request api */\n \n /* true if the request was cancelled, useful in the invoke callback */\n-#define EIO_CANCELLED(req)   ((req)->flags & EIO_FLAG_CANCELLED)\n+#define EIO_CANCELLED(req)   ((req)->cancelled)\n \n #define EIO_RESULT(req)      ((req)->result)\n /* returns a pointer to the result buffer allocated by eio */\n@@ -332,21 +360,13 @@ void eio_grp_cancel    (eio_req *grp); /* cancels all sub requests but not the g\n void eio_submit (eio_req *req);\n /* cancel a request as soon fast as possible, if possible */\n void eio_cancel (eio_req *req);\n-/* destroy a request that has never been submitted */\n-void eio_destroy (eio_req *req);\n \n /*****************************************************************************/\n-/* convinience functions */\n-\n-ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count);\n+/* convenience functions */\n \n-/*****************************************************************************/\n-/* export these so node_file can use these function instead of pread/write */\n-\n-#if !HAVE_PREADWRITE\n-ssize_t eio__pread (int fd, void *buf, size_t count, off_t offset);\n-ssize_t eio__pwrite (int fd, void *buf, size_t count, off_t offset);\n-#endif\n+eio_ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count);\n+eio_ssize_t eio__pread        (int fd, void *buf, size_t count, off_t offset);\n+eio_ssize_t eio__pwrite       (int fd, void *buf, size_t count, off_t offset);\n \n #ifdef __cplusplus\n }", "previous_filename": "src/rt/libuv/include/eio.h"}, {"sha": "1db1e2664935c1686f1aab288956de9a0ad9b87b", "filename": "src/rt/libuv/include/uv-private/ev.h", "status": "renamed", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -48,6 +48,12 @@\n \n EV_CPP(extern \"C\" {)\n \n+#ifdef __GNUC__\n+# define EV_MAYBE_UNUSED __attribute__ ((unused))\n+#else\n+# define EV_MAYBE_UNUSED\n+#endif\n+\n /*****************************************************************************/\n \n /* pre-4.0 compatibility */\n@@ -539,15 +545,15 @@ void ev_set_syserr_cb (void (*cb)(const char *msg));\n struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0));\n \n EV_INLINE struct ev_loop *\n-ev_default_loop_uc_ (void)\n+EV_MAYBE_UNUSED ev_default_loop_uc_ (void)\n {\n   extern struct ev_loop *ev_default_loop_ptr;\n \n   return ev_default_loop_ptr;\n }\n \n EV_INLINE int\n-ev_is_default_loop (EV_P)\n+EV_MAYBE_UNUSED ev_is_default_loop (EV_P)\n {\n   return EV_A == EV_DEFAULT_UC;\n }\n@@ -807,14 +813,14 @@ void ev_async_send     (EV_P_ ev_async *w);\n   #define EVUNLOOP_ONE    EVBREAK_ONE\n   #define EVUNLOOP_ALL    EVBREAK_ALL\n   #if EV_PROTOTYPES\n-    EV_INLINE void ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }\n-    EV_INLINE void ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }\n-    EV_INLINE void ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }\n-    EV_INLINE void ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }\n+    EV_INLINE void EV_MAYBE_UNUSED ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }\n+    EV_INLINE void EV_MAYBE_UNUSED ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }\n+    EV_INLINE void EV_MAYBE_UNUSED ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }\n+    EV_INLINE void EV_MAYBE_UNUSED ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }\n     #if EV_FEATURE_API\n-      EV_INLINE unsigned int ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }\n-      EV_INLINE unsigned int ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }\n-      EV_INLINE void         ev_loop_verify (EV_P) {        ev_verify     (EV_A); }\n+      EV_INLINE unsigned int EV_MAYBE_UNUSED ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }\n+      EV_INLINE unsigned int EV_MAYBE_UNUSED ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }\n+      EV_INLINE void         EV_MAYBE_UNUSED ev_loop_verify (EV_P) {        ev_verify     (EV_A); }\n     #endif\n   #endif\n #else", "previous_filename": "src/rt/libuv/include/ev.h"}, {"sha": "f8576d67dc24f44fa6d1cf5c112ad15160457d7e", "filename": "src/rt/libuv/include/uv-private/ngx-queue.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/include/ngx-queue.h"}, {"sha": "37966d353c3de68aefa5dba3e773dc8513d0c9d7", "filename": "src/rt/libuv/include/uv-private/tree.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/include/tree.h"}, {"sha": "7f7b05932d9ec54d8f0b2c29b836c2d0a4b1f5b7", "filename": "src/rt/libuv/include/uv-private/uv-linux.h", "status": "renamed", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-linux.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -1,4 +1,5 @@\n /* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to\n  * deal in the Software without restriction, including without limitation the\n@@ -18,32 +19,11 @@\n  * IN THE SOFTWARE.\n  */\n \n-#include \"uv.h\"\n-\n-\n-int uv_exepath(char* buffer, size_t* size) {\n-  uint32_t usize;\n-  int result;\n-  char* path;\n-  char* fullpath;\n-\n-  if (!buffer || !size) {\n-    return -1;\n-  }\n-\n-  int mib[4];\n-\n-  mib[0] = CTL_KERN;\n-  mib[1] = KERN_PROC;\n-  mib[2] = KERN_PROC_PATHNAME;\n-  mib[3] = -1;\n+#ifndef UV_LINUX_H\n+#define UV_LINUX_H\n \n-  size_t cb = *size;\n-  if (sysctl(mib, 4, buffer, &cb, NULL, 0) < 0) {\n-\t  *size = 0;\n-\t  return -1;\n-  }\n-  *size = strlen(buffer);\n+#define UV_FS_EVENT_PRIVATE_FIELDS \\\n+  ev_io read_watcher; \\\n+  uv_fs_event_cb cb; \\\n \n-  return 0;\n-}\n+#endif /* UV_LINUX_H */", "previous_filename": "src/rt/libuv/src/uv-freebsd.c"}, {"sha": "5fa132872dc9d1a90f79956eef8613ce83516bd0", "filename": "src/rt/libuv/include/uv-private/uv-unix.h", "status": "renamed", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -25,6 +25,11 @@\n #include \"ngx-queue.h\"\n \n #include \"ev.h\"\n+#include \"eio.h\"\n+\n+#if defined(__linux__)\n+#include \"uv-private/uv-linux.h\"\n+#endif\n \n #include <sys/types.h>\n #include <sys/socket.h>\n@@ -39,16 +44,52 @@ typedef struct {\n   size_t len;\n } uv_buf_t;\n \n-#define UV_REQ_BUFSML_SIZE (4)\n+typedef int uv_file;\n \n-#define UV_REQ_PRIVATE_FIELDS \\\n-  int write_index; \\\n+/* Stub. Remove it once all platforms support the file watcher API. */\n+#ifndef UV_FS_EVENT_PRIVATE_FIELDS\n+#define UV_FS_EVENT_PRIVATE_FIELDS /* empty */\n+#endif\n+\n+#define UV_LOOP_PRIVATE_FIELDS \\\n+  ares_channel channel; \\\n+  /* \\\n+   * While the channel is active this timer is called once per second to be \\\n+   * sure that we're always calling ares_process. See the warning above the \\\n+   * definition of ares_timeout(). \\\n+   */ \\\n   ev_timer timer; \\\n+  struct ev_loop* ev;\n+\n+#define UV_REQ_BUFSML_SIZE (4)\n+\n+#define UV_REQ_PRIVATE_FIELDS  /* empty */\n+\n+#define UV_WRITE_PRIVATE_FIELDS \\\n   ngx_queue_t queue; \\\n+  int write_index; \\\n   uv_buf_t* bufs; \\\n   int bufcnt; \\\n+  int error; \\\n   uv_buf_t bufsml[UV_REQ_BUFSML_SIZE];\n \n+#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */\n+\n+#define UV_CONNECT_PRIVATE_FIELDS \\\n+  ngx_queue_t queue;\n+\n+#define UV_UDP_SEND_PRIVATE_FIELDS  \\\n+  ngx_queue_t queue;                \\\n+  struct sockaddr_storage addr;     \\\n+  socklen_t addrlen;                \\\n+  uv_buf_t* bufs;                   \\\n+  int bufcnt;                       \\\n+  ssize_t status;                   \\\n+  uv_udp_send_cb send_cb;           \\\n+  uv_buf_t bufsml[UV_REQ_BUFSML_SIZE];  \\\n+\n+#define UV_PRIVATE_REQ_TYPES /* empty */\n+\n \n /* TODO: union or classes please! */\n #define UV_HANDLE_PRIVATE_FIELDS \\\n@@ -59,20 +100,35 @@ typedef struct {\n \n #define UV_STREAM_PRIVATE_FIELDS \\\n   uv_read_cb read_cb; \\\n-  uv_alloc_cb alloc_cb;\n-\n-\n-/* UV_TCP */\n-#define UV_TCP_PRIVATE_FIELDS \\\n-  int delayed_error; \\\n-  uv_connection_cb connection_cb; \\\n-  int accepted_fd; \\\n-  uv_req_t *connect_req; \\\n-  uv_req_t *shutdown_req; \\\n+  uv_alloc_cb alloc_cb; \\\n+  uv_connect_t *connect_req; \\\n+  uv_shutdown_t *shutdown_req; \\\n   ev_io read_watcher; \\\n   ev_io write_watcher; \\\n   ngx_queue_t write_queue; \\\n-  ngx_queue_t write_completed_queue;\n+  ngx_queue_t write_completed_queue; \\\n+  int delayed_error; \\\n+  uv_connection_cb connection_cb; \\\n+  int accepted_fd;\n+\n+\n+/* UV_TCP */\n+#define UV_TCP_PRIVATE_FIELDS\n+\n+\n+/* UV_UDP */\n+#define UV_UDP_PRIVATE_FIELDS         \\\n+  uv_alloc_cb alloc_cb;               \\\n+  uv_udp_recv_cb recv_cb;             \\\n+  ev_io read_watcher;                 \\\n+  ev_io write_watcher;                \\\n+  ngx_queue_t write_queue;            \\\n+  ngx_queue_t write_completed_queue;  \\\n+\n+\n+/* UV_NAMED_PIPE */\n+#define UV_PIPE_PRIVATE_FIELDS \\\n+  const char* pipe_fname; /* strdup'ed */\n \n \n /* UV_PREPARE */ \\\n@@ -117,4 +173,16 @@ typedef struct {\n   struct addrinfo* res; \\\n   int retcode;\n \n+#define UV_PROCESS_PRIVATE_FIELDS \\\n+  ev_child child_watcher;\n+\n+#define UV_FS_PRIVATE_FIELDS \\\n+  struct stat statbuf; \\\n+  eio_req* eio;\n+\n+#define UV_WORK_PRIVATE_FIELDS \\\n+  eio_req* eio;\n+\n+#define UV_TTY_PRIVATE_FIELDS /* empty */\n+\n #endif /* UV_UNIX_H */", "previous_filename": "src/rt/libuv/include/uv-unix.h"}, {"sha": "f203d6728916fe583941ba95a4970dbc1b103123", "filename": "src/rt/libuv/include/uv-private/uv-win.h", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,281 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef _WIN32_WINNT\n+# define _WIN32_WINNT   0x0502\n+#endif\n+\n+#include <stdint.h>\n+#include <winsock2.h>\n+#include <mswsock.h>\n+#include <ws2tcpip.h>\n+#include <windows.h>\n+#include <sys/stat.h>\n+\n+#include \"tree.h\"\n+\n+#define MAX_PIPENAME_LEN 256\n+\n+/**\n+ * It should be possible to cast uv_buf_t[] to WSABUF[]\n+ * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n+ */\n+typedef struct uv_buf_t {\n+  ULONG len;\n+  char* base;\n+} uv_buf_t;\n+\n+typedef int uv_file;\n+\n+RB_HEAD(uv_timer_tree_s, uv_timer_s);\n+\n+#define UV_LOOP_PRIVATE_FIELDS                                                \\\n+    /* The loop's I/O completion port */                                      \\\n+  HANDLE iocp;                                                                \\\n+  /* Reference count that keeps the event loop alive */                       \\\n+  int refs;                                                                   \\\n+  /* The current time according to the event loop. in msecs. */               \\\n+  int64_t time;                                                               \\\n+  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \\\n+  /* is empty, tail_ is NULL. If there is only one item, */                   \\\n+  /* tail_->next_req == tail_ */                                              \\\n+  uv_req_t* pending_reqs_tail;                                                \\\n+  /* Head of a single-linked list of closed handles */                        \\\n+  uv_handle_t* endgame_handles;                                               \\\n+  /* The head of the timers tree */                                           \\\n+  struct uv_timer_tree_s timers;                                              \\\n+    /* Lists of active loop (prepare / check / idle) watchers */              \\\n+  uv_prepare_t* prepare_handles;                                              \\\n+  uv_check_t* check_handles;                                                  \\\n+  uv_idle_t* idle_handles;                                                    \\\n+  /* This pointer will refer to the prepare/check/idle handle whose */        \\\n+  /* callback is scheduled to be called next. This is needed to allow */      \\\n+  /* safe removal from one of the lists above while that list being */        \\\n+  /* iterated over. */                                                        \\\n+  uv_prepare_t* next_prepare_handle;                                          \\\n+  uv_check_t* next_check_handle;                                              \\\n+  uv_idle_t* next_idle_handle;                                                \\\n+  ares_channel ares_chan;                                                     \\\n+  int ares_active_sockets;                                                    \\\n+  uv_timer_t ares_polling_timer;                                              \\\n+  /* Last error code */                                                       \\\n+  uv_err_t last_error;\n+\n+#define UV_REQ_TYPE_PRIVATE               \\\n+  /* TODO: remove the req suffix */       \\\n+  UV_ARES_EVENT_REQ,                      \\\n+  UV_ARES_CLEANUP_REQ,                    \\\n+  UV_GETADDRINFO_REQ,                     \\\n+  UV_PROCESS_EXIT,                        \\\n+  UV_PROCESS_CLOSE,                       \\\n+  UV_UDP_RECV,                            \\\n+  UV_FS_EVENT_REQ\n+\n+#define UV_REQ_PRIVATE_FIELDS             \\\n+  union {                                 \\\n+    /* Used by I/O operations */          \\\n+    struct {                              \\\n+      OVERLAPPED overlapped;              \\\n+      size_t queued_bytes;                \\\n+    };                                    \\\n+  };                                      \\\n+  struct uv_req_s* next_req;\n+\n+#define UV_WRITE_PRIVATE_FIELDS           \\\n+  /* empty */\n+\n+#define UV_CONNECT_PRIVATE_FIELDS         \\\n+  /* empty */\n+\n+#define UV_SHUTDOWN_PRIVATE_FIELDS        \\\n+  /* empty */\n+\n+#define UV_UDP_SEND_PRIVATE_FIELDS        \\\n+  /* empty */\n+\n+#define UV_PRIVATE_REQ_TYPES              \\\n+  typedef struct uv_pipe_accept_s {       \\\n+    UV_REQ_FIELDS                         \\\n+    HANDLE pipeHandle;                    \\\n+    struct uv_pipe_accept_s* next_pending; \\\n+  } uv_pipe_accept_t;                     \\\n+  typedef struct uv_tcp_accept_s {        \\\n+    UV_REQ_FIELDS                         \\\n+    SOCKET accept_socket;                 \\\n+    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32]; \\\n+    struct uv_tcp_accept_s* next_pending; \\\n+  } uv_tcp_accept_t;\n+\n+#define uv_stream_connection_fields       \\\n+  unsigned int write_reqs_pending;        \\\n+  uv_shutdown_t* shutdown_req;\n+\n+#define uv_stream_server_fields           \\\n+  uv_connection_cb connection_cb;\n+\n+#define UV_STREAM_PRIVATE_FIELDS          \\\n+  unsigned int reqs_pending;              \\\n+  uv_alloc_cb alloc_cb;                   \\\n+  uv_read_cb read_cb;                     \\\n+  uv_req_t read_req;                      \\\n+  union {                                 \\\n+    struct { uv_stream_connection_fields };  \\\n+    struct { uv_stream_server_fields     };  \\\n+  };\n+\n+#define uv_tcp_server_fields              \\\n+  uv_tcp_accept_t* accept_reqs;           \\\n+  uv_tcp_accept_t* pending_accepts;\n+\n+#define uv_tcp_connection_fields          \\\n+  uv_buf_t read_buffer;\n+\n+#define UV_TCP_PRIVATE_FIELDS             \\\n+  SOCKET socket;                          \\\n+  uv_err_t bind_error;                    \\\n+  union {                                 \\\n+    struct { uv_tcp_server_fields };      \\\n+    struct { uv_tcp_connection_fields };  \\\n+  };\n+\n+#define UV_UDP_PRIVATE_FIELDS             \\\n+  SOCKET socket;                          \\\n+  unsigned int reqs_pending;              \\\n+  uv_req_t recv_req;                      \\\n+  uv_buf_t recv_buffer;                   \\\n+  struct sockaddr_storage recv_from;      \\\n+  int recv_from_len;                      \\\n+  uv_udp_recv_cb recv_cb;                 \\\n+  uv_alloc_cb alloc_cb;\n+\n+#define uv_pipe_server_fields             \\\n+    uv_pipe_accept_t accept_reqs[4];      \\\n+    uv_pipe_accept_t* pending_accepts;\n+\n+#define uv_pipe_connection_fields         \\\n+  uv_timer_t* eof_timer;\n+\n+#define UV_PIPE_PRIVATE_FIELDS            \\\n+  HANDLE handle;                          \\\n+  wchar_t* name;                          \\\n+  union {                                 \\\n+    struct { uv_pipe_server_fields };     \\\n+    struct { uv_pipe_connection_fields }; \\\n+  };\n+\n+#define UV_TIMER_PRIVATE_FIELDS           \\\n+  RB_ENTRY(uv_timer_s) tree_entry;        \\\n+  int64_t due;                            \\\n+  int64_t repeat;                         \\\n+  uv_timer_cb timer_cb;\n+\n+#define UV_ASYNC_PRIVATE_FIELDS           \\\n+  struct uv_req_s async_req;              \\\n+  uv_async_cb async_cb;                   \\\n+  /* char to avoid alignment issues */    \\\n+  char volatile async_sent;\n+\n+#define UV_PREPARE_PRIVATE_FIELDS         \\\n+  uv_prepare_t* prepare_prev;             \\\n+  uv_prepare_t* prepare_next;             \\\n+  uv_prepare_cb prepare_cb;\n+\n+#define UV_CHECK_PRIVATE_FIELDS           \\\n+  uv_check_t* check_prev;                 \\\n+  uv_check_t* check_next;                 \\\n+  uv_check_cb check_cb;\n+\n+#define UV_IDLE_PRIVATE_FIELDS            \\\n+  uv_idle_t* idle_prev;                   \\\n+  uv_idle_t* idle_next;                   \\\n+  uv_idle_cb idle_cb;\n+\n+#define UV_HANDLE_PRIVATE_FIELDS          \\\n+  uv_handle_t* endgame_next;              \\\n+  unsigned int flags;\n+\n+#define UV_ARES_TASK_PRIVATE_FIELDS       \\\n+  struct uv_req_s ares_req;               \\\n+  SOCKET sock;                            \\\n+  HANDLE h_wait;                          \\\n+  WSAEVENT h_event;                       \\\n+  HANDLE h_close_event;\n+\n+#define UV_GETADDRINFO_PRIVATE_FIELDS     \\\n+  struct uv_req_s getadddrinfo_req;       \\\n+  uv_getaddrinfo_cb getaddrinfo_cb;       \\\n+  void* alloc;                            \\\n+  wchar_t* node;                          \\\n+  wchar_t* service;                       \\\n+  struct addrinfoW* hints;                \\\n+  struct addrinfoW* res;                  \\\n+  int retcode;\n+\n+#define UV_PROCESS_PRIVATE_FIELDS         \\\n+  struct uv_process_exit_s {              \\\n+    UV_REQ_FIELDS                         \\\n+  } exit_req;                             \\\n+  struct uv_process_close_s {             \\\n+    UV_REQ_FIELDS                         \\\n+  } close_req;                            \\\n+  HANDLE child_stdio[3];                  \\\n+  int exit_signal;                        \\\n+  DWORD spawn_errno;                      \\\n+  HANDLE wait_handle;                     \\\n+  HANDLE process_handle;                  \\\n+  HANDLE close_handle;\n+\n+#define UV_FS_PRIVATE_FIELDS              \\\n+  int flags;                              \\\n+  int last_error;                         \\\n+  struct _stati64 stat;                   \\\n+  void* arg0;                             \\\n+  union {                                 \\\n+    struct {                              \\\n+      void* arg1;                         \\\n+      void* arg2;                         \\\n+      void* arg3;                         \\\n+    };                                    \\\n+    struct {                              \\\n+      ssize_t arg4;                       \\\n+      ssize_t arg5;                       \\\n+    };                                    \\\n+  };\n+\n+#define UV_WORK_PRIVATE_FIELDS            \\\n+\n+#define UV_FS_EVENT_PRIVATE_FIELDS        \\\n+  struct uv_fs_event_req_s {              \\\n+    UV_REQ_FIELDS                         \\\n+  } req;                                  \\\n+  HANDLE dir_handle;                      \\\n+  int req_pending;                        \\\n+  uv_fs_event_cb cb;                      \\\n+  wchar_t* filew;                         \\\n+  int is_path_dir;                        \\\n+  char* buffer;\n+\n+#define UV_TTY_PRIVATE_FIELDS /* empty */\n+\n+int uv_utf16_to_utf8(const wchar_t* utf16Buffer, size_t utf16Size,\n+    char* utf8Buffer, size_t utf8Size);\n+int uv_utf8_to_utf16(const char* utf8Buffer, wchar_t* utf16Buffer,\n+    size_t utf16Size);"}, {"sha": "e6254fee09ae6d477077c5c1aab865e77b6a6e58", "filename": "src/rt/libuv/include/uv-win.h", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-win.h?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,130 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#ifndef _WIN32_WINNT\n-# define _WIN32_WINNT   0x0501\n-#endif\n-\n-#include <stdint.h>\n-#include <winsock2.h>\n-#include <mswsock.h>\n-#include <ws2tcpip.h>\n-#include <windows.h>\n-\n-#include \"tree.h\"\n-\n-/**\n- * It should be possible to cast uv_buf_t[] to WSABUF[]\n- * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n- */\n-typedef struct uv_buf_t {\n-  ULONG len;\n-  char* base;\n-} uv_buf_t;\n-\n-#define UV_REQ_PRIVATE_FIELDS             \\\n-  union {                                 \\\n-    /* Used by I/O operations */          \\\n-    struct {                              \\\n-      OVERLAPPED overlapped;              \\\n-      size_t queued_bytes;                \\\n-    };                                    \\\n-  };                                      \\\n-  int flags;                              \\\n-  uv_err_t error;                         \\\n-  struct uv_req_s* next_req;\n-\n-#define UV_STREAM_PRIVATE_FIELDS          \\\n-  uv_alloc_cb alloc_cb;                   \\\n-  uv_read_cb read_cb;                     \\\n-  struct uv_req_s read_req;               \\\n-  \n-#define uv_tcp_connection_fields          \\\n-  unsigned int write_reqs_pending;        \\\n-  uv_req_t* shutdown_req;\n-\n-#define uv_tcp_server_fields              \\\n-  uv_connection_cb connection_cb;         \\\n-  SOCKET accept_socket;                   \\\n-  struct uv_req_s accept_req;             \\\n-  char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];\n-\n-#define UV_TCP_PRIVATE_FIELDS             \\\n-  unsigned int reqs_pending;              \\\n-  union {                                 \\\n-    SOCKET socket;                        \\\n-    HANDLE handle;                        \\\n-  };                                      \\\n-  union {                                 \\\n-    struct { uv_tcp_connection_fields };  \\\n-    struct { uv_tcp_server_fields     };  \\\n-  };\n-\n-#define UV_TIMER_PRIVATE_FIELDS           \\\n-  RB_ENTRY(uv_timer_s) tree_entry;        \\\n-  int64_t due;                            \\\n-  int64_t repeat;                         \\\n-  uv_timer_cb timer_cb;\n-\n-#define UV_ASYNC_PRIVATE_FIELDS           \\\n-  struct uv_req_s async_req;              \\\n-  /* char to avoid alignment issues */    \\\n-  char volatile async_sent;\n-\n-#define UV_PREPARE_PRIVATE_FIELDS         \\\n-  uv_prepare_t* prepare_prev;             \\\n-  uv_prepare_t* prepare_next;             \\\n-  uv_prepare_cb prepare_cb;\n-\n-#define UV_CHECK_PRIVATE_FIELDS           \\\n-  uv_check_t* check_prev;                 \\\n-  uv_check_t* check_next;                 \\\n-  uv_check_cb check_cb;\n-\n-#define UV_IDLE_PRIVATE_FIELDS            \\\n-  uv_idle_t* idle_prev;                   \\\n-  uv_idle_t* idle_next;                   \\\n-  uv_idle_cb idle_cb;\n-\n-#define UV_HANDLE_PRIVATE_FIELDS          \\\n-  uv_handle_t* endgame_next;              \\\n-  unsigned int flags;                     \\\n-  uv_err_t error;\n-\n-#define UV_ARES_TASK_PRIVATE_FIELDS       \\\n-  struct uv_req_s ares_req;               \\\n-  SOCKET sock;                            \\\n-  HANDLE h_wait;                          \\\n-  WSAEVENT h_event;                       \\\n-  HANDLE h_close_event;\n-\n-#define UV_GETADDRINFO_PRIVATE_FIELDS     \\\n-  struct uv_req_s getadddrinfo_req;       \\\n-  uv_getaddrinfo_cb getaddrinfo_cb;       \\\n-  void* alloc;                            \\\n-  wchar_t* node;                          \\\n-  wchar_t* service;                       \\\n-  struct addrinfoW* hints;                \\\n-  struct addrinfoW* res;                  \\\n-  int retcode;\n-\n-int uv_utf16_to_utf8(wchar_t* utf16Buffer, size_t utf16Size, char* utf8Buffer, size_t utf8Size);\n-int uv_utf8_to_utf16(const char* utf8Buffer, wchar_t* utf16Buffer, size_t utf16Size);"}, {"sha": "b8bdc0930225888faedd7e962acc615bc9d7c25f", "filename": "src/rt/libuv/include/uv.h", "status": "modified", "additions": 738, "deletions": 93, "changes": 831, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -19,6 +19,8 @@\n  * IN THE SOFTWARE.\n  */\n \n+/* See uv_loop_new for an introduction. */\n+\n #ifndef UV_H\n #define UV_H\n #ifdef __cplusplus\n@@ -39,48 +41,112 @@ extern \"C\" {\n typedef intptr_t ssize_t;\n #endif\n \n+typedef struct uv_loop_s uv_loop_t;\n+typedef struct uv_ares_task_s uv_ares_task_t;\n typedef struct uv_err_s uv_err_t;\n typedef struct uv_handle_s uv_handle_t;\n typedef struct uv_stream_s uv_stream_t;\n typedef struct uv_tcp_s uv_tcp_t;\n+typedef struct uv_udp_s uv_udp_t;\n+typedef struct uv_pipe_s uv_pipe_t;\n+typedef struct uv_tty_s uv_tty_t;\n typedef struct uv_timer_s uv_timer_t;\n typedef struct uv_prepare_s uv_prepare_t;\n typedef struct uv_check_s uv_check_t;\n typedef struct uv_idle_s uv_idle_t;\n-typedef struct uv_req_s uv_req_t;\n typedef struct uv_async_s uv_async_t;\n typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\n-\n+typedef struct uv_process_s uv_process_t;\n+typedef struct uv_counters_s uv_counters_t;\n+/* Request types */\n+typedef struct uv_req_s uv_req_t;\n+typedef struct uv_shutdown_s uv_shutdown_t;\n+typedef struct uv_write_s uv_write_t;\n+typedef struct uv_connect_s uv_connect_t;\n+typedef struct uv_udp_send_s uv_udp_send_t;\n+typedef struct uv_fs_s uv_fs_t;\n+/* uv_fs_event_t is a subclass of uv_handle_t. */\n+typedef struct uv_fs_event_s uv_fs_event_t;\n+typedef struct uv_work_s uv_work_t;\n \n #if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)\n-# include \"uv-unix.h\"\n+# include \"uv-private/uv-unix.h\"\n #else\n-# include \"uv-win.h\"\n+# include \"uv-private/uv-win.h\"\n #endif\n \n \n-/* The status parameter is 0 if the request completed successfully,\n+/*\n+ * This function must be called before any other functions in libuv.\n+ *\n+ * All functions besides uv_run() are non-blocking.\n+ *\n+ * All callbacks in libuv are made asynchronously. That is they are never\n+ * made by the function that takes them as a parameter.\n+ */\n+uv_loop_t* uv_loop_new();\n+void uv_loop_delete(uv_loop_t*);\n+\n+\n+/*\n+ * Returns the default loop.\n+ */\n+uv_loop_t* uv_default_loop();\n+\n+/*\n+ * This function starts the event loop. It blocks until the reference count\n+ * of the loop drops to zero.\n+ */\n+int uv_run(uv_loop_t*);\n+\n+/*\n+ * Manually modify the event loop's reference count. Useful if the user wants\n+ * to have a handle or timeout that doesn't keep the loop alive.\n+ */\n+void uv_ref(uv_loop_t*);\n+void uv_unref(uv_loop_t*);\n+\n+void uv_update_time(uv_loop_t*);\n+int64_t uv_now(uv_loop_t*);\n+\n+\n+/*\n+ * The status parameter is 0 if the request completed successfully,\n  * and should be -1 if the request was cancelled or failed.\n  * For uv_close_cb, -1 means that the handle was closed due to an error.\n  * Error details can be obtained by calling uv_last_error().\n  *\n  * In the case of uv_read_cb the uv_buf_t returned should be freed by the\n  * user.\n  */\n-typedef uv_buf_t (*uv_alloc_cb)(uv_stream_t* tcp, size_t suggested_size);\n-typedef void (*uv_read_cb)(uv_stream_t* tcp, ssize_t nread, uv_buf_t buf);\n-typedef void (*uv_write_cb)(uv_req_t* req, int status);\n-typedef void (*uv_connect_cb)(uv_req_t* req, int status);\n-typedef void (*uv_shutdown_cb)(uv_req_t* req, int status);\n-typedef void (*uv_connection_cb)(uv_handle_t* server, int status);\n+typedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);\n+typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n+typedef void (*uv_write_cb)(uv_write_t* req, int status);\n+typedef void (*uv_connect_cb)(uv_connect_t* req, int status);\n+typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\n+typedef void (*uv_connection_cb)(uv_stream_t* server, int status);\n typedef void (*uv_close_cb)(uv_handle_t* handle);\n typedef void (*uv_timer_cb)(uv_timer_t* handle, int status);\n /* TODO: do these really need a status argument? */\n typedef void (*uv_async_cb)(uv_async_t* handle, int status);\n typedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);\n typedef void (*uv_check_cb)(uv_check_t* handle, int status);\n typedef void (*uv_idle_cb)(uv_idle_t* handle, int status);\n-typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status, struct addrinfo* res);\n+typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status,\n+    struct addrinfo* res);\n+typedef void (*uv_exit_cb)(uv_process_t*, int exit_status, int term_signal);\n+typedef void (*uv_fs_cb)(uv_fs_t* req);\n+typedef void (*uv_work_cb)(uv_work_t* req);\n+typedef void (*uv_after_work_cb)(uv_work_t* req);\n+\n+/*\n+* This will be called repeatedly after the uv_fs_event_t is initialized.\n+* If uv_fs_event_t was initialized with a directory the filename parameter\n+* will be a relative path to a file contained in the directory.\n+* The events paramenter is an ORed mask of enum uv_fs_event elements.\n+*/\n+typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,\n+    int events, int status);\n \n \n /* Expand this list if necessary. */\n@@ -106,6 +172,7 @@ typedef enum {\n   UV_EINVAL,\n   UV_EISCONN,\n   UV_EMFILE,\n+  UV_EMSGSIZE,\n   UV_ENETDOWN,\n   UV_ENETUNREACH,\n   UV_ENFILE,\n@@ -116,6 +183,8 @@ typedef enum {\n   UV_ENOTCONN,\n   UV_ENOTSOCK,\n   UV_ENOTSUP,\n+  UV_ENOENT,\n+  UV_EPIPE,\n   UV_EPROTO,\n   UV_EPROTONOSUPPORT,\n   UV_EPROTOTYPE,\n@@ -124,12 +193,15 @@ typedef enum {\n   UV_EAIFAMNOSUPPORT,\n   UV_EAINONAME,\n   UV_EAISERVICE,\n-  UV_EAISOCKTYPE\n+  UV_EAISOCKTYPE,\n+  UV_ESHUTDOWN,\n+  UV_EEXIST\n } uv_err_code;\n \n typedef enum {\n   UV_UNKNOWN_HANDLE = 0,\n   UV_TCP,\n+  UV_UDP,\n   UV_NAMED_PIPE,\n   UV_TTY,\n   UV_FILE,\n@@ -138,9 +210,10 @@ typedef enum {\n   UV_CHECK,\n   UV_IDLE,\n   UV_ASYNC,\n-  UV_ARES,\n   UV_ARES_TASK,\n-  UV_GETADDRINFO\n+  UV_ARES_EVENT,\n+  UV_PROCESS,\n+  UV_FS_EVENT\n } uv_handle_type;\n \n typedef enum {\n@@ -150,7 +223,12 @@ typedef enum {\n   UV_READ,\n   UV_WRITE,\n   UV_SHUTDOWN,\n-  UV_WAKEUP\n+  UV_WAKEUP,\n+  UV_UDP_SEND,\n+  UV_FS,\n+  UV_WORK,\n+  UV_GETADDRINFO,\n+  UV_REQ_TYPE_PRIVATE\n } uv_req_type;\n \n \n@@ -162,27 +240,55 @@ struct uv_err_s {\n };\n \n \n-struct uv_req_s {\n-  /* read-only */\n-  uv_req_type type;\n-  /* public */\n-  uv_handle_t* handle;\n-  void *(*cb)(void *);\n-  void* data;\n-  /* private */\n+/*\n+ * Most functions return boolean: 0 for success and -1 for failure.\n+ * On error the user should then call uv_last_error() to determine\n+ * the error code.\n+ */\n+uv_err_t uv_last_error(uv_loop_t*);\n+char* uv_strerror(uv_err_t err);\n+const char* uv_err_name(uv_err_t err);\n+\n+\n+#define UV_REQ_FIELDS \\\n+  /* read-only */ \\\n+  uv_req_type type; \\\n+  /* public */ \\\n+  void* data; \\\n+  /* private */ \\\n   UV_REQ_PRIVATE_FIELDS\n+\n+/* Abstract base class of all requests. */\n+struct uv_req_s {\n+  UV_REQ_FIELDS\n };\n \n+\n+/* Platform-specific request types */\n+UV_PRIVATE_REQ_TYPES\n+\n+\n /*\n- * Initialize a request for use with uv_write, uv_shutdown, or uv_connect.\n+ * uv_shutdown_t is a subclass of uv_req_t\n+ *\n+ * Shutdown the outgoing (write) side of a duplex stream. It waits for\n+ * pending write requests to complete. The handle should refer to a\n+ * initialized stream. req should be an uninitalized shutdown request\n+ * struct. The cb is a called after shutdown is complete.\n  */\n-void uv_req_init(uv_req_t* req, uv_handle_t* handle, void *(*cb)(void *));\n+int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb);\n \n-int uv_shutdown(uv_req_t* req);\n+struct uv_shutdown_s {\n+  UV_REQ_FIELDS\n+  uv_stream_t* handle;\n+  uv_shutdown_cb cb;\n+  UV_SHUTDOWN_PRIVATE_FIELDS\n+};\n \n \n #define UV_HANDLE_FIELDS \\\n   /* read-only */ \\\n+  uv_loop_t* loop; \\\n   uv_handle_type type; \\\n   /* public */ \\\n   uv_close_cb close_cb; \\\n@@ -204,8 +310,21 @@ int uv_is_active(uv_handle_t* handle);\n /*\n  * Request handle to be closed. close_cb will be called asynchronously after\n  * this call. This MUST be called on each handle before memory is released.\n+ *\n+ * Note that handles that wrap file descriptors are closed immediately but\n+ * close_cb will still be deferred to the next iteration of the event loop.\n+ * It gives you a chance to free up any resources associated with the handle.\n  */\n-int uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n+void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n+\n+\n+/*\n+ * Constructor for uv_buf_t.\n+ * Due to platform differences the user cannot rely on the ordering of the\n+ * base and len members of the uv_buf_t struct. The user is responsible for\n+ * freeing base after the uv_buf_t is done. Return struct passed by value.\n+ */\n+uv_buf_t uv_buf_init(char* base, size_t len);\n \n \n #define UV_STREAM_FIELDS \\\n@@ -214,13 +333,23 @@ int uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n   /* private */ \\\n   UV_STREAM_PRIVATE_FIELDS\n \n-/* The abstract base class for all streams. */\n+/*\n+ * uv_stream_t is a subclass of uv_handle_t\n+ *\n+ * uv_stream is an abstract class.\n+ *\n+ * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+ * and soon uv_file_t.\n+ */\n struct uv_stream_s {\n   UV_HANDLE_FIELDS\n   UV_STREAM_FIELDS\n };\n \n-/* This call is used in conjunction with uv_listen() to accept incoming\n+int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n+\n+/*\n+ * This call is used in conjunction with uv_listen() to accept incoming\n  * connections. Call uv_accept after receiving a uv_connection_cb to accept\n  * the connection. Before calling uv_accept use uv_*_init() must be\n  * called on the client. Non-zero return value indicates an error.\n@@ -230,9 +359,10 @@ struct uv_stream_s {\n  * once, it may fail. It is suggested to only call uv_accept once per\n  * uv_connection_cb call.\n  */\n-int uv_accept(uv_handle_t* server, uv_stream_t* client);\n+int uv_accept(uv_stream_t* server, uv_stream_t* client);\n \n-/* Read data from an incoming stream. The callback will be made several\n+/*\n+ * Read data from an incoming stream. The callback will be made several\n  * several times until there is no more data to read or uv_read_stop is\n  * called. When we've reached EOF nread will be set to -1 and the error is\n  * set to UV_EOF. When nread == -1 the buf parameter might not point to a\n@@ -245,7 +375,16 @@ int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read_cb read_cb);\n \n int uv_read_stop(uv_stream_t*);\n \n-/* Write data to stream. Buffers are written in order. Example:\n+typedef enum {\n+  UV_STDIN = 0,\n+  UV_STDOUT,\n+  UV_STDERR\n+} uv_std_type;\n+\n+uv_stream_t* uv_std_handle(uv_loop_t*, uv_std_type type);\n+\n+/*\n+ * Write data to stream. Buffers are written in order. Example:\n  *\n  *   uv_buf_t a[] = {\n  *     { .base = \"1\", .len = 1 },\n@@ -258,89 +397,327 @@ int uv_read_stop(uv_stream_t*);\n  *   };\n  *\n  *   // writes \"1234\"\n- *   uv_write(req, a, 2);\n- *   uv_write(req, b, 2);\n+ *   uv_write(req, stream, a, 2);\n+ *   uv_write(req, stream, b, 2);\n  *\n  */\n-int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt);\n+int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n+    uv_write_cb cb);\n+\n+/* uv_write_t is a subclass of uv_req_t */\n+struct uv_write_s {\n+  UV_REQ_FIELDS\n+  uv_write_cb cb;\n+  uv_stream_t* handle;\n+  UV_WRITE_PRIVATE_FIELDS\n+};\n+\n \n \n /*\n- * A subclass of uv_stream_t representing a TCP stream or TCP server. In the\n- * future this will probably be split into two classes - one a stream and\n- * the other a server.\n+ * uv_tcp_t is a subclass of uv_stream_t\n+ *\n+ * Represents a TCP stream or TCP server.\n  */\n struct uv_tcp_s {\n   UV_HANDLE_FIELDS\n   UV_STREAM_FIELDS\n   UV_TCP_PRIVATE_FIELDS\n };\n \n-int uv_tcp_init(uv_tcp_t* handle);\n+int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n \n int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n+int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name, int* namelen);\n+int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name, int* namelen);\n+\n+/*\n+ * uv_tcp_connect, uv_tcp_connect6\n+ * These functions establish IPv4 and IPv6 TCP connections. Provide an\n+ * initialized TCP handle and an uninitialized uv_connect_t*. The callback\n+ * will be made when the connection is estabished.\n+ */\n+int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n+    struct sockaddr_in address, uv_connect_cb cb);\n+int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n+    struct sockaddr_in6 address, uv_connect_cb cb);\n+\n+/* uv_connect_t is a subclass of uv_req_t */\n+struct uv_connect_s {\n+  UV_REQ_FIELDS\n+  uv_connect_cb cb;\n+  uv_stream_t* handle;\n+  UV_CONNECT_PRIVATE_FIELDS\n+};\n+\n+\n+/*\n+ * UDP support.\n+ */\n+\n+enum uv_udp_flags {\n+  /* Disables dual stack mode. Used with uv_udp_bind6(). */\n+  UV_UDP_IPV6ONLY = 1,\n+  /*\n+   * Indicates message was truncated because read buffer was too small. The\n+   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n+   */\n+  UV_UDP_PARTIAL = 2\n+};\n+\n+/*\n+ * Called after a uv_udp_send() or uv_udp_send6(). status 0 indicates\n+ * success otherwise error.\n+ */\n+typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\n+\n+/*\n+ * Callback that is invoked when a new UDP datagram is received.\n+ *\n+ *  handle  UDP handle.\n+ *  nread   Number of bytes that have been received.\n+ *          0 if there is no more data to read. You may\n+ *          discard or repurpose the read buffer.\n+ *          -1 if a transmission error was detected.\n+ *  buf     uv_buf_t with the received data.\n+ *  addr    struct sockaddr_in or struct sockaddr_in6.\n+ *          Valid for the duration of the callback only.\n+ *  flags   One or more OR'ed UV_UDP_* constants.\n+ *          Right now only UV_UDP_PARTIAL is used.\n+ */\n+typedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,\n+    struct sockaddr* addr, unsigned flags);\n+\n+/* uv_udp_t is a subclass of uv_handle_t */\n+struct uv_udp_s {\n+  UV_HANDLE_FIELDS\n+  UV_UDP_PRIVATE_FIELDS\n+};\n+\n+/* uv_udp_send_t is a subclass of uv_req_t */\n+struct uv_udp_send_s {\n+  UV_REQ_FIELDS\n+  uv_udp_t* handle;\n+  uv_udp_send_cb cb;\n+  UV_UDP_SEND_PRIVATE_FIELDS\n+};\n+\n+/*\n+ * Initialize a new UDP handle. The actual socket is created lazily.\n+ * Returns 0 on success.\n+ */\n+int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n+\n+/*\n+ * Bind to a IPv4 address and port.\n+ *\n+ * Arguments:\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  addr      struct sockaddr_in with the address and port to bind to.\n+ *  flags     Unused.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags);\n+\n+/*\n+ * Bind to a IPv6 address and port.\n+ *\n+ * Arguments:\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  addr      struct sockaddr_in with the address and port to bind to.\n+ *  flags     Should be 0 or UV_UDP_IPV6ONLY.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags);\n+int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name, int* namelen);\n+\n+/*\n+ * Send data. If the socket has not previously been bound with `uv_udp_bind`\n+ * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n+ * and a random port number.\n+ *\n+ * Arguments:\n+ *  req       UDP request handle. Need not be initialized.\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  bufs      List of buffers to send.\n+ *  bufcnt    Number of buffers in `bufs`.\n+ *  addr      Address of the remote peer. See `uv_ip4_addr`.\n+ *  send_cb   Callback to invoke when the data has been sent out.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n+    int bufcnt, struct sockaddr_in addr, uv_udp_send_cb send_cb);\n+\n+/*\n+ * Send data. If the socket has not previously been bound with `uv_udp_bind6`,\n+ * it is bound to ::0 (the \"all interfaces\" address) and a random port number.\n+ *\n+ * Arguments:\n+ *  req       UDP request handle. Need not be initialized.\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  bufs      List of buffers to send.\n+ *  bufcnt    Number of buffers in `bufs`.\n+ *  addr      Address of the remote peer. See `uv_ip6_addr`.\n+ *  send_cb   Callback to invoke when the data has been sent out.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n+    int bufcnt, struct sockaddr_in6 addr, uv_udp_send_cb send_cb);\n+\n+/*\n+ * Send data. If the socket has not previously been bound with `uv_udp_bind`\n+ * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n+ * and a random port number.\n+ *\n+ * Arguments:\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  alloc_cb  Callback to invoke when temporary storage is needed.\n+ *  recv_cb   Callback to invoke with received data.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n+    uv_udp_recv_cb recv_cb);\n \n-int uv_tcp_connect(uv_req_t* req, struct sockaddr_in);\n-int uv_tcp_connect6(uv_req_t* req, struct sockaddr_in6);\n+/*\n+ * Stop listening for incoming datagrams.\n+ *\n+ * Arguments:\n+ *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_recv_stop(uv_udp_t* handle);\n+\n+\n+/*\n+ * uv_tty_t is a subclass of uv_stream_t\n+ *\n+ * Representing a stream for the console.\n+ */\n+struct uv_tty_s {\n+  UV_HANDLE_FIELDS\n+  UV_STREAM_FIELDS\n+  UV_TTY_PRIVATE_FIELDS\n+};\n+\n+int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd);\n+\n+/*\n+ * Set mode. 0 for normal, 1 for raw.\n+ */\n+int uv_tty_set_mode(uv_tty_t*, int mode);\n+\n+/*\n+ * Gets the current Window size. On success zero is returned.\n+ */\n+int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n+\n+/*\n+ * Used to detect what type of stream should be used with a given file\n+ * descriptor. Usually this will be used during initialization to guess the\n+ * type of the stdio streams.\n+ * For isatty() functionality use this function and test for UV_TTY.\n+ */\n+uv_handle_type uv_guess_handle(uv_file file);\n+\n+/*\n+ * uv_pipe_t is a subclass of uv_stream_t\n+ *\n+ * Representing a pipe stream or pipe server. On Windows this is a Named\n+ * Pipe. On Unix this is a UNIX domain socket.\n+ */\n+struct uv_pipe_s {\n+  UV_HANDLE_FIELDS\n+  UV_STREAM_FIELDS\n+  UV_PIPE_PRIVATE_FIELDS\n+};\n+\n+int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle);\n \n-int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\n+/*\n+ * Opens an existing file descriptor or HANDLE as a pipe.\n+ */\n+void uv_pipe_open(uv_pipe_t*, uv_file file);\n+\n+int uv_pipe_bind(uv_pipe_t* handle, const char* name);\n+\n+int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n+    const char* name, uv_connect_cb cb);\n \n \n /*\n- * Subclass of uv_handle_t. libev wrapper. Every active prepare handle gets\n- * its callback called exactly once per loop iteration, just before the\n- * system blocks to wait for completed i/o.\n+ * uv_prepare_t is a subclass of uv_handle_t.\n+ *\n+ * libev wrapper. Every active prepare handle gets its callback called\n+ * exactly once per loop iteration, just before the system blocks to wait\n+ * for completed i/o.\n  */\n struct uv_prepare_s {\n   UV_HANDLE_FIELDS\n   UV_PREPARE_PRIVATE_FIELDS\n };\n \n-int uv_prepare_init(uv_prepare_t* prepare);\n+int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\n \n int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n \n int uv_prepare_stop(uv_prepare_t* prepare);\n \n \n /*\n- * Subclass of uv_handle_t. libev wrapper. Every active check handle gets\n- * its callback called exactly once per loop iteration, just after the\n- * system returns from blocking.\n+ * uv_check_t is a subclass of uv_handle_t.\n+ *\n+ * libev wrapper. Every active check handle gets its callback called exactly\n+ * once per loop iteration, just after the system returns from blocking.\n  */\n struct uv_check_s {\n   UV_HANDLE_FIELDS\n   UV_CHECK_PRIVATE_FIELDS\n };\n \n-int uv_check_init(uv_check_t* check);\n+int uv_check_init(uv_loop_t*, uv_check_t* check);\n \n int uv_check_start(uv_check_t* check, uv_check_cb cb);\n \n int uv_check_stop(uv_check_t* check);\n \n \n /*\n- * Subclass of uv_handle_t. libev wrapper. Every active idle handle gets its\n- * callback called repeatedly until it is stopped. This happens after all\n- * other types of callbacks are processed.  When there are multiple \"idle\"\n- * handles active, their callbacks are called in turn.\n+ * uv_idle_t is a subclass of uv_handle_t.\n+ *\n+ * libev wrapper. Every active idle handle gets its callback called\n+ * repeatedly until it is stopped. This happens after all other types of\n+ * callbacks are processed.  When there are multiple \"idle\" handles active,\n+ * their callbacks are called in turn.\n  */\n struct uv_idle_s {\n   UV_HANDLE_FIELDS\n   UV_IDLE_PRIVATE_FIELDS\n };\n \n-int uv_idle_init(uv_idle_t* idle);\n+int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\n \n int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n \n int uv_idle_stop(uv_idle_t* idle);\n \n \n /*\n- * Subclass of uv_handle_t. libev wrapper. uv_async_send wakes up the event\n+ * uv_async_t is a subclass of uv_handle_t.\n+ *\n+ * libev wrapper. uv_async_send wakes up the event\n  * loop and calls the async handle's callback There is no guarantee that\n  * every uv_async_send call leads to exactly one invocation of the callback;\n  * The only guarantee is that the callback function is  called at least once\n@@ -352,23 +729,31 @@ struct uv_async_s {\n   UV_ASYNC_PRIVATE_FIELDS\n };\n \n-int uv_async_init(uv_async_t* async, uv_async_cb async_cb);\n+int uv_async_init(uv_loop_t*, uv_async_t* async, uv_async_cb async_cb);\n \n+/*\n+ * This can be called from other threads to wake up a libuv thread.\n+ *\n+ * libuv is single threaded at the moment.\n+ */\n int uv_async_send(uv_async_t* async);\n \n \n /*\n- * Subclass of uv_handle_t. Wraps libev's ev_timer watcher. Used to get\n- * woken up at a specified time in the future.\n+ * uv_timer_t is a subclass of uv_handle_t.\n+ *\n+ * Wraps libev's ev_timer watcher. Used to get woken up at a specified time\n+ * in the future.\n  */\n struct uv_timer_s {\n   UV_HANDLE_FIELDS\n   UV_TIMER_PRIVATE_FIELDS\n };\n \n-int uv_timer_init(uv_timer_t* timer);\n+int uv_timer_init(uv_loop_t*, uv_timer_t* timer);\n \n-int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout, int64_t repeat);\n+int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout,\n+    int64_t repeat);\n \n int uv_timer_stop(uv_timer_t* timer);\n \n@@ -391,63 +776,286 @@ int64_t uv_timer_get_repeat(uv_timer_t* timer);\n \n \n /* c-ares integration initialize and terminate */\n-int uv_ares_init_options(ares_channel *channelptr,\n-                        struct ares_options *options,\n-                        int optmask);\n+int uv_ares_init_options(uv_loop_t*,\n+                         ares_channel *channelptr,\n+                         struct ares_options *options,\n+                         int optmask);\n \n-void uv_ares_destroy(ares_channel channel);\n+/* TODO remove the loop argument from this function? */\n+void uv_ares_destroy(uv_loop_t*, ares_channel channel);\n \n \n /*\n- * Subclass of uv_handle_t. Used for integration of getaddrinfo.\n+ * uv_getaddrinfo_t is a subclass of uv_req_t\n+ *\n+ * Request object for uv_getaddrinfo.\n  */\n struct uv_getaddrinfo_s {\n-  UV_HANDLE_FIELDS\n+  UV_REQ_FIELDS\n+  /* read-only */\n+  uv_loop_t* loop; \\\n   UV_GETADDRINFO_PRIVATE_FIELDS\n };\n \n \n-/* uv_getaddrinfo\n- * return code of UV_OK means that request is accepted,\n- * and callback will be called with result.\n- * Other return codes mean that there will not be a callback.\n+/*\n+ * Asynchronous getaddrinfo(3).\n+ *\n+ * Return code 0 means that request is accepted and callback will be called\n+ * with result. Other return codes mean that there will not be a callback.\n  * Input arguments may be released after return from this call.\n- * Callback must not call freeaddrinfo\n+ *\n+ * uv_freeaddrinfo() must be called after completion to free the addrinfo\n+ * structure.\n  */\n- int uv_getaddrinfo(uv_getaddrinfo_t* handle,\n+ int uv_getaddrinfo(uv_loop_t*,\n+                    uv_getaddrinfo_t* handle,\n                     uv_getaddrinfo_cb getaddrinfo_cb,\n                     const char* node,\n                     const char* service,\n                     const struct addrinfo* hints);\n \n+void uv_freeaddrinfo(struct addrinfo* ai);\n+\n+/* uv_spawn() options */\n+typedef struct uv_process_options_s {\n+  uv_exit_cb exit_cb; /* Called after the process exits. */\n+  const char* file; /* Path to program to execute. */\n+  /*\n+   * Command line arguments. args[0] should be the path to the program. On\n+   * Windows this uses CreateProcess which concatinates the arguments into a\n+   * string this can cause some strange errors. See the note at\n+   * windows_verbatim_arguments.\n+   */\n+  char** args;\n+  /*\n+   * This will be set as the environ variable in the subprocess. If this is\n+   * NULL then the parents environ will be used.\n+   */\n+  char** env;\n+  /*\n+   * If non-null this represents a directory the subprocess should execute\n+   * in. Stands for current working directory.\n+   */\n+  char* cwd;\n+\n+  /*\n+   * TODO describe how this works.\n+   */\n+  int windows_verbatim_arguments;\n+\n+  /*\n+   * The user should supply pointers to initialized uv_pipe_t structs for\n+   * stdio. This is used to to send or receive input from the subprocess.\n+   * The user is reponsible for calling uv_close on them.\n+   */\n+  uv_pipe_t* stdin_stream;\n+  uv_pipe_t* stdout_stream;\n+  uv_pipe_t* stderr_stream;\n+} uv_process_options_t;\n \n /*\n- * Most functions return boolean: 0 for success and -1 for failure.\n- * On error the user should then call uv_last_error() to determine\n- * the error code.\n+ * uv_process_t is a subclass of uv_handle_t\n  */\n-uv_err_t uv_last_error();\n-char* uv_strerror(uv_err_t err);\n-const char* uv_err_name(uv_err_t err);\n+struct uv_process_s {\n+  UV_HANDLE_FIELDS\n+  uv_exit_cb exit_cb;\n+  int pid;\n+  UV_PROCESS_PRIVATE_FIELDS\n+};\n \n-void uv_init();\n-int uv_run();\n+/* Initializes uv_process_t and starts the process. */\n+int uv_spawn(uv_loop_t*, uv_process_t*, uv_process_options_t options);\n \n /*\n- * Manually modify the event loop's reference count. Useful if the user wants\n- * to have a handle or timeout that doesn't keep the loop alive.\n+ * Kills the process with the specified signal. The user must still\n+ * call uv_close on the process.\n  */\n-void uv_ref();\n-void uv_unref();\n+int uv_process_kill(uv_process_t*, int signum);\n \n-void uv_update_time();\n-int64_t uv_now();\n \n+/*\n+ * uv_work_t is a subclass of uv_req_t\n+ */\n+struct uv_work_s {\n+  UV_REQ_FIELDS\n+  uv_loop_t* loop;\n+  uv_work_cb work_cb;\n+  uv_after_work_cb after_work_cb;\n+  UV_WORK_PRIVATE_FIELDS\n+};\n+\n+/* Queues a work request to execute asynchronously on the thread pool. */\n+int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb,\n+    uv_after_work_cb after_work_cb);\n+\n+\n+\n+\n+/*\n+ * File System Methods.\n+ *\n+ * The uv_fs_* functions execute a blocking system call asynchronously (in a\n+ * thread pool) and call the specified callback in the specified loop after\n+ * completion. If the user gives NULL as the callback the blocking system\n+ * call will be called synchronously. req should be a pointer to an\n+ * uninitialized uv_fs_t object.\n+ *\n+ * uv_fs_req_cleanup() must be called after completion of the uv_fs_\n+ * function to free any internal memory allocations associted with the\n+ * request.\n+ */\n+\n+typedef enum {\n+  UV_FS_UNKNOWN = -1,\n+  UV_FS_CUSTOM,\n+  UV_FS_OPEN,\n+  UV_FS_CLOSE,\n+  UV_FS_READ,\n+  UV_FS_WRITE,\n+  UV_FS_SENDFILE,\n+  UV_FS_STAT,\n+  UV_FS_LSTAT,\n+  UV_FS_FSTAT,\n+  UV_FS_FTRUNCATE,\n+  UV_FS_UTIME,\n+  UV_FS_FUTIME,\n+  UV_FS_CHMOD,\n+  UV_FS_FCHMOD,\n+  UV_FS_FSYNC,\n+  UV_FS_FDATASYNC,\n+  UV_FS_UNLINK,\n+  UV_FS_RMDIR,\n+  UV_FS_MKDIR,\n+  UV_FS_RENAME,\n+  UV_FS_READDIR,\n+  UV_FS_LINK,\n+  UV_FS_SYMLINK,\n+  UV_FS_READLINK,\n+  UV_FS_CHOWN,\n+  UV_FS_FCHOWN\n+} uv_fs_type;\n+\n+/* uv_fs_t is a subclass of uv_req_t */\n+struct uv_fs_s {\n+  UV_REQ_FIELDS\n+  uv_loop_t* loop;\n+  uv_fs_type fs_type;\n+  uv_fs_cb cb;\n+  ssize_t result;\n+  void* ptr;\n+  char* path;\n+  int errorno;\n+  UV_FS_PRIVATE_FIELDS\n+};\n+\n+void uv_fs_req_cleanup(uv_fs_t* req);\n+\n+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+\n+int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+    int mode, uv_fs_cb cb);\n+\n+int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n+    size_t length, off_t offset, uv_fs_cb cb);\n+\n+int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+\n+int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n+    size_t length, off_t offset, uv_fs_cb cb);\n+\n+int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n+    uv_fs_cb cb);\n+\n+int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+\n+int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+    uv_fs_cb cb);\n+\n+int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+\n+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+\n+int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    const char* new_path, uv_fs_cb cb);\n+\n+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+\n+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+\n+int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    off_t offset, uv_fs_cb cb);\n+\n+int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n+    uv_file in_fd, off_t in_offset, size_t length, uv_fs_cb cb);\n+\n+int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n+    uv_fs_cb cb);\n+\n+int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n+    double mtime, uv_fs_cb cb);\n+\n+int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,\n+    double mtime, uv_fs_cb cb);\n+\n+int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+\n+int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    const char* new_path, uv_fs_cb cb);\n+\n+/* \n+ * This flag can be used with uv_fs_symlink on Windows\n+ * to specify whether path argument points to a directory.\n+ */\n+#define UV_FS_SYMLINK_DIR          0x0001\n+\n+int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    const char* new_path, int flags, uv_fs_cb cb);\n+\n+int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    uv_fs_cb cb);\n+\n+int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,\n+    uv_fs_cb cb);\n+\n+int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,\n+    int gid, uv_fs_cb cb);\n+\n+int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid,\n+    int gid, uv_fs_cb cb);\n+\n+\n+enum uv_fs_event {\n+  UV_RENAME = 1,\n+  UV_CHANGE = 2\n+};\n+\n+\n+struct uv_fs_event_s {\n+  UV_HANDLE_FIELDS\n+  char* filename;\n+  UV_FS_EVENT_PRIVATE_FIELDS\n+};\n+\n+\n+/*\n+* If filename is a directory then we will watch for all events in that\n+* directory. If filename is a file - we will only get events from that\n+* file. Subdirectories are not watched.\n+*/\n+int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n+    const char* filename, uv_fs_event_cb cb);\n \n /* Utility */\n+\n+/* Convert string ip addresses to binary structures */\n struct sockaddr_in uv_ip4_addr(const char* ip, int port);\n struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n \n+/* Convert binary addresses to strings */\n+int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);\n+int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n+\n /* Gets the executable path */\n int uv_exepath(char* buffer, size_t* size);\n \n@@ -463,33 +1071,67 @@ int uv_exepath(char* buffer, size_t* size);\n extern uint64_t uv_hrtime(void);\n \n \n-/* the presence of this union forces similar struct layout */\n+/* the presence of these unions force similar struct layout */\n union uv_any_handle {\n   uv_tcp_t tcp;\n+  uv_pipe_t pipe;\n   uv_prepare_t prepare;\n   uv_check_t check;\n   uv_idle_t idle;\n   uv_async_t async;\n   uv_timer_t timer;\n   uv_getaddrinfo_t getaddrinfo;\n+  uv_fs_event_t fs_event;\n };\n \n-/* Diagnostic counters */\n-typedef struct {\n+union uv_any_req {\n+  uv_req_t req;\n+  uv_write_t write;\n+  uv_connect_t connect;\n+  uv_shutdown_t shutdown;\n+  uv_fs_t fs_req;\n+  uv_work_t work_req;\n+};\n+\n+\n+struct uv_counters_s {\n+  uint64_t eio_init;\n   uint64_t req_init;\n   uint64_t handle_init;\n+  uint64_t stream_init;\n   uint64_t tcp_init;\n+  uint64_t udp_init;\n+  uint64_t pipe_init;\n+  uint64_t tty_init;\n   uint64_t prepare_init;\n   uint64_t check_init;\n   uint64_t idle_init;\n   uint64_t async_init;\n   uint64_t timer_init;\n-} uv_counters_t;\n+  uint64_t process_init;\n+  uint64_t fs_event_init;\n+};\n \n-uv_counters_t* uv_counters();\n+\n+struct uv_loop_s {\n+  UV_LOOP_PRIVATE_FIELDS\n+  /* list used for ares task handles */\n+  uv_ares_task_t* uv_ares_handles_;\n+  /* Various thing for libeio. */\n+  uv_async_t uv_eio_want_poll_notifier;\n+  uv_async_t uv_eio_done_poll_notifier;\n+  uv_idle_t uv_eio_poller;\n+  /* Diagnostic counters */\n+  uv_counters_t counters;\n+  /* The last error */\n+  uv_err_t last_err;\n+  /* User data - use this for whatever. */\n+  void* data;\n+};\n \n \n /* Don't export the private CPP symbols. */\n+#undef UV_REQ_TYPE_PRIVATE\n #undef UV_REQ_PRIVATE_FIELDS\n #undef UV_STREAM_PRIVATE_FIELDS\n #undef UV_TCP_PRIVATE_FIELDS\n@@ -499,6 +1141,9 @@ uv_counters_t* uv_counters();\n #undef UV_ASYNC_PRIVATE_FIELDS\n #undef UV_TIMER_PRIVATE_FIELDS\n #undef UV_GETADDRINFO_PRIVATE_FIELDS\n+#undef UV_FS_REQ_PRIVATE_FIELDS\n+#undef UV_WORK_PRIVATE_FIELDS\n+#undef UV_FS_EVENT_PRIVATE_FIELDS\n \n #ifdef __cplusplus\n }"}, {"sha": "4ada6ccb3df0ddb10331ea66b9e102598cd242a4", "filename": "src/rt/libuv/msvs/c-ares.vcxproj", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Fc-ares.vcxproj?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,179 +0,0 @@\n-\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n-  <ItemGroup Label=\"ProjectConfigurations\">\n-    <ProjectConfiguration Include=\"Debug|Win32\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Debug|x64\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|Win32\">\n-      <Configuration>Release</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|x64\">\n-      <Configuration>Release</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-  </ItemGroup>\n-  <PropertyGroup Label=\"Globals\">\n-    <Keyword>Win32Proj</Keyword>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n-  <ImportGroup Label=\"ExtensionSettings\">\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <PropertyGroup Label=\"UserMacros\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <ClCompile>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <ClCompile>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-      <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemGroup>\n-    <ClCompile Include=\"..\\src\\ares\\ares__close_sockets.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares__get_hostent.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares__read_line.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares__timeval.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_cancel.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_data.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_destroy.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_expand_name.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_expand_string.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_fds.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_free_hostent.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_free_string.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_gethostbyaddr.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_gethostbyname.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_getnameinfo.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_getsock.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_init.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_library_init.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_llist.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_mkquery.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_nowarn.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_options.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_a_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_aaaa_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_mx_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_ns_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_ptr_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_srv_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_parse_txt_reply.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_process.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_query.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_search.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_send.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_strcasecmp.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_strdup.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_strerror.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_timeout.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_version.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\ares_writev.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\bitncmp.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\inet_net_pton.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\inet_ntop.c\" />\n-    <ClCompile Include=\"..\\src\\ares\\windows_port.c\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ClInclude Include=\"..\\include\\ares.h\" />\n-    <ClInclude Include=\"..\\include\\ares_version.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_data.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_dns.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_iphlpapi.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_ipv6.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_library_init.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_llist.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_nowarn.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_private.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_rules.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_setup.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_strcasecmp.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_strdup.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_version.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\ares_writev.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\bitncmp.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\config_win32\\ares_config.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\inet_net_pton.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\inet_ntop.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\nameser.h\" />\n-    <ClInclude Include=\"..\\src\\ares\\setup_once.h\" />\n-  </ItemGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n-  <ImportGroup Label=\"ExtensionTargets\">\n-  </ImportGroup>\n-</Project>"}, {"sha": "5727a1aa3c8959ab29edefdd5f97130013455522", "filename": "src/rt/libuv/msvs/libuv-benchmark.vcxproj", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,167 +0,0 @@\n-\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n-  <ItemGroup Label=\"ProjectConfigurations\">\n-    <ProjectConfiguration Include=\"Debug|Win32\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Debug|x64\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|Win32\">\n-      <Configuration>Release</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|x64\">\n-      <Configuration>Release</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-  </ItemGroup>\n-  <PropertyGroup Label=\"Globals\">\n-    <Keyword>Win32Proj</Keyword>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n-  <ImportGroup Label=\"ExtensionSettings\">\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <PropertyGroup Label=\"UserMacros\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <TargetMachine>MachineX86</TargetMachine>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <TargetMachine>MachineX86</TargetMachine>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n-      <OptimizeReferences>true</OptimizeReferences>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n-      <OptimizeReferences>true</OptimizeReferences>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemGroup>\n-    <ClCompile Include=\"..\\test\\benchmark-ares.c\" />\n-    <ClCompile Include=\"..\\test\\benchmark-getaddrinfo.c\" />\n-    <ClCompile Include=\"..\\test\\benchmark-ping-pongs.c\" />\n-    <ClCompile Include=\"..\\test\\benchmark-pump.c\" />\n-    <ClCompile Include=\"..\\test\\benchmark-sizes.c\" />\n-    <ClCompile Include=\"..\\test\\dns-server.c\" />\n-    <ClCompile Include=\"..\\test\\echo-server.c\" />\n-    <ClCompile Include=\"..\\test\\run-benchmarks.c\" />\n-    <ClCompile Include=\"..\\test\\runner-win.c\" />\n-    <ClCompile Include=\"..\\test\\runner.c\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ClInclude Include=\"..\\test\\benchmark-list.h\" />\n-    <ClInclude Include=\"..\\test\\runner-win.h\" />\n-    <ClInclude Include=\"..\\test\\runner.h\" />\n-    <ClInclude Include=\"..\\test\\task.h\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ProjectReference Include=\"libuv.vcxproj\">\n-      <Project>{301fe650-cd34-14e5-6b63-42e383fa02bc}</Project>\n-    </ProjectReference>\n-  </ItemGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n-  <ImportGroup Label=\"ExtensionTargets\">\n-  </ImportGroup>\n-</Project>"}, {"sha": "5b47daeb2018c751eee5140293b2d415674d2627", "filename": "src/rt/libuv/msvs/libuv-test.vcxproj", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,180 +0,0 @@\n-\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n-  <ItemGroup Label=\"ProjectConfigurations\">\n-    <ProjectConfiguration Include=\"Debug|Win32\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Debug|x64\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|Win32\">\n-      <Configuration>Release</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|x64\">\n-      <Configuration>Release</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-  </ItemGroup>\n-  <PropertyGroup Label=\"Globals\">\n-    <Keyword>Win32Proj</Keyword>\n-    <ProjectGuid>{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}</ProjectGuid>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>Application</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n-  <ImportGroup Label=\"ExtensionSettings\">\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <PropertyGroup Label=\"UserMacros\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <LinkIncremental>true</LinkIncremental>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-  </PropertyGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <TargetMachine>MachineX86</TargetMachine>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <TargetMachine>MachineX86</TargetMachine>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n-      <OptimizeReferences>true</OptimizeReferences>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-    <Link>\n-      <GenerateDebugInformation>true</GenerateDebugInformation>\n-      <SubSystem>Console</SubSystem>\n-      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n-      <OptimizeReferences>true</OptimizeReferences>\n-      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n-    </Link>\n-  </ItemDefinitionGroup>\n-  <ItemGroup>\n-    <ClCompile Include=\"..\\test\\echo-server.c\" />\n-    <ClCompile Include=\"..\\test\\test-async.c\" />\n-    <ClCompile Include=\"..\\test\\test-bind6-error.c\" />\n-    <ClCompile Include=\"..\\test\\test-delayed-accept.c\" />\n-    <ClCompile Include=\"..\\test\\test-callback-stack.c\" />\n-    <ClCompile Include=\"..\\test\\test-connection-fail.c\" />\n-    <ClCompile Include=\"..\\test\\test-get-currentexe.c\" />\n-    <ClCompile Include=\"..\\test\\test-fail-always.c\" />\n-    <ClCompile Include=\"..\\test\\test-gethostbyname.c\" />\n-    <ClCompile Include=\"..\\test\\test-getaddrinfo.c\" />\n-    <ClCompile Include=\"..\\test\\test-hrtime.c\" />\n-    <ClCompile Include=\"..\\test\\test-loop-handles.c\" />\n-    <ClCompile Include=\"..\\test\\test-pass-always.c\" />\n-    <ClCompile Include=\"..\\test\\test-ping-pong.c\" />\n-    <ClCompile Include=\"..\\test\\runner-win.c\" />\n-    <ClCompile Include=\"..\\test\\runner.c\" />\n-    <ClCompile Include=\"..\\test\\test-bind-error.c\" />\n-    <ClCompile Include=\"..\\test\\test-shutdown-eof.c\" />\n-    <ClCompile Include=\"..\\test\\test-tcp-writealot.c\" />\n-    <ClCompile Include=\"..\\test\\test-timer-again.c\" />\n-    <ClCompile Include=\"..\\test\\test-timer.c\" />\n-    <ClCompile Include=\"..\\test\\run-tests.c\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ClInclude Include=\"..\\test\\test-list.h\" />\n-    <ClInclude Include=\"..\\test\\runner-win.h\" />\n-    <ClInclude Include=\"..\\test\\runner.h\" />\n-    <ClInclude Include=\"..\\test\\task.h\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ProjectReference Include=\"libuv.vcxproj\">\n-      <Project>{301fe650-cd34-14e5-6b63-42e383fa02bc}</Project>\n-    </ProjectReference>\n-  </ItemGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n-  <ImportGroup Label=\"ExtensionTargets\">\n-  </ImportGroup>\n-</Project>"}, {"sha": "a4eca0a6d4b38b7e2352cb43bc03c3c3a9da71c7", "filename": "src/rt/libuv/msvs/libuv.sln", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,56 +0,0 @@\n-\ufeff\r\n-Microsoft Visual Studio Solution File, Format Version 11.00\r\n-# Visual Studio 2010\r\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv\", \"libuv.vcxproj\", \"{301FE650-CD34-14E5-6B63-42E383FA02BC}\"\r\n-EndProject\r\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-test\", \"libuv-test.vcxproj\", \"{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}\"\r\n-EndProject\r\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-benchmark\", \"libuv-benchmark.vcxproj\", \"{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}\"\r\n-EndProject\r\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"c-ares\", \"c-ares.vcxproj\", \"{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}\"\r\n-EndProject\r\n-Global\r\n-\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n-\t\tDebug|Win32 = Debug|Win32\r\n-\t\tDebug|x64 = Debug|x64\r\n-\t\tRelease|Win32 = Release|Win32\r\n-\t\tRelease|x64 = Release|x64\r\n-\tEndGlobalSection\r\n-\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|Win32.ActiveCfg = Debug|Win32\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|Win32.Build.0 = Debug|Win32\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|x64.ActiveCfg = Debug|x64\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|x64.Build.0 = Debug|x64\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|Win32.ActiveCfg = Release|Win32\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|Win32.Build.0 = Release|Win32\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|x64.ActiveCfg = Release|x64\r\n-\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|x64.Build.0 = Release|x64\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|Win32.ActiveCfg = Debug|Win32\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|Win32.Build.0 = Debug|Win32\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|x64.ActiveCfg = Debug|x64\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|x64.Build.0 = Debug|x64\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|Win32.ActiveCfg = Release|Win32\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|Win32.Build.0 = Release|Win32\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|x64.ActiveCfg = Release|x64\r\n-\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|x64.Build.0 = Release|x64\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|Win32.ActiveCfg = Debug|Win32\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|Win32.Build.0 = Debug|Win32\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|x64.ActiveCfg = Debug|x64\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|x64.Build.0 = Debug|x64\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|Win32.ActiveCfg = Release|Win32\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|Win32.Build.0 = Release|Win32\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.ActiveCfg = Release|x64\r\n-\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.Build.0 = Release|x64\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|Win32.ActiveCfg = Debug|Win32\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|Win32.Build.0 = Debug|Win32\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|x64.ActiveCfg = Debug|x64\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Debug|x64.Build.0 = Debug|x64\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|Win32.ActiveCfg = Release|Win32\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|Win32.Build.0 = Release|Win32\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|x64.ActiveCfg = Release|x64\r\n-\t\t{2B6A4644-EBA9-DFB5-AF35-6C56EDF05C7F}.Release|x64.Build.0 = Release|x64\r\n-\tEndGlobalSection\r\n-\tGlobalSection(SolutionProperties) = preSolution\r\n-\t\tHideSolutionNode = FALSE\r\n-\tEndGlobalSection\r\n-EndGlobal\r"}, {"sha": "c896c6970f03b787a4e313bfabdbdc7efb724f5f", "filename": "src/rt/libuv/msvs/libuv.vcxproj", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,131 +0,0 @@\n-\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n-  <ItemGroup Label=\"ProjectConfigurations\">\n-    <ProjectConfiguration Include=\"Debug|Win32\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Debug|x64\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|Win32\">\n-      <Configuration>Release</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|x64\">\n-      <Configuration>Release</Configuration>\n-      <Platform>x64</Platform>\n-    </ProjectConfiguration>\n-  </ItemGroup>\n-  <PropertyGroup Label=\"Globals\">\n-    <Keyword>Win32Proj</Keyword>\n-    <ProjectGuid>{301FE650-CD34-14E5-6B63-42E383FA02BC}</ProjectGuid>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>true</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n-    <ConfigurationType>StaticLibrary</ConfigurationType>\n-    <UseDebugLibraries>false</UseDebugLibraries>\n-  </PropertyGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n-  <ImportGroup Label=\"ExtensionSettings\">\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n-    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n-  </ImportGroup>\n-  <PropertyGroup Label=\"UserMacros\" />\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n-    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n-  </PropertyGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n-      <WarningLevel>Level3</WarningLevel>\n-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n-      <Optimization>Disabled</Optimization>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <ClCompile>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n-    <ClCompile>\n-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n-      <AdditionalIncludeDirectories>..\\include;..\\src\\ares\\config_win32</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-  <ItemGroup>\n-    <ProjectReference Include=\"c-ares.vcxproj\">\n-      <Project>{2b6a4644-eba9-dfb5-af35-6c56edf05c7f}</Project>\n-      <Private>true</Private>\n-      <ReferenceOutputAssembly>true</ReferenceOutputAssembly>\n-      <CopyLocalSatelliteAssemblies>false</CopyLocalSatelliteAssemblies>\n-      <LinkLibraryDependencies>true</LinkLibraryDependencies>\n-      <UseLibraryDependencyInputs>false</UseLibraryDependencyInputs>\n-    </ProjectReference>\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ClCompile Include=\"..\\src\\uv-common.c\" />\n-    <ClCompile Include=\"..\\src\\uv-win.c\" />\n-  </ItemGroup>\n-  <ItemGroup>\n-    <ClInclude Include=\"..\\include\\ares.h\" />\n-    <ClInclude Include=\"..\\include\\ares_version.h\" />\n-    <ClInclude Include=\"..\\include\\tree.h\" />\n-    <ClInclude Include=\"..\\include\\uv-win.h\" />\n-    <ClInclude Include=\"..\\include\\uv.h\" />\n-    <ClInclude Include=\"..\\src\\uv-common.h\" />\n-  </ItemGroup>\n-  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n-  <ImportGroup Label=\"ExtensionTargets\">\n-  </ImportGroup>\n-</Project>"}, {"sha": "9926c27c577089a69ac13a1d4b952e368c6dfbb0", "filename": "src/rt/libuv/src/ares/ares_parse_a_reply.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -238,6 +238,8 @@ int ares_parse_a_reply(const unsigned char *abuf, int alen,\n                   for (i = 0; i < naddrs; i++)\n                     hostent->h_addr_list[i] = (char *) &addrs[i];\n                   hostent->h_addr_list[naddrs] = NULL;\n+                  if (!naddrs && addrs)\n+                    free(addrs);\n                   *host = hostent;\n                   return ARES_SUCCESS;\n                 }"}, {"sha": "5e3ae6886452517297fa3399930d29776707e3b8", "filename": "src/rt/libuv/src/ares/config_netbsd/ares_config.h", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,510 @@\n+/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n+/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+/* #undef AC_APPLE_UNIVERSAL_BUILD */\n+\n+/* define this if ares is built for a big endian system */\n+/* #undef ARES_BIG_ENDIAN */\n+\n+/* when building as static part of libcurl */\n+/* #undef BUILDING_LIBCURL */\n+\n+/* when building c-ares library */\n+/* #undef CARES_BUILDING_LIBRARY */\n+\n+/* when not building a shared library */\n+/* #undef CARES_STATICLIB */\n+\n+/* Define to 1 to enable hiding of library internal symbols. */\n+/* #undef CARES_SYMBOL_HIDING */\n+\n+/* Definition to make a library symbol externally visible. */\n+/* #undef CARES_SYMBOL_SCOPE_EXTERN */\n+\n+/* if a /etc/inet dir is being used */\n+/* #undef ETC_INET */\n+\n+/* Define to the type qualifier of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_QUAL_ARG1 const\n+\n+/* Define to the type of arg 1 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n+\n+/* Define to the type of arg 2 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG2 socklen_t\n+\n+/* Define to the type of args 4 and 6 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG46 size_t\n+\n+/* Define to the type of arg 7 for getnameinfo. */\n+#define GETNAMEINFO_TYPE_ARG7 int\n+\n+/* Specifies the number of arguments to getservbyport_r */\n+#define GETSERVBYPORT_R_ARGS 4\n+\n+/* Specifies the size of the buffer to pass to getservbyport_r */\n+#define GETSERVBYPORT_R_BUFSIZE sizeof(struct servent_data)\n+\n+/* Define to 1 if you have AF_INET6. */\n+#define HAVE_AF_INET6 1\n+\n+/* Define to 1 if you have the <arpa/inet.h> header file. */\n+#define HAVE_ARPA_INET_H 1\n+\n+/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n+/* #undef HAVE_ARPA_NAMESER_COMPAT_H */\n+\n+/* Define to 1 if you have the <arpa/nameser.h> header file. */\n+#define HAVE_ARPA_NAMESER_H 1\n+\n+/* Define to 1 if you have the <assert.h> header file. */\n+#define HAVE_ASSERT_H 1\n+\n+/* Define to 1 if you have the `bitncmp' function. */\n+/* #undef HAVE_BITNCMP */\n+\n+/* Define to 1 if bool is an available type. */\n+#define HAVE_BOOL_T 1\n+\n+/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n+#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n+\n+/* Define to 1 if you have the closesocket function. */\n+/* #undef HAVE_CLOSESOCKET */\n+\n+/* Define to 1 if you have the CloseSocket camel case function. */\n+/* #undef HAVE_CLOSESOCKET_CAMEL */\n+\n+/* Define to 1 if you have the connect function. */\n+#define HAVE_CONNECT 1\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#define HAVE_ERRNO_H 1\n+\n+/* Define to 1 if you have the fcntl function. */\n+#define HAVE_FCNTL 1\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#define HAVE_FCNTL_H 1\n+\n+/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n+#define HAVE_FCNTL_O_NONBLOCK 1\n+\n+/* Define to 1 if you have the freeaddrinfo function. */\n+#define HAVE_FREEADDRINFO 1\n+\n+/* Define to 1 if you have a working getaddrinfo function. */\n+#define HAVE_GETADDRINFO 1\n+\n+/* Define to 1 if the getaddrinfo function is threadsafe. */\n+/* #undef HAVE_GETADDRINFO_THREADSAFE */\n+\n+/* Define to 1 if you have the gethostbyaddr function. */\n+#define HAVE_GETHOSTBYADDR 1\n+\n+/* Define to 1 if you have the gethostbyname function. */\n+#define HAVE_GETHOSTBYNAME 1\n+\n+/* Define to 1 if you have the gethostname function. */\n+#define HAVE_GETHOSTNAME 1\n+\n+/* Define to 1 if you have the getnameinfo function. */\n+#define HAVE_GETNAMEINFO 1\n+\n+/* Define to 1 if you have the getservbyport_r function. */\n+#define HAVE_GETSERVBYPORT_R 1\n+\n+/* Define to 1 if you have the `gettimeofday' function. */\n+#define HAVE_GETTIMEOFDAY 1\n+\n+/* Define to 1 if you have the `if_indextoname' function. */\n+#define HAVE_IF_INDEXTONAME 1\n+\n+/* Define to 1 if you have the `inet_net_pton' function. */\n+#define HAVE_INET_NET_PTON 1\n+\n+/* Define to 1 if inet_net_pton supports IPv6. */\n+/* #undef HAVE_INET_NET_PTON_IPV6 */\n+\n+/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n+#define HAVE_INET_NTOP 1\n+\n+/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n+#define HAVE_INET_PTON 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the ioctl function. */\n+#define HAVE_IOCTL 1\n+\n+/* Define to 1 if you have the ioctlsocket function. */\n+/* #undef HAVE_IOCTLSOCKET */\n+\n+/* Define to 1 if you have the IoctlSocket camel case function. */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL */\n+\n+/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n+   */\n+/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n+/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n+\n+/* Define to 1 if you have a working ioctl FIONBIO function. */\n+#define HAVE_IOCTL_FIONBIO 1\n+\n+/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n+#define HAVE_IOCTL_SIOCGIFADDR 1\n+\n+/* Define to 1 if you have the `resolve' library (-lresolve). */\n+/* #undef HAVE_LIBRESOLVE */\n+\n+/* Define to 1 if you have the <limits.h> header file. */\n+#define HAVE_LIMITS_H 1\n+\n+/* if your compiler supports LL */\n+#define HAVE_LL 1\n+\n+/* Define to 1 if the compiler supports the 'long long' data type. */\n+#define HAVE_LONGLONG 1\n+\n+/* Define to 1 if you have the malloc.h header file. */\n+#define HAVE_MALLOC_H 1\n+\n+/* Define to 1 if you have the memory.h header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n+/* #undef HAVE_MSG_NOSIGNAL */\n+\n+/* Define to 1 if you have the <netdb.h> header file. */\n+#define HAVE_NETDB_H 1\n+\n+/* Define to 1 if you have the <netinet/in.h> header file. */\n+#define HAVE_NETINET_IN_H 1\n+\n+/* Define to 1 if you have the <netinet/tcp.h> header file. */\n+#define HAVE_NETINET_TCP_H 1\n+\n+/* Define to 1 if you have the <net/if.h> header file. */\n+#define HAVE_NET_IF_H 1\n+\n+/* Define to 1 if you have PF_INET6. */\n+#define HAVE_PF_INET6 1\n+\n+/* Define to 1 if you have the recv function. */\n+#define HAVE_RECV 1\n+\n+/* Define to 1 if you have the recvfrom function. */\n+#define HAVE_RECVFROM 1\n+\n+/* Define to 1 if you have the send function. */\n+#define HAVE_SEND 1\n+\n+/* Define to 1 if you have the setsockopt function. */\n+#define HAVE_SETSOCKOPT 1\n+\n+/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n+/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n+\n+/* Define to 1 if you have the <signal.h> header file. */\n+#define HAVE_SIGNAL_H 1\n+\n+/* Define to 1 if sig_atomic_t is an available typedef. */\n+#define HAVE_SIG_ATOMIC_T 1\n+\n+/* Define to 1 if sig_atomic_t is already defined as volatile. */\n+/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n+\n+/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n+#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n+\n+/* Define to 1 if you have the socket function. */\n+#define HAVE_SOCKET 1\n+\n+/* Define to 1 if you have the <socket.h> header file. */\n+/* #undef HAVE_SOCKET_H */\n+\n+/* Define to 1 if you have the <stdbool.h> header file. */\n+#define HAVE_STDBOOL_H 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the strcasecmp function. */\n+#define HAVE_STRCASECMP 1\n+\n+/* Define to 1 if you have the strcmpi function. */\n+/* #undef HAVE_STRCMPI */\n+\n+/* Define to 1 if you have the strdup function. */\n+#define HAVE_STRDUP 1\n+\n+/* Define to 1 if you have the stricmp function. */\n+/* #undef HAVE_STRICMP */\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the strncasecmp function. */\n+#define HAVE_STRNCASECMP 1\n+\n+/* Define to 1 if you have the strncmpi function. */\n+/* #undef HAVE_STRNCMPI */\n+\n+/* Define to 1 if you have the strnicmp function. */\n+/* #undef HAVE_STRNICMP */\n+\n+/* Define to 1 if you have the <stropts.h> header file. */\n+/* #undef HAVE_STROPTS_H */\n+\n+/* Define to 1 if you have struct addrinfo. */\n+#define HAVE_STRUCT_ADDRINFO 1\n+\n+/* Define to 1 if you have struct in6_addr. */\n+#define HAVE_STRUCT_IN6_ADDR 1\n+\n+/* Define to 1 if you have struct sockaddr_in6. */\n+#define HAVE_STRUCT_SOCKADDR_IN6 1\n+\n+/* if struct sockaddr_storage is defined */\n+#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n+\n+/* Define to 1 if you have the timeval struct. */\n+#define HAVE_STRUCT_TIMEVAL 1\n+\n+/* Define to 1 if you have the <sys/ioctl.h> header file. */\n+#define HAVE_SYS_IOCTL_H 1\n+\n+/* Define to 1 if you have the <sys/param.h> header file. */\n+#define HAVE_SYS_PARAM_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/socket.h> header file. */\n+#define HAVE_SYS_SOCKET_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#define HAVE_SYS_TIME_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#define HAVE_SYS_UIO_H 1\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#define HAVE_TIME_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to 1 if you have the windows.h header file. */\n+/* #undef HAVE_WINDOWS_H */\n+\n+/* Define to 1 if you have the winsock2.h header file. */\n+/* #undef HAVE_WINSOCK2_H */\n+\n+/* Define to 1 if you have the winsock.h header file. */\n+/* #undef HAVE_WINSOCK_H */\n+\n+/* Define to 1 if you have the writev function. */\n+#define HAVE_WRITEV 1\n+\n+/* Define to 1 if you have the ws2tcpip.h header file. */\n+/* #undef HAVE_WS2TCPIP_H */\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Define to 1 if you are building a native Windows target. */\n+/* #undef NATIVE_WINDOWS */\n+\n+/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n+/* #undef NEED_MALLOC_H */\n+\n+/* Define to 1 if you need the memory.h header file even with stdlib.h */\n+/* #undef NEED_MEMORY_H */\n+\n+/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n+/* #undef NEED_REENTRANT */\n+\n+/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n+/* #undef NEED_THREAD_SAFE */\n+\n+/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n+/* #undef NO_MINUS_C_MINUS_O */\n+\n+/* cpu-machine-OS */\n+#define OS \"i386-unknown-openbsd4.7\"\n+\n+/* Name of package */\n+#define PACKAGE \"c-ares\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"c-ares\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"c-ares 1.7.1\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"c-ares\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"1.7.1\"\n+\n+/* a suitable file/device to read random data from */\n+#define RANDOM_FILE \"/dev/urandom\"\n+\n+/* Define to the type of arg 1 for recvfrom. */\n+#define RECVFROM_TYPE_ARG1 int\n+\n+/* Define to the type pointed by arg 2 for recvfrom. */\n+#define RECVFROM_TYPE_ARG2 void\n+\n+/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n+#define RECVFROM_TYPE_ARG2_IS_VOID 1\n+\n+/* Define to the type of arg 3 for recvfrom. */\n+#define RECVFROM_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recvfrom. */\n+#define RECVFROM_TYPE_ARG4 int\n+\n+/* Define to the type pointed by arg 5 for recvfrom. */\n+#define RECVFROM_TYPE_ARG5 struct sockaddr\n+\n+/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n+\n+/* Define to the type pointed by arg 6 for recvfrom. */\n+#define RECVFROM_TYPE_ARG6 socklen_t\n+\n+/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n+/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n+\n+/* Define to the function return type for recvfrom. */\n+#define RECVFROM_TYPE_RETV int\n+\n+/* Define to the type of arg 1 for recv. */\n+#define RECV_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for recv. */\n+#define RECV_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for recv. */\n+#define RECV_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for recv. */\n+#define RECV_TYPE_ARG4 int\n+\n+/* Define to the function return type for recv. */\n+#define RECV_TYPE_RETV int\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#define RETSIGTYPE void\n+\n+/* Define to the type qualifier of arg 2 for send. */\n+#define SEND_QUAL_ARG2 const\n+\n+/* Define to the type of arg 1 for send. */\n+#define SEND_TYPE_ARG1 int\n+\n+/* Define to the type of arg 2 for send. */\n+#define SEND_TYPE_ARG2 void *\n+\n+/* Define to the type of arg 3 for send. */\n+#define SEND_TYPE_ARG3 size_t\n+\n+/* Define to the type of arg 4 for send. */\n+#define SEND_TYPE_ARG4 int\n+\n+/* Define to the function return type for send. */\n+#define SEND_TYPE_RETV int\n+\n+/* The size of `int', as computed by sizeof. */\n+#define SIZEOF_INT 4\n+\n+/* The size of `long', as computed by sizeof. */\n+#define SIZEOF_LONG 4\n+\n+/* The size of `size_t', as computed by sizeof. */\n+#define SIZEOF_SIZE_T 4\n+\n+/* The size of `struct in6_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN6_ADDR 16\n+\n+/* The size of `struct in_addr', as computed by sizeof. */\n+#define SIZEOF_STRUCT_IN_ADDR 4\n+\n+/* The size of `time_t', as computed by sizeof. */\n+#define SIZEOF_TIME_T 4\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#define TIME_WITH_SYS_TIME 1\n+\n+/* Define to disable non-blocking sockets. */\n+/* #undef USE_BLOCKING_SOCKETS */\n+\n+/* Version number of package */\n+#define VERSION \"1.7.1\"\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+/* #  undef WORDS_BIGENDIAN */\n+# endif\n+#endif\n+\n+/* Define to 1 if OS is AIX. */\n+#ifndef _ALL_SOURCE\n+/* #  undef _ALL_SOURCE */\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+/* #undef _FILE_OFFSET_BITS */\n+\n+/* Define for large files, on AIX-style hosts. */\n+/* #undef _LARGE_FILES */\n+\n+/* Define to empty if `const' does not conform to ANSI C. */\n+/* #undef const */\n+\n+/* Type to use in place of in_addr_t when system does not provide it. */\n+/* #undef in_addr_t */\n+\n+/* Define to `unsigned int' if <sys/types.h> does not define. */\n+/* #undef size_t */\n+\n+/* the signed version of size_t */\n+/* #undef ssize_t */"}, {"sha": "1b5389e893c42af0decc6e6bcf33e8709dcbcd07", "filename": "src/rt/libuv/src/ares/inet_ntop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -18,6 +18,7 @@\n  */\n \n #ifdef HAVE_INET_NTOP\n+#include <arpa/inet.h>\n #define ares_inet_ntop(w,x,y,z) inet_ntop(w,x,y,z)\n #else\n const char *ares_inet_ntop(int af, const void *src, char *dst, size_t size);"}, {"sha": "baa94eca9cab45e558c4837bbf1fb1c2ad95e1b7", "filename": "src/rt/libuv/src/eio/Changes", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2FChanges?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,35 +0,0 @@\n-Revision history for libeio\n-\n-TODO: maybe add mincore support? available on at least darwin, solaris, linux, freebsd\n-TODO: openbsd requites stdint.h for intptr_t - why posix?\n-\n-1.0\n-        - readdir: correctly handle malloc failures.\n-        - readdir: new flags argument, can return inode\n-          and possibly filetype, can sort in various ways.\n-        - readdir: stop immediately when cancelled, do\n-          not continue reading the directory.\n-        - fix return value of eio_sendfile_sync.\n-        - include sys/mman.h for msync.\n-\t- added EIO_STACKSIZE.\n-\t- added msync, mtouch support (untested).\n-        - added sync_file_range (untested).\n-        - fixed custom support.\n-        - use a more robust feed-add detection method.\n-\t- \"outbundled\" from IO::AIO.\n-        - eio_set_max_polltime did not properly convert time to ticks.\n-        - tentatively support darwin in sendfile.\n-        - fix freebsd/darwin sendfile.\n-        - also use sendfile emulation for ENOTSUP and EOPNOTSUPP\n-          error codes.\n-        - add OS-independent EIO_MT_* and EIO_MS_* flag enums.\n-        - add eio_statvfs/eio_fstatvfs.\n-        - add eio_mlock/eio_mlockall and OS-independent MCL_* flag enums.\n-        - no longer set errno to 0 before making syscalls, this only lures\n-          people into the trap of believing errno shows success or failure.\n-        - \"fix\" demo.c so that it works as non-root.\n-        - suppoert utimes seperately from futimes, as some systems have\n-          utimes but not futimes.\n-        - use _POSIX_MEMLOCK_RANGE for mlock.\n-        - do not (errornously) overwrite CFLAGS in configure.ac.\n-"}, {"sha": "bd3387c46c70f00112b261e0fa62f0aa6951afcb", "filename": "src/rt/libuv/src/eio/autogen.sh", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Fautogen.sh?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,5 +0,0 @@\n-libtoolize\n-aclocal\n-automake --add-missing\n-autoconf\n-autoheader"}, {"sha": "c83768ebf1910ce9d733b0a956dafac2cfbf8589", "filename": "src/rt/libuv/src/eio/eio.pod", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Feio%2Feio.pod?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,303 +0,0 @@\n-=head1 NAME\n-\n-libeio - truly asynchronous POSIX I/O\n-\n-=head1 SYNOPSIS\n-\n-  #include <eio.h>\n-\n-=head1 DESCRIPTION\n-\n-The newest version of this document is also available as an html-formatted\n-web page you might find easier to navigate when reading it for the first\n-time: L<http://pod.tst.eu/http://cvs.schmorp.de/libeio/eio.pod>.\n-\n-Note that this library is a by-product of the C<IO::AIO> perl\n-module, and many of the subtler points regarding requets lifetime\n-and so on are only documented in its documentation at the\n-moment: L<http://pod.tst.eu/http://cvs.schmorp.de/IO-AIO/AIO.pm>.\n-\n-=head2 FEATURES\n-\n-This library provides fully asynchronous versions of most POSIX functions\n-dealign with I/O. Unlike most asynchronous libraries, this not only\n-includes C<read> and C<write>, but also C<open>, C<stat>, C<unlink> and\n-similar functions, as well as less rarely ones such as C<mknod>, C<futime>\n-or C<readlink>.\n-\n-It also offers wrappers around C<sendfile> (Solaris, Linux, HP-UX and\n-FreeBSD, with emulation on other platforms) and C<readahead> (Linux, with\n-emulation elsewhere>).\n-\n-The goal is to enable you to write fully non-blocking programs. For\n-example, in a game server, you would not want to freeze for a few seconds\n-just because the server is running a backup and you happen to call\n-C<readdir>.\n-\n-=head2 TIME REPRESENTATION\n-\n-Libeio represents time as a single floating point number, representing the\n-(fractional) number of seconds since the (POSIX) epoch (somewhere near\n-the beginning of 1970, details are complicated, don't ask). This type is\n-called C<eio_tstamp>, but it is guarenteed to be of type C<double> (or\n-better), so you can freely use C<double> yourself.\n-\n-Unlike the name component C<stamp> might indicate, it is also used for\n-time differences throughout libeio.\n-\n-=head2 FORK SUPPORT\n-\n-Calling C<fork ()> is fully supported by this module. It is implemented in these steps:\n-\n-   1. wait till all requests in \"execute\" state have been handled\n-      (basically requests that are already handed over to the kernel).\n-   2. fork\n-   3. in the parent, continue business as usual, done\n-   4. in the child, destroy all ready and pending requests and free the\n-      memory used by the worker threads. This gives you a fully empty\n-      libeio queue.\n-\n-=head1 INITIALISATION/INTEGRATION\n-\n-Before you can call any eio functions you first have to initialise the\n-library. The library integrates into any event loop, but can also be used\n-without one, including in polling mode.\n-\n-You have to provide the necessary glue yourself, however.\n-\n-=over 4\n-\n-=item int eio_init (void (*want_poll)(void), void (*done_poll)(void))\n-\n-This function initialises the library. On success it returns C<0>, on\n-failure it returns C<-1> and sets C<errno> appropriately.\n-\n-It accepts two function pointers specifying callbacks as argument, both of\n-which can be C<0>, in which case the callback isn't called.\n-\n-=item want_poll callback\n-\n-The C<want_poll> callback is invoked whenever libeio wants attention (i.e.\n-it wants to be polled by calling C<eio_poll>). It is \"edge-triggered\",\n-that is, it will only be called once when eio wants attention, until all\n-pending requests have been handled.\n-\n-This callback is called while locks are being held, so I<you must\n-not call any libeio functions inside this callback>. That includes\n-C<eio_poll>. What you should do is notify some other thread, or wake up\n-your event loop, and then call C<eio_poll>.\n-\n-=item done_poll callback\n-\n-This callback is invoked when libeio detects that all pending requests\n-have been handled. It is \"edge-triggered\", that is, it will only be\n-called once after C<want_poll>. To put it differently, C<want_poll> and\n-C<done_poll> are invoked in pairs: after C<want_poll> you have to call\n-C<eio_poll ()> until either C<eio_poll> indicates that everything has been\n-handled or C<done_poll> has been called, which signals the same.\n-\n-Note that C<eio_poll> might return after C<done_poll> and C<want_poll>\n-have been called again, so watch out for races in your code.\n-\n-As with C<want_poll>, this callback is called while lcoks are being held,\n-so you I<must not call any libeio functions form within this callback>.\n-\n-=item int eio_poll ()\n-\n-This function has to be called whenever there are pending requests that\n-need finishing. You usually call this after C<want_poll> has indicated\n-that you should do so, but you can also call this function regularly to\n-poll for new results.\n-\n-If any request invocation returns a non-zero value, then C<eio_poll ()>\n-immediately returns with that value as return value.\n-\n-Otherwise, if all requests could be handled, it returns C<0>. If for some\n-reason not all requests have been handled, i.e. some are still pending, it\n-returns C<-1>.\n-\n-=back\n-\n-For libev, you would typically use an C<ev_async> watcher: the\n-C<want_poll> callback would invoke C<ev_async_send> to wake up the event\n-loop. Inside the callback set for the watcher, one would call C<eio_poll\n-()> (followed by C<ev_async_send> again if C<eio_poll> indicates that not\n-all requests have been handled yet). The race is taken care of because\n-libev resets/rearms the async watcher before calling your callback,\n-and therefore, before calling C<eio_poll>. This might result in (some)\n-spurious wake-ups, but is generally harmless.\n-\n-For most other event loops, you would typically use a pipe - the event\n-loop should be told to wait for read readyness on the read end. In\n-C<want_poll> you would write a single byte, in C<done_poll> you would try\n-to read that byte, and in the callback for the read end, you would call\n-C<eio_poll>. The race is avoided here because the event loop should invoke\n-your callback again and again until the byte has been read (as the pipe\n-read callback does not read it, only C<done_poll>).\n-\n-=head2 CONFIGURATION\n-\n-The functions in this section can sometimes be useful, but the default\n-configuration will do in most case, so you should skip this section on\n-first reading.\n-\n-=over 4\n-\n-=item eio_set_max_poll_time (eio_tstamp nseconds)\n-\n-This causes C<eio_poll ()> to return after it has detected that it was\n-running for C<nsecond> seconds or longer (this number can be fractional).\n-\n-This can be used to limit the amount of time spent handling eio requests,\n-for example, in interactive programs, you might want to limit this time to\n-C<0.01> seconds or so.\n-\n-Note that:\n-\n-a) libeio doesn't know how long your request callbacks take, so the time\n-spent in C<eio_poll> is up to one callback invocation longer then this\n-interval.\n-\n-b) this is implemented by calling C<gettimeofday> after each request,\n-which can be costly.\n-\n-c) at least one request will be handled.\n-\n-=item eio_set_max_poll_reqs (unsigned int nreqs)\n-\n-When C<nreqs> is non-zero, then C<eio_poll> will not handle more than\n-C<nreqs> requests per invocation. This is a less costly way to limit the\n-amount of work done by C<eio_poll> then setting a time limit.\n-\n-If you know your callbacks are generally fast, you could use this to\n-encourage interactiveness in your programs by setting it to C<10>, C<100>\n-or even C<1000>.\n-\n-=item eio_set_min_parallel (unsigned int nthreads)\n-\n-Make sure libeio can handle at least this many requests in parallel. It\n-might be able handle more.\n-\n-=item eio_set_max_parallel (unsigned int nthreads)\n-\n-Set the maximum number of threads that libeio will spawn.\n-\n-=item eio_set_max_idle (unsigned int nthreads)\n-\n-Libeio uses threads internally to handle most requests, and will start and stop threads on demand.\n-\n-This call can be used to limit the number of idle threads (threads without\n-work to do): libeio will keep some threads idle in preperation for more\n-requests, but never longer than C<nthreads> threads.\n-\n-In addition to this, libeio will also stop threads when they are idle for\n-a few seconds, regardless of this setting.\n-\n-=item unsigned int eio_nthreads ()\n-\n-Return the number of worker threads currently running.\n-\n-=item unsigned int eio_nreqs ()\n-\n-Return the number of requests currently handled by libeio. This is the\n-total number of requests that have been submitted to libeio, but not yet\n-destroyed.\n-\n-=item unsigned int eio_nready ()\n-\n-Returns the number of ready requests, i.e. requests that have been\n-submitted but have not yet entered the execution phase.\n-\n-=item unsigned int eio_npending ()\n-\n-Returns the number of pending requests, i.e. requests that have been\n-executed and have results, but have not been finished yet by a call to\n-C<eio_poll>).\n-\n-=back\n-\n-\n-=head1 ANATOMY OF AN EIO REQUEST\n-\n-#TODO\n-\n-\n-=head1 HIGH LEVEL REQUEST API\n-\n-#TODO\n-\n-=back\n-\n-\n-=head1 LOW LEVEL REQUEST API\n-\n-#TODO\n-\n-=head1 EMBEDDING\n-\n-Libeio can be embedded directly into programs. This functionality is not\n-documented and not (yet) officially supported.\n-\n-Note that, when including C<libeio.m4>, you are responsible for defining\n-the compilation environment (C<_LARGEFILE_SOURCE>, C<_GNU_SOURCE> etc.).\n-\n-If you need to know how, check the C<IO::AIO> perl module, which does\n-exactly that.\n-\n-\n-=head1 COMPILETIME CONFIGURATION\n-\n-These symbols, if used, must be defined when compiling F<eio.c>.\n-\n-=over 4\n-\n-=item EIO_STACKSIZE\n-\n-This symbol governs the stack size for each eio thread. Libeio itself\n-was written to use very little stackspace, but when using C<EIO_CUSTOM>\n-requests, you might want to increase this.\n-\n-If this symbol is undefined (the default) then libeio will use its default\n-stack size (C<sizeof (long) * 4096> currently).  If it is defined, but\n-C<0>, then the default operating system stack size will be used. In all\n-other cases, the value must be an expression that evaluates to the desired\n-stack size.\n-\n-=back\n-\n-\n-=head1 PORTABILITY REQUIREMENTS\n-\n-In addition to a working ISO-C implementation, libeio relies on a few\n-additional extensions:\n-\n-=over 4\n-\n-=item POSIX threads\n-\n-To be portable, this module uses threads, specifically, the POSIX threads\n-library must be available (and working, which partially excludes many xBSD\n-systems, where C<fork ()> is buggy).\n-\n-=item POSIX-compatible filesystem API\n-\n-This is actually a harder portability requirement: The libeio API is quite\n-demanding regarding POSIX API calls (symlinks, user/group management\n-etc.).\n-\n-=item C<double> must hold a time value in seconds with enough accuracy\n-\n-The type C<double> is used to represent timestamps. It is required to\n-have at least 51 bits of mantissa (and 9 bits of exponent), which is good\n-enough for at least into the year 4000. This requirement is fulfilled by\n-implementations implementing IEEE 754 (basically all existing ones).\n-\n-=back\n-\n-If you know of other additional requirements drop me a note.\n-\n-\n-=head1 AUTHOR\n-\n-Marc Lehmann <libeio@schmorp.de>.\n-"}, {"sha": "a2466f59e6f80ff66ad038c6d8e20a4728f96cc2", "filename": "src/rt/libuv/src/unix/cares.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,185 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+\n+/*\n+ * This is called once per second by loop->timer. It is used to\n+ * constantly callback into c-ares for possibly processing timeouts.\n+ */\n+static void uv__ares_timeout(struct ev_loop* ev, struct ev_timer* watcher,\n+    int revents) {\n+  uv_loop_t* loop = ev_userdata(ev);\n+\n+  assert(ev == loop->ev);\n+  assert((uv_loop_t*)watcher->data == loop);\n+  assert(watcher == &loop->timer);\n+  assert(revents == EV_TIMER);\n+  assert(!uv_ares_handles_empty(loop));\n+\n+  ares_process_fd(loop->channel, ARES_SOCKET_BAD, ARES_SOCKET_BAD);\n+}\n+\n+\n+static void uv__ares_io(struct ev_loop* ev, struct ev_io* watcher,\n+    int revents) {\n+  uv_loop_t* loop = ev_userdata(ev);\n+\n+  assert(ev == loop->ev);\n+\n+  /* Reset the idle timer */\n+  ev_timer_again(ev, &loop->timer);\n+\n+  /* Process DNS responses */\n+  ares_process_fd(loop->channel,\n+      revents & EV_READ ? watcher->fd : ARES_SOCKET_BAD,\n+      revents & EV_WRITE ? watcher->fd : ARES_SOCKET_BAD);\n+}\n+\n+\n+/* Allocates and returns a new uv_ares_task_t */\n+static uv_ares_task_t* uv__ares_task_create(int fd) {\n+  uv_ares_task_t* h = malloc(sizeof(uv_ares_task_t));\n+\n+  if (h == NULL) {\n+    uv_fatal_error(ENOMEM, \"malloc\");\n+  }\n+\n+  h->sock = fd;\n+\n+  ev_io_init(&h->read_watcher, uv__ares_io, fd, EV_READ);\n+  ev_io_init(&h->write_watcher, uv__ares_io, fd, EV_WRITE);\n+\n+  h->read_watcher.data = h;\n+  h->write_watcher.data = h;\n+\n+  return h;\n+}\n+\n+\n+/* Callback from ares when socket operation is started */\n+static void uv__ares_sockstate_cb(void* data, ares_socket_t sock,\n+    int read, int write) {\n+  uv_loop_t* loop = data;\n+  uv_ares_task_t* h;\n+\n+  assert((uv_loop_t*)loop->timer.data == loop);\n+\n+  h = uv_find_ares_handle(loop, sock);\n+\n+  if (read || write) {\n+    if (!h) {\n+      /* New socket */\n+\n+      /* If this is the first socket then start the timer. */\n+      if (!ev_is_active(&loop->timer)) {\n+        assert(uv_ares_handles_empty(loop));\n+        ev_timer_again(loop->ev, &loop->timer);\n+      }\n+\n+      h = uv__ares_task_create(sock);\n+      uv_add_ares_handle(loop, h);\n+    }\n+\n+    if (read) {\n+      ev_io_start(loop->ev, &h->read_watcher);\n+    } else {\n+      ev_io_stop(loop->ev, &h->read_watcher);\n+    }\n+\n+    if (write) {\n+      ev_io_start(loop->ev, &h->write_watcher);\n+    } else {\n+      ev_io_stop(loop->ev, &h->write_watcher);\n+    }\n+\n+  } else {\n+    /*\n+     * read == 0 and write == 0 this is c-ares's way of notifying us that\n+     * the socket is now closed. We must free the data associated with\n+     * socket.\n+     */\n+    assert(h && \"When an ares socket is closed we should have a handle for it\");\n+\n+    ev_io_stop(loop->ev, &h->read_watcher);\n+    ev_io_stop(loop->ev, &h->write_watcher);\n+\n+    uv_remove_ares_handle(h);\n+    free(h);\n+\n+    if (uv_ares_handles_empty(loop)) {\n+      ev_timer_stop(loop->ev, &loop->timer);\n+    }\n+  }\n+}\n+\n+\n+/* c-ares integration initialize and terminate */\n+/* TODO: share this with windows? */\n+int uv_ares_init_options(uv_loop_t* loop, ares_channel *channelptr,\n+    struct ares_options *options, int optmask) {\n+  int rc;\n+\n+  /* only allow single init at a time */\n+  if (loop->channel != NULL) {\n+    uv_err_new_artificial(loop, UV_EALREADY);\n+    return -1;\n+  }\n+\n+  /* set our callback as an option */\n+  options->sock_state_cb = uv__ares_sockstate_cb;\n+  options->sock_state_cb_data = loop;\n+  optmask |= ARES_OPT_SOCK_STATE_CB;\n+\n+  /* We do the call to ares_init_option for caller. */\n+  rc = ares_init_options(channelptr, options, optmask);\n+\n+  /* if success, save channel */\n+  if (rc == ARES_SUCCESS) {\n+    loop->channel = *channelptr;\n+  } \n+\n+  /*\n+   * Initialize the timeout timer. The timer won't be started until the\n+   * first socket is opened.\n+   */\n+  ev_timer_init(&loop->timer, uv__ares_timeout, 1., 1.);\n+  loop->timer.data = loop;\n+\n+  return rc;\n+}\n+\n+\n+/* TODO share this with windows? */\n+void uv_ares_destroy(uv_loop_t* loop, ares_channel channel) {\n+  /* only allow destroy if did init */\n+  if (loop->channel) {\n+    ev_timer_stop(loop->ev, &loop->timer);\n+    ares_destroy(channel);\n+    loop->channel = NULL;\n+  }\n+}"}, {"sha": "80b3bf6ed9e21473ac3518d55843c75f310a3f6d", "filename": "src/rt/libuv/src/unix/core.c", "status": "added", "additions": 799, "deletions": 0, "changes": 799, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,799 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"unix/internal.h\"\n+\n+#include <stddef.h> /* NULL */\n+#include <stdio.h> /* printf */\n+#include <stdlib.h>\n+#include <string.h> /* strerror */\n+#include <errno.h>\n+#include <assert.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#include <limits.h> /* PATH_MAX */\n+#include <sys/uio.h> /* writev */\n+\n+#ifdef __sun\n+# include <sys/types.h>\n+# include <sys/wait.h>\n+#endif\n+\n+#if defined(__APPLE__)\n+#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n+#endif\n+\n+#if defined(__FreeBSD__)\n+#include <sys/sysctl.h>\n+#include <sys/wait.h>\n+#endif\n+\n+static uv_loop_t default_loop_struct;\n+static uv_loop_t* default_loop_ptr;\n+\n+void uv__next(EV_P_ ev_idle* watcher, int revents);\n+static void uv__finish_close(uv_handle_t* handle);\n+\n+\n+\n+#ifndef __GNUC__\n+#define __attribute__(a)\n+#endif\n+\n+\n+void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n+  uv_udp_t* udp;\n+  uv_async_t* async;\n+  uv_timer_t* timer;\n+  uv_stream_t* stream;\n+  uv_process_t* process;\n+\n+  handle->close_cb = close_cb;\n+\n+  switch (handle->type) {\n+    case UV_NAMED_PIPE:\n+      uv_pipe_cleanup((uv_pipe_t*)handle);\n+      /* Fall through. */\n+\n+    case UV_TTY:\n+    case UV_TCP:\n+      stream = (uv_stream_t*)handle;\n+\n+      uv_read_stop(stream);\n+      ev_io_stop(stream->loop->ev, &stream->write_watcher);\n+\n+      uv__close(stream->fd);\n+      stream->fd = -1;\n+\n+      if (stream->accepted_fd >= 0) {\n+        uv__close(stream->accepted_fd);\n+        stream->accepted_fd = -1;\n+      }\n+\n+      assert(!ev_is_active(&stream->read_watcher));\n+      assert(!ev_is_active(&stream->write_watcher));\n+      break;\n+\n+    case UV_UDP:\n+      udp = (uv_udp_t*)handle;\n+      uv__udp_watcher_stop(udp, &udp->read_watcher);\n+      uv__udp_watcher_stop(udp, &udp->write_watcher);\n+      uv__close(udp->fd);\n+      udp->fd = -1;\n+      break;\n+\n+    case UV_PREPARE:\n+      uv_prepare_stop((uv_prepare_t*) handle);\n+      break;\n+\n+    case UV_CHECK:\n+      uv_check_stop((uv_check_t*) handle);\n+      break;\n+\n+    case UV_IDLE:\n+      uv_idle_stop((uv_idle_t*) handle);\n+      break;\n+\n+    case UV_ASYNC:\n+      async = (uv_async_t*)handle;\n+      ev_async_stop(async->loop->ev, &async->async_watcher);\n+      ev_ref(async->loop->ev);\n+      break;\n+\n+    case UV_TIMER:\n+      timer = (uv_timer_t*)handle;\n+      if (ev_is_active(&timer->timer_watcher)) {\n+        ev_ref(timer->loop->ev);\n+      }\n+      ev_timer_stop(timer->loop->ev, &timer->timer_watcher);\n+      break;\n+\n+    case UV_PROCESS:\n+      process = (uv_process_t*)handle;\n+      ev_child_stop(process->loop->ev, &process->child_watcher);\n+      break;\n+\n+    case UV_FS_EVENT:\n+      uv__fs_event_destroy((uv_fs_event_t*)handle);\n+      break;\n+\n+    default:\n+      assert(0);\n+  }\n+\n+  handle->flags |= UV_CLOSING;\n+\n+  /* This is used to call the on_close callback in the next loop. */\n+  ev_idle_start(handle->loop->ev, &handle->next_watcher);\n+  ev_feed_event(handle->loop->ev, &handle->next_watcher, EV_IDLE);\n+  assert(ev_is_pending(&handle->next_watcher));\n+}\n+\n+\n+uv_loop_t* uv_loop_new() {\n+  uv_loop_t* loop = calloc(1, sizeof(uv_loop_t));\n+  loop->ev = ev_loop_new(0);\n+  ev_set_userdata(loop->ev, loop);\n+  return loop;\n+}\n+\n+\n+void uv_loop_delete(uv_loop_t* loop) {\n+  uv_ares_destroy(loop, loop->channel);\n+  ev_loop_destroy(loop->ev);\n+  free(loop);\n+}\n+\n+\n+uv_loop_t* uv_default_loop() {\n+  if (!default_loop_ptr) {\n+    default_loop_ptr = &default_loop_struct;\n+#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060\n+    default_loop_struct.ev = ev_default_loop(EVBACKEND_KQUEUE);\n+#else\n+    default_loop_struct.ev = ev_default_loop(EVFLAG_AUTO);\n+#endif\n+    ev_set_userdata(default_loop_struct.ev, default_loop_ptr);\n+  }\n+  assert(default_loop_ptr->ev == EV_DEFAULT_UC);\n+  return default_loop_ptr;\n+}\n+\n+\n+int uv_run(uv_loop_t* loop) {\n+  ev_run(loop->ev, 0);\n+  return 0;\n+}\n+\n+\n+void uv__handle_init(uv_loop_t* loop, uv_handle_t* handle,\n+    uv_handle_type type) {\n+  loop->counters.handle_init++;\n+\n+  handle->loop = loop;\n+  handle->type = type;\n+  handle->flags = 0;\n+\n+  ev_init(&handle->next_watcher, uv__next);\n+  handle->next_watcher.data = handle;\n+\n+  /* Ref the loop until this handle is closed. See uv__finish_close. */\n+  ev_ref(loop->ev);\n+}\n+\n+\n+void uv__finish_close(uv_handle_t* handle) {\n+  uv_loop_t* loop = handle->loop;\n+\n+  assert(handle->flags & UV_CLOSING);\n+  assert(!(handle->flags & UV_CLOSED));\n+  handle->flags |= UV_CLOSED;\n+\n+  switch (handle->type) {\n+    case UV_PREPARE:\n+      assert(!ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher));\n+      break;\n+\n+    case UV_CHECK:\n+      assert(!ev_is_active(&((uv_check_t*)handle)->check_watcher));\n+      break;\n+\n+    case UV_IDLE:\n+      assert(!ev_is_active(&((uv_idle_t*)handle)->idle_watcher));\n+      break;\n+\n+    case UV_ASYNC:\n+      assert(!ev_is_active(&((uv_async_t*)handle)->async_watcher));\n+      break;\n+\n+    case UV_TIMER:\n+      assert(!ev_is_active(&((uv_timer_t*)handle)->timer_watcher));\n+      break;\n+\n+    case UV_NAMED_PIPE:\n+    case UV_TCP:\n+    case UV_TTY:\n+      assert(!ev_is_active(&((uv_stream_t*)handle)->read_watcher));\n+      assert(!ev_is_active(&((uv_stream_t*)handle)->write_watcher));\n+      assert(((uv_stream_t*)handle)->fd == -1);\n+      uv__stream_destroy((uv_stream_t*)handle);\n+      break;\n+\n+    case UV_UDP:\n+      assert(!ev_is_active(&((uv_udp_t*)handle)->read_watcher));\n+      assert(!ev_is_active(&((uv_udp_t*)handle)->write_watcher));\n+      assert(((uv_udp_t*)handle)->fd == -1);\n+      uv__udp_destroy((uv_udp_t*)handle);\n+      break;\n+\n+    case UV_PROCESS:\n+      assert(!ev_is_active(&((uv_process_t*)handle)->child_watcher));\n+      break;\n+\n+    case UV_FS_EVENT:\n+      break;\n+\n+    default:\n+      assert(0);\n+      break;\n+  }\n+\n+  ev_idle_stop(loop->ev, &handle->next_watcher);\n+\n+  if (handle->close_cb) {\n+    handle->close_cb(handle);\n+  }\n+\n+  ev_unref(loop->ev);\n+}\n+\n+\n+void uv__next(EV_P_ ev_idle* watcher, int revents) {\n+  uv_handle_t* handle = watcher->data;\n+  assert(watcher == &handle->next_watcher);\n+  assert(revents == EV_IDLE);\n+\n+  /* For now this function is only to handle the closing event, but we might\n+   * put more stuff here later.\n+   */\n+  assert(handle->flags & UV_CLOSING);\n+  uv__finish_close(handle);\n+}\n+\n+\n+void uv_ref(uv_loop_t* loop) {\n+  ev_ref(loop->ev);\n+}\n+\n+\n+void uv_unref(uv_loop_t* loop) {\n+  ev_unref(loop->ev);\n+}\n+\n+\n+void uv_update_time(uv_loop_t* loop) {\n+  ev_now_update(loop->ev);\n+}\n+\n+\n+int64_t uv_now(uv_loop_t* loop) {\n+  return (int64_t)(ev_now(loop->ev) * 1000);\n+}\n+\n+\n+void uv__req_init(uv_req_t* req) {\n+  /* loop->counters.req_init++; */\n+  req->type = UV_UNKNOWN_REQ;\n+}\n+\n+\n+static void uv__prepare(EV_P_ ev_prepare* w, int revents) {\n+  uv_prepare_t* prepare = w->data;\n+\n+  if (prepare->prepare_cb) {\n+    prepare->prepare_cb(prepare, 0);\n+  }\n+}\n+\n+\n+int uv_prepare_init(uv_loop_t* loop, uv_prepare_t* prepare) {\n+  uv__handle_init(loop, (uv_handle_t*)prepare, UV_PREPARE);\n+  loop->counters.prepare_init++;\n+\n+  ev_prepare_init(&prepare->prepare_watcher, uv__prepare);\n+  prepare->prepare_watcher.data = prepare;\n+\n+  prepare->prepare_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb) {\n+  int was_active = ev_is_active(&prepare->prepare_watcher);\n+\n+  prepare->prepare_cb = cb;\n+\n+  ev_prepare_start(prepare->loop->ev, &prepare->prepare_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(prepare->loop->ev);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_prepare_stop(uv_prepare_t* prepare) {\n+  int was_active = ev_is_active(&prepare->prepare_watcher);\n+\n+  ev_prepare_stop(prepare->loop->ev, &prepare->prepare_watcher);\n+\n+  if (was_active) {\n+    ev_ref(prepare->loop->ev);\n+  }\n+  return 0;\n+}\n+\n+\n+\n+static void uv__check(EV_P_ ev_check* w, int revents) {\n+  uv_check_t* check = w->data;\n+\n+  if (check->check_cb) {\n+    check->check_cb(check, 0);\n+  }\n+}\n+\n+\n+int uv_check_init(uv_loop_t* loop, uv_check_t* check) {\n+  uv__handle_init(loop, (uv_handle_t*)check, UV_CHECK);\n+  loop->counters.check_init++;\n+\n+  ev_check_init(&check->check_watcher, uv__check);\n+  check->check_watcher.data = check;\n+\n+  check->check_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_check_start(uv_check_t* check, uv_check_cb cb) {\n+  int was_active = ev_is_active(&check->check_watcher);\n+\n+  check->check_cb = cb;\n+\n+  ev_check_start(check->loop->ev, &check->check_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(check->loop->ev);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_check_stop(uv_check_t* check) {\n+  int was_active = ev_is_active(&check->check_watcher);\n+\n+  ev_check_stop(check->loop->ev, &check->check_watcher);\n+\n+  if (was_active) {\n+    ev_ref(check->loop->ev);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static void uv__idle(EV_P_ ev_idle* w, int revents) {\n+  uv_idle_t* idle = (uv_idle_t*)(w->data);\n+\n+  if (idle->idle_cb) {\n+    idle->idle_cb(idle, 0);\n+  }\n+}\n+\n+\n+\n+int uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n+  uv__handle_init(loop, (uv_handle_t*)idle, UV_IDLE);\n+  loop->counters.idle_init++;\n+\n+  ev_idle_init(&idle->idle_watcher, uv__idle);\n+  idle->idle_watcher.data = idle;\n+\n+  idle->idle_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {\n+  int was_active = ev_is_active(&idle->idle_watcher);\n+\n+  idle->idle_cb = cb;\n+  ev_idle_start(idle->loop->ev, &idle->idle_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(idle->loop->ev);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_idle_stop(uv_idle_t* idle) {\n+  int was_active = ev_is_active(&idle->idle_watcher);\n+\n+  ev_idle_stop(idle->loop->ev, &idle->idle_watcher);\n+\n+  if (was_active) {\n+    ev_ref(idle->loop->ev);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_is_active(uv_handle_t* handle) {\n+  switch (handle->type) {\n+    case UV_TIMER:\n+      return ev_is_active(&((uv_timer_t*)handle)->timer_watcher);\n+\n+    case UV_PREPARE:\n+      return ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher);\n+\n+    case UV_CHECK:\n+      return ev_is_active(&((uv_check_t*)handle)->check_watcher);\n+\n+    case UV_IDLE:\n+      return ev_is_active(&((uv_idle_t*)handle)->idle_watcher);\n+\n+    default:\n+      return 1;\n+  }\n+}\n+\n+\n+static void uv__async(EV_P_ ev_async* w, int revents) {\n+  uv_async_t* async = w->data;\n+\n+  if (async->async_cb) {\n+    async->async_cb(async, 0);\n+  }\n+}\n+\n+\n+int uv_async_init(uv_loop_t* loop, uv_async_t* async, uv_async_cb async_cb) {\n+  uv__handle_init(loop, (uv_handle_t*)async, UV_ASYNC);\n+  loop->counters.async_init++;\n+\n+  ev_async_init(&async->async_watcher, uv__async);\n+  async->async_watcher.data = async;\n+\n+  async->async_cb = async_cb;\n+\n+  /* Note: This does not have symmetry with the other libev wrappers. */\n+  ev_async_start(loop->ev, &async->async_watcher);\n+  ev_unref(loop->ev);\n+\n+  return 0;\n+}\n+\n+\n+int uv_async_send(uv_async_t* async) {\n+  ev_async_send(async->loop->ev, &async->async_watcher);\n+  return 0;\n+}\n+\n+\n+static void uv__timer_cb(EV_P_ ev_timer* w, int revents) {\n+  uv_timer_t* timer = w->data;\n+\n+  if (!ev_is_active(w)) {\n+    ev_ref(EV_A);\n+  }\n+\n+  if (timer->timer_cb) {\n+    timer->timer_cb(timer, 0);\n+  }\n+}\n+\n+\n+int uv_timer_init(uv_loop_t* loop, uv_timer_t* timer) {\n+  uv__handle_init(loop, (uv_handle_t*)timer, UV_TIMER);\n+  loop->counters.timer_init++;\n+\n+  ev_init(&timer->timer_watcher, uv__timer_cb);\n+  timer->timer_watcher.data = timer;\n+\n+  return 0;\n+}\n+\n+\n+int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout,\n+    int64_t repeat) {\n+  if (ev_is_active(&timer->timer_watcher)) {\n+    return -1;\n+  }\n+\n+  timer->timer_cb = cb;\n+  ev_timer_set(&timer->timer_watcher, timeout / 1000.0, repeat / 1000.0);\n+  ev_timer_start(timer->loop->ev, &timer->timer_watcher);\n+  ev_unref(timer->loop->ev);\n+  return 0;\n+}\n+\n+\n+int uv_timer_stop(uv_timer_t* timer) {\n+  if (ev_is_active(&timer->timer_watcher)) {\n+    ev_ref(timer->loop->ev);\n+  }\n+\n+  ev_timer_stop(timer->loop->ev, &timer->timer_watcher);\n+  return 0;\n+}\n+\n+\n+int uv_timer_again(uv_timer_t* timer) {\n+  if (!ev_is_active(&timer->timer_watcher)) {\n+    uv_err_new(timer->loop, EINVAL);\n+    return -1;\n+  }\n+\n+  ev_timer_again(timer->loop->ev, &timer->timer_watcher);\n+  return 0;\n+}\n+\n+void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat) {\n+  assert(timer->type == UV_TIMER);\n+  timer->timer_watcher.repeat = repeat / 1000.0;\n+}\n+\n+int64_t uv_timer_get_repeat(uv_timer_t* timer) {\n+  assert(timer->type == UV_TIMER);\n+  return (int64_t)(1000 * timer->timer_watcher.repeat);\n+}\n+\n+\n+static int uv_getaddrinfo_done(eio_req* req) {\n+  uv_getaddrinfo_t* handle = req->data;\n+  struct addrinfo *res = handle->res;\n+  handle->res = NULL;\n+\n+  uv_unref(handle->loop);\n+\n+  free(handle->hints);\n+  free(handle->service);\n+  free(handle->hostname);\n+\n+  if (handle->retcode != 0) {\n+    /* TODO how to display gai error strings? */\n+    uv_err_new(handle->loop, handle->retcode);\n+  }\n+\n+  handle->cb(handle, handle->retcode, res);\n+\n+  return 0;\n+}\n+\n+\n+static void getaddrinfo_thread_proc(eio_req *req) {\n+  uv_getaddrinfo_t* handle = req->data;\n+\n+  handle->retcode = getaddrinfo(handle->hostname,\n+                                handle->service,\n+                                handle->hints,\n+                                &handle->res);\n+}\n+\n+\n+/* stub implementation of uv_getaddrinfo */\n+int uv_getaddrinfo(uv_loop_t* loop,\n+                   uv_getaddrinfo_t* handle,\n+                   uv_getaddrinfo_cb cb,\n+                   const char* hostname,\n+                   const char* service,\n+                   const struct addrinfo* hints) {\n+  eio_req* req;\n+  uv_eio_init(loop);\n+\n+  if (handle == NULL || cb == NULL ||\n+      (hostname == NULL && service == NULL)) {\n+    uv_err_new_artificial(loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  uv__req_init((uv_req_t*)handle);\n+  handle->type = UV_GETADDRINFO;\n+  handle->loop = loop;\n+  handle->cb = cb;\n+\n+  /* TODO don't alloc so much. */\n+\n+  if (hints) {\n+    handle->hints = malloc(sizeof(struct addrinfo));\n+    memcpy(&handle->hints, hints, sizeof(struct addrinfo));\n+  }\n+  else {\n+    handle->hints = NULL;\n+  }\n+\n+  /* TODO security! check lengths, check return values. */\n+\n+  handle->hostname = hostname ? strdup(hostname) : NULL;\n+  handle->service = service ? strdup(service) : NULL;\n+  handle->res = NULL;\n+  handle->retcode = 0;\n+\n+  /* TODO check handle->hostname == NULL */\n+  /* TODO check handle->service == NULL */\n+\n+  uv_ref(loop);\n+\n+  req = eio_custom(getaddrinfo_thread_proc, EIO_PRI_DEFAULT,\n+      uv_getaddrinfo_done, handle);\n+  assert(req);\n+  assert(req->data == handle);\n+\n+  return 0;\n+}\n+\n+\n+void uv_freeaddrinfo(struct addrinfo* ai) {\n+  freeaddrinfo(ai);\n+}\n+\n+\n+/* Open a socket in non-blocking close-on-exec mode, atomically if possible. */\n+int uv__socket(int domain, int type, int protocol) {\n+#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)\n+  return socket(domain, type | SOCK_NONBLOCK | SOCK_CLOEXEC, protocol);\n+#else\n+  int sockfd;\n+\n+  if ((sockfd = socket(domain, type, protocol)) == -1) {\n+    return -1;\n+  }\n+\n+  if (uv__nonblock(sockfd, 1) == -1 || uv__cloexec(sockfd, 1) == -1) {\n+    uv__close(sockfd);\n+    return -1;\n+  }\n+\n+  return sockfd;\n+#endif\n+}\n+\n+\n+int uv__accept(int sockfd, struct sockaddr* saddr, socklen_t slen) {\n+  int peerfd;\n+\n+  assert(sockfd >= 0);\n+\n+  do {\n+#if defined(HAVE_ACCEPT4)\n+    peerfd = accept4(sockfd, saddr, &slen, SOCK_NONBLOCK | SOCK_CLOEXEC);\n+#else\n+    if ((peerfd = accept(sockfd, saddr, &slen)) != -1) {\n+      if (uv__cloexec(peerfd, 1) == -1 || uv__nonblock(peerfd, 1) == -1) {\n+        uv__close(peerfd);\n+        return -1;\n+      }\n+    }\n+#endif\n+  }\n+  while (peerfd == -1 && errno == EINTR);\n+\n+  return peerfd;\n+}\n+\n+\n+int uv__close(int fd) {\n+  int status;\n+\n+  /*\n+   * Retry on EINTR. You may think this is academic but on linux\n+   * and probably other Unices too, close(2) is interruptible.\n+   * Failing to handle EINTR is a common source of fd leaks.\n+   */\n+  do {\n+    status = close(fd);\n+  }\n+  while (status == -1 && errno == EINTR);\n+\n+  return status;\n+}\n+\n+\n+int uv__nonblock(int fd, int set) {\n+  int flags;\n+\n+  if ((flags = fcntl(fd, F_GETFL)) == -1) {\n+    return -1;\n+  }\n+\n+  if (set) {\n+    flags |= O_NONBLOCK;\n+  } else {\n+    flags &= ~O_NONBLOCK;\n+  }\n+\n+  if (fcntl(fd, F_SETFL, flags) == -1) {\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv__cloexec(int fd, int set) {\n+  int flags;\n+\n+  if ((flags = fcntl(fd, F_GETFD)) == -1) {\n+    return -1;\n+  }\n+\n+  if (set) {\n+    flags |= FD_CLOEXEC;\n+  } else {\n+    flags &= ~FD_CLOEXEC;\n+  }\n+\n+  if (fcntl(fd, F_SETFD, flags) == -1) {\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* TODO move to uv-common.c? */\n+size_t uv__strlcpy(char* dst, const char* src, size_t size) {\n+  const char *org;\n+\n+  if (size == 0) {\n+    return 0;\n+  }\n+\n+  org = src;\n+  while (--size && *src) {\n+    *dst++ = *src++;\n+  }\n+  *dst = '\\0';\n+\n+  return src - org;\n+}\n+\n+\n+uv_stream_t* uv_std_handle(uv_loop_t* loop, uv_std_type type) {\n+  assert(0 && \"implement me\");\n+  return NULL;\n+}\n+"}, {"sha": "6702eb9234fa6e591dc0b9f1676ac8f6adb46415", "filename": "src/rt/libuv/src/unix/cygwin.c", "status": "renamed", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -20,8 +20,10 @@\n \n #include \"uv.h\"\n \n+#include <assert.h>\n #include <stdint.h>\n #include <stddef.h>\n+#include <errno.h>\n #include <time.h>\n \n #undef NANOSEC\n@@ -50,3 +52,17 @@ int uv_exepath(char* buffer, size_t* size) {\n   buffer[*size] = '\\0';\n   return 0;\n }\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"implement me\");\n+}", "previous_filename": "src/rt/libuv/src/uv-cygwin.c"}, {"sha": "af72b4b0ec888ba312dd7326dbcbccce3ceb1f3a", "filename": "src/rt/libuv/src/unix/darwin.c", "status": "renamed", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -19,11 +19,16 @@\n  */\n \n #include \"uv.h\"\n+#include \"internal.h\"\n \n+#include <assert.h>\n #include <stdint.h>\n+#include <errno.h>\n+\n #include <CoreServices/CoreServices.h>\n #include <mach/mach.h>\n #include <mach/mach_time.h>\n+#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n \n \n uint64_t uv_hrtime() {\n@@ -62,3 +67,17 @@ int uv_exepath(char* buffer, size_t* size) {\n   *size = strlen(buffer);\n   return 0;\n }\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"implement me\");\n+}", "previous_filename": "src/rt/libuv/src/uv-darwin.c"}, {"sha": "9d3e3231c12c0f0d2bbcb4ae3bc93aa47164beba", "filename": "src/rt/libuv/src/unix/eio/Changes", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,63 @@\n+Revision history for libeio\n+\n+TODO: maybe add mincore support? available on at least darwin, solaris, linux, freebsd\n+TODO: openbsd requires stdint.h for intptr_t - why posix?\n+\n+TODO: make mtouch/readdir maybe others cancellable in-request\n+TODO: fadvise request\n+1.0\n+\t- fix a deadlock where a wakeup signal could be missed when\n+          a timeout occured at the same time.\n+\t- use nonstandard but maybe-working-on-bsd fork technique.\n+        - use fewer time() syscalls when waiting for new requests.\n+        - fix a path-memory-leak in readdir when using the wrappers\n+          (reported by Thomas L. Shinnick).\n+\t- support a max_idle value of 0.\n+\t- support setting of idle timeout value (eio_set_idle_timeout).\n+        - readdir: correctly handle malloc failures.\n+        - readdir: new flags argument, can return inode\n+          and possibly filetype, can sort in various ways.\n+        - readdir: stop immediately when cancelled, do\n+          not continue reading the directory.\n+        - fix return value of eio_sendfile_sync.\n+        - include sys/mman.h for msync.\n+\t- added EIO_STACKSIZE.\n+\t- added msync, mtouch support (untested).\n+        - added sync_file_range (untested).\n+        - fixed custom support.\n+        - use a more robust feed-add detection method.\n+\t- \"outbundled\" from IO::AIO.\n+        - eio_set_max_polltime did not properly convert time to ticks.\n+        - tentatively support darwin in sendfile.\n+        - fix freebsd/darwin sendfile.\n+        - also use sendfile emulation for ENOTSUP and EOPNOTSUPP\n+          error codes.\n+        - add OS-independent EIO_MT_* and EIO_MS_* flag enums.\n+        - add eio_statvfs/eio_fstatvfs.\n+        - add eio_mlock/eio_mlockall and OS-independent MCL_* flag enums.\n+        - no longer set errno to 0 before making syscalls, this only lures\n+          people into the trap of believing errno shows success or failure.\n+        - \"fix\" demo.c so that it works as non-root.\n+        - suppoert utimes seperately from futimes, as some systems have\n+          utimes but not futimes.\n+        - use _POSIX_MEMLOCK_RANGE for mlock.\n+        - do not (errornously) overwrite CFLAGS in configure.ac.\n+        - mknod used int3 for dev_t (\u00a72 bit), not offs (64 bit).\n+        - fix memory corruption in eio_readdirx for the flags\n+          combination EIO_READDIR_STAT_ORDER | EIO_READDIR_DIRS_FIRST.\n+        - port to openbsd (another blatantly broken non-UNIX/POSIX platform).\n+        - fix eio_custom prototype.\n+        - work around a Linux (and likely FreeBSD and other kernels) bug\n+          where sendfile would not transfer all the requested bytes on\n+          large transfers, using a heuristic.\n+        - use libecb, and apply lots of minor space optimisations.\n+        - disable sendfile on darwin, broken as everything else.\n+        - add realpath request and implementation.\n+\t- cancelled requests will still invoke their request callbacks.\n+        - add fallocate.\n+        - do not acquire any locks when forking.\n+        - incorporated some mingw32 changes by traviscline.\n+        - added syncfs support, using direct syscall.\n+        - set thread name on linux (ps -L/Hcx, top, gdb).\n+        - remove useless use of volatile variables.\n+"}, {"sha": "1ed1324d304ebd61920cd1f89df05486f3dd49e1", "filename": "src/rt/libuv/src/unix/eio/LICENSE", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/eio/LICENSE"}, {"sha": "e9866c0d5e7c33d45c3239a916aaff1df1f80e48", "filename": "src/rt/libuv/src/unix/eio/Makefile.am", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -10,6 +10,6 @@ include_HEADERS = eio.h\n \n lib_LTLIBRARIES = libeio.la\n \n-libeio_la_SOURCES = eio.c xthread.h config.h\n+libeio_la_SOURCES = eio.c ecb.h xthread.h config.h\n libeio_la_LDFLAGS = -version-info $(VERSION_INFO)\n ", "previous_filename": "src/rt/libuv/src/eio/Makefile.am"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/unix/eio/aclocal.m4", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/eio/aclocal.m4"}, {"sha": "8056ee7f9be66c09300ec241e922550f7aab9d34", "filename": "src/rt/libuv/src/unix/eio/autogen.sh", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,3 @@\n+#!/bin/sh\n+\n+autoreconf --install --symlink --force"}, {"sha": "73e9dd07d280fe6d849e6e886690354b892d9b5e", "filename": "src/rt/libuv/src/unix/eio/config.h.in", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/eio/config.h.in"}, {"sha": "f64e7fe441a165f4019ea39277f0c6a818232b70", "filename": "src/rt/libuv/src/unix/eio/config_cygwin.h", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -7,6 +7,9 @@\n /* fdatasync(2) is available */\n #define HAVE_FDATASYNC 1\n \n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n /* futimes(2) is available */\n #define HAVE_FUTIMES 1\n ", "previous_filename": "src/rt/libuv/src/eio/config_cygwin.h"}, {"sha": "f406759e09e47afddb1a085dd84831636c5367b4", "filename": "src/rt/libuv/src/unix/eio/config_darwin.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,141 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fallocate(2) is available */\n+/* #undef HAVE_FALLOCATE */\n+\n+/* fdatasync(2) is available */\n+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060\n+#define HAVE_FDATASYNC 1\n+#else\n+#define HAVE_FDATASYNC 0\n+#endif\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* posix_fadvise(2) is available */\n+/* #undef HAVE_POSIX_FADVISE */\n+\n+/* posix_madvise(2) is available */\n+#define HAVE_POSIX_MADVISE 1\n+\n+/* prctl(PR_SET_NAME) is available */\n+/* #undef HAVE_PRCTL_SET_NAME */\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+#define HAVE_SENDFILE 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/prctl.h> header file. */\n+/* #undef HAVE_SYS_PRCTL_H */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* syscall(__NR_syncfs) is available */\n+/* #undef HAVE_SYS_SYNCFS */\n+\n+/* Define to 1 if you have the <sys/syscall.h> header file. */\n+#define HAVE_SYS_SYSCALL_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# define _ALL_SOURCE 1\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# define _GNU_SOURCE 1\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# define _POSIX_PTHREAD_SEMANTICS 1\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# define _TANDEM_SOURCE 1\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# define __EXTENSIONS__ 1\n+#endif\n+\n+\n+/* Version number of package */\n+#define VERSION \"1.0\"\n+\n+/* Define to 1 if on MINIX. */\n+/* #undef _MINIX */\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+/* #undef _POSIX_1_SOURCE */\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+/* #undef _POSIX_SOURCE */"}, {"sha": "3c93d260f7991925d93cd5f3f88475d8f27b0eec", "filename": "src/rt/libuv/src/unix/eio/config_freebsd.h", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -7,6 +7,9 @@\n /* fdatasync(2) is available */\n /* #undef HAVE_FDATASYNC */\n \n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n /* futimes(2) is available */\n #define HAVE_FUTIMES 1\n ", "previous_filename": "src/rt/libuv/src/eio/config_freebsd.h"}, {"sha": "606301faf2ac629fcb6b5ec2a8451913d4f51102", "filename": "src/rt/libuv/src/unix/eio/config_linux.h", "status": "renamed", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -2,19 +2,17 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n #include <linux/version.h>\n-\n-#define LINUX_VERSION_CODE_FOR(major, minor, patch) \\\n-  (((major & 255) << 16) | ((minor & 255) << 8) | (patch & 255))\n-\n-#define LINUX_VERSION_AT_LEAST(major, minor, patch) \\\n-  (LINUX_VERSION_CODE >= LINUX_VERSION_CODE_FOR(major, minor, patch))\n+#include <features.h>\n \n /* Define to 1 if you have the <dlfcn.h> header file. */\n #define HAVE_DLFCN_H 1\n \n /* fdatasync(2) is available */\n #define HAVE_FDATASYNC 1\n \n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n /* futimes(2) is available */\n #define HAVE_FUTIMES 1\n \n@@ -45,8 +43,12 @@\n /* Define to 1 if you have the <string.h> header file. */\n #define HAVE_STRING_H 1\n \n-/* sync_file_range(2) is available */\n-#define HAVE_SYNC_FILE_RANGE LINUX_VERSION_AT_LEAST(2, 6, 17)\n+/* sync_file_range(2) is available if kernel >= 2.6.17 and glibc >= 2.6 */\n+#if LINUX_VERSION_CODE >= 0x020611 && __GLIBC_PREREQ(2, 6)\n+#define HAVE_SYNC_FILE_RANGE 1\n+#else\n+#define HAVE_SYNC_FILE_RANGE 0\n+#endif\n \n /* Define to 1 if you have the <sys/stat.h> header file. */\n #define HAVE_SYS_STAT_H 1", "previous_filename": "src/rt/libuv/src/eio/config_linux.h"}, {"sha": "31f18e604656c50da7f64dad88bf944fc8e5db3a", "filename": "src/rt/libuv/src/unix/eio/config_netbsd.h", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -4,9 +4,11 @@\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #define HAVE_DLFCN_H 1\n \n-/* fdatasync(2) is not available on 10.5 but is on 10.6 \n- * How should we deal with this? */\n-/* #define HAVE_FDATASYNC 0 */\n+/* fdatasync(2) is available */\n+/* #undef HAVE_FDATASYNC */\n+\n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n \n /* futimes(2) is available */\n #define HAVE_FUTIMES 1\n@@ -24,7 +26,7 @@\n /* #undef HAVE_READAHEAD */\n \n /* sendfile(2) is available and supported */\n-#define HAVE_SENDFILE 1\n+#define HAVE_SENDFILE 0\n \n /* Define to 1 if you have the <stdint.h> header file. */\n #define HAVE_STDINT_H 1\n@@ -69,9 +71,6 @@\n /* Define to the one symbol short name of this package. */\n #define PACKAGE_TARNAME \"\"\n \n-/* Define to the home page for this package. */\n-#define PACKAGE_URL \"\"\n-\n /* Define to the version of this package. */\n #define PACKAGE_VERSION \"\"\n ", "previous_filename": "src/rt/libuv/src/eio/config_darwin.h"}, {"sha": "01d049c3e62b187ab21d9cda5af32eeb374951e3", "filename": "src/rt/libuv/src/unix/eio/config_sunos.h", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -7,6 +7,9 @@\n /* fdatasync(2) is available */\n #define HAVE_FDATASYNC 1\n \n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n /* futimes(2) is available */\n /* #undef HAVE_FUTIMES */\n ", "previous_filename": "src/rt/libuv/src/eio/config_sunos.h"}, {"sha": "9faffad538b29341e4b7ed294b4bd72d9b5f4ebf", "filename": "src/rt/libuv/src/unix/eio/configure.ac", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -5,17 +5,17 @@ AC_CONFIG_HEADERS([config.h])\n \n AM_INIT_AUTOMAKE(libeio,1.0)\n AM_MAINTAINER_MODE\n+\n+AC_GNU_SOURCE\n+\n AC_PROG_LIBTOOL\n \n AC_PROG_CC\n \n if test \"x$GCC\" = xyes ; then\n-  CFLAGS=\"$CFLAGS -O3\"\n+  CFLAGS=\"-O3 $CFLAGS\"\n fi\n \n-dnl somebody will forgive me\n-CFLAGS=\"-D_GNU_SOURCE $CFLAGS\"\n-\n m4_include([libeio.m4])\n \n AC_CONFIG_FILES([Makefile])", "previous_filename": "src/rt/libuv/src/eio/configure.ac"}, {"sha": "cbef59557fe0282dabc3df7bb42163f2ea8acac3", "filename": "src/rt/libuv/src/unix/eio/demo.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/eio/demo.c"}, {"sha": "a4aabc109163a51709820509bd42c0c53c55bc8e", "filename": "src/rt/libuv/src/unix/eio/ecb.h", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,370 @@\n+/*\n+ * libecb - http://software.schmorp.de/pkg/libecb\n+ *\n+ * Copyright (\u00a9) 2009-2011 Marc Alexander Lehmann <libecb@schmorp.de>\n+ * Copyright (\u00a9) 2011 Emanuele Giaquinta\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef ECB_H\n+#define ECB_H\n+\n+#ifdef _WIN32\n+  typedef   signed char   int8_t;\n+  typedef unsigned char  uint8_t;\n+  typedef   signed short  int16_t;\n+  typedef unsigned short uint16_t;\n+  typedef   signed int    int32_t;\n+  typedef unsigned int   uint32_t;\n+  #if __GNUC__\n+    typedef   signed long long int64_t;\n+    typedef unsigned long long uint64_t;\n+  #else /* _MSC_VER || __BORLANDC__ */\n+    typedef   signed __int64   int64_t;\n+    typedef unsigned __int64   uint64_t;\n+  #endif\n+#else\n+  #include <inttypes.h>\n+#endif\n+\n+/* many compilers define _GNUC_ to some versions but then only implement\n+ * what their idiot authors think are the \"more important\" extensions,\n+ * causing enourmous grief in return for some better fake benchmark numbers.\n+ * or so.\n+ * we try to detect these and simply assume they are not gcc - if they have\n+ * an issue with that they should have done it right in the first place.\n+ */\n+#ifndef ECB_GCC_VERSION\n+  #if !defined(__GNUC_MINOR__) || defined(__INTEL_COMPILER) || defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__llvm__) || defined(__clang__)\n+    #define ECB_GCC_VERSION(major,minor) 0\n+  #else\n+    #define ECB_GCC_VERSION(major,minor) (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor)))\n+  #endif\n+#endif\n+\n+/*****************************************************************************/\n+\n+#ifndef ECB_MEMORY_FENCE\n+  #if ECB_GCC_VERSION(2,5)\n+    #if defined(__x86) || defined(__i386)\n+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (\"lock; orb $0, -1(%%esp)\" : : : \"memory\")\n+      #define ECB_MEMORY_FENCE_ACQUIRE ECB_MEMORY_FENCE /* non-lock xchg might be enough */\n+      #define ECB_MEMORY_FENCE_RELEASE do { } while (0) /* unlikely to change in future cpus */\n+    #elif __amd64\n+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (\"mfence\" : : : \"memory\")\n+      #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ (\"lfence\" : : : \"memory\")\n+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ (\"sfence\") /* play safe - not needed in any current cpu */\n+    #endif\n+  #endif\n+#endif\n+\n+#ifndef ECB_MEMORY_FENCE\n+  #if ECB_GCC_VERSION(4,4)\n+    #define ECB_MEMORY_FENCE         __sync_synchronize ()\n+    #define ECB_MEMORY_FENCE_ACQUIRE ({ char dummy = 0; __sync_lock_test_and_set (&dummy, 1); })\n+    #define ECB_MEMORY_FENCE_RELEASE ({ char dummy = 1; __sync_lock_release      (&dummy   ); })\n+  #elif _MSC_VER >= 1400 /* VC++ 2005 */\n+    #pragma intrinsic(_ReadBarrier,_WriteBarrier,_ReadWriteBarrier)\n+    #define ECB_MEMORY_FENCE         _ReadWriteBarrier ()\n+    #define ECB_MEMORY_FENCE_ACQUIRE _ReadWriteBarrier () /* according to msdn, _ReadBarrier is not a load fence */\n+    #define ECB_MEMORY_FENCE_RELEASE _WriteBarrier ()\n+  #elif defined(_WIN32)\n+    #include <WinNT.h>\n+    #define ECB_MEMORY_FENCE         MemoryBarrier () /* actually just xchg on x86... scary */\n+    #define ECB_MEMORY_FENCE_ACQUIRE ECB_MEMORY_FENCE\n+    #define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE\n+  #endif\n+#endif\n+\n+#ifndef ECB_MEMORY_FENCE\n+  /*\n+   * if you get undefined symbol references to pthread_mutex_lock,\n+   * or failure to find pthread.h, then you should implement\n+   * the ECB_MEMORY_FENCE operations for your cpu/compiler\n+   * OR proide pthread.h and link against the posix thread library\n+   * of your system.\n+   */\n+  #include <pthread.h>\n+\n+  static pthread_mutex_t ecb_mf_lock = PTHREAD_MUTEX_INITIALIZER;\n+  #define ECB_MEMORY_FENCE do { pthread_mutex_lock (&ecb_mf_lock); pthread_mutex_unlock (&ecb_mf_lock); } while (0)\n+  #define ECB_MEMORY_FENCE_ACQUIRE ECB_MEMORY_FENCE\n+  #define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE\n+#endif\n+\n+/*****************************************************************************/\n+\n+#define ECB_C99 (__STDC_VERSION__ >= 199901L)\n+\n+#if __cplusplus\n+  #define ecb_inline static inline\n+#elif ECB_GCC_VERSION(2,5)\n+  #define ecb_inline static __inline__\n+#elif ECB_C99\n+  #define ecb_inline static inline\n+#else\n+  #define ecb_inline static\n+#endif\n+\n+#if ECB_GCC_VERSION(3,3)\n+  #define ecb_restrict __restrict__\n+#elif ECB_C99\n+  #define ecb_restrict restrict\n+#else\n+  #define ecb_restrict\n+#endif\n+\n+typedef int ecb_bool;\n+\n+#define ECB_CONCAT_(a, b) a ## b\n+#define ECB_CONCAT(a, b) ECB_CONCAT_(a, b)\n+#define ECB_STRINGIFY_(a) # a\n+#define ECB_STRINGIFY(a) ECB_STRINGIFY_(a)\n+\n+#define ecb_function_ ecb_inline\n+\n+#if ECB_GCC_VERSION(3,1)\n+  #define ecb_attribute(attrlist)        __attribute__(attrlist)\n+  #define ecb_is_constant(expr)          __builtin_constant_p (expr)\n+  #define ecb_expect(expr,value)         __builtin_expect ((expr),(value))\n+  #define ecb_prefetch(addr,rw,locality) __builtin_prefetch (addr, rw, locality)\n+#else\n+  #define ecb_attribute(attrlist)\n+  #define ecb_is_constant(expr)          0\n+  #define ecb_expect(expr,value)         (expr)\n+  #define ecb_prefetch(addr,rw,locality)\n+#endif\n+\n+/* no emulation for ecb_decltype */\n+#if ECB_GCC_VERSION(4,5)\n+  #define ecb_decltype(x) __decltype(x)\n+#elif ECB_GCC_VERSION(3,0)\n+  #define ecb_decltype(x) __typeof(x)\n+#endif\n+\n+#define ecb_noinline   ecb_attribute ((__noinline__))\n+#define ecb_noreturn   ecb_attribute ((__noreturn__))\n+#define ecb_unused     ecb_attribute ((__unused__))\n+#define ecb_const      ecb_attribute ((__const__))\n+#define ecb_pure       ecb_attribute ((__pure__))\n+\n+#if ECB_GCC_VERSION(4,3)\n+  #define ecb_artificial ecb_attribute ((__artificial__))\n+  #define ecb_hot        ecb_attribute ((__hot__))\n+  #define ecb_cold       ecb_attribute ((__cold__))\n+#else\n+  #define ecb_artificial\n+  #define ecb_hot\n+  #define ecb_cold\n+#endif\n+\n+/* put around conditional expressions if you are very sure that the  */\n+/* expression is mostly true or mostly false. note that these return */\n+/* booleans, not the expression.                                     */\n+#define ecb_expect_false(expr) ecb_expect (!!(expr), 0)\n+#define ecb_expect_true(expr)  ecb_expect (!!(expr), 1)\n+/* for compatibility to the rest of the world */\n+#define ecb_likely(expr)   ecb_expect_true  (expr)\n+#define ecb_unlikely(expr) ecb_expect_false (expr)\n+\n+/* count trailing zero bits and count # of one bits */\n+#if ECB_GCC_VERSION(3,4)\n+  /* we assume int == 32 bit, long == 32 or 64 bit and long long == 64 bit */\n+  #define ecb_ld32(x)      (__builtin_clz      (x) ^ 31)\n+  #define ecb_ld64(x)      (__builtin_clzll    (x) ^ 63)\n+  #define ecb_ctz32(x)      __builtin_ctz      (x)\n+  #define ecb_ctz64(x)      __builtin_ctzll    (x)\n+  #define ecb_popcount32(x) __builtin_popcount (x)\n+  /* no popcountll */\n+#else\n+  ecb_function_ int ecb_ctz32 (uint32_t x) ecb_const;\n+  ecb_function_ int\n+  ecb_ctz32 (uint32_t x)\n+  {\n+    int r = 0;\n+\n+    x &= ~x + 1; /* this isolates the lowest bit */\n+\n+#if ECB_branchless_on_i386\n+    r += !!(x & 0xaaaaaaaa) << 0;\n+    r += !!(x & 0xcccccccc) << 1;\n+    r += !!(x & 0xf0f0f0f0) << 2;\n+    r += !!(x & 0xff00ff00) << 3;\n+    r += !!(x & 0xffff0000) << 4;\n+#else\n+    if (x & 0xaaaaaaaa) r +=  1;\n+    if (x & 0xcccccccc) r +=  2;\n+    if (x & 0xf0f0f0f0) r +=  4;\n+    if (x & 0xff00ff00) r +=  8;\n+    if (x & 0xffff0000) r += 16;\n+#endif\n+\n+    return r;\n+  }\n+\n+  ecb_function_ int ecb_ctz64 (uint64_t x) ecb_const;\n+  ecb_function_ int\n+  ecb_ctz64 (uint64_t x)\n+  {\n+    int shift = x & 0xffffffffU ? 0 : 32;\n+    return ecb_ctz32 (x >> shift) + shift;\n+  }\n+\n+  ecb_function_ int ecb_popcount32 (uint32_t x) ecb_const;\n+  ecb_function_ int\n+  ecb_popcount32 (uint32_t x)\n+  {\n+    x -=  (x >> 1) & 0x55555555;\n+    x  = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n+    x  = ((x >> 4) + x) & 0x0f0f0f0f;\n+    x *= 0x01010101;\n+\n+    return x >> 24;\n+  }\n+\n+  /* you have the choice beetween something with a table lookup, */\n+  /* something using lots of bit arithmetic and a simple loop */\n+  /* we went for the loop */\n+  ecb_function_ int ecb_ld32 (uint32_t x) ecb_const;\n+  ecb_function_ int ecb_ld32 (uint32_t x)\n+  {\n+    int r = 0;\n+\n+    if (x >> 16) { x >>= 16; r += 16; }\n+    if (x >>  8) { x >>=  8; r +=  8; }\n+    if (x >>  4) { x >>=  4; r +=  4; }\n+    if (x >>  2) { x >>=  2; r +=  2; }\n+    if (x >>  1) {           r +=  1; }\n+\n+    return r;\n+  }\n+\n+  ecb_function_ int ecb_ld64 (uint64_t x) ecb_const;\n+  ecb_function_ int ecb_ld64 (uint64_t x)\n+  {\n+    int r = 0;\n+\n+    if (x >> 32) { x >>= 32; r += 32; }\n+\n+    return r + ecb_ld32 (x);\n+  }\n+#endif\n+\n+/* popcount64 is only available on 64 bit cpus as gcc builtin */\n+/* so for this version we are lazy */\n+ecb_function_ int ecb_popcount64 (uint64_t x) ecb_const;\n+ecb_function_ int\n+ecb_popcount64 (uint64_t x)\n+{\n+  return ecb_popcount32 (x) + ecb_popcount32 (x >> 32);\n+}\n+\n+ecb_inline uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count) ecb_const;\n+ecb_inline uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count) ecb_const;\n+ecb_inline uint16_t ecb_rotl16 (uint16_t x, unsigned int count) ecb_const;\n+ecb_inline uint16_t ecb_rotr16 (uint16_t x, unsigned int count) ecb_const;\n+ecb_inline uint32_t ecb_rotl32 (uint32_t x, unsigned int count) ecb_const;\n+ecb_inline uint32_t ecb_rotr32 (uint32_t x, unsigned int count) ecb_const;\n+ecb_inline uint64_t ecb_rotl64 (uint64_t x, unsigned int count) ecb_const;\n+ecb_inline uint64_t ecb_rotr64 (uint64_t x, unsigned int count) ecb_const;\n+\n+ecb_inline uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count) { return (x >> ( 8 - count)) | (x << count); }\n+ecb_inline uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count) { return (x << ( 8 - count)) | (x >> count); }\n+ecb_inline uint16_t ecb_rotl16 (uint16_t x, unsigned int count) { return (x >> (16 - count)) | (x << count); }\n+ecb_inline uint16_t ecb_rotr16 (uint16_t x, unsigned int count) { return (x << (16 - count)) | (x >> count); }\n+ecb_inline uint32_t ecb_rotl32 (uint32_t x, unsigned int count) { return (x >> (32 - count)) | (x << count); }\n+ecb_inline uint32_t ecb_rotr32 (uint32_t x, unsigned int count) { return (x << (32 - count)) | (x >> count); }\n+ecb_inline uint64_t ecb_rotl64 (uint64_t x, unsigned int count) { return (x >> (64 - count)) | (x << count); }\n+ecb_inline uint64_t ecb_rotr64 (uint64_t x, unsigned int count) { return (x << (64 - count)) | (x >> count); }\n+\n+#if ECB_GCC_VERSION(4,3)\n+  #define ecb_bswap16(x) (__builtin_bswap32 (x) >> 16)\n+  #define ecb_bswap32(x)  __builtin_bswap32 (x)\n+  #define ecb_bswap64(x)  __builtin_bswap64 (x)\n+#else\n+  ecb_function_ uint16_t ecb_bswap16 (uint16_t x) ecb_const;\n+  ecb_function_ uint16_t\n+  ecb_bswap16 (uint16_t x)\n+  {\n+    return ecb_rotl16 (x, 8);\n+  }\n+\n+  ecb_function_ uint32_t ecb_bswap32 (uint32_t x) ecb_const;\n+  ecb_function_ uint32_t\n+  ecb_bswap32 (uint32_t x)\n+  {\n+    return (((uint32_t)ecb_bswap16 (x)) << 16) | ecb_bswap16 (x >> 16);\n+  }\n+\n+  ecb_function_ uint64_t ecb_bswap64 (uint64_t x) ecb_const;\n+  ecb_function_ uint64_t\n+  ecb_bswap64 (uint64_t x)\n+  {\n+    return (((uint64_t)ecb_bswap32 (x)) << 32) | ecb_bswap32 (x >> 32);\n+  }\n+#endif\n+\n+#if ECB_GCC_VERSION(4,5)\n+  #define ecb_unreachable() __builtin_unreachable ()\n+#else\n+  /* this seems to work fine, but gcc always emits a warning for it :/ */\n+  ecb_function_ void ecb_unreachable (void) ecb_noreturn;\n+  ecb_function_ void ecb_unreachable (void) { }\n+#endif\n+\n+/* try to tell the compiler that some condition is definitely true */\n+#define ecb_assume(cond) do { if (!(cond)) ecb_unreachable (); } while (0)\n+\n+ecb_function_ unsigned char ecb_byteorder_helper (void) ecb_const;\n+ecb_function_ unsigned char\n+ecb_byteorder_helper (void)\n+{\n+  const uint32_t u = 0x11223344;\n+  return *(unsigned char *)&u;\n+}\n+\n+ecb_function_ ecb_bool ecb_big_endian    (void) ecb_const;\n+ecb_function_ ecb_bool ecb_big_endian    (void) { return ecb_byteorder_helper () == 0x11; }\n+ecb_function_ ecb_bool ecb_little_endian (void) ecb_const;\n+ecb_function_ ecb_bool ecb_little_endian (void) { return ecb_byteorder_helper () == 0x44; }\n+\n+#if ECB_GCC_VERSION(3,0) || ECB_C99\n+  #define ecb_mod(m,n) ((m) % (n) + ((m) % (n) < 0 ? (n) : 0))\n+#else\n+  #define ecb_mod(m,n) ((m) < 0 ? ((n) - 1 - ((-1 - (m)) % (n))) : ((m) % (n)))\n+#endif\n+\n+#if ecb_cplusplus_does_not_suck\n+  /* does not work for local types (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm) */\n+  template<typename T, int N>\n+  static inline int ecb_array_length (const T (&arr)[N])\n+  {\n+    return N;\n+  }\n+#else\n+  #define ecb_array_length(name) (sizeof (name) / sizeof (name [0]))\n+#endif\n+\n+#endif\n+"}, {"sha": "ec5bde33e1aec5e90582e23519fcc81a75517f8b", "filename": "src/rt/libuv/src/unix/eio/eio.3", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/eio/eio.3"}, {"sha": "a005db5d3b4b1ac86d9f5d059ff0a117836a6f43", "filename": "src/rt/libuv/src/unix/eio/eio.c", "status": "renamed", "additions": 1008, "deletions": 551, "changes": 1559, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -1,7 +1,7 @@\n /*\n  * libeio implementation\n  *\n- * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libeio@schmorp.de>\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libeio@schmorp.de>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without modifica-\n@@ -37,16 +37,22 @@\n  * either the BSD or the GPL.\n  */\n \n+#ifdef EIO_CONFIG_H\n+# include EIO_CONFIG_H\n+#endif\n+\n+/*  Undone by libuv for easy build scripts.\n+ * #ifndef _WIN32\n+ * # include \"config.h\"\n+ * #endif\n+ */\n+\n #include \"eio.h\"\n+#include \"ecb.h\"\n \n #ifdef EIO_STACKSIZE\n-# define XTHREAD_STACKSIZE EIO_STACKSIZE\n+# define X_STACKSIZE EIO_STACKSIZE\n #endif\n-\n-// For statically-linked pthreads-w32, use:\n-// #ifdef _WIN32\n-// # define PTW32_STATIC_LIB 1\n-// #endif\n #include \"xthread.h\"\n \n #include <errno.h>\n@@ -60,10 +66,25 @@\n #include <fcntl.h>\n #include <assert.h>\n \n-#ifndef _WIN32\n-#include <sys/statvfs.h>\n+/* intptr_t comes from unistd.h, says POSIX/UNIX/tradition */\n+/* intptr_t only comes from stdint.h, says idiot openbsd coder */\n+#if HAVE_STDINT_H\n+# include <stdint.h>\n #endif\n \n+#ifndef ECANCELED\n+# define ECANCELED EDOM\n+#endif\n+#ifndef ELOOP\n+# define ELOOP EDOM\n+#endif\n+\n+#if !defined(ENOTSOCK) && defined(WSAENOTSOCK)\n+# define ENOTSOCK WSAENOTSOCK\n+#endif\n+\n+static void eio_destroy (eio_req *req);\n+\n #ifndef EIO_FINISH\n # define EIO_FINISH(req)  ((req)->finish) && !EIO_CANCELLED (req) ? (req)->finish (req) : 0\n #endif\n@@ -76,65 +97,216 @@\n # define EIO_FEED(req)    do { if ((req)->feed   ) (req)->feed    (req); } while (0)\n #endif\n \n+#ifndef EIO_FD_TO_WIN32_HANDLE\n+# define EIO_FD_TO_WIN32_HANDLE(fd) _get_osfhandle (fd)\n+#endif\n+#ifndef EIO_WIN32_HANDLE_TO_FD\n+# define EIO_WIN32_HANDLE_TO_FD(handle) _open_osfhandle (handle, 0)\n+#endif\n+\n+#define EIO_ERRNO(errval,retval) ((errno = errval), retval)\n+\n+#define EIO_ENOSYS() EIO_ERRNO (ENOSYS, -1)\n+\n #ifdef _WIN32\n \n-# include <errno.h>\n-# include <sys/time.h>\n-# include <unistd.h>\n-# include <utime.h>\n-# include <signal.h>\n-# include <dirent.h>\n-# include <windows.h>\n+  #include <direct.h>\n \n-# define ENOTSOCK WSAENOTSOCK\n-# define EOPNOTSUPP WSAEOPNOTSUPP\n-# define ECANCELED 140\n+  #undef PAGESIZE\n+  #define PAGESIZE 4096 /* GetSystemInfo? */\n \n-# ifndef EIO_STRUCT_DIRENT\n-#  define EIO_STRUCT_DIRENT struct dirent\n-# endif\n+  /* TODO: look at how perl does stat (non-sloppy), unlink (ro-files), utime, link */\n \n-#else\n+  #ifdef EIO_STRUCT_STATI64\n+    /* look at perl's non-sloppy stat */\n+    #define stat(path,buf)       _stati64 (path,buf)\n+    #define fstat(fd,buf)        _fstati64 (fd,buf)\n+  #endif\n+  #define lstat(path,buf)      stat (path,buf)\n+  #define fsync(fd)            (FlushFileBuffers ((HANDLE)EIO_FD_TO_WIN32_HANDLE (fd)) ? 0 : EIO_ERRNO (EBADF, -1))\n+  #define mkdir(path,mode)     _mkdir (path)\n+  #define link(old,neu)        (CreateHardLink (neu, old, 0) ? 0 : EIO_ERRNO (ENOENT, -1))\n+\n+  #define chmod(path,mode)     _chmod (path, mode)\n+  #define dup(fd)              _dup (fd)\n+  #define dup2(fd1,fd2)        _dup2 (fd1, fd2)\n+\n+  #define fchmod(fd,mode)      EIO_ENOSYS ()\n+  #define chown(path,uid,gid)  EIO_ENOSYS ()\n+  #define fchown(fd,uid,gid)   EIO_ENOSYS ()\n+  #define truncate(path,offs)  EIO_ENOSYS () /* far-miss: SetEndOfFile */\n+  #define ftruncate(fd,offs)   EIO_ENOSYS () /* near-miss: SetEndOfFile */\n+  #define mknod(path,mode,dev) EIO_ENOSYS ()\n+  #define sync()               EIO_ENOSYS ()\n+  #define readlink(path,buf,s) EIO_ENOSYS ()\n+  #define statvfs(path,buf)    EIO_ENOSYS ()\n+  #define fstatvfs(fd,buf)     EIO_ENOSYS ()\n+\n+  #define getcwd(buf,s)        _getcwd(buf, s)\n+  #define rmdir(path)          _rmdir(path)\n+\n+  /* rename() uses MoveFile, which fails to overwrite */\n+  #define rename(old,neu)      eio__rename (old, neu)\n+\n+  static int\n+  eio__rename (const char *old, const char *neu)\n+  {\n+    if (MoveFileEx (old, neu, MOVEFILE_REPLACE_EXISTING))\n+      return 0;\n \n-# ifdef EIO_CONFIG_H\n-#  include EIO_CONFIG_H\n-# else\n-#  include \"config.h\"\n-# endif\n+    /* should steal _dosmaperr */\n+    switch (GetLastError ())\n+      {\n+        case ERROR_FILE_NOT_FOUND:\n+        case ERROR_PATH_NOT_FOUND:\n+        case ERROR_INVALID_DRIVE:\n+        case ERROR_NO_MORE_FILES:\n+        case ERROR_BAD_NETPATH:\n+        case ERROR_BAD_NET_NAME:\n+        case ERROR_BAD_PATHNAME:\n+        case ERROR_FILENAME_EXCED_RANGE:\n+          errno = ENOENT;\n+          break;\n \n-# include <sys/time.h>\n-# include <sys/select.h>\n-# include <unistd.h>\n-# include <utime.h>\n-# include <signal.h>\n-# include <dirent.h>\n+        default:\n+          errno = EACCES;\n+          break;\n+      }\n \n-#if _POSIX_MEMLOCK || _POSIX_MEMLOCK_RANGE || _POSIX_MAPPED_FILES\n-# include <sys/mman.h>\n+    return -1;\n+  }\n+\n+  /* we could even stat and see if it exists */\n+  static int\n+  symlink (const char *old, const char *neu)\n+  {\n+    #if WINVER >= 0x0600\n+      if (CreateSymbolicLink (neu, old, 1))\n+        return 0;\n+\n+      if (CreateSymbolicLink (neu, old, 0))\n+        return 0;\n+    #endif\n+\n+    return EIO_ERRNO (ENOENT, -1);\n+  }\n+\n+  /* POSIX API only */\n+  #ifndef CreateHardLink\n+  # define CreateHardLink(neu,old,flags) 0\n+  #endif\n+  #define CreateSymbolicLink(neu,old,flags) 0\n+\n+  struct statvfs\n+  {\n+    int dummy;\n+  };\n+\n+  #define DT_DIR EIO_DT_DIR\n+  #define DT_REG EIO_DT_REG\n+  #define D_NAME(entp) entp.cFileName\n+  #define D_TYPE(entp) (entp.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? DT_DIR : DT_REG)\n+\n+#include <sys/utime.h>\n+#define utime(path, times)   _utime(path, times)\n+#define utimbuf              _utimbuf\n+\n+#if defined(_MSC_VER) || defined(_MSC_EXTENSIONS)\n+  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64\n+#else\n+  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL\n #endif\n \n-/* POSIX_SOURCE is useless on bsd's, and XOPEN_SOURCE is unreliable there, too */\n-# if __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__\n-#  define _DIRENT_HAVE_D_TYPE /* sigh */\n-#  define D_INO(de) (de)->d_fileno\n-#  define D_NAMLEN(de) (de)->d_namlen\n-# elif __linux || defined d_ino || _XOPEN_SOURCE >= 600\n-#  define D_INO(de) (de)->d_ino\n-# endif\n+struct timezone \n+{\n+  int  tz_minuteswest; /* minutes W of Greenwich */\n+  int  tz_dsttime;     /* type of dst correction */\n+};\n+\n+static int gettimeofday(struct timeval *tv, struct timezone *tz)\n+{\n+  FILETIME ft;\n+  unsigned __int64 tmpres = 0;\n+  static int tzflag;\n+\n+  if (NULL != tv)\n+  {\n+    GetSystemTimeAsFileTime(&ft);\n+\n+    tmpres |= ft.dwHighDateTime;\n+    tmpres <<= 32;\n+    tmpres |= ft.dwLowDateTime;\n+\n+    /*converting file time to unix epoch*/\n+    tmpres -= DELTA_EPOCH_IN_MICROSECS; \n+    tmpres /= 10;  /*convert into microseconds*/\n+    tv->tv_sec = (long)(tmpres / 1000000UL);\n+    tv->tv_usec = (long)(tmpres % 1000000UL);\n+  }\n+\n+  if (NULL != tz)\n+  {\n+    if (!tzflag)\n+    {\n+      _tzset();\n+      tzflag++;\n+    }\n+    tz->tz_minuteswest = _timezone / 60;\n+    tz->tz_dsttime = _daylight;\n+  }\n+\n+  return 0;\n+}\n+\n+#else\n+\n+  #include <sys/time.h>\n+  #include <sys/select.h>\n+  #include <sys/statvfs.h>\n+  #include <unistd.h>\n+  #include <signal.h>\n+  #include <dirent.h>\n+\n+  #if _POSIX_MEMLOCK || _POSIX_MEMLOCK_RANGE || _POSIX_MAPPED_FILES\n+    #include <sys/mman.h>\n+  #endif\n+\n+  #define D_NAME(entp) entp->d_name\n+\n+  /* POSIX_SOURCE is useless on bsd's, and XOPEN_SOURCE is unreliable there, too */\n+  #if __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__\n+    #define _DIRENT_HAVE_D_TYPE /* sigh */\n+    #define D_INO(de) (de)->d_fileno\n+    #define D_NAMLEN(de) (de)->d_namlen\n+  #elif __linux || defined d_ino || _XOPEN_SOURCE >= 600\n+    #define D_INO(de) (de)->d_ino\n+  #endif\n+\n+  #ifdef _D_EXACT_NAMLEN\n+    #undef D_NAMLEN\n+    #define D_NAMLEN(de) _D_EXACT_NAMLEN (de)\n+  #endif\n+\n+  #ifdef _DIRENT_HAVE_D_TYPE\n+    #define D_TYPE(de) (de)->d_type\n+  #endif\n+\n+  #ifndef EIO_STRUCT_DIRENT\n+    #define EIO_STRUCT_DIRENT struct dirent\n+  #endif\n \n-#ifdef _D_EXACT_NAMLEN\n-# undef D_NAMLEN\n-# define D_NAMLEN(de) _D_EXACT_NAMLEN (de)\n #endif\n \n-# ifdef _DIRENT_HAVE_D_TYPE\n-#  define D_TYPE(de) (de)->d_type\n-# endif\n+#if HAVE_UTIMES\n+# include <utime.h>\n+#endif\n \n-# ifndef EIO_STRUCT_DIRENT\n-#  define EIO_STRUCT_DIRENT struct dirent\n-# endif\n+#if HAVE_SYS_SYSCALL_H\n+# include <sys/syscall.h>\n+#endif\n \n+#if HAVE_SYS_PRCTL_H\n+# include <sys/prctl.h>\n #endif\n \n #if HAVE_SENDFILE\n@@ -159,12 +331,9 @@\n # define D_INO(de) 0\n #endif\n #ifndef D_NAMLEN\n-# define D_NAMLEN(de) strlen ((de)->d_name)\n+# define D_NAMLEN(entp) strlen (D_NAME (entp))\n #endif\n \n-/* number of seconds after which an idle threads exit */\n-#define IDLE_TIMEOUT 10\n-\n /* used for struct dirent, AIX doesn't provide it */\n #ifndef NAME_MAX\n # define NAME_MAX 4096\n@@ -179,28 +348,15 @@\n #define EIO_BUFSIZE 65536\n \n #define dBUF\t \t\t\t\t\\\n-  char *eio_buf;\t\t\t\t\\\n-  ETP_WORKER_LOCK (self);\t\t\t\\\n-  self->dbuf = eio_buf = malloc (EIO_BUFSIZE);\t\\\n-  ETP_WORKER_UNLOCK (self);\t\t\t\\\n+  char *eio_buf = malloc (EIO_BUFSIZE);\t\t\\\n   errno = ENOMEM;\t\t\t\t\\\n   if (!eio_buf)\t\t\t\t\t\\\n-    return -1;\n+    return -1\n \n-#define EIO_TICKS ((1000000 + 1023) >> 10)\n+#define FUBd\t\t\t\t\t\\\n+  free (eio_buf)\n \n-/*****************************************************************************/\n-\n-#if __GNUC__ >= 3\n-# define expect(expr,value) __builtin_expect ((expr),(value))\n-#else\n-# define expect(expr,value) (expr)\n-#endif\n-\n-#define expect_false(expr) expect ((expr) != 0, 0)\n-#define expect_true(expr)  expect ((expr) != 0, 1)\n-\n-/*****************************************************************************/\n+#define EIO_TICKS ((1000000 + 1023) >> 10)\n \n #define ETP_PRI_MIN EIO_PRI_MIN\n #define ETP_PRI_MAX EIO_PRI_MAX\n@@ -214,29 +370,13 @@ static int eio_finish (eio_req *req);\n static void eio_execute (struct etp_worker *self, eio_req *req);\n #define ETP_EXECUTE(wrk,req) eio_execute (wrk,req)\n \n-#define ETP_WORKER_CLEAR(req)\t\\\n-  if (wrk->dbuf)\t\t\\\n-    {\t\t\t\t\\\n-      free (wrk->dbuf);\t\t\\\n-      wrk->dbuf = 0;\t\t\\\n-    }\t\t\t\t\\\n-\t\t\t\t\\\n-  if (wrk->dirp)\t\t\\\n-    {\t\t\t\t\\\n-      closedir (wrk->dirp);\t\\\n-      wrk->dirp = 0;\t\t\\\n-    }\n-\n-#define ETP_WORKER_COMMON \\\n-  void *dbuf;\t\\\n-  DIR *dirp;\n-\n /*****************************************************************************/\n \n #define ETP_NUM_PRI (ETP_PRI_MAX - ETP_PRI_MIN + 1)\n \n /* calculate time difference in ~1/EIO_TICKS of a second */\n-static int tvdiff (struct timeval *tv1, struct timeval *tv2)\n+ecb_inline int\n+tvdiff (struct timeval *tv1, struct timeval *tv2)\n {\n   return  (tv2->tv_sec  - tv1->tv_sec ) * EIO_TICKS\n        + ((tv2->tv_usec - tv1->tv_usec) >> 10);\n@@ -250,16 +390,23 @@ static void (*done_poll_cb) (void);\n static unsigned int max_poll_time;     /* reslock */\n static unsigned int max_poll_reqs;     /* reslock */\n \n-static volatile unsigned int nreqs;    /* reqlock */\n-static volatile unsigned int nready;   /* reqlock */\n-static volatile unsigned int npending; /* reqlock */\n-static volatile unsigned int max_idle = 4;\n-\n-static xmutex_t wrklock = X_MUTEX_INIT;\n-static xmutex_t reslock = X_MUTEX_INIT;\n-static xmutex_t reqlock = X_MUTEX_INIT;\n-static xcond_t  reqwait = X_COND_INIT;\n-\n+static unsigned int nreqs;    /* reqlock */\n+static unsigned int nready;   /* reqlock */\n+static unsigned int npending; /* reqlock */\n+static unsigned int max_idle = 4;      /* maximum number of threads that can idle indefinitely */\n+static unsigned int idle_timeout = 10; /* number of seconds after which an idle threads exit */\n+\n+static xmutex_t wrklock;\n+static xmutex_t reslock;\n+static xmutex_t reqlock;\n+static xcond_t  reqwait;\n+\n+/* Fix for test-fs-sir-writes-alot */\n+/* Apple's OSX can't safely write() concurrently from 2 threads */\n+/* for more info see the thread \"fs.write Data Munging\" in the nodejs google group */\n+/* http://groups.google.com/group/nodejs/browse_thread/thread/c11f8b683f37cef/b18ad9e0a15314c5 */\n+/* And the thread \"write()s and pwrite()s from multiple threads in OSX\" in libev@lists.schmorp.de */\n+/* http://lists.schmorp.de/pipermail/libev/2010q4/001185.html */\n #if defined (__APPLE__)\n static xmutex_t apple_bug_writelock = X_MUTEX_INIT;\n #endif\n@@ -270,7 +417,7 @@ static xmutex_t apple_bug_writelock = X_MUTEX_INIT;\n  * normal read/write by using a mutex. slows down execution a lot,\n  * but that's your problem, not mine.\n  */\n-static xmutex_t preadwritelock = X_MUTEX_INIT;\n+static xmutex_t preadwritelock;\n #endif\n \n typedef struct etp_worker\n@@ -283,30 +430,34 @@ typedef struct etp_worker\n   /* locked by reslock, reqlock or wrklock */\n   ETP_REQ *req; /* currently processed request */\n \n+#ifdef ETP_WORKER_COMMON\n   ETP_WORKER_COMMON\n+#endif\n } etp_worker;\n \n-static etp_worker wrk_first = { &wrk_first, &wrk_first, 0 }; /* NOT etp */\n+static etp_worker wrk_first; /* NOT etp */\n \n #define ETP_WORKER_LOCK(wrk)   X_LOCK   (wrklock)\n #define ETP_WORKER_UNLOCK(wrk) X_UNLOCK (wrklock)\n \n /* worker threads management */\n \n-static void etp_worker_clear (etp_worker *wrk)\n+static void ecb_cold\n+etp_worker_clear (etp_worker *wrk)\n {\n-  ETP_WORKER_CLEAR (wrk);\n }\n \n-static void etp_worker_free (etp_worker *wrk)\n+static void ecb_cold\n+etp_worker_free (etp_worker *wrk)\n {\n   wrk->next->prev = wrk->prev;\n   wrk->prev->next = wrk->next;\n \n   free (wrk);\n }\n \n-static unsigned int etp_nreqs (void)\n+static unsigned int\n+etp_nreqs (void)\n {\n   int retval;\n   if (WORDACCESS_UNSAFE) X_LOCK   (reqlock);\n@@ -315,7 +466,8 @@ static unsigned int etp_nreqs (void)\n   return retval;\n }\n \n-static unsigned int etp_nready (void)\n+static unsigned int\n+etp_nready (void)\n {\n   unsigned int retval;\n \n@@ -326,7 +478,8 @@ static unsigned int etp_nready (void)\n   return retval;\n }\n \n-static unsigned int etp_npending (void)\n+static unsigned int\n+etp_npending (void)\n {\n   unsigned int retval;\n \n@@ -337,7 +490,8 @@ static unsigned int etp_npending (void)\n   return retval;\n }\n \n-static unsigned int etp_nthreads (void)\n+static unsigned int\n+etp_nthreads (void)\n {\n   unsigned int retval;\n \n@@ -361,7 +515,19 @@ typedef struct {\n static etp_reqq req_queue;\n static etp_reqq res_queue;\n \n-static int reqq_push (etp_reqq *q, ETP_REQ *req)\n+static void ecb_noinline ecb_cold\n+reqq_init (etp_reqq *q)\n+{\n+  int pri;\n+\n+  for (pri = 0; pri < ETP_NUM_PRI; ++pri)\n+    q->qs[pri] = q->qe[pri] = 0;\n+\n+  q->size = 0;\n+}\n+\n+static int ecb_noinline\n+reqq_push (etp_reqq *q, ETP_REQ *req)\n {\n   int pri = req->pri;\n   req->next = 0;\n@@ -377,7 +543,8 @@ static int reqq_push (etp_reqq *q, ETP_REQ *req)\n   return q->size++;\n }\n \n-static ETP_REQ *reqq_shift (etp_reqq *q)\n+static ETP_REQ * ecb_noinline\n+reqq_shift (etp_reqq *q)\n {\n   int pri;\n \n@@ -402,69 +569,26 @@ static ETP_REQ *reqq_shift (etp_reqq *q)\n   abort ();\n }\n \n-static void etp_atfork_prepare (void)\n-{\n-  X_LOCK (wrklock);\n-  X_LOCK (reqlock);\n-  X_LOCK (reslock);\n-#if !HAVE_PREADWRITE\n-  X_LOCK (preadwritelock);\n-#endif\n-}\n-\n-static void etp_atfork_parent (void)\n-{\n-#if !HAVE_PREADWRITE\n-  X_UNLOCK (preadwritelock);\n-#endif\n-  X_UNLOCK (reslock);\n-  X_UNLOCK (reqlock);\n-  X_UNLOCK (wrklock);\n-}\n-\n-static void etp_atfork_child (void)\n+static int ecb_cold\n+etp_init (void (*want_poll)(void), void (*done_poll)(void))\n {\n-  ETP_REQ *prv;\n+  X_MUTEX_CREATE (wrklock);\n+  X_MUTEX_CREATE (reslock);\n+  X_MUTEX_CREATE (reqlock);\n+  X_COND_CREATE  (reqwait);\n \n-  while ((prv = reqq_shift (&req_queue)))\n-    ETP_DESTROY (prv);\n+  reqq_init (&req_queue);\n+  reqq_init (&res_queue);\n \n-  while ((prv = reqq_shift (&res_queue)))\n-    ETP_DESTROY (prv);\n-\n-  while (wrk_first.next != &wrk_first)\n-    {\n-      etp_worker *wrk = wrk_first.next;\n-\n-      if (wrk->req)\n-        ETP_DESTROY (wrk->req);\n-\n-      etp_worker_clear (wrk);\n-      etp_worker_free (wrk);\n-    }\n+  wrk_first.next =\n+  wrk_first.prev = &wrk_first;\n \n   started  = 0;\n   idle     = 0;\n   nreqs    = 0;\n   nready   = 0;\n   npending = 0;\n \n-  etp_atfork_parent ();\n-}\n-\n-static void\n-etp_once_init (void)\n-{    \n-  X_THREAD_ATFORK (etp_atfork_prepare, etp_atfork_parent, etp_atfork_child);\n-}\n-\n-static int\n-etp_init (void (*want_poll)(void), void (*done_poll)(void))\n-{\n-  static pthread_once_t doinit = PTHREAD_ONCE_INIT;\n-\n-  pthread_once (&doinit, etp_once_init);\n-\n   want_poll_cb = want_poll;\n   done_poll_cb = done_poll;\n \n@@ -473,7 +597,8 @@ etp_init (void (*want_poll)(void), void (*done_poll)(void))\n \n X_THREAD_PROC (etp_proc);\n \n-static void etp_start_thread (void)\n+static void ecb_cold\n+etp_start_thread (void)\n {\n   etp_worker *wrk = calloc (1, sizeof (etp_worker));\n \n@@ -496,19 +621,21 @@ static void etp_start_thread (void)\n   X_UNLOCK (wrklock);\n }\n \n-static void etp_maybe_start_thread (void)\n+static void\n+etp_maybe_start_thread (void)\n {\n-  if (expect_true (etp_nthreads () >= wanted))\n+  if (ecb_expect_true (etp_nthreads () >= wanted))\n     return;\n   \n   /* todo: maybe use idle here, but might be less exact */\n-  if (expect_true (0 <= (int)etp_nthreads () + (int)etp_npending () - (int)etp_nreqs ()))\n+  if (ecb_expect_true (0 <= (int)etp_nthreads () + (int)etp_npending () - (int)etp_nreqs ()))\n     return;\n \n   etp_start_thread ();\n }\n \n-static void etp_end_thread (void)\n+static void ecb_cold\n+etp_end_thread (void)\n {\n   eio_req *req = calloc (1, sizeof (eio_req));\n \n@@ -525,7 +652,8 @@ static void etp_end_thread (void)\n   X_UNLOCK (wrklock);\n }\n \n-static int etp_poll (void)\n+static int\n+etp_poll (void)\n {\n   unsigned int maxreqs;\n   unsigned int maxtime;\n@@ -565,19 +693,19 @@ static int etp_poll (void)\n       --nreqs;\n       X_UNLOCK (reqlock);\n \n-      if (expect_false (req->type == EIO_GROUP && req->size))\n+      if (ecb_expect_false (req->type == EIO_GROUP && req->size))\n         {\n           req->int1 = 1; /* mark request as delayed */\n           continue;\n         }\n       else\n         {\n           int res = ETP_FINISH (req);\n-          if (expect_false (res))\n+          if (ecb_expect_false (res))\n             return res;\n         }\n \n-      if (expect_false (maxreqs && !--maxreqs))\n+      if (ecb_expect_false (maxreqs && !--maxreqs))\n         break;\n \n       if (maxtime)\n@@ -593,23 +721,23 @@ static int etp_poll (void)\n   return -1;\n }\n \n-static void etp_cancel (ETP_REQ *req)\n+static void\n+etp_cancel (ETP_REQ *req)\n {\n-  X_LOCK   (wrklock);\n-  req->flags |= EIO_FLAG_CANCELLED;\n-  X_UNLOCK (wrklock);\n+  req->cancelled = 1;\n \n   eio_grp_cancel (req);\n }\n \n-static void etp_submit (ETP_REQ *req)\n+static void\n+etp_submit (ETP_REQ *req)\n {\n   req->pri -= ETP_PRI_MIN;\n \n-  if (expect_false (req->pri < ETP_PRI_MIN - ETP_PRI_MIN)) req->pri = ETP_PRI_MIN - ETP_PRI_MIN;\n-  if (expect_false (req->pri > ETP_PRI_MAX - ETP_PRI_MIN)) req->pri = ETP_PRI_MAX - ETP_PRI_MIN;\n+  if (ecb_expect_false (req->pri < ETP_PRI_MIN - ETP_PRI_MIN)) req->pri = ETP_PRI_MIN - ETP_PRI_MIN;\n+  if (ecb_expect_false (req->pri > ETP_PRI_MAX - ETP_PRI_MIN)) req->pri = ETP_PRI_MAX - ETP_PRI_MIN;\n \n-  if (expect_false (req->type == EIO_GROUP))\n+  if (ecb_expect_false (req->type == EIO_GROUP))\n     {\n       /* I hope this is worth it :/ */\n       X_LOCK (reqlock);\n@@ -638,34 +766,47 @@ static void etp_submit (ETP_REQ *req)\n     }\n }\n \n-static void etp_set_max_poll_time (double nseconds)\n+static void ecb_cold\n+etp_set_max_poll_time (double nseconds)\n {\n   if (WORDACCESS_UNSAFE) X_LOCK   (reslock);\n   max_poll_time = nseconds * EIO_TICKS;\n   if (WORDACCESS_UNSAFE) X_UNLOCK (reslock);\n }\n \n-static void etp_set_max_poll_reqs (unsigned int maxreqs)\n+static void ecb_cold\n+etp_set_max_poll_reqs (unsigned int maxreqs)\n {\n   if (WORDACCESS_UNSAFE) X_LOCK   (reslock);\n   max_poll_reqs = maxreqs;\n   if (WORDACCESS_UNSAFE) X_UNLOCK (reslock);\n }\n \n-static void etp_set_max_idle (unsigned int nthreads)\n+static void ecb_cold\n+etp_set_max_idle (unsigned int nthreads)\n+{\n+  if (WORDACCESS_UNSAFE) X_LOCK   (reqlock);\n+  max_idle = nthreads;\n+  if (WORDACCESS_UNSAFE) X_UNLOCK (reqlock);\n+}\n+\n+static void ecb_cold\n+etp_set_idle_timeout (unsigned int seconds)\n {\n   if (WORDACCESS_UNSAFE) X_LOCK   (reqlock);\n-  max_idle = nthreads <= 0 ? 1 : nthreads;\n+  idle_timeout = seconds;\n   if (WORDACCESS_UNSAFE) X_UNLOCK (reqlock);\n }\n \n-static void etp_set_min_parallel (unsigned int nthreads)\n+static void ecb_cold\n+etp_set_min_parallel (unsigned int nthreads)\n {\n   if (wanted < nthreads)\n     wanted = nthreads;\n }\n \n-static void etp_set_max_parallel (unsigned int nthreads)\n+static void ecb_cold\n+etp_set_max_parallel (unsigned int nthreads)\n {\n   if (wanted > nthreads)\n     wanted = nthreads;\n@@ -676,7 +817,8 @@ static void etp_set_max_parallel (unsigned int nthreads)\n \n /*****************************************************************************/\n \n-static void grp_try_feed (eio_req *grp)\n+static void\n+grp_try_feed (eio_req *grp)\n {\n   while (grp->size < grp->int2 && !EIO_CANCELLED (grp))\n     {\n@@ -693,7 +835,8 @@ static void grp_try_feed (eio_req *grp)\n     }\n }\n \n-static int grp_dec (eio_req *grp)\n+static int\n+grp_dec (eio_req *grp)\n {\n   --grp->size;\n \n@@ -707,15 +850,17 @@ static int grp_dec (eio_req *grp)\n     return 0;\n }\n \n-void eio_destroy (eio_req *req)\n+static void\n+eio_destroy (eio_req *req)\n {\n   if ((req)->flags & EIO_FLAG_PTR1_FREE) free (req->ptr1);\n   if ((req)->flags & EIO_FLAG_PTR2_FREE) free (req->ptr2);\n \n   EIO_DESTROY (req);\n }\n \n-static int eio_finish (eio_req *req)\n+static int\n+eio_finish (eio_req *req)\n {\n   int res = EIO_FINISH (req);\n \n@@ -733,7 +878,7 @@ static int eio_finish (eio_req *req)\n \n       res2 = grp_dec (grp);\n \n-      if (!res && res2)\n+      if (!res)\n         res = res2;\n     }\n \n@@ -742,63 +887,81 @@ static int eio_finish (eio_req *req)\n   return res;\n }\n \n-void eio_grp_cancel (eio_req *grp)\n+void\n+eio_grp_cancel (eio_req *grp)\n {\n   for (grp = grp->grp_first; grp; grp = grp->grp_next)\n     eio_cancel (grp);\n }\n \n-void eio_cancel (eio_req *req)\n+void\n+eio_cancel (eio_req *req)\n {\n   etp_cancel (req);\n }\n \n-void eio_submit (eio_req *req)\n+void\n+eio_submit (eio_req *req)\n {\n   etp_submit (req);\n }\n \n-unsigned int eio_nreqs (void)\n+unsigned int\n+eio_nreqs (void)\n {\n   return etp_nreqs ();\n }\n \n-unsigned int eio_nready (void)\n+unsigned int\n+eio_nready (void)\n {\n   return etp_nready ();\n }\n \n-unsigned int eio_npending (void)\n+unsigned int\n+eio_npending (void)\n {\n   return etp_npending ();\n }\n \n-unsigned int eio_nthreads (void)\n+unsigned int ecb_cold\n+eio_nthreads (void)\n {\n   return etp_nthreads ();\n }\n \n-void eio_set_max_poll_time (double nseconds)\n+void ecb_cold\n+eio_set_max_poll_time (double nseconds)\n {\n   etp_set_max_poll_time (nseconds);\n }\n \n-void eio_set_max_poll_reqs (unsigned int maxreqs)\n+void ecb_cold\n+eio_set_max_poll_reqs (unsigned int maxreqs)\n {\n   etp_set_max_poll_reqs (maxreqs);\n }\n \n-void eio_set_max_idle (unsigned int nthreads)\n+void ecb_cold\n+eio_set_max_idle (unsigned int nthreads)\n {\n   etp_set_max_idle (nthreads);\n }\n \n-void eio_set_min_parallel (unsigned int nthreads)\n+void ecb_cold\n+eio_set_idle_timeout (unsigned int seconds)\n+{\n+  etp_set_idle_timeout (seconds);\n+}\n+\n+void ecb_cold\n+eio_set_min_parallel (unsigned int nthreads)\n {\n   etp_set_min_parallel (nthreads);\n }\n \n-void eio_set_max_parallel (unsigned int nthreads)\n+void ecb_cold\n+eio_set_max_parallel (unsigned int nthreads)\n {\n   etp_set_max_parallel (nthreads);\n }\n@@ -817,10 +980,10 @@ int eio_poll (void)\n # define pread  eio__pread\n # define pwrite eio__pwrite\n \n-ssize_t\n+eio_ssize_t\n eio__pread (int fd, void *buf, size_t count, off_t offset)\n {\n-  ssize_t res;\n+  eio_ssize_t res;\n   off_t ooffset;\n \n   X_LOCK (preadwritelock);\n@@ -833,10 +996,10 @@ eio__pread (int fd, void *buf, size_t count, off_t offset)\n   return res;\n }\n \n-ssize_t\n+eio_ssize_t\n eio__pwrite (int fd, void *buf, size_t count, off_t offset)\n {\n-  ssize_t res;\n+  eio_ssize_t res;\n   off_t ooffset;\n \n   X_LOCK (preadwritelock);\n@@ -878,33 +1041,40 @@ eio__utimes (const char *filename, const struct timeval times[2])\n # undef futimes\n # define futimes(fd,times) eio__futimes (fd, times)\n \n-static int eio__futimes (int fd, const struct timeval tv[2])\n+static int\n+eio__futimes (int fd, const struct timeval tv[2])\n {\n   errno = ENOSYS;\n   return -1;\n }\n \n #endif\n \n-#ifdef _WIN32\n-# define fsync(fd) (FlushFileBuffers((HANDLE)_get_osfhandle(fd)) ? 0 : -1)\n-#endif\n-\n #if !HAVE_FDATASYNC\n # undef fdatasync\n # define fdatasync(fd) fsync (fd)\n #endif\n \n-// Use unicode and big file aware stat on windows\n-#ifdef _WIN32\n-# undef stat\n-# undef fstat\n-# define stat  _stati64\n-# define fstat _fstati64\n+static int\n+eio__syncfs (int fd)\n+{\n+  int res;\n+\n+#if HAVE_SYS_SYNCFS\n+  res = (int)syscall (__NR_syncfs, (int)(fd));\n+#else\n+  res = -1;\n+  errno = ENOSYS;\n #endif\n \n+  if (res < 0 && errno == ENOSYS && fd >= 0)\n+    sync ();\n+\n+  return res;\n+}\n+\n /* sync_file_range always needs emulation */\n-int\n+static int\n eio__sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags)\n {\n #if HAVE_SYNC_FILE_RANGE\n@@ -931,11 +1101,22 @@ eio__sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags)\n   return fdatasync (fd);\n }\n \n+static int\n+eio__fallocate (int fd, int mode, off_t offset, size_t len)\n+{\n+#if HAVE_FALLOCATE\n+  return fallocate (fd, mode, offset, len);\n+#else\n+  errno = ENOSYS;\n+  return -1;\n+#endif\n+}\n+\n #if !HAVE_READAHEAD\n # undef readahead\n # define readahead(fd,offset,count) eio__readahead (fd, offset, count, self)\n \n-static ssize_t\n+static eio_ssize_t\n eio__readahead (int fd, off_t offset, size_t count, etp_worker *self)\n {\n   size_t todo = count;\n@@ -950,145 +1131,455 @@ eio__readahead (int fd, off_t offset, size_t count, etp_worker *self)\n       todo   -= len;\n     }\n \n+  FUBd;\n+\n   errno = 0;\n   return count;\n }\n \n #endif\n \n /* sendfile always needs emulation */\n-static ssize_t\n-eio__sendfile (int ofd, int ifd, off_t offset, size_t count, etp_worker *self)\n+static eio_ssize_t\n+eio__sendfile (int ofd, int ifd, off_t offset, size_t count)\n {\n-  ssize_t res;\n+  eio_ssize_t written = 0;\n+  eio_ssize_t res;\n \n   if (!count)\n     return 0;\n \n+  for (;;)\n+    {\n+#ifdef __APPLE__\n+# undef HAVE_SENDFILE /* broken, as everything on os x */\n+#endif\n #if HAVE_SENDFILE\n # if __linux\n-  res = sendfile (ofd, ifd, &offset, count);\n+      off_t soffset = offset;\n+      res = sendfile (ofd, ifd, &soffset, count);\n \n # elif __FreeBSD__\n-  /*\n-   * Of course, the freebsd sendfile is a dire hack with no thoughts\n-   * wasted on making it similar to other I/O functions.\n-   */\n+      /*\n+       * Of course, the freebsd sendfile is a dire hack with no thoughts\n+       * wasted on making it similar to other I/O functions.\n+       */\n+      off_t sbytes;\n+      res = sendfile (ifd, ofd, offset, count, 0, &sbytes, 0);\n+\n+      #if 0 /* according to the manpage, this is correct, but broken behaviour */\n+      /* freebsd' sendfile will return 0 on success */\n+      /* freebsd 8 documents it as only setting *sbytes on EINTR and EAGAIN, but */\n+      /* not on e.g. EIO or EPIPE - sounds broken */\n+      if ((res < 0 && (errno == EAGAIN || errno == EINTR) && sbytes) || res == 0)\n+        res = sbytes;\n+      #endif\n+\n+      /* according to source inspection, this is correct, and useful behaviour */\n+      if (sbytes)\n+        res = sbytes;\n+\n+# elif defined (__APPLE__)\n+      off_t sbytes = count;\n+      res = sendfile (ifd, ofd, offset, &sbytes, 0, 0);\n+\n+      /* according to the manpage, sbytes is always valid */\n+      if (sbytes)\n+        res = sbytes;\n+\n+# elif __hpux\n+      res = sendfile (ofd, ifd, offset, count, 0, 0);\n+\n+# elif __solaris\n+      struct sendfilevec vec;\n+      size_t sbytes;\n+\n+      vec.sfv_fd   = ifd;\n+      vec.sfv_flag = 0;\n+      vec.sfv_off  = offset;\n+      vec.sfv_len  = count;\n+\n+      res = sendfilev (ofd, &vec, 1, &sbytes);\n+\n+      if (res < 0 && sbytes)\n+        res = sbytes;\n+\n+# endif\n+\n+#elif defined (_WIN32) && 0\n+      /* does not work, just for documentation of what would need to be done */\n+      /* actually, cannot be done like this, as TransmitFile changes the file offset, */\n+      /* libeio guarantees that the file offset does not change, and windows */\n+      /* has no way to get an independent handle to the same file description */\n+      HANDLE h = TO_SOCKET (ifd);\n+      SetFilePointer (h, offset, 0, FILE_BEGIN);\n+      res = TransmitFile (TO_SOCKET (ofd), h, count, 0, 0, 0, 0);\n+\n+#else\n+      res = -1;\n+      errno = ENOSYS;\n+#endif\n+\n+      /* we assume sendfile can copy at least 128mb in one go */\n+      if (res <= 128 * 1024 * 1024)\n+        {\n+          if (res > 0)\n+            written += res;\n+\n+          if (written)\n+            return written;\n+\n+          break;\n+        }\n+      else\n+        {\n+          /* if we requested more, then probably the kernel was lazy */\n+          written += res;\n+          offset  += res;\n+          count   -= res;\n+\n+          if (!count)\n+            return written;\n+        }\n+    }\n+\n+  if (res < 0\n+      && (errno == ENOSYS || errno == EINVAL || errno == ENOTSOCK\n+          /* BSDs */\n+#ifdef ENOTSUP /* sigh, if the steenking pile called openbsd would only try to at least compile posix code... */\n+          || errno == ENOTSUP\n+#endif\n+#ifdef EOPNOTSUPP /* windows */\n+          || errno == EOPNOTSUPP /* BSDs */\n+#endif\n+#if __solaris\n+          || errno == EAFNOSUPPORT || errno == EPROTOTYPE\n+#endif\n+         )\n+      )\n+    {\n+      /* emulate sendfile. this is a major pain in the ass */\n+      dBUF;\n+\n+      res = 0;\n+\n+      while (count)\n+        {\n+          eio_ssize_t cnt;\n+          \n+          cnt = pread (ifd, eio_buf, count > EIO_BUFSIZE ? EIO_BUFSIZE : count, offset);\n+\n+          if (cnt <= 0)\n+            {\n+              if (cnt && !res) res = -1;\n+              break;\n+            }\n+\n+          cnt = write (ofd, eio_buf, cnt);\n+\n+          if (cnt <= 0)\n+            {\n+              if (cnt && !res) res = -1;\n+              break;\n+            }\n+\n+          offset += cnt;\n+          res    += cnt;\n+          count  -= cnt;\n+        }\n+\n+      FUBd;\n+    }\n+\n+  return res;\n+}\n+\n+#ifdef PAGESIZE\n+# define eio_pagesize() PAGESIZE\n+#else\n+static intptr_t\n+eio_pagesize (void)\n+{\n+  static intptr_t page;\n+\n+  if (!page)\n+    page = sysconf (_SC_PAGESIZE);\n+\n+  return page;\n+}\n+#endif\n+\n+static void\n+eio_page_align (void **addr, size_t *length)\n+{\n+  intptr_t mask = eio_pagesize () - 1;\n+\n+  /* round down addr */\n+  intptr_t adj = mask & (intptr_t)*addr;\n+\n+  *addr   = (void *)((intptr_t)*addr - adj);\n+  *length += adj;\n+\n+  /* round up length */\n+  *length = (*length + mask) & ~mask;\n+}\n+\n+#if !_POSIX_MEMLOCK\n+# define eio__mlockall(a) EIO_ENOSYS ()\n+#else\n+\n+static int\n+eio__mlockall (int flags)\n+{\n+  #if __GLIBC__ == 2 && __GLIBC_MINOR__ <= 7\n+    extern int mallopt (int, int);\n+    mallopt (-6, 238); /* http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=473812 */\n+  #endif\n+\n+  if (EIO_MCL_CURRENT   != MCL_CURRENT\n+      || EIO_MCL_FUTURE != MCL_FUTURE)\n+    {\n+      flags = 0\n+         | (flags & EIO_MCL_CURRENT ? MCL_CURRENT : 0)\n+         | (flags & EIO_MCL_FUTURE  ? MCL_FUTURE : 0);\n+    }\n+\n+  return mlockall (flags);\n+}\n+#endif\n+\n+#if !_POSIX_MEMLOCK_RANGE\n+# define eio__mlock(a,b) EIO_ENOSYS ()\n+#else\n+\n+static int\n+eio__mlock (void *addr, size_t length)\n+{\n+  eio_page_align (&addr, &length);\n+\n+  return mlock (addr, length);\n+}\n+\n+#endif\n+\n+#if !(_POSIX_MAPPED_FILES && _POSIX_SYNCHRONIZED_IO)\n+# define eio__msync(a,b,c) EIO_ENOSYS ()\n+#else\n+\n+static int\n+eio__msync (void *mem, size_t len, int flags)\n+{\n+  eio_page_align (&mem, &len);\n+\n+  if (EIO_MS_ASYNC         != MS_SYNC\n+      || EIO_MS_INVALIDATE != MS_INVALIDATE\n+      || EIO_MS_SYNC       != MS_SYNC)\n+    {\n+      flags = 0\n+         | (flags & EIO_MS_ASYNC      ? MS_ASYNC : 0)\n+         | (flags & EIO_MS_INVALIDATE ? MS_INVALIDATE : 0)\n+         | (flags & EIO_MS_SYNC       ? MS_SYNC : 0);\n+    }\n+\n+  return msync (mem, len, flags);\n+}\n+\n+#endif\n+\n+static int\n+eio__mtouch (eio_req *req)\n+{\n+  void *mem  = req->ptr2;\n+  size_t len = req->size;\n+  int flags  = req->int1;\n+\n+  eio_page_align (&mem, &len);\n+\n   {\n-    off_t sbytes;\n-    res = sendfile (ifd, ofd, offset, count, 0, &sbytes, 0);\n-\n-    #if 0 /* according to the manpage, this is correct, but broken behaviour */\n-    /* freebsd' sendfile will return 0 on success */\n-    /* freebsd 8 documents it as only setting *sbytes on EINTR and EAGAIN, but */\n-    /* not on e.g. EIO or EPIPE - sounds broken */\n-    if ((res < 0 && (errno == EAGAIN || errno == EINTR) && sbytes) || res == 0)\n-      res = sbytes;\n-    #endif\n+    intptr_t addr = (intptr_t)mem;\n+    intptr_t end = addr + len;\n+    intptr_t page = eio_pagesize ();\n \n-    /* according to source inspection, this is correct, and useful behaviour */\n-    if (sbytes)\n-      res = sbytes;\n+    if (addr < end)\n+      if (flags & EIO_MT_MODIFY) /* modify */\n+        do { *((volatile sig_atomic_t *)addr) |= 0; } while ((addr += page) < len && !EIO_CANCELLED (req));\n+      else\n+        do { *((volatile sig_atomic_t *)addr)     ; } while ((addr += page) < len && !EIO_CANCELLED (req));\n   }\n \n-# elif defined (__APPLE__)\n+  return 0;\n+}\n+\n+/*****************************************************************************/\n+/* requests implemented outside eio_execute, because they are so large */\n+\n+static void\n+eio__realpath (eio_req *req, etp_worker *self)\n+{\n+  char *rel = req->ptr1;\n+  char *res;\n+  char *tmp1, *tmp2;\n+#if SYMLOOP_MAX > 32\n+  int symlinks = SYMLOOP_MAX;\n+#else\n+  int symlinks = 32;\n+#endif\n+\n+  req->result = -1;\n+\n+  errno = EINVAL;\n+  if (!rel)\n+    return;\n+\n+  errno = ENOENT;\n+  if (!*rel)\n+    return;\n+\n+  if (!req->ptr2)\n+    {\n+      X_LOCK (wrklock);\n+      req->flags |= EIO_FLAG_PTR2_FREE;\n+      X_UNLOCK (wrklock);\n+      req->ptr2 = malloc (PATH_MAX * 3);\n+\n+      errno = ENOMEM;\n+      if (!req->ptr2)\n+        return;\n+    }\n+\n+  res  = req->ptr2;\n+  tmp1 = res  + PATH_MAX;\n+  tmp2 = tmp1 + PATH_MAX;\n+\n+#if 0 /* disabled, the musl way to do things is just too racy */\n+#if __linux && defined(O_NONBLOCK) && defined(O_NOATIME)\n+  /* on linux we may be able to ask the kernel */\n+  {\n+    int fd = open (rel, O_RDONLY | O_NONBLOCK | O_NOCTTY | O_NOATIME);\n+\n+    if (fd >= 0)\n+      {\n+        sprintf (tmp1, \"/proc/self/fd/%d\", fd);\n+        req->result = readlink (tmp1, res, PATH_MAX);\n+        close (fd);\n+\n+        /* here we should probably stat the open file and the disk file, to make sure they still match */\n+\n+        if (req->result > 0)\n+          goto done;\n+      }\n+    else if (errno == ELOOP || errno == ENAMETOOLONG || errno == ENOENT || errno == ENOTDIR || errno == EIO)\n+      return;\n+  }\n+#endif\n+#endif\n+\n+  if (*rel != '/')\n+    {\n+      if (!getcwd (res, PATH_MAX))\n+        return;\n+\n+      if (res [1]) /* only use if not / */\n+        res += strlen (res);\n+    }\n+\n+  while (*rel)\n+    {\n+      eio_ssize_t len, linklen;\n+      char *beg = rel;\n+\n+      while (*rel && *rel != '/')\n+        ++rel;\n+\n+      len = rel - beg;\n+\n+      if (!len) /* skip slashes */\n+        {\n+          ++rel;\n+          continue;\n+        }\n \n-  {\n-    off_t sbytes = count;\n-    res = sendfile (ifd, ofd, offset, &sbytes, 0, 0);\n+      if (beg [0] == '.')\n+        {\n+          if (len == 1)\n+            continue; /* . - nop */\n \n-    /* according to the manpage, sbytes is always valid */\n-    if (sbytes)\n-      res = sbytes;\n-  }\n+          if (beg [1] == '.' && len == 2)\n+            {\n+              /* .. - back up one component, if possible */\n \n-# elif __hpux\n-  res = sendfile (ofd, ifd, offset, count, 0, 0);\n+              while (res != req->ptr2)\n+                if (*--res == '/')\n+                  break;\n \n-# elif __solaris\n-  {\n-    struct sendfilevec vec;\n-    size_t sbytes;\n+              continue;\n+            }\n+        }\n \n-    vec.sfv_fd   = ifd;\n-    vec.sfv_flag = 0;\n-    vec.sfv_off  = offset;\n-    vec.sfv_len  = count;\n+        errno = ENAMETOOLONG;\n+        if (res + 1 + len + 1 >= tmp1)\n+          return;\n \n-    res = sendfilev (ofd, &vec, 1, &sbytes);\n+        /* copy one component */\n+        *res = '/';\n+        memcpy (res + 1, beg, len);\n \n-    if (res < 0 && sbytes)\n-      res = sbytes;\n-  }\n+        /* zero-terminate, for readlink */\n+        res [len + 1] = 0;\n \n-# endif\n+        /* now check if it's a symlink */\n+        linklen = readlink (req->ptr2, tmp1, PATH_MAX);\n \n-//#elif defined (_WIN32)\n-//\n-//  /* does not work, just for documentation of what would need to be done */\n-//  {\n-//    HANDLE h = TO_SOCKET (ifd);\n-//    SetFilePointer (h, offset, 0, FILE_BEGIN);\n-//    res = TransmitFile (TO_SOCKET (ofd), h, count, 0, 0, 0, 0);\n-//  }\n+        if (linklen < 0)\n+          {\n+            if (errno != EINVAL)\n+              return;\n \n-#else\n-  res = -1;\n-  errno = ENOSYS;\n-#endif\n+            /* it's a normal directory. hopefully */\n+            res += len + 1;\n+          }\n+        else\n+          {\n+            /* yay, it was a symlink - build new path in tmp2 */\n+            int rellen = strlen (rel);\n \n-  if (res <  0\n-      && (errno == ENOSYS || errno == EINVAL || errno == ENOTSOCK\n-          /* BSDs */\n-#ifdef ENOTSUP /* sigh, if the steenking pile called openbsd would only try to at least compile posix code... */\n-          || errno == ENOTSUP\n-#endif\n-          || errno == EOPNOTSUPP /* BSDs */\n-#if __solaris\n-          || errno == EAFNOSUPPORT || errno == EPROTOTYPE\n-#endif\n-         )\n-      )\n-    {\n-      /* emulate sendfile. this is a major pain in the ass */\n-      dBUF;\n+            errno = ENAMETOOLONG;\n+            if (linklen + 1 + rellen >= PATH_MAX)\n+              return;\n \n-      res = 0;\n+            errno = ELOOP;\n+            if (!--symlinks)\n+              return;\n \n-      while (count)\n-        {\n-          ssize_t cnt;\n-          \n-          cnt = pread (ifd, eio_buf, count > EIO_BUFSIZE ? EIO_BUFSIZE : count, offset);\n+            if (*tmp1 == '/')\n+              res = req->ptr2; /* symlink resolves to an absolute path */\n \n-          if (cnt <= 0)\n-            {\n-              if (cnt && !res) res = -1;\n-              break;\n-            }\n+            /* we need to be careful, as rel might point into tmp2 already */\n+            memmove (tmp2 + linklen + 1, rel, rellen + 1);\n+            tmp2 [linklen] = '/';\n+            memcpy (tmp2, tmp1, linklen);\n \n-          cnt = write (ofd, eio_buf, cnt);\n+            rel = tmp2;\n+          }\n+    }\n \n-          if (cnt <= 0)\n-            {\n-              if (cnt && !res) res = -1;\n-              break;\n-            }\n+  /* special case for the lone root path */\n+  if (res == req->ptr2)\n+    *res++ = '/';\n \n-          offset += cnt;\n-          res    += cnt;\n-          count  -= cnt;\n-        }\n-    }\n+  req->result = res - (char *)req->ptr2;\n \n-  return res;\n+done:\n+  req->ptr2 = realloc (req->ptr2, req->result); /* trade time for space savings */\n }\n \n static signed char\n eio_dent_cmp (const eio_dirent *a, const eio_dirent *b)\n {\n-    return a->score - b->score ? a->score - b->score /* works because our signed char is always 0..100 */\n-              : a->inode < b->inode ? -1 : a->inode > b->inode ? 1 : 0;\n+  return a->score - b->score ? a->score - b->score /* works because our signed char is always 0..100 */\n+       : a->inode < b->inode ? -1\n+       : a->inode > b->inode ?  1\n+       :                        0;\n }\n \n #define EIO_DENT_CMP(i,op,j) eio_dent_cmp (&i, &j) op 0\n@@ -1097,41 +1588,41 @@ eio_dent_cmp (const eio_dirent *a, const eio_dirent *b)\n #define EIO_SORT_FAST   60 /* when to only use insertion sort */\n \n static void\n-eio_dent_radix_sort (eio_dirent *dents, int size, signed char score_bits, ino_t inode_bits)\n+eio_dent_radix_sort (eio_dirent *dents, int size, signed char score_bits, eio_ino_t inode_bits)\n {\n-  unsigned char bits [9 + sizeof (ino_t) * 8];\n+  unsigned char bits [9 + sizeof (eio_ino_t) * 8];\n   unsigned char *bit = bits;\n \n   assert (CHAR_BIT == 8);\n   assert (sizeof (eio_dirent) * 8 < 256);\n-  assert (offsetof (eio_dirent, inode)); /* we use 0 as sentinel */\n-  assert (offsetof (eio_dirent, score)); /* we use 0 as sentinel */\n+  assert (offsetof (eio_dirent, inode)); /* we use bit #0 as sentinel */\n+  assert (offsetof (eio_dirent, score)); /* we use bit #0 as sentinel */\n \n   if (size <= EIO_SORT_FAST)\n     return;\n \n   /* first prepare an array of bits to test in our radix sort */\n-  /* try to take endianness into account, as well as differences in ino_t sizes */\n+  /* try to take endianness into account, as well as differences in eio_ino_t sizes */\n   /* inode_bits must contain all inodes ORed together */\n   /* which is used to skip bits that are 0 everywhere, which is very common */\n   {\n-    ino_t endianness;\n+    eio_ino_t endianness;\n     int i, j;\n \n     /* we store the byte offset of byte n into byte n of \"endianness\" */\n-    for (i = 0; i < sizeof (ino_t); ++i)\n+    for (i = 0; i < sizeof (eio_ino_t); ++i)\n       ((unsigned char *)&endianness)[i] = i;\n \n     *bit++ = 0;\n \n-    for (i = 0; i < sizeof (ino_t); ++i)\n+    for (i = 0; i < sizeof (eio_ino_t); ++i)\n       {\n         /* shifting off the byte offsets out of \"endianness\" */\n         int offs = (offsetof (eio_dirent, inode) + (endianness & 0xff)) * 8;\n         endianness >>= 8;\n \n         for (j = 0; j < 8; ++j)\n-          if (inode_bits & (((ino_t)1) << (i * 8 + j)))\n+          if (inode_bits & (((eio_ino_t)1) << (i * 8 + j)))\n             *bit++ = offs + j;\n       }\n \n@@ -1142,9 +1633,9 @@ eio_dent_radix_sort (eio_dirent *dents, int size, signed char score_bits, ino_t\n \n   /* now actually do the sorting (a variant of MSD radix sort) */\n   {\n-    eio_dirent    *base_stk [9 + sizeof (ino_t) * 8], *base;\n-    eio_dirent    *end_stk  [9 + sizeof (ino_t) * 8], *end;\n-    unsigned char *bit_stk  [9 + sizeof (ino_t) * 8];\n+    eio_dirent    *base_stk [9 + sizeof (eio_ino_t) * 8], *base;\n+    eio_dirent    *end_stk  [9 + sizeof (eio_ino_t) * 8], *end;\n+    unsigned char *bit_stk  [9 + sizeof (eio_ino_t) * 8];\n     int stk_idx = 0;\n \n     base_stk [stk_idx] = dents;\n@@ -1233,7 +1724,7 @@ eio_dent_insertion_sort (eio_dirent *dents, int size)\n }\n \n static void\n-eio_dent_sort (eio_dirent *dents, int size, signed char score_bits, ino_t inode_bits)\n+eio_dent_sort (eio_dirent *dents, int size, signed char score_bits, eio_ino_t inode_bits)\n {\n   if (size <= 1)\n     return; /* our insertion sort relies on size > 0 */\n@@ -1251,47 +1742,112 @@ eio_dent_sort (eio_dirent *dents, int size, signed char score_bits, ino_t inode_\n static void\n eio__scandir (eio_req *req, etp_worker *self)\n {\n-  DIR *dirp;\n-  EIO_STRUCT_DIRENT *entp;\n   char *name, *names;\n-  int namesalloc = 4096;\n+  int namesalloc = 4096 - sizeof (void *) * 4;\n   int namesoffs = 0;\n   int flags = req->int1;\n   eio_dirent *dents = 0;\n   int dentalloc = 128;\n   int dentoffs = 0;\n-  ino_t inode_bits = 0;\n+  eio_ino_t inode_bits = 0;\n+#ifdef _WIN32\n+  HANDLE dirp;\n+  WIN32_FIND_DATA entp;\n+#else\n+  DIR *dirp;\n+  EIO_STRUCT_DIRENT *entp;\n+#endif\n \n   req->result = -1;\n \n   if (!(flags & EIO_READDIR_DENTS))\n     flags &= ~(EIO_READDIR_DIRS_FIRST | EIO_READDIR_STAT_ORDER);\n \n-  X_LOCK (wrklock);\n-  /* the corresponding closedir is in ETP_WORKER_CLEAR */\n-  self->dirp = dirp = opendir (req->ptr1);\n+#ifdef _WIN32\n+  {\n+    int len = strlen ((const char *)req->ptr1);\n+    char *path = malloc (MAX_PATH);\n+    const char *fmt;\n+\n+    if (!len)\n+      fmt = \"./*\";\n+    else if (((const char *)req->ptr1)[len - 1] == '/' || ((const char *)req->ptr1)[len - 1] == '\\\\')\n+      fmt = \"%s*\";\n+    else\n+      fmt = \"%s/*\";\n+\n+    _snprintf (path, MAX_PATH, fmt, (const char *)req->ptr1);\n+    dirp = FindFirstFile (path, &entp);\n+    free (path);\n+\n+    if (dirp == INVALID_HANDLE_VALUE)\n+     {\n+       dirp = 0;\n+\n+        /* should steal _dosmaperr */\n+        switch (GetLastError ())\n+          {\n+            case ERROR_FILE_NOT_FOUND:\n+              req->result = 0;\n+              break;\n+\n+            case ERROR_INVALID_NAME:\n+            case ERROR_PATH_NOT_FOUND:\n+            case ERROR_NO_MORE_FILES:\n+              errno = ENOENT;\n+              break;\n+\n+            case ERROR_NOT_ENOUGH_MEMORY:\n+              errno = ENOMEM;\n+              break;\n+\n+            default:\n+              errno = EINVAL;\n+              break;\n+          }\n+     }\n+  }\n+#else\n+  dirp = opendir (req->ptr1);\n+#endif\n+\n+  if (req->flags & EIO_FLAG_PTR1_FREE)\n+    free (req->ptr1);\n+\n   req->flags |= EIO_FLAG_PTR1_FREE | EIO_FLAG_PTR2_FREE;\n   req->ptr1 = dents = flags ? malloc (dentalloc * sizeof (eio_dirent)) : 0;\n   req->ptr2 = names = malloc (namesalloc);\n-  X_UNLOCK (wrklock);\n \n   if (dirp && names && (!flags || dents))\n     for (;;)\n       {\n+        int done;\n+\n+#ifdef _WIN32\n+        done = !dirp;\n+#else\n         errno = 0;\n         entp = readdir (dirp);\n+        done = !entp;\n+#endif\n \n-        if (!entp)\n+        if (done)\n           {\n+#ifndef _WIN32\n+            int old_errno = errno;\n+            closedir (dirp);\n+            errno = old_errno;\n+\n             if (errno)\n               break;\n+#endif\n \n             /* sort etc. */\n             req->int1   = flags;\n             req->result = dentoffs;\n \n             if (flags & EIO_READDIR_STAT_ORDER)\n-              eio_dent_sort (dents, dentoffs, 0, inode_bits); /* sort by inode exclusively */\n+              eio_dent_sort (dents, dentoffs, flags & EIO_READDIR_DIRS_FIRST ? 7 : 0, inode_bits);\n             else if (flags & EIO_READDIR_DIRS_FIRST)\n               if (flags & EIO_READDIR_FOUND_UNKNOWN)\n                 eio_dent_sort (dents, dentoffs, 7, inode_bits); /* sort by score and inode */\n@@ -1303,7 +1859,6 @@ eio__scandir (eio_req *req, etp_worker *self)\n \n                   /* now partition dirs to the front, and non-dirs to the back */\n                   /* by walking from both sides and swapping if necessary */\n-                  /* also clear score, so it doesn't influence sorting */\n                   while (oth > dir)\n                     {\n                       if (dir->type == EIO_DT_DIR)\n@@ -1316,27 +1871,25 @@ eio__scandir (eio_req *req, etp_worker *self)\n                         }\n                     }\n \n-                  /* now sort the dirs only */\n+                  /* now sort the dirs only (dirs all have the same score) */\n                   eio_dent_sort (dents, dir - dents, 0, inode_bits);\n                 }\n \n             break;\n           }\n \n         /* now add the entry to our list(s) */\n-        name = entp->d_name;\n+        name = D_NAME (entp);\n \n         /* skip . and .. entries */\n         if (name [0] != '.' || (name [1] && (name [1] != '.' || name [2])))\n           {\n             int len = D_NAMLEN (entp) + 1;\n \n-            while (expect_false (namesoffs + len > namesalloc))\n+            while (ecb_expect_false (namesoffs + len > namesalloc))\n               {\n                 namesalloc *= 2;\n-                X_LOCK (wrklock);\n                 req->ptr2 = names = realloc (names, namesalloc);\n-                X_UNLOCK (wrklock);\n \n                 if (!names)\n                   break;\n@@ -1348,12 +1901,10 @@ eio__scandir (eio_req *req, etp_worker *self)\n               {\n                 struct eio_dirent *ent;\n \n-                if (expect_false (dentoffs == dentalloc))\n+                if (ecb_expect_false (dentoffs == dentalloc))\n                   {\n                     dentalloc *= 2;\n-                    X_LOCK (wrklock);\n                     req->ptr1 = dents = realloc (dents, dentalloc * sizeof (eio_dirent));\n-                    X_UNLOCK (wrklock);\n \n                     if (!dents)\n                       break;\n@@ -1443,131 +1994,15 @@ eio__scandir (eio_req *req, etp_worker *self)\n             errno = ECANCELED;\n             break;\n           }\n-      }\n-}\n-\n-#ifdef PAGESIZE\n-# define eio_pagesize() PAGESIZE\n-\n-#elif defined(_WIN32)\n-  /* Windows */\n-  static intptr_t\n-  eio_pagesize (void)\n-  { \n-    SYSTEM_INFO si;\n-    GetSystemInfo(&si);\n-    return si.dwPageSize;\n-  }\n-\n-#else\n-  /* POSIX */\n-  static intptr_t\n-  eio_pagesize (void)\n-  {\n-    static intptr_t page;\n-\n-    if (!page)\n-      page = sysconf (_SC_PAGESIZE);\n-\n-    return page;\n-  }\n-#endif\n-\n-static void\n-eio_page_align (void **addr, size_t *length)\n-{\n-  intptr_t mask = eio_pagesize () - 1;\n-\n-  /* round down addr */\n-  intptr_t adj = mask & (intptr_t)*addr;\n-\n-  *addr   = (void *)((intptr_t)*addr - adj);\n-  *length += adj;\n-\n-  /* round up length */\n-  *length = (*length + mask) & ~mask;\n-}\n-\n-#if !_POSIX_MEMLOCK\n-# define eio__mlockall(a) ((errno = ENOSYS), -1)\n-#else\n-\n-static int\n-eio__mlockall (int flags)\n-{\n-  #if __GLIBC__ == 2 && __GLIBC_MINOR__ <= 7\n-    extern int mallopt (int, int);\n-    mallopt (-6, 238); /* http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=473812 */\n-  #endif\n-\n-  if (EIO_MCL_CURRENT   != MCL_CURRENT\n-      || EIO_MCL_FUTURE != MCL_FUTURE)\n-    {\n-      flags = 0\n-         | (flags & EIO_MCL_CURRENT ? MCL_CURRENT : 0)\n-         | (flags & EIO_MCL_FUTURE  ? MCL_FUTURE : 0);\n-    }\n-\n-  return mlockall (flags);\n-}\n-#endif\n-\n-#if !_POSIX_MEMLOCK_RANGE\n-# define eio__mlock(a,b) ((errno = ENOSYS), -1)\n-#else\n-\n-static int\n-eio__mlock (void *addr, size_t length)\n-{\n-  eio_page_align (&addr, &length);\n-\n-  return mlock (addr, length);\n-}\n-\n-#endif\n-\n-#if !(_POSIX_MAPPED_FILES && _POSIX_SYNCHRONIZED_IO)\n-# define eio__msync(a,b,c) ((errno = ENOSYS), -1)\n-#else\n-\n-int\n-eio__msync (void *mem, size_t len, int flags)\n-{\n-  eio_page_align (&mem, &len);\n-\n-  if (EIO_MS_ASYNC         != MS_SYNC\n-      || EIO_MS_INVALIDATE != MS_INVALIDATE\n-      || EIO_MS_SYNC       != MS_SYNC)\n-    {\n-      flags = 0\n-         | (flags & EIO_MS_ASYNC      ? MS_ASYNC : 0)\n-         | (flags & EIO_MS_INVALIDATE ? MS_INVALIDATE : 0)\n-         | (flags & EIO_MS_SYNC       ? MS_SYNC : 0);\n-    }\n-\n-  return msync (mem, len, flags);\n-}\n \n+#ifdef _WIN32\n+        if (!FindNextFile (dirp, &entp))\n+          {\n+            FindClose (dirp);\n+            dirp = 0;\n+          }\n #endif\n-\n-int\n-eio__mtouch (void *mem, size_t len, int flags)\n-{\n-  eio_page_align (&mem, &len);\n-\n-  {\n-    intptr_t addr = (intptr_t)mem;\n-    intptr_t end = addr + len;\n-    intptr_t page = eio_pagesize ();\n-\n-    if (addr < end)\n-      if (flags & EIO_MT_MODIFY) /* modify */\n-        do { *((volatile sig_atomic_t *)addr) |= 0; } while ((addr += page) < len);\n-      else\n-        do { *((volatile sig_atomic_t *)addr)     ; } while ((addr += page) < len);\n-  }\n-\n-  return 0;\n+      }\n }\n \n /*****************************************************************************/\n@@ -1593,11 +2028,17 @@ X_THREAD_PROC (etp_proc)\n   struct timespec ts;\n   etp_worker *self = (etp_worker *)thr_arg;\n \n-  /* try to distribute timeouts somewhat randomly */\n+#if HAVE_PRCTL_SET_NAME\n+  prctl (PR_SET_NAME, (unsigned long)\"eio_thread\", 0, 0, 0);\n+#endif\n+\n+  /* try to distribute timeouts somewhat evenly */\n   ts.tv_nsec = ((unsigned long)self & 1023UL) * (1000000000UL / 1024UL);\n \n   for (;;)\n     {\n+      ts.tv_sec = 0;\n+\n       X_LOCK (reqlock);\n \n       for (;;)\n@@ -1607,23 +2048,28 @@ X_THREAD_PROC (etp_proc)\n           if (req)\n             break;\n \n+          if (ts.tv_sec == 1) /* no request, but timeout detected, let's quit */\n+            {\n+              X_UNLOCK (reqlock);\n+              X_LOCK (wrklock);\n+              --started;\n+              X_UNLOCK (wrklock);\n+              goto quit;\n+            }\n+\n           ++idle;\n \n-          ts.tv_sec = time (0) + IDLE_TIMEOUT;\n-          if (X_COND_TIMEDWAIT (reqwait, reqlock, ts) == ETIMEDOUT)\n+          if (idle <= max_idle)\n+            /* we are allowed to idle, so do so without any timeout */\n+            X_COND_WAIT (reqwait, reqlock);\n+          else\n             {\n-              if (idle > max_idle)\n-                {\n-                  --idle;\n-                  X_UNLOCK (reqlock);\n-                  X_LOCK (wrklock);\n-                  --started;\n-                  X_UNLOCK (wrklock);\n-                  goto quit;\n-                }\n+              /* initialise timeout once */\n+              if (!ts.tv_sec)\n+                ts.tv_sec = time (0) + idle_timeout;\n \n-              /* we are allowed to idle, so do so without any timeout */\n-              X_COND_WAIT (reqwait, reqlock);\n+              if (X_COND_TIMEDWAIT (reqwait, reqlock, ts) == ETIMEDOUT)\n+                ts.tv_sec = 1; /* assuming this is not a value computed above.,.. */\n             }\n \n           --idle;\n@@ -1636,8 +2082,7 @@ X_THREAD_PROC (etp_proc)\n       if (req->type < 0)\n         goto quit;\n \n-      if (!EIO_CANCELLED (req))\n-        ETP_EXECUTE (self, req);\n+      ETP_EXECUTE (self, req);\n \n       X_LOCK (reslock);\n \n@@ -1662,12 +2107,18 @@ X_THREAD_PROC (etp_proc)\n \n /*****************************************************************************/\n \n-int eio_init (void (*want_poll)(void), void (*done_poll)(void))\n+int ecb_cold\n+eio_init (void (*want_poll)(void), void (*done_poll)(void))\n {\n+#if !HAVE_PREADWRITE\n+  X_MUTEX_CREATE (preadwritelock);\n+#endif\n+\n   return etp_init (want_poll, done_poll);\n }\n \n-static void eio_api_destroy (eio_req *req)\n+ecb_inline void\n+eio_api_destroy (eio_req *req)\n {\n   free (req);\n }\n@@ -1696,14 +2147,23 @@ static void eio_api_destroy (eio_req *req)\n       return 0;\t\t\t\t\t\t\t\\\n     }\n \n-static void eio_execute (etp_worker *self, eio_req *req)\n+static void\n+eio_execute (etp_worker *self, eio_req *req)\n {\n+  if (ecb_expect_false (EIO_CANCELLED (req)))\n+    {\n+      req->result  = -1;\n+      req->errorno = ECANCELED;\n+      return;\n+    }\n+\n   switch (req->type)\n     {\n       case EIO_READ:      ALLOC (req->size);\n                           req->result = req->offs >= 0\n                                       ? pread     (req->int1, req->ptr2, req->size, req->offs)\n                                       : read      (req->int1, req->ptr2, req->size); break;\n+\n       case EIO_WRITE:\n #if defined (__APPLE__)\n                           pthread_mutex_lock (&apple_bug_writelock);\n@@ -1719,65 +2179,53 @@ static void eio_execute (etp_worker *self, eio_req *req)\n                           break;\n \n       case EIO_READAHEAD: req->result = readahead     (req->int1, req->offs, req->size); break;\n-      case EIO_SENDFILE:  req->result = eio__sendfile (req->int1, req->int2, req->offs, req->size, self); break;\n+      case EIO_SENDFILE:  req->result = eio__sendfile (req->int1, req->int2, req->offs, req->size); break;\n \n       case EIO_STAT:      ALLOC (sizeof (EIO_STRUCT_STAT));\n                           req->result = stat      (req->ptr1, (EIO_STRUCT_STAT *)req->ptr2); break;\n-#ifndef _WIN32\n       case EIO_LSTAT:     ALLOC (sizeof (EIO_STRUCT_STAT));\n                           req->result = lstat     (req->ptr1, (EIO_STRUCT_STAT *)req->ptr2); break;\n-#endif\n       case EIO_FSTAT:     ALLOC (sizeof (EIO_STRUCT_STAT));\n                           req->result = fstat     (req->int1, (EIO_STRUCT_STAT *)req->ptr2); break;\n \n-#ifndef _WIN32\n       case EIO_STATVFS:   ALLOC (sizeof (EIO_STRUCT_STATVFS));\n                           req->result = statvfs   (req->ptr1, (EIO_STRUCT_STATVFS *)req->ptr2); break;\n       case EIO_FSTATVFS:  ALLOC (sizeof (EIO_STRUCT_STATVFS));\n                           req->result = fstatvfs  (req->int1, (EIO_STRUCT_STATVFS *)req->ptr2); break;\n \n       case EIO_CHOWN:     req->result = chown     (req->ptr1, req->int2, req->int3); break;\n       case EIO_FCHOWN:    req->result = fchown    (req->int1, req->int2, req->int3); break;\n-#endif\n-      case EIO_CHMOD:     req->result = chmod     (req->ptr1, (mode_t)req->int2); break;\n-#ifndef _WIN32\n-      case EIO_FCHMOD:    req->result = fchmod    (req->int1, (mode_t)req->int2); break;\n+      case EIO_CHMOD:     req->result = chmod     (req->ptr1, (eio_mode_t)req->int2); break;\n+      case EIO_FCHMOD:    req->result = fchmod    (req->int1, (eio_mode_t)req->int2); break;\n       case EIO_TRUNCATE:  req->result = truncate  (req->ptr1, req->offs); break;\n-#endif\n       case EIO_FTRUNCATE: req->result = ftruncate (req->int1, req->offs); break;\n \n-      case EIO_OPEN:      req->result = open      (req->ptr1, req->int1, (mode_t)req->int2); break;\n+      case EIO_OPEN:      req->result = open      (req->ptr1, req->int1, (eio_mode_t)req->int2); break;\n       case EIO_CLOSE:     req->result = close     (req->int1); break;\n       case EIO_DUP2:      req->result = dup2      (req->int1, req->int2); break;\n       case EIO_UNLINK:    req->result = unlink    (req->ptr1); break;\n       case EIO_RMDIR:     req->result = rmdir     (req->ptr1); break;\n-#ifdef _WIN32\n-      case EIO_MKDIR:     req->result = mkdir     (req->ptr1); break;\n-#else\n-      case EIO_MKDIR:     req->result = mkdir     (req->ptr1, (mode_t)req->int2); break;\n-#endif\n+      case EIO_MKDIR:     req->result = mkdir     (req->ptr1, (eio_mode_t)req->int2); break;\n       case EIO_RENAME:    req->result = rename    (req->ptr1, req->ptr2); break;\n-#ifndef _WIN32\n       case EIO_LINK:      req->result = link      (req->ptr1, req->ptr2); break;\n       case EIO_SYMLINK:   req->result = symlink   (req->ptr1, req->ptr2); break;\n-      case EIO_MKNOD:     req->result = mknod     (req->ptr1, (mode_t)req->int2, (dev_t)req->int3); break;\n-#endif\n+      case EIO_MKNOD:     req->result = mknod     (req->ptr1, (eio_mode_t)req->int2, (dev_t)req->offs); break;\n+\n+      case EIO_REALPATH:  eio__realpath (req, self); break;\n \n-#ifndef _WIN32\n       case EIO_READLINK:  ALLOC (PATH_MAX);\n                           req->result = readlink  (req->ptr1, req->ptr2, PATH_MAX); break;\n-#endif\n \n-#ifndef _WIN32\n       case EIO_SYNC:      req->result = 0; sync (); break;\n-#endif\n       case EIO_FSYNC:     req->result = fsync     (req->int1); break;\n       case EIO_FDATASYNC: req->result = fdatasync (req->int1); break;\n+      case EIO_SYNCFS:    req->result = eio__syncfs (req->int1); break;\n+      case EIO_SYNC_FILE_RANGE: req->result = eio__sync_file_range (req->int1, req->offs, req->size, req->int2); break;\n       case EIO_MSYNC:     req->result = eio__msync (req->ptr2, req->size, req->int1); break;\n-      case EIO_MTOUCH:    req->result = eio__mtouch (req->ptr2, req->size, req->int1); break;\n+      case EIO_MTOUCH:    req->result = eio__mtouch (req); break;\n       case EIO_MLOCK:     req->result = eio__mlock (req->ptr2, req->size); break;\n       case EIO_MLOCKALL:  req->result = eio__mlockall (req->int1); break;\n-      case EIO_SYNC_FILE_RANGE: req->result = eio__sync_file_range (req->int1, req->offs, req->size, req->int2); break;\n+      case EIO_FALLOCATE: req->result = eio__fallocate (req->int1, req->int2, req->offs, req->size); break;\n \n       case EIO_READDIR:   eio__scandir (req, self); break;\n \n@@ -1828,7 +2276,7 @@ static void eio_execute (etp_worker *self, eio_req *req)\n         break;\n \n       case EIO_CUSTOM:\n-        ((void (*)(eio_req *))req->feed) (req);\n+        req->feed (req);\n         break;\n \n       default:\n@@ -1867,6 +2315,21 @@ eio_req *eio_msync (void *addr, size_t length, int flags, int pri, eio_cb cb, vo\n   REQ (EIO_MSYNC); req->ptr2 = addr; req->size = length; req->int1 = flags; SEND;\n }\n \n+eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data)\n+{\n+  REQ (EIO_FDATASYNC); req->int1 = fd; SEND;\n+}\n+\n+eio_req *eio_syncfs (int fd, int pri, eio_cb cb, void *data)\n+{\n+  REQ (EIO_SYNCFS); req->int1 = fd; SEND;\n+}\n+\n+eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data)\n+{\n+  REQ (EIO_SYNC_FILE_RANGE); req->int1 = fd; req->offs = offset; req->size = nbytes; req->int2 = flags; SEND;\n+}\n+\n eio_req *eio_mtouch (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_MTOUCH); req->ptr2 = addr; req->size = length; req->int1 = flags; SEND;\n@@ -1882,14 +2345,9 @@ eio_req *eio_mlockall (int flags, int pri, eio_cb cb, void *data)\n   REQ (EIO_MLOCKALL); req->int1 = flags; SEND;\n }\n \n-eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data)\n-{\n-  REQ (EIO_SYNC_FILE_RANGE); req->int1 = fd; req->offs = offset; req->size = nbytes; req->int2 = flags; SEND;\n-}\n-\n-eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data)\n+eio_req *eio_fallocate (int fd, int mode, off_t offset, size_t len, int pri, eio_cb cb, void *data)\n {\n-  REQ (EIO_FDATASYNC); req->int1 = fd; SEND;\n+  REQ (EIO_FALLOCATE); req->int1 = fd; req->int2 = mode; req->offs = offset; req->size = len; SEND;\n }\n \n eio_req *eio_close (int fd, int pri, eio_cb cb, void *data)\n@@ -1932,12 +2390,12 @@ eio_req *eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data)\n   REQ (EIO_FTRUNCATE); req->int1 = fd; req->offs = offset; SEND;\n }\n \n-eio_req *eio_fchmod (int fd, mode_t mode, int pri, eio_cb cb, void *data)\n+eio_req *eio_fchmod (int fd, eio_mode_t mode, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_FCHMOD); req->int1 = fd; req->int2 = (long)mode; SEND;\n }\n \n-eio_req *eio_fchown (int fd, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data)\n+eio_req *eio_fchown (int fd, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_FCHOWN); req->int1 = fd; req->int2 = (long)uid; req->int3 = (long)gid; SEND;\n }\n@@ -1952,7 +2410,7 @@ eio_req *eio_sendfile (int out_fd, int in_fd, off_t in_offset, size_t length, in\n   REQ (EIO_SENDFILE); req->int1 = out_fd; req->int2 = in_fd; req->offs = in_offset; req->size = length; SEND;\n }\n \n-eio_req *eio_open (const char *path, int flags, mode_t mode, int pri, eio_cb cb, void *data)\n+eio_req *eio_open (const char *path, int flags, eio_mode_t mode, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_OPEN); PATH; req->int1 = flags; req->int2 = (long)mode; SEND;\n }\n@@ -1967,17 +2425,17 @@ eio_req *eio_truncate (const char *path, off_t offset, int pri, eio_cb cb, void\n   REQ (EIO_TRUNCATE); PATH; req->offs = offset; SEND;\n }\n \n-eio_req *eio_chown (const char *path, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data)\n+eio_req *eio_chown (const char *path, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_CHOWN); PATH; req->int2 = (long)uid; req->int3 = (long)gid; SEND;\n }\n \n-eio_req *eio_chmod (const char *path, mode_t mode, int pri, eio_cb cb, void *data)\n+eio_req *eio_chmod (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_CHMOD); PATH; req->int2 = (long)mode; SEND;\n }\n \n-eio_req *eio_mkdir (const char *path, mode_t mode, int pri, eio_cb cb, void *data)\n+eio_req *eio_mkdir (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data)\n {\n   REQ (EIO_MKDIR); PATH; req->int2 = (long)mode; SEND;\n }\n@@ -1993,6 +2451,11 @@ eio_req *eio_readlink (const char *path, int pri, eio_cb cb, void *data)\n   return eio__1path (EIO_READLINK, path, pri, cb, data);\n }\n \n+eio_req *eio_realpath (const char *path, int pri, eio_cb cb, void *data)\n+{\n+  return eio__1path (EIO_REALPATH, path, pri, cb, data);\n+}\n+\n eio_req *eio_stat (const char *path, int pri, eio_cb cb, void *data)\n {\n   return eio__1path (EIO_STAT, path, pri, cb, data);\n@@ -2023,9 +2486,9 @@ eio_req *eio_readdir (const char *path, int flags, int pri, eio_cb cb, void *dat\n   REQ (EIO_READDIR); PATH; req->int1 = flags; SEND;\n }\n \n-eio_req *eio_mknod (const char *path, mode_t mode, dev_t dev, int pri, eio_cb cb, void *data)\n+eio_req *eio_mknod (const char *path, eio_mode_t mode, dev_t dev, int pri, eio_cb cb, void *data)\n {\n-  REQ (EIO_MKNOD); PATH; req->int2 = (long)mode; req->int3 = (long)dev; SEND;\n+  REQ (EIO_MKNOD); PATH; req->int2 = (long)mode; req->offs = (off_t)dev; SEND;\n }\n \n static eio_req *\n@@ -2059,9 +2522,9 @@ eio_req *eio_rename (const char *path, const char *new_path, int pri, eio_cb cb,\n   return eio__2path (EIO_RENAME, path, new_path, pri, cb, data);\n }\n \n-eio_req *eio_custom (eio_cb execute, int pri, eio_cb cb, void *data)\n+eio_req *eio_custom (void (*execute)(eio_req *), int pri, eio_cb cb, void *data)\n {\n-  REQ (EIO_CUSTOM); req->feed = (void (*)(eio_req *))execute; SEND;\n+  REQ (EIO_CUSTOM); req->feed = execute; SEND;\n }\n \n #endif\n@@ -2080,22 +2543,25 @@ eio_req *eio_grp (eio_cb cb, void *data)\n /*****************************************************************************/\n /* grp functions */\n \n-void eio_grp_feed (eio_req *grp, void (*feed)(eio_req *req), int limit)\n+void\n+eio_grp_feed (eio_req *grp, void (*feed)(eio_req *req), int limit)\n {\n   grp->int2 = limit;\n   grp->feed = feed;\n \n   grp_try_feed (grp);\n }\n \n-void eio_grp_limit (eio_req *grp, int limit)\n+void\n+eio_grp_limit (eio_req *grp, int limit)\n {\n   grp->int2 = limit;\n \n   grp_try_feed (grp);\n }\n \n-void eio_grp_add (eio_req *grp, eio_req *req)\n+void\n+eio_grp_add (eio_req *grp, eio_req *req)\n {\n   assert ((\"cannot add requests to IO::AIO::GRP after the group finished\", grp->int1 != 2));\n \n@@ -2116,18 +2582,9 @@ void eio_grp_add (eio_req *grp, eio_req *req)\n /*****************************************************************************/\n /* misc garbage */\n \n-ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count)\n+eio_ssize_t\n+eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count)\n {\n-  etp_worker wrk;\n-  ssize_t ret;\n-\n-  wrk.dbuf = 0;\n-\n-  ret = eio__sendfile (ofd, ifd, offset, count, &wrk);\n-\n-  if (wrk.dbuf)\n-    free (wrk.dbuf);\n-\n-  return ret;\n+  return eio__sendfile (ofd, ifd, offset, count);\n }\n ", "previous_filename": "src/rt/libuv/src/eio/eio.c"}, {"sha": "da5f33c01da39d6d4f9fa543ae9cfd3a10f486cf", "filename": "src/rt/libuv/src/unix/eio/eio.pod", "status": "added", "additions": 969, "deletions": 0, "changes": 969, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,969 @@\n+=head1 NAME\n+\n+libeio - truly asynchronous POSIX I/O\n+\n+=head1 SYNOPSIS\n+\n+  #include <eio.h>\n+\n+=head1 DESCRIPTION\n+\n+The newest version of this document is also available as an html-formatted\n+web page you might find easier to navigate when reading it for the first\n+time: L<http://pod.tst.eu/http://cvs.schmorp.de/libeio/eio.pod>.\n+\n+Note that this library is a by-product of the C<IO::AIO> perl\n+module, and many of the subtler points regarding requests lifetime\n+and so on are only documented in its documentation at the\n+moment: L<http://pod.tst.eu/http://cvs.schmorp.de/IO-AIO/AIO.pm>.\n+\n+=head2 FEATURES\n+\n+This library provides fully asynchronous versions of most POSIX functions\n+dealing with I/O. Unlike most asynchronous libraries, this not only\n+includes C<read> and C<write>, but also C<open>, C<stat>, C<unlink> and\n+similar functions, as well as less rarely ones such as C<mknod>, C<futime>\n+or C<readlink>.\n+\n+It also offers wrappers around C<sendfile> (Solaris, Linux, HP-UX and\n+FreeBSD, with emulation on other platforms) and C<readahead> (Linux, with\n+emulation elsewhere>).\n+\n+The goal is to enable you to write fully non-blocking programs. For\n+example, in a game server, you would not want to freeze for a few seconds\n+just because the server is running a backup and you happen to call\n+C<readdir>.\n+\n+=head2 TIME REPRESENTATION\n+\n+Libeio represents time as a single floating point number, representing the\n+(fractional) number of seconds since the (POSIX) epoch (somewhere near\n+the beginning of 1970, details are complicated, don't ask). This type is\n+called C<eio_tstamp>, but it is guaranteed to be of type C<double> (or\n+better), so you can freely use C<double> yourself.\n+\n+Unlike the name component C<stamp> might indicate, it is also used for\n+time differences throughout libeio.\n+\n+=head2 FORK SUPPORT\n+\n+Usage of pthreads in a program changes the semantics of fork\n+considerably. Specifically, only async-safe functions can be called after\n+fork. Libeio uses pthreads, so this applies, and makes using fork hard for\n+anything but relatively fork + exec uses.\n+\n+This library only works in the process that initialised it: Forking is\n+fully supported, but using libeio in any other process than the one that\n+called C<eio_init> is not.\n+\n+You might get around by not I<using> libeio before (or after) forking in\n+the parent, and using it in the child afterwards. You could also try to\n+call the L<eio_init> function again in the child, which will brutally\n+reinitialise all data structures, which isn't POSIX conformant, but\n+typically works.\n+\n+Otherwise, the only recommendation you should follow is: treat fork code\n+the same way you treat signal handlers, and only ever call C<eio_init> in\n+the process that uses it, and only once ever.\n+\n+=head1 INITIALISATION/INTEGRATION\n+\n+Before you can call any eio functions you first have to initialise the\n+library. The library integrates into any event loop, but can also be used\n+without one, including in polling mode.\n+\n+You have to provide the necessary glue yourself, however.\n+\n+=over 4\n+\n+=item int eio_init (void (*want_poll)(void), void (*done_poll)(void))\n+\n+This function initialises the library. On success it returns C<0>, on\n+failure it returns C<-1> and sets C<errno> appropriately.\n+\n+It accepts two function pointers specifying callbacks as argument, both of\n+which can be C<0>, in which case the callback isn't called.\n+\n+There is currently no way to change these callbacks later, or to\n+\"uninitialise\" the library again.\n+\n+=item want_poll callback\n+\n+The C<want_poll> callback is invoked whenever libeio wants attention (i.e.\n+it wants to be polled by calling C<eio_poll>). It is \"edge-triggered\",\n+that is, it will only be called once when eio wants attention, until all\n+pending requests have been handled.\n+\n+This callback is called while locks are being held, so I<you must\n+not call any libeio functions inside this callback>. That includes\n+C<eio_poll>. What you should do is notify some other thread, or wake up\n+your event loop, and then call C<eio_poll>.\n+\n+=item done_poll callback\n+\n+This callback is invoked when libeio detects that all pending requests\n+have been handled. It is \"edge-triggered\", that is, it will only be\n+called once after C<want_poll>. To put it differently, C<want_poll> and\n+C<done_poll> are invoked in pairs: after C<want_poll> you have to call\n+C<eio_poll ()> until either C<eio_poll> indicates that everything has been\n+handled or C<done_poll> has been called, which signals the same.\n+\n+Note that C<eio_poll> might return after C<done_poll> and C<want_poll>\n+have been called again, so watch out for races in your code.\n+\n+As with C<want_poll>, this callback is called while locks are being held,\n+so you I<must not call any libeio functions form within this callback>.\n+\n+=item int eio_poll ()\n+\n+This function has to be called whenever there are pending requests that\n+need finishing. You usually call this after C<want_poll> has indicated\n+that you should do so, but you can also call this function regularly to\n+poll for new results.\n+\n+If any request invocation returns a non-zero value, then C<eio_poll ()>\n+immediately returns with that value as return value.\n+\n+Otherwise, if all requests could be handled, it returns C<0>. If for some\n+reason not all requests have been handled, i.e. some are still pending, it\n+returns C<-1>.\n+\n+=back\n+\n+For libev, you would typically use an C<ev_async> watcher: the\n+C<want_poll> callback would invoke C<ev_async_send> to wake up the event\n+loop. Inside the callback set for the watcher, one would call C<eio_poll\n+()>.\n+\n+If C<eio_poll ()> is configured to not handle all results in one go\n+(i.e. it returns C<-1>) then you should start an idle watcher that calls\n+C<eio_poll> until it returns something C<!= -1>.\n+\n+A full-featured connector between libeio and libev would look as follows\n+(if C<eio_poll> is handling all requests, it can of course be simplified a\n+lot by removing the idle watcher logic):\n+\n+  static struct ev_loop *loop;\n+  static ev_idle repeat_watcher;\n+  static ev_async ready_watcher;\n+\n+  /* idle watcher callback, only used when eio_poll */\n+  /* didn't handle all results in one call */\n+  static void\n+  repeat (EV_P_ ev_idle *w, int revents)\n+  {\n+    if (eio_poll () != -1)\n+      ev_idle_stop (EV_A_ w);\n+  }\n+\n+  /* eio has some results, process them */\n+  static void\n+  ready (EV_P_ ev_async *w, int revents)\n+  {\n+    if (eio_poll () == -1)\n+      ev_idle_start (EV_A_ &repeat_watcher);\n+  }\n+\n+  /* wake up the event loop */\n+  static void\n+  want_poll (void)\n+  {\n+    ev_async_send (loop, &ready_watcher)\n+  }\n+\n+  void\n+  my_init_eio ()\n+  {\n+    loop = EV_DEFAULT;\n+\n+    ev_idle_init (&repeat_watcher, repeat);\n+    ev_async_init (&ready_watcher, ready);\n+    ev_async_start (loop &watcher);\n+\n+    eio_init (want_poll, 0);\n+  }\n+\n+For most other event loops, you would typically use a pipe - the event\n+loop should be told to wait for read readiness on the read end. In\n+C<want_poll> you would write a single byte, in C<done_poll> you would try\n+to read that byte, and in the callback for the read end, you would call\n+C<eio_poll>.\n+\n+You don't have to take special care in the case C<eio_poll> doesn't handle\n+all requests, as the done callback will not be invoked, so the event loop\n+will still signal readiness for the pipe until I<all> results have been\n+processed.\n+\n+\n+=head1 HIGH LEVEL REQUEST API\n+\n+Libeio has both a high-level API, which consists of calling a request\n+function with a callback to be called on completion, and a low-level API\n+where you fill out request structures and submit them.\n+\n+This section describes the high-level API.\n+\n+=head2 REQUEST SUBMISSION AND RESULT PROCESSING\n+\n+You submit a request by calling the relevant C<eio_TYPE> function with the\n+required parameters, a callback of type C<int (*eio_cb)(eio_req *req)>\n+(called C<eio_cb> below) and a freely usable C<void *data> argument.\n+\n+The return value will either be 0, in case something went really wrong\n+(which can basically only happen on very fatal errors, such as C<malloc>\n+returning 0, which is rather unlikely), or a pointer to the newly-created\n+and submitted C<eio_req *>.\n+\n+The callback will be called with an C<eio_req *> which contains the\n+results of the request. The members you can access inside that structure\n+vary from request to request, except for:\n+\n+=over 4\n+\n+=item C<ssize_t result>\n+\n+This contains the result value from the call (usually the same as the\n+syscall of the same name).\n+\n+=item C<int errorno>\n+\n+This contains the value of C<errno> after the call.\n+\n+=item C<void *data>\n+\n+The C<void *data> member simply stores the value of the C<data> argument.\n+\n+=back\n+\n+The return value of the callback is normally C<0>, which tells libeio to\n+continue normally. If a callback returns a nonzero value, libeio will\n+stop processing results (in C<eio_poll>) and will return the value to its\n+caller.\n+\n+Memory areas passed to libeio must stay valid as long as a request\n+executes, with the exception of paths, which are being copied\n+internally. Any memory libeio itself allocates will be freed after the\n+finish callback has been called. If you want to manage all memory passed\n+to libeio yourself you can use the low-level API.\n+\n+For example, to open a file, you could do this:\n+\n+  static int\n+  file_open_done (eio_req *req)\n+  {\n+    if (req->result < 0)\n+      {\n+        /* open() returned -1 */\n+        errno = req->errorno;\n+        perror (\"open\");\n+      }\n+    else\n+      {\n+        int fd = req->result;\n+        /* now we have the new fd in fd */\n+      }\n+\n+    return 0;\n+  }\n+\n+  /* the first three arguments are passed to open(2) */\n+  /* the remaining are priority, callback and data */\n+  if (!eio_open (\"/etc/passwd\", O_RDONLY, 0, 0, file_open_done, 0))\n+    abort (); /* something went wrong, we will all die!!! */\n+\n+Note that you additionally need to call C<eio_poll> when the C<want_cb>\n+indicates that requests are ready to be processed.\n+\n+=head2 CANCELLING REQUESTS\n+\n+Sometimes the need for a request goes away before the request is\n+finished. In that case, one can cancel the request by a call to\n+C<eio_cancel>:\n+\n+=over 4\n+\n+=item eio_cancel (eio_req *req)\n+\n+Cancel the request (and all its subrequests). If the request is currently\n+executing it might still continue to execute, and in other cases it might\n+still take a while till the request is cancelled.\n+\n+Even if cancelled, the finish callback will still be invoked - the\n+callbacks of all cancellable requests need to check whether the request\n+has been cancelled by calling C<EIO_CANCELLED (req)>:\n+\n+  static int\n+  my_eio_cb (eio_req *req)\n+  {\n+    if (EIO_CANCELLED (req))\n+      return 0;\n+  }\n+\n+In addition, cancelled requests will I<either> have C<< req->result >>\n+set to C<-1> and C<errno> to C<ECANCELED>, or I<otherwise> they were\n+successfully executed, despite being cancelled (e.g. when they have\n+already been executed at the time they were cancelled).\n+\n+C<EIO_CANCELLED> is still true for requests that have successfully\n+executed, as long as C<eio_cancel> was called on them at some point.\n+\n+=back\n+\n+=head2 AVAILABLE REQUESTS\n+\n+The following request functions are available. I<All> of them return the\n+C<eio_req *> on success and C<0> on failure, and I<all> of them have the\n+same three trailing arguments: C<pri>, C<cb> and C<data>. The C<cb> is\n+mandatory, but in most cases, you pass in C<0> as C<pri> and C<0> or some\n+custom data value as C<data>.\n+\n+=head3 POSIX API WRAPPERS\n+\n+These requests simply wrap the POSIX call of the same name, with the same\n+arguments. If a function is not implemented by the OS and cannot be emulated\n+in some way, then all of these return C<-1> and set C<errorno> to C<ENOSYS>.\n+\n+=over 4\n+\n+=item eio_open      (const char *path, int flags, mode_t mode, int pri, eio_cb cb, void *data)\n+\n+=item eio_truncate  (const char *path, off_t offset, int pri, eio_cb cb, void *data)\n+\n+=item eio_chown     (const char *path, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data)\n+\n+=item eio_chmod     (const char *path, mode_t mode, int pri, eio_cb cb, void *data)\n+\n+=item eio_mkdir     (const char *path, mode_t mode, int pri, eio_cb cb, void *data)\n+\n+=item eio_rmdir     (const char *path, int pri, eio_cb cb, void *data)\n+\n+=item eio_unlink    (const char *path, int pri, eio_cb cb, void *data)\n+\n+=item eio_utime     (const char *path, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data)\n+\n+=item eio_mknod     (const char *path, mode_t mode, dev_t dev, int pri, eio_cb cb, void *data)\n+\n+=item eio_link      (const char *path, const char *new_path, int pri, eio_cb cb, void *data)\n+\n+=item eio_symlink   (const char *path, const char *new_path, int pri, eio_cb cb, void *data)\n+\n+=item eio_rename    (const char *path, const char *new_path, int pri, eio_cb cb, void *data)\n+\n+=item eio_mlock     (void *addr, size_t length, int pri, eio_cb cb, void *data)\n+\n+=item eio_close     (int fd, int pri, eio_cb cb, void *data)\n+\n+=item eio_sync      (int pri, eio_cb cb, void *data)\n+\n+=item eio_fsync     (int fd, int pri, eio_cb cb, void *data)\n+\n+=item eio_fdatasync (int fd, int pri, eio_cb cb, void *data)\n+\n+=item eio_futime    (int fd, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data)\n+\n+=item eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data)\n+\n+=item eio_fchmod    (int fd, mode_t mode, int pri, eio_cb cb, void *data)\n+\n+=item eio_fchown    (int fd, uid_t uid, gid_t gid, int pri, eio_cb cb, void *data)\n+\n+=item eio_dup2      (int fd, int fd2, int pri, eio_cb cb, void *data)\n+\n+These have the same semantics as the syscall of the same name, their\n+return value is available as C<< req->result >> later.\n+\n+=item eio_read      (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data)\n+\n+=item eio_write     (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data)\n+\n+These two requests are called C<read> and C<write>, but actually wrap\n+C<pread> and C<pwrite>. On systems that lack these calls (such as cygwin),\n+libeio uses lseek/read_or_write/lseek and a mutex to serialise the\n+requests, so all these requests run serially and do not disturb each\n+other. However, they still disturb the file offset while they run, so it's\n+not safe to call these functions concurrently with non-libeio functions on\n+the same fd on these systems.\n+\n+Not surprisingly, pread and pwrite are not thread-safe on Darwin (OS/X),\n+so it is advised not to submit multiple requests on the same fd on this\n+horrible pile of garbage.\n+\n+=item eio_mlockall  (int flags, int pri, eio_cb cb, void *data)\n+\n+Like C<mlockall>, but the flag value constants are called\n+C<EIO_MCL_CURRENT> and C<EIO_MCL_FUTURE>.\n+\n+=item eio_msync     (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data)\n+\n+Just like msync, except that the flag values are called C<EIO_MS_ASYNC>,\n+C<EIO_MS_INVALIDATE> and C<EIO_MS_SYNC>.\n+\n+=item eio_readlink  (const char *path, int pri, eio_cb cb, void *data)\n+\n+If successful, the path read by C<readlink(2)> can be accessed via C<<\n+req->ptr2 >> and is I<NOT> null-terminated, with the length specified as\n+C<< req->result >>.\n+\n+  if (req->result >= 0)\n+    {\n+      char *target = strndup ((char *)req->ptr2, req->result);\n+\n+      free (target);\n+    }\n+\n+=item eio_realpath  (const char *path, int pri, eio_cb cb, void *data)\n+\n+Similar to the realpath libc function, but unlike that one, C<<\n+req->result >> is C<-1> on failure. On success, the result is the length\n+of the returned path in C<ptr2> (which is I<NOT> 0-terminated) - this is\n+similar to readlink.\n+\n+=item eio_stat      (const char *path, int pri, eio_cb cb, void *data)\n+\n+=item eio_lstat     (const char *path, int pri, eio_cb cb, void *data)\n+\n+=item eio_fstat     (int fd, int pri, eio_cb cb, void *data)\n+   \n+Stats a file - if C<< req->result >> indicates success, then you can\n+access the C<struct stat>-like structure via C<< req->ptr2 >>:\n+\n+  EIO_STRUCT_STAT *statdata = (EIO_STRUCT_STAT *)req->ptr2;\n+\n+=item eio_statvfs   (const char *path, int pri, eio_cb cb, void *data)\n+\n+=item eio_fstatvfs  (int fd, int pri, eio_cb cb, void *data)\n+\n+Stats a filesystem - if C<< req->result >> indicates success, then you can\n+access the C<struct statvfs>-like structure via C<< req->ptr2 >>:\n+\n+  EIO_STRUCT_STATVFS *statdata = (EIO_STRUCT_STATVFS *)req->ptr2;\n+\n+=back\n+\n+=head3 READING DIRECTORIES\n+\n+Reading directories sounds simple, but can be rather demanding, especially\n+if you want to do stuff such as traversing a directory hierarchy or\n+processing all files in a directory. Libeio can assist these complex tasks\n+with it's C<eio_readdir> call.\n+\n+=over 4\n+\n+=item eio_readdir (const char *path, int flags, int pri, eio_cb cb, void *data)\n+\n+This is a very complex call. It basically reads through a whole directory\n+(via the C<opendir>, C<readdir> and C<closedir> calls) and returns either\n+the names or an array of C<struct eio_dirent>, depending on the C<flags>\n+argument.\n+\n+The C<< req->result >> indicates either the number of files found, or\n+C<-1> on error. On success, null-terminated names can be found as C<< req->ptr2 >>,\n+and C<struct eio_dirents>, if requested by C<flags>, can be found via C<<\n+req->ptr1 >>.\n+\n+Here is an example that prints all the names:\n+\n+  int i;\n+  char *names = (char *)req->ptr2;\n+\n+  for (i = 0; i < req->result; ++i)\n+    {\n+      printf (\"name #%d: %s\\n\", i, names);\n+\n+      /* move to next name */\n+      names += strlen (names) + 1;\n+    }\n+\n+Pseudo-entries such as F<.> and F<..> are never returned by C<eio_readdir>.\n+\n+C<flags> can be any combination of:\n+\n+=over 4\n+\n+=item EIO_READDIR_DENTS\n+\n+If this flag is specified, then, in addition to the names in C<ptr2>,\n+also an array of C<struct eio_dirent> is returned, in C<ptr1>. A C<struct\n+eio_dirent> looks like this:\n+\n+  struct eio_dirent\n+  {\n+    int nameofs; /* offset of null-terminated name string in (char *)req->ptr2 */\n+    unsigned short namelen; /* size of filename without trailing 0 */\n+    unsigned char type; /* one of EIO_DT_* */\n+    signed char score; /* internal use */\n+    ino_t inode; /* the inode number, if available, otherwise unspecified */\n+  };\n+\n+The only members you normally would access are C<nameofs>, which is the\n+byte-offset from C<ptr2> to the start of the name, C<namelen> and C<type>.\n+\n+C<type> can be one of:\n+\n+C<EIO_DT_UNKNOWN> - if the type is not known (very common) and you have to C<stat>\n+the name yourself if you need to know,\n+one of the \"standard\" POSIX file types (C<EIO_DT_REG>, C<EIO_DT_DIR>, C<EIO_DT_LNK>,\n+C<EIO_DT_FIFO>, C<EIO_DT_SOCK>, C<EIO_DT_CHR>, C<EIO_DT_BLK>)\n+or some OS-specific type (currently\n+C<EIO_DT_MPC> - multiplexed char device (v7+coherent),\n+C<EIO_DT_NAM> - xenix special named file,\n+C<EIO_DT_MPB> - multiplexed block device (v7+coherent),\n+C<EIO_DT_NWK> - HP-UX network special,\n+C<EIO_DT_CMP> - VxFS compressed,\n+C<EIO_DT_DOOR> - solaris door, or\n+C<EIO_DT_WHT>).\n+\n+This example prints all names and their type:\n+\n+  int i;\n+  struct eio_dirent *ents = (struct eio_dirent *)req->ptr1;\n+  char *names = (char *)req->ptr2;\n+\n+  for (i = 0; i < req->result; ++i)\n+    {\n+      struct eio_dirent *ent = ents + i;\n+      char *name = names + ent->nameofs;\n+\n+      printf (\"name #%d: %s (type %d)\\n\", i, name, ent->type);\n+    }\n+\n+=item EIO_READDIR_DIRS_FIRST\n+\n+When this flag is specified, then the names will be returned in an order\n+where likely directories come first, in optimal C<stat> order. This is\n+useful when you need to quickly find directories, or you want to find all\n+directories while avoiding to stat() each entry.\n+\n+If the system returns type information in readdir, then this is used\n+to find directories directly. Otherwise, likely directories are names\n+beginning with \".\", or otherwise names with no dots, of which names with\n+short names are tried first.\n+\n+=item EIO_READDIR_STAT_ORDER\n+\n+When this flag is specified, then the names will be returned in an order\n+suitable for stat()'ing each one. That is, when you plan to stat()\n+all files in the given directory, then the returned order will likely\n+be fastest.\n+\n+If both this flag and C<EIO_READDIR_DIRS_FIRST> are specified, then the\n+likely directories come first, resulting in a less optimal stat order.\n+\n+=item EIO_READDIR_FOUND_UNKNOWN\n+\n+This flag should not be specified when calling C<eio_readdir>. Instead,\n+it is being set by C<eio_readdir> (you can access the C<flags> via C<<\n+req->int1 >>, when any of the C<type>'s found were C<EIO_DT_UNKNOWN>. The\n+absence of this flag therefore indicates that all C<type>'s are known,\n+which can be used to speed up some algorithms.\n+\n+A typical use case would be to identify all subdirectories within a\n+directory - you would ask C<eio_readdir> for C<EIO_READDIR_DIRS_FIRST>. If\n+then this flag is I<NOT> set, then all the entries at the beginning of the\n+returned array of type C<EIO_DT_DIR> are the directories. Otherwise, you\n+should start C<stat()>'ing the entries starting at the beginning of the\n+array, stopping as soon as you found all directories (the count can be\n+deduced by the link count of the directory).\n+\n+=back\n+\n+=back\n+\n+=head3 OS-SPECIFIC CALL WRAPPERS\n+\n+These wrap OS-specific calls (usually Linux ones), and might or might not\n+be emulated on other operating systems. Calls that are not emulated will\n+return C<-1> and set C<errno> to C<ENOSYS>.\n+\n+=over 4\n+\n+=item eio_sendfile (int out_fd, int in_fd, off_t in_offset, size_t length, int pri, eio_cb cb, void *data)\n+\n+Wraps the C<sendfile> syscall. The arguments follow the Linux version, but\n+libeio supports and will use similar calls on FreeBSD, HP/UX, Solaris and\n+Darwin.\n+\n+If the OS doesn't support some sendfile-like call, or the call fails,\n+indicating support for the given file descriptor type (for example,\n+Linux's sendfile might not support file to file copies), then libeio will\n+emulate the call in userspace, so there are almost no limitations on its\n+use.\n+\n+=item eio_readahead (int fd, off_t offset, size_t length, int pri, eio_cb cb, void *data)\n+\n+Calls C<readahead(2)>. If the syscall is missing, then the call is\n+emulated by simply reading the data (currently in 64kiB chunks).\n+\n+=item eio_syncfs (int fd, int pri, eio_cb cb, void *data)\n+\n+Calls Linux' C<syncfs> syscall, if available. Returns C<-1> and sets\n+C<errno> to C<ENOSYS> if the call is missing I<but still calls sync()>,\n+if the C<fd> is C<< >= 0 >>, so you can probe for the availability of the\n+syscall with a negative C<fd> argument and checking for C<-1/ENOSYS>.\n+\n+=item eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data)\n+\n+Calls C<sync_file_range>. If the syscall is missing, then this is the same\n+as calling C<fdatasync>.\n+\n+Flags can be any combination of C<EIO_SYNC_FILE_RANGE_WAIT_BEFORE>,\n+C<EIO_SYNC_FILE_RANGE_WRITE> and C<EIO_SYNC_FILE_RANGE_WAIT_AFTER>.\n+\n+=item eio_fallocate (int fd, int mode, off_t offset, off_t len, int pri, eio_cb cb, void *data)\n+\n+Calls C<fallocate> (note: I<NOT> C<posix_fallocate>!). If the syscall is\n+missing, then it returns failure and sets C<errno> to C<ENOSYS>.\n+\n+The C<mode> argument can be C<0> (for behaviour similar to\n+C<posix_fallocate>), or C<EIO_FALLOC_FL_KEEP_SIZE>, which keeps the size\n+of the file unchanged (but still preallocates space beyond end of file).\n+\n+=back\n+\n+=head3 LIBEIO-SPECIFIC REQUESTS\n+\n+These requests are specific to libeio and do not correspond to any OS call.\n+\n+=over 4\n+\n+=item eio_mtouch (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data)\n+\n+Reads (C<flags == 0>) or modifies (C<flags == EIO_MT_MODIFY) the given\n+memory area, page-wise, that is, it reads (or reads and writes back) the\n+first octet of every page that spans the memory area.\n+\n+This can be used to page in some mmapped file, or dirty some pages. Note\n+that dirtying is an unlocked read-write access, so races can ensue when\n+the some other thread modifies the data stored in that memory area.\n+\n+=item eio_custom (void (*)(eio_req *) execute, int pri, eio_cb cb, void *data)\n+\n+Executes a custom request, i.e., a user-specified callback.\n+\n+The callback gets the C<eio_req *> as parameter and is expected to read\n+and modify any request-specific members. Specifically, it should set C<<\n+req->result >> to the result value, just like other requests.\n+\n+Here is an example that simply calls C<open>, like C<eio_open>, but it\n+uses the C<data> member as filename and uses a hardcoded C<O_RDONLY>. If\n+you want to pass more/other parameters, you either need to pass some\n+struct or so via C<data> or provide your own wrapper using the low-level\n+API.\n+\n+  static int\n+  my_open_done (eio_req *req)\n+  {\n+    int fd = req->result;\n+\n+    return 0;\n+  }\n+\n+  static void\n+  my_open (eio_req *req)\n+  {\n+    req->result = open (req->data, O_RDONLY);\n+  }\n+\n+  eio_custom (my_open, 0, my_open_done, \"/etc/passwd\");\n+\n+=item eio_busy (eio_tstamp delay, int pri, eio_cb cb, void *data)\n+\n+This is a request that takes C<delay> seconds to execute, but otherwise\n+does nothing - it simply puts one of the worker threads to sleep for this\n+long.\n+\n+This request can be used to artificially increase load, e.g. for debugging\n+or benchmarking reasons.\n+\n+=item eio_nop (int pri, eio_cb cb, void *data)\n+   \n+This request does nothing, except go through the whole request cycle. This\n+can be used to measure latency or in some cases to simplify code, but is\n+not really of much use.\n+\n+=back\n+\n+=head3 GROUPING AND LIMITING REQUESTS\n+\n+There is one more rather special request, C<eio_grp>. It is a very special\n+aio request: Instead of doing something, it is a container for other eio\n+requests.\n+\n+There are two primary use cases for this: a) bundle many requests into a\n+single, composite, request with a definite callback and the ability to\n+cancel the whole request with its subrequests and b) limiting the number\n+of \"active\" requests.\n+\n+Further below you will find more discussion of these topics - first\n+follows the reference section detailing the request generator and other\n+methods.\n+\n+=over 4\n+\n+=item eio_req *grp = eio_grp (eio_cb cb, void *data)\n+\n+Creates, submits and returns a group request. Note that it doesn't have a\n+priority, unlike all other requests.\n+\n+=item eio_grp_add (eio_req *grp, eio_req *req)\n+\n+Adds a request to the request group.\n+\n+=item eio_grp_cancel (eio_req *grp)\n+\n+Cancels all requests I<in> the group, but I<not> the group request\n+itself. You can cancel the group request I<and> all subrequests via a\n+normal C<eio_cancel> call.\n+\n+=back\n+\n+=head4 GROUP REQUEST LIFETIME\n+\n+Left alone, a group request will instantly move to the pending state and\n+will be finished at the next call of C<eio_poll>.\n+\n+The usefulness stems from the fact that, if a subrequest is added to a\n+group I<before> a call to C<eio_poll>, via C<eio_grp_add>, then the group\n+will not finish until all the subrequests have finished.\n+\n+So the usage cycle of a group request is like this: after it is created,\n+you normally instantly add a subrequest. If none is added, the group\n+request will finish on it's own. As long as subrequests are added before\n+the group request is finished it will be kept from finishing, that is the\n+callbacks of any subrequests can, in turn, add more requests to the group,\n+and as long as any requests are active, the group request itself will not\n+finish.\n+\n+=head4 CREATING COMPOSITE REQUESTS\n+\n+Imagine you wanted to create an C<eio_load> request that opens a file,\n+reads it and closes it. This means it has to execute at least three eio\n+requests, but for various reasons it might be nice if that request looked\n+like any other eio request.\n+\n+This can be done with groups:\n+\n+=over 4\n+\n+=item 1) create the request object\n+\n+Create a group that contains all further requests. This is the request you\n+can return as \"the load request\".\n+\n+=item 2) open the file, maybe\n+\n+Next, open the file with C<eio_open> and add the request to the group\n+request and you are finished setting up the request.\n+\n+If, for some reason, you cannot C<eio_open> (path is a null ptr?) you\n+can set C<< grp->result >> to C<-1> to signal an error and let the group\n+request finish on its own.\n+\n+=item 3) open callback adds more requests\n+\n+In the open callback, if the open was not successful, copy C<<\n+req->errorno >> to C<< grp->errorno >> and set C<< grp->errorno >> to\n+C<-1> to signal an error.\n+\n+Otherwise, malloc some memory or so and issue a read request, adding the\n+read request to the group.\n+\n+=item 4) continue issuing requests till finished\n+\n+In the real callback, check for errors and possibly continue with\n+C<eio_close> or any other eio request in the same way.\n+\n+As soon as no new requests are added the group request will finish. Make\n+sure you I<always> set C<< grp->result >> to some sensible value.\n+\n+=back\n+\n+=head4 REQUEST LIMITING\n+\n+\n+#TODO\n+\n+void eio_grp_limit     (eio_req *grp, int limit);\n+\n+\n+=back\n+\n+\n+=head1 LOW LEVEL REQUEST API\n+\n+#TODO\n+\n+\n+=head1 ANATOMY AND LIFETIME OF AN EIO REQUEST\n+\n+A request is represented by a structure of type C<eio_req>. To initialise\n+it, clear it to all zero bytes:\n+\n+  eio_req req;\n+\n+  memset (&req, 0, sizeof (req));\n+\n+A more common way to initialise a new C<eio_req> is to use C<calloc>:\n+\n+  eio_req *req = calloc (1, sizeof (*req));\n+\n+In either case, libeio neither allocates, initialises or frees the\n+C<eio_req> structure for you - it merely uses it.\n+\n+zero\n+\n+#TODO\n+\n+=head2 CONFIGURATION\n+\n+The functions in this section can sometimes be useful, but the default\n+configuration will do in most case, so you should skip this section on\n+first reading.\n+\n+=over 4\n+\n+=item eio_set_max_poll_time (eio_tstamp nseconds)\n+\n+This causes C<eio_poll ()> to return after it has detected that it was\n+running for C<nsecond> seconds or longer (this number can be fractional).\n+\n+This can be used to limit the amount of time spent handling eio requests,\n+for example, in interactive programs, you might want to limit this time to\n+C<0.01> seconds or so.\n+\n+Note that:\n+\n+=over 4\n+\n+=item a) libeio doesn't know how long your request callbacks take, so the\n+time spent in C<eio_poll> is up to one callback invocation longer then\n+this interval.\n+\n+=item b) this is implemented by calling C<gettimeofday> after each\n+request, which can be costly.\n+\n+=item c) at least one request will be handled.\n+\n+=back\n+\n+=item eio_set_max_poll_reqs (unsigned int nreqs)\n+\n+When C<nreqs> is non-zero, then C<eio_poll> will not handle more than\n+C<nreqs> requests per invocation. This is a less costly way to limit the\n+amount of work done by C<eio_poll> then setting a time limit.\n+\n+If you know your callbacks are generally fast, you could use this to\n+encourage interactiveness in your programs by setting it to C<10>, C<100>\n+or even C<1000>.\n+\n+=item eio_set_min_parallel (unsigned int nthreads)\n+\n+Make sure libeio can handle at least this many requests in parallel. It\n+might be able handle more.\n+\n+=item eio_set_max_parallel (unsigned int nthreads)\n+\n+Set the maximum number of threads that libeio will spawn.\n+\n+=item eio_set_max_idle (unsigned int nthreads)\n+\n+Libeio uses threads internally to handle most requests, and will start and stop threads on demand.\n+\n+This call can be used to limit the number of idle threads (threads without\n+work to do): libeio will keep some threads idle in preparation for more\n+requests, but never longer than C<nthreads> threads.\n+\n+In addition to this, libeio will also stop threads when they are idle for\n+a few seconds, regardless of this setting.\n+\n+=item unsigned int eio_nthreads ()\n+\n+Return the number of worker threads currently running.\n+\n+=item unsigned int eio_nreqs ()\n+\n+Return the number of requests currently handled by libeio. This is the\n+total number of requests that have been submitted to libeio, but not yet\n+destroyed.\n+\n+=item unsigned int eio_nready ()\n+\n+Returns the number of ready requests, i.e. requests that have been\n+submitted but have not yet entered the execution phase.\n+\n+=item unsigned int eio_npending ()\n+\n+Returns the number of pending requests, i.e. requests that have been\n+executed and have results, but have not been finished yet by a call to\n+C<eio_poll>).\n+\n+=back\n+\n+=head1 EMBEDDING\n+\n+Libeio can be embedded directly into programs. This functionality is not\n+documented and not (yet) officially supported.\n+\n+Note that, when including C<libeio.m4>, you are responsible for defining\n+the compilation environment (C<_LARGEFILE_SOURCE>, C<_GNU_SOURCE> etc.).\n+\n+If you need to know how, check the C<IO::AIO> perl module, which does\n+exactly that.\n+\n+\n+=head1 COMPILETIME CONFIGURATION\n+\n+These symbols, if used, must be defined when compiling F<eio.c>.\n+\n+=over 4\n+\n+=item EIO_STACKSIZE\n+\n+This symbol governs the stack size for each eio thread. Libeio itself\n+was written to use very little stackspace, but when using C<EIO_CUSTOM>\n+requests, you might want to increase this.\n+\n+If this symbol is undefined (the default) then libeio will use its default\n+stack size (C<sizeof (void *) * 4096> currently). If it is defined, but\n+C<0>, then the default operating system stack size will be used. In all\n+other cases, the value must be an expression that evaluates to the desired\n+stack size.\n+\n+=back\n+\n+\n+=head1 PORTABILITY REQUIREMENTS\n+\n+In addition to a working ISO-C implementation, libeio relies on a few\n+additional extensions:\n+\n+=over 4\n+\n+=item POSIX threads\n+\n+To be portable, this module uses threads, specifically, the POSIX threads\n+library must be available (and working, which partially excludes many xBSD\n+systems, where C<fork ()> is buggy).\n+\n+=item POSIX-compatible filesystem API\n+\n+This is actually a harder portability requirement: The libeio API is quite\n+demanding regarding POSIX API calls (symlinks, user/group management\n+etc.).\n+\n+=item C<double> must hold a time value in seconds with enough accuracy\n+\n+The type C<double> is used to represent timestamps. It is required to\n+have at least 51 bits of mantissa (and 9 bits of exponent), which is good\n+enough for at least into the year 4000. This requirement is fulfilled by\n+implementations implementing IEEE 754 (basically all existing ones).\n+\n+=back\n+\n+If you know of other additional requirements drop me a note.\n+\n+\n+=head1 AUTHOR\n+\n+Marc Lehmann <libeio@schmorp.de>.\n+"}, {"sha": "59151f5348a6f181b8330be0083f3ea728db2449", "filename": "src/rt/libuv/src/unix/eio/libeio.m4", "status": "renamed", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -1,3 +1,7 @@\n+dnl openbsd in it's neverending brokenness requires stdint.h for intptr_t,\n+dnl but that header isn't very portable...\n+AC_CHECK_HEADERS([stdint.h sys/syscall.h sys/prctl.h])\n+\n AC_SEARCH_LIBS(\n    pthread_create,\n    [pthread pthreads pthreadVC2],\n@@ -119,6 +123,41 @@ int main (void)\n ],ac_cv_sync_file_range=yes,ac_cv_sync_file_range=no)])\n test $ac_cv_sync_file_range = yes && AC_DEFINE(HAVE_SYNC_FILE_RANGE, 1, sync_file_range(2) is available)\n \n+AC_CACHE_CHECK(for fallocate, ac_cv_fallocate, [AC_LINK_IFELSE([\n+#include <fcntl.h>\n+int main (void)\n+{\n+   int fd = 0;\n+   int mode = 0;\n+   off_t offset = 1;\n+   off_t len = 1;\n+   int res;\n+   res = fallocate (fd, mode, offset, len);\n+   return 0;\n+}\n+],ac_cv_fallocate=yes,ac_cv_fallocate=no)])\n+test $ac_cv_fallocate = yes && AC_DEFINE(HAVE_FALLOCATE, 1, fallocate(2) is available)\n+\n+AC_CACHE_CHECK(for sys_syncfs, ac_cv_sys_syncfs, [AC_LINK_IFELSE([\n+#include <unistd.h>\n+#include <sys/syscall.h>\n+int main (void)\n+{\n+  int res = syscall (__NR_syncfs, (int)0);\n+}\n+],ac_cv_sys_syncfs=yes,ac_cv_sys_syncfs=no)])\n+test $ac_cv_sys_syncfs = yes && AC_DEFINE(HAVE_SYS_SYNCFS, 1, syscall(__NR_syncfs) is available)\n+\n+AC_CACHE_CHECK(for prctl_set_name, ac_cv_prctl_set_name, [AC_LINK_IFELSE([\n+#include <sys/prctl.h>\n+int main (void)\n+{\n+  char name[] = \"test123\";\n+  int res = prctl (PR_SET_NAME, (unsigned long)name, 0, 0, 0);\n+}\n+],ac_cv_prctl_set_name=yes,ac_cv_prctl_set_name=no)])\n+test $ac_cv_prctl_set_name = yes && AC_DEFINE(HAVE_PRCTL_SET_NAME, 1, prctl(PR_SET_NAME) is available)\n+\n dnl #############################################################################\n dnl # these checks exist for the benefit of IO::AIO\n ", "previous_filename": "src/rt/libuv/src/eio/libeio.m4"}, {"sha": "7184c7bb73fb8f0b4c6835abfd26e4d0e59e93c1", "filename": "src/rt/libuv/src/unix/eio/xthread.h", "status": "renamed", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -2,7 +2,7 @@\n #define XTHREAD_H_\n \n /* whether word reads are potentially non-atomic.\n- * this is conservatice, likely most arches this runs\n+ * this is conservative, likely most arches this runs\n  * on have atomic word read/writes.\n  */\n #ifndef WORDACCESS_UNSAFE\n@@ -17,14 +17,6 @@\n \n #ifdef _WIN32\n \n-#ifndef __MINGW32__\n-typedef int ssize_t\n-#endif\n-\n-#define NTDDI_VERSION NTDDI_WIN2K // needed to get win2000 api calls\n-#ifndef _WIN32_WINNT\n-#define _WIN32_WINNT 0x400\n-#endif\n #include <stdio.h>//D\n #include <fcntl.h>\n #include <io.h>\n@@ -34,18 +26,20 @@ typedef int ssize_t\n #include <windows.h>\n #include <pthread.h>\n #define sigset_t int\n+#define sigfillset(a)\n #define pthread_sigmask(a,b,c)\n #define sigaddset(a,b)\n #define sigemptyset(s)\n-#define sigfillset(s)\n \n typedef pthread_mutex_t xmutex_t;\n #define X_MUTEX_INIT           PTHREAD_MUTEX_INITIALIZER\n+#define X_MUTEX_CREATE(mutex)  pthread_mutex_init (&(mutex), 0)\n #define X_LOCK(mutex)          pthread_mutex_lock (&(mutex))\n #define X_UNLOCK(mutex)        pthread_mutex_unlock (&(mutex))\n \n typedef pthread_cond_t xcond_t;\n #define X_COND_INIT                     PTHREAD_COND_INITIALIZER\n+#define X_COND_CREATE(cond)\t\tpthread_cond_init (&(cond), 0)\n #define X_COND_SIGNAL(cond)             pthread_cond_signal (&(cond))\n #define X_COND_WAIT(cond,mutex)         pthread_cond_wait (&(cond), &(mutex))\n #define X_COND_TIMEDWAIT(cond,mutex,to) pthread_cond_timedwait (&(cond), &(mutex), &(to))\n@@ -100,18 +94,27 @@ thread_create (xthread_t *tid, void *(*proc)(void *), void *arg)\n \n typedef pthread_mutex_t xmutex_t;\n #if __linux && defined (PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP)\n-# define X_MUTEX_INIT PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP\n+# define X_MUTEX_INIT\t\tPTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP\n+# define X_MUTEX_CREATE(mutex)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    pthread_mutexattr_t attr;\t\t\t\t\t\t\\\n+    pthread_mutexattr_init (&attr);\t\t\t\t\t\\\n+    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\t\\\n+    pthread_mutex_init (&(mutex), &attr);\t\t\t\t\\\n+  } while (0)\n #else\n-# define X_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n+# define X_MUTEX_INIT\t\tPTHREAD_MUTEX_INITIALIZER\n+# define X_MUTEX_CREATE(mutex)\tpthread_mutex_init (&(mutex), 0)\n #endif\n-#define X_LOCK(mutex)   pthread_mutex_lock   (&(mutex))\n-#define X_UNLOCK(mutex) pthread_mutex_unlock (&(mutex))\n+#define X_LOCK(mutex)\t\tpthread_mutex_lock   (&(mutex))\n+#define X_UNLOCK(mutex)\t\tpthread_mutex_unlock (&(mutex))\n \n typedef pthread_cond_t xcond_t;\n-#define X_COND_INIT PTHREAD_COND_INITIALIZER\n-#define X_COND_SIGNAL(cond) pthread_cond_signal (&(cond))\n-#define X_COND_WAIT(cond,mutex) pthread_cond_wait (&(cond), &(mutex))\n-#define X_COND_TIMEDWAIT(cond,mutex,to) pthread_cond_timedwait (&(cond), &(mutex), &(to))\n+#define X_COND_INIT\t\t\tPTHREAD_COND_INITIALIZER\n+#define X_COND_CREATE(cond)\t\tpthread_cond_init (&(cond), 0)\n+#define X_COND_SIGNAL(cond)\t\tpthread_cond_signal (&(cond))\n+#define X_COND_WAIT(cond,mutex)\t\tpthread_cond_wait (&(cond), &(mutex))\n+#define X_COND_TIMEDWAIT(cond,mutex,to)\tpthread_cond_timedwait (&(cond), &(mutex), &(to))\n \n typedef pthread_t xthread_t;\n #define X_THREAD_PROC(name) static void *name (void *thr_arg)\n@@ -122,8 +125,8 @@ typedef pthread_t xthread_t;\n # define PTHREAD_STACK_MIN 0\n #endif\n \n-#ifndef X_STACKSIZE\n-# define X_STACKSIZE sizeof (long) * 4096\n+#ifndef XTHREAD_STACKSIZE\n+# define XTHREAD_STACKSIZE sizeof (void *) * 4096\n #endif\n \n static int", "previous_filename": "src/rt/libuv/src/eio/xthread.h"}, {"sha": "3520eec719bbfc50c58fd05695dfe9c243446733", "filename": "src/rt/libuv/src/unix/error.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,110 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+/*\n+ * TODO Share this code with Windows.\n+ * See https://github.com/joyent/libuv/issues/76\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* TODO Expose callback to user to handle fatal error like V8 does. */\n+void uv_fatal_error(const int errorno, const char* syscall) {\n+  char* buf = NULL;\n+  const char* errmsg;\n+\n+  if (buf) {\n+    errmsg = buf;\n+  } else {\n+    errmsg = \"Unknown error\";\n+  }\n+\n+  if (syscall) {\n+    fprintf(stderr, \"\\nlibuv fatal error. %s: (%d) %s\\n\", syscall, errorno,\n+        errmsg);\n+  } else {\n+    fprintf(stderr, \"\\nlibuv fatal error. (%d) %s\\n\", errorno, errmsg);\n+  }\n+\n+  abort();\n+}\n+\n+\n+uv_err_t uv_last_error(uv_loop_t* loop) {\n+  return loop->last_err;\n+}\n+\n+\n+char* uv_strerror(uv_err_t err) {\n+  return strerror(err.sys_errno_);\n+}\n+\n+\n+uv_err_code uv_translate_sys_error(int sys_errno) {\n+  switch (sys_errno) {\n+    case 0: return UV_OK;\n+    case ENOENT: return UV_ENOENT;\n+    case EACCES: return UV_EACCESS;\n+    case EBADF: return UV_EBADF;\n+    case EPIPE: return UV_EPIPE;\n+    case EAGAIN: return UV_EAGAIN;\n+    case ECONNRESET: return UV_ECONNRESET;\n+    case EFAULT: return UV_EFAULT;\n+    case EMFILE: return UV_EMFILE;\n+    case EMSGSIZE: return UV_EMSGSIZE;\n+    case EINVAL: return UV_EINVAL;\n+    case ECONNREFUSED: return UV_ECONNREFUSED;\n+    case EADDRINUSE: return UV_EADDRINUSE;\n+    case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;\n+    case ENOTCONN: return UV_ENOTCONN;\n+    case EEXIST: return UV_EEXIST;\n+    default: return UV_UNKNOWN;\n+  }\n+\n+  assert(0 && \"unreachable\");\n+  return -1;\n+}\n+\n+\n+uv_err_t uv_err_new_artificial(uv_loop_t* loop, int code) {\n+  uv_err_t err;\n+  err.sys_errno_ = 0;\n+  err.code = code;\n+  loop->last_err = err;\n+  return err;\n+}\n+\n+\n+uv_err_t uv_err_new(uv_loop_t* loop, int sys_error) {\n+  uv_err_t err;\n+  err.sys_errno_ = sys_error;\n+  err.code = uv_translate_sys_error(sys_error);\n+  loop->last_err = err;\n+  return err;\n+}"}, {"sha": "d6fca2f67cde91d0c45c9d2e4fbf450d7fb95c6c", "filename": "src/rt/libuv/src/unix/ev/Changes", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/Changes"}, {"sha": "7fa0e9f844f0bcc1f34a48c63b2388b02ac5d9e6", "filename": "src/rt/libuv/src/unix/ev/LICENSE", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/LICENSE"}, {"sha": "058c2cb0c1efc542c9539bcde4499524d6eaa102", "filename": "src/rt/libuv/src/unix/ev/Makefile.am", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/Makefile.am"}, {"sha": "9817a7ebd7f4331b09a5fff5dc5b40dd35c1d778", "filename": "src/rt/libuv/src/unix/ev/Makefile.in", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/Makefile.in"}, {"sha": "ca403c6f470494320d5de96f75f16f99946c68ac", "filename": "src/rt/libuv/src/unix/ev/README", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/README"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/unix/ev/aclocal.m4", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/aclocal.m4"}, {"sha": "087d2aa4e963b767adc7a08d828852875e436686", "filename": "src/rt/libuv/src/unix/ev/autogen.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/autogen.sh"}, {"sha": "f32079abda668e5fc8f8de6f226e7b26384e8a03", "filename": "src/rt/libuv/src/unix/ev/config.guess", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config.guess"}, {"sha": "75da15cce7e7552e5770d1a1ca44f42762c9587b", "filename": "src/rt/libuv/src/unix/ev/config.h.in", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config.h.in"}, {"sha": "6759825a5b7fcf64476b4398dc0e30b3090b925c", "filename": "src/rt/libuv/src/unix/ev/config.sub", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config.sub"}, {"sha": "1f6f6d98c815e28d66bcbb23c8a3188ff7f3a2b3", "filename": "src/rt/libuv/src/unix/ev/config_cygwin.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config_cygwin.h"}, {"sha": "03e3b219ec98ecf939dd47d8bdeb990cab564314", "filename": "src/rt/libuv/src/unix/ev/config_darwin.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config_darwin.h"}, {"sha": "ebebd4156d2e036e1e101e7868b5caac1344f86b", "filename": "src/rt/libuv/src/unix/ev/config_freebsd.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config_freebsd.h"}, {"sha": "a13b179f280506224da315742e1d32f8ac421327", "filename": "src/rt/libuv/src/unix/ev/config_linux.h", "status": "renamed", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -2,12 +2,7 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n #include <linux/version.h>\n-\n-#define LINUX_VERSION_CODE_FOR(major, minor, patch) \\\n-  (((major & 255) << 16) | ((minor & 255) << 8) | (patch & 255))\n-\n-#define LINUX_VERSION_AT_LEAST(major, minor, patch) \\\n-  (LINUX_VERSION_CODE >= LINUX_VERSION_CODE_FOR(major, minor, patch))\n+#include <features.h>\n \n /* Define to 1 if you have the `clock_gettime' function. */\n /* #undef HAVE_CLOCK_GETTIME */\n@@ -18,14 +13,26 @@\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #define HAVE_DLFCN_H 1\n \n-/* Define to 1 if you have the `epoll_ctl' function. */\n+/* epoll_ctl(2) is available if kernel >= 2.6.9 and glibc >= 2.4 */\n+#if LINUX_VERSION_CODE >= 0x020609 && __GLIBC_PREREQ(2, 4)\n #define HAVE_EPOLL_CTL 1\n-\n-/* Define to 1 if you have the `eventfd' function. */\n-#define HAVE_EVENTFD LINUX_VERSION_AT_LEAST(2, 6, 22)\n-\n-/* Define to 1 if you have the `inotify_init' function. */\n-#define HAVE_INOTIFY_INIT LINUX_VERSION_AT_LEAST(2, 6, 13)\n+#else\n+#define HAVE_EPOLL_CTL 0\n+#endif\n+\n+/* eventfd(2) is available if kernel >= 2.6.22 and glibc >= 2.8 */\n+#if LINUX_VERSION_CODE >= 0x020616 && __GLIBC_PREREQ(2, 8)\n+#define HAVE_EVENTFD 1\n+#else\n+#define HAVE_EVENTFD 0\n+#endif\n+\n+/* inotify_init(2) is available if kernel >= 2.6.13 and glibc >= 2.4 */\n+#if LINUX_VERSION_CODE >= 0x02060d && __GLIBC_PREREQ(2, 4)\n+#define HAVE_INOTIFY_INIT 1\n+#else\n+#define HAVE_INOTIFY_INIT 0\n+#endif\n \n /* Define to 1 if you have the <inttypes.h> header file. */\n #define HAVE_INTTYPES_H 1\n@@ -60,8 +67,12 @@\n /* Define to 1 if you have the `select' function. */\n #define HAVE_SELECT 1\n \n-/* Define to 1 if you have the `signalfd' function. */\n-#define HAVE_SIGNALFD LINUX_VERSION_AT_LEAST(2, 6, 22)\n+/* signalfd(2) is available if kernel >= 2.6.22 and glibc >= 2.8 */\n+#if LINUX_VERSION_CODE >= 0x020616 && __GLIBC_PREREQ(2, 8)\n+#define HAVE_SIGNALFD 1\n+#else\n+#define HAVE_SIGNALFD 0\n+#endif\n \n /* Define to 1 if you have the <stdint.h> header file. */\n #define HAVE_STDINT_H 1", "previous_filename": "src/rt/libuv/src/ev/config_linux.h"}, {"sha": "ebebd4156d2e036e1e101e7868b5caac1344f86b", "filename": "src/rt/libuv/src/unix/ev/config_netbsd.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,120 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the `clock_gettime' function. */\n+/* #undef HAVE_CLOCK_GETTIME */\n+\n+/* \"use syscall interface for clock_gettime\" */\n+/* #undef HAVE_CLOCK_SYSCALL */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the `epoll_ctl' function. */\n+/* #undef HAVE_EPOLL_CTL */\n+\n+/* Define to 1 if you have the `eventfd' function. */\n+/* #undef HAVE_EVENTFD */\n+\n+/* Define to 1 if you have the `inotify_init' function. */\n+/* #undef HAVE_INOTIFY_INIT */\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the `kqueue' function. */\n+#define HAVE_KQUEUE 1\n+\n+/* Define to 1 if you have the `m' library (-lm). */\n+#define HAVE_LIBM 1\n+\n+/* Define to 1 if you have the `rt' library (-lrt). */\n+/* #undef HAVE_LIBRT */\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the `nanosleep' function. */\n+/* #undef HAVE_NANOSLEEP */\n+\n+/* Define to 1 if you have the `poll' function. */\n+#define HAVE_POLL 1\n+\n+/* Define to 1 if you have the <poll.h> header file. */\n+#define HAVE_POLL_H 1\n+\n+/* Define to 1 if you have the `port_create' function. */\n+/* #undef HAVE_PORT_CREATE */\n+\n+/* Define to 1 if you have the <port.h> header file. */\n+/* #undef HAVE_PORT_H */\n+\n+/* Define to 1 if you have the `select' function. */\n+#define HAVE_SELECT 1\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the <sys/epoll.h> header file. */\n+/* #undef HAVE_SYS_EPOLL_H */\n+\n+/* Define to 1 if you have the <sys/eventfd.h> header file. */\n+/* #undef HAVE_SYS_EVENTFD_H */\n+\n+/* Define to 1 if you have the <sys/event.h> header file. */\n+#define HAVE_SYS_EVENT_H 1\n+\n+/* Define to 1 if you have the <sys/inotify.h> header file. */\n+/* #undef HAVE_SYS_INOTIFY_H */\n+\n+/* Define to 1 if you have the <sys/queue.h> header file. */\n+#define HAVE_SYS_QUEUE_H 1\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libev\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"3.9\""}, {"sha": "9f8861d8a369219be47c314e18d738005e2049f4", "filename": "src/rt/libuv/src/unix/ev/config_sunos.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/config_sunos.h"}, {"sha": "98f102f1e42ed1f005a751278302ff5ea66e95d9", "filename": "src/rt/libuv/src/unix/ev/configure", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/configure"}, {"sha": "03a784f2eba9bcc262637747cc3984b3d4eb2c8f", "filename": "src/rt/libuv/src/unix/ev/configure.ac", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/configure.ac"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "src/rt/libuv/src/unix/ev/depcomp", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/depcomp"}, {"sha": "ce42b5f2de0ef0241d258db609f26eab72f4b2eb", "filename": "src/rt/libuv/src/unix/ev/ev++.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev++.h"}, {"sha": "f2a4514582eb89bd724adb6e3dae9e0d49006f44", "filename": "src/rt/libuv/src/unix/ev/ev.3", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev.3"}, {"sha": "5e616c254fcb737f453961d8cf9d1947805bc857", "filename": "src/rt/libuv/src/unix/ev/ev.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -3846,7 +3846,7 @@ ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w))\n \n #if EV_IDLE_ENABLE\n   if (types & EV_IDLE)\n-    for (j = NUMPRI; i--; )\n+    for (j = NUMPRI; j--; )\n       for (i = idlecnt [j]; i--; )\n         cb (EV_A_ EV_IDLE, idles [j][i]);\n #endif", "previous_filename": "src/rt/libuv/src/ev/ev.c"}, {"sha": "4bbef1fcf25b3deb62c8a31bb4fddd2b844c598b", "filename": "src/rt/libuv/src/unix/ev/ev.pod", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev.pod"}, {"sha": "5deb65211181541bbac3f7082856ccdeef3beeba", "filename": "src/rt/libuv/src/unix/ev/ev_epoll.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_epoll.c"}, {"sha": "1b526d1c7bc0ded3fb3cc8e0124ec9f85b50ebc5", "filename": "src/rt/libuv/src/unix/ev/ev_kqueue.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_kqueue.c"}, {"sha": "e53ae0de93c6055e2346e1a5d02afab295ea3e20", "filename": "src/rt/libuv/src/unix/ev/ev_poll.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_poll.c"}, {"sha": "0ffebc372672866e3bfde9abe18cbf717b32a24f", "filename": "src/rt/libuv/src/unix/ev/ev_port.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_port.c"}, {"sha": "0ea9467e4015a5df7fcf1de9536f8f8d803cdaf6", "filename": "src/rt/libuv/src/unix/ev/ev_select.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_select.c"}, {"sha": "5ee3ed1b2a0eb2368cce927ba8af84bf37d8898f", "filename": "src/rt/libuv/src/unix/ev/ev_vars.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_vars.h"}, {"sha": "338886efe407cfba00e33a1e425cc90d4d760a0c", "filename": "src/rt/libuv/src/unix/ev/ev_win32.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_win32.c"}, {"sha": "2c195c5db4b2f8e65de6e55603b9752f3729b24b", "filename": "src/rt/libuv/src/unix/ev/ev_wrap.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ev_wrap.h"}, {"sha": "aaf6d534ca45f8c2c7041e3329bbda88a1d08ad6", "filename": "src/rt/libuv/src/unix/ev/event.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/event.c"}, {"sha": "10ff05a3cb4d64a397bb3aada943f2836858161a", "filename": "src/rt/libuv/src/unix/ev/event.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/event.h"}, {"sha": "6ce63b9f76bc6ab5ff08f967f52f8cf4c53a1353", "filename": "src/rt/libuv/src/unix/ev/install-sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/install-sh"}, {"sha": "e3f4c81b236d53a9f0ea2aa965a4264b2958bfcd", "filename": "src/rt/libuv/src/unix/ev/libev.m4", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/libev.m4"}, {"sha": "d88da2c264c8c312b286a83ae06d688d5287361a", "filename": "src/rt/libuv/src/unix/ev/ltmain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/ltmain.sh"}, {"sha": "fc54c64ec969d9c1630335d8a88c5d72d3ca0856", "filename": "src/rt/libuv/src/unix/ev/missing", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/missing"}, {"sha": "d2d5f21b611235316317197d3a32c2dff5897a6f", "filename": "src/rt/libuv/src/unix/ev/mkinstalldirs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/src/ev/mkinstalldirs"}, {"sha": "449aad4c211c367a0ed6ba06427e5b7cd6998178", "filename": "src/rt/libuv/src/unix/freebsd.c", "status": "renamed", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -20,18 +20,19 @@\n \n #include \"uv.h\"\n \n-#include <stdint.h>\n-#include <stddef.h>\n+#include <assert.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n #include <time.h>\n \n #undef NANOSEC\n #define NANOSEC 1000000000\n \n-/*\n- * There's probably some way to get time from Linux than gettimeofday(). What\n- * it is, I don't know.\n- */\n-uint64_t uv_hrtime() {\n+\n+uint64_t uv_hrtime(void) {\n   struct timespec ts;\n   clock_gettime(CLOCK_MONOTONIC, &ts);\n   return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n@@ -43,13 +44,39 @@ int uv_exepath(char* buffer, size_t* size) {\n   int result;\n   char* path;\n   char* fullpath;\n+  int mib[4];\n+  size_t cb;\n \n   if (!buffer || !size) {\n     return -1;\n   }\n \n-  *size = readlink(\"/proc/self/exe\", buffer, *size - 1);\n-  if (*size <= 0) return -1;\n-  buffer[*size] = '\\0';\n+\n+  mib[0] = CTL_KERN;\n+  mib[1] = KERN_PROC;\n+  mib[2] = KERN_PROC_PATHNAME;\n+  mib[3] = -1;\n+\n+  cb = *size;\n+  if (sysctl(mib, 4, buffer, &cb, NULL, 0) < 0) {\n+    *size = 0;\n+    return -1;\n+  }\n+  *size = strlen(buffer);\n+\n   return 0;\n }\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"implement me\");\n+}", "previous_filename": "src/rt/libuv/src/uv-linux.c"}, {"sha": "d745622835be0660f57aba2fe0367c01d07c5f10", "filename": "src/rt/libuv/src/unix/fs.c", "status": "added", "additions": 697, "deletions": 0, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,697 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+#include \"eio.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <dirent.h>\n+#include <assert.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <utime.h>\n+#include <sys/time.h>\n+\n+\n+#define ARGS1(a)       (a)\n+#define ARGS2(a,b)     (a), (b)\n+#define ARGS3(a,b,c)   (a), (b), (c)\n+#define ARGS4(a,b,c,d) (a), (b), (c), (d)\n+\n+#define WRAP_EIO(type, eiofunc, func, args) \\\n+  uv_fs_req_init(loop, req, type, path, cb); \\\n+  if (cb) { \\\n+    /* async */ \\\n+    req->eio = eiofunc(args, EIO_PRI_DEFAULT, uv__fs_after, req); \\\n+    if (!req->eio) { \\\n+      uv_err_new(loop, ENOMEM); \\\n+      return -1; \\\n+    } \\\n+    uv_ref(loop); \\\n+  } else { \\\n+    /* sync */ \\\n+    req->result = func(args); \\\n+    if (req->result) { \\\n+      uv_err_new(loop, errno); \\\n+    }  \\\n+    return req->result; \\\n+  } \\\n+  return 0;\n+\n+\n+static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req, uv_fs_type fs_type,\n+    const char* path, uv_fs_cb cb) {\n+  /* Make sure the thread pool is initialized. */\n+  uv_eio_init(loop);\n+\n+  uv__req_init((uv_req_t*) req);\n+  req->type = UV_FS;\n+  req->loop = loop;\n+  req->fs_type = fs_type;\n+  req->cb = cb;\n+  req->result = 0;\n+  req->ptr = NULL;\n+  req->path = path ? strdup(path) : NULL;\n+  req->errorno = 0;\n+  req->eio = NULL;\n+}\n+\n+\n+void uv_fs_req_cleanup(uv_fs_t* req) {\n+  free(req->path);\n+  req->path = NULL;\n+\n+  switch (req->fs_type) {\n+    case UV_FS_READDIR:\n+      assert((req->result == -1 && req->ptr == NULL)\n+          || (req->result >= 0 && req->ptr != NULL));\n+      free(req->ptr);\n+      req->ptr = NULL;\n+      break;\n+\n+    case UV_FS_STAT:\n+    case UV_FS_LSTAT:\n+      req->ptr = NULL;\n+      break;\n+\n+    default:\n+      break;\n+  }\n+}\n+\n+\n+static int uv__fs_after(eio_req* eio) {\n+  char* name;\n+  int namelen;\n+  int buflen = 0;\n+  uv_fs_t* req = eio->data;\n+  int i;\n+\n+  assert(req->cb);\n+\n+  req->result = req->eio->result;\n+  req->errorno = uv_translate_sys_error(req->eio->errorno);\n+\n+  switch (req->fs_type) {\n+    case UV_FS_READDIR:\n+      if (req->eio->result == -1)\n+        break; /* opendir() or readdir() operation failed. */\n+\n+      /*\n+       * XXX This is pretty bad.\n+       * We alloc and copy the large null terminated string list from libeio.\n+       * This is done because libeio is going to free eio->ptr2 after this\n+       * callback. We must keep it until uv_fs_req_cleanup. If we get rid of\n+       * libeio this can be avoided.\n+       */\n+      buflen = 0;\n+      name = req->eio->ptr2;\n+      for (i = 0; i < req->result; i++) {\n+        namelen = strlen(name);\n+        buflen += namelen + 1;\n+        /* TODO check ENOMEM */\n+        name += namelen;\n+        assert(*name == '\\0');\n+        name++;\n+      }\n+      req->ptr = malloc(buflen);\n+      memcpy(req->ptr, req->eio->ptr2, buflen);\n+      break;\n+\n+    case UV_FS_STAT:\n+    case UV_FS_LSTAT:\n+    case UV_FS_FSTAT:\n+      req->ptr = req->eio->ptr2;\n+      break;\n+\n+    case UV_FS_READLINK:\n+      if (req->result == -1) {\n+        req->ptr = NULL;\n+      } else {\n+        assert(req->result > 0);\n+\n+        if ((name = realloc(req->eio->ptr2, req->result + 1)) == NULL) {\n+          /* Not enough memory. Reuse buffer, chop off last byte. */\n+          name = req->eio->ptr2;\n+          req->result--;\n+        }\n+\n+        name[req->result] = '\\0';\n+        req->ptr = name;\n+        req->result = 0;\n+      }\n+      break;\n+\n+    default:\n+      break;\n+  }\n+\n+  uv_unref(req->loop);\n+  req->eio = NULL; /* Freed by libeio */\n+\n+  req->cb(req);\n+  return 0;\n+}\n+\n+\n+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_CLOSE, eio_close, close, ARGS1(file));\n+}\n+\n+\n+int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+    int mode, uv_fs_cb cb) {\n+  uv_fs_req_init(loop, req, UV_FS_OPEN, path, cb);\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_open(path, flags, mode, EIO_PRI_DEFAULT, uv__fs_after, req);\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = open(path, flags, mode);\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    uv__cloexec(req->result, 1);\n+\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n+    size_t length, off_t offset, uv_fs_cb cb) {\n+  uv_fs_req_init(loop, req, UV_FS_READ, NULL, cb);\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_read(fd, buf, length, offset, EIO_PRI_DEFAULT,\n+        uv__fs_after, req);\n+\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = offset < 0 ?\n+      read(fd, buf, length) :\n+      pread(fd, buf, length, offset);\n+\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_UNLINK, eio_unlink, unlink, ARGS1(path))\n+}\n+\n+\n+int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n+    size_t length, off_t offset, uv_fs_cb cb) {\n+  uv_fs_req_init(loop, req, UV_FS_WRITE, NULL, cb);\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_write(file, buf, length, offset, EIO_PRI_DEFAULT,\n+        uv__fs_after, req);\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = offset < 0 ?\n+        write(file, buf, length) :\n+        pwrite(file, buf, length, offset);\n+\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n+    uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_MKDIR, eio_mkdir, mkdir, ARGS2(path, mode))\n+}\n+\n+\n+int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_RMDIR, eio_rmdir, rmdir, ARGS1(path))\n+}\n+\n+\n+int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+    uv_fs_cb cb) {\n+  int r;\n+  struct dirent* entry;\n+  size_t size = 0;\n+  size_t d_namlen = 0;\n+\n+  uv_fs_req_init(loop, req, UV_FS_READDIR, path, cb);\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_readdir(path, flags, EIO_PRI_DEFAULT, uv__fs_after, req);\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    DIR* dir = opendir(path);\n+    if (!dir) {\n+      uv_err_new(loop, errno);\n+      req->result = -1;\n+      return -1;\n+    }\n+\n+    /* req->result stores number of entries */\n+    req->result = 0;\n+\n+    while ((entry = readdir(dir))) {\n+      d_namlen = strlen(entry->d_name);\n+\n+      /* Skip . and .. */\n+      if ((d_namlen == 1 && entry->d_name[0] == '.') ||\n+          (d_namlen == 2 && entry->d_name[0] == '.' &&\n+           entry->d_name[1] == '.')) {\n+        continue;\n+      }\n+\n+      req->ptr = realloc(req->ptr, size + d_namlen + 1);\n+      /* TODO check ENOMEM */\n+      memcpy((char*)req->ptr + size, entry->d_name, d_namlen);\n+      size += d_namlen;\n+      ((char*)req->ptr)[size] = '\\0';\n+      size++;\n+      req->result++;\n+    }\n+\n+    r = closedir(dir);\n+    if (r) {\n+      uv_err_new(loop, errno);\n+      req->result = -1;\n+      return -1;\n+    }\n+\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  char* pathdup;\n+  int pathlen;\n+\n+  uv_fs_req_init(loop, req, UV_FS_STAT, path, cb);\n+\n+  /* TODO do this without duplicating the string. */\n+  /* TODO security */\n+  pathdup = strdup(path);\n+  pathlen = strlen(path);\n+\n+  if (pathlen > 0 && path[pathlen - 1] == '\\\\') {\n+    /* TODO do not modify input string */\n+    pathdup[pathlen - 1] = '\\0';\n+  }\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_stat(pathdup, EIO_PRI_DEFAULT, uv__fs_after, req);\n+\n+    free(pathdup);\n+\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = stat(pathdup, &req->statbuf);\n+\n+    free(pathdup);\n+\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    req->ptr = &req->statbuf;\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  uv_fs_req_init(loop, req, UV_FS_FSTAT, NULL, cb);\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_fstat(file, EIO_PRI_DEFAULT, uv__fs_after, req);\n+\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = fstat(file, &req->statbuf);\n+\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    req->ptr = &req->statbuf;\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path,\n+    uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_RENAME, eio_rename, rename, ARGS2(path, new_path))\n+}\n+\n+\n+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_FSYNC, eio_fsync, fsync, ARGS1(file))\n+}\n+\n+\n+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  char* path = NULL;\n+#ifdef __FreeBSD__\n+  /* freebsd doesn't have fdatasync, do a full fsync instead. */\n+  WRAP_EIO(UV_FS_FDATASYNC, eio_fdatasync, fsync, ARGS1(file))\n+#else\n+  WRAP_EIO(UV_FS_FDATASYNC, eio_fdatasync, fdatasync, ARGS1(file))\n+#endif\n+}\n+\n+\n+int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file, off_t offset,\n+    uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_FTRUNCATE, eio_ftruncate, ftruncate, ARGS2(file, offset))\n+}\n+\n+\n+int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd, uv_file in_fd,\n+    off_t in_offset, size_t length, uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_SENDFILE, eio_sendfile, eio_sendfile_sync,\n+      ARGS4(out_fd, in_fd, in_offset, length))\n+}\n+\n+\n+int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n+    uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_CHMOD, eio_chmod, chmod, ARGS2(path, mode))\n+}\n+\n+\n+static int _utime(const char* path, double atime, double mtime) {\n+  struct utimbuf buf;\n+  buf.actime = atime;\n+  buf.modtime = mtime;\n+  return utime(path, &buf);\n+}\n+\n+\n+int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n+    double mtime, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_UTIME, eio_utime, _utime, ARGS3(path, atime, mtime))\n+}\n+\n+\n+#if defined(HAVE_FUTIMES)\n+static int _futime(const uv_file file, double atime, double mtime) {\n+  struct timeval tv[2];\n+\n+  /* FIXME possible loss of precision in floating-point arithmetic? */\n+  tv[0].tv_sec = atime;\n+  tv[0].tv_usec = (unsigned long)(atime * 1000000) % 1000000;\n+\n+  tv[1].tv_sec = mtime;\n+  tv[1].tv_usec = (unsigned long)(mtime * 1000000) % 1000000;\n+\n+  return futimes(file, tv);\n+}\n+#endif\n+\n+\n+int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,\n+    double mtime, uv_fs_cb cb) {\n+#if defined(HAVE_FUTIMES)\n+  const char* path = NULL;\n+\n+  uv_fs_req_init(loop, req, UV_FS_FUTIME, path, cb);\n+\n+  WRAP_EIO(UV_FS_FUTIME, eio_futime, _futime, ARGS3(file, atime, mtime))\n+#else\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+#endif\n+}\n+\n+\n+int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  char* pathdup;\n+  int pathlen;\n+\n+  uv_fs_req_init(loop, req, UV_FS_LSTAT, path, cb);\n+\n+  /* TODO do this without duplicating the string. */\n+  /* TODO security */\n+  pathdup = strdup(path);\n+  pathlen = strlen(path);\n+\n+  if (pathlen > 0 && path[pathlen - 1] == '\\\\') {\n+    /* TODO do not modify input string */\n+    pathdup[pathlen - 1] = '\\0';\n+  }\n+\n+  if (cb) {\n+    /* async */\n+    uv_ref(loop);\n+    req->eio = eio_lstat(pathdup, EIO_PRI_DEFAULT, uv__fs_after, req);\n+\n+    free(pathdup);\n+\n+    if (!req->eio) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+  } else {\n+    /* sync */\n+    req->result = lstat(pathdup, &req->statbuf);\n+\n+    free(pathdup);\n+\n+    if (req->result < 0) {\n+      uv_err_new(loop, errno);\n+      return -1;\n+    }\n+\n+    req->ptr = &req->statbuf;\n+    return req->result;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    const char* new_path, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_LINK, eio_link, link, ARGS2(path, new_path))\n+}\n+\n+\n+int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    const char* new_path, int flags, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_SYMLINK, eio_symlink, symlink, ARGS2(path, new_path))\n+}\n+\n+\n+int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    uv_fs_cb cb) {\n+  ssize_t size;\n+  int status;\n+  char* buf;\n+\n+  status = -1;\n+\n+  uv_fs_req_init(loop, req, UV_FS_READLINK, path, cb);\n+\n+  if (cb) {\n+    if ((req->eio = eio_readlink(path, EIO_PRI_DEFAULT, uv__fs_after, req))) {\n+      uv_ref(loop);\n+      return 0;\n+    } else {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+  } else {\n+    /* pathconf(_PC_PATH_MAX) may return -1 to signify that path\n+     * lengths have no upper limit or aren't suitable for malloc'ing.\n+     */\n+    if ((size = pathconf(path, _PC_PATH_MAX)) == -1) {\n+#if defined(PATH_MAX)\n+      size = PATH_MAX;\n+#else\n+      size = 4096;\n+#endif\n+    }\n+\n+    if ((buf = malloc(size + 1)) == NULL) {\n+      uv_err_new(loop, ENOMEM);\n+      return -1;\n+    }\n+\n+    if ((size = readlink(path, buf, size)) == -1) {\n+      req->errorno = errno;\n+      req->result = -1;\n+      free(buf);\n+    } else {\n+      /* Cannot conceivably fail since it shrinks the buffer. */\n+      buf = realloc(buf, size + 1);\n+      buf[size] = '\\0';\n+      req->result = 0;\n+      req->ptr = buf;\n+    }\n+\n+    return req->result;\n+  }\n+\n+  assert(0 && \"unreachable\");\n+}\n+\n+\n+int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,\n+    uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_FCHMOD, eio_fchmod, fchmod, ARGS2(file, mode))\n+}\n+\n+\n+int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,\n+    int gid, uv_fs_cb cb) {\n+  WRAP_EIO(UV_FS_CHOWN, eio_chown, chown, ARGS3(path, uid, gid))\n+}\n+\n+\n+int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid, int gid,\n+    uv_fs_cb cb) {\n+  char* path = NULL;\n+  WRAP_EIO(UV_FS_FCHOWN, eio_fchown, fchown, ARGS3(file, uid, gid))\n+}\n+\n+\n+static void uv__work(eio_req* eio) {\n+  uv_work_t* req = eio->data;\n+  if (req->work_cb) {\n+    req->work_cb(req);\n+  }\n+}\n+\n+\n+static int uv__after_work(eio_req *eio) {\n+  uv_work_t* req = eio->data;\n+  uv_unref(req->loop);\n+  if (req->after_work_cb) {\n+    req->after_work_cb(req);\n+  }\n+  return 0;\n+}\n+\n+\n+int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb,\n+    uv_after_work_cb after_work_cb) {\n+  void* data = req->data;\n+\n+  uv_eio_init(loop);\n+\n+  uv__req_init((uv_req_t*) req);\n+  uv_ref(loop);\n+  req->loop = loop;\n+  req->data = data;\n+  req->work_cb = work_cb;\n+  req->after_work_cb = after_work_cb;\n+\n+  req->eio = eio_custom(uv__work, EIO_PRI_DEFAULT, uv__after_work, req);\n+\n+  if (!req->eio) {\n+    uv_err_new(loop, ENOMEM);\n+    return -1;\n+  }\n+\n+  return 0;\n+}"}, {"sha": "42283ca2a51d2141f1f40a586e0b1c83e040dc15", "filename": "src/rt/libuv/src/unix/internal.h", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,129 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef UV_UNIX_INTERNAL_H_\n+#define UV_UNIX_INTERNAL_H_\n+\n+#include \"uv-common.h\"\n+#include \"uv-eio.h\"\n+\n+#include <stddef.h> /* offsetof */\n+\n+#if defined(__linux__)\n+\n+#include <linux/version.h>\n+#include <features.h>\n+\n+#undef HAVE_FUTIMES\n+#undef HAVE_PIPE2\n+#undef HAVE_ACCEPT4\n+\n+/* futimes() requires linux >= 2.6.22 and glib >= 2.6 */\n+#if LINUX_VERSION_CODE >= 0x20616 && __GLIBC_PREREQ(2, 6)\n+#define HAVE_FUTIMES\n+#endif\n+\n+/* pipe2() requires linux >= 2.6.27 and glibc >= 2.9 */\n+#if LINUX_VERSION_CODE >= 0x2061B && __GLIBC_PREREQ(2, 9)\n+#define HAVE_PIPE2\n+#endif\n+\n+/* accept4() requires linux >= 2.6.28 and glib >= 2.10 */\n+#if LINUX_VERSION_CODE >= 0x2061C && __GLIBC_PREREQ(2, 10)\n+#define HAVE_ACCEPT4\n+#endif\n+\n+#endif /* __linux__ */\n+\n+#ifdef __APPLE__\n+# define HAVE_FUTIMES\n+#endif\n+\n+#ifdef __FreeBSD__\n+# define HAVE_FUTIMES\n+#endif\n+\n+#define container_of(ptr, type, member) \\\n+  ((type *) ((char *) (ptr) - offsetof(type, member)))\n+\n+#define SAVE_ERRNO(block) \\\n+  do { \\\n+    int _saved_errno = errno; \\\n+    do { block; } while (0); \\\n+    errno = _saved_errno; \\\n+  } \\\n+  while (0);\n+\n+/* flags */\n+enum {\n+  UV_CLOSING  = 0x00000001, /* uv_close() called but not finished. */\n+  UV_CLOSED   = 0x00000002, /* close(2) finished. */\n+  UV_READING  = 0x00000004, /* uv_read_start() called. */\n+  UV_SHUTTING = 0x00000008, /* uv_shutdown() called but not complete. */\n+  UV_SHUT     = 0x00000010, /* Write side closed. */\n+  UV_READABLE = 0x00000020, /* The stream is readable */\n+  UV_WRITABLE = 0x00000040  /* The stream is writable */\n+};\n+\n+size_t uv__strlcpy(char* dst, const char* src, size_t size);\n+\n+int uv__close(int fd);\n+void uv__req_init(uv_req_t*);\n+void uv__handle_init(uv_loop_t* loop, uv_handle_t* handle, uv_handle_type type);\n+\n+\n+int uv__nonblock(int fd, int set) __attribute__((unused));\n+int uv__cloexec(int fd, int set) __attribute__((unused));\n+int uv__socket(int domain, int type, int protocol);\n+\n+/* error */\n+uv_err_code uv_translate_sys_error(int sys_errno);\n+uv_err_t uv_err_new(uv_loop_t* loop, int sys_error);\n+uv_err_t uv_err_new_artificial(uv_loop_t* loop, int code);\n+void uv_fatal_error(const int errorno, const char* syscall);\n+\n+/* stream */\n+void uv__stream_init(uv_loop_t* loop, uv_stream_t* stream,\n+    uv_handle_type type);\n+int uv__stream_open(uv_stream_t*, int fd, int flags);\n+void uv__stream_destroy(uv_stream_t* stream);\n+void uv__stream_io(EV_P_ ev_io* watcher, int revents);\n+void uv__server_io(EV_P_ ev_io* watcher, int revents);\n+int uv__accept(int sockfd, struct sockaddr* saddr, socklen_t len);\n+int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n+    socklen_t addrlen, uv_connect_cb cb);\n+\n+/* tcp */\n+int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb);\n+\n+/* pipe */\n+int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);\n+void uv__pipe_accept(EV_P_ ev_io* watcher, int revents);\n+int uv_pipe_cleanup(uv_pipe_t* handle);\n+\n+/* udp */\n+void uv__udp_destroy(uv_udp_t* handle);\n+void uv__udp_watcher_stop(uv_udp_t* handle, ev_io* w);\n+\n+/* fs */\n+void uv__fs_event_destroy(uv_fs_event_t* handle);\n+\n+#endif /* UV_UNIX_INTERNAL_H_ */"}, {"sha": "0b4ce64ddf3046111d570add231492dd4d9dc47c", "filename": "src/rt/libuv/src/unix/linux.c", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,183 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <errno.h>\n+\n+#include <sys/inotify.h>\n+#include <unistd.h>\n+#include <time.h>\n+\n+#undef NANOSEC\n+#define NANOSEC 1000000000\n+\n+\n+/* Don't look aghast, this is exactly how glibc's basename() works. */\n+static char* basename_r(const char* path) {\n+  char* s = strrchr(path, '/');\n+  return s ? (s + 1) : (char*)path;\n+}\n+\n+\n+/*\n+ * There's probably some way to get time from Linux than gettimeofday(). What\n+ * it is, I don't know.\n+ */\n+uint64_t uv_hrtime() {\n+  struct timespec ts;\n+  clock_gettime(CLOCK_MONOTONIC, &ts);\n+  return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n+}\n+\n+\n+int uv_exepath(char* buffer, size_t* size) {\n+  if (!buffer || !size) {\n+    return -1;\n+  }\n+\n+  *size = readlink(\"/proc/self/exe\", buffer, *size - 1);\n+  if (*size <= 0) return -1;\n+  buffer[*size] = '\\0';\n+  return 0;\n+}\n+\n+\n+static int new_inotify_fd(void) {\n+#if defined(IN_NONBLOCK) && defined(IN_CLOEXEC)\n+  return inotify_init1(IN_NONBLOCK | IN_CLOEXEC);\n+#else\n+  int fd;\n+\n+  if ((fd = inotify_init()) == -1)\n+    return -1;\n+\n+  if (uv__cloexec(fd, 1) || uv__nonblock(fd, 1)) {\n+    SAVE_ERRNO(uv__close(fd));\n+    fd = -1;\n+  }\n+\n+  return fd;\n+#endif\n+}\n+\n+\n+static void uv__inotify_read(EV_P_ ev_io* w, int revents) {\n+  struct inotify_event* e;\n+  uv_fs_event_t* handle;\n+  const char* filename;\n+  ssize_t size;\n+  int events;\n+  char *p;\n+  /* needs to be large enough for sizeof(inotify_event) + strlen(filename) */\n+  char buf[4096];\n+\n+  handle = container_of(w, uv_fs_event_t, read_watcher);\n+\n+  do {\n+    do {\n+      size = read(handle->fd, buf, sizeof buf);\n+    }\n+    while (size == -1 && errno == EINTR);\n+\n+    if (size == -1) {\n+      assert(errno == EAGAIN || errno == EWOULDBLOCK);\n+      break;\n+    }\n+\n+    assert(size > 0); /* pre-2.6.21 thing, size=0 == read buffer too small */\n+\n+    /* Now we have one or more inotify_event structs. */\n+    for (p = buf; p < buf + size; p += sizeof(*e) + e->len) {\n+      e = (void*)p;\n+\n+      events = 0;\n+      if (e->mask & (IN_ATTRIB|IN_MODIFY))\n+        events |= UV_CHANGE;\n+      if (e->mask & ~(IN_ATTRIB|IN_MODIFY))\n+        events |= UV_RENAME;\n+\n+      /* inotify does not return the filename when monitoring a single file\n+       * for modifications. Repurpose the filename for API compatibility.\n+       * I'm not convinced this is a good thing, maybe it should go.\n+       */\n+      filename = e->len ? e->name : basename_r(handle->filename);\n+\n+      handle->cb(handle, filename, events, 0);\n+    }\n+  }\n+  while (handle->fd != -1); /* handle might've been closed by callback */\n+}\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  int flags;\n+  int fd;\n+\n+  /*\n+   * TODO share a single inotify fd across the event loop?\n+   * We'll run into fs.inotify.max_user_instances if we\n+   * keep creating new inotify fds.\n+   */\n+  if ((fd = new_inotify_fd()) == -1) {\n+    uv_err_new(loop, errno);\n+    return -1;\n+  }\n+\n+  flags = IN_ATTRIB\n+        | IN_CREATE\n+        | IN_MODIFY\n+        | IN_DELETE\n+        | IN_DELETE_SELF\n+        | IN_MOVED_FROM\n+        | IN_MOVED_TO;\n+\n+  if (inotify_add_watch(fd, filename, flags) == -1) {\n+    uv_err_new(loop, errno);\n+    uv__close(fd);\n+    return -1;\n+  }\n+\n+  uv__handle_init(loop, (uv_handle_t*)handle, UV_FS_EVENT);\n+  handle->filename = strdup(filename); /* this should go! */\n+  handle->cb = cb;\n+  handle->fd = fd;\n+\n+  ev_io_init(&handle->read_watcher, uv__inotify_read, fd, EV_READ);\n+  ev_io_start(loop->ev, &handle->read_watcher);\n+\n+  return 0;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  ev_io_stop(handle->loop->ev, &handle->read_watcher);\n+  uv__close(handle->fd);\n+  handle->fd = -1;\n+  free(handle->filename);\n+}"}, {"sha": "0ba799975457e3b62384dcc74ef09ac1ff86528b", "filename": "src/rt/libuv/src/unix/netbsd.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,85 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+\n+#include <unistd.h>\n+#include <time.h>\n+\n+#undef NANOSEC\n+#define NANOSEC 1000000000\n+\n+\n+uint64_t uv_hrtime(void) {\n+  struct timespec ts;\n+  clock_gettime(CLOCK_MONOTONIC, &ts);\n+  return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n+}\n+\n+\n+int uv_exepath(char* buffer, size_t* size) {\n+  uint32_t usize;\n+  int result;\n+  char* path;\n+  char* fullpath;\n+  int mib[4];\n+  size_t cb;\n+  pid_t mypid;\n+\n+  if (!buffer || !size) {\n+    return -1;\n+  }\n+\n+  mypid = getpid();\n+  mib[0] = CTL_KERN;\n+  mib[1] = KERN_PROC_ARGS;\n+  mib[2] = mypid;\n+  mib[3] = KERN_PROC_ARGV;\n+\n+  cb = *size;\n+  if (sysctl(mib, 4, buffer, &cb, NULL, 0) < 0) {\n+    *size = 0;\n+    return -1;\n+  }\n+  *size = strlen(buffer);\n+\n+  return 0;\n+}\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"implement me\");\n+}"}, {"sha": "50dc635b7e4c00a709c3feb1b21463428315b2ca", "filename": "src/rt/libuv/src/unix/pipe.c", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,272 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <sys/un.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+\n+int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle) {\n+  uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);\n+  loop->counters.pipe_init++;\n+  handle->pipe_fname = NULL;\n+  return 0;\n+}\n+\n+\n+int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n+  struct sockaddr_un saddr;\n+  const char* pipe_fname;\n+  int saved_errno;\n+  int sockfd;\n+  int status;\n+  int bound;\n+\n+  saved_errno = errno;\n+  pipe_fname = NULL;\n+  sockfd = -1;\n+  status = -1;\n+  bound = 0;\n+\n+  /* Already bound? */\n+  if (handle->fd >= 0) {\n+    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    goto out;\n+  }\n+\n+  /* Make a copy of the file name, it outlives this function's scope. */\n+  if ((pipe_fname = strdup(name)) == NULL) {\n+    uv_err_new(handle->loop, ENOMEM);\n+    goto out;\n+  }\n+\n+  /* We've got a copy, don't touch the original any more. */\n+  name = NULL;\n+\n+  if ((sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    goto out;\n+  }\n+\n+  memset(&saddr, 0, sizeof saddr);\n+  uv__strlcpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path));\n+  saddr.sun_family = AF_UNIX;\n+\n+  if (bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr) == -1) {\n+    /* On EADDRINUSE:\n+     *\n+     * We hold the file lock so there is no other process listening\n+     * on the socket. Ergo, it's stale - remove it.\n+     *\n+     * This assumes that the other process uses locking too\n+     * but that's a good enough assumption for now.\n+     */\n+    if (errno != EADDRINUSE\n+        || unlink(pipe_fname) == -1\n+        || bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr) == -1) {\n+      /* Convert ENOENT to EACCES for compatibility with Windows. */\n+      uv_err_new(handle->loop, (errno == ENOENT) ? EACCES : errno);\n+      goto out;\n+    }\n+  }\n+  bound = 1;\n+\n+  /* Success. */\n+  handle->pipe_fname = pipe_fname; /* Is a strdup'ed copy. */\n+  handle->fd = sockfd;\n+  status = 0;\n+\n+out:\n+  /* Clean up on error. */\n+  if (status) {\n+    if (bound) {\n+      /* unlink() before close() to avoid races. */\n+      assert(pipe_fname != NULL);\n+      unlink(pipe_fname);\n+    }\n+    uv__close(sockfd);\n+\n+    free((void*)pipe_fname);\n+  }\n+\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n+  int saved_errno;\n+  int status;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  if (handle->fd == -1) {\n+    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    goto out;\n+  }\n+  assert(handle->fd >= 0);\n+\n+  if ((status = listen(handle->fd, backlog)) == -1) {\n+    uv_err_new(handle->loop, errno);\n+  } else {\n+    handle->connection_cb = cb;\n+    ev_io_init(&handle->read_watcher, uv__pipe_accept, handle->fd, EV_READ);\n+    ev_io_start(handle->loop->ev, &handle->read_watcher);\n+  }\n+\n+out:\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+int uv_pipe_cleanup(uv_pipe_t* handle) {\n+  int saved_errno;\n+  int status;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  if (handle->pipe_fname) {\n+    /*\n+     * Unlink the file system entity before closing the file descriptor.\n+     * Doing it the other way around introduces a race where our process\n+     * unlinks a socket with the same name that's just been created by\n+     * another thread or process.\n+     *\n+     * This is less of an issue now that we attach a file lock\n+     * to the socket but it's still a best practice.\n+     */\n+    unlink(handle->pipe_fname);\n+    free((void*)handle->pipe_fname);\n+  }\n+\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+void uv_pipe_open(uv_pipe_t* handle, uv_file fd) {\n+  uv__stream_open((uv_stream_t*)handle, fd, UV_READABLE | UV_WRITABLE);\n+}\n+\n+\n+int uv_pipe_connect(uv_connect_t* req,\n+                    uv_pipe_t* handle,\n+                    const char* name,\n+                    uv_connect_cb cb) {\n+  struct sockaddr_un saddr;\n+  int saved_errno;\n+  int sockfd;\n+  int status;\n+  int r;\n+\n+  saved_errno = errno;\n+  sockfd = -1;\n+  status = -1;\n+\n+  if ((sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    goto out;\n+  }\n+\n+  memset(&saddr, 0, sizeof saddr);\n+  uv__strlcpy(saddr.sun_path, name, sizeof(saddr.sun_path));\n+  saddr.sun_family = AF_UNIX;\n+\n+  /* We don't check for EINPROGRESS. Think about it: the socket\n+   * is either there or not.\n+   */\n+  do {\n+    r = connect(sockfd, (struct sockaddr*)&saddr, sizeof saddr);\n+  }\n+  while (r == -1 && errno == EINTR);\n+\n+  if (r == -1) {\n+    uv_err_new(handle->loop, errno);\n+    uv__close(sockfd);\n+    goto out;\n+  }\n+\n+  uv__stream_open((uv_stream_t*)handle, sockfd, UV_READABLE | UV_WRITABLE);\n+\n+  ev_io_start(handle->loop->ev, &handle->read_watcher);\n+  ev_io_start(handle->loop->ev, &handle->write_watcher);\n+\n+  status = 0;\n+\n+out:\n+  handle->delayed_error = status; /* Passed to callback. */\n+  handle->connect_req = req;\n+  req->handle = (uv_stream_t*)handle;\n+  req->type = UV_CONNECT;\n+  req->cb = cb;\n+  ngx_queue_init(&req->queue);\n+\n+  /* Run callback on next tick. */\n+  ev_feed_event(handle->loop->ev, &handle->read_watcher, EV_CUSTOM);\n+  assert(ev_is_pending(&handle->read_watcher));\n+\n+  /* Mimic the Windows pipe implementation, always\n+   * return 0 and let the callback handle errors.\n+   */\n+  errno = saved_errno;\n+  return 0;\n+}\n+\n+\n+/* TODO merge with uv__server_io()? */\n+void uv__pipe_accept(EV_P_ ev_io* watcher, int revents) {\n+  struct sockaddr_un saddr;\n+  uv_pipe_t* pipe;\n+  int saved_errno;\n+  int sockfd;\n+\n+  saved_errno = errno;\n+  pipe = watcher->data;\n+\n+  assert(pipe->type == UV_NAMED_PIPE);\n+  assert(pipe->pipe_fname != NULL);\n+\n+  sockfd = uv__accept(pipe->fd, (struct sockaddr *)&saddr, sizeof saddr);\n+  if (sockfd == -1) {\n+    if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+      assert(0 && \"EAGAIN on uv__accept(pipefd)\");\n+    } else {\n+      uv_err_new(pipe->loop, errno);\n+    }\n+  } else {\n+    pipe->accepted_fd = sockfd;\n+    pipe->connection_cb((uv_stream_t*)pipe, 0);\n+    if (pipe->accepted_fd == sockfd) {\n+      /* The user hasn't yet accepted called uv_accept() */\n+      ev_io_stop(pipe->loop->ev, &pipe->read_watcher);\n+    }\n+  }\n+\n+  errno = saved_errno;\n+}"}, {"sha": "34f12d1737fb3fa11e211a6e82ae631c4f0bda6c", "filename": "src/rt/libuv/src/unix/process.c", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,300 @@\n+\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <sys/wait.h>\n+#include <fcntl.h> /* O_CLOEXEC, O_NONBLOCK */\n+#include <poll.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+\n+#ifdef __APPLE__\n+# include <crt_externs.h>\n+# define environ (*_NSGetEnviron())\n+#else\n+extern char **environ;\n+#endif\n+\n+\n+static void uv__chld(EV_P_ ev_child* watcher, int revents) {\n+  int status = watcher->rstatus;\n+  int exit_status = 0;\n+  int term_signal = 0;\n+  uv_process_t *process = watcher->data;\n+\n+  assert(&process->child_watcher == watcher);\n+  assert(revents & EV_CHILD);\n+\n+  ev_child_stop(EV_A_ &process->child_watcher);\n+\n+  if (WIFEXITED(status)) {\n+    exit_status = WEXITSTATUS(status);\n+  }\n+\n+  if (WIFSIGNALED(status)) {\n+    term_signal = WTERMSIG(status);\n+  }\n+\n+  if (process->exit_cb) {\n+    process->exit_cb(process, exit_status, term_signal);\n+  }\n+}\n+\n+#ifndef SPAWN_WAIT_EXEC\n+# define SPAWN_WAIT_EXEC 1\n+#endif\n+\n+int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n+    uv_process_options_t options) {\n+  /*\n+   * Save environ in the case that we get it clobbered\n+   * by the child process.\n+   */\n+  char** save_our_env = environ;\n+  int stdin_pipe[2] = { -1, -1 };\n+  int stdout_pipe[2] = { -1, -1 };\n+  int stderr_pipe[2] = { -1, -1 };\n+#if SPAWN_WAIT_EXEC\n+  int signal_pipe[2] = { -1, -1 };\n+  struct pollfd pfd;\n+#endif\n+  int status;\n+  pid_t pid;\n+\n+  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n+  loop->counters.process_init++;\n+\n+  process->exit_cb = options.exit_cb;\n+\n+  if (options.stdin_stream) {\n+    if (options.stdin_stream->type != UV_NAMED_PIPE) {\n+      errno = EINVAL;\n+      goto error;\n+    }\n+\n+    if (pipe(stdin_pipe) < 0) {\n+      goto error;\n+    }\n+    uv__cloexec(stdin_pipe[0], 1);\n+    uv__cloexec(stdin_pipe[1], 1);\n+  }\n+\n+  if (options.stdout_stream) {\n+    if (options.stdout_stream->type != UV_NAMED_PIPE) {\n+      errno = EINVAL;\n+      goto error;\n+    }\n+\n+    if (pipe(stdout_pipe) < 0) {\n+      goto error;\n+    }\n+    uv__cloexec(stdout_pipe[0], 1);\n+    uv__cloexec(stdout_pipe[1], 1);\n+  }\n+\n+  if (options.stderr_stream) {\n+    if (options.stderr_stream->type != UV_NAMED_PIPE) {\n+      errno = EINVAL;\n+      goto error;\n+    }\n+\n+    if (pipe(stderr_pipe) < 0) {\n+      goto error;\n+    }\n+    uv__cloexec(stderr_pipe[0], 1);\n+    uv__cloexec(stderr_pipe[1], 1);\n+  }\n+\n+  /* This pipe is used by the parent to wait until\n+   * the child has called `execve()`. We need this\n+   * to avoid the following race condition:\n+   *\n+   *    if ((pid = fork()) > 0) {\n+   *      kill(pid, SIGTERM);\n+   *    }\n+   *    else if (pid == 0) {\n+   *      execve(\"/bin/cat\", argp, envp);\n+   *    }\n+   *\n+   * The parent sends a signal immediately after forking.\n+   * Since the child may not have called `execve()` yet,\n+   * there is no telling what process receives the signal,\n+   * our fork or /bin/cat.\n+   *\n+   * To avoid ambiguity, we create a pipe with both ends\n+   * marked close-on-exec. Then, after the call to `fork()`,\n+   * the parent polls the read end until it sees POLLHUP.\n+   */\n+#if SPAWN_WAIT_EXEC\n+# ifdef HAVE_PIPE2\n+  if (pipe2(signal_pipe, O_CLOEXEC | O_NONBLOCK) < 0) {\n+    goto error;\n+  }\n+# else\n+  if (pipe(signal_pipe) < 0) {\n+    goto error;\n+  }\n+  uv__cloexec(signal_pipe[0], 1);\n+  uv__cloexec(signal_pipe[1], 1);\n+  uv__nonblock(signal_pipe[0], 1);\n+  uv__nonblock(signal_pipe[1], 1);\n+# endif\n+#endif\n+\n+  pid = fork();\n+\n+  if (pid == -1) {\n+#if SPAWN_WAIT_EXEC\n+    uv__close(signal_pipe[0]);\n+    uv__close(signal_pipe[1]);\n+#endif\n+    environ = save_our_env;\n+    goto error;\n+  }\n+\n+  if (pid == 0) {\n+    if (stdin_pipe[0] >= 0) {\n+      uv__close(stdin_pipe[1]);\n+      dup2(stdin_pipe[0],  STDIN_FILENO);\n+    } else {\n+      /* Reset flags that might be set by Node */\n+      uv__cloexec(STDIN_FILENO, 0);\n+      uv__nonblock(STDIN_FILENO, 0);\n+    }\n+\n+    if (stdout_pipe[1] >= 0) {\n+      uv__close(stdout_pipe[0]);\n+      dup2(stdout_pipe[1], STDOUT_FILENO);\n+    } else {\n+      /* Reset flags that might be set by Node */\n+      uv__cloexec(STDOUT_FILENO, 0);\n+      uv__nonblock(STDOUT_FILENO, 0);\n+    }\n+\n+    if (stderr_pipe[1] >= 0) {\n+      uv__close(stderr_pipe[0]);\n+      dup2(stderr_pipe[1], STDERR_FILENO);\n+    } else {\n+      /* Reset flags that might be set by Node */\n+      uv__cloexec(STDERR_FILENO, 0);\n+      uv__nonblock(STDERR_FILENO, 0);\n+    }\n+\n+    if (options.cwd && chdir(options.cwd)) {\n+      perror(\"chdir()\");\n+      _exit(127);\n+    }\n+\n+    environ = options.env;\n+\n+    execvp(options.file, options.args);\n+    perror(\"execvp()\");\n+    _exit(127);\n+    /* Execution never reaches here. */\n+  }\n+\n+  /* Parent. */\n+\n+  /* Restore environment. */\n+  environ = save_our_env;\n+\n+#if SPAWN_WAIT_EXEC\n+  /* POLLHUP signals child has exited or execve()'d. */\n+  uv__close(signal_pipe[1]);\n+  do {\n+    pfd.fd = signal_pipe[0];\n+    pfd.events = POLLIN|POLLHUP;\n+    pfd.revents = 0;\n+    errno = 0, status = poll(&pfd, 1, -1);\n+  }\n+  while (status == -1 && (errno == EINTR || errno == ENOMEM));\n+\n+  uv__close(signal_pipe[0]);\n+  uv__close(signal_pipe[1]);\n+\n+  assert((status == 1)\n+      && \"poll() on pipe read end failed\");\n+  assert((pfd.revents & POLLHUP) == POLLHUP\n+      && \"no POLLHUP on pipe read end\");\n+#endif\n+\n+  process->pid = pid;\n+\n+  ev_child_init(&process->child_watcher, uv__chld, pid, 0);\n+  ev_child_start(process->loop->ev, &process->child_watcher);\n+  process->child_watcher.data = process;\n+\n+  if (stdin_pipe[1] >= 0) {\n+    assert(options.stdin_stream);\n+    assert(stdin_pipe[0] >= 0);\n+    uv__close(stdin_pipe[0]);\n+    uv__nonblock(stdin_pipe[1], 1);\n+    uv__stream_open((uv_stream_t*)options.stdin_stream, stdin_pipe[1],\n+        UV_WRITABLE);\n+  }\n+\n+  if (stdout_pipe[0] >= 0) {\n+    assert(options.stdout_stream);\n+    assert(stdout_pipe[1] >= 0);\n+    uv__close(stdout_pipe[1]);\n+    uv__nonblock(stdout_pipe[0], 1);\n+    uv__stream_open((uv_stream_t*)options.stdout_stream, stdout_pipe[0],\n+        UV_READABLE);\n+  }\n+\n+  if (stderr_pipe[0] >= 0) {\n+    assert(options.stderr_stream);\n+    assert(stderr_pipe[1] >= 0);\n+    uv__close(stderr_pipe[1]);\n+    uv__nonblock(stderr_pipe[0], 1);\n+    uv__stream_open((uv_stream_t*)options.stderr_stream, stderr_pipe[0],\n+        UV_READABLE);\n+  }\n+\n+  return 0;\n+\n+error:\n+  uv_err_new(process->loop, errno);\n+  uv__close(stdin_pipe[0]);\n+  uv__close(stdin_pipe[1]);\n+  uv__close(stdout_pipe[0]);\n+  uv__close(stdout_pipe[1]);\n+  uv__close(stderr_pipe[0]);\n+  uv__close(stderr_pipe[1]);\n+  return -1;\n+}\n+\n+\n+int uv_process_kill(uv_process_t* process, int signum) {\n+  int r = kill(process->pid, signum);\n+\n+  if (r) {\n+    uv_err_new(process->loop, errno);\n+    return -1;\n+  } else {\n+    return 0;\n+  }\n+}"}, {"sha": "3983ca23b6d9cbd21f5d3a949eb1121c986f9596", "filename": "src/rt/libuv/src/unix/stream.c", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,783 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/uio.h>\n+\n+\n+static void uv__stream_connect(uv_stream_t*);\n+static void uv__write(uv_stream_t* stream);\n+static void uv__read(uv_stream_t* stream);\n+\n+\n+static size_t uv__buf_count(uv_buf_t bufs[], int bufcnt) {\n+  size_t total = 0;\n+  int i;\n+\n+  for (i = 0; i < bufcnt; i++) {\n+    total += bufs[i].len;\n+  }\n+\n+  return total;\n+}\n+\n+\n+void uv__stream_init(uv_loop_t* loop,\n+                     uv_stream_t* stream,\n+                     uv_handle_type type) {\n+  uv__handle_init(loop, (uv_handle_t*)stream, type);\n+\n+  stream->alloc_cb = NULL;\n+  stream->close_cb = NULL;\n+  stream->connection_cb = NULL;\n+  stream->connect_req = NULL;\n+  stream->accepted_fd = -1;\n+  stream->fd = -1;\n+  stream->delayed_error = 0;\n+  ngx_queue_init(&stream->write_queue);\n+  ngx_queue_init(&stream->write_completed_queue);\n+  stream->write_queue_size = 0;\n+\n+  ev_init(&stream->read_watcher, uv__stream_io);\n+  stream->read_watcher.data = stream;\n+\n+  ev_init(&stream->write_watcher, uv__stream_io);\n+  stream->write_watcher.data = stream;\n+\n+  assert(ngx_queue_empty(&stream->write_queue));\n+  assert(ngx_queue_empty(&stream->write_completed_queue));\n+  assert(stream->write_queue_size == 0);\n+}\n+\n+\n+int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n+  socklen_t yes;\n+\n+  assert(fd >= 0);\n+  stream->fd = fd;\n+\n+  ((uv_handle_t*)stream)->flags |= flags;\n+\n+  /* Reuse the port address if applicable. */\n+  yes = 1;\n+  if (stream->type == UV_TCP\n+      && setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {\n+    uv_err_new(stream->loop, errno);\n+    return -1;\n+  }\n+\n+  /* Associate the fd with each ev_io watcher. */\n+  ev_io_set(&stream->read_watcher, fd, EV_READ);\n+  ev_io_set(&stream->write_watcher, fd, EV_WRITE);\n+\n+  /* These should have been set up by uv_tcp_init or uv_pipe_init. */\n+  assert(stream->read_watcher.cb == uv__stream_io);\n+  assert(stream->write_watcher.cb == uv__stream_io);\n+\n+  return 0;\n+}\n+\n+\n+void uv__stream_destroy(uv_stream_t* stream) {\n+  uv_write_t* req;\n+  ngx_queue_t* q;\n+\n+  assert(stream->flags & UV_CLOSED);\n+\n+  while (!ngx_queue_empty(&stream->write_queue)) {\n+    q = ngx_queue_head(&stream->write_queue);\n+    ngx_queue_remove(q);\n+\n+    req = ngx_queue_data(q, uv_write_t, queue);\n+    if (req->bufs != req->bufsml)\n+      free(req->bufs);\n+\n+    if (req->cb) {\n+      uv_err_new_artificial(req->handle->loop, UV_EINTR);\n+      req->cb(req, -1);\n+    }\n+  }\n+\n+  while (!ngx_queue_empty(&stream->write_completed_queue)) {\n+    q = ngx_queue_head(&stream->write_completed_queue);\n+    ngx_queue_remove(q);\n+\n+    req = ngx_queue_data(q, uv_write_t, queue);\n+    if (req->cb) {\n+      uv_err_new_artificial(stream->loop, req->error);\n+      req->cb(req, req->error ? -1 : 0);\n+    }\n+  }\n+}\n+\n+\n+void uv__server_io(EV_P_ ev_io* watcher, int revents) {\n+  int fd;\n+  struct sockaddr_storage addr;\n+  uv_stream_t* stream = watcher->data;\n+\n+  assert(watcher == &stream->read_watcher ||\n+         watcher == &stream->write_watcher);\n+  assert(revents == EV_READ);\n+\n+  assert(!(stream->flags & UV_CLOSING));\n+\n+  if (stream->accepted_fd >= 0) {\n+    ev_io_stop(EV_A, &stream->read_watcher);\n+    return;\n+  }\n+\n+  /* connection_cb can close the server socket while we're\n+   * in the loop so check it on each iteration.\n+   */\n+  while (stream->fd != -1) {\n+    assert(stream->accepted_fd < 0);\n+    fd = uv__accept(stream->fd, (struct sockaddr*)&addr, sizeof addr);\n+\n+    if (fd < 0) {\n+      if (errno == EAGAIN) {\n+        /* No problem. */\n+        return;\n+      } else if (errno == EMFILE) {\n+        /* TODO special trick. unlock reserved socket, accept, close. */\n+        return;\n+      } else {\n+        uv_err_new(stream->loop, errno);\n+        stream->connection_cb((uv_stream_t*)stream, -1);\n+      }\n+    } else {\n+      stream->accepted_fd = fd;\n+      stream->connection_cb((uv_stream_t*)stream, 0);\n+      if (stream->accepted_fd >= 0) {\n+        /* The user hasn't yet accepted called uv_accept() */\n+        ev_io_stop(stream->loop->ev, &stream->read_watcher);\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+\n+int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n+  uv_stream_t* streamServer;\n+  uv_stream_t* streamClient;\n+  int saved_errno;\n+  int status;\n+\n+  /* TODO document this */\n+  assert(server->loop == client->loop);\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  streamServer = (uv_stream_t*)server;\n+  streamClient = (uv_stream_t*)client;\n+\n+  if (streamServer->accepted_fd < 0) {\n+    uv_err_new(server->loop, EAGAIN);\n+    goto out;\n+  }\n+\n+  if (uv__stream_open(streamClient, streamServer->accepted_fd,\n+        UV_READABLE | UV_WRITABLE)) {\n+    /* TODO handle error */\n+    streamServer->accepted_fd = -1;\n+    uv__close(streamServer->accepted_fd);\n+    goto out;\n+  }\n+\n+  ev_io_start(streamServer->loop->ev, &streamServer->read_watcher);\n+  streamServer->accepted_fd = -1;\n+  status = 0;\n+\n+out:\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {\n+  switch (stream->type) {\n+    case UV_TCP:\n+      return uv_tcp_listen((uv_tcp_t*)stream, backlog, cb);\n+    case UV_NAMED_PIPE:\n+      return uv_pipe_listen((uv_pipe_t*)stream, backlog, cb);\n+    default:\n+      assert(0);\n+      return -1;\n+  }\n+}\n+\n+\n+uv_write_t* uv_write_queue_head(uv_stream_t* stream) {\n+  ngx_queue_t* q;\n+  uv_write_t* req;\n+\n+  if (ngx_queue_empty(&stream->write_queue)) {\n+    return NULL;\n+  }\n+\n+  q = ngx_queue_head(&stream->write_queue);\n+  if (!q) {\n+    return NULL;\n+  }\n+\n+  req = ngx_queue_data(q, struct uv_write_s, queue);\n+  assert(req);\n+\n+  return req;\n+}\n+\n+\n+static void uv__drain(uv_stream_t* stream) {\n+  uv_shutdown_t* req;\n+\n+  assert(!uv_write_queue_head(stream));\n+  assert(stream->write_queue_size == 0);\n+\n+  ev_io_stop(stream->loop->ev, &stream->write_watcher);\n+\n+  /* Shutdown? */\n+  if ((stream->flags & UV_SHUTTING) &&\n+      !(stream->flags & UV_CLOSING) &&\n+      !(stream->flags & UV_SHUT)) {\n+    assert(stream->shutdown_req);\n+\n+    req = stream->shutdown_req;\n+\n+    if (shutdown(stream->fd, SHUT_WR)) {\n+      /* Error. Report it. User should call uv_close(). */\n+      uv_err_new(stream->loop, errno);\n+      if (req->cb) {\n+        req->cb(req, -1);\n+      }\n+    } else {\n+      uv_err_new(stream->loop, 0);\n+      ((uv_handle_t*) stream)->flags |= UV_SHUT;\n+      if (req->cb) {\n+        req->cb(req, 0);\n+      }\n+    }\n+  }\n+}\n+\n+\n+static size_t uv__write_req_size(uv_write_t* req) {\n+  size_t size;\n+\n+  size = uv__buf_count(req->bufs + req->write_index,\n+                       req->bufcnt - req->write_index);\n+  assert(req->handle->write_queue_size >= size);\n+\n+  return size;\n+}\n+\n+\n+static void uv__write_req_finish(uv_write_t* req) {\n+  uv_stream_t* stream = req->handle;\n+\n+  /* Pop the req off tcp->write_queue. */\n+  ngx_queue_remove(&req->queue);\n+  if (req->bufs != req->bufsml) {\n+    free(req->bufs);\n+  }\n+  req->bufs = NULL;\n+\n+  /* Add it to the write_completed_queue where it will have its\n+   * callback called in the near future.\n+   */\n+  ngx_queue_insert_tail(&stream->write_completed_queue, &req->queue);\n+  ev_feed_event(stream->loop->ev, &stream->write_watcher, EV_WRITE);\n+}\n+\n+\n+/* On success returns NULL. On error returns a pointer to the write request\n+ * which had the error.\n+ */\n+static void uv__write(uv_stream_t* stream) {\n+  uv_write_t* req;\n+  struct iovec* iov;\n+  int iovcnt;\n+  ssize_t n;\n+\n+  assert(stream->fd >= 0);\n+\n+  /* TODO: should probably while(1) here until EAGAIN */\n+\n+  /* Get the request at the head of the queue. */\n+  req = uv_write_queue_head(stream);\n+  if (!req) {\n+    assert(stream->write_queue_size == 0);\n+    return;\n+  }\n+\n+  assert(req->handle == stream);\n+\n+  /* Cast to iovec. We had to have our own uv_buf_t instead of iovec\n+   * because Windows's WSABUF is not an iovec.\n+   */\n+  assert(sizeof(uv_buf_t) == sizeof(struct iovec));\n+  iov = (struct iovec*) &(req->bufs[req->write_index]);\n+  iovcnt = req->bufcnt - req->write_index;\n+\n+  /* Now do the actual writev. Note that we've been updating the pointers\n+   * inside the iov each time we write. So there is no need to offset it.\n+   */\n+\n+  do {\n+    if (iovcnt == 1) {\n+      n = write(stream->fd, iov[0].iov_base, iov[0].iov_len);\n+    } else {\n+      n = writev(stream->fd, iov, iovcnt);\n+    }\n+  }\n+  while (n == -1 && errno == EINTR);\n+\n+  if (n < 0) {\n+    if (errno != EAGAIN) {\n+      /* Error */\n+      req->error = errno;\n+      stream->write_queue_size -= uv__write_req_size(req);\n+      uv__write_req_finish(req);\n+      return;\n+    }\n+  } else {\n+    /* Successful write */\n+\n+    /* Update the counters. */\n+    while (n >= 0) {\n+      uv_buf_t* buf = &(req->bufs[req->write_index]);\n+      size_t len = buf->len;\n+\n+      assert(req->write_index < req->bufcnt);\n+\n+      if ((size_t)n < len) {\n+        buf->base += n;\n+        buf->len -= n;\n+        stream->write_queue_size -= n;\n+        n = 0;\n+\n+        /* There is more to write. Break and ensure the watcher is pending. */\n+        break;\n+\n+      } else {\n+        /* Finished writing the buf at index req->write_index. */\n+        req->write_index++;\n+\n+        assert((size_t)n >= len);\n+        n -= len;\n+\n+        assert(stream->write_queue_size >= len);\n+        stream->write_queue_size -= len;\n+\n+        if (req->write_index == req->bufcnt) {\n+          /* Then we're done! */\n+          assert(n == 0);\n+          uv__write_req_finish(req);\n+          /* TODO: start trying to write the next request. */\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  /* Either we've counted n down to zero or we've got EAGAIN. */\n+  assert(n == 0 || n == -1);\n+\n+  /* We're not done. */\n+  ev_io_start(stream->loop->ev, &stream->write_watcher);\n+}\n+\n+\n+static void uv__write_callbacks(uv_stream_t* stream) {\n+  int callbacks_made = 0;\n+  ngx_queue_t* q;\n+  uv_write_t* req;\n+\n+  while (!ngx_queue_empty(&stream->write_completed_queue)) {\n+    /* Pop a req off write_completed_queue. */\n+    q = ngx_queue_head(&stream->write_completed_queue);\n+    assert(q);\n+    req = ngx_queue_data(q, struct uv_write_s, queue);\n+    ngx_queue_remove(q);\n+\n+    /* NOTE: call callback AFTER freeing the request data. */\n+    if (req->cb) {\n+      uv_err_new_artificial(stream->loop, req->error);\n+      req->cb(req, req->error ? -1 : 0);\n+    }\n+\n+    callbacks_made++;\n+  }\n+\n+  assert(ngx_queue_empty(&stream->write_completed_queue));\n+\n+  /* Write queue drained. */\n+  if (!uv_write_queue_head(stream)) {\n+    uv__drain(stream);\n+  }\n+}\n+\n+\n+static void uv__read(uv_stream_t* stream) {\n+  uv_buf_t buf;\n+  ssize_t nread;\n+  struct ev_loop* ev = stream->loop->ev;\n+\n+  /* XXX: Maybe instead of having UV_READING we just test if\n+   * tcp->read_cb is NULL or not?\n+   */\n+  while (stream->read_cb && ((uv_handle_t*)stream)->flags & UV_READING) {\n+    assert(stream->alloc_cb);\n+    buf = stream->alloc_cb((uv_handle_t*)stream, 64 * 1024);\n+\n+    assert(buf.len > 0);\n+    assert(buf.base);\n+    assert(stream->fd >= 0);\n+\n+    do {\n+      nread = read(stream->fd, buf.base, buf.len);\n+    }\n+    while (nread < 0 && errno == EINTR);\n+\n+    if (nread < 0) {\n+      /* Error */\n+      if (errno == EAGAIN) {\n+        /* Wait for the next one. */\n+        if (stream->flags & UV_READING) {\n+          ev_io_start(ev, &stream->read_watcher);\n+        }\n+        uv_err_new(stream->loop, EAGAIN);\n+        stream->read_cb(stream, 0, buf);\n+        return;\n+      } else {\n+        /* Error. User should call uv_close(). */\n+        uv_err_new(stream->loop, errno);\n+        stream->read_cb(stream, -1, buf);\n+        assert(!ev_is_active(&stream->read_watcher));\n+        return;\n+      }\n+    } else if (nread == 0) {\n+      /* EOF */\n+      uv_err_new_artificial(stream->loop, UV_EOF);\n+      ev_io_stop(ev, &stream->read_watcher);\n+      stream->read_cb(stream, -1, buf);\n+      return;\n+    } else {\n+      /* Successful read */\n+      stream->read_cb(stream, nread, buf);\n+    }\n+  }\n+}\n+\n+\n+int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n+  assert((stream->type == UV_TCP || stream->type == UV_NAMED_PIPE) &&\n+         \"uv_shutdown (unix) only supports uv_handle_t right now\");\n+  assert(stream->fd >= 0);\n+\n+  if (!(stream->flags & UV_WRITABLE) ||\n+      stream->flags & UV_SHUT ||\n+      stream->flags & UV_CLOSED ||\n+      stream->flags & UV_CLOSING) {\n+    uv_err_new(stream->loop, EINVAL);\n+    return -1;\n+  }\n+\n+  /* Initialize request */\n+  uv__req_init((uv_req_t*)req);\n+  req->handle = stream;\n+  req->cb = cb;\n+\n+  stream->shutdown_req = req;\n+  req->type = UV_SHUTDOWN;\n+\n+  ((uv_handle_t*)stream)->flags |= UV_SHUTTING;\n+\n+\n+  ev_io_start(stream->loop->ev, &stream->write_watcher);\n+\n+  return 0;\n+}\n+\n+\n+void uv__stream_io(EV_P_ ev_io* watcher, int revents) {\n+  uv_stream_t* stream = watcher->data;\n+\n+  assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n+      stream->type == UV_TTY);\n+  assert(watcher == &stream->read_watcher ||\n+         watcher == &stream->write_watcher);\n+  assert(!(stream->flags & UV_CLOSING));\n+\n+  if (stream->connect_req) {\n+    uv__stream_connect(stream);\n+  } else {\n+    assert(revents & (EV_READ | EV_WRITE));\n+    assert(stream->fd >= 0);\n+\n+    if (revents & EV_READ) {\n+      uv__read((uv_stream_t*)stream);\n+    }\n+\n+    if (revents & EV_WRITE) {\n+      uv__write(stream);\n+      uv__write_callbacks(stream);\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * We get called here from directly following a call to connect(2).\n+ * In order to determine if we've errored out or succeeded must call\n+ * getsockopt.\n+ */\n+static void uv__stream_connect(uv_stream_t* stream) {\n+  int error;\n+  uv_connect_t* req = stream->connect_req;\n+  socklen_t errorsize = sizeof(int);\n+\n+  assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE);\n+  assert(req);\n+\n+  if (stream->delayed_error) {\n+    /* To smooth over the differences between unixes errors that\n+     * were reported synchronously on the first connect can be delayed\n+     * until the next tick--which is now.\n+     */\n+    error = stream->delayed_error;\n+    stream->delayed_error = 0;\n+  } else {\n+    /* Normal situation: we need to get the socket error from the kernel. */\n+    assert(stream->fd >= 0);\n+    getsockopt(stream->fd, SOL_SOCKET, SO_ERROR, &error, &errorsize);\n+  }\n+\n+  if (!error) {\n+    ev_io_start(stream->loop->ev, &stream->read_watcher);\n+\n+    /* Successful connection */\n+    stream->connect_req = NULL;\n+    if (req->cb) {\n+      req->cb(req, 0);\n+    }\n+\n+  } else if (error == EINPROGRESS) {\n+    /* Still connecting. */\n+    return;\n+  } else {\n+    /* Error */\n+    uv_err_new(stream->loop, error);\n+\n+    stream->connect_req = NULL;\n+    if (req->cb) {\n+      req->cb(req, -1);\n+    }\n+  }\n+}\n+\n+\n+int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n+    socklen_t addrlen, uv_connect_cb cb) { \n+  int sockfd;\n+  int r;\n+\n+  if (stream->fd <= 0) {\n+    if ((sockfd = uv__socket(addr->sa_family, SOCK_STREAM, 0)) == -1) {\n+      uv_err_new(stream->loop, errno);\n+      return -1;\n+    }\n+\n+    if (uv__stream_open(stream, sockfd, UV_READABLE | UV_WRITABLE)) {\n+      uv__close(sockfd);\n+      return -2;\n+    }\n+  }\n+\n+  uv__req_init((uv_req_t*)req);\n+  req->cb = cb;\n+  req->handle = stream;\n+  req->type = UV_CONNECT;\n+  ngx_queue_init(&req->queue);\n+\n+  if (stream->connect_req) {\n+    uv_err_new(stream->loop, EALREADY);\n+    return -1;\n+  }\n+\n+  if (stream->type != UV_TCP) {\n+    uv_err_new(stream->loop, ENOTSOCK);\n+    return -1;\n+  }\n+\n+  stream->connect_req = req;\n+\n+  do {\n+    r = connect(stream->fd, addr, addrlen);\n+  }\n+  while (r == -1 && errno == EINTR);\n+\n+  stream->delayed_error = 0;\n+\n+  if (r != 0 && errno != EINPROGRESS) {\n+    switch (errno) {\n+      /* If we get a ECONNREFUSED wait until the next tick to report the\n+       * error. Solaris wants to report immediately--other unixes want to\n+       * wait.\n+       */\n+      case ECONNREFUSED:\n+        stream->delayed_error = errno;\n+        break;\n+\n+      default:\n+        uv_err_new(stream->loop, errno);\n+        return -1;\n+    }\n+  }\n+\n+  assert(stream->write_watcher.data == stream);\n+  ev_io_start(stream->loop->ev, &stream->write_watcher);\n+\n+  if (stream->delayed_error) {\n+    ev_feed_event(stream->loop->ev, &stream->write_watcher, EV_WRITE);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* The buffers to be written must remain valid until the callback is called.\n+ * This is not required for the uv_buf_t array.\n+ */\n+int uv_write(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n+    uv_write_cb cb) {\n+  int empty_queue;\n+\n+  assert((stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n+      stream->type == UV_TTY) &&\n+      \"uv_write (unix) does not yet support other types of streams\");\n+\n+  if (stream->fd < 0) {\n+    uv_err_new(stream->loop, EBADF);\n+    return -1;\n+  }\n+\n+  empty_queue = (stream->write_queue_size == 0);\n+\n+  /* Initialize the req */\n+  uv__req_init((uv_req_t*) req);\n+  req->cb = cb;\n+  req->handle = stream;\n+  req->error = 0;\n+  req->type = UV_WRITE;\n+  ngx_queue_init(&req->queue);\n+\n+  if (bufcnt <= UV_REQ_BUFSML_SIZE) {\n+    req->bufs = req->bufsml;\n+  }\n+  else {\n+    req->bufs = malloc(sizeof(uv_buf_t) * bufcnt);\n+  }\n+\n+  memcpy(req->bufs, bufs, bufcnt * sizeof(uv_buf_t));\n+  req->bufcnt = bufcnt;\n+\n+  /*\n+   * fprintf(stderr, \"cnt: %d bufs: %p bufsml: %p\\n\", bufcnt, req->bufs, req->bufsml);\n+   */\n+\n+  req->write_index = 0;\n+  stream->write_queue_size += uv__buf_count(bufs, bufcnt);\n+\n+  /* Append the request to write_queue. */\n+  ngx_queue_insert_tail(&stream->write_queue, &req->queue);\n+\n+  assert(!ngx_queue_empty(&stream->write_queue));\n+  assert(stream->write_watcher.cb == uv__stream_io);\n+  assert(stream->write_watcher.data == stream);\n+  assert(stream->write_watcher.fd == stream->fd);\n+\n+  /* If the queue was empty when this function began, we should attempt to\n+   * do the write immediately. Otherwise start the write_watcher and wait\n+   * for the fd to become writable.\n+   */\n+  if (empty_queue) {\n+    uv__write(stream);\n+  } else {\n+    ev_io_start(stream->loop->ev, &stream->write_watcher);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {\n+  assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n+      stream->type == UV_TTY);\n+\n+  if (stream->flags & UV_CLOSING) {\n+    uv_err_new(stream->loop, EINVAL);\n+    return -1;\n+  }\n+\n+  /* The UV_READING flag is irrelevant of the state of the tcp - it just\n+   * expresses the desired state of the user.\n+   */\n+  ((uv_handle_t*)stream)->flags |= UV_READING;\n+\n+  /* TODO: try to do the read inline? */\n+  /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n+   * not start the IO watcher.\n+   */\n+  assert(stream->fd >= 0);\n+  assert(alloc_cb);\n+\n+  stream->read_cb = read_cb;\n+  stream->alloc_cb = alloc_cb;\n+\n+  /* These should have been set by uv_tcp_init. */\n+  assert(stream->read_watcher.cb == uv__stream_io);\n+\n+  ev_io_start(stream->loop->ev, &stream->read_watcher);\n+  return 0;\n+}\n+\n+\n+int uv_read_stop(uv_stream_t* stream) {\n+  uv_tcp_t* tcp = (uv_tcp_t*)stream;\n+\n+  ((uv_handle_t*)tcp)->flags &= ~UV_READING;\n+\n+  ev_io_stop(tcp->loop->ev, &tcp->read_watcher);\n+  tcp->read_cb = NULL;\n+  tcp->alloc_cb = NULL;\n+  return 0;\n+}\n+\n+"}, {"sha": "0b5c03b5a696174a0ecf27c96104c8a85b6cfb96", "filename": "src/rt/libuv/src/unix/sunos.c", "status": "renamed", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -22,8 +22,11 @@\n \n #include <stdio.h>\n #include <stdint.h>\n-#include <unistd.h>\n+#include <assert.h>\n+#include <errno.h>\n+\n #include <sys/time.h>\n+#include <unistd.h>\n \n \n uint64_t uv_hrtime() {\n@@ -37,7 +40,7 @@ uint64_t uv_hrtime() {\n  * we don't want to potentially create a race condition in the use of snprintf.\n  */\n int uv_exepath(char* buffer, size_t* size) {\n-  size_t res;\n+  ssize_t res;\n   pid_t pid;\n   char buf[128];\n \n@@ -58,3 +61,17 @@ int uv_exepath(char* buffer, size_t* size) {\n   *size = res;\n   return (0);\n }\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv_err_new(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"implement me\");\n+}", "previous_filename": "src/rt/libuv/src/uv-sunos.c"}, {"sha": "9f14c1b6c0f7373a670f9e2144400bd4f9136124", "filename": "src/rt/libuv/src/unix/tcp.c", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,280 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <errno.h>\n+\n+\n+int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* tcp) {\n+  uv__stream_init(loop, (uv_stream_t*)tcp, UV_TCP);\n+  loop->counters.tcp_init++;\n+  return 0;\n+}\n+\n+\n+static int uv__tcp_bind(uv_tcp_t* tcp,\n+                        int domain,\n+                        struct sockaddr* addr,\n+                        int addrsize) {\n+  int saved_errno;\n+  int status;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  if (tcp->fd < 0) {\n+    if ((tcp->fd = uv__socket(domain, SOCK_STREAM, 0)) == -1) {\n+      uv_err_new(tcp->loop, errno);\n+      goto out;\n+    }\n+\n+    if (uv__stream_open((uv_stream_t*)tcp, tcp->fd, UV_READABLE | UV_WRITABLE)) {\n+      uv__close(tcp->fd);\n+      tcp->fd = -1;\n+      status = -2;\n+      goto out;\n+    }\n+  }\n+\n+  assert(tcp->fd >= 0);\n+\n+  tcp->delayed_error = 0;\n+  if (bind(tcp->fd, addr, addrsize) == -1) {\n+    if (errno == EADDRINUSE) {\n+      tcp->delayed_error = errno;\n+    } else {\n+      uv_err_new(tcp->loop, errno);\n+      goto out;\n+    }\n+  }\n+  status = 0;\n+\n+out:\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+int uv_tcp_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {\n+  if (addr.sin_family != AF_INET) {\n+    uv_err_new(tcp->loop, EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__tcp_bind(tcp,\n+                      AF_INET,\n+                      (struct sockaddr*)&addr,\n+                      sizeof(struct sockaddr_in));\n+}\n+\n+\n+int uv_tcp_bind6(uv_tcp_t* tcp, struct sockaddr_in6 addr) {\n+  if (addr.sin6_family != AF_INET6) {\n+    uv_err_new(tcp->loop, EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__tcp_bind(tcp,\n+                      AF_INET6,\n+                      (struct sockaddr*)&addr,\n+                      sizeof(struct sockaddr_in6));\n+}\n+\n+\n+int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n+    int* namelen) {\n+  socklen_t socklen;\n+  int saved_errno;\n+  int rv = 0;\n+\n+  /* Don't clobber errno. */\n+  saved_errno = errno;\n+\n+  if (handle->delayed_error) {\n+    uv_err_new(handle->loop, handle->delayed_error);\n+    rv = -1;\n+    goto out;\n+  }\n+\n+  if (handle->fd < 0) {\n+    uv_err_new(handle->loop, EINVAL);\n+    rv = -1;\n+    goto out;\n+  }\n+\n+  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n+  socklen = (socklen_t)*namelen;\n+\n+  if (getsockname(handle->fd, name, &socklen) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    rv = -1;\n+  } else {\n+    *namelen = (int)socklen;\n+  }\n+\n+out:\n+  errno = saved_errno;\n+  return rv;\n+}\n+\n+\n+int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n+    int* namelen) {\n+  socklen_t socklen;\n+  int saved_errno;\n+  int rv = 0;\n+\n+  /* Don't clobber errno. */\n+  saved_errno = errno;\n+\n+  if (handle->delayed_error) {\n+    uv_err_new(handle->loop, handle->delayed_error);\n+    rv = -1;\n+    goto out;\n+  }\n+\n+  if (handle->fd < 0) {\n+    uv_err_new(handle->loop, EINVAL);\n+    rv = -1;\n+    goto out;\n+  }\n+\n+  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n+  socklen = (socklen_t)*namelen;\n+\n+  if (getpeername(handle->fd, name, &socklen) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    rv = -1;\n+  } else {\n+    *namelen = (int)socklen;\n+  }\n+\n+out:\n+  errno = saved_errno;\n+  return rv;\n+}\n+\n+\n+int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n+  int r;\n+\n+  if (tcp->delayed_error) {\n+    uv_err_new(tcp->loop, tcp->delayed_error);\n+    return -1;\n+  }\n+\n+  if (tcp->fd < 0) {\n+    if ((tcp->fd = uv__socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n+      uv_err_new(tcp->loop, errno);\n+      return -1;\n+    }\n+\n+    if (uv__stream_open((uv_stream_t*)tcp, tcp->fd, UV_READABLE)) {\n+      uv__close(tcp->fd);\n+      tcp->fd = -1;\n+      return -1;\n+    }\n+  }\n+\n+  assert(tcp->fd >= 0);\n+\n+  r = listen(tcp->fd, backlog);\n+  if (r < 0) {\n+    uv_err_new(tcp->loop, errno);\n+    return -1;\n+  }\n+\n+  tcp->connection_cb = cb;\n+\n+  /* Start listening for connections. */\n+  ev_io_set(&tcp->read_watcher, tcp->fd, EV_READ);\n+  ev_set_cb(&tcp->read_watcher, uv__server_io);\n+  ev_io_start(tcp->loop->ev, &tcp->read_watcher);\n+\n+  return 0;\n+}\n+\n+\n+int uv_tcp_connect(uv_connect_t* req,\n+                   uv_tcp_t* handle,\n+                   struct sockaddr_in address,\n+                   uv_connect_cb cb) {\n+  int saved_errno;\n+  int status;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  if (handle->type != UV_TCP) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  if (address.sin_family != AF_INET) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  status = uv__connect(req,\n+                       (uv_stream_t*)handle,\n+                       (struct sockaddr*)&address,\n+                       sizeof address,\n+                       cb);\n+\n+out:\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+int uv_tcp_connect6(uv_connect_t* req,\n+                    uv_tcp_t* handle,\n+                    struct sockaddr_in6 address,\n+                    uv_connect_cb cb) {\n+  int saved_errno;\n+  int status;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  if (handle->type != UV_TCP) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  if (address.sin6_family != AF_INET6) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  status = uv__connect(req,\n+                       (uv_stream_t*)handle,\n+                       (struct sockaddr*)&address,\n+                       sizeof address,\n+                       cb);\n+\n+out:\n+  errno = saved_errno;\n+  return status;\n+}"}, {"sha": "989c09d1bf1470d0613b2c11e7ca96a67fd5c105", "filename": "src/rt/libuv/src/unix/tty.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,110 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <unistd.h>\n+#include <termios.h>\n+#include <errno.h>\n+#include <sys/ioctl.h>\n+\n+\n+int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd) {\n+  uv__nonblock(fd, 1);\n+  uv__stream_init(loop, (uv_stream_t*)tty, UV_TTY);\n+  uv__stream_open((uv_stream_t*)tty, fd, UV_READABLE | UV_WRITABLE);\n+  loop->counters.tty_init++;\n+  return 0;\n+}\n+\n+\n+int uv_tty_set_mode(uv_tty_t* tty, int mode) {\n+  int fd = tty->fd;\n+  struct termios orig_termios; /* in order to restore at exit */\n+  struct termios raw;\n+\n+  if (tcgetattr(fd, &orig_termios) == -1) goto fatal;\n+\n+  raw = orig_termios;  /* modify the original mode */\n+  /* input modes: no break, no CR to NL, no parity check, no strip char,\n+   * no start/stop output control. */\n+  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n+  /* output modes */\n+  raw.c_oflag |= (ONLCR);\n+  /* control modes - set 8 bit chars */\n+  raw.c_cflag |= (CS8);\n+  /* local modes - echoing off, canonical off, no extended functions,\n+   * no signal chars (^Z,^C) */\n+  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n+  /* control chars - set return condition: min number of bytes and timer.\n+   * We want read to return every single byte, without timeout. */\n+  raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n+\n+  /* put terminal in raw mode after flushing */\n+  if (tcsetattr(fd, TCSAFLUSH, &raw) < 0) goto fatal;\n+  return 0;\n+\n+fatal:\n+  uv_err_new(tty->loop, ENOTTY);\n+  return -1;\n+}\n+\n+\n+int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {\n+  struct winsize ws;\n+\n+  if (ioctl(tty->fd, TIOCGWINSZ, &ws) < 0) {\n+    uv_err_new(tty->loop, errno);\n+    return -1;\n+  }\n+\n+  *width = ws.ws_col;\n+  *height = ws.ws_row;\n+\n+  return 0;\n+}\n+\n+\n+uv_handle_type uv_guess_handle(uv_file file) {\n+  struct stat s;\n+\n+  if (file < 0) {\n+    uv_err_new(NULL, EINVAL); /* XXX Need loop? */\n+    return -1;\n+  }\n+\n+  if (isatty(file)) {\n+    return UV_TTY;\n+  }\n+\n+  if (fstat(file, &s)) {\n+    uv_err_new(NULL, errno); /* XXX Need loop? */\n+    return -1;\n+  }\n+\n+  if (!S_ISSOCK(s.st_mode) && !S_ISFIFO(s.st_mode)) {\n+    return UV_FILE;\n+  }\n+\n+  return UV_NAMED_PIPE;\n+}"}, {"sha": "20e5f3798b984e11e717aac6d41884ad9817a237", "filename": "src/rt/libuv/src/unix/udp.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -0,0 +1,555 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+\n+static void uv__udp_watcher_start(uv_udp_t* handle, ev_io* w);\n+static void uv__udp_run_completed(uv_udp_t* handle);\n+static void uv__udp_run_pending(uv_udp_t* handle);\n+static void uv__udp_recvmsg(uv_udp_t* handle);\n+static void uv__udp_sendmsg(uv_udp_t* handle);\n+static void uv__udp_io(EV_P_ ev_io* w, int events);\n+static int uv__udp_bind(uv_udp_t* handle, int domain, struct sockaddr* addr,\n+    socklen_t len, unsigned flags);\n+static int uv__udp_maybe_deferred_bind(uv_udp_t* handle, int domain);\n+static int uv__udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n+    int bufcnt, struct sockaddr* addr, socklen_t addrlen, uv_udp_send_cb send_cb);\n+\n+\n+static void uv__udp_watcher_start(uv_udp_t* handle, ev_io* w) {\n+  int flags;\n+\n+  assert(w == &handle->read_watcher\n+      || w == &handle->write_watcher);\n+\n+  flags = (w == &handle->read_watcher ? EV_READ : EV_WRITE);\n+\n+  w->data = handle;\n+  ev_set_cb(w, uv__udp_io);\n+  ev_io_set(w, handle->fd, flags);\n+  ev_io_start(handle->loop->ev, w);\n+}\n+\n+\n+void uv__udp_watcher_stop(uv_udp_t* handle, ev_io* w) {\n+  int flags;\n+\n+  assert(w == &handle->read_watcher\n+      || w == &handle->write_watcher);\n+\n+  flags = (w == &handle->read_watcher ? EV_READ : EV_WRITE);\n+\n+  ev_io_stop(handle->loop->ev, w);\n+  ev_io_set(w, -1, flags);\n+  ev_set_cb(w, NULL);\n+  w->data = (void*)0xDEADBABE;\n+}\n+\n+\n+void uv__udp_destroy(uv_udp_t* handle) {\n+  uv_udp_send_t* req;\n+  ngx_queue_t* q;\n+\n+  uv__udp_run_completed(handle);\n+\n+  while (!ngx_queue_empty(&handle->write_queue)) {\n+    q = ngx_queue_head(&handle->write_queue);\n+    ngx_queue_remove(q);\n+\n+    req = ngx_queue_data(q, uv_udp_send_t, queue);\n+    if (req->send_cb) {\n+      /* FIXME proper error code like UV_EABORTED */\n+      uv_err_new_artificial(handle->loop, UV_EINTR);\n+      req->send_cb(req, -1);\n+    }\n+  }\n+\n+  /* Now tear down the handle. */\n+  handle->flags = 0;\n+  handle->recv_cb = NULL;\n+  handle->alloc_cb = NULL;\n+  /* but _do not_ touch close_cb */\n+\n+  if (handle->fd != -1) {\n+    uv__close(handle->fd);\n+    handle->fd = -1;\n+  }\n+\n+  uv__udp_watcher_stop(handle, &handle->read_watcher);\n+  uv__udp_watcher_stop(handle, &handle->write_watcher);\n+}\n+\n+\n+static void uv__udp_run_pending(uv_udp_t* handle) {\n+  uv_udp_send_t* req;\n+  ngx_queue_t* q;\n+  struct msghdr h;\n+  ssize_t size;\n+\n+  while (!ngx_queue_empty(&handle->write_queue)) {\n+    q = ngx_queue_head(&handle->write_queue);\n+    assert(q != NULL);\n+\n+    req = ngx_queue_data(q, uv_udp_send_t, queue);\n+    assert(req != NULL);\n+\n+    memset(&h, 0, sizeof h);\n+    h.msg_name = &req->addr;\n+    h.msg_namelen = req->addrlen;\n+    h.msg_iov = (struct iovec*)req->bufs;\n+    h.msg_iovlen = req->bufcnt;\n+\n+    do {\n+      size = sendmsg(handle->fd, &h, 0);\n+    }\n+    while (size == -1 && errno == EINTR);\n+\n+    /* TODO try to write once or twice more in the\n+     * hope that the socket becomes readable again?\n+     */\n+    if (size == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))\n+      break;\n+\n+    req->status = (size == -1 ? -errno : size);\n+\n+#ifndef NDEBUG\n+    /* Sanity check. */\n+    if (size != -1) {\n+      ssize_t nbytes;\n+      int i;\n+\n+      for (nbytes = i = 0; i < req->bufcnt; i++)\n+        nbytes += req->bufs[i].len;\n+\n+      assert(size == nbytes);\n+    }\n+#endif\n+\n+    /* Sending a datagram is an atomic operation: either all data\n+     * is written or nothing is (and EMSGSIZE is raised). That is\n+     * why we don't handle partial writes. Just pop the request\n+     * off the write queue and onto the completed queue, done.\n+     */\n+    ngx_queue_remove(&req->queue);\n+    ngx_queue_insert_tail(&handle->write_completed_queue, &req->queue);\n+  }\n+}\n+\n+\n+static void uv__udp_run_completed(uv_udp_t* handle) {\n+  uv_udp_send_t* req;\n+  ngx_queue_t* q;\n+\n+  while (!ngx_queue_empty(&handle->write_completed_queue)) {\n+    q = ngx_queue_head(&handle->write_completed_queue);\n+    assert(q != NULL);\n+\n+    ngx_queue_remove(q);\n+\n+    req = ngx_queue_data(q, uv_udp_send_t, queue);\n+    assert(req != NULL);\n+\n+    if (req->bufs != req->bufsml)\n+      free(req->bufs);\n+\n+    if (req->send_cb == NULL)\n+      continue;\n+\n+    /* req->status >= 0 == bytes written\n+     * req->status <  0 == errno\n+     */\n+    if (req->status >= 0) {\n+      req->send_cb(req, 0);\n+    }\n+    else {\n+      uv_err_new(handle->loop, -req->status);\n+      req->send_cb(req, -1);\n+    }\n+  }\n+}\n+\n+\n+static void uv__udp_recvmsg(uv_udp_t* handle) {\n+  struct sockaddr_storage peer;\n+  struct msghdr h;\n+  ssize_t nread;\n+  uv_buf_t buf;\n+  int flags;\n+\n+  assert(handle->recv_cb != NULL);\n+  assert(handle->alloc_cb != NULL);\n+\n+  do {\n+    /* FIXME: hoist alloc_cb out the loop but for now follow uv__read() */\n+    buf = handle->alloc_cb((uv_handle_t*)handle, 64 * 1024);\n+    assert(buf.len > 0);\n+    assert(buf.base != NULL);\n+\n+    memset(&h, 0, sizeof h);\n+    h.msg_name = &peer;\n+    h.msg_namelen = sizeof peer;\n+    h.msg_iov = (struct iovec*)&buf;\n+    h.msg_iovlen = 1;\n+\n+    do {\n+      nread = recvmsg(handle->fd, &h, 0);\n+    }\n+    while (nread == -1 && errno == EINTR);\n+\n+    if (nread == -1) {\n+      if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+        uv_err_new(handle->loop, EAGAIN);\n+        handle->recv_cb(handle, 0, buf, NULL, 0);\n+      }\n+      else {\n+        uv_err_new(handle->loop, errno);\n+        handle->recv_cb(handle, -1, buf, NULL, 0);\n+      }\n+    }\n+    else {\n+      flags = 0;\n+\n+      if (h.msg_flags & MSG_TRUNC)\n+        flags |= UV_UDP_PARTIAL;\n+\n+      handle->recv_cb(handle,\n+                      nread,\n+                      buf,\n+                      (struct sockaddr*)&peer,\n+                      flags);\n+    }\n+  }\n+  /* recv_cb callback may decide to pause or close the handle */\n+  while (nread != -1\n+      && handle->fd != -1\n+      && handle->recv_cb != NULL);\n+}\n+\n+\n+static void uv__udp_sendmsg(uv_udp_t* handle) {\n+  assert(!ngx_queue_empty(&handle->write_queue)\n+      || !ngx_queue_empty(&handle->write_completed_queue));\n+\n+  /* Write out pending data first. */\n+  uv__udp_run_pending(handle);\n+\n+  /* Drain 'request completed' queue. */\n+  uv__udp_run_completed(handle);\n+\n+  if (!ngx_queue_empty(&handle->write_completed_queue)) {\n+    /* Schedule completion callbacks. */\n+    ev_feed_event(handle->loop->ev, &handle->write_watcher, EV_WRITE);\n+  }\n+  else if (ngx_queue_empty(&handle->write_queue)) {\n+    /* Pending queue and completion queue empty, stop watcher. */\n+    uv__udp_watcher_stop(handle, &handle->write_watcher);\n+  }\n+}\n+\n+\n+static void uv__udp_io(EV_P_ ev_io* w, int events) {\n+  uv_udp_t* handle;\n+\n+  handle = w->data;\n+  assert(handle != NULL);\n+  assert(handle->type == UV_UDP);\n+  assert(handle->fd >= 0);\n+  assert(!(events & ~(EV_READ|EV_WRITE)));\n+\n+  if (events & EV_READ)\n+    uv__udp_recvmsg(handle);\n+\n+  if (events & EV_WRITE)\n+    uv__udp_sendmsg(handle);\n+}\n+\n+\n+static int uv__udp_bind(uv_udp_t* handle,\n+                        int domain,\n+                        struct sockaddr* addr,\n+                        socklen_t len,\n+                        unsigned flags) {\n+  int saved_errno;\n+  int status;\n+  int yes;\n+  int fd;\n+\n+  saved_errno = errno;\n+  status = -1;\n+\n+  /* Check for bad flags. */\n+  if (flags & ~UV_UDP_IPV6ONLY) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  /* Cannot set IPv6-only mode on non-IPv6 socket. */\n+  if ((flags & UV_UDP_IPV6ONLY) && domain != AF_INET6) {\n+    uv_err_new(handle->loop, EINVAL);\n+    goto out;\n+  }\n+\n+  /* Check for already active socket. */\n+  if (handle->fd != -1) {\n+    uv_err_new_artificial(handle->loop, UV_EALREADY);\n+    goto out;\n+  }\n+\n+  if ((fd = uv__socket(domain, SOCK_DGRAM, 0)) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    goto out;\n+  }\n+\n+  if (flags & UV_UDP_IPV6ONLY) {\n+#ifdef IPV6_V6ONLY\n+    yes = 1;\n+    if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof yes) == -1) {\n+      uv_err_new(handle->loop, errno);\n+      goto out;\n+    }\n+#else\n+    uv_err_new((uv_handle_t*)handle, ENOTSUP);\n+    goto out;\n+#endif\n+  }\n+\n+  if (bind(fd, addr, len) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    goto out;\n+  }\n+\n+  handle->fd = fd;\n+  status = 0;\n+\n+out:\n+  if (status)\n+    uv__close(fd);\n+\n+  errno = saved_errno;\n+  return status;\n+}\n+\n+\n+static int uv__udp_maybe_deferred_bind(uv_udp_t* handle, int domain) {\n+  struct sockaddr_storage taddr;\n+  socklen_t addrlen;\n+\n+  assert(domain == AF_INET || domain == AF_INET6);\n+\n+  if (handle->fd != -1)\n+    return 0;\n+\n+  switch (domain) {\n+  case AF_INET:\n+  {\n+    struct sockaddr_in* addr = (void*)&taddr;\n+    memset(addr, 0, sizeof *addr);\n+    addr->sin_family = AF_INET;\n+    addr->sin_addr.s_addr = INADDR_ANY;\n+    addrlen = sizeof *addr;\n+    break;\n+  }\n+  case AF_INET6:\n+  {\n+    struct sockaddr_in6* addr = (void*)&taddr;\n+    memset(addr, 0, sizeof *addr);\n+    addr->sin6_family = AF_INET6;\n+    addr->sin6_addr = in6addr_any;\n+    addrlen = sizeof *addr;\n+    break;\n+  }\n+  default:\n+    assert(0 && \"unsupported address family\");\n+    abort();\n+  }\n+\n+  return uv__udp_bind(handle, domain, (struct sockaddr*)&taddr, addrlen, 0);\n+}\n+\n+\n+static int uv__udp_send(uv_udp_send_t* req,\n+                        uv_udp_t* handle,\n+                        uv_buf_t bufs[],\n+                        int bufcnt,\n+                        struct sockaddr* addr,\n+                        socklen_t addrlen,\n+                        uv_udp_send_cb send_cb) {\n+  if (uv__udp_maybe_deferred_bind(handle, addr->sa_family))\n+    return -1;\n+\n+  /* Don't use uv__req_init(), it zeroes the data field. */\n+  handle->loop->counters.req_init++;\n+\n+  memcpy(&req->addr, addr, addrlen);\n+  req->addrlen = addrlen;\n+  req->send_cb = send_cb;\n+  req->handle = handle;\n+  req->bufcnt = bufcnt;\n+  req->type = UV_UDP_SEND;\n+\n+  if (bufcnt <= UV_REQ_BUFSML_SIZE) {\n+    req->bufs = req->bufsml;\n+  }\n+  else if ((req->bufs = malloc(bufcnt * sizeof(bufs[0]))) == NULL) {\n+    uv_err_new(handle->loop, ENOMEM);\n+    return -1;\n+  }\n+  memcpy(req->bufs, bufs, bufcnt * sizeof(bufs[0]));\n+\n+  ngx_queue_insert_tail(&handle->write_queue, &req->queue);\n+  uv__udp_watcher_start(handle, &handle->write_watcher);\n+\n+  return 0;\n+}\n+\n+\n+int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n+  memset(handle, 0, sizeof *handle);\n+\n+  uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP);\n+  loop->counters.udp_init++;\n+\n+  handle->fd = -1;\n+  ngx_queue_init(&handle->write_queue);\n+  ngx_queue_init(&handle->write_completed_queue);\n+\n+  return 0;\n+}\n+\n+\n+int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags) {\n+  return uv__udp_bind(handle,\n+                      AF_INET,\n+                      (struct sockaddr*)&addr,\n+                      sizeof addr,\n+                      flags);\n+}\n+\n+\n+int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags) {\n+  return uv__udp_bind(handle,\n+                      AF_INET6,\n+                      (struct sockaddr*)&addr,\n+                      sizeof addr,\n+                      flags);\n+}\n+\n+\n+int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n+    int* namelen) {\n+  socklen_t socklen;\n+  int saved_errno;\n+  int rv = 0;\n+\n+  /* Don't clobber errno. */\n+  saved_errno = errno;\n+\n+  if (handle->fd < 0) {\n+    uv_err_new(handle->loop, EINVAL);\n+    rv = -1;\n+    goto out;\n+  }\n+\n+  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n+  socklen = (socklen_t)*namelen;\n+\n+  if (getsockname(handle->fd, name, &socklen) == -1) {\n+    uv_err_new(handle->loop, errno);\n+    rv = -1;\n+  } else {\n+    *namelen = (int)socklen;\n+  }\n+\n+out:\n+  errno = saved_errno;\n+  return rv;\n+}\n+\n+\n+int uv_udp_send(uv_udp_send_t* req,\n+                uv_udp_t* handle,\n+                uv_buf_t bufs[],\n+                int bufcnt,\n+                struct sockaddr_in addr,\n+                uv_udp_send_cb send_cb) {\n+  return uv__udp_send(req,\n+                      handle,\n+                      bufs,\n+                      bufcnt,\n+                      (struct sockaddr*)&addr,\n+                      sizeof addr,\n+                      send_cb);\n+}\n+\n+\n+int uv_udp_send6(uv_udp_send_t* req,\n+                 uv_udp_t* handle,\n+                 uv_buf_t bufs[],\n+                 int bufcnt,\n+                 struct sockaddr_in6 addr,\n+                 uv_udp_send_cb send_cb) {\n+  return uv__udp_send(req,\n+                      handle,\n+                      bufs,\n+                      bufcnt,\n+                      (struct sockaddr*)&addr,\n+                      sizeof addr,\n+                      send_cb);\n+}\n+\n+\n+int uv_udp_recv_start(uv_udp_t* handle,\n+                      uv_alloc_cb alloc_cb,\n+                      uv_udp_recv_cb recv_cb) {\n+  if (alloc_cb == NULL || recv_cb == NULL) {\n+    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  if (ev_is_active(&handle->read_watcher)) {\n+    uv_err_new_artificial(handle->loop, UV_EALREADY);\n+    return -1;\n+  }\n+\n+  if (uv__udp_maybe_deferred_bind(handle, AF_INET))\n+    return -1;\n+\n+  handle->alloc_cb = alloc_cb;\n+  handle->recv_cb = recv_cb;\n+  uv__udp_watcher_start(handle, &handle->read_watcher);\n+\n+  return 0;\n+}\n+\n+\n+int uv_udp_recv_stop(uv_udp_t* handle) {\n+  uv__udp_watcher_stop(handle, &handle->read_watcher);\n+  handle->alloc_cb = NULL;\n+  handle->recv_cb = NULL;\n+  return 0;\n+}"}, {"sha": "84afe09b74776491305ed98ff531c6c9730c105c", "filename": "src/rt/libuv/src/unix/uv-eio.c", "status": "renamed", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -22,51 +22,55 @@\n \n #include \"uv.h\"\n #include \"eio.h\"\n+\n #include <assert.h>\n+#include <stdio.h>\n \n \n-static uv_async_t uv_eio_want_poll_notifier;\n-static uv_async_t uv_eio_done_poll_notifier;\n-static uv_idle_t uv_eio_poller;\n-static int uv_eio_init_count;\n+/* TODO remove me! */\n+static uv_loop_t* main_loop;\n \n \n static void uv_eio_do_poll(uv_idle_t* watcher, int status) {\n-  assert(watcher == &uv_eio_poller);\n+  assert(watcher == &(watcher->loop->uv_eio_poller));\n \n   /* printf(\"uv_eio_poller\\n\"); */\n \n-  if (eio_poll() != -1 && uv_is_active((uv_handle_t*) &uv_eio_poller)) {\n+  if (eio_poll() != -1 && uv_is_active((uv_handle_t*) watcher)) {\n     /* printf(\"uv_eio_poller stop\\n\"); */\n-    uv_idle_stop(&uv_eio_poller);\n-    uv_unref();\n+    uv_idle_stop(watcher);\n+    uv_unref(watcher->loop);\n   }\n }\n \n \n /* Called from the main thread. */\n static void uv_eio_want_poll_notifier_cb(uv_async_t* watcher, int status) {\n-  assert(watcher == &uv_eio_want_poll_notifier);\n+  uv_loop_t* loop = watcher->loop;\n+\n+  assert(watcher == &loop->uv_eio_want_poll_notifier);\n \n   /* printf(\"want poll notifier\\n\"); */\n \n-  if (eio_poll() == -1 && !uv_is_active((uv_handle_t*) &uv_eio_poller)) {\n+  if (eio_poll() == -1 && !uv_is_active((uv_handle_t*) &loop->uv_eio_poller)) {\n     /* printf(\"uv_eio_poller start\\n\"); */\n-    uv_idle_start(&uv_eio_poller, uv_eio_do_poll);\n-    uv_ref();\n+    uv_idle_start(&loop->uv_eio_poller, uv_eio_do_poll);\n+    uv_ref(loop);\n   }\n }\n \n \n static void uv_eio_done_poll_notifier_cb(uv_async_t* watcher, int revents) {\n-  assert(watcher == &uv_eio_done_poll_notifier);\n+  uv_loop_t* loop = watcher->loop;\n+\n+  assert(watcher == &loop->uv_eio_done_poll_notifier);\n \n   /* printf(\"done poll notifier\\n\"); */\n \n-  if (eio_poll() != -1 && uv_is_active((uv_handle_t*) &uv_eio_poller)) {\n+  if (eio_poll() != -1 && uv_is_active((uv_handle_t*) &loop->uv_eio_poller)) {\n     /* printf(\"uv_eio_poller stop\\n\"); */\n-    uv_idle_stop(&uv_eio_poller);\n-    uv_unref();\n+    uv_idle_stop(&loop->uv_eio_poller);\n+    uv_unref(loop);\n   }\n }\n \n@@ -77,7 +81,13 @@ static void uv_eio_done_poll_notifier_cb(uv_async_t* watcher, int revents) {\n  */\n static void uv_eio_want_poll(void) {\n   /* Signal the main thread that eio_poll need to be processed. */\n-  uv_async_send(&uv_eio_want_poll_notifier);\n+\n+  /*\n+   * TODO need to select the correct uv_loop_t and async_send to\n+   * uv_eio_want_poll_notifier.\n+   */\n+\n+  uv_async_send(&main_loop->uv_eio_want_poll_notifier);\n }\n \n \n@@ -86,28 +96,39 @@ static void uv_eio_done_poll(void) {\n    * Signal the main thread that we should stop calling eio_poll().\n    * from the idle watcher.\n    */\n-  uv_async_send(&uv_eio_done_poll_notifier);\n+  uv_async_send(&main_loop->uv_eio_done_poll_notifier);\n }\n \n \n-void uv_eio_init() {\n-  if (uv_eio_init_count == 0) {\n-    uv_eio_init_count++;\n+void uv_eio_init(uv_loop_t* loop) {\n+  if (loop->counters.eio_init == 0) {\n+    loop->counters.eio_init++;\n+\n+    main_loop = loop;\n \n-    uv_idle_init(&uv_eio_poller);\n-    uv_idle_start(&uv_eio_poller, uv_eio_do_poll);\n+    uv_idle_init(loop, &loop->uv_eio_poller);\n+    uv_idle_start(&loop->uv_eio_poller, uv_eio_do_poll);\n \n-    uv_async_init(&uv_eio_want_poll_notifier, uv_eio_want_poll_notifier_cb);\n-    uv_unref();\n+    loop->uv_eio_want_poll_notifier.data = loop;\n+    uv_async_init(loop, &loop->uv_eio_want_poll_notifier,\n+        uv_eio_want_poll_notifier_cb);\n+    uv_unref(loop);\n \n-    uv_async_init(&uv_eio_done_poll_notifier, uv_eio_done_poll_notifier_cb);\n-    uv_unref();\n+    uv_async_init(loop, &loop->uv_eio_done_poll_notifier,\n+        uv_eio_done_poll_notifier_cb);\n+    uv_unref(loop);\n \n     eio_init(uv_eio_want_poll, uv_eio_done_poll);\n     /*\n      * Don't handle more than 10 reqs on each eio_poll(). This is to avoid\n      * race conditions. See Node's test/simple/test-eio-race.js\n      */\n     eio_set_max_poll_reqs(10);\n+  } else {\n+    /*\n+     * If this assertion breaks then Ryan hasn't implemented support for\n+     * receiving thread pool requests back to multiple threads.\n+     */\n+    assert(main_loop == loop);\n   }\n }", "previous_filename": "src/rt/libuv/src/uv-eio.c"}, {"sha": "711d0cf281c166b157d703fbbcbcd109e0a0b82e", "filename": "src/rt/libuv/src/unix/uv-eio.h", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -9,5 +9,5 @@\n  * safe to call more than once.\n  * TODO: uv_eio_deinit\n  */\n-void uv_eio_init(void);\n+void uv_eio_init(uv_loop_t*);\n #endif", "previous_filename": "src/rt/libuv/src/uv-eio.h"}, {"sha": "51188337bd9562abae3b29643cba436c71a27546", "filename": "src/rt/libuv/src/uv-common.c", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -29,9 +29,7 @@\n /* use inet_pton from c-ares if necessary */\n #include \"ares_config.h\"\n #include \"ares/inet_net_pton.h\"\n-\n-/* list used for ares task handles */\n-static uv_ares_task_t* uv_ares_handles_ = NULL;\n+#include \"ares/inet_ntop.h\"\n \n \n static uv_counters_t counters;\n@@ -42,6 +40,14 @@ uv_counters_t* uv_counters() {\n }\n \n \n+uv_buf_t uv_buf_init(char* base, size_t len) {\n+  uv_buf_t buf;\n+  buf.base = base;\n+  buf.len = len;\n+  return buf;\n+}\n+\n+\n const char* uv_err_name(uv_err_t err) {\n   switch (err.code) {\n     case UV_UNKNOWN: return \"UNKNOWN\";\n@@ -75,10 +81,13 @@ const char* uv_err_name(uv_err_t err) {\n     case UV_ENOTCONN: return \"ENOTCONN\";\n     case UV_ENOTSOCK: return \"ENOTSOCK\";\n     case UV_ENOTSUP: return \"ENOTSUP\";\n+    case UV_ENOENT: return \"ENOENT\";\n+    case UV_EPIPE: return \"EPIPE\";\n     case UV_EPROTO: return \"EPROTO\";\n     case UV_EPROTONOSUPPORT: return \"EPROTONOSUPPORT\";\n     case UV_EPROTOTYPE: return \"EPROTOTYPE\";\n     case UV_ETIMEDOUT: return \"ETIMEDOUT\";\n+    case UV_EEXIST: return \"EEXIST\";\n     default:\n       assert(0);\n       return NULL;\n@@ -112,21 +121,36 @@ struct sockaddr_in6 uv_ip6_addr(const char* ip, int port) {\n }\n \n \n+int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size) {\n+  const char* d = ares_inet_ntop(AF_INET, &src->sin_addr, dst, size);\n+  return d != dst;\n+}\n+\n+\n+int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size) {\n+  const char* d = ares_inet_ntop(AF_INET6, &src->sin6_addr, dst, size);\n+  return d != dst;\n+}\n+\n+\n /* find matching ares handle in list */\n-void uv_add_ares_handle(uv_ares_task_t* handle) {\n-  handle->ares_next = uv_ares_handles_;\n+void uv_add_ares_handle(uv_loop_t* loop, uv_ares_task_t* handle) {\n+  handle->loop = loop;\n+  handle->ares_next = loop->uv_ares_handles_;\n   handle->ares_prev = NULL;\n \n-  if (uv_ares_handles_) {\n-    uv_ares_handles_->ares_prev = handle;\n+  if (loop->uv_ares_handles_) {\n+    loop->uv_ares_handles_->ares_prev = handle;\n   }\n-  uv_ares_handles_ = handle;\n+\n+  loop->uv_ares_handles_ = handle;\n }\n \n /* find matching ares handle in list */\n /* TODO: faster lookup */\n-uv_ares_task_t* uv_find_ares_handle(ares_socket_t sock) {\n-  uv_ares_task_t* handle = uv_ares_handles_;\n+uv_ares_task_t* uv_find_ares_handle(uv_loop_t* loop, ares_socket_t sock) {\n+  uv_ares_task_t* handle = loop->uv_ares_handles_;\n+\n   while (handle != NULL) {\n     if (handle->sock == sock) {\n       break;\n@@ -139,8 +163,10 @@ uv_ares_task_t* uv_find_ares_handle(ares_socket_t sock) {\n \n /* remove ares handle in list */\n void uv_remove_ares_handle(uv_ares_task_t* handle) {\n-  if (handle == uv_ares_handles_) {\n-    uv_ares_handles_ = handle->ares_next;\n+  uv_loop_t* loop = handle->loop;\n+\n+  if (handle == loop->uv_ares_handles_) {\n+    loop->uv_ares_handles_ = handle->ares_next;\n   }\n \n   if (handle->ares_next) {\n@@ -154,6 +180,6 @@ void uv_remove_ares_handle(uv_ares_task_t* handle) {\n \n \n /* Returns 1 if the uv_ares_handles_ list is empty. 0 otherwise. */\n-int uv_ares_handles_empty() {\n-  return uv_ares_handles_ ? 0 : 1;\n+int uv_ares_handles_empty(uv_loop_t* loop) {\n+  return loop->uv_ares_handles_ ? 0 : 1;\n }"}, {"sha": "ae543195569ead7b0bea688c1bd73bc97118fcef", "filename": "src/rt/libuv/src/uv-common.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "patch": "@@ -29,10 +29,8 @@\n \n #include \"uv.h\"\n \n-/*\n- * Subclass of uv_handle_t. Used for integration of c-ares.\n- */\n-typedef struct uv_ares_task_s uv_ares_task_t;\n+#define COUNTOF(a) (sizeof(a) / sizeof(a[0]))\n+\n \n struct uv_ares_task_s {\n   UV_HANDLE_FIELDS\n@@ -43,9 +41,12 @@ struct uv_ares_task_s {\n \n \n void uv_remove_ares_handle(uv_ares_task_t* handle);\n-uv_ares_task_t* uv_find_ares_handle(ares_socket_t sock);\n-void uv_add_ares_handle(uv_ares_task_t* handle);\n-int uv_ares_handles_empty();\n+uv_ares_task_t* uv_find_ares_handle(uv_loop_t*, ares_socket_t sock);\n+\n+/* TODO Rename to uv_ares_task_init? */\n+void uv_add_ares_handle(uv_loop_t* loop, uv_ares_task_t* handle);\n+\n+int uv_ares_handles_empty(uv_loop_t* loop);\n \n \n #endif /* UV_COMMON_H_ */"}, {"sha": "e29c842bfae05a94bd3cc462b2914df3dfa31750", "filename": "src/rt/libuv/src/uv-unix.c", "status": "removed", "additions": 0, "deletions": 1596, "changes": 1596, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-unix.c?ref=d8f6e9f23736f6a12dfa028d22557d1360648234", "patch": "@@ -1,1596 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#include \"uv.h\"\n-#include \"uv-common.h\"\n-#include \"uv-eio.h\"\n-\n-#include <stddef.h> /* NULL */\n-#include <stdio.h> /* printf */\n-#include <stdlib.h>\n-#include <string.h> /* strerror */\n-#include <errno.h>\n-#include <assert.h>\n-#include <unistd.h>\n-#include <fcntl.h>\n-#include <sys/socket.h>\n-#include <netinet/in.h>\n-#include <arpa/inet.h>\n-#include <limits.h> /* PATH_MAX */\n-\n-#if defined(__APPLE__)\n-#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n-#endif\n-\n-#if defined(__FreeBSD__)\n-#include <sys/sysctl.h>\n-#endif\n-\n-\n-static uv_err_t last_err;\n-\n-struct uv_ares_data_s {\n-  ares_channel channel;\n-  /*\n-   * While the channel is active this timer is called once per second to be sure\n-   * that we're always calling ares_process. See the warning above the\n-   * definition of ares_timeout().\n-   */\n-  ev_timer timer;\n-};\n-\n-static struct uv_ares_data_s ares_data;\n-\n-\n-void uv__tcp_io(EV_P_ ev_io* watcher, int revents);\n-void uv__next(EV_P_ ev_idle* watcher, int revents);\n-static void uv__tcp_connect(uv_tcp_t*);\n-int uv_tcp_open(uv_tcp_t*, int fd);\n-static void uv__finish_close(uv_handle_t* handle);\n-\n-/* flags */\n-enum {\n-  UV_CLOSING  = 0x00000001, /* uv_close() called but not finished. */\n-  UV_CLOSED   = 0x00000002, /* close(2) finished. */\n-  UV_READING  = 0x00000004, /* uv_read_start() called. */\n-  UV_SHUTTING = 0x00000008, /* uv_shutdown() called but not complete. */\n-  UV_SHUT     = 0x00000010  /* Write side closed. */\n-};\n-\n-\n-void uv_flag_set(uv_handle_t* handle, int flag) {\n-  handle->flags |= flag;\n-}\n-\n-\n-/* TODO Share this code with Windows. */\n-/* TODO Expose callback to user to handle fatal error like V8 does. */\n-static void uv_fatal_error(const int errorno, const char* syscall) {\n-  char* buf = NULL;\n-  const char* errmsg;\n-\n-  if (buf) {\n-    errmsg = buf;\n-  } else {\n-    errmsg = \"Unknown error\";\n-  }\n-\n-  if (syscall) {\n-    fprintf(stderr, \"\\nlibuv fatal error. %s: (%d) %s\\n\", syscall, errorno,\n-        errmsg);\n-  } else {\n-    fprintf(stderr, \"\\nlibuv fatal error. (%d) %s\\n\", errorno, errmsg);\n-  }\n-\n-  abort();\n-}\n-\n-\n-uv_err_t uv_last_error() {\n-  return last_err;\n-}\n-\n-\n-char* uv_strerror(uv_err_t err) {\n-  return strerror(err.sys_errno_);\n-}\n-\n-\n-void uv_flag_unset(uv_handle_t* handle, int flag) {\n-  handle->flags = handle->flags & ~flag;\n-}\n-\n-\n-int uv_flag_is_set(uv_handle_t* handle, int flag) {\n-  return (handle->flags & flag) != 0;\n-}\n-\n-\n-static uv_err_code uv_translate_sys_error(int sys_errno) {\n-  switch (sys_errno) {\n-    case 0: return UV_OK;\n-    case EACCES: return UV_EACCESS;\n-    case EAGAIN: return UV_EAGAIN;\n-    case ECONNRESET: return UV_ECONNRESET;\n-    case EFAULT: return UV_EFAULT;\n-    case EMFILE: return UV_EMFILE;\n-    case EINVAL: return UV_EINVAL;\n-    case ECONNREFUSED: return UV_ECONNREFUSED;\n-    case EADDRINUSE: return UV_EADDRINUSE;\n-    case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;\n-    default: return UV_UNKNOWN;\n-  }\n-}\n-\n-\n-static uv_err_t uv_err_new_artificial(uv_handle_t* handle, int code) {\n-  uv_err_t err;\n-  err.sys_errno_ = 0;\n-  err.code = code;\n-  last_err = err;\n-  return err;\n-}\n-\n-\n-static uv_err_t uv_err_new(uv_handle_t* handle, int sys_error) {\n-  uv_err_t err;\n-  err.sys_errno_ = sys_error;\n-  err.code = uv_translate_sys_error(sys_error);\n-  last_err = err;\n-  return err;\n-}\n-\n-\n-int uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n-  uv_tcp_t* tcp;\n-  uv_async_t* async;\n-  uv_timer_t* timer;\n-\n-  handle->close_cb = close_cb;\n-\n-  switch (handle->type) {\n-    case UV_TCP:\n-      tcp = (uv_tcp_t*) handle;\n-      ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n-      ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n-      break;\n-\n-    case UV_PREPARE:\n-      uv_prepare_stop((uv_prepare_t*) handle);\n-      break;\n-\n-    case UV_CHECK:\n-      uv_check_stop((uv_check_t*) handle);\n-      break;\n-\n-    case UV_IDLE:\n-      uv_idle_stop((uv_idle_t*) handle);\n-      break;\n-\n-    case UV_ASYNC:\n-      async = (uv_async_t*)handle;\n-      ev_async_stop(EV_DEFAULT_ &async->async_watcher);\n-      ev_ref(EV_DEFAULT_UC);\n-      break;\n-\n-    case UV_TIMER:\n-      timer = (uv_timer_t*)handle;\n-      if (ev_is_active(&timer->timer_watcher)) {\n-        ev_ref(EV_DEFAULT_UC);\n-      }\n-      ev_timer_stop(EV_DEFAULT_ &timer->timer_watcher);\n-      break;\n-\n-    default:\n-      assert(0);\n-      return -1;\n-  }\n-\n-  uv_flag_set(handle, UV_CLOSING);\n-\n-  /* This is used to call the on_close callback in the next loop. */\n-  ev_idle_start(EV_DEFAULT_ &handle->next_watcher);\n-  ev_feed_event(EV_DEFAULT_ &handle->next_watcher, EV_IDLE);\n-  assert(ev_is_pending(&handle->next_watcher));\n-\n-  return 0;\n-}\n-\n-\n-void uv_init() {\n-  /* Initialize the default ev loop. */\n-#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060\n-  ev_default_loop(EVBACKEND_KQUEUE);\n-#else\n-  ev_default_loop(EVFLAG_AUTO);\n-#endif\n-}\n-\n-\n-int uv_run() {\n-  ev_run(EV_DEFAULT_ 0);\n-  return 0;\n-}\n-\n-\n-static void uv__handle_init(uv_handle_t* handle, uv_handle_type type) {\n-  uv_counters()->handle_init++;\n-\n-  handle->type = type;\n-  handle->flags = 0;\n-\n-  ev_init(&handle->next_watcher, uv__next);\n-  handle->next_watcher.data = handle;\n-\n-  /* Ref the loop until this handle is closed. See uv__finish_close. */\n-  ev_ref(EV_DEFAULT_UC);\n-}\n-\n-\n-int uv_tcp_init(uv_tcp_t* tcp) {\n-  uv__handle_init((uv_handle_t*)tcp, UV_TCP);\n-  uv_counters()->tcp_init++;\n-\n-  tcp->alloc_cb = NULL;\n-  tcp->connect_req = NULL;\n-  tcp->accepted_fd = -1;\n-  tcp->fd = -1;\n-  tcp->delayed_error = 0;\n-  ngx_queue_init(&tcp->write_queue);\n-  ngx_queue_init(&tcp->write_completed_queue);\n-  tcp->write_queue_size = 0;\n-\n-  ev_init(&tcp->read_watcher, uv__tcp_io);\n-  tcp->read_watcher.data = tcp;\n-\n-  ev_init(&tcp->write_watcher, uv__tcp_io);\n-  tcp->write_watcher.data = tcp;\n-\n-  assert(ngx_queue_empty(&tcp->write_queue));\n-  assert(ngx_queue_empty(&tcp->write_completed_queue));\n-  assert(tcp->write_queue_size == 0);\n-\n-  return 0;\n-}\n-\n-\n-int uv__bind(uv_tcp_t* tcp, int domain, struct sockaddr* addr, int addrsize) {\n-  int r;\n-\n-  if (tcp->fd <= 0) {\n-    int fd = socket(domain, SOCK_STREAM, 0);\n-\n-    if (fd < 0) {\n-      uv_err_new((uv_handle_t*)tcp, errno);\n-      return -1;\n-    }\n-\n-    if (uv_tcp_open(tcp, fd)) {\n-      close(fd);\n-      return -2;\n-    }\n-  }\n-\n-  assert(tcp->fd >= 0);\n-\n-  r = bind(tcp->fd, addr, addrsize);\n-  tcp->delayed_error = 0;\n-\n-  if (r) {\n-    switch (errno) {\n-      case EADDRINUSE:\n-        tcp->delayed_error = errno;\n-        return 0;\n-\n-      default:\n-        uv_err_new((uv_handle_t*)tcp, errno);\n-        return -1;\n-    }\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_tcp_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {\n-  if (addr.sin_family != AF_INET) {\n-    uv_err_new((uv_handle_t*)tcp, EFAULT);\n-    return -1;\n-  }\n-\n-  return uv__bind(tcp, AF_INET, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));\n-}\n-\n-\n-int uv_tcp_bind6(uv_tcp_t* tcp, struct sockaddr_in6 addr) {\n-  if (addr.sin6_family != AF_INET6) {\n-    uv_err_new((uv_handle_t*)tcp, EFAULT);\n-    return -1;\n-  }\n-\n-  return uv__bind(tcp, AF_INET6, (struct sockaddr*)&addr, sizeof(struct sockaddr_in6));\n-}\n-\n-\n-int uv_tcp_open(uv_tcp_t* tcp, int fd) {\n-  int yes;\n-  int r;\n-\n-  assert(fd >= 0);\n-  tcp->fd = fd;\n-\n-  /* Set non-blocking. */\n-  yes = 1;\n-  r = fcntl(fd, F_SETFL, O_NONBLOCK);\n-  assert(r == 0);\n-\n-  /* Reuse the port address. */\n-  r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n-  assert(r == 0);\n-\n-  /* Associate the fd with each ev_io watcher. */\n-  ev_io_set(&tcp->read_watcher, fd, EV_READ);\n-  ev_io_set(&tcp->write_watcher, fd, EV_WRITE);\n-\n-  /* These should have been set up by uv_tcp_init. */\n-  assert(tcp->next_watcher.data == tcp);\n-  assert(tcp->write_watcher.data == tcp);\n-  assert(tcp->read_watcher.data == tcp);\n-  assert(tcp->read_watcher.cb == uv__tcp_io);\n-  assert(tcp->write_watcher.cb == uv__tcp_io);\n-\n-  return 0;\n-}\n-\n-\n-void uv__server_io(EV_P_ ev_io* watcher, int revents) {\n-  int fd;\n-  struct sockaddr_storage addr;\n-  socklen_t addrlen = sizeof(struct sockaddr_storage);\n-  uv_tcp_t* tcp = watcher->data;\n-\n-  assert(watcher == &tcp->read_watcher ||\n-         watcher == &tcp->write_watcher);\n-  assert(revents == EV_READ);\n-\n-  assert(!uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING));\n-\n-  if (tcp->accepted_fd >= 0) {\n-    ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n-    return;\n-  }\n-\n-  while (1) {\n-    assert(tcp->accepted_fd < 0);\n-    fd = accept(tcp->fd, (struct sockaddr*)&addr, &addrlen);\n-\n-    if (fd < 0) {\n-      if (errno == EAGAIN) {\n-        /* No problem. */\n-        return;\n-      } else if (errno == EMFILE) {\n-        /* TODO special trick. unlock reserved socket, accept, close. */\n-        return;\n-      } else {\n-        uv_err_new((uv_handle_t*)tcp, errno);\n-        tcp->connection_cb((uv_handle_t*)tcp, -1);\n-      }\n-\n-    } else {\n-      tcp->accepted_fd = fd;\n-      tcp->connection_cb((uv_handle_t*)tcp, 0);\n-      if (tcp->accepted_fd >= 0) {\n-        /* The user hasn't yet accepted called uv_accept() */\n-        ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n-        return;\n-      }\n-    }\n-  }\n-}\n-\n-\n-int uv_accept(uv_handle_t* server, uv_stream_t* client) {\n-  uv_tcp_t* tcpServer = (uv_tcp_t*)server;\n-  uv_tcp_t* tcpClient = (uv_tcp_t*)client;\n-\n-  if (tcpServer->accepted_fd < 0) {\n-    uv_err_new(server, EAGAIN);\n-    return -1;\n-  }\n-\n-  if (uv_tcp_open(tcpClient, tcpServer->accepted_fd)) {\n-    /* Ignore error for now */\n-    tcpServer->accepted_fd = -1;\n-    close(tcpServer->accepted_fd);\n-    return -1;\n-  } else {\n-    tcpServer->accepted_fd = -1;\n-    ev_io_start(EV_DEFAULT_ &tcpServer->read_watcher);\n-    return 0;\n-  }\n-}\n-\n-\n-int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n-  int r;\n-\n-  assert(tcp->fd >= 0);\n-\n-  if (tcp->delayed_error) {\n-    uv_err_new((uv_handle_t*)tcp, tcp->delayed_error);\n-    return -1;\n-  }\n-\n-  r = listen(tcp->fd, backlog);\n-  if (r < 0) {\n-    uv_err_new((uv_handle_t*)tcp, errno);\n-    return -1;\n-  }\n-\n-  tcp->connection_cb = cb;\n-\n-  /* Start listening for connections. */\n-  ev_io_set(&tcp->read_watcher, tcp->fd, EV_READ);\n-  ev_set_cb(&tcp->read_watcher, uv__server_io);\n-  ev_io_start(EV_DEFAULT_ &tcp->read_watcher);\n-\n-  return 0;\n-}\n-\n-\n-void uv__finish_close(uv_handle_t* handle) {\n-  uv_tcp_t* tcp;\n-\n-  assert(uv_flag_is_set(handle, UV_CLOSING));\n-  assert(!uv_flag_is_set(handle, UV_CLOSED));\n-  uv_flag_set(handle, UV_CLOSED);\n-\n-  switch (handle->type) {\n-    case UV_TCP:\n-      /* XXX Is it necessary to stop these watchers here? weren't they\n-       * supposed to be stopped in uv_close()?\n-       */\n-      tcp = (uv_tcp_t*)handle;\n-      ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n-      ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n-\n-      assert(!ev_is_active(&tcp->read_watcher));\n-      assert(!ev_is_active(&tcp->write_watcher));\n-\n-      close(tcp->fd);\n-      tcp->fd = -1;\n-\n-      if (tcp->accepted_fd >= 0) {\n-        close(tcp->accepted_fd);\n-        tcp->accepted_fd = -1;\n-      }\n-      break;\n-\n-    case UV_PREPARE:\n-      assert(!ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher));\n-      break;\n-\n-    case UV_CHECK:\n-      assert(!ev_is_active(&((uv_check_t*)handle)->check_watcher));\n-      break;\n-\n-    case UV_IDLE:\n-      assert(!ev_is_active(&((uv_idle_t*)handle)->idle_watcher));\n-      break;\n-\n-    case UV_ASYNC:\n-      assert(!ev_is_active(&((uv_async_t*)handle)->async_watcher));\n-      break;\n-\n-    case UV_TIMER:\n-      assert(!ev_is_active(&((uv_timer_t*)handle)->timer_watcher));\n-      break;\n-\n-    default:\n-      assert(0);\n-      break;\n-  }\n-\n-  ev_idle_stop(EV_DEFAULT_ &handle->next_watcher);\n-\n-  if (handle->close_cb) {\n-    handle->close_cb(handle);\n-  }\n-\n-  ev_unref(EV_DEFAULT_UC);\n-}\n-\n-\n-uv_req_t* uv_write_queue_head(uv_tcp_t* tcp) {\n-  ngx_queue_t* q;\n-  uv_req_t* req;\n-\n-  if (ngx_queue_empty(&tcp->write_queue)) {\n-    return NULL;\n-  }\n-\n-  q = ngx_queue_head(&tcp->write_queue);\n-  if (!q) {\n-    return NULL;\n-  }\n-\n-  req = ngx_queue_data(q, struct uv_req_s, queue);\n-  assert(req);\n-\n-  return req;\n-}\n-\n-\n-void uv__next(EV_P_ ev_idle* watcher, int revents) {\n-  uv_handle_t* handle = watcher->data;\n-  assert(watcher == &handle->next_watcher);\n-  assert(revents == EV_IDLE);\n-\n-  /* For now this function is only to handle the closing event, but we might\n-   * put more stuff here later.\n-   */\n-  assert(uv_flag_is_set(handle, UV_CLOSING));\n-  uv__finish_close(handle);\n-}\n-\n-\n-static void uv__drain(uv_tcp_t* tcp) {\n-  uv_req_t* req;\n-  uv_shutdown_cb cb;\n-\n-  assert(!uv_write_queue_head(tcp));\n-  assert(tcp->write_queue_size == 0);\n-\n-  ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n-\n-  /* Shutdown? */\n-  if (uv_flag_is_set((uv_handle_t*)tcp, UV_SHUTTING) &&\n-      !uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING) &&\n-      !uv_flag_is_set((uv_handle_t*)tcp, UV_SHUT)) {\n-    assert(tcp->shutdown_req);\n-\n-    req = tcp->shutdown_req;\n-    cb = (uv_shutdown_cb)req->cb;\n-\n-    if (shutdown(tcp->fd, SHUT_WR)) {\n-      /* Error. Report it. User should call uv_close(). */\n-      uv_err_new((uv_handle_t*)tcp, errno);\n-      if (cb) cb(req, -1);\n-    } else {\n-      uv_err_new((uv_handle_t*)tcp, 0);\n-      uv_flag_set((uv_handle_t*)tcp, UV_SHUT);\n-      if (cb) cb(req, 0);\n-    }\n-  }\n-}\n-\n-\n-/* On success returns NULL. On error returns a pointer to the write request\n- * which had the error.\n- */\n-static uv_req_t* uv__write(uv_tcp_t* tcp) {\n-  uv_req_t* req;\n-  struct iovec* iov;\n-  int iovcnt;\n-  ssize_t n;\n-\n-  assert(tcp->fd >= 0);\n-\n-  /* TODO: should probably while(1) here until EAGAIN */\n-\n-  /* Get the request at the head of the queue. */\n-  req = uv_write_queue_head(tcp);\n-  if (!req) {\n-    assert(tcp->write_queue_size == 0);\n-    return NULL;\n-  }\n-\n-  assert(req->handle == (uv_handle_t*)tcp);\n-\n-  /* Cast to iovec. We had to have our own uv_buf_t instead of iovec\n-   * because Windows's WSABUF is not an iovec.\n-   */\n-  assert(sizeof(uv_buf_t) == sizeof(struct iovec));\n-  iov = (struct iovec*) &(req->bufs[req->write_index]);\n-  iovcnt = req->bufcnt - req->write_index;\n-\n-  /* Now do the actual writev. Note that we've been updating the pointers\n-   * inside the iov each time we write. So there is no need to offset it.\n-   */\n-\n-  if (iovcnt == 1) {\n-    n = write(tcp->fd, iov[0].iov_base, iov[0].iov_len);\n-  }\n-  else {\n-    n = writev(tcp->fd, iov, iovcnt);\n-  }\n-\n-  if (n < 0) {\n-    if (errno != EAGAIN) {\n-      /* Error */\n-      uv_err_new((uv_handle_t*)tcp, errno);\n-      return req;\n-    }\n-  } else {\n-    /* Successful write */\n-\n-    /* Update the counters. */\n-    while (n > 0) {\n-      uv_buf_t* buf = &(req->bufs[req->write_index]);\n-      size_t len = buf->len;\n-\n-      assert(req->write_index < req->bufcnt);\n-\n-      if (n < len) {\n-        buf->base += n;\n-        buf->len -= n;\n-        tcp->write_queue_size -= n;\n-        n = 0;\n-\n-        /* There is more to write. Break and ensure the watcher is pending. */\n-        break;\n-\n-      } else {\n-        /* Finished writing the buf at index req->write_index. */\n-        req->write_index++;\n-\n-        assert(n >= len);\n-        n -= len;\n-\n-        assert(tcp->write_queue_size >= len);\n-        tcp->write_queue_size -= len;\n-\n-        if (req->write_index == req->bufcnt) {\n-          /* Then we're done! */\n-          assert(n == 0);\n-\n-          /* Pop the req off tcp->write_queue. */\n-          ngx_queue_remove(&req->queue);\n-          if (req->bufs != req->bufsml) {\n-            free(req->bufs);\n-          }\n-          req->bufs = NULL;\n-\n-          /* Add it to the write_completed_queue where it will have its\n-           * callback called in the near future.\n-           * TODO: start trying to write the next request.\n-           */\n-          ngx_queue_insert_tail(&tcp->write_completed_queue, &req->queue);\n-          ev_feed_event(EV_DEFAULT_ &tcp->write_watcher, EV_WRITE);\n-          return NULL;\n-        }\n-      }\n-    }\n-  }\n-\n-  /* Either we've counted n down to zero or we've got EAGAIN. */\n-  assert(n == 0 || n == -1);\n-\n-  /* We're not done. */\n-  ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n-\n-  return NULL;\n-}\n-\n-\n-static void uv__write_callbacks(uv_tcp_t* tcp) {\n-  uv_write_cb cb;\n-  int callbacks_made = 0;\n-  ngx_queue_t* q;\n-  uv_req_t* req;\n-\n-  while (!ngx_queue_empty(&tcp->write_completed_queue)) {\n-    /* Pop a req off write_completed_queue. */\n-    q = ngx_queue_head(&tcp->write_completed_queue);\n-    assert(q);\n-    req = ngx_queue_data(q, struct uv_req_s, queue);\n-    ngx_queue_remove(q);\n-\n-    cb = (uv_write_cb) req->cb;\n-\n-    /* NOTE: call callback AFTER freeing the request data. */\n-    if (cb) {\n-      cb(req, 0);\n-    }\n-\n-    callbacks_made++;\n-  }\n-\n-  assert(ngx_queue_empty(&tcp->write_completed_queue));\n-\n-  /* Write queue drained. */\n-  if (!uv_write_queue_head(tcp)) {\n-    uv__drain(tcp);\n-  }\n-}\n-\n-\n-void uv__read(uv_tcp_t* tcp) {\n-  uv_buf_t buf;\n-  struct iovec* iov;\n-  ssize_t nread;\n-\n-  /* XXX: Maybe instead of having UV_READING we just test if\n-   * tcp->read_cb is NULL or not?\n-   */\n-  while (tcp->read_cb && uv_flag_is_set((uv_handle_t*)tcp, UV_READING)) {\n-    assert(tcp->alloc_cb);\n-    buf = tcp->alloc_cb((uv_stream_t*)tcp, 64 * 1024);\n-\n-    assert(buf.len > 0);\n-    assert(buf.base);\n-\n-    iov = (struct iovec*) &buf;\n-\n-    nread = read(tcp->fd, buf.base, buf.len);\n-\n-    if (nread < 0) {\n-      /* Error */\n-      if (errno == EAGAIN) {\n-        /* Wait for the next one. */\n-        if (uv_flag_is_set((uv_handle_t*)tcp, UV_READING)) {\n-          ev_io_start(EV_DEFAULT_UC_ &tcp->read_watcher);\n-        }\n-        uv_err_new((uv_handle_t*)tcp, EAGAIN);\n-        tcp->read_cb((uv_stream_t*)tcp, 0, buf);\n-        return;\n-      } else {\n-        /* Error. User should call uv_close(). */\n-        uv_err_new((uv_handle_t*)tcp, errno);\n-        tcp->read_cb((uv_stream_t*)tcp, -1, buf);\n-        assert(!ev_is_active(&tcp->read_watcher));\n-        return;\n-      }\n-    } else if (nread == 0) {\n-      /* EOF */\n-      uv_err_new_artificial((uv_handle_t*)tcp, UV_EOF);\n-      ev_io_stop(EV_DEFAULT_UC_ &tcp->read_watcher);\n-      tcp->read_cb((uv_stream_t*)tcp, -1, buf);\n-      return;\n-    } else {\n-      /* Successful read */\n-      tcp->read_cb((uv_stream_t*)tcp, nread, buf);\n-    }\n-  }\n-}\n-\n-\n-int uv_shutdown(uv_req_t* req) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n-  assert(tcp->fd >= 0);\n-  assert(tcp->type == UV_TCP);\n-\n-  if (uv_flag_is_set((uv_handle_t*)tcp, UV_SHUT) ||\n-      uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSED) ||\n-      uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING)) {\n-    return -1;\n-  }\n-\n-  tcp->shutdown_req = req;\n-  req->type = UV_SHUTDOWN;\n-\n-  uv_flag_set((uv_handle_t*)tcp, UV_SHUTTING);\n-\n-  ev_io_start(EV_DEFAULT_UC_ &tcp->write_watcher);\n-\n-  return 0;\n-}\n-\n-\n-void uv__tcp_io(EV_P_ ev_io* watcher, int revents) {\n-  uv_tcp_t* tcp = watcher->data;\n-  assert(watcher == &tcp->read_watcher ||\n-         watcher == &tcp->write_watcher);\n-\n-  assert(tcp->fd >= 0);\n-\n-  assert(!uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING));\n-\n-  if (tcp->connect_req) {\n-    uv__tcp_connect(tcp);\n-  } else {\n-    if (revents & EV_READ) {\n-      uv__read(tcp);\n-    }\n-\n-    if (revents & EV_WRITE) {\n-      uv_req_t* req = uv__write(tcp);\n-      if (req) {\n-        /* Error. Notify the user. */\n-        uv_write_cb cb = (uv_write_cb) req->cb;\n-\n-        if (cb) {\n-          cb(req, -1);\n-        }\n-      } else {\n-        uv__write_callbacks(tcp);\n-      }\n-    }\n-  }\n-}\n-\n-\n-/**\n- * We get called here from directly following a call to connect(2).\n- * In order to determine if we've errored out or succeeded must call\n- * getsockopt.\n- */\n-static void uv__tcp_connect(uv_tcp_t* tcp) {\n-  int error;\n-  uv_req_t* req;\n-  uv_connect_cb connect_cb;\n-  socklen_t errorsize = sizeof(int);\n-\n-  assert(tcp->fd >= 0);\n-\n-  req = tcp->connect_req;\n-  assert(req);\n-\n-  if (tcp->delayed_error) {\n-    /* To smooth over the differences between unixes errors that\n-     * were reported synchronously on the first connect can be delayed\n-     * until the next tick--which is now.\n-     */\n-    error = tcp->delayed_error;\n-    tcp->delayed_error = 0;\n-  } else {\n-    /* Normal situation: we need to get the socket error from the kernel. */\n-    getsockopt(tcp->fd, SOL_SOCKET, SO_ERROR, &error, &errorsize);\n-  }\n-\n-  if (!error) {\n-    ev_io_start(EV_DEFAULT_ &tcp->read_watcher);\n-\n-    /* Successful connection */\n-    tcp->connect_req = NULL;\n-    connect_cb = (uv_connect_cb) req->cb;\n-    if (connect_cb) {\n-      connect_cb(req, 0);\n-    }\n-\n-  } else if (error == EINPROGRESS) {\n-    /* Still connecting. */\n-    return;\n-  } else {\n-    /* Error */\n-    uv_err_t err = uv_err_new((uv_handle_t*)tcp, error);\n-\n-    tcp->connect_req = NULL;\n-\n-    connect_cb = (uv_connect_cb) req->cb;\n-    if (connect_cb) {\n-      connect_cb(req, -1);\n-    }\n-  }\n-}\n-\n-\n-static int uv__connect(uv_req_t* req, struct sockaddr* addr,\n-    socklen_t addrlen) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n-  int r;\n-\n-  if (tcp->fd <= 0) {\n-    int fd = socket(addr->sa_family, SOCK_STREAM, 0);\n-\n-    if (fd < 0) {\n-      uv_err_new((uv_handle_t*)tcp, errno);\n-      return -1;\n-    }\n-\n-    if (uv_tcp_open(tcp, fd)) {\n-      close(fd);\n-      return -2;\n-    }\n-  }\n-\n-  req->type = UV_CONNECT;\n-  ngx_queue_init(&req->queue);\n-\n-  if (tcp->connect_req) {\n-    uv_err_new((uv_handle_t*)tcp, EALREADY);\n-    return -1;\n-  }\n-\n-  if (tcp->type != UV_TCP) {\n-    uv_err_new((uv_handle_t*)tcp, ENOTSOCK);\n-    return -1;\n-  }\n-\n-  tcp->connect_req = req;\n-\n-  r = connect(tcp->fd, addr, addrlen);\n-\n-  tcp->delayed_error = 0;\n-\n-  if (r != 0 && errno != EINPROGRESS) {\n-    switch (errno) {\n-      /* If we get a ECONNREFUSED wait until the next tick to report the\n-       * error. Solaris wants to report immediately--other unixes want to\n-       * wait.\n-       */\n-      case ECONNREFUSED:\n-        tcp->delayed_error = errno;\n-        break;\n-\n-      default:\n-        uv_err_new((uv_handle_t*)tcp, errno);\n-        return -1;\n-    }\n-  }\n-\n-  assert(tcp->write_watcher.data == tcp);\n-  ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n-\n-  if (tcp->delayed_error) {\n-    ev_feed_event(EV_DEFAULT_ &tcp->write_watcher, EV_WRITE);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_tcp_connect(uv_req_t* req, struct sockaddr_in addr) {\n-  assert(addr.sin_family == AF_INET);\n-  return uv__connect(req, (struct sockaddr*) &addr,\n-      sizeof(struct sockaddr_in));\n-}\n-\n-\n-int uv_tcp_connect6(uv_req_t* req, struct sockaddr_in6 addr) {\n-  assert(addr.sin6_family == AF_INET6);\n-  return uv__connect(req, (struct sockaddr*) &addr,\n-      sizeof(struct sockaddr_in6));\n-}\n-\n-\n-static size_t uv__buf_count(uv_buf_t bufs[], int bufcnt) {\n-  size_t total = 0;\n-  int i;\n-\n-  for (i = 0; i < bufcnt; i++) {\n-    total += bufs[i].len;\n-  }\n-\n-  return total;\n-}\n-\n-\n-/* The buffers to be written must remain valid until the callback is called.\n- * This is not required for the uv_buf_t array.\n- */\n-int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n-  int empty_queue = (tcp->write_queue_size == 0);\n-  assert(tcp->fd >= 0);\n-\n-  ngx_queue_init(&req->queue);\n-  req->type = UV_WRITE;\n-\n-\n-  if (bufcnt < UV_REQ_BUFSML_SIZE) {\n-    req->bufs = req->bufsml;\n-  }\n-  else {\n-    req->bufs = malloc(sizeof(uv_buf_t) * bufcnt);\n-  }\n-\n-  memcpy(req->bufs, bufs, bufcnt * sizeof(uv_buf_t));\n-  req->bufcnt = bufcnt;\n-\n-  /*\n-   * fprintf(stderr, \"cnt: %d bufs: %p bufsml: %p\\n\", bufcnt, req->bufs, req->bufsml);\n-   */\n-\n-  req->write_index = 0;\n-  tcp->write_queue_size += uv__buf_count(bufs, bufcnt);\n-\n-  /* Append the request to write_queue. */\n-  ngx_queue_insert_tail(&tcp->write_queue, &req->queue);\n-\n-  assert(!ngx_queue_empty(&tcp->write_queue));\n-  assert(tcp->write_watcher.cb == uv__tcp_io);\n-  assert(tcp->write_watcher.data == tcp);\n-  assert(tcp->write_watcher.fd == tcp->fd);\n-\n-  /* If the queue was empty when this function began, we should attempt to\n-   * do the write immediately. Otherwise start the write_watcher and wait\n-   * for the fd to become writable.\n-   */\n-  if (empty_queue) {\n-    if (uv__write(tcp)) {\n-      /* Error. uv_last_error has been set. */\n-      return -1;\n-    }\n-  }\n-\n-  /* If the queue is now empty - we've flushed the request already. That\n-   * means we need to make the callback. The callback can only be done on a\n-   * fresh stack so we feed the event loop in order to service it.\n-   */\n-  if (ngx_queue_empty(&tcp->write_queue)) {\n-    ev_feed_event(EV_DEFAULT_ &tcp->write_watcher, EV_WRITE);\n-  } else {\n-    /* Otherwise there is data to write - so we should wait for the file\n-     * descriptor to become writable.\n-     */\n-    ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-void uv_ref() {\n-  ev_ref(EV_DEFAULT_UC);\n-}\n-\n-\n-void uv_unref() {\n-  ev_unref(EV_DEFAULT_UC);\n-}\n-\n-\n-void uv_update_time() {\n-  ev_now_update(EV_DEFAULT_UC);\n-}\n-\n-\n-int64_t uv_now() {\n-  return (int64_t)(ev_now(EV_DEFAULT_UC) * 1000);\n-}\n-\n-\n-int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)stream;\n-\n-  /* The UV_READING flag is irrelevant of the state of the tcp - it just\n-   * expresses the desired state of the user.\n-   */\n-  uv_flag_set((uv_handle_t*)tcp, UV_READING);\n-\n-  /* TODO: try to do the read inline? */\n-  /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n-   * not start the IO watcher.\n-   */\n-  assert(tcp->fd >= 0);\n-  assert(alloc_cb);\n-\n-  tcp->read_cb = read_cb;\n-  tcp->alloc_cb = alloc_cb;\n-\n-  /* These should have been set by uv_tcp_init. */\n-  assert(tcp->read_watcher.data == tcp);\n-  assert(tcp->read_watcher.cb == uv__tcp_io);\n-\n-  ev_io_start(EV_DEFAULT_UC_ &tcp->read_watcher);\n-  return 0;\n-}\n-\n-\n-int uv_read_stop(uv_stream_t* stream) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)stream;\n-\n-  uv_flag_unset((uv_handle_t*)tcp, UV_READING);\n-\n-  ev_io_stop(EV_DEFAULT_UC_ &tcp->read_watcher);\n-  tcp->read_cb = NULL;\n-  tcp->alloc_cb = NULL;\n-  return 0;\n-}\n-\n-\n-void uv_req_init(uv_req_t* req, uv_handle_t* handle, void *(*cb)(void *)) {\n-  uv_counters()->req_init++;\n-  req->type = UV_UNKNOWN_REQ;\n-  req->cb = cb;\n-  req->handle = handle;\n-  ngx_queue_init(&req->queue);\n-}\n-\n-\n-static void uv__prepare(EV_P_ ev_prepare* w, int revents) {\n-  uv_prepare_t* prepare = w->data;\n-\n-  if (prepare->prepare_cb) {\n-    prepare->prepare_cb(prepare, 0);\n-  }\n-}\n-\n-\n-int uv_prepare_init(uv_prepare_t* prepare) {\n-  uv__handle_init((uv_handle_t*)prepare, UV_PREPARE);\n-  uv_counters()->prepare_init++;\n-\n-  ev_prepare_init(&prepare->prepare_watcher, uv__prepare);\n-  prepare->prepare_watcher.data = prepare;\n-\n-  prepare->prepare_cb = NULL;\n-\n-  return 0;\n-}\n-\n-\n-int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb) {\n-  int was_active = ev_is_active(&prepare->prepare_watcher);\n-\n-  prepare->prepare_cb = cb;\n-\n-  ev_prepare_start(EV_DEFAULT_UC_ &prepare->prepare_watcher);\n-\n-  if (!was_active) {\n-    ev_unref(EV_DEFAULT_UC);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_prepare_stop(uv_prepare_t* prepare) {\n-  int was_active = ev_is_active(&prepare->prepare_watcher);\n-\n-  ev_prepare_stop(EV_DEFAULT_UC_ &prepare->prepare_watcher);\n-\n-  if (was_active) {\n-    ev_ref(EV_DEFAULT_UC);\n-  }\n-  return 0;\n-}\n-\n-\n-\n-static void uv__check(EV_P_ ev_check* w, int revents) {\n-  uv_check_t* check = w->data;\n-\n-  if (check->check_cb) {\n-    check->check_cb(check, 0);\n-  }\n-}\n-\n-\n-int uv_check_init(uv_check_t* check) {\n-  uv__handle_init((uv_handle_t*)check, UV_CHECK);\n-  uv_counters()->check_init;\n-\n-  ev_check_init(&check->check_watcher, uv__check);\n-  check->check_watcher.data = check;\n-\n-  check->check_cb = NULL;\n-\n-  return 0;\n-}\n-\n-\n-int uv_check_start(uv_check_t* check, uv_check_cb cb) {\n-  int was_active = ev_is_active(&check->check_watcher);\n-\n-  check->check_cb = cb;\n-\n-  ev_check_start(EV_DEFAULT_UC_ &check->check_watcher);\n-\n-  if (!was_active) {\n-    ev_unref(EV_DEFAULT_UC);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_check_stop(uv_check_t* check) {\n-  int was_active = ev_is_active(&check->check_watcher);\n-\n-  ev_check_stop(EV_DEFAULT_UC_ &check->check_watcher);\n-\n-  if (was_active) {\n-    ev_ref(EV_DEFAULT_UC);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-static void uv__idle(EV_P_ ev_idle* w, int revents) {\n-  uv_idle_t* idle = (uv_idle_t*)(w->data);\n-\n-  if (idle->idle_cb) {\n-    idle->idle_cb(idle, 0);\n-  }\n-}\n-\n-\n-\n-int uv_idle_init(uv_idle_t* idle) {\n-  uv__handle_init((uv_handle_t*)idle, UV_IDLE);\n-  uv_counters()->idle_init++;\n-\n-  ev_idle_init(&idle->idle_watcher, uv__idle);\n-  idle->idle_watcher.data = idle;\n-\n-  idle->idle_cb = NULL;\n-\n-  return 0;\n-}\n-\n-\n-int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {\n-  int was_active = ev_is_active(&idle->idle_watcher);\n-\n-  idle->idle_cb = cb;\n-  ev_idle_start(EV_DEFAULT_UC_ &idle->idle_watcher);\n-\n-  if (!was_active) {\n-    ev_unref(EV_DEFAULT_UC);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_idle_stop(uv_idle_t* idle) {\n-  int was_active = ev_is_active(&idle->idle_watcher);\n-\n-  ev_idle_stop(EV_DEFAULT_UC_ &idle->idle_watcher);\n-\n-  if (was_active) {\n-    ev_ref(EV_DEFAULT_UC);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-int uv_is_active(uv_handle_t* handle) {\n-  switch (handle->type) {\n-    case UV_TIMER:\n-      return ev_is_active(&((uv_timer_t*)handle)->timer_watcher);\n-\n-    case UV_PREPARE:\n-      return ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher);\n-\n-    case UV_CHECK:\n-      return ev_is_active(&((uv_check_t*)handle)->check_watcher);\n-\n-    case UV_IDLE:\n-      return ev_is_active(&((uv_idle_t*)handle)->idle_watcher);\n-\n-    default:\n-      return 1;\n-  }\n-}\n-\n-\n-static void uv__async(EV_P_ ev_async* w, int revents) {\n-  uv_async_t* async = w->data;\n-\n-  if (async->async_cb) {\n-    async->async_cb(async, 0);\n-  }\n-}\n-\n-\n-int uv_async_init(uv_async_t* async, uv_async_cb async_cb) {\n-  uv__handle_init((uv_handle_t*)async, UV_ASYNC);\n-  uv_counters()->async_init++;\n-\n-  ev_async_init(&async->async_watcher, uv__async);\n-  async->async_watcher.data = async;\n-\n-  async->async_cb = async_cb;\n-\n-  /* Note: This does not have symmetry with the other libev wrappers. */\n-  ev_async_start(EV_DEFAULT_UC_ &async->async_watcher);\n-  ev_unref(EV_DEFAULT_UC);\n-\n-  return 0;\n-}\n-\n-\n-int uv_async_send(uv_async_t* async) {\n-  ev_async_send(EV_DEFAULT_UC_ &async->async_watcher);\n-}\n-\n-\n-static void uv__timer_cb(EV_P_ ev_timer* w, int revents) {\n-  uv_timer_t* timer = w->data;\n-\n-  if (!ev_is_active(w)) {\n-    ev_ref(EV_DEFAULT_UC);\n-  }\n-\n-  if (timer->timer_cb) {\n-    timer->timer_cb(timer, 0);\n-  }\n-}\n-\n-\n-int uv_timer_init(uv_timer_t* timer) {\n-  uv__handle_init((uv_handle_t*)timer, UV_TIMER);\n-  uv_counters()->timer_init++;\n-\n-  ev_init(&timer->timer_watcher, uv__timer_cb);\n-  timer->timer_watcher.data = timer;\n-\n-  return 0;\n-}\n-\n-\n-int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout,\n-    int64_t repeat) {\n-  if (ev_is_active(&timer->timer_watcher)) {\n-    return -1;\n-  }\n-\n-  timer->timer_cb = cb;\n-  ev_timer_set(&timer->timer_watcher, timeout / 1000.0, repeat / 1000.0);\n-  ev_timer_start(EV_DEFAULT_UC_ &timer->timer_watcher);\n-  ev_unref(EV_DEFAULT_UC);\n-  return 0;\n-}\n-\n-\n-int uv_timer_stop(uv_timer_t* timer) {\n-  if (ev_is_active(&timer->timer_watcher)) {\n-    ev_ref(EV_DEFAULT_UC);\n-  }\n-\n-  ev_timer_stop(EV_DEFAULT_UC_ &timer->timer_watcher);\n-  return 0;\n-}\n-\n-\n-int uv_timer_again(uv_timer_t* timer) {\n-  if (!ev_is_active(&timer->timer_watcher)) {\n-    uv_err_new((uv_handle_t*)timer, EINVAL);\n-    return -1;\n-  }\n-\n-  ev_timer_again(EV_DEFAULT_UC_ &timer->timer_watcher);\n-  return 0;\n-}\n-\n-void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat) {\n-  assert(timer->type == UV_TIMER);\n-  timer->timer_watcher.repeat = repeat / 1000.0;\n-}\n-\n-int64_t uv_timer_get_repeat(uv_timer_t* timer) {\n-  assert(timer->type == UV_TIMER);\n-  return (int64_t)(1000 * timer->timer_watcher.repeat);\n-}\n-\n-\n-/*\n- * This is called once per second by ares_data.timer. It is used to \n- * constantly callback into c-ares for possibly processing timeouts.\n- */\n-static void uv__ares_timeout(EV_P_ struct ev_timer* watcher, int revents) {\n-  assert(watcher == &ares_data.timer);\n-  assert(revents == EV_TIMER);\n-  assert(!uv_ares_handles_empty());\n-  ares_process_fd(ares_data.channel, ARES_SOCKET_BAD, ARES_SOCKET_BAD);\n-}\n-\n-\n-static void uv__ares_io(EV_P_ struct ev_io* watcher, int revents) {\n-  /* Reset the idle timer */\n-  ev_timer_again(EV_A_ &ares_data.timer);\n-\n-  /* Process DNS responses */\n-  ares_process_fd(ares_data.channel,\n-      revents & EV_READ ? watcher->fd : ARES_SOCKET_BAD,\n-      revents & EV_WRITE ? watcher->fd : ARES_SOCKET_BAD);\n-}\n-\n-\n-/* Allocates and returns a new uv_ares_task_t */\n-static uv_ares_task_t* uv__ares_task_create(int fd) {\n-  uv_ares_task_t* h = malloc(sizeof(uv_ares_task_t));\n-\n-  if (h == NULL) {\n-    uv_fatal_error(ENOMEM, \"malloc\");\n-  }\n-\n-  h->sock = fd;\n-\n-  ev_io_init(&h->read_watcher, uv__ares_io, fd, EV_READ);\n-  ev_io_init(&h->write_watcher, uv__ares_io, fd, EV_WRITE);\n-\n-  h->read_watcher.data = h;\n-  h->write_watcher.data = h;\n-}\n-\n-\n-/* Callback from ares when socket operation is started */\n-static void uv__ares_sockstate_cb(void* data, ares_socket_t sock,\n-    int read, int write) {\n-  uv_ares_task_t* h = uv_find_ares_handle(sock);\n-\n-  if (read || write) {\n-    if (!h) {\n-      /* New socket */\n-\n-      /* If this is the first socket then start the timer. */\n-      if (!ev_is_active(&ares_data.timer)) {\n-        assert(uv_ares_handles_empty());\n-        ev_timer_again(EV_DEFAULT_UC_ &ares_data.timer);\n-      }\n-\n-      h = uv__ares_task_create(sock);\n-      uv_add_ares_handle(h);\n-    }\n-\n-    if (read) {\n-      ev_io_start(EV_DEFAULT_UC_ &h->read_watcher);\n-    } else {\n-      ev_io_stop(EV_DEFAULT_UC_ &h->read_watcher);\n-    }\n-\n-    if (write) {\n-      ev_io_start(EV_DEFAULT_UC_ &h->write_watcher);\n-    } else {\n-      ev_io_stop(EV_DEFAULT_UC_ &h->write_watcher);\n-    }\n-\n-  } else {\n-    /*\n-     * read == 0 and write == 0 this is c-ares's way of notifying us that\n-     * the socket is now closed. We must free the data associated with\n-     * socket.\n-     */\n-    assert(h && \"When an ares socket is closed we should have a handle for it\");\n-\n-    ev_io_stop(EV_DEFAULT_UC_ &h->read_watcher);\n-    ev_io_stop(EV_DEFAULT_UC_ &h->write_watcher);\n-\n-    uv_remove_ares_handle(h);\n-    free(h);\n-\n-    if (uv_ares_handles_empty()) {\n-      ev_timer_stop(EV_DEFAULT_UC_ &ares_data.timer);\n-    }\n-  }\n-}\n-\n-\n-/* c-ares integration initialize and terminate */\n-/* TODO: share this with windows? */\n-int uv_ares_init_options(ares_channel *channelptr,\n-                         struct ares_options *options,\n-                         int optmask) {\n-  int rc;\n-\n-  /* only allow single init at a time */\n-  if (ares_data.channel != NULL) {\n-    uv_err_new_artificial(NULL, UV_EALREADY);\n-    return -1;\n-  }\n-\n-  /* set our callback as an option */\n-  options->sock_state_cb = uv__ares_sockstate_cb;\n-  options->sock_state_cb_data = &ares_data;\n-  optmask |= ARES_OPT_SOCK_STATE_CB;\n-\n-  /* We do the call to ares_init_option for caller. */\n-  rc = ares_init_options(channelptr, options, optmask);\n-\n-  /* if success, save channel */\n-  if (rc == ARES_SUCCESS) {\n-    ares_data.channel = *channelptr;\n-  }\n-\n-  /*\n-   * Initialize the timeout timer. The timer won't be started until the\n-   * first socket is opened.\n-   */\n-  ev_init(&ares_data.timer, uv__ares_timeout);\n-  ares_data.timer.repeat = 1.0;\n-\n-  return rc;\n-}\n-\n-\n-/* TODO share this with windows? */\n-void uv_ares_destroy(ares_channel channel) {\n-  /* only allow destroy if did init */\n-  if (ares_data.channel != NULL) {\n-    ev_timer_stop(EV_DEFAULT_UC_ &ares_data.timer);\n-    ares_destroy(channel);\n-    ares_data.channel = NULL;\n-  }\n-}\n-\n-\n-static int uv_getaddrinfo_done(eio_req* req) {\n-  uv_getaddrinfo_t* handle = req->data;\n-\n-  uv_unref();\n-\n-  free(handle->hints);\n-  free(handle->service);\n-  free(handle->hostname);\n-\n-  if (handle->retcode != 0) {\n-    /* TODO how to display gai error strings? */\n-    uv_err_new(NULL, handle->retcode);\n-  }\n-\n-  handle->cb(handle, handle->retcode, handle->res);\n-\n-  freeaddrinfo(handle->res);\n-  handle->res = NULL;\n-\n-  return 0;\n-}\n-\n-\n-static int getaddrinfo_thread_proc(eio_req *req) {\n-  uv_getaddrinfo_t* handle = req->data;\n-\n-  handle->retcode = getaddrinfo(handle->hostname,\n-                                handle->service,\n-                                handle->hints,\n-                                &handle->res);\n-  return 0;\n-}\n-\n-\n-/* stub implementation of uv_getaddrinfo */\n-int uv_getaddrinfo(uv_getaddrinfo_t* handle,\n-                   uv_getaddrinfo_cb cb,\n-                   const char* hostname,\n-                   const char* service,\n-                   const struct addrinfo* hints) {\n-  eio_req* req;\n-  uv_eio_init();\n-\n-  if (handle == NULL || cb == NULL ||\n-      (hostname == NULL && service == NULL)) {\n-    uv_err_new_artificial(NULL, UV_EINVAL);\n-    return -1;\n-  }\n-\n-  memset(handle, 0, sizeof(uv_getaddrinfo_t));\n-\n-  /* TODO don't alloc so much. */\n-\n-  if (hints) {\n-    handle->hints = malloc(sizeof(struct addrinfo));\n-    memcpy(&handle->hints, hints, sizeof(struct addrinfo));\n-  }\n-\n-  /* TODO security! check lengths, check return values. */\n-\n-  handle->cb = cb;\n-  handle->hostname = hostname ? strdup(hostname) : NULL;\n-  handle->service = service ? strdup(service) : NULL;\n-\n-  /* TODO check handle->hostname == NULL */\n-  /* TODO check handle->service == NULL */\n-\n-  uv_ref();\n-\n-  req = eio_custom(getaddrinfo_thread_proc, EIO_PRI_DEFAULT,\n-      uv_getaddrinfo_done, handle);\n-  assert(req);\n-  assert(req->data == handle);\n-\n-  return 0;\n-}\n-"}, {"sha": "93bf64d193c3d79f3b92e4863eef0d4747529069", "filename": "src/rt/libuv/src/uv-win.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/d8f6e9f23736f6a12dfa028d22557d1360648234/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-win.c?ref=d8f6e9f23736f6a12dfa028d22557d1360648234"}, {"sha": "ee5faea272c662efc8adcb21ea515937777f5ef3", "filename": "src/rt/libuv/src/win/async.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "f146c31a56adf6871bb1ff22f64336ba3d98a2d2", "filename": "src/rt/libuv/src/win/cares.c", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "3211bbf2afd8f6a3e33af2c8d5f46f04540b0ed0", "filename": "src/rt/libuv/src/win/core.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "0ed2e16abe26a0d749148184bba127c66bc7d547", "filename": "src/rt/libuv/src/win/error.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "a68dfe00def89c5a10488924deba5c7879483c8e", "filename": "src/rt/libuv/src/win/fs-event.c", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "93fa5eb36b5b6ee615628ac5a364de28a6942ed9", "filename": "src/rt/libuv/src/win/fs.c", "status": "added", "additions": 1302, "deletions": 0, "changes": 1302, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "1416f04d62e36479d526c7677cda806c41739b6e", "filename": "src/rt/libuv/src/win/getaddrinfo.c", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "ab4f64bc5aef6d25de9d971acdae970c08b74e6c", "filename": "src/rt/libuv/src/win/handle.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "87a64eda1b2c857997231341851f04a59085c6e2", "filename": "src/rt/libuv/src/win/internal.h", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "c597cd99b12e9c718dcabada78148d09e93fbde3", "filename": "src/rt/libuv/src/win/loop-watcher.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "7832c6a41af346d995ceab9984d7e49438b2118b", "filename": "src/rt/libuv/src/win/pipe.c", "status": "added", "additions": 1067, "deletions": 0, "changes": 1067, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "ed8015e0ef6f12621bb09bb630751df76551ca0f", "filename": "src/rt/libuv/src/win/process.c", "status": "added", "additions": 1045, "deletions": 0, "changes": 1045, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "a0a6e03dc6070578a7ed2121dbeef43554a274ec", "filename": "src/rt/libuv/src/win/req.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "30fe2a1d6e1e013bb323f0fa779970fcbceef5a6", "filename": "src/rt/libuv/src/win/stdio.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstdio.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstdio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstdio.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "26964110fceed79ae6ca8f707241f20b5165c357", "filename": "src/rt/libuv/src/win/stream.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "ebd835349837f03bd934ffee563aa0c2d73dcc88", "filename": "src/rt/libuv/src/win/tcp.c", "status": "added", "additions": 870, "deletions": 0, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "c40613e1f5cc272f4941460484ac1ada764d2345", "filename": "src/rt/libuv/src/win/threadpool.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "1fc6b73f8700dfe16deecfdd7a8c388185054f3c", "filename": "src/rt/libuv/src/win/threads.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "ac20925293f98aeb2715a70731c886df217ace76", "filename": "src/rt/libuv/src/win/timer.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "a4a46829643418c224233e43b707be7aab6a7a7c", "filename": "src/rt/libuv/src/win/tty.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "3a2ab6bc1b46d8dbcc2c88c661bfa8f5c3022cba", "filename": "src/rt/libuv/src/win/udp.c", "status": "added", "additions": 598, "deletions": 0, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "67de53e5c04fe9ec9c5b215e44d06b550d7767b5", "filename": "src/rt/libuv/src/win/util.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "4a58c14574f3bdcc264c00ca559e17085e59dd74", "filename": "src/rt/libuv/src/win/winapi.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "760281e8619cc3e19b0c9c7bcf8532d94b2c5908", "filename": "src/rt/libuv/src/win/winapi.h", "status": "added", "additions": 4337, "deletions": 0, "changes": 4337, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "1f56b3d75bd9cb47e2b70a4c6f3bba657a39582c", "filename": "src/rt/libuv/src/win/winsock.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "2c9fb92db1bfe8fd3997883e594f8038b3233b52", "filename": "src/rt/libuv/src/win/winsock.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "bfd081deff54dd7c9c60e9177740a93a49ccff33", "filename": "src/rt/libuv/test/benchmark-ares.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "892c14d1e95815736aae8cb1478ac2f6e123da36", "filename": "src/rt/libuv/test/benchmark-getaddrinfo.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "0e5467c7a1bd4f2a34704694e075a585636ac1bc", "filename": "src/rt/libuv/test/benchmark-list.h", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "c36215c1deb802d0bd8636c1a6a1809f37dc741f", "filename": "src/rt/libuv/test/benchmark-ping-pongs.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "1f56e27f69d450f7d6b1227d5b8d5ac0352c3498", "filename": "src/rt/libuv/test/benchmark-pound.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "d0b0930157012f50abbdee48a6ec547d91b0b140", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "modified", "additions": 140, "deletions": 66, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "3967f301f9f019a33d3a929cccb230dcb839724c", "filename": "src/rt/libuv/test/benchmark-sizes.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "6e5493d529b10824d360550d87f798c69db19e84", "filename": "src/rt/libuv/test/benchmark-spawn.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "24a9e1b920dc8824ecc0d517638a92db7e7a4479", "filename": "src/rt/libuv/test/benchmark-udp-packet-storm.c", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "086b52d1a363c1c2c098e04dbf56bf8adb433f1a", "filename": "src/rt/libuv/test/dns-server.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "453ada66d2461a46d744599be91c2185c48dcf9e", "filename": "src/rt/libuv/test/echo-server.c", "status": "modified", "additions": 141, "deletions": 57, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "af11beb9b4c3ff410b5f2526bfd5743095e16df5", "filename": "src/rt/libuv/test/run-benchmarks.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "a187869110a81239bc0f6fdd9e636270c3b006c6", "filename": "src/rt/libuv/test/run-tests.c", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "6033d64294d482721c0e5e345ebe43d5abf3f258", "filename": "src/rt/libuv/test/runner-unix.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "fc08839ee481e6293019ff4b711f3ce351d5e41c", "filename": "src/rt/libuv/test/runner-win.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "73a3864ee415364c9e60d5ecdb2ba077587e046f", "filename": "src/rt/libuv/test/runner.c", "status": "modified", "additions": 208, "deletions": 68, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "3b93ffe991ba8fe22da5287a76c4c8810e030dee", "filename": "src/rt/libuv/test/runner.h", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "76c6903311e1836db21c8c68ccd76126d9480d8e", "filename": "src/rt/libuv/test/task.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftask.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "3d8415183d1cd0bb9b3a34114327ae5d6850fff6", "filename": "src/rt/libuv/test/test-async.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "4af636488616def642c4fdf99be5858e2989dfc7", "filename": "src/rt/libuv/test/test-callback-stack.c", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "2762aa285a9392885c28b724868d2f77b0538916", "filename": "src/rt/libuv/test/test-connection-fail.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "78531f68067cac74167afd9da5a122c55007f290", "filename": "src/rt/libuv/test/test-delayed-accept.c", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "d249ec6692cd2da8913fdae682808c3fa057710b", "filename": "src/rt/libuv/test/test-fs-event.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "fbe0396bf8436056b02f5ba5e2270fef7904ebcf", "filename": "src/rt/libuv/test/test-fs.c", "status": "added", "additions": 1247, "deletions": 0, "changes": 1247, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "9dd267691c056bb60a92f5f8200df2ba887e33f4", "filename": "src/rt/libuv/test/test-get-currentexe.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "2a8c94e755283336e1903a5fd07d0ac3f2c0efc0", "filename": "src/rt/libuv/test/test-getaddrinfo.c", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "583622e72452c1d77a4cfb23cfbbf86ded26a772", "filename": "src/rt/libuv/test/test-gethostbyname.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "5dac88b73e4896135aea8ea7968f7f38ed34ca2e", "filename": "src/rt/libuv/test/test-getsockname.c", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "566e0d2ee020cd290b65e4640f57dbadf9d81606", "filename": "src/rt/libuv/test/test-hrtime.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "95ef3a94959e9578396df7153c08d1b5d9f7974c", "filename": "src/rt/libuv/test/test-idle.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "bf376e3914175b1088a63038fa3f47eb8143a2be", "filename": "src/rt/libuv/test/test-list.h", "status": "modified", "additions": 130, "deletions": 36, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "9a76cc53fa6b198d29a0f5eb13c33010cf34f382", "filename": "src/rt/libuv/test/test-loop-handles.c", "status": "modified", "additions": 14, "deletions": 74, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "f452fce50b52443077ecc24b31ad8cbe7da9bdc3", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "modified", "additions": 79, "deletions": 44, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "832ce0231530f7c0f5401e971ad65530bb277089", "filename": "src/rt/libuv/test/test-pipe-bind-error.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "0083335fd12c964ab01a6e1209bc7e77662df5eb", "filename": "src/rt/libuv/test/test-ref.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "9d4f2cce74d5aaa41cbcc81a0bbade1c123096d0", "filename": "src/rt/libuv/test/test-shutdown-eof.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "653f9ac95d3ba39a89cc12e375ced5c58ec97a20", "filename": "src/rt/libuv/test/test-spawn.c", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "9512519ac0cd013d7696583ba37bae4994ca6bb9", "filename": "src/rt/libuv/test/test-tcp-bind-error.c", "status": "renamed", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/test/test-bind-error.c"}, {"sha": "5a8b76363a63ffcbc1d235e3b8099c9fa547caa3", "filename": "src/rt/libuv/test/test-tcp-bind6-error.c", "status": "renamed", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e", "previous_filename": "src/rt/libuv/test/test-bind6-error.c"}, {"sha": "5da8a84f8a20cc71d3fd338613436435ab6082fb", "filename": "src/rt/libuv/test/test-tcp-close.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "f3d12b8d6bfb3c62eae28c4698e51d0c541c31ce", "filename": "src/rt/libuv/test/test-tcp-write-error.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "f6b1dc6efa1934dfc143ed4200179cf6bbc621cd", "filename": "src/rt/libuv/test/test-tcp-writealot.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "92130b506c55516ad8d49b898596b0e366f59186", "filename": "src/rt/libuv/test/test-threadpool.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "9eeee1e34dca36ace803fb8f1a633a5af0681efa", "filename": "src/rt/libuv/test/test-timer-again.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "17bcb84b7707be6fb7c495fb8463aecac5c4e7a0", "filename": "src/rt/libuv/test/test-timer.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "11816156fff58c41d88e07c13619927a375ccd00", "filename": "src/rt/libuv/test/test-tty.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "2d172c0640ce53a24b5b7486c94ce52cbf7f4ff3", "filename": "src/rt/libuv/test/test-udp-dgram-too-big.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "6ff36b32b017b9f5ffd5c2a7041318046e1e1254", "filename": "src/rt/libuv/test/test-udp-ipv6.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "ab47e91c21c30461f650af46e723ba0da79b2dac", "filename": "src/rt/libuv/test/test-udp-send-and-recv.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "e32dddd3b5d38bf14ccc9496aaef8d02f4275a44", "filename": "src/rt/libuv/uv.gyp", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fuv.gyp", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fuv.gyp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv.gyp?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "bccefff9dcdec915630c53f0499821a2d673bb0e", "filename": "src/rt/libuv/vcbuild.bat", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fvcbuild.bat", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Flibuv%2Fvcbuild.bat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fvcbuild.bat?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}, {"sha": "39f99b9b190194ad347792a5023509647fc3b2ce", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5f066e06b991041f2c1d988f493d5b29f8e56b7e/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=5f066e06b991041f2c1d988f493d5b29f8e56b7e"}]}