{"sha": "9aad2d551e76d80783e812be70de5f49fb038b5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYWQyZDU1MWU3NmQ4MDc4M2U4MTJiZTcwZGU1ZjQ5ZmIwMzhiNWU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-08-25T22:32:46Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2016-12-30T14:17:26Z"}, "message": "Add a way to retrieve constant value in 128 bits\n\nFixes rebase fallout, makes code correct in presence of 128-bit constants.\n\nThis commit includes manual merge conflict resolution changes from a rebase by @est31.", "tree": {"sha": "5ed61b4debe55d287d4babb25be7ccf3eabc7722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ed61b4debe55d287d4babb25be7ccf3eabc7722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aad2d551e76d80783e812be70de5f49fb038b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aad2d551e76d80783e812be70de5f49fb038b5e", "html_url": "https://github.com/rust-lang/rust/commit/9aad2d551e76d80783e812be70de5f49fb038b5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aad2d551e76d80783e812be70de5f49fb038b5e/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "508fef5dffa5e0fad578f6faa13cfce86ead9463", "url": "https://api.github.com/repos/rust-lang/rust/commits/508fef5dffa5e0fad578f6faa13cfce86ead9463", "html_url": "https://github.com/rust-lang/rust/commit/508fef5dffa5e0fad578f6faa13cfce86ead9463"}], "stats": {"total": 171, "additions": 101, "deletions": 70}, "files": [{"sha": "59eb4b70aa8ff4eba799748a6af0718cae9c57b7", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -58,7 +58,8 @@ mod ubounds {\n     bounds!{u128: 0,\n         i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n         u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n-        isize IMIN IMAX usize UMIN UMAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n     }\n }\n \n@@ -78,11 +79,42 @@ mod ibounds {\n     bounds!{i128,\n         i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n         u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n-        isize IMIN IMAX usize UMIN UMAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n     }\n }\n \n impl ConstInt {\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n+        match ty {\n+            UintTy::U8 if val <= ubounds::U8MAX => Some(U8(val as u8)),\n+            UintTy::U16 if val <= ubounds::U16MAX => Some(U16(val as u16)),\n+            UintTy::U32 if val <= ubounds::U32MAX => Some(U32(val as u32)),\n+            UintTy::U64 if val <= ubounds::U64MAX => Some(U64(val as u64)),\n+            UintTy::Us if val <= ubounds::U64MAX => ConstUsize::new(val as u64, usize_ty).ok()\n+                .map(Usize),\n+            UintTy::U128 => Some(U128(val)),\n+            _ => None\n+        }\n+    }\n+\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n+        match ty {\n+            IntTy::I8 if val <= ibounds::I8MAX => Some(I8(val as i8)),\n+            IntTy::I16 if val <= ibounds::I16MAX => Some(I16(val as i16)),\n+            IntTy::I32 if val <= ibounds::I32MAX => Some(I32(val as i32)),\n+            IntTy::I64 if val <= ibounds::I64MAX => Some(I64(val as i64)),\n+            IntTy::Is if val <= ibounds::I64MAX => ConstIsize::new(val as i64, isize_ty).ok()\n+                .map(Isize),\n+            IntTy::I128 => Some(I128(val)),\n+            _ => None\n+        }\n+    }\n+\n     /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n     /// the other value. If both values have no type, don't do anything\n     pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {"}, {"sha": "fb188252075e6d99bb5ce4a0c68ef5873e663df2", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -582,6 +582,8 @@ extern \"C\" {\n     pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n+                                  high: *mut u64, low: *mut u64) -> bool;\n \n \n     // Operations on composite constants"}, {"sha": "f4c7d2973bf66145f0dcfe1f424b6fa84c94a323", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -592,20 +592,34 @@ fn is_const_integral(v: ValueRef) -> bool {\n     }\n }\n \n-pub fn const_to_opt_int(v: ValueRef) -> Option<i64> {\n+\n+#[cfg(stage0)]\n+pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetSExtValue(v))\n+            if !sign_ext {\n+                Some(llvm::LLVMConstIntGetZExtValue(v))\n+            } else {\n+                Some(llvm::LLVMConstIntGetSExtValue(v) as u64)\n+            }\n         } else {\n             None\n         }\n     }\n }\n \n-pub fn const_to_opt_uint(v: ValueRef) -> Option<u64> {\n+#[cfg(not(stage0))]\n+pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetZExtValue(v))\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                       &mut hi as *mut u64, &mut lo as *mut u64);\n+            if success {\n+                Some(((hi as u128) << 64) | (lo as u128))\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }"}, {"sha": "2e2644d91bb6c3584aadeec23a53e7b52cbd6b53", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -24,7 +24,6 @@ use monomorphize::{Instance};\n use type_::Type;\n use type_of;\n use rustc::ty;\n-use rustc_i128::{i128, u128};\n \n use rustc::hir;\n "}, {"sha": "62141369caec1cf11a3644e8fef37e6d02ccbc06", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -346,11 +346,12 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_uint(sized_align), const_to_opt_uint(unsized_align)) {\n+            let align = match (const_to_opt_u128(sized_align, false),\n+                               const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n+                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,"}, {"sha": "c4129b346e409b4dca0d2a4762ae2035a2e5ca25", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -32,6 +32,8 @@ use syntax::symbol::Symbol;\n use rustc::session::Session;\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n use std::cmp::Ordering;\n use std::iter;\n \n@@ -1019,15 +1021,15 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  in_elem, in_ty,\n                  ret_ty, ret_ty.simd_type(tcx));\n \n-        let total_len = in_len as u64 * 2;\n+        let total_len = in_len as u128 * 2;\n \n         let vector = llargs[2];\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n                 let val = const_get_elt(vector, &[i as libc::c_uint]);\n-                match const_to_opt_uint(val) {\n+                match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None"}, {"sha": "ecedcd68382d167ad44ef8d6d852472ab8cb112b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond = self.trans_operand(&bcx, cond).immediate();\n-                let mut const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n+                let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from\n@@ -322,14 +322,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let len = self.trans_operand(&mut bcx, len).immediate();\n                         let index = self.trans_operand(&mut bcx, index).immediate();\n \n-                        let const_err = common::const_to_opt_uint(len).and_then(|len| {\n-                            common::const_to_opt_uint(index).map(|index| {\n-                                ErrKind::IndexOutOfBounds {\n-                                    len: len,\n-                                    index: index\n-                                }\n-                            })\n-                        });\n+                        let const_err = common::const_to_opt_u128(len, false)\n+                            .and_then(|len| common::const_to_opt_u128(index, false)\n+                                .map(|index| ErrKind::IndexOutOfBounds {\n+                                    len: len as u64,\n+                                    index: index as u64\n+                                }));\n \n                         let file_line = C_struct(bcx.ccx, &[filename, line], false);\n                         let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));"}, {"sha": "04f1e4fb8640edd34fa349cbc72358201e19fa0e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -13,7 +13,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::{ErrKind, ConstEvalErr, report_const_eval_err};\n use rustc_const_math::ConstInt::*;\n use rustc_const_math::ConstFloat::*;\n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstMathErr};\n+use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n@@ -27,23 +27,23 @@ use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_int, const_to_opt_uint};\n+use common::{const_to_opt_u128};\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n use value::Value;\n \n-use syntax::ast;\n use syntax_pos::Span;\n-use rustc_i128::u128;\n \n use std::fmt;\n use std::ptr;\n \n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n+use rustc_i128::{u128, i128};\n+\n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n /// e.g. each enum variant would have its own LLVM struct type.\n@@ -431,15 +431,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::ProjectionElem::Index(ref index) => {\n                         let llindex = self.const_operand(index, span)?.llval;\n \n-                        let iv = if let Some(iv) = common::const_to_opt_uint(llindex) {\n+                        let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n                             iv\n                         } else {\n                             span_bug!(span, \"index is not an integer-constant expression\")\n                         };\n \n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n-                        let llelem = if iv < len {\n+                        let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, &[iv as u32])\n                         } else {\n                             C_undef(type_of::type_of(self.ccx, projected_ty))\n@@ -797,49 +797,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n-            ast::IntTy::I8 => {\n-                assert_eq!(input as i8 as i64, input);\n-                Some(ConstInt::I8(input as i8))\n-            },\n-            ast::IntTy::I16 => {\n-                assert_eq!(input as i16 as i64, input);\n-                Some(ConstInt::I16(input as i16))\n-            },\n-            ast::IntTy::I32 => {\n-                assert_eq!(input as i32 as i64, input);\n-                Some(ConstInt::I32(input as i32))\n-            },\n-            ast::IntTy::I64 => {\n-                Some(ConstInt::I64(input))\n-            },\n-            ast::IntTy::Is => {\n-                ConstIsize::new(input, tcx.sess.target.int_type)\n-                    .ok().map(ConstInt::Isize)\n-            },\n-        }),\n-        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n-            ast::UintTy::U8 => {\n-                assert_eq!(input as u8 as u64, input);\n-                Some(ConstInt::U8(input as u8))\n-            },\n-            ast::UintTy::U16 => {\n-                assert_eq!(input as u16 as u64, input);\n-                Some(ConstInt::U16(input as u16))\n-            },\n-            ast::UintTy::U32 => {\n-                assert_eq!(input as u32 as u64, input);\n-                Some(ConstInt::U32(input as u32))\n-            },\n-            ast::UintTy::U64 => {\n-                Some(ConstInt::U64(input))\n-            },\n-            ast::UintTy::Us => {\n-                ConstUsize::new(input, tcx.sess.target.uint_type)\n-                    .ok().map(ConstInt::Usize)\n-            },\n-        }),\n-        _ => None,\n+        ty::TyInt(int_type) => const_to_opt_u128(value, true)\n+            .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n+                                                   tcx.sess.target.int_type)),\n+        ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n+            .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n+                                                     tcx.sess.target.uint_type)),\n+        _ => None\n+\n     }\n }\n "}, {"sha": "1c8c63a14459da8abd41541ba6f8af47684e8de5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -1653,6 +1653,7 @@ impl From<ast::IntTy> for PrimitiveType {\n             ast::IntTy::I16 => PrimitiveType::I16,\n             ast::IntTy::I32 => PrimitiveType::I32,\n             ast::IntTy::I64 => PrimitiveType::I64,\n+            ast::IntTy::I128 => PrimitiveType::I128,\n         }\n     }\n }\n@@ -1665,6 +1666,7 @@ impl From<ast::UintTy> for PrimitiveType {\n             ast::UintTy::U16 => PrimitiveType::U16,\n             ast::UintTy::U32 => PrimitiveType::U32,\n             ast::UintTy::U64 => PrimitiveType::U64,\n+            ast::UintTy::U128 => PrimitiveType::U128,\n         }\n     }\n }\n@@ -2489,7 +2491,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n-    use PrimitiveType::*;\n+    use self::PrimitiveType::*;\n     let tcx = cx.tcx;\n \n     for item in items {"}, {"sha": "81093249318001f8504bcdb122b4a57422ed1c98", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9aad2d551e76d80783e812be70de5f49fb038b5e/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=9aad2d551e76d80783e812be70de5f49fb038b5e", "patch": "@@ -1456,6 +1456,22 @@ extern \"C\" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {\n \n extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage) {\n     LLVMSetLinkage(V, from_rust(RustLinkage));\n+\n+// Returns true if both high and low were successfully set. Fails in case constant wasn\u2019t any of\n+// the common sizes (1, 8, 16, 32, 64, 128 bits)\n+extern \"C\" bool LLVMRustConstInt128Get(LLVMValueRef CV, bool sext, uint64_t *high, uint64_t *low)\n+{\n+    auto C = unwrap<llvm::ConstantInt>(CV);\n+    if (C->getBitWidth() > 128) { return false; }\n+    APInt AP;\n+    if (sext) {\n+        AP = C->getValue().sextOrSelf(128);\n+    } else {\n+        AP = C->getValue().zextOrSelf(128);\n+    }\n+    *low = AP.getLoBits(64).getZExtValue();\n+    *high = AP.getHiBits(64).getZExtValue();\n+    return true;\n }\n \n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {"}]}