{"sha": "f440999bb2a894eee5f8a9d299ddb849420bcf63", "node_id": "C_kwDOAAsO6NoAKGY0NDA5OTliYjJhODk0ZWVlNWY4YTlkMjk5ZGRiODQ5NDIwYmNmNjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-06T11:30:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-06T11:30:05Z"}, "message": "Rollup merge of #111167 - cuviper:type-decl-disubprogram, r=michaelwoerister\n\ndebuginfo: split method declaration and definition\n\nWhen we're adding a method to a type DIE, we only want a DW_AT_declaration\nthere, because LLVM LTO can't unify type definitions when a child DIE is a\nfull subprogram definition. Now the subprogram definition gets added at the\nCU level with a specification link back to the abstract declaration.\n\nBoth GCC and Clang write debuginfo this way for C++ class methods.\n\nFixes #109730.\nFixes #109934.", "tree": {"sha": "1e7399dfe471a3cb66c4597e1950876a7ee6ba1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e7399dfe471a3cb66c4597e1950876a7ee6ba1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f440999bb2a894eee5f8a9d299ddb849420bcf63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVjo9CRBK7hj4Ov3rIwAAi8YIAFm84c26Ab++/JS8/dKByZlm\noJzPbSWif92wEahTbP+bA2pmgcnek+WretXTREQS72gBdhvIMfG+P06LO0kSNk/w\nuWurlYgilBpj8h/3sKoFqEvrU34r0fXuLIs3D4WUZZVDgMb5LCrgbZArP3AwN1/X\nLdRiloeHxuIC6NeVv0DYO65SXTS19EzuCq/XGtCx2r1aLuqF39rK2wAQ6tfp3CEf\naWFe4XhShBcPMR+nUjm3ksxrqsE73167f6RPd7qFSquEuNmsaxgfpJKRzzD6u8Vi\nGFxM4A1Q3P6FHlCcsyyH/VW7XpOXU+/boUIcoN0LZBpUqiguGxk6Q/P2/LJU5wQ=\n=7F7m\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e7399dfe471a3cb66c4597e1950876a7ee6ba1b\nparent 8ec84dd523df611060c585b5d1b538fd6fee13e9\nparent 10b69dde3fd15334ea2382d2dc9e9a261de1afaf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683372605 +0200\ncommitter GitHub <noreply@github.com> 1683372605 +0200\n\nRollup merge of #111167 - cuviper:type-decl-disubprogram, r=michaelwoerister\n\ndebuginfo: split method declaration and definition\n\nWhen we're adding a method to a type DIE, we only want a DW_AT_declaration\nthere, because LLVM LTO can't unify type definitions when a child DIE is a\nfull subprogram definition. Now the subprogram definition gets added at the\nCU level with a specification link back to the abstract declaration.\n\nBoth GCC and Clang write debuginfo this way for C++ class methods.\n\nFixes #109730.\nFixes #109934.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f440999bb2a894eee5f8a9d299ddb849420bcf63", "html_url": "https://github.com/rust-lang/rust/commit/f440999bb2a894eee5f8a9d299ddb849420bcf63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f440999bb2a894eee5f8a9d299ddb849420bcf63/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec84dd523df611060c585b5d1b538fd6fee13e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec84dd523df611060c585b5d1b538fd6fee13e9", "html_url": "https://github.com/rust-lang/rust/commit/8ec84dd523df611060c585b5d1b538fd6fee13e9"}, {"sha": "10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "html_url": "https://github.com/rust-lang/rust/commit/10b69dde3fd15334ea2382d2dc9e9a261de1afaf"}], "stats": {"total": 143, "additions": 109, "deletions": 34}, "files": [{"sha": "b138b0c0e70a17205b7f4c5b3628370f0b6065b1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=f440999bb2a894eee5f8a9d299ddb849420bcf63", "patch": "@@ -322,7 +322,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n \n         let def_id = instance.def_id();\n-        let containing_scope = get_containing_scope(self, instance);\n+        let (containing_scope, is_method) = get_containing_scope(self, instance);\n         let span = tcx.def_span(def_id);\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n@@ -378,8 +378,29 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        unsafe {\n-            return llvm::LLVMRustDIBuilderCreateFunction(\n+        // When we're adding a method to a type DIE, we only want a DW_AT_declaration there, because\n+        // LLVM LTO can't unify type definitions when a child DIE is a full subprogram definition.\n+        // When we use this `decl` below, the subprogram definition gets created at the CU level\n+        // with a DW_AT_specification pointing back to the type's declaration.\n+        let decl = is_method.then(|| unsafe {\n+            llvm::LLVMRustDIBuilderCreateMethod(\n+                DIB(self),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n+                file_metadata,\n+                loc.line,\n+                function_type_metadata,\n+                flags,\n+                spflags & !DISPFlags::SPFlagDefinition,\n+                template_parameters,\n+            )\n+        });\n+\n+        return unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n                 name.as_ptr().cast(),\n@@ -394,9 +415,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 spflags,\n                 maybe_definition_llfn,\n                 template_parameters,\n-                None,\n-            );\n-        }\n+                decl,\n+            )\n+        };\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -493,14 +514,16 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             names\n         }\n \n+        /// Returns a scope, plus `true` if that's a type scope for \"class\" methods,\n+        /// otherwise `false` for plain namespace scopes.\n         fn get_containing_scope<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n             instance: Instance<'tcx>,\n-        ) -> &'ll DIScope {\n+        ) -> (&'ll DIScope, bool) {\n             // First, let's see if this is a method within an inherent impl. Because\n             // if yes, we want to make the result subroutine DIE a child of the\n             // subroutine's self-type.\n-            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+            if let Some(impl_def_id) = cx.tcx.impl_of_method(instance.def_id()) {\n                 // If the method does *not* belong to a trait, proceed\n                 if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n@@ -511,39 +534,33 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.kind() {\n-                        ty::Adt(def, ..) if !def.is_box() => {\n-                            // Again, only create type information if full debuginfo is enabled\n-                            if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.has_param()\n-                            {\n-                                Some(type_di_node(cx, impl_self_ty))\n-                            } else {\n-                                Some(namespace::item_namespace(cx, def.did()))\n-                            }\n+                    if let ty::Adt(def, ..) = impl_self_ty.kind() && !def.is_box() {\n+                        // Again, only create type information if full debuginfo is enabled\n+                        if cx.sess().opts.debuginfo == DebugInfo::Full && !impl_self_ty.has_param()\n+                        {\n+                            return (type_di_node(cx, impl_self_ty), true);\n+                        } else {\n+                            return (namespace::item_namespace(cx, def.did()), false);\n                         }\n-                        _ => None,\n                     }\n                 } else {\n                     // For trait method impls we still use the \"parallel namespace\"\n                     // strategy\n-                    None\n                 }\n-            });\n+            }\n \n-            self_type.unwrap_or_else(|| {\n-                namespace::item_namespace(\n-                    cx,\n-                    DefId {\n-                        krate: instance.def_id().krate,\n-                        index: cx\n-                            .tcx\n-                            .def_key(instance.def_id())\n-                            .parent\n-                            .expect(\"get_containing_scope: missing parent?\"),\n-                    },\n-                )\n-            })\n+            let scope = namespace::item_namespace(\n+                cx,\n+                DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx\n+                        .tcx\n+                        .def_key(instance.def_id())\n+                        .parent\n+                        .expect(\"get_containing_scope: missing parent?\"),\n+                },\n+            );\n+            (scope, false)\n         }\n     }\n "}, {"sha": "61365e6dc4b0e93f9fae086bc674dbfeb482de06", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=f440999bb2a894eee5f8a9d299ddb849420bcf63", "patch": "@@ -1987,6 +1987,21 @@ extern \"C\" {\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n \n+    pub fn LLVMRustDIBuilderCreateMethod<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        SPFlags: DISPFlags,\n+        TParam: &'a DIArray,\n+    ) -> &'a DISubprogram;\n+\n     pub fn LLVMRustDIBuilderCreateBasicType<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,"}, {"sha": "49acd71b3e106a9d8d4604def4782cdba908dd06", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f440999bb2a894eee5f8a9d299ddb849420bcf63/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=f440999bb2a894eee5f8a9d299ddb849420bcf63", "patch": "@@ -831,6 +831,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   return wrap(Sub);\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMethod(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n+    LLVMMetadataRef Ty, LLVMRustDIFlags Flags,\n+    LLVMRustDISPFlags SPFlags, LLVMMetadataRef TParam) {\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram::DISPFlags llvmSPFlags = fromRust(SPFlags);\n+  DINode::DIFlags llvmFlags = fromRust(Flags);\n+  DISubprogram *Sub = Builder->createMethod(\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty),\n+      0, 0, nullptr, // VTable params aren't used\n+      llvmFlags, llvmSPFlags, TParams);\n+  return wrap(Sub);\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     uint64_t SizeInBits, unsigned Encoding) {"}, {"sha": "3b7a99d3dbc62c8576fa582194855246a763952f", "filename": "tests/run-make/issue-109934-lto-debuginfo/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f440999bb2a894eee5f8a9d299ddb849420bcf63/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f440999bb2a894eee5f8a9d299ddb849420bcf63/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile?ref=f440999bb2a894eee5f8a9d299ddb849420bcf63", "patch": "@@ -0,0 +1,12 @@\n+# ignore-cross-compile\n+include ../tools.mk\n+\n+# With the upgrade to LLVM 16, this was getting:\n+#\n+#   error: Cannot represent a difference across sections\n+#\n+# The error stemmed from DI function definitions under type scopes, fixed by\n+# only declaring in type scope and defining the subprogram elsewhere.\n+\n+all:\n+\t$(RUSTC) lib.rs --test -C lto=fat -C debuginfo=2 -C incremental=$(TMPDIR)/inc-fat"}, {"sha": "c405928bd18241f61e0c72c7d8e75409c2fc9be4", "filename": "tests/run-make/issue-109934-lto-debuginfo/lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f440999bb2a894eee5f8a9d299ddb849420bcf63/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f440999bb2a894eee5f8a9d299ddb849420bcf63/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs?ref=f440999bb2a894eee5f8a9d299ddb849420bcf63", "patch": "@@ -0,0 +1,9 @@\n+extern crate alloc;\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn something_alloc() {\n+        assert_eq!(Vec::<u32>::new(), Vec::<u32>::new());\n+    }\n+}"}]}