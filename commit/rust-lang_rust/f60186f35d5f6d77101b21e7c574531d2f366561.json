{"sha": "f60186f35d5f6d77101b21e7c574531d2f366561", "node_id": "C_kwDOAAsO6NoAKGY2MDE4NmYzNWQ1ZjZkNzcxMDFiMjFlN2M1NzQ1MzFkMmYzNjY1NjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T09:05:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T09:05:50Z"}, "message": "Auto merge of #9800 - Alexendoo:def_path_res_multiple, r=dswij\n\nReturn multiple resolutions from `def_path_res`\n\nChanges `def_path_res` to return all the resolutions matching the path rather than the first one (with a namespace hint that covered some cases).  This would fix any issues that come up with multiple versions of the same crate being present as they all have the same crate name\n\nIt also adds resolution of `impl _ {}` items for local items, and removes struct field resolution as it didn't seem to be used anywhere\n\nI tested it on a local crate and it worked for the multiple crate issue, but I couldn't come up with a test that worked well with `// aux-build`, maybe `// aux-crate` after https://github.com/rust-lang/rust/pull/103266 could work but I'm not sure on that either\n\nchangelog: [`disallowed_methods`], [`disallowed_types`], [`disallowed_macros`]: fix path resolution with multiple versions of the same crate\nchangelog: [`disallowed_methods`]: Resolve methods in `impl`s in the current crate", "tree": {"sha": "cb1da7fe787c68779fe6bff68793145233bc9695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1da7fe787c68779fe6bff68793145233bc9695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f60186f35d5f6d77101b21e7c574531d2f366561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f60186f35d5f6d77101b21e7c574531d2f366561", "html_url": "https://github.com/rust-lang/rust/commit/f60186f35d5f6d77101b21e7c574531d2f366561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f60186f35d5f6d77101b21e7c574531d2f366561/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e144c7d1aefd0b789adf1c98b96068cebdb11405", "url": "https://api.github.com/repos/rust-lang/rust/commits/e144c7d1aefd0b789adf1c98b96068cebdb11405", "html_url": "https://github.com/rust-lang/rust/commit/e144c7d1aefd0b789adf1c98b96068cebdb11405"}, {"sha": "1e1ac2b4985a1236003ef23b92e3edf3af8f5dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1ac2b4985a1236003ef23b92e3edf3af8f5dfe", "html_url": "https://github.com/rust-lang/rust/commit/1e1ac2b4985a1236003ef23b92e3edf3af8f5dfe"}], "stats": {"total": 517, "additions": 281, "deletions": 236}, "files": [{"sha": "d40a385435afb59e695d2d101633f4df737fbad0", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -189,7 +188,7 @@ impl LateLintPass<'_> for AwaitHolding {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_invalid_types {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.def_ids.insert(id, conf.clone());\n             }\n         }"}, {"sha": "68122b4cef577fede678085f08f58baa9181cbe1", "filename": "clippy_lints/src/disallowed_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_macros.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::macro_backtrace;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefIdMap;\n use rustc_hir::{Expr, ForeignItem, HirId, ImplItem, Item, Pat, Path, Stmt, TraitItem, Ty};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -89,7 +88,7 @@ impl DisallowedMacros {\n                     &format!(\"use of a disallowed macro `{}`\", conf.path()),\n                     |diag| {\n                         if let Some(reason) = conf.reason() {\n-                            diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                            diag.note(reason);\n                         }\n                     },\n                 );\n@@ -104,7 +103,7 @@ impl LateLintPass<'_> for DisallowedMacros {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::MacroNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }"}, {"sha": "ca8671c8f1aa0ea94dcc678433d9b08b3bf2d83d", "filename": "clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{fn_def_id, get_parent_expr, path_def_id};\n \n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefIdMap;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -79,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::ValueNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }\n@@ -104,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n         let msg = format!(\"use of a disallowed method `{}`\", conf.path());\n         span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n             if let Some(reason) = conf.reason() {\n-                diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                diag.note(reason);\n             }\n         });\n     }"}, {"sha": "aee3d8c4f08527234f622a6ea81dc6f551a9920f", "filename": "clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -53,8 +53,8 @@ declare_clippy_lint! {\n #[derive(Clone, Debug)]\n pub struct DisallowedTypes {\n     conf_disallowed: Vec<conf::DisallowedPath>,\n-    def_ids: FxHashMap<DefId, Option<String>>,\n-    prim_tys: FxHashMap<PrimTy, Option<String>>,\n+    def_ids: FxHashMap<DefId, usize>,\n+    prim_tys: FxHashMap<PrimTy, usize>,\n }\n \n impl DisallowedTypes {\n@@ -69,13 +69,13 @@ impl DisallowedTypes {\n     fn check_res_emit(&self, cx: &LateContext<'_>, res: &Res, span: Span) {\n         match res {\n             Res::Def(_, did) => {\n-                if let Some(reason) = self.def_ids.get(did) {\n-                    emit(cx, &cx.tcx.def_path_str(*did), span, reason.as_deref());\n+                if let Some(&index) = self.def_ids.get(did) {\n+                    emit(cx, &cx.tcx.def_path_str(*did), span, &self.conf_disallowed[index]);\n                 }\n             },\n             Res::PrimTy(prim) => {\n-                if let Some(reason) = self.prim_tys.get(prim) {\n-                    emit(cx, prim.name_str(), span, reason.as_deref());\n+                if let Some(&index) = self.prim_tys.get(prim) {\n+                    emit(cx, prim.name_str(), span, &self.conf_disallowed[index]);\n                 }\n             },\n             _ => {},\n@@ -87,17 +87,19 @@ impl_lint_pass!(DisallowedTypes => [DISALLOWED_TYPES]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        for conf in &self.conf_disallowed {\n+        for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            let reason = conf.reason().map(|reason| format!(\"{reason} (from clippy.toml)\"));\n-            match clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n-                Res::Def(_, id) => {\n-                    self.def_ids.insert(id, reason);\n-                },\n-                Res::PrimTy(ty) => {\n-                    self.prim_tys.insert(ty, reason);\n-                },\n-                _ => {},\n+\n+            for res in clippy_utils::def_path_res(cx, &segs) {\n+                match res {\n+                    Res::Def(_, id) => {\n+                        self.def_ids.insert(id, index);\n+                    },\n+                    Res::PrimTy(ty) => {\n+                        self.prim_tys.insert(ty, index);\n+                    },\n+                    _ => {},\n+                }\n             }\n         }\n     }\n@@ -119,14 +121,14 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     }\n }\n \n-fn emit(cx: &LateContext<'_>, name: &str, span: Span, reason: Option<&str>) {\n+fn emit(cx: &LateContext<'_>, name: &str, span: Span, conf: &conf::DisallowedPath) {\n     span_lint_and_then(\n         cx,\n         DISALLOWED_TYPES,\n         span,\n         &format!(\"`{name}` is not allowed according to config\"),\n         |diag| {\n-            if let Some(reason) = reason {\n+            if let Some(reason) = conf.reason() {\n                 diag.note(reason);\n             }\n         },"}, {"sha": "4712846939e6a0fcaae2a242895f7d9709988314", "filename": "clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -59,7 +59,7 @@ impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n             let segs = path.split(\"::\").collect::<Vec<_>>();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, None) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }"}, {"sha": "f0f152904f7e1dc3a75c217ad4a2f11fee59aed1", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{def_path_res, trait_ref_of_method};\n+use clippy_utils::{def_path_def_ids, trait_ref_of_method};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def::Namespace;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n@@ -94,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n         let mut path = Vec::new();\n         for ty in &self.ignore_interior_mutability {\n             path.extend(ty.split(\"::\"));\n-            if let Some(id) = def_path_res(cx, &path[..], Some(Namespace::TypeNS)).opt_def_id() {\n+            for id in def_path_def_ids(cx, &path[..]) {\n                 self.ignore_mut_def_ids.insert(id);\n             }\n             path.clear();"}, {"sha": "b37d4239477eaa1c2ed866cd3112173f71f6f2b7", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -53,11 +53,11 @@ impl DisallowedPath {\n         path\n     }\n \n-    pub fn reason(&self) -> Option<&str> {\n+    pub fn reason(&self) -> Option<String> {\n         match self {\n             Self::WithReason {\n                 reason: Some(reason), ..\n-            } => Some(reason),\n+            } => Some(format!(\"{reason} (from clippy.toml)\")),\n             _ => None,\n         }\n     }"}, {"sha": "4b33d492a0e478f7ab5c0003f45ede45a917887d", "filename": "clippy_lints/src/utils/internal_lints/interning_defined_symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{def_path_res, is_expn_of, match_def_path, paths};\n+use clippy_utils::{def_path_def_ids, is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n+            for def_id in def_path_def_ids(cx, module) {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "4e2e1cc8d7762ccf8929e857f66f727bb31f68f5", "filename": "clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::def_path_res;\n use clippy_utils::diagnostics::span_lint;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::DefKind;\n use rustc_hir::Item;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path, None) != Res::Err {\n+    if !def_path_res(cx, path).is_empty() {\n         return true;\n     }\n "}, {"sha": "0d91398b74f0b3123a4254c4c310ac37c84bdd62", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,19 +1,19 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n+use clippy_utils::{def_path_def_ids, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n-use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use std::str;\n@@ -110,7 +110,7 @@ impl UnnecessaryDefPath {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, item_arg);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = inherent_def_path_res(cx, &segments[..]);\n+            if let Some(def_id) = def_path_def_ids(cx, &segments[..]).next();\n             then {\n                 // Check if the target item is a diagnostic item or LangItem.\n                 #[rustfmt::skip]\n@@ -209,7 +209,7 @@ impl UnnecessaryDefPath {\n     fn check_array(&mut self, cx: &LateContext<'_>, elements: &[Expr<'_>], span: Span) {\n         let Some(path) = path_from_array(elements) else { return };\n \n-        if let Some(def_id) = inherent_def_path_res(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n+        for def_id in def_path_def_ids(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n             self.array_def_ids.insert((def_id, span));\n         }\n     }\n@@ -293,41 +293,11 @@ fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n         .collect()\n }\n \n-// def_path_res will match field names before anything else, but for this we want to match\n-// inherent functions first.\n-fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefId> {\n-    def_path_res(cx, segments, None).opt_def_id().map(|def_id| {\n-        if cx.tcx.def_kind(def_id) == DefKind::Field {\n-            let method_name = *segments.last().unwrap();\n-            cx.tcx\n-                .def_key(def_id)\n-                .parent\n-                .and_then(|parent_idx| {\n-                    cx.tcx\n-                        .inherent_impls(DefId {\n-                            index: parent_idx,\n-                            krate: def_id.krate,\n-                        })\n-                        .iter()\n-                        .find_map(|impl_id| {\n-                            cx.tcx.associated_items(*impl_id).find_by_name_and_kind(\n-                                cx.tcx,\n-                                Ident::from_str(method_name),\n-                                AssocKind::Fn,\n-                                *impl_id,\n-                            )\n-                        })\n-                })\n-                .map_or(def_id, |item| item.def_id)\n-        } else {\n-            def_id\n-        }\n-    })\n-}\n-\n fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n     if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-        let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+        let lang_items = def_path_def_ids(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"])\n+            .next()\n+            .unwrap();\n         let item_name = cx\n             .tcx\n             .adt_def(lang_items)"}, {"sha": "670b740d8418c34fa6a8b0be59c0466404db8818", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 159, "deletions": 148, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -80,17 +80,16 @@ use rustc_ast::ast::{self, LitKind};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Constness, Destination, Expr,\n-    ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource,\n-    Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind,\n-    TraitRef, TyKind, UnOp,\n+    self as hir, def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Constness, Destination,\n+    Expr, ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, ImplItemRef, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, OwnerId, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n+    TraitItem, TraitItemKind, TraitItemRef, TraitRef, TyKind, UnOp,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -112,7 +111,7 @@ use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::source_map::SourceMap;\n use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n@@ -525,176 +524,188 @@ pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>\n     path_res(cx, maybe_path).opt_def_id()\n }\n \n-fn find_primitive<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n-    let single = |ty| tcx.incoherent_impls(ty).iter().copied();\n-    let empty = || [].iter().copied();\n-    match name {\n-        \"bool\" => single(BoolSimplifiedType),\n-        \"char\" => single(CharSimplifiedType),\n-        \"str\" => single(StrSimplifiedType),\n-        \"array\" => single(ArraySimplifiedType),\n-        \"slice\" => single(SliceSimplifiedType),\n+fn find_primitive_impls<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n+    let ty = match name {\n+        \"bool\" => BoolSimplifiedType,\n+        \"char\" => CharSimplifiedType,\n+        \"str\" => StrSimplifiedType,\n+        \"array\" => ArraySimplifiedType,\n+        \"slice\" => SliceSimplifiedType,\n         // FIXME: rustdoc documents these two using just `pointer`.\n         //\n         // Maybe this is something we should do here too.\n-        \"const_ptr\" => single(PtrSimplifiedType(Mutability::Not)),\n-        \"mut_ptr\" => single(PtrSimplifiedType(Mutability::Mut)),\n-        \"isize\" => single(IntSimplifiedType(IntTy::Isize)),\n-        \"i8\" => single(IntSimplifiedType(IntTy::I8)),\n-        \"i16\" => single(IntSimplifiedType(IntTy::I16)),\n-        \"i32\" => single(IntSimplifiedType(IntTy::I32)),\n-        \"i64\" => single(IntSimplifiedType(IntTy::I64)),\n-        \"i128\" => single(IntSimplifiedType(IntTy::I128)),\n-        \"usize\" => single(UintSimplifiedType(UintTy::Usize)),\n-        \"u8\" => single(UintSimplifiedType(UintTy::U8)),\n-        \"u16\" => single(UintSimplifiedType(UintTy::U16)),\n-        \"u32\" => single(UintSimplifiedType(UintTy::U32)),\n-        \"u64\" => single(UintSimplifiedType(UintTy::U64)),\n-        \"u128\" => single(UintSimplifiedType(UintTy::U128)),\n-        \"f32\" => single(FloatSimplifiedType(FloatTy::F32)),\n-        \"f64\" => single(FloatSimplifiedType(FloatTy::F64)),\n-        _ => empty(),\n-    }\n-}\n-\n-/// Resolves a def path like `std::vec::Vec`. `namespace_hint` can be supplied to disambiguate\n-/// between `std::vec` the module and `std::vec` the macro\n-///\n-/// This function is expensive and should be used sparingly.\n-pub fn def_path_res(cx: &LateContext<'_>, path: &[&str], namespace_hint: Option<Namespace>) -> Res {\n-    fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str, matches_ns: impl Fn(Res) -> bool) -> Option<Res> {\n-        match tcx.def_kind(def_id) {\n-            DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n-                .module_children(def_id)\n-                .iter()\n-                .find(|item| item.ident.name.as_str() == name && matches_ns(item.res.expect_non_local()))\n-                .map(|child| child.res.expect_non_local()),\n-            DefKind::Impl => tcx\n-                .associated_item_def_ids(def_id)\n-                .iter()\n-                .copied()\n-                .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n-                .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n-            DefKind::Struct | DefKind::Union => tcx\n-                .adt_def(def_id)\n-                .non_enum_variant()\n-                .fields\n-                .iter()\n-                .find(|f| f.name.as_str() == name)\n-                .map(|f| Res::Def(DefKind::Field, f.did)),\n-            _ => None,\n+        \"const_ptr\" => PtrSimplifiedType(Mutability::Not),\n+        \"mut_ptr\" => PtrSimplifiedType(Mutability::Mut),\n+        \"isize\" => IntSimplifiedType(IntTy::Isize),\n+        \"i8\" => IntSimplifiedType(IntTy::I8),\n+        \"i16\" => IntSimplifiedType(IntTy::I16),\n+        \"i32\" => IntSimplifiedType(IntTy::I32),\n+        \"i64\" => IntSimplifiedType(IntTy::I64),\n+        \"i128\" => IntSimplifiedType(IntTy::I128),\n+        \"usize\" => UintSimplifiedType(UintTy::Usize),\n+        \"u8\" => UintSimplifiedType(UintTy::U8),\n+        \"u16\" => UintSimplifiedType(UintTy::U16),\n+        \"u32\" => UintSimplifiedType(UintTy::U32),\n+        \"u64\" => UintSimplifiedType(UintTy::U64),\n+        \"u128\" => UintSimplifiedType(UintTy::U128),\n+        \"f32\" => FloatSimplifiedType(FloatTy::F32),\n+        \"f64\" => FloatSimplifiedType(FloatTy::F64),\n+        _ => return [].iter().copied(),\n+    };\n+\n+    tcx.incoherent_impls(ty).iter().copied()\n+}\n+\n+fn non_local_item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Vec<Res> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n+            .module_children(def_id)\n+            .iter()\n+            .filter(|item| item.ident.name == name)\n+            .map(|child| child.res.expect_non_local())\n+            .collect(),\n+        DefKind::Impl => tcx\n+            .associated_item_def_ids(def_id)\n+            .iter()\n+            .copied()\n+            .filter(|assoc_def_id| tcx.item_name(*assoc_def_id) == name)\n+            .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id))\n+            .collect(),\n+        _ => Vec::new(),\n+    }\n+}\n+\n+fn local_item_children_by_name(tcx: TyCtxt<'_>, local_id: LocalDefId, name: Symbol) -> Vec<Res> {\n+    let hir = tcx.hir();\n+\n+    let root_mod;\n+    let item_kind = match hir.find_by_def_id(local_id) {\n+        Some(Node::Crate(r#mod)) => {\n+            root_mod = ItemKind::Mod(r#mod);\n+            &root_mod\n+        },\n+        Some(Node::Item(item)) => &item.kind,\n+        _ => return Vec::new(),\n+    };\n+\n+    let res = |ident: Ident, owner_id: OwnerId| {\n+        if ident.name == name {\n+            let def_id = owner_id.to_def_id();\n+            Some(Res::Def(tcx.def_kind(def_id), def_id))\n+        } else {\n+            None\n         }\n+    };\n+\n+    match item_kind {\n+        ItemKind::Mod(r#mod) => r#mod\n+            .item_ids\n+            .iter()\n+            .filter_map(|&item_id| res(hir.item(item_id).ident, item_id.def_id))\n+            .collect(),\n+        ItemKind::Impl(r#impl) => r#impl\n+            .items\n+            .iter()\n+            .filter_map(|&ImplItemRef { ident, id, .. }| res(ident, id.def_id))\n+            .collect(),\n+        ItemKind::Trait(.., trait_item_refs) => trait_item_refs\n+            .iter()\n+            .filter_map(|&TraitItemRef { ident, id, .. }| res(ident, id.def_id))\n+            .collect(),\n+        _ => Vec::new(),\n+    }\n+}\n+\n+fn item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Vec<Res> {\n+    if let Some(local_id) = def_id.as_local() {\n+        local_item_children_by_name(tcx, local_id, name)\n+    } else {\n+        non_local_item_children_by_name(tcx, def_id, name)\n     }\n+}\n \n-    fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n+/// Resolves a def path like `std::vec::Vec`.\n+///\n+/// Can return multiple resolutions when there are multiple versions of the same crate, e.g.\n+/// `memchr::memchr` could return the functions from both memchr 1.0 and memchr 2.0.\n+///\n+/// Also returns multiple results when there are mulitple paths under the same name e.g. `std::vec`\n+/// would have both a [`DefKind::Mod`] and [`DefKind::Macro`].\n+///\n+/// This function is expensive and should be used sparingly.\n+pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Vec<Res> {\n+    fn find_crates(tcx: TyCtxt<'_>, name: Symbol) -> impl Iterator<Item = DefId> + '_ {\n         tcx.crates(())\n             .iter()\n             .copied()\n-            .find(|&num| tcx.crate_name(num).as_str() == name)\n+            .filter(move |&num| tcx.crate_name(num) == name)\n             .map(CrateNum::as_def_id)\n     }\n \n-    let (base, path) = match *path {\n+    let tcx = cx.tcx;\n+\n+    let (base, mut path) = match *path {\n         [primitive] => {\n-            return PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy);\n-        },\n-        [base, ref path @ ..] => {\n-            let crate_name = cx.sess().opts.crate_name.as_deref();\n-            if Some(base) == crate_name {\n-                return def_path_res_local(cx, path);\n-            }\n-            (base, path)\n+            return vec![PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy)];\n         },\n-        _ => return Res::Err,\n+        [base, ref path @ ..] => (base, path),\n+        _ => return Vec::new(),\n     };\n-    let tcx = cx.tcx;\n-    let starts = find_primitive(tcx, base)\n-        .chain(find_crate(tcx, base))\n+\n+    let base_sym = Symbol::intern(base);\n+\n+    let local_crate = if tcx.crate_name(LOCAL_CRATE) == base_sym {\n+        Some(LOCAL_CRATE.as_def_id())\n+    } else {\n+        None\n+    };\n+\n+    let starts = find_primitive_impls(tcx, base)\n+        .chain(find_crates(tcx, base_sym))\n+        .chain(local_crate)\n         .map(|id| Res::Def(tcx.def_kind(id), id));\n \n-    for first in starts {\n-        let last = path\n-            .iter()\n-            .copied()\n-            .enumerate()\n-            // for each segment, find the child item\n-            .try_fold(first, |res, (idx, segment)| {\n-                let matches_ns = |res: Res| {\n-                    // If at the last segment in the path, respect the namespace hint\n-                    if idx == path.len() - 1 {\n-                        match namespace_hint {\n-                            Some(ns) => res.matches_ns(ns),\n-                            None => true,\n-                        }\n-                    } else {\n-                        res.matches_ns(Namespace::TypeNS)\n-                    }\n-                };\n-\n-                let def_id = res.def_id();\n-                if let Some(item) = item_child_by_name(tcx, def_id, segment, matches_ns) {\n-                    Some(item)\n-                } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n-                    // it is not a child item so check inherent impl items\n-                    tcx.inherent_impls(def_id)\n-                        .iter()\n-                        .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment, matches_ns))\n-                } else {\n-                    None\n-                }\n-            });\n+    let mut resolutions: Vec<Res> = starts.collect();\n \n-        if let Some(last) = last {\n-            return last;\n-        }\n+    while let [segment, rest @ ..] = path {\n+        path = rest;\n+        let segment = Symbol::intern(segment);\n+\n+        resolutions = resolutions\n+            .into_iter()\n+            .filter_map(|res| res.opt_def_id())\n+            .flat_map(|def_id| {\n+                // When the current def_id is e.g. `struct S`, check the impl items in\n+                // `impl S { ... }`\n+                let inherent_impl_children = tcx\n+                    .inherent_impls(def_id)\n+                    .iter()\n+                    .flat_map(|&impl_def_id| item_children_by_name(tcx, impl_def_id, segment));\n+\n+                let direct_children = item_children_by_name(tcx, def_id, segment);\n+\n+                inherent_impl_children.chain(direct_children)\n+            })\n+            .collect();\n     }\n-    Res::Err\n+\n+    resolutions\n }\n \n-fn def_path_res_local(cx: &LateContext<'_>, mut path: &[&str]) -> Res {\n-    let map = cx.tcx.hir();\n-    let mut ids = map.root_module().item_ids;\n-    while let Some(&segment) = path.first() {\n-        let mut next_ids = None;\n-        for i in ids {\n-            if let Some(Node::Item(hir::Item {\n-                ident,\n-                kind,\n-                def_id: item_def_id,\n-                ..\n-            })) = map.find(i.hir_id())\n-            {\n-                if ident.name.as_str() == segment {\n-                    path = &path[1..];\n-                    if path.is_empty() {\n-                        let def_id = item_def_id.to_def_id();\n-                        return Res::Def(cx.tcx.def_kind(def_id), def_id);\n-                    }\n-                    if let ItemKind::Mod(m) = kind {\n-                        next_ids = Some(m.item_ids);\n-                    };\n-                    break;\n-                }\n-            }\n-        }\n-        if let Some(next_ids) = next_ids {\n-            ids = next_ids;\n-        } else {\n-            break;\n-        }\n-    }\n-    Res::Err\n+/// Resolves a def path like `std::vec::Vec` to its [`DefId`]s, see [`def_path_res`].\n+pub fn def_path_def_ids(cx: &LateContext<'_>, path: &[&str]) -> impl Iterator<Item = DefId> {\n+    def_path_res(cx, path).into_iter().filter_map(|res| res.opt_def_id())\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n ///\n /// This function is expensive and should be used sparingly.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match def_path_res(cx, path, Some(Namespace::TypeNS)) {\n+    def_path_res(cx, path).into_iter().find_map(|res| match res {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n         _ => None,\n-    }\n+    })\n }\n \n /// Gets the `hir::TraitRef` of the trait the given method is implemented for."}, {"sha": "825aa1487e7a3f682ed07a2f133ee2cf3f3a6df7", "filename": "tests/ui-toml/await_holding_invalid_type/await_holding_invalid_type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -4,7 +4,7 @@ error: `std::string::String` may not be held across an `await` point per `clippy\n LL |     let _x = String::from(\"hello\");\n    |         ^^\n    |\n-   = note: strings are bad\n+   = note: strings are bad (from clippy.toml)\n    = note: `-D clippy::await-holding-invalid-type` implied by `-D warnings`\n \n error: `std::net::Ipv4Addr` may not be held across an `await` point per `clippy.toml`\n@@ -19,7 +19,7 @@ error: `std::string::String` may not be held across an `await` point per `clippy\n LL |         let _x = String::from(\"hi!\");\n    |             ^^\n    |\n-   = note: strings are bad\n+   = note: strings are bad (from clippy.toml)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "41dbd5068479bc59f26985531e1212ebab9d1d5e", "filename": "tests/ui-toml/toml_disallowed_methods/clippy.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -8,4 +8,10 @@ disallowed-methods = [\n     { path = \"regex::Regex::is_match\", reason = \"no matching allowed\" },\n     # can use an inline table but omit reason\n     { path = \"regex::Regex::new\" },\n+    # local paths\n+    \"conf_disallowed_methods::local_fn\",\n+    \"conf_disallowed_methods::local_mod::f\",\n+    \"conf_disallowed_methods::Struct::method\",\n+    \"conf_disallowed_methods::Trait::provided_method\",\n+    \"conf_disallowed_methods::Trait::implemented_method\",\n ]"}, {"sha": "2f3160c833833314263414c602108d2ec5753b60", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: --crate-name conf_disallowed_methods\n+\n #![warn(clippy::disallowed_methods)]\n \n extern crate futures;\n@@ -6,6 +8,27 @@ extern crate regex;\n use futures::stream::{empty, select_all};\n use regex::Regex;\n \n+fn local_fn() {}\n+\n+struct Struct;\n+\n+impl Struct {\n+    fn method(&self) {}\n+}\n+\n+trait Trait {\n+    fn provided_method(&self) {}\n+    fn implemented_method(&self);\n+}\n+\n+impl Trait for Struct {\n+    fn implemented_method(&self) {}\n+}\n+\n+mod local_mod {\n+    pub fn f() {}\n+}\n+\n fn main() {\n     let re = Regex::new(r\"ab.*c\").unwrap();\n     re.is_match(\"abc\");\n@@ -26,4 +49,11 @@ fn main() {\n \n     // resolve ambiguity between `futures::stream::select_all` the module and the function\n     let same_name_as_module = select_all(vec![empty::<()>()]);\n+\n+    local_fn();\n+    local_mod::f();\n+    let s = Struct;\n+    s.method();\n+    s.provided_method();\n+    s.implemented_method();\n }"}, {"sha": "148d1cae51f1082cc89ab3c832e738cb5e5fc7d5", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.stderr", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f60186f35d5f6d77101b21e7c574531d2f366561/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr?ref=f60186f35d5f6d77101b21e7c574531d2f366561", "patch": "@@ -1,60 +1,90 @@\n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:10:14\n+  --> $DIR/conf_disallowed_methods.rs:33:14\n    |\n LL |     let re = Regex::new(r\"ab.*c\").unwrap();\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::disallowed-methods` implied by `-D warnings`\n \n error: use of a disallowed method `regex::Regex::is_match`\n-  --> $DIR/conf_disallowed_methods.rs:11:5\n+  --> $DIR/conf_disallowed_methods.rs:34:5\n    |\n LL |     re.is_match(\"abc\");\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: no matching allowed (from clippy.toml)\n \n error: use of a disallowed method `std::iter::Iterator::sum`\n-  --> $DIR/conf_disallowed_methods.rs:14:5\n+  --> $DIR/conf_disallowed_methods.rs:37:5\n    |\n LL |     a.iter().sum::<i32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `slice::sort_unstable`\n-  --> $DIR/conf_disallowed_methods.rs:16:5\n+  --> $DIR/conf_disallowed_methods.rs:39:5\n    |\n LL |     a.sort_unstable();\n    |     ^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `f32::clamp`\n-  --> $DIR/conf_disallowed_methods.rs:18:13\n+  --> $DIR/conf_disallowed_methods.rs:41:13\n    |\n LL |     let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:21:61\n+  --> $DIR/conf_disallowed_methods.rs:44:61\n    |\n LL |     let indirect: fn(&str) -> Result<Regex, regex::Error> = Regex::new;\n    |                                                             ^^^^^^^^^^\n \n error: use of a disallowed method `f32::clamp`\n-  --> $DIR/conf_disallowed_methods.rs:24:28\n+  --> $DIR/conf_disallowed_methods.rs:47:28\n    |\n LL |     let in_call = Box::new(f32::clamp);\n    |                            ^^^^^^^^^^\n \n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:25:53\n+  --> $DIR/conf_disallowed_methods.rs:48:53\n    |\n LL |     let in_method_call = [\"^\", \"$\"].into_iter().map(Regex::new);\n    |                                                     ^^^^^^^^^^\n \n error: use of a disallowed method `futures::stream::select_all`\n-  --> $DIR/conf_disallowed_methods.rs:28:31\n+  --> $DIR/conf_disallowed_methods.rs:51:31\n    |\n LL |     let same_name_as_module = select_all(vec![empty::<()>()]);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: use of a disallowed method `conf_disallowed_methods::local_fn`\n+  --> $DIR/conf_disallowed_methods.rs:53:5\n+   |\n+LL |     local_fn();\n+   |     ^^^^^^^^^^\n+\n+error: use of a disallowed method `conf_disallowed_methods::local_mod::f`\n+  --> $DIR/conf_disallowed_methods.rs:54:5\n+   |\n+LL |     local_mod::f();\n+   |     ^^^^^^^^^^^^^^\n+\n+error: use of a disallowed method `conf_disallowed_methods::Struct::method`\n+  --> $DIR/conf_disallowed_methods.rs:56:5\n+   |\n+LL |     s.method();\n+   |     ^^^^^^^^^^\n+\n+error: use of a disallowed method `conf_disallowed_methods::Trait::provided_method`\n+  --> $DIR/conf_disallowed_methods.rs:57:5\n+   |\n+LL |     s.provided_method();\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed method `conf_disallowed_methods::Trait::implemented_method`\n+  --> $DIR/conf_disallowed_methods.rs:58:5\n+   |\n+LL |     s.implemented_method();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 14 previous errors\n "}]}