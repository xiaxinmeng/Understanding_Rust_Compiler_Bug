{"sha": "85c25aed510ce599504b172f7c7bef280e91637b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YzI1YWVkNTEwY2U1OTk1MDRiMTcyZjdjN2JlZjI4MGU5MTYzN2I=", "commit": {"author": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-07-15T22:48:36Z"}, "committer": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-07-15T22:48:36Z"}, "message": "Move usercall_wait_timeout to abi::usercalls::wait_timeout", "tree": {"sha": "a80a4b1cd516f4516cb7ab85027db12ca8c4b6ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a80a4b1cd516f4516cb7ab85027db12ca8c4b6ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85c25aed510ce599504b172f7c7bef280e91637b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85c25aed510ce599504b172f7c7bef280e91637b", "html_url": "https://github.com/rust-lang/rust/commit/85c25aed510ce599504b172f7c7bef280e91637b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85c25aed510ce599504b172f7c7bef280e91637b/comments", "author": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1466598e19321bc6b97aef8271a317e78211d54d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1466598e19321bc6b97aef8271a317e78211d54d", "html_url": "https://github.com/rust-lang/rust/commit/1466598e19321bc6b97aef8271a317e78211d54d"}], "stats": {"total": 156, "additions": 74, "deletions": 82}, "files": [{"sha": "73f1b951e74304b0d406ba631e0f9c26896fac79", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=85c25aed510ce599504b172f7c7bef280e91637b", "patch": "@@ -1,8 +1,8 @@\n use crate::cmp;\n use crate::convert::TryFrom;\n-use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n+use crate::io::{Error as IoError, ErrorKind, IoSlice, IoSliceMut, Result as IoResult};\n use crate::sys::rand::rdrand64;\n-use crate::time::Duration;\n+use crate::time::{Duration, Instant};\n \n pub(crate) mod alloc;\n #[macro_use]\n@@ -169,6 +169,76 @@ pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n \n+/// This function makes an effort to wait for a non-spurious event at least as\n+/// long as `duration`. Note that in general there is no guarantee about accuracy\n+/// of time and timeouts in SGX model. The enclave runner serving usercalls may\n+/// lie about current time and/or ignore timeout values.\n+///\n+/// Once the event is observed, `should_wake_up` will be used to determine\n+/// whether or not the event was spurious.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)\n+where\n+    F: Fn() -> bool,\n+{\n+    // Calls the wait usercall and checks the result. Returns true if event was\n+    // returned, and false if WouldBlock/TimedOut was returned.\n+    // If duration is None, it will use WAIT_NO.\n+    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n+        let timeout = duration.map_or(raw::WAIT_NO, |duration| {\n+            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n+        });\n+        match wait(event_mask, timeout) {\n+            Ok(eventset) => {\n+                if event_mask == 0 {\n+                    rtabort!(\"expected wait() to return Err, found Ok.\");\n+                }\n+                rtassert!(eventset != 0 && eventset & !event_mask == 0);\n+                true\n+            }\n+            Err(e) => {\n+                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n+                false\n+            }\n+        }\n+    }\n+\n+    match wait_checked(event_mask, Some(duration)) {\n+        false => return,                    // timed out\n+        true if should_wake_up() => return, // woken up\n+        true => {}                          // spurious event\n+    }\n+\n+    // Drain all cached events.\n+    // Note that `event_mask != 0` is implied if we get here.\n+    loop {\n+        match wait_checked(event_mask, None) {\n+            false => break,                     // no more cached events\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+    }\n+\n+    // Continue waiting, but take note of time spent waiting so we don't wait\n+    // forever. We intentionally don't call `Instant::now()` before this point\n+    // to avoid the cost of the `insecure_time` usercall in case there are no\n+    // spurious wakeups.\n+\n+    let start = Instant::now();\n+    let mut remaining = duration;\n+    loop {\n+        match wait_checked(event_mask, Some(remaining)) {\n+            false => return,                    // timed out\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+        remaining = match duration.checked_sub(start.elapsed()) {\n+            Some(remaining) => remaining,\n+            None => break,\n+        }\n+    }\n+}\n+\n /// Usercall `send`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {"}, {"sha": "7a3a3eb2049b32a26a3caca5dbfeaa977aa7c817", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=85c25aed510ce599504b172f7c7bef280e91637b", "patch": "@@ -110,82 +110,6 @@ pub fn decode_error_kind(code: i32) -> ErrorKind {\n     }\n }\n \n-// This function makes an effort to wait for a non-spurious event at least as\n-// long as `duration`. Note that in general there is no guarantee about accuracy\n-// of time and timeouts in SGX model. The enclave runner serving usercalls may\n-// lie about current time and/or ignore timeout values.\n-//\n-// Once the event is observed, `should_wake_up` will be used to determine\n-// whether or not the event was spurious.\n-pub fn usercall_wait_timeout<F>(event_mask: u64, duration: crate::time::Duration, should_wake_up: F)\n-where\n-    F: Fn() -> bool,\n-{\n-    use self::abi::usercalls;\n-    use crate::cmp;\n-    use crate::io::ErrorKind;\n-    use crate::time::{Duration, Instant};\n-\n-    // Calls the wait usercall and checks the result. Returns true if event was\n-    // returned, and false if WouldBlock/TimedOut was returned.\n-    // If duration is None, it will use WAIT_NO.\n-    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n-        let timeout = duration.map_or(usercalls::raw::WAIT_NO, |duration| {\n-            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n-        });\n-        match usercalls::wait(event_mask, timeout) {\n-            Ok(eventset) => {\n-                if event_mask == 0 {\n-                    rtabort!(\"expected usercalls::wait() to return Err, found Ok.\");\n-                }\n-                // A matching event is one whose bits are equal to or a subset\n-                // of `event_mask`.\n-                rtassert!(eventset & !event_mask == 0);\n-                true\n-            }\n-            Err(e) => {\n-                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n-                false\n-            }\n-        }\n-    }\n-\n-    match wait_checked(event_mask, Some(duration)) {\n-        false => return,                    // timed out\n-        true if should_wake_up() => return, // woken up\n-        true => {}                          // spurious event\n-    }\n-\n-    // Drain all cached events.\n-    // Note that `event_mask != 0` is implied if we get here.\n-    loop {\n-        match wait_checked(event_mask, None) {\n-            false => break,                     // no more cached events\n-            true if should_wake_up() => return, // woken up\n-            true => {}                          // spurious event\n-        }\n-    }\n-\n-    // Continue waiting, but take note of time spent waiting so we don't wait\n-    // forever. We intentionally don't call `Instant::now()` before this point\n-    // to avoid the cost of the `insecure_time` usercall in case there are no\n-    // spurious wakeups.\n-\n-    let start = Instant::now();\n-    let mut remaining = duration;\n-    loop {\n-        match wait_checked(event_mask, Some(remaining)) {\n-            false => return,                    // timed out\n-            true if should_wake_up() => return, // woken up\n-            true => {}                          // spurious event\n-        }\n-        remaining = match duration.checked_sub(start.elapsed()) {\n-            Some(remaining) => remaining,\n-            None => break,\n-        }\n-    }\n-}\n-\n // This enum is used as the storage for a bunch of types which can't actually\n // exist.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]"}, {"sha": "5895f70436efa4a6f36547fd36e24fb0bffd048f", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=85c25aed510ce599504b172f7c7bef280e91637b", "patch": "@@ -1,7 +1,6 @@\n #![cfg_attr(test, allow(dead_code))] // why is this necessary?\n use crate::ffi::CStr;\n use crate::io;\n-use crate::sys::usercall_wait_timeout;\n use crate::time::Duration;\n \n use super::abi::usercalls;\n@@ -75,7 +74,7 @@ impl Thread {\n     }\n \n     pub fn sleep(dur: Duration) {\n-        usercall_wait_timeout(0, dur, || true);\n+        usercalls::wait_timeout(0, dur, || true);\n     }\n \n     pub fn join(self) {"}, {"sha": "070afa55f301927e3d5f7ac429a5fb930e3c595c", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85c25aed510ce599504b172f7c7bef280e91637b/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=85c25aed510ce599504b172f7c7bef280e91637b", "patch": "@@ -11,7 +11,6 @@\n //! The queue and associated wait state are stored in a `WaitVariable`.\n use crate::num::NonZeroUsize;\n use crate::ops::{Deref, DerefMut};\n-use crate::sys::usercall_wait_timeout;\n use crate::time::Duration;\n \n use super::abi::thread;\n@@ -176,7 +175,7 @@ impl WaitQueue {\n             }));\n             let entry_lock = lock.lock().queue.inner.push(&mut entry);\n             before_wait();\n-            usercall_wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n+            usercalls::wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n             // acquire the wait queue's lock first to avoid deadlock.\n             let mut guard = lock.lock();\n             let success = entry_lock.lock().wake;"}]}