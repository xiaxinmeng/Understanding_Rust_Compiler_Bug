{"sha": "4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMjJkMmYzYjA4NTJmMzJjMGJhNWU0NTQ1ZWM4Y2MyZDk4NmNmY2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-29T08:20:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-29T08:20:02Z"}, "message": "Merge #2112\n\n2112: start ra_hir_def crate r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "09667ecbdcc8b84916c509d3a3d09ab56b5d4aed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09667ecbdcc8b84916c509d3a3d09ab56b5d4aed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdt/YyCRBK7hj4Ov3rIwAAdHIIAJLE+W8e3Wd7FRLiajr6MSgK\nE7z7CNHmGiaOyLExuF+lI5eFGlov2terMkPL6qvtAhY04rDcHGood40/BcSYG8dh\nUUL7AWY23Ghn7wF2bOht2pVvMgA2c6rNimNEeA8ut4InfaiBwDBYl8AnfxtBC/0K\nAHGhoGqmggaqqc0bnyC/3S73YUKGXW7yknlJX0xLfEi+OTDX4woZ0jzMKkIjJqpw\n4uNcMV5j/JpgQLKi9oJ8EDGQ7ReGh+uVAXWWOQLH4KynwVpF/PVComkkcBFUk0zP\naI/ihB+VRLTgyOTCG1hyvCxXeaLo9M7zTEMTTIb8PgVX7d1fPwPEIqcP34ltV5E=\n=A3Ut\n-----END PGP SIGNATURE-----\n", "payload": "tree 09667ecbdcc8b84916c509d3a3d09ab56b5d4aed\nparent 120000609ab0a0e6a946404d0477f5a0a7107800\nparent 77f90caf2deeb6a2d2c8196399fbba61bf0c461d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572337202 +0000\ncommitter GitHub <noreply@github.com> 1572337202 +0000\n\nMerge #2112\n\n2112: start ra_hir_def crate r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "html_url": "https://github.com/rust-lang/rust/commit/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "120000609ab0a0e6a946404d0477f5a0a7107800", "url": "https://api.github.com/repos/rust-lang/rust/commits/120000609ab0a0e6a946404d0477f5a0a7107800", "html_url": "https://github.com/rust-lang/rust/commit/120000609ab0a0e6a946404d0477f5a0a7107800"}, {"sha": "77f90caf2deeb6a2d2c8196399fbba61bf0c461d", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f90caf2deeb6a2d2c8196399fbba61bf0c461d", "html_url": "https://github.com/rust-lang/rust/commit/77f90caf2deeb6a2d2c8196399fbba61bf0c461d"}], "stats": {"total": 312, "additions": 181, "deletions": 131}, "files": [{"sha": "260be728984406b50f2c1624f58910ebe39b88b3", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -991,6 +991,7 @@ dependencies = [\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n  \"ra_mbe 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n@@ -1000,6 +1001,15 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_ide_api\"\n version = \"0.1.0\""}, {"sha": "82720da9e26738e0bcca8ad7ec226710e17c3b62", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -19,6 +19,7 @@ ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n "}, {"sha": "7abbf8dca1f721f15d77b56152644a8a1618af0a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -59,11 +59,11 @@ pub trait InternDatabase: SourceDatabase {\n /// incremental.\n #[salsa::query_group(AstDatabaseStorage)]\n pub trait AstDatabase: InternDatabase {\n-    #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n+    #[salsa::invoke(crate::source_id::ast_id_map_query)]\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n     #[salsa::transparent]\n-    #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n+    #[salsa::invoke(crate::source_id::file_item_query)]\n     fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> SyntaxNode;\n \n     #[salsa::transparent]"}, {"sha": "24733b3de38273cf44fc5241aa97f6c92266b444", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     path::GenericArgs,\n     ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n     type_ref::TypeRef,\n-    DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n+    AstId, DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n     Source,\n };\n \n@@ -458,11 +458,10 @@ where\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::MacroCall(e) => {\n-                let ast_id = self\n-                    .db\n-                    .ast_id_map(self.current_file_id)\n-                    .ast_id(&e)\n-                    .with_file_id(self.current_file_id);\n+                let ast_id = AstId::new(\n+                    self.current_file_id,\n+                    self.db.ast_id_map(self.current_file_id).ast_id(&e),\n+                );\n \n                 if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {"}, {"sha": "7954c04b2e8bbfa2a1f85a1b02e22e2952f81f75", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n     name::AsName,\n-    Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n+    AstId, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n     ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n@@ -183,7 +183,7 @@ impl Module {\n             ModuleSource::Module(ref module) => {\n                 assert!(!module.has_semi());\n                 let ast_id_map = db.ast_id_map(src.file_id);\n-                let item_id = ast_id_map.ast_id(module).with_file_id(src.file_id);\n+                let item_id = AstId::new(src.file_id, ast_id_map.ast_id(module));\n                 Some(item_id)\n             }\n             ModuleSource::SourceFile(_) => None,"}, {"sha": "f141206c648d2fd178371156768e93d81e706a38", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -264,7 +264,7 @@ pub(crate) trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n         Self::from_ast_id(ctx, item_id)\n     }\n     fn from_ast_id(ctx: LocationCtx<&impl InternDatabase>, ast_id: FileAstId<N>) -> Self {\n-        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n+        let loc = ItemLoc { module: ctx.module, ast_id: AstId::new(ctx.file_id, ast_id) };\n         Self::intern(ctx.db, loc)\n     }\n     fn source(self, db: &impl AstDatabase) -> Source<N> {"}, {"sha": "9c739f3f166c32e11a5661e2aa1c78beea707b5f", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     resolve::Resolver,\n     ty::Ty,\n     type_ref::TypeRef,\n-    AssocItem, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n+    AssocItem, AstId, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n     TypeAlias,\n };\n \n@@ -256,7 +256,7 @@ impl ModuleImplBlocks {\n                     }\n \n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n-                    let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n+                    let ast_id = AstId::new(file_id, db.ast_id_map(file_id).ast_id(&macro_call));\n                     if let Some(path) = macro_call\n                         .path()\n                         .and_then(|path| Path::from_src(Source { ast: path, file_id }, db))"}, {"sha": "4f363df3691850a3a3776e535ddc652dca6cbb87", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -567,7 +567,7 @@ where\n             // inline module, just recurse\n             raw::ModuleData::Definition { name, items, ast_id } => {\n                 let module_id =\n-                    self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n+                    self.push_child_module(name.clone(), AstId::new(self.file_id, *ast_id), None);\n \n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n@@ -583,7 +583,7 @@ where\n             }\n             // out of line module, resolve, parse and recurse\n             raw::ModuleData::Declaration { name, ast_id } => {\n-                let ast_id = ast_id.with_file_id(self.file_id);\n+                let ast_id = AstId::new(self.file_id, *ast_id);\n                 match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n                     self.file_id,\n@@ -671,21 +671,18 @@ where\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n+        let ast_id = AstId::new(self.file_id, mac.ast_id);\n+\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId {\n-                    ast_id: mac.ast_id.with_file_id(self.file_id),\n-                    krate: self.def_collector.def_map.krate,\n-                };\n+                let macro_id = MacroDefId { ast_id, krate: self.def_collector.def_map.krate };\n                 let macro_ = MacroDef { id: macro_id };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n             }\n             return;\n         }\n \n-        let ast_id = mac.ast_id.with_file_id(self.file_id);\n-\n         // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n         // recursive item collection.\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {"}, {"sha": "260b7966106b0890dafafdfd39b7c860ad779976", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 22, "deletions": 110, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -2,18 +2,18 @@\n \n use std::{\n     hash::{Hash, Hasher},\n-    marker::PhantomData,\n     sync::Arc,\n };\n \n-use ra_arena::{impl_arena_id, Arena, RawId};\n-use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr};\n+pub use hir_def::ast_id_map::{AstIdMap, ErasedFileAstId, FileAstId};\n+use ra_syntax::{AstNode, SyntaxNode};\n \n use crate::{db::AstDatabase, HirFileId};\n \n /// `AstId` points to an AST node in any file.\n ///\n /// It is stable across reparses, and can be used as salsa key/value.\n+// FIXME: isn't this just a `Source<FileAstId<N>>` ?\n #[derive(Debug)]\n pub(crate) struct AstId<N: AstNode> {\n     file_id: HirFileId,\n@@ -40,122 +40,34 @@ impl<N: AstNode> Hash for AstId<N> {\n }\n \n impl<N: AstNode> AstId<N> {\n+    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n+        AstId { file_id, file_ast_id }\n+    }\n+\n     pub(crate) fn file_id(&self) -> HirFileId {\n         self.file_id\n     }\n \n     pub(crate) fn to_node(&self, db: &impl AstDatabase) -> N {\n-        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n+        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.into());\n         N::cast(syntax_node).unwrap()\n     }\n }\n \n-/// `AstId` points to an AST node in a specific file.\n-#[derive(Debug)]\n-pub(crate) struct FileAstId<N: AstNode> {\n-    raw: ErasedFileAstId,\n-    _ty: PhantomData<fn() -> N>,\n-}\n-\n-impl<N: AstNode> Clone for FileAstId<N> {\n-    fn clone(&self) -> FileAstId<N> {\n-        *self\n-    }\n-}\n-impl<N: AstNode> Copy for FileAstId<N> {}\n-\n-impl<N: AstNode> PartialEq for FileAstId<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.raw == other.raw\n-    }\n-}\n-impl<N: AstNode> Eq for FileAstId<N> {}\n-impl<N: AstNode> Hash for FileAstId<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.raw.hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> FileAstId<N> {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n-        AstId { file_id, file_ast_id: self }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ErasedFileAstId(RawId);\n-impl_arena_id!(ErasedFileAstId);\n-\n-/// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n-#[derive(Debug, PartialEq, Eq, Default)]\n-pub struct AstIdMap {\n-    arena: Arena<ErasedFileAstId, SyntaxNodePtr>,\n+pub(crate) fn ast_id_map_query(db: &impl AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+    let map = if let Some(node) = db.parse_or_expand(file_id) {\n+        AstIdMap::from_source(&node)\n+    } else {\n+        AstIdMap::default()\n+    };\n+    Arc::new(map)\n }\n \n-impl AstIdMap {\n-    pub(crate) fn ast_id_map_query(db: &impl AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n-        let map = if let Some(node) = db.parse_or_expand(file_id) {\n-            AstIdMap::from_source(&node)\n-        } else {\n-            AstIdMap::default()\n-        };\n-        Arc::new(map)\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl AstDatabase,\n-        file_id: HirFileId,\n-        ast_id: ErasedFileAstId,\n-    ) -> SyntaxNode {\n-        let node = db.parse_or_expand(file_id).unwrap();\n-        db.ast_id_map(file_id).arena[ast_id].to_node(&node)\n-    }\n-\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n-        let ptr = SyntaxNodePtr::new(item.syntax());\n-        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            Some((it, _)) => it,\n-            None => panic!(\n-                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n-                item.syntax(),\n-                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-            ),\n-        };\n-\n-        FileAstId { raw, _ty: PhantomData }\n-    }\n-\n-    fn from_source(node: &SyntaxNode) -> AstIdMap {\n-        assert!(node.parent().is_none());\n-        let mut res = AstIdMap { arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, adding a new child does not\n-        // change parent's id. This means that, say, adding a new function to a\n-        // trait does not change ids of top-level items, which helps caching.\n-        bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it.clone()) {\n-                res.alloc(module_item.syntax());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                res.alloc(macro_call.syntax());\n-            }\n-        });\n-        res\n-    }\n-\n-    fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n-        self.arena.alloc(SyntaxNodePtr::new(item))\n-    }\n-}\n-\n-/// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(SyntaxNode)) {\n-    let mut curr_layer = vec![node.clone()];\n-    let mut next_layer = vec![];\n-    while !curr_layer.is_empty() {\n-        curr_layer.drain(..).for_each(|node| {\n-            next_layer.extend(node.children());\n-            f(node);\n-        });\n-        std::mem::swap(&mut curr_layer, &mut next_layer);\n-    }\n+pub(crate) fn file_item_query(\n+    db: &impl AstDatabase,\n+    file_id: HirFileId,\n+    ast_id: ErasedFileAstId,\n+) -> SyntaxNode {\n+    let node = db.parse_or_expand(file_id).unwrap();\n+    db.ast_id_map(file_id)[ast_id].to_node(&node)\n }"}, {"sha": "7c57d56bd4864cd6d1259e67b7406d2ea09ce4bd", "filename": "crates/ra_hir_def/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir_def\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "c3b389102ac57135d8dae3c459ee988890ccedce", "filename": "crates/ra_hir_def/src/ast_id_map.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fast_id_map.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -0,0 +1,114 @@\n+//! `AstIdMap` allows to create stable IDs for \"large\" syntax nodes like items\n+//! and macro calls.\n+//!\n+//! Specifically, it enumerates all items in a file and uses position of a an\n+//! item as an ID. That way, id's don't change unless the set of items itself\n+//! changes.\n+\n+use std::{\n+    hash::{Hash, Hasher},\n+    marker::PhantomData,\n+    ops,\n+};\n+\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxNodePtr};\n+\n+/// `AstId` points to an AST node in a specific file.\n+#[derive(Debug)]\n+pub struct FileAstId<N: AstNode> {\n+    raw: ErasedFileAstId,\n+    _ty: PhantomData<fn() -> N>,\n+}\n+\n+impl<N: AstNode> Clone for FileAstId<N> {\n+    fn clone(&self) -> FileAstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for FileAstId<N> {}\n+\n+impl<N: AstNode> PartialEq for FileAstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for FileAstId<N> {}\n+impl<N: AstNode> Hash for FileAstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.raw.hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> From<FileAstId<N>> for ErasedFileAstId {\n+    fn from(id: FileAstId<N>) -> Self {\n+        id.raw\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ErasedFileAstId(RawId);\n+impl_arena_id!(ErasedFileAstId);\n+\n+/// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub struct AstIdMap {\n+    arena: Arena<ErasedFileAstId, SyntaxNodePtr>,\n+}\n+\n+impl AstIdMap {\n+    pub fn from_source(node: &SyntaxNode) -> AstIdMap {\n+        assert!(node.parent().is_none());\n+        let mut res = AstIdMap { arena: Arena::default() };\n+        // By walking the tree in bread-first order we make sure that parents\n+        // get lower ids then children. That is, adding a new child does not\n+        // change parent's id. This means that, say, adding a new function to a\n+        // trait does not change ids of top-level items, which helps caching.\n+        bfs(node, |it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it.clone()) {\n+                res.alloc(module_item.syntax());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                res.alloc(macro_call.syntax());\n+            }\n+        });\n+        res\n+    }\n+\n+    pub fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        let ptr = SyntaxNodePtr::new(item.syntax());\n+        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            Some((it, _)) => it,\n+            None => panic!(\n+                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n+                item.syntax(),\n+                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+            ),\n+        };\n+\n+        FileAstId { raw, _ty: PhantomData }\n+    }\n+\n+    fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n+        self.arena.alloc(SyntaxNodePtr::new(item))\n+    }\n+}\n+\n+impl ops::Index<ErasedFileAstId> for AstIdMap {\n+    type Output = SyntaxNodePtr;\n+    fn index(&self, index: ErasedFileAstId) -> &SyntaxNodePtr {\n+        &self.arena[index]\n+    }\n+}\n+\n+/// Walks the subtree in bfs order, calling `f` for each node.\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(SyntaxNode)) {\n+    let mut curr_layer = vec![node.clone()];\n+    let mut next_layer = vec![];\n+    while !curr_layer.is_empty() {\n+        curr_layer.drain(..).for_each(|node| {\n+            next_layer.extend(node.children());\n+            f(node);\n+        });\n+        std::mem::swap(&mut curr_layer, &mut next_layer);\n+    }\n+}"}, {"sha": "4d4d2cb19c740baf5dbb7b151bbcd76aafad83ac", "filename": "crates/ra_hir_def/src/lib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=4f22d2f3b0852f32c0ba5e4545ec8cc2d986cfcc", "patch": "@@ -0,0 +1,7 @@\n+//! `ra_hir_def` contains initial \"phases\" of the compiler. Roughly, everything\n+//! before types.\n+//!\n+//! Note that we are in the process of moving parts of `ra_hir` into\n+//! `ra_hir_def`, so this crates doesn't contain a lot at the moment.\n+\n+pub mod ast_id_map;"}]}