{"sha": "9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZjRmNTdjZDBlZTA1MzdiOTEzNWE5NzU0N2RhZjExMzFmMGJjMTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-02T20:11:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-01T14:28:28Z"}, "message": "move job of creating local-def-ids to ast-map (with a few stragglers)", "tree": {"sha": "4a33ba22fc0bb4506c760c7ccf5a208b989f33a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a33ba22fc0bb4506c760c7ccf5a208b989f33a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "html_url": "https://github.com/rust-lang/rust/commit/9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd139f5fd51ba8cd2af454c6a36e216708649f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd139f5fd51ba8cd2af454c6a36e216708649f2", "html_url": "https://github.com/rust-lang/rust/commit/2dd139f5fd51ba8cd2af454c6a36e216708649f2"}], "stats": {"total": 740, "additions": 414, "deletions": 326}, "files": [{"sha": "8d8932552b7d445a36d2a643b3904550ff713623", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -12,6 +12,7 @@ pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n \n+use metadata::cstore::LOCAL_CRATE;\n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n@@ -267,6 +268,18 @@ pub struct Map<'ast> {\n }\n \n impl<'ast> Map<'ast> {\n+    pub fn local_def_id(&self, node: NodeId) -> DefId {\n+        DefId::xxx_local(node)\n+    }\n+\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n+        if def_id.krate == LOCAL_CRATE {\n+            Some(def_id.node)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.borrow().len()\n     }\n@@ -383,7 +396,7 @@ impl<'ast> Map<'ast> {\n         match self.find_entry(parent) {\n             Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n             Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n-            _ => DefId::local(parent)\n+            _ => self.local_def_id(parent)\n         }\n     }\n \n@@ -1134,3 +1147,4 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n+"}, {"sha": "b67da4baf5ab0a7ae35274c2d808b9dc40c1db2a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -119,7 +119,7 @@ pub fn def_to_string(did: DefId) -> String {\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ecx.tcx.item_variances(DefId::local(id));\n+    let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -130,8 +130,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n-                           &ecx.tcx.lookup_item_type(DefId::local(id)),\n-                           &ecx.tcx.lookup_predicates(DefId::local(id)));\n+                           &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n+                           &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -278,7 +278,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n-    let def = ecx.tcx.lookup_adt_def(DefId::local(id));\n+    let def = ecx.tcx.lookup_adt_def(ecx.tcx.map.local_def_id(id));\n     for variant in &def.variants {\n         let vid = variant.did;\n         assert!(vid.is_local());\n@@ -302,7 +302,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             ty::VariantKind::Dict => 'V'\n         });\n         encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, DefId::local(id));\n+        encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(id));\n         encode_visibility(rbml_w, vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n@@ -504,19 +504,19 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        name: Name,\n                        vis: hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(id));\n+    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n     encode_name(rbml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in &md.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(DefId::local(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(auxiliary_node_id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n         });\n \n@@ -526,14 +526,14 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    name,\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(DefId::local(did)));\n+            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(ecx.tcx.map.local_def_id(did)));\n         }\n     }\n \n     encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup(ecx.tcx, DefId::local(id));\n+    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n@@ -627,7 +627,7 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_struct_field_family(rbml_w, field.vis);\n     encode_name(rbml_w, nm);\n     encode_bounds_and_type_for_item(rbml_w, ecx, id);\n-    encode_def_id(rbml_w, DefId::local(id));\n+    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(id));\n \n     let stab = stability::lookup(ecx.tcx, field.did);\n     encode_stability(rbml_w, stab);\n@@ -647,18 +647,18 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(ctor_id));\n+    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(ctor_id));\n     encode_family(rbml_w, 'o');\n     encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n-    encode_parent_item(rbml_w, DefId::local(struct_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup(ecx.tcx, DefId::local(ctor_id));\n+    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n@@ -789,7 +789,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_visibility(rbml_w, associated_const.vis);\n     encode_family(rbml_w, 'C');\n \n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n     encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n@@ -802,7 +802,10 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id), ii));\n+        encode_inlined_item(ecx,\n+                            rbml_w,\n+                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                     ii));\n     }\n \n     rbml_w.end_tag();\n@@ -821,7 +824,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, m);\n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n@@ -840,8 +843,10 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == hir::Constness::Const {\n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id),\n-                                                               impl_item));\n+                encode_inlined_item(ecx,\n+                                    rbml_w,\n+                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                             impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n             if !any_types {\n@@ -870,7 +875,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_name(rbml_w, associated_type.name);\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n@@ -991,8 +996,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let def_id = DefId::local(item.id);\n-    let stab = stability::lookup(tcx, DefId::local(item.id));\n+    let def_id = ecx.tcx.map.local_def_id(item.id);\n+    let stab = stability::lookup(tcx, ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n@@ -1072,7 +1077,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(foreign_item.id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1102,7 +1107,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, DefId::local(v.node.id));\n+            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.id));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n@@ -1174,7 +1179,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1194,7 +1199,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n \n-        match tcx.custom_coerce_unsized_kinds.borrow().get(&DefId::local(item.id)) {\n+        match tcx.custom_coerce_unsized_kinds.borrow().get(&ecx.tcx.map.local_def_id(item.id)) {\n             Some(&kind) => {\n                 rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n                 kind.encode(rbml_w);\n@@ -1228,7 +1233,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = tcx.impl_trait_ref(DefId::local(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1472,7 +1477,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     });\n \n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(nitem.id));\n+    encode_def_id(rbml_w, ecx.tcx.map.local_def_id(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n@@ -1483,7 +1488,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n@@ -1496,7 +1501,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.name);\n@@ -1831,7 +1836,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n             if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                     def_id.krate != LOCAL_CRATE {\n                 self.rbml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.rbml_w, DefId::local(item.id));\n+                encode_def_id(self.rbml_w, self.ecx.tcx.map.local_def_id(item.id));\n                 self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n                 self.rbml_w.end_tag();\n             }\n@@ -1873,11 +1878,11 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(DefId::local(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(auxiliary_node_id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n         });\n     }"}, {"sha": "75afe11839ce89123446423bb85784332faa6e0f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -213,15 +213,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 // by the receiver-matching code in collect, which won't\n                 // be going down this code path, and anyway I will kill it\n                 // the moment wfcheck becomes the standard.\n-                let node_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), '|');\n+                let def_id = self.parse_def(NominalType);\n                 let space = self.parse_param_space();\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    param_id: node_id,\n+                    param_id: def_id,\n                     space: space,\n                     index: index,\n                     name: name"}, {"sha": "c085f0e582562cc7a8ec0f79c323d38b9c920f70", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -250,7 +250,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReEarlyBound(ref data) => {\n             mywrite!(w, \"B[{}|{}|{}|{}]\",\n-                     data.param_id,\n+                     (cx.ds)(data.param_id),\n                      data.space.to_uint(),\n                      data.index,\n                      data.name);"}, {"sha": "a137d295bd19900693120bc659d832dfeb380b49", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -934,7 +934,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n                 rbml_w.id(id);\n \n-                let var_id = freevar.def.def_id().node;\n+                let var_id = freevar.def.node_id();\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n                     closure_expr_id: id\n@@ -997,14 +997,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&DefId::local(id)) {\n+    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&tcx.map.local_def_id(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n-    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&DefId::local(id)) {\n+    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&tcx.map.local_def_id(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             encode_closure_kind(rbml_w, *closure_kind)\n@@ -1476,14 +1476,16 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     c::tag_table_closure_tys => {\n                         let closure_ty =\n                             val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_tys.insert(DefId::local(id),\n-                                                                closure_ty);\n+                        dcx.tcx.tables.borrow_mut().closure_tys.insert(\n+                            dcx.tcx.map.local_def_id(id),\n+                            closure_ty);\n                     }\n                     c::tag_table_closure_kinds => {\n                         let closure_kind =\n                             val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(DefId::local(id),\n-                                                                  closure_kind);\n+                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(\n+                            dcx.tcx.map.local_def_id(id),\n+                            closure_kind);\n                     }\n                     c::tag_table_cast_kinds => {\n                         let cast_kind ="}, {"sha": "86dbbb578fff940a33715dd78ae0d582d9c65f5c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n                 def::DefConst(_) | def::DefAssociatedConst(..) => {\n-                    self.check_def_id(def.def_id())\n+                    self.check_def_id(def.def_id());\n                 }\n                 _ if self.ignore_non_const_paths => (),\n                 def::DefPrimTy(_) => (),\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let impl_items = self.tcx.impl_items.borrow();\n-        match self.tcx.inherent_impls.borrow().get(&DefId::local(id)) {\n+        match self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {"}, {"sha": "58d747002c92790ceb28f5ea3df8b9fceec02746", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -10,7 +10,6 @@\n \n pub use self::Def::*;\n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n@@ -115,10 +114,24 @@ pub struct Export {\n }\n \n impl Def {\n-    pub fn local_node_id(&self) -> ast::NodeId {\n-        let def_id = self.def_id();\n-        assert_eq!(def_id.krate, LOCAL_CRATE);\n-        def_id.node\n+    pub fn node_id(&self) -> ast::NodeId {\n+        match *self {\n+            DefLocal(id) |\n+            DefUpvar(id, _, _) |\n+            DefRegion(id) |\n+            DefLabel(id)  |\n+            DefSelfTy(_, Some((_, id))) => {\n+                id\n+            }\n+\n+            DefFn(_, _) | DefMod(_) | DefForeignMod(_) | DefStatic(_, _) |\n+            DefVariant(_, _, _) | DefTy(_, _) | DefAssociatedTy(_, _) |\n+            DefTyParam(_, _, _, _) | DefUse(_) | DefStruct(_) | DefTrait(_) |\n+            DefMethod(_) | DefConst(_) | DefAssociatedConst(_) |\n+            DefSelfTy(Some(_), None) | DefPrimTy(_) | DefSelfTy(..) => {\n+                panic!(\"attempted .def_id() on invalid {:?}\", self)\n+            }\n+        }\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -130,12 +143,13 @@ impl Def {\n             DefSelfTy(Some(id), None)=> {\n                 id\n             }\n+\n             DefLocal(id) |\n             DefUpvar(id, _, _) |\n             DefRegion(id) |\n             DefLabel(id)  |\n             DefSelfTy(_, Some((_, id))) => {\n-                DefId::local(id)\n+                DefId::xxx_local(id) // TODO, clearly\n             }\n \n             DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\"),"}, {"sha": "bbfaffb111266697a1875b0d4030855eeb1c07ac", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -41,7 +41,7 @@ impl fmt::Debug for DefId {\n \n \n impl DefId {\n-    pub fn local(id: NodeId) -> DefId {\n+    pub fn xxx_local(id: NodeId) -> DefId {\n         DefId { krate: LOCAL_CRATE, node: id }\n     }\n "}, {"sha": "86b321a94550cb75bcf8a52a562b838a03d02934", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -1160,7 +1160,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let id_var = freevar.def.def_id().node;\n+                let id_var = freevar.def.node_id();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n@@ -1192,7 +1192,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = upvar_def.def_id().node;\n+        let var_id = upvar_def.node_id();\n         let var_ty = try!(self.typer.node_ty(var_id));\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "262c5c1422b7ccacacd61beb4cfbe767d361843b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -21,6 +21,7 @@\n \n pub use self::LangItem::*;\n \n+use front::map as hir_map;\n use session::Session;\n use metadata::csearch::each_lang_item;\n use middle::def_id::DefId;\n@@ -144,38 +145,42 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector<'a> {\n+struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n \n+    ast_map: &'a hir_map::Map<'tcx>,\n+\n     session: &'a Session,\n \n     item_refs: FnvHashMap<&'static str, usize>,\n }\n \n-impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n+impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, DefId::local(item.id), item.span)\n+                self.collect_item(item_index, self.ast_map.local_def_id(item.id), item.span)\n             }\n         }\n \n         visit::walk_item(self, item);\n     }\n }\n \n-impl<'a> LanguageItemCollector<'a> {\n-    pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n+impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n+    pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n+               -> LanguageItemCollector<'a, 'tcx> {\n         let mut item_refs = FnvHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n             session: session,\n+            ast_map: ast_map,\n             items: LanguageItems::new(),\n-            item_refs: item_refs\n+            item_refs: item_refs,\n         }\n     }\n \n@@ -230,9 +235,11 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     return None;\n }\n \n-pub fn collect_language_items(krate: &hir::Crate,\n-                              session: &Session) -> LanguageItems {\n-    let mut collector = LanguageItemCollector::new(session);\n+pub fn collect_language_items(session: &Session,\n+                              map: &hir_map::Map)\n+                              -> LanguageItems {\n+    let krate: &hir::Crate = map.krate();\n+    let mut collector = LanguageItemCollector::new(session, map);\n     collector.collect(krate);\n     let LanguageItemCollector { mut items, .. } = collector;\n     weak_lang_items::check_crate(krate, session, &mut items);"}, {"sha": "b6a4c97b180bf52ae39711516d703e60fcd22b12", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -113,7 +113,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                             \"An API can't be stabilized after it is deprecated\");\n                     }\n \n-                    self.index.map.insert(DefId::local(id), Some(stab));\n+                    let def_id = self.tcx.map.local_def_id(id);\n+                    self.index.map.insert(def_id, Some(stab));\n \n                     // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                     if stab.level != attr::Stable {\n@@ -129,7 +130,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                            use_parent, self.parent);\n                     if use_parent {\n                         if let Some(stab) = self.parent {\n-                            self.index.map.insert(DefId::local(id), Some(stab));\n+                            let def_id = self.tcx.map.local_def_id(id);\n+                            self.index.map.insert(def_id, Some(stab));\n                         } else if self.index.staged_api[&LOCAL_CRATE] && required\n                             && self.export_map.contains(&id)\n                             && !self.tcx.sess.opts.test {"}, {"sha": "a48d34281bb63f46ff42fbc0ee00440a59108240", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -618,7 +618,7 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: self.def_id.node,\n+            param_id: self.def_id,\n             space: self.space,\n             index: self.index,\n             name: self.name,\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = cx.map.get_parent(id);\n-                        let impl_def_id = DefId::local(impl_id);\n+                        let impl_def_id = cx.map.local_def_id(impl_id);\n                         let scheme = cx.lookup_item_type(impl_def_id);\n                         let predicates = cx.lookup_predicates(impl_def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -1134,7 +1134,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ConstImplItem(_, _) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::MethodImplItem(_, ref body) => {\n-                        let method_def_id = DefId::local(id);\n+                        let method_def_id = cx.map.local_def_id(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -1169,7 +1169,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = cx.map.get_parent(id);\n-                        let trait_def_id = DefId::local(trait_id);\n+                        let trait_def_id = cx.map.local_def_id(trait_id);\n                         let trait_def = cx.lookup_trait_def(trait_def_id);\n                         let predicates = cx.lookup_predicates(trait_def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ConstTraitItem(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -1191,8 +1191,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // block, unless this is a trait method with\n                         // no default, then fallback to the method id.\n                         let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n-                        let method_def_id = DefId::local(id);\n-\n+                        let method_def_id = cx.map.local_def_id(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -1217,7 +1216,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n-                        let fn_def_id = DefId::local(id);\n+                        let fn_def_id = cx.map.local_def_id(id);\n                         let fn_scheme = cx.lookup_item_type(fn_def_id);\n                         let fn_predicates = cx.lookup_predicates(fn_def_id);\n \n@@ -1231,7 +1230,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -1240,7 +1239,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ItemTrait(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let trait_def = cx.lookup_trait_def(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -2106,7 +2105,7 @@ impl<'tcx> ctxt<'tcx> {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n                 ms.iter().filter_map(|ti| {\n                     if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(DefId::local(ti.id)) {\n+                        match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                             MethodTraitItem(m) => Some(m),\n                             _ => {\n                                 self.sess.bug(\"provided_trait_methods(): \\\n@@ -2132,7 +2131,7 @@ impl<'tcx> ctxt<'tcx> {\n                 ItemTrait(_, _, _, ref tis) => {\n                     tis.iter().filter_map(|ti| {\n                         if let hir::ConstTraitItem(_, _) = ti.node {\n-                            match self.impl_or_trait_item(DefId::local(ti.id)) {\n+                            match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\\n@@ -2148,7 +2147,7 @@ impl<'tcx> ctxt<'tcx> {\n                 ItemImpl(_, _, _, _, _, ref iis) => {\n                     iis.iter().filter_map(|ii| {\n                         if let hir::ConstImplItem(_, _) = ii.node {\n-                            match self.impl_or_trait_item(DefId::local(ii.id)) {\n+                            match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\"}, {"sha": "c553e3ca5b38d5cfe44233425aa419644a7b0795", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use std::mem;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::parse::token::special_idents;\n \n use rustc_front::hir;\n@@ -675,7 +675,7 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub param_id: NodeId,\n+    pub param_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,"}, {"sha": "8daaf1325eae7e91ab687d199e9c0c080ec628a6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -232,7 +232,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(DefId::local(DUMMY_NODE_ID), name)\n+                ty::BrNamed(tcx.map.local_def_id(DUMMY_NODE_ID), name)\n             }\n         })\n     }).0;\n@@ -466,7 +466,7 @@ impl fmt::Debug for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {:?}, {}, {})\",\n+                write!(f, \"ReEarlyBound({:?}, {:?}, {}, {})\",\n                        data.param_id,\n                        data.space,\n                        data.index,\n@@ -896,7 +896,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut sep = \" \";\n                     try!(tcx.with_freevars(did.node, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n-                            let node_id = freevar.def.local_node_id();\n+                            let node_id = freevar.def.node_id();\n                             try!(write!(f,\n                                         \"{}{}:{}\",\n                                         sep,"}, {"sha": "d004d557856b7e3c124d66e12f0d716a61fe5f36", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -661,7 +661,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n          LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", ||\n-                          middle::lang_items::collect_language_items(krate, &sess));\n+                          middle::lang_items::collect_language_items(&sess, &ast_map));\n \n     let resolve::CrateMap {\n         def_map,"}, {"sha": "4b3b3a5e84827bd00a62d9761123f6b2fb3956c0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -130,7 +130,7 @@ fn test_env<F>(source_string: &str,\n     let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(krate, &sess);\n+    let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n     let resolve::CrateMap { def_map, freevars, .. } =\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);"}, {"sha": "afa736d2220d39b13e9721dd6bcddc3f54ff1734", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::def_id::DefId;\n use middle::ty;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -29,7 +28,8 @@ pub enum MethodLateContext {\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n-    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n+    let def_id = cx.tcx.map.local_def_id(id);\n+    match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n         None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,"}, {"sha": "9d502a312616a86566f9977f85dcc64f196d20ef", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -555,15 +555,15 @@ impl LateLintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n                 (def, cx.tcx.mk_struct(def,\n                                        cx.tcx.mk_substs(Substs::empty())))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n                 (def, cx.tcx.mk_enum(def,\n                                      cx.tcx.mk_substs(Substs::empty())))\n             }\n@@ -764,7 +764,7 @@ impl LateLintPass for UnconditionalRecursion {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                cx.tcx.impl_or_trait_item(DefId::local(id)).as_opt_method()\n+                cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure => return\n@@ -877,8 +877,11 @@ impl LateLintPass for UnconditionalRecursion {\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.def_map.borrow().get(&callee.id)\n-                        .map_or(false, |def| def.def_id() == DefId::local(fn_id))\n+                    tcx.def_map\n+                       .borrow()\n+                       .get(&callee.id)\n+                       .map_or(false,\n+                               |def| def.def_id() == tcx.map.local_def_id(fn_id))\n                 }\n                 _ => false\n             }"}, {"sha": "ebde7e1d097b367c74f5e5a14fb345870ae018f4", "filename": "src/librustc_mir/dump.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -26,7 +26,6 @@ use repr::Mir;\n use std::fs::File;\n use tcx::{PatNode, Cx};\n \n-use self::rustc::middle::def_id::DefId;\n use self::rustc::middle::infer;\n use self::rustc::middle::region::CodeExtentData;\n use self::rustc::middle::ty::{self, Ty};\n@@ -210,7 +209,7 @@ fn closure_self_ty<'a,'tcx>(tcx: &ty::ctxt<'tcx>,\n     let region =\n         tcx.mk_region(region);\n \n-    match tcx.closure_kind(DefId::local(closure_expr_id)) {\n+    match tcx.closure_kind(tcx.map.local_def_id(closure_expr_id)) {\n         ty::ClosureKind::FnClosureKind =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,"}, {"sha": "6560f8449c426c37d5a767a8a0bd9ac75eb9d407", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -17,7 +17,6 @@ use tcx::block;\n use tcx::pattern::PatNode;\n use tcx::rustc::front::map;\n use tcx::rustc::middle::def;\n-use tcx::rustc::middle::def_id::DefId;\n use tcx::rustc::middle::region::CodeExtent;\n use tcx::rustc::middle::pat_util;\n use tcx::rustc::middle::ty::{self, Ty};\n@@ -612,7 +611,7 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n             let region =\n                 cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(DefId::local(closure_expr_id)) {\n+            let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::FnClosureKind => {\n                     let ref_closure_ty =\n                         cx.tcx.mk_ref(region,"}, {"sha": "aa41dccc6dcd7298896d1752b86b350098322777", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                     _ => true,\n                 };\n-                let tr = self.tcx.impl_trait_ref(DefId::local(item.id));\n+                let tr = self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n                     !tr.def_id.is_local() ||\n                      self.exported_items.contains(&tr.def_id.node)"}, {"sha": "1f850fc9687c1ed85110be22b0ebd82a941dca9e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -427,18 +427,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == hir::MutMutable;\n \n-                name_bindings.define_value(DefStatic(DefId::local(item.id), mutbl), sp, modifiers);\n+                name_bindings.define_value(DefStatic(self.ast_map.local_def_id(item.id), mutbl),\n+                                           sp,\n+                                           modifiers);\n                 parent.clone()\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(DefId::local(item.id)), sp, modifiers);\n+                    .define_value(DefConst(self.ast_map.local_def_id(item.id)), sp, modifiers);\n                 parent.clone()\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n-                let def = DefFn(DefId::local(item.id), false);\n+                let def = DefFn(self.ast_map.local_def_id(item.id), false);\n                 name_bindings.define_value(def, sp, modifiers);\n                 parent.clone()\n             }\n@@ -448,12 +450,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp,\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false), sp,\n                                           modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(DefId::local(item.id)),\n+                                              Some(self.ast_map.local_def_id(item.id)),\n                                               TypeModuleKind,\n                                               false,\n                                               is_public,\n@@ -465,11 +467,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(DefId::local(item.id), true), sp, modifiers);\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), true),\n+                                          sp,\n+                                          modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(DefId::local(item.id)),\n+                                              Some(self.ast_map.local_def_id(item.id)),\n                                               EnumModuleKind,\n                                               false,\n                                               is_public,\n@@ -478,9 +482,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module = name_bindings.get_module();\n \n                 for variant in &(*enum_definition).variants {\n+                    let item_def_id = self.ast_map.local_def_id(item.id);\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n-                        DefId::local(item.id),\n+                        item_def_id,\n                         &module);\n                 }\n                 parent.clone()\n@@ -497,12 +502,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp, modifiers);\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n+                                          sp,\n+                                          modifiers);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if let Some(cid) = ctor_id {\n-                    name_bindings.define_value(DefStruct(DefId::local(cid)), sp, modifiers);\n+                    name_bindings.define_value(DefStruct(self.ast_map.local_def_id(cid)),\n+                                               sp,\n+                                               modifiers);\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -512,7 +521,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         UnnamedField(_) => None\n                     }\n                 }).collect();\n-                self.structs.insert(DefId::local(item.id), named_fields);\n+                let item_def_id = self.ast_map.local_def_id(item.id);\n+                self.structs.insert(item_def_id, named_fields);\n \n                 parent.clone()\n             }\n@@ -527,14 +537,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.define_module(parent_link,\n-                                            Some(DefId::local(item.id)),\n+                                            Some(self.ast_map.local_def_id(item.id)),\n                                             TraitModuleKind,\n                                             false,\n                                             is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n-                let def_id = DefId::local(item.id);\n+                let def_id = self.ast_map.local_def_id(item.id);\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n@@ -545,25 +555,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     match trait_item.node {\n                         hir::ConstTraitItem(..) => {\n-                            let def = DefAssociatedConst(DefId::local(trait_item.id));\n+                            let def = DefAssociatedConst(self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::MethodTraitItem(..) => {\n-                            let def = DefMethod(DefId::local(trait_item.id));\n+                            let def = DefMethod(self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::TypeTraitItem(..) => {\n-                            let def = DefAssociatedTy(DefId::local(item.id),\n-                                                      DefId::local(trait_item.id));\n+                            let def = DefAssociatedTy(self.ast_map.local_def_id(item.id),\n+                                                      self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n-                    self.trait_item_map.insert((trait_item.name, def_id),\n-                                               DefId::local(trait_item.id));\n+                    let trait_item_def_id = self.ast_map.local_def_id(trait_item.id);\n+                    self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n@@ -583,7 +593,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n                 // Not adding fields for variants as they are not accessed with a self receiver\n-                self.structs.insert(DefId::local(variant.node.id), Vec::new());\n+                let variant_def_id = self.ast_map.local_def_id(variant.node.id);\n+                self.structs.insert(variant_def_id, Vec::new());\n                 true\n             }\n         };\n@@ -594,10 +605,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // variants are always treated as importable to allow them to be glob\n         // used\n         child.define_value(DefVariant(item_id,\n-                                      DefId::local(variant.node.id), is_exported),\n+                                      self.ast_map.local_def_id(variant.node.id), is_exported),\n                            variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n-                                     DefId::local(variant.node.id), is_exported),\n+                                     self.ast_map.local_def_id(variant.node.id), is_exported),\n                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n@@ -618,10 +629,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n-                DefFn(DefId::local(foreign_item.id), false)\n+                DefFn(self.ast_map.local_def_id(foreign_item.id), false)\n             }\n             ForeignItemStatic(_, m) => {\n-                DefStatic(DefId::local(foreign_item.id), m)\n+                DefStatic(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n         name_bindings.define_value(def, foreign_item.span, modifiers);"}, {"sha": "4497bfb3898d3693bfe79eee2b0411b1f0c3c2a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -2156,7 +2156,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                TypeSpace,\n                                                                ItemRibKind),\n                                              |this| {\n-                    this.with_self_rib(DefSelfTy(Some(DefId::local(item.id)), None), |this| {\n+                    let local_def_id = this.ast_map.local_def_id(item.id);\n+                    this.with_self_rib(DefSelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n@@ -2280,7 +2281,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     function_type_rib.bindings.insert(name,\n                         DlDef(DefTyParam(space,\n                                          index as u32,\n-                                         DefId::local(type_parameter.id),\n+                                         self.ast_map.local_def_id(type_parameter.id),\n                                          name)));\n                 }\n                 self.type_ribs.push(function_type_rib);"}, {"sha": "c2ec4456e118a526e334fbe5993040a3a9ceee29", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -349,15 +349,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> FunctionData {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(DefId::local(id)) {\n+        let qualname = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     match item.node {\n                         hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&rustc_front::print::pprust::ty_to_string(&**ty));\n \n-                            match self.tcx.trait_of_item(DefId::local(id)) {\n+                            match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -381,7 +381,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                  impl_id.node, id, self.tcx.map.get(impl_id.node)));\n                 }\n             },\n-            None => match self.tcx.trait_of_item(DefId::local(id)) {\n+            None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n                     match self.tcx.map.get(def_id.node) {\n                         NodeItem(_) => {\n@@ -403,11 +403,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let decl_id = self.tcx.trait_item_of_item(DefId::local(id))\n+        let def_id = self.tcx.map.local_def_id(id);\n+        let decl_id =\n+            self.tcx.trait_item_of_item(def_id)\n             .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != DefId::local(id) {\n-                    Some(def_id)\n+                let new_def_id = new_id.def_id();\n+                if new_def_id.node != 0 && new_def_id != def_id {\n+                    Some(new_def_id)\n                 } else {\n                     None\n                 }"}, {"sha": "8a0578332e6beb2c11b7be624424698d1464ae26", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -2086,7 +2086,8 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     // error in trans. This is used to write compile-fail tests\n                     // that actually test that compilation succeeds without\n                     // reporting an error.\n-                    if ccx.tcx().has_attr(DefId::local(item.id), \"rustc_error\") {\n+                    let item_def_id = ccx.tcx().map.local_def_id(item.id);\n+                    if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n                         ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n                     }\n                 }"}, {"sha": "d992f6eeab19e23512319f97a951b5c7a6a44951", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -43,7 +43,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n-    let closure_id = DefId::local(bcx.fcx.id);\n+    let closure_id = bcx.tcx().map.local_def_id(bcx.fcx.id);\n     let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n     let kind = kind_for_closure(bcx.ccx(), closure_id);\n@@ -69,7 +69,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.node_id(),\n                                      closure_expr_id: closure_id.node };\n         let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n         let mut upvar_ptr = StructGEP(bcx, llenv, i);\n@@ -190,7 +190,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     debug!(\"trans_closure_expr()\");\n \n-    let closure_id = DefId::local(id);\n+    let closure_id = tcx.map.local_def_id(id);\n     let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n@@ -235,7 +235,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.node_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n             ty::UpvarCapture::ByValue => {"}, {"sha": "ba50bec2ecd913e856ee6996718c30f21f71f565", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -1145,8 +1145,9 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n+    let inlined_vid_def_id = ccx.tcx().map.local_def_id(inlined_vid);\n     adt_def.variants.iter().find(|v| {\n-        DefId::local(inlined_vid) == v.did ||\n+        inlined_vid_def_id == v.did ||\n             ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n     }).unwrap_or_else(|| {\n         ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))"}, {"sha": "75dc67bd9b09bb81adb3a8932c8c744ee51b185f", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -1887,7 +1887,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let namespace_node = namespace_for_item(cx, DefId::local(node_id));\n+    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let namespace_node = namespace_for_item(cx, node_def_id);\n     let var_name = name.to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[..]);"}, {"sha": "a08f33c8899943ede12c914c26b98ecc22eb51d4", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -351,7 +351,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // somehow (storing a path in the hir_map, or construct a path using the\n     // enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n-        let namespace_node = namespace_for_item(cx, DefId::local(fn_ast_id));\n+        let fn_ast_def_id = cx.tcx().map.local_def_id(fn_ast_id);\n+        let namespace_node = namespace_for_item(cx, fn_ast_def_id);\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n             &function_name[..]);\n         let containing_scope = namespace_node.scope;"}, {"sha": "bf5f20d72e3f53960a24d4060a0df0f3dd65806b", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -30,7 +30,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n                    ccx.tcx().item_path_str(fn_id), node_id);\n-            return Some(DefId::local(node_id));\n+            let node_def_id = ccx.tcx().map.local_def_id(node_id);\n+            return Some(node_def_id);\n         }\n         Some(&None) => {\n             return None; // Not inlinable\n@@ -144,8 +145,9 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n             let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n+            let trait_item_def_id = ccx.tcx().map.local_def_id(trait_item.id);\n             ccx.tcx().impl_or_trait_items.borrow_mut()\n-                     .insert(DefId::local(trait_item.id), ty_trait_item);\n+                     .insert(trait_item_def_id, ty_trait_item);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n@@ -185,7 +187,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n         }\n     };\n \n-    Some(DefId::local(inline_id))\n+    let inline_def_id = ccx.tcx().map.local_def_id(inline_id);\n+    Some(inline_def_id)\n }\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)"}, {"sha": "c424245facca75e1f050c651f75fa5defbfdd474", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -168,12 +168,13 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            ty::ReLateBound(debruijn, ty::BrNamed(DefId::local(id), lifetime.name))\n+            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id), lifetime.name))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n+            let def_id = tcx.map.local_def_id(id);\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: id,\n+                param_id: def_id,\n                 space: space,\n                 index: index,\n                 name: lifetime.name\n@@ -183,7 +184,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n         Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n                     scope: tcx.region_maps.item_extent(scope.node_id),\n-                    bound_region: ty::BrNamed(DefId::local(id),\n+                    bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n                                               lifetime.name)\n                 })\n         }\n@@ -1264,7 +1265,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n-            let trait_ref = tcx.impl_trait_ref(DefId::local(impl_id)).unwrap();\n+            let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n             let trait_ref = if let Some(free_substs) = this.get_free_substs() {\n                 trait_ref.subst(tcx, free_substs)\n             } else {\n@@ -1333,7 +1334,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 let item = trait_items.iter()\n                                       .find(|i| i.name == assoc_name)\n                                       .expect(\"missing associated type\");\n-                DefId::local(item.id)\n+                tcx.map.local_def_id(item.id)\n             }\n             _ => unreachable!()\n         }\n@@ -1639,7 +1640,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "8bcff22575563592178e9f678495cc02e1717160", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::def_id::DefId;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n@@ -202,9 +201,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 d\n             } else if qself.position == 0 {\n+                // This is just a sentinel for finish_resolving_def_to_ty.\n+                let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n-                    // This is just a sentinel for finish_resolving_def_to_ty.\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(sentinel),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "4f7a6395395461f4d444916b0934d5e5d3f4a42f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -13,7 +13,6 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n-use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n@@ -46,7 +45,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           decl: &'tcx hir::FnDecl,\n                           body: &'tcx hir::Block,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = DefId::local(expr.id);\n+    let expr_def_id = fcx.tcx().map.local_def_id(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,"}, {"sha": "4afc610f63ea553e4dc803006467815e7f740e4d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -13,7 +13,6 @@\n \n use astconv::AstConv;\n use intrinsics;\n-use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::FnSig;\n use middle::ty::{self, Ty};\n@@ -43,7 +42,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &hir::ForeignItem,\n             variadic: false,\n         }),\n     }));\n-    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n+    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,\n@@ -365,7 +364,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n+    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     let name = it.name.as_str();\n "}, {"sha": "caa6b226d1b062a90b37c8a98ed4c732a0efd30c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -15,6 +15,7 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n+use front::map as hir_map;\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n use middle::def;\n use middle::def_id::DefId;\n@@ -385,21 +386,24 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         // Crate-local:\n         //\n         // meh.\n-        struct Visitor<'a> {\n+        struct Visitor<'a, 'tcx:'a> {\n+            map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v, 'a> visit::Visitor<'v> for Visitor<'a> {\n+        impl<'v, 'a, 'tcx> visit::Visitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n-                        self.traits.push(TraitInfo::new(DefId::local(i.id)));\n+                        let def_id = self.map.local_def_id(i.id);\n+                        self.traits.push(TraitInfo::new(def_id));\n                     }\n                     _ => {}\n                 }\n                 visit::walk_item(self, i)\n             }\n         }\n         visit::walk_crate(&mut Visitor {\n+            map: &ccx.tcx.map,\n             traits: &mut traits\n         }, ccx.tcx.map.krate());\n "}, {"sha": "7f4b1095cb596fa54cf1209ab1c4d206158029fd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -688,15 +688,15 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n \n     check_representable(tcx, span, id, \"struct\");\n \n-    if tcx.lookup_simd(DefId::local(id)) {\n+    if tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n         check_simd(tcx, span, id);\n     }\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(DefId::local(it.id)));\n+           ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -711,7 +711,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          match ccx.tcx.impl_trait_ref(DefId::local(it.id)) {\n+          match ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n@@ -742,7 +742,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(DefId::local(item.id));\n+                let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -764,18 +764,18 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_body(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(DefId::local(it.id)));\n+           ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n+        let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        let impl_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n+        let impl_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n \n         for impl_item in impl_items {\n             match impl_item.node {\n@@ -793,7 +793,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         }\n       }\n       hir::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ccx.tcx.lookup_trait_def(DefId::local(it.id));\n+        let trait_def = ccx.tcx.lookup_trait_def(ccx.tcx.map.local_def_id(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n@@ -912,7 +912,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = ccx.tcx.impl_or_trait_item(DefId::local(impl_item.id));\n+        let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name())\n             .unwrap_or_else(|| {\n@@ -1954,7 +1954,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.infcx().next_ty_var(),\n                                 origin_span: codemap::DUMMY_SP,\n-                                def_id: DefId::local(0) // what do I put here?\n+                                def_id: self.tcx().map.local_def_id(0) // what do I put here?\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -3357,7 +3357,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -4109,7 +4109,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.ccx.tcx.lookup_item_type(DefId::local(id)).ty;\n+    let declty = fcx.ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -4237,7 +4237,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n         }\n \n-        let def_id = DefId::local(id);\n+        let def_id = ccx.tcx.map.local_def_id(id);\n \n         let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n         for (v, variant) in vs.iter().zip(variants.iter()) {"}, {"sha": "590b7e50e94388504e91ad8176de1f2293f49b6c", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -43,7 +43,6 @@\n use super::FnCtxt;\n \n use check::demand;\n-use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::{self, Ty};\n@@ -116,7 +115,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: hir::CaptureClause,\n                      _body: &hir::Block)\n     {\n-        let closure_def_id = DefId::local(expr.id);\n+        let closure_def_id = self.tcx().map.local_def_id(expr.id);\n         if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.tables.borrow_mut().closure_kinds\n@@ -127,7 +126,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n \n         self.tcx().with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_node_id = freevar.def.local_node_id();\n+                let var_node_id = freevar.def.node_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -215,7 +214,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         // Now we must process and remove any deferred resolutions,\n         // since we have a concrete closure kind.\n-        let closure_def_id = DefId::local(id);\n+        let closure_def_id = self.fcx.tcx().map.local_def_id(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n@@ -469,7 +468,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n             return;\n         }\n \n-        let closure_def_id = DefId::local(closure_id);\n+        let closure_def_id = self.fcx.tcx().map.local_def_id(closure_id);\n         let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n "}, {"sha": "b5cf069bda6847dcade038ccfc1f6a1e83c8f764", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -12,7 +12,6 @@ use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n-use middle::def_id::DefId;\n use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n@@ -57,7 +56,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(DefId::local(item.id)));\n+               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -81,7 +80,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+                let item_def_id = ccx.tcx.map.local_def_id(item.id);\n+                let trait_ref = ccx.tcx.impl_trait_ref(item_def_id).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -117,9 +117,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             hir::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n-                    ccx.tcx.lookup_predicates(DefId::local(item.id));\n+                    ccx.tcx.lookup_predicates(ccx.tcx.map.local_def_id(item.id));\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ccx.tcx.trait_has_default_impl(DefId::local(item.id)) {\n+                if ccx.tcx.trait_has_default_impl(ccx.tcx.map.local_def_id(item.id)) {\n                     if !items.is_empty() {\n                         wfcheck::error_380(ccx, item.span);\n                     }\n@@ -133,7 +133,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         F: for<'fcx> FnMut(&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>, &FnCtxt<'fcx, 'tcx>),\n     {\n         let ccx = self.ccx;\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = ccx.tcx.map.local_def_id(item.id);\n         let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n         let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n@@ -194,7 +194,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         Some(&mut this.cache));\n             debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n+            let type_scheme = fcx.tcx().lookup_item_type(item_def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -230,7 +231,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Similarly, obtain an \"inside\" reference to the trait\n             // that the impl implements.\n-            let trait_ref = match fcx.tcx().impl_trait_ref(DefId::local(item.id)) {\n+            let trait_ref = match fcx.tcx().impl_trait_ref(fcx.tcx().map.local_def_id(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n@@ -279,7 +280,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -431,7 +432,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             FnKind::Closure | FnKind::ItemFn(..) => {}\n             FnKind::Method(..) => {\n-                match self.tcx().impl_or_trait_item(DefId::local(id)) {\n+                match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n@@ -444,7 +445,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            match self.tcx().impl_or_trait_item(DefId::local(trait_item.id)) {\n+            match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds(\n                         self.tcx(),"}, {"sha": "b8d942ad22703ddf23dbb3792ceae67c3d0c6091", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -63,7 +63,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(DefId::local(item.id)));\n+               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -90,7 +90,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), _, _) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(item.id)).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -137,7 +137,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n             let free_id = fcx.inh.infcx.parameter_environment.free_id;\n \n-            let item = fcx.tcx().impl_or_trait_item(DefId::local(item_id));\n+            let item = fcx.tcx().impl_or_trait_item(fcx.tcx().map.local_def_id(item_id));\n \n             let mut implied_bounds = match item.container() {\n                 ty::TraitContainer(_) => vec![],\n@@ -216,7 +216,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n \n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n@@ -228,7 +228,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                    item: &hir::Item,\n                    items: &[P<hir::TraitItem>])\n     {\n-        let trait_def_id = DefId::local(item.id);\n+        let trait_def_id = self.tcx().map.local_def_id(item.id);\n \n         if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n             if !items.is_empty() {\n@@ -251,7 +251,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n@@ -260,7 +260,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n \n             let mut implied_bounds = vec![];\n@@ -276,7 +276,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -299,7 +299,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let item_def_id = DefId::local(item.id);\n+            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n@@ -328,7 +328,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            impl_implied_bounds(fcx, DefId::local(item.id), item.span)\n+            impl_implied_bounds(fcx, fcx.tcx().map.local_def_id(item.id), item.span)\n         });\n     }\n \n@@ -386,7 +386,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n "}, {"sha": "ddb11c910b19ef9f93788d1c653ab3adc0515a66", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n-        let impl_did = DefId::local(item.id);\n+        let impl_did = tcx.map.local_def_id(item.id);\n         let self_type = tcx.lookup_item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n@@ -195,15 +195,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         match item.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 impl_items.iter().map(|impl_item| {\n+                    let impl_def_id = self.crate_context.tcx.map.local_def_id(impl_item.id);\n                     match impl_item.node {\n                         hir::ConstImplItem(..) => {\n-                            ConstTraitItemId(DefId::local(impl_item.id))\n+                            ConstTraitItemId(impl_def_id)\n                         }\n                         hir::MethodImplItem(..) => {\n-                            MethodTraitItemId(DefId::local(impl_item.id))\n+                            MethodTraitItemId(impl_def_id)\n                         }\n                         hir::TypeImplItem(_) => {\n-                            TypeTraitItemId(DefId::local(impl_item.id))\n+                            TypeTraitItemId(impl_def_id)\n                         }\n                     }\n                 }).collect()"}, {"sha": "f796f7fe9f9bd0d191d0ac8eefd811d9c146b936", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -64,7 +64,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn check_item(&self, item: &hir::Item) {\n-        let def_id = DefId::local(item.id);\n+        let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemImpl(_, _, _, None, _, _) => {\n                 // For inherent impls, self type must be a nominal type"}, {"sha": "a2c8e8fd131fced35c9a7fff9ed1dff593ed325a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -178,20 +178,20 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n-                let impl_def_id = DefId::local(item.id);\n+                let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n                         self.report_overlap_error(trait_ref.def_id,\n                                                   impl_def_id,\n-                                                  DefId::local(prev_id));\n+                                                  self.tcx.map.local_def_id(prev_id));\n                     }\n                     None => { }\n                 }\n             }\n             hir::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n-                let impl_def_id = DefId::local(item.id);\n+                let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {"}, {"sha": "f7b10b9001340097e9faa11ed7120bb709a0d492", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -11,7 +11,6 @@\n //! Unsafety checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use middle::def_id::DefId;\n use middle::ty;\n use rustc_front::visit;\n use rustc_front::hir;\n@@ -30,7 +29,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self, item: &'v hir::Item,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n-        match self.tcx.impl_trait_ref(DefId::local(item.id)) {\n+        match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {"}, {"sha": "e24d3f340b6e7ff107815fc08beaac2232c0949f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 83, "deletions": 67, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -199,7 +199,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n-        let def_id = DefId::local(method_id);\n+        let def_id = self.tcx.map.local_def_id(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             _ => {\n@@ -562,7 +562,7 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 path_res.depth == 0 && def_id.node == param_id\n             }\n             def::DefTyParam(_, _, def_id, _) => {\n-                path_res.depth == 0 && def_id == DefId::local(param_id)\n+                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => {\n                 false\n@@ -592,7 +592,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty);\n \n-    let def_id = DefId::local(id);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -632,12 +632,12 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n-    ccx.tcx.register_item_type(DefId::local(v.node.id),\n+    ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(v.node.id),\n                                ty::TypeScheme {\n                                    generics: struct_generics.clone(),\n                                    ty: tt\n                                });\n-    ccx.tcx.predicates.borrow_mut().insert(DefId::local(v.node.id),\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(v.node.id),\n                                            struct_predicates.clone());\n }\n \n@@ -649,21 +649,21 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n {\n-    ccx.tcx.predicates.borrow_mut().insert(DefId::local(id),\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n                                            ty::GenericPredicates::empty());\n \n     write_ty_to_tcx(ccx.tcx, id, ty);\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n         vis: vis,\n-        def_id: DefId::local(id),\n+        def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n         ty: ty,\n         has_value: has_value\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(DefId::local(id), ty::ConstTraitItem(associated_const));\n+       .insert(ccx.tcx.map.local_def_id(id), ty::ConstTraitItem(associated_const));\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -677,11 +677,11 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         name: name,\n         vis: vis,\n         ty: ty,\n-        def_id: DefId::local(id),\n+        def_id: ccx.tcx.map.local_def_id(id),\n         container: container\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(DefId::local(id), ty::TypeTraitItem(associated_type));\n+       .insert(ccx.tcx.map.local_def_id(id), ty::TypeTraitItem(associated_type));\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -752,7 +752,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def_master(DefId::local(it.id)),\n+                                       tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n                                        scheme,\n                                        predicates,\n                                        &enum_definition.variants);\n@@ -766,7 +766,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), Some(trait_ref));\n+            tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                    Some(trait_ref));\n         }\n         hir::ItemImpl(_, _,\n                       ref generics,\n@@ -783,21 +784,21 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.register_item_type(DefId::local(it.id),\n+            tcx.register_item_type(ccx.tcx.map.local_def_id(it.id),\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n+            tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                ty_predicates.clone());\n             if let &Some(ref ast_trait_ref) = opt_trait_ref {\n                 tcx.impl_trait_refs.borrow_mut().insert(\n-                    DefId::local(it.id),\n+                    ccx.tcx.map.local_def_id(it.id),\n                     Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                              &ExplicitRscope,\n                                                              ast_trait_ref,\n                                                              Some(selfty)))\n                         );\n             } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), None);\n+                tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id), None);\n             }\n \n \n@@ -839,12 +840,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 if let hir::ConstImplItem(ref ty, _) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &*ty);\n-                    tcx.register_item_type(DefId::local(impl_item.id),\n+                    tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n                                            TypeScheme {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n+                    convert_associated_const(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, true /* has_value */);\n@@ -861,7 +862,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(DefId::local(it.id)),\n+                    convert_associated_type(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                                             impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n@@ -880,7 +881,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             });\n             convert_methods(ccx,\n-                            ImplContainer(DefId::local(it.id)),\n+                            ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                             methods,\n                             selfty,\n                             &ty_generics,\n@@ -900,15 +901,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             enforce_impl_params_are_constrained(tcx,\n                                                 generics,\n-                                                DefId::local(it.id),\n+                                                ccx.tcx.map.local_def_id(it.id),\n                                                 impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ccx.ensure_super_predicates(it.span, DefId::local(it.id));\n+                ccx.ensure_super_predicates(it.span, ccx.tcx.map.local_def_id(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(DefId::local(it.id));\n+            let trait_predicates = tcx.lookup_predicates(ccx.tcx.map.local_def_id(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -918,14 +919,18 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::ConstTraitItem(ref ty, ref default) => {\n                         let ty = ccx.icx(&trait_predicates)\n                                     .to_ty(&ExplicitRscope, ty);\n-                        tcx.register_item_type(DefId::local(trait_item.id),\n+                        tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n                                                TypeScheme {\n                                                    generics: trait_def.generics.clone(),\n                                                    ty: ty,\n                                                });\n-                        convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n-                                                 trait_item.name, trait_item.id,\n-                                                 hir::Public, ty, default.is_some());\n+                        convert_associated_const(ccx,\n+                                                 TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n+                                                 trait_item.name,\n+                                                 trait_item.id,\n+                                                 hir::Public,\n+                                                 ty,\n+                                                 default.is_some())\n                     }\n                     _ => {}\n                 }\n@@ -939,8 +944,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                             |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                         });\n \n-                        convert_associated_type(ccx, TraitContainer(DefId::local(it.id)),\n-                                                trait_item.name, trait_item.id, hir::Public,\n+                        convert_associated_type(ccx,\n+                                                TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n+                                                trait_item.name,\n+                                                trait_item.id,\n+                                                hir::Public,\n                                                 typ);\n                     }\n                     _ => {}\n@@ -957,15 +965,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Run convert_methods on the trait methods.\n             convert_methods(ccx,\n-                            TraitContainer(DefId::local(it.id)),\n+                            TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n                             methods,\n                             tcx.mk_self_type(),\n                             &trait_def.generics,\n                             &trait_predicates);\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = DefId::local(trait_item.id);\n+                let def_id = ccx.tcx.map.local_def_id(trait_item.id);\n                 match trait_item.node {\n                     hir::ConstTraitItem(..) => {\n                         ty::ConstTraitItemId(def_id)\n@@ -978,7 +986,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     }\n                 }\n             }).collect());\n-            tcx.trait_item_def_ids.borrow_mut().insert(DefId::local(it.id), trait_item_def_ids);\n+            tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                       trait_item_def_ids);\n \n             // This must be done after `collect_trait_methods` so that\n             // we have a method type stored for every method.\n@@ -999,7 +1008,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            let variant = tcx.lookup_adt_def_master(DefId::local(it.id)).struct_variant();\n+            let it_def_id = ccx.tcx.map.local_def_id(it.id);\n+            let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -1037,14 +1047,14 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            tcx.mk_ctor_fn(DefId::local(ctor_id),\n+            tcx.mk_ctor_fn(tcx.map.local_def_id(ctor_id),\n                            &inputs[..],\n                            scheme.ty)\n         }\n     };\n     write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(DefId::local(ctor_id), predicates);\n-    tcx.register_item_type(DefId::local(ctor_id),\n+    tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n+    tcx.register_item_type(tcx.map.local_def_id(ctor_id),\n                            TypeScheme {\n                                generics: scheme.generics,\n                                ty: ctor_ty\n@@ -1096,7 +1106,7 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 def: &hir::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let fields = def.fields.iter().map(|f| {\n-        let fid = DefId::local(f.node.id);\n+        let fid = tcx.map.local_def_id(f.node.id);\n         match f.node.kind {\n             hir::NamedField(name, vis) => {\n                 let dup_span = seen_fields.get(&name).cloned();\n@@ -1130,7 +1140,7 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> ty::AdtDefMaster<'tcx>\n {\n \n-    let did = DefId::local(it.id);\n+    let did = tcx.map.local_def_id(it.id);\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n@@ -1207,7 +1217,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   disr: ty::Disr)\n                                   -> ty::VariantDefData<'tcx, 'tcx>\n     {\n-        let did = DefId::local(v.node.id);\n+        let did = tcx.map.local_def_id(v.node.id);\n         let name = v.node.name;\n         match v.node.kind {\n             hir::TupleVariantKind(ref va) => {\n@@ -1217,7 +1227,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     disr_val: disr,\n                     fields: va.iter().map(|&hir::VariantArg { id, .. }| {\n                         ty::FieldDefData::new(\n-                            DefId::local(id),\n+                            tcx.map.local_def_id(id),\n                             special_idents::unnamed_field.name,\n                             hir::Visibility::Public\n                         )\n@@ -1229,7 +1239,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n     }\n-    let did = DefId::local(it.id);\n+    let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n     let mut prev_disr = None;\n@@ -1243,7 +1253,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         prev_disr = Some(disr);\n         v\n     }).collect();\n-    tcx.intern_adt_def(DefId::local(it.id), ty::AdtKind::Enum, variants)\n+    tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1316,7 +1326,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n-               DefId::local(item.id),\n+               tcx.map.local_def_id(item.id),\n                superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n@@ -1339,7 +1349,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &hir::Item)\n                                -> &'tcx ty::TraitDef<'tcx>\n {\n-    let def_id = DefId::local(it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n     let tcx = ccx.tcx;\n \n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n@@ -1402,12 +1412,15 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.lifetimes\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        param_id: def.lifetime.id,\n-                        space: TypeSpace,\n-                        index: i as u32,\n-                        name: def.lifetime.name\n-                    }))\n+                    .map(|(i, def)| {\n+                        let def_id = tcx.map.local_def_id(def.lifetime.id);\n+                        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                            param_id: def_id,\n+                            space: TypeSpace,\n+                            index: i as u32,\n+                            name: def.lifetime.name\n+                        })\n+                    })\n                     .collect();\n \n         // Start with the generics in the type parameters...\n@@ -1453,7 +1466,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n \n-    let def_id = DefId::local(it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n \n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n@@ -1552,7 +1565,7 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             DefId::local(it.id),\n+             ccx.tcx.map.local_def_id(it.id),\n              |_| compute_type_scheme_of_item(ccx, it))\n }\n \n@@ -1569,7 +1582,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n-            let ty = tcx.mk_fn(Some(DefId::local(it.id)), tcx.mk_bare_fn(tofd));\n+            let ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemTy(ref t, ref generics) => {\n@@ -1644,12 +1657,12 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                              predicates.clone());\n     assert!(prev_predicates.is_none());\n \n     // Debugging aid.\n-    if tcx.has_attr(DefId::local(it.id), \"rustc_object_lifetime_default\") {\n+    if tcx.has_attr(ccx.tcx.map.local_def_id(it.id), \"rustc_object_lifetime_default\") {\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n@@ -1672,7 +1685,7 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n     -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             DefId::local(it.id),\n+             ccx.tcx.map.local_def_id(it.id),\n              |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n }\n \n@@ -1717,7 +1730,8 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id), predicates);\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                             predicates);\n     assert!(prev_predicates.is_none());\n }\n \n@@ -1741,7 +1755,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n-           DefId::local(trait_id), substs);\n+           ccx.tcx.map.local_def_id(trait_id), substs);\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -1757,8 +1771,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n-        def_id: DefId::local(param_id),\n-        default_def_id: DefId::local(parent),\n+        def_id: ccx.tcx.map.local_def_id(param_id),\n+        default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: None,\n         object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n     };\n@@ -1877,9 +1891,10 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n+        let def_id = tcx.map.local_def_id(param.lifetime.id);\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: param.lifetime.id,\n+                param_id: def_id,\n                 space: space,\n                 index: index,\n                 name: param.lifetime.name\n@@ -1965,7 +1980,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n                                            index: i as u32,\n-                                           def_id: DefId::local(l.lifetime.id),\n+                                           def_id: ccx.tcx.map.local_def_id(l.lifetime.id),\n                                            bounds: bounds };\n         result.regions.push(space, def);\n     }\n@@ -2033,8 +2048,8 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         space: space,\n         index: index,\n         name: param.name,\n-        def_id: DefId::local(param.id),\n-        default_def_id: DefId::local(parent),\n+        def_id: ccx.tcx.map.local_def_id(param.id),\n+        default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     };\n@@ -2377,7 +2392,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         tcx.fold_regions(value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n-                    let def_id = DefId::local(data.param_id);\n+                    let def_id = data.param_id;\n                     ty::ReFree(ty::FreeRegion { scope: scope,\n                                                 bound_region: ty::BrNamed(def_id, data.name) })\n                 }\n@@ -2424,7 +2439,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .map(|item| tcx.impl_or_trait_item(DefId::local(item.id)))\n+                  .map(|item| tcx.impl_or_trait_item(tcx.map.local_def_id(item.id)))\n                   .filter_map(|item| match item {\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n@@ -2437,7 +2452,8 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n-        let region = ty::EarlyBoundRegion { param_id: lifetime_def.lifetime.id,\n+        let def_id = tcx.map.local_def_id(lifetime_def.lifetime.id);\n+        let region = ty::EarlyBoundRegion { param_id: def_id,\n                                             space: TypeSpace,\n                                             index: index as u32,\n                                             name: lifetime_def.lifetime.name };"}, {"sha": "7156c9c6091a7b4fb9810b55fe271fc008f4906b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -98,20 +98,20 @@ extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n \n+pub use rustc::front;\n pub use rustc::lint;\n pub use rustc::metadata;\n pub use rustc::middle;\n pub use rustc::session;\n pub use rustc::util;\n \n+use front::map as hir_map;\n use middle::def;\n-use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::ty::{self, Ty, HasTypeFlags};\n use session::config;\n use util::common::time;\n-use rustc::front::map as hir_map;\n use rustc_front::hir;\n \n use syntax::codemap::Span;\n@@ -239,7 +239,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = tcx.mk_fn(Some(DefId::local(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let main_def_id = tcx.map.local_def_id(main_id);\n+            let se_ty = tcx.mk_fn(Some(main_def_id), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -285,7 +286,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = tcx.mk_fn(Some(DefId::local(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(start_id)),\n+                                  tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {"}, {"sha": "86a97f305aa6962121c728e728733abd60d4f11c", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -452,9 +452,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // \"invalid item id\" from \"item id with no\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n+            let item_def_id = self.tcx.map.local_def_id(item_id);\n             let newly_added =\n                 self.tcx.item_variance_map.borrow_mut().insert(\n-                    DefId::local(item_id),\n+                    item_def_id,\n                     self.empty_variances.clone()).is_none();\n             assert!(newly_added);\n         }\n@@ -487,7 +488,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               self.tcx.item_path_str(DefId::local(item_id)),\n+               self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n                item_id, kind, space, index, param_id, inf_index,\n                initial_variance);\n     }\n@@ -597,8 +598,8 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let did = DefId::local(item.id);\n         let tcx = self.terms_cx.tcx;\n+        let did = tcx.map.local_def_id(item.id);\n \n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n@@ -1012,8 +1013,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                if self.is_to_be_inferred(data.param_id) {\n-                    let index = self.inferred_index(data.param_id);\n+                let node_id = self.tcx().map.as_local_node_id(data.param_id).unwrap();\n+                if self.is_to_be_inferred(node_id) {\n+                    let index = self.inferred_index(node_id);\n                     self.add_constraint(index, variance);\n                 }\n             }\n@@ -1164,7 +1166,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     item_id,\n                     item_variances);\n \n-            let item_def_id = DefId::local(item_id);\n+            let item_def_id = tcx.map.local_def_id(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found."}, {"sha": "e6580a2c03778b060e4a22e091b8cb6b2a5f4b3a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(hir::Public),\n                     stability: None,\n-                    def_id: DefId::local(prim.to_node_id()),\n+                    def_id: cx.map.local_def_id(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n                 });\n             }\n@@ -420,7 +420,7 @@ impl Clean<Item> for doctree::Module {\n             source: whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -1088,7 +1088,7 @@ impl Clean<Item> for doctree::Function {\n             source: self.whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1211,7 +1211,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TraitItem(Trait {\n@@ -1261,9 +1261,9 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1294,9 +1294,9 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1660,7 +1660,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (DefId::local(0), &fty.sig).clean(cx),\n+                decl: (cx.map.local_def_id(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n             ty::TyStruct(def, substs) |\n@@ -1728,8 +1728,8 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.node.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Some(vis),\n-            stability: get_stability(cx, DefId::local(self.node.id)),\n-            def_id: DefId::local(self.node.id),\n+            stability: get_stability(cx, cx.map.local_def_id(self.node.id)),\n+            def_id: cx.map.local_def_id(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n     }\n@@ -1782,7 +1782,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StructItem(Struct {\n@@ -1828,7 +1828,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: EnumItem(Enum {\n@@ -1853,7 +1853,7 @@ impl Clean<Item> for doctree::Variant {\n             source: self.whence.clean(cx),\n             visibility: None,\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(cx),\n             }),\n@@ -2083,7 +2083,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id.clone()),\n+            def_id: cx.map.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TypedefItem(Typedef {\n@@ -2134,7 +2134,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StaticItem(Static {\n@@ -2158,7 +2158,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ConstantItem(Constant {\n@@ -2232,7 +2232,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ImplItem(Impl {\n@@ -2314,7 +2314,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: Some(hir::Public),\n             stability: None,\n             inner: DefaultImplItem(DefaultImpl {\n@@ -2331,7 +2331,7 @@ impl Clean<Item> for doctree::ExternCrate {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(0),\n+            def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n@@ -2396,7 +2396,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(0),\n+            def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ImportItem(inner)\n@@ -2482,9 +2482,9 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2662,7 +2662,7 @@ impl Clean<Item> for doctree::Macro {\n             source: self.whence.clean(cx),\n             visibility: hir::Public.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: MacroItem(Macro {\n                 source: self.whence.to_src(cx),\n                 imported_from: self.imported_from.clean(cx),"}, {"sha": "8bc832a68dbd7dd7a2b87636387d5a309614492d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -19,7 +19,6 @@ use rustc::lint;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_front::lowering::lower_crate;\n-use rustc_front::hir;\n \n use syntax::{ast, codemap, diagnostic};\n use syntax::feature_gate::UnstableFeatures;\n@@ -44,7 +43,7 @@ pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n-    pub krate: &'tcx hir::Crate,\n+    pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n     pub external_paths: ExternalPaths,\n@@ -148,7 +147,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n \n         let ctxt = DocContext {\n-            krate: tcx.map.krate(),\n+            map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n             external_traits: RefCell::new(Some(HashMap::new())),\n@@ -158,7 +157,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n             populated_crate_impls: RefCell::new(HashSet::new()),\n             deref_trait_did: Cell::new(None),\n         };\n-        debug!(\"crate: {:?}\", ctxt.krate);\n+        debug!(\"crate: {:?}\", ctxt.map.krate());\n \n         let mut analysis = CrateAnalysis {\n             exported_items: exported_items,\n@@ -171,7 +170,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n         let krate = {\n             let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-            v.visit(ctxt.krate);\n+            v.visit(ctxt.map.krate());\n             v.clean(&ctxt)\n         };\n "}, {"sha": "c392e75ebf91a4cc5926ebaaeca3de642fb94f52", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -214,7 +214,7 @@ pub struct Cache {\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_methods: Vec<(ast::NodeId, clean::Item)>,\n+    orphan_methods: Vec<(DefId, clean::Item)>,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -460,8 +460,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in orphan_methods {\n-            let did = DefId::local(pid);\n+        for &(did, ref item) in orphan_methods {\n             match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n                     // Needed to determine `self` type.\n@@ -969,7 +968,7 @@ impl DocFolder for Cache {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent.node, item.clone()))\n+                        self.orphan_methods.push((parent, item.clone()))\n                     }\n                 }\n                 _ => {}\n@@ -1034,7 +1033,7 @@ impl DocFolder for Cache {\n                     ref t => {\n                         match t.primitive_type() {\n                             Some(prim) => {\n-                                let did = DefId::local(prim.to_node_id());\n+                                let did = DefId::xxx_local(prim.to_node_id()); // TODO\n                                 self.parent_stack.push(did);\n                                 true\n                             }"}, {"sha": "387e1a8cc07273f857b22da06456b61b513b603f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -22,6 +22,7 @@ use std::sync::{Arc, Mutex};\n \n use testing;\n use rustc_lint;\n+use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -86,8 +87,11 @@ pub fn run(input: &str,\n \n     let opts = scrape_test_config(&krate);\n \n+    let mut forest = hir_map::Forest::new(krate);\n+    let map = hir_map::map_crate(&mut forest);\n+\n     let ctx = core::DocContext {\n-        krate: &krate,\n+        map: &map,\n         maybe_typed: core::NotTyped(sess),\n         input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n@@ -99,7 +103,7 @@ pub fn run(input: &str,\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);\n-    v.visit(ctx.krate);\n+    v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,"}, {"sha": "f9c8f2a0b8dff73dc0e17a8feb2c131ae57d34f0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff4f57cd0ee0537b9135a97547daf1131f0bc17/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9ff4f57cd0ee0537b9135a97547daf1131f0bc17", "patch": "@@ -21,7 +21,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n use rustc::front::map as hir_map;\n-use rustc::middle::def_id::DefId;\n use rustc::middle::stability;\n \n use rustc_front::hir;\n@@ -64,7 +63,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx_opt().and_then(\n-            |tcx| stability::lookup(tcx, DefId::local(id)).map(|x| x.clone()))\n+            |tcx| stability::lookup(tcx, self.cx.map.local_def_id(id)).map(|x| x.clone()))\n     }\n \n     pub fn visit(&mut self, krate: &hir::Crate) {"}]}