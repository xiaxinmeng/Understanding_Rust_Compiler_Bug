{"sha": "944d904ad4b4fdef90a2f2267fac206de205f3a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NGQ5MDRhZDRiNGZkZWY5MGEyZjIyNjdmYWMyMDZkZTIwNWYzYTA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T04:54:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T14:46:50Z"}, "message": "Convert vec::{split, splitn, rsplit, rsplitn} to external iterators.", "tree": {"sha": "c6f4af39069b0eb1f8b86fe4330468af7ddac57c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6f4af39069b0eb1f8b86fe4330468af7ddac57c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/944d904ad4b4fdef90a2f2267fac206de205f3a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/944d904ad4b4fdef90a2f2267fac206de205f3a0", "html_url": "https://github.com/rust-lang/rust/commit/944d904ad4b4fdef90a2f2267fac206de205f3a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/944d904ad4b4fdef90a2f2267fac206de205f3a0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f19fb2459f4fc695225f996692a6a6b30b801ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f19fb2459f4fc695225f996692a6a6b30b801ee9", "html_url": "https://github.com/rust-lang/rust/commit/f19fb2459f4fc695225f996692a6a6b30b801ee9"}], "stats": {"total": 421, "additions": 158, "deletions": 263}, "files": [{"sha": "53a7f71221a4b1430f2479a8f081f20ca3fdcbbf", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 158, "deletions": 263, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/944d904ad4b4fdef90a2f2267fac206de205f3a0/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944d904ad4b4fdef90a2f2267fac206de205f3a0/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=944d904ad4b4fdef90a2f2267fac206de205f3a0", "patch": "@@ -173,105 +173,70 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n     build_sized(size.get_or_default(4), builder)\n }\n \n-// Accessors\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct VecSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n+}\n \n-/// Copies\n+impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-/// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n+        }\n \n-    let mut start = 0u;\n-    let mut result = ~[];\n-    while start < ln {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                start += i + 1u;\n+        match self.v.iter().position_(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                self.n -= 1;\n+                ret\n             }\n         }\n     }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n }\n \n-/**\n- * Split the vector `v` by applying each element against the predicate `f` up\n- * to `n` times.\n- */\n-pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n-\n-    let mut start = 0u;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while start < ln && count > 0u {\n-        match v.slice(start, ln).iter().position_(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(start, start + i).to_owned());\n-                // Make sure to skip the separator.\n-                start += i + 1u;\n-                count -= 1u;\n-            }\n-        }\n-    }\n-    result.push(v.slice(start, ln).to_owned());\n-    result\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, from back to front.\n+pub struct VecRSplitIterator<'self, T> {\n+    priv v: &'self [T],\n+    priv n: uint,\n+    priv pred: &'self fn(t: &T) -> bool,\n+    priv finished: bool\n }\n \n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f`.\n- */\n-pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0) { return ~[] }\n+impl<'self, T> Iterator<&'self [T]> for VecRSplitIterator<'self, T> {\n+    fn next(&mut self) -> Option<&'self [T]> {\n+        if self.finished { return None; }\n \n-    let mut end = ln;\n-    let mut result = ~[];\n-    while end > 0 {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1, end).to_owned());\n-                end = i;\n-            }\n+        if self.n == 0 {\n+            self.finished = true;\n+            return Some(self.v);\n         }\n-    }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n-}\n-\n-/**\n- * Reverse split the vector `v` by applying each element against the predicate\n- * `f` up to `n times.\n- */\n-pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = v.len();\n-    if (ln == 0u) { return ~[] }\n \n-    let mut end = ln;\n-    let mut count = n;\n-    let mut result = ~[];\n-    while end > 0u && count > 0u {\n-        match v.slice(0, end).rposition(|t| f(t)) {\n-            None => break,\n-            Some(i) => {\n-                result.push(v.slice(i + 1u, end).to_owned());\n-                // Make sure to skip the separator.\n-                end = i;\n-                count -= 1u;\n+        match self.v.rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                self.n -= 1;\n+                ret\n             }\n         }\n     }\n-    result.push(v.slice(0u, end).to_owned());\n-    result.reverse();\n-    result\n }\n \n // Appending\n@@ -758,6 +723,11 @@ pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n     fn rev_iter(self) -> VecRevIterator<'self, T>;\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+\n     fn head(&self) -> &'self T;\n     fn head_opt(&self) -> Option<&'self T>;\n     fn tail(&self) -> &'self [T];\n@@ -808,6 +778,45 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         }\n     }\n \n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.\n+    #[inline]\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        self.splitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.\n+    #[inline]\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+        VecSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`. This starts at the\n+    /// end of the vector and works backwards.\n+    #[inline]\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        self.rsplitn_iter(uint::max_value, pred)\n+    }\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.\n+    #[inline]\n+    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+        VecRSplitIterator {\n+            v: self,\n+            n: n,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n     fn head(&self) -> &'self T {\n@@ -2614,50 +2623,6 @@ mod tests {\n         assert!(v3.is_empty());\n     }\n \n-    #[test]\n-    fn test_split() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(split([], f), ~[]);\n-        assert_eq!(split([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(split([3, 1, 2], f), ~[~[], ~[1, 2]]);\n-        assert_eq!(split([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert_eq!(split([1, 2, 3, 4, 3, 5], f), ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_splitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(splitn([], 1u, f), ~[]);\n-        assert_eq!(splitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(splitn([3, 1, 2], 1u, f), ~[~[], ~[1, 2]]);\n-        assert_eq!(splitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert!(splitn([1, 2, 3, 4, 3, 5], 1u, f) ==\n-                      ~[~[1, 2], ~[4, 3, 5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplit() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplit([], f), ~[]);\n-        assert_eq!(rsplit([1, 2], f), ~[~[1, 2]]);\n-        assert_eq!(rsplit([1, 2, 3], f), ~[~[1, 2], ~[]]);\n-        assert!(rsplit([1, 2, 3, 4, 3, 5], f) ==\n-            ~[~[1, 2], ~[4], ~[5]]);\n-    }\n-\n-    #[test]\n-    fn test_rsplitn() {\n-        fn f(x: &int) -> bool { *x == 3 }\n-\n-        assert_eq!(rsplitn([], 1u, f), ~[]);\n-        assert_eq!(rsplitn([1, 2], 1u, f), ~[~[1, 2]]);\n-        assert_eq!(rsplitn([1, 2, 3], 1u, f), ~[~[1, 2], ~[]]);\n-        assert_eq!(rsplitn([1, 2, 3, 4, 3, 5], 1u, f), ~[~[1, 2, 3, 4], ~[5]]);\n-    }\n-\n     #[test]\n     fn test_partition() {\n         assert_eq!((~[]).partition(|x: &int| *x < 3), (~[], ~[]));\n@@ -2823,142 +2788,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_split_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do splitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_splitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do split(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplit_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplit(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_true() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_rsplitn_fail_ret_false() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do rsplitn(v, 100) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-\n-            false\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3140,6 +2969,72 @@ mod tests {\n         assert_eq!(xs.consume_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n+    #[test]\n+    fn test_split_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.split_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3], &[5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[], &[2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4], &[]]);\n+        assert_eq!(xs.split_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.split_iter(|_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[], &[], &[]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_splitn_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.splitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.splitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1], &[3,4,5]]);\n+        assert_eq!(xs.splitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.splitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplit_iterator() {\n+        let xs = &[1i,2,3,4,5];\n+\n+        assert_eq!(xs.rsplit_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[3], &[1]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+                   ~[&[2,3,4,5], &[]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+                   ~[&[], &[1,2,3,4]]);\n+        assert_eq!(xs.rsplit_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n+    #[test]\n+    fn test_rsplitn_iterator() {\n+        let xs = &[1,2,3,4,5];\n+\n+        assert_eq!(xs.rsplitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[1,2,3,4,5]]);\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+                   ~[&[5], &[1,2,3]]);\n+        assert_eq!(xs.rsplitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+                   ~[&[], &[], &[], &[1,2]]);\n+\n+        let xs: &[int] = &[];\n+        assert_eq!(xs.rsplitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+    }\n+\n     #[test]\n     fn test_move_from() {\n         let mut a = [1,2,3,4,5];"}]}