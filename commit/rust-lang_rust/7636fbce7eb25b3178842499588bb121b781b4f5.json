{"sha": "7636fbce7eb25b3178842499588bb121b781b4f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MzZmYmNlN2ViMjViMzE3ODg0MjQ5OTU4OGJiMTIxYjc4MWI0ZjU=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-08T14:31:47Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-08T14:31:47Z"}, "message": "Merge commit '27afd6ade4bb1123a8bf82001629b69d23d62aff' into clippyup", "tree": {"sha": "8088ff374214eccc1eabdccda8085ae16b2ddbd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8088ff374214eccc1eabdccda8085ae16b2ddbd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7636fbce7eb25b3178842499588bb121b781b4f5", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmE4yVcACgkQHKDfKvWd\naKXQvhAAh0Yol8X6asDnMNet0Mnd6EPa2cqasaa/cc9Ka5/zJMKI8EJe+c4XaP2v\nDff2mBYAOpgwHkYgJ2Ok1rzDBnTbDn1JA4OoXZdiDwdmbebBwv40jO+H5o2vKFMi\n20bCR8ebXoWjwJQeMFPSE3jWtOrLKYFEDLpuZE7GVVsPLuwF3xjJZlHpfK6zpjIW\nUmP/NYJbxUfQpX/G9pD6XT/qcGQVnIO+nS1LsnwFB20FwLkB0Ylb1TZ7AgaU2Svb\nWBv25/f6WHHhl9aGHxsbrnV8rioTuYcamHBl23EDm5VCxLTAMFzKg7RXkh1YKExj\nwDASqYdoj2C+cA/GXt7yL+Hmxt3SOj4b6Ljuu5mNtb63d0fo3KmkOKY3d5aZoZVn\n5SJOpDNSaT5ZfCFds7SR0juCkZg91eefi3LXv2SvVX5FoNnazzcaps3byqZuChHo\n4uwaMmfTGrpvsf0lBB2hAK1OdNRIF0kVr+yht7lyVxyjjTVL3NWXXtn8xPLrVcXm\nmYBpHFQU7FTee/KHiG+K0ub8Tix/6cLchBWwicfx2XSeUcEx8/xCtXgt5CL7oXLG\nV6jIEK12TwSCvFxh1DXzRfq1/ab8qxk+GU9DuYQItShYwIrQCDLy0UMG026cqgg6\nAFa8A52fuKtnNpXxtOLCnKyWuyr0GqBCdeUXufKR2IczeLuuoEY=\n=kK8T\n-----END PGP SIGNATURE-----", "payload": "tree 8088ff374214eccc1eabdccda8085ae16b2ddbd5\nparent 434cb437b55d61bcb54a01921de7ac752e6dee13\nparent 27afd6ade4bb1123a8bf82001629b69d23d62aff\nauthor flip1995 <philipp.krones@embecosm.com> 1631111507 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1631111507 +0200\n\nMerge commit '27afd6ade4bb1123a8bf82001629b69d23d62aff' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7636fbce7eb25b3178842499588bb121b781b4f5", "html_url": "https://github.com/rust-lang/rust/commit/7636fbce7eb25b3178842499588bb121b781b4f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7636fbce7eb25b3178842499588bb121b781b4f5/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "434cb437b55d61bcb54a01921de7ac752e6dee13", "url": "https://api.github.com/repos/rust-lang/rust/commits/434cb437b55d61bcb54a01921de7ac752e6dee13", "html_url": "https://github.com/rust-lang/rust/commit/434cb437b55d61bcb54a01921de7ac752e6dee13"}, {"sha": "27afd6ade4bb1123a8bf82001629b69d23d62aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/27afd6ade4bb1123a8bf82001629b69d23d62aff", "html_url": "https://github.com/rust-lang/rust/commit/27afd6ade4bb1123a8bf82001629b69d23d62aff"}], "stats": {"total": 5428, "additions": 4143, "deletions": 1285}, "files": [{"sha": "84ae36a46d71de51a394f27bc3fe2533c2ccec60", "filename": "src/tools/clippy/.cargo/config", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.cargo%2Fconfig?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -5,4 +5,5 @@ lintcheck = \"run --target-dir lintcheck/target --package lintcheck --bin lintche\n collect-metadata = \"test --test dogfood --features metadata-collector-lint -- run_metadata_collection_lint --ignored\"\n \n [build]\n-rustflags = [\"-Zunstable-options\"]\n+# -Zbinary-dep-depinfo allows us to track which rlib files to use for compiling UI tests\n+rustflags = [\"-Zunstable-options\", \"-Zbinary-dep-depinfo\"]"}, {"sha": "2891d5e5da1e1ec7490817e6089a867ad1c47ff4", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/blank_issue.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -2,3 +2,17 @@\n name: Blank Issue\n about: Create a blank issue.\n ---\n+\n+\n+<!--\n+Additional labels can be added to this issue by including the following command\n+(without the space after the @ symbol):\n+\n+`@rustbot label +<label>`\n+\n+Common labels for this issue type are:\n+* C-an-interesting-project\n+* C-enhancement\n+* C-question\n+* C-tracking-issue\n+-->"}, {"sha": "87c18cdee66c5d24d96ddf95aafe305a9b2beaf7", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -20,28 +20,24 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n \n <!--\n-Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n-environment. E.g. `RUST_BACKTRACE=1 cargo clippy`.\n+Additional labels can be added to this issue by including the following command\n+(without the space after the @ symbol):\n+\n+`@rustbot label +<label>`\n+\n+Common labels for this issue type are:\n+* `I-suggestion-causes-error`\n -->\n-<details><summary>Backtrace</summary>\n-  <p>\n-  \n-  ```\n-  <backtrace>\n-  ```\n-  \n-  </p>\n-</details>"}, {"sha": "d9ea2db34edd7cf74a9789f17801005a3e0762e9", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_negative.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -22,14 +22,14 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```"}, {"sha": "4170b9ff2dbe5d149854fa8c2167efc4fec45a52", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_positive.md", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -22,14 +22,23 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n+\n+<!--\n+Additional labels can be added to this issue by including the following command\n+(without the space after the @ symbol):\n+\n+`@rustbot label +<label>`\n+\n+Common labels for this issue type are:\n+* I-suggestion-causes-error\n+-->"}, {"sha": "6c1bed663c6cb37f74bb9dfd9f4226560bc8837c", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -20,17 +20,16 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n \n ### Error output\n "}, {"sha": "9a5416153abdb62856d4ad34305f806294aa43f9", "filename": "src/tools/clippy/.github/workflows/clippy_dev.yml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -42,9 +42,6 @@ jobs:\n       run: cargo build --features deny-warnings\n       working-directory: clippy_dev\n \n-    - name: Test limit_stderr_length\n-      run: cargo dev limit_stderr_length\n-\n     - name: Test update_lints\n       run: cargo dev update_lints --check\n "}, {"sha": "f5ac2f7c9f8c92a596aeb79401441bb8eaf4c3b3", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -964,7 +964,7 @@ Released 2020-11-19\n   [#5907](https://github.com/rust-lang/rust-clippy/pull/5907)\n * [`suspicious_arithmetic_impl`]: extend to implementations of `BitAnd`, `BitOr`, `BitXor`, `Rem`, `Shl`, and `Shr`\n   [#5884](https://github.com/rust-lang/rust-clippy/pull/5884)\n-* [`invalid_atomic_ordering`]: detect misuse of `compare_exchange`, `compare_exchange_weak`, and `fetch_update`\n+* `invalid_atomic_ordering`: detect misuse of `compare_exchange`, `compare_exchange_weak`, and `fetch_update`\n   [#6025](https://github.com/rust-lang/rust-clippy/pull/6025)\n * Avoid [`redundant_pattern_matching`] triggering in macros\n   [#6069](https://github.com/rust-lang/rust-clippy/pull/6069)\n@@ -1451,7 +1451,7 @@ Released 2020-03-12\n * [`option_as_ref_deref`] [#4945](https://github.com/rust-lang/rust-clippy/pull/4945)\n * [`wildcard_in_or_patterns`] [#4960](https://github.com/rust-lang/rust-clippy/pull/4960)\n * [`iter_nth_zero`] [#4966](https://github.com/rust-lang/rust-clippy/pull/4966)\n-* [`invalid_atomic_ordering`] [#4999](https://github.com/rust-lang/rust-clippy/pull/4999)\n+* `invalid_atomic_ordering` [#4999](https://github.com/rust-lang/rust-clippy/pull/4999)\n * [`skip_while_next`] [#5067](https://github.com/rust-lang/rust-clippy/pull/5067)\n \n ### Moves and Deprecations\n@@ -2613,6 +2613,7 @@ Released 2018-09-13\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n+[`derivable_impls`]: https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n@@ -2712,7 +2713,6 @@ Released 2018-09-13\n [`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n [`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n-[`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n [`invalid_null_ptr_usage`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_null_ptr_usage\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n@@ -2754,6 +2754,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n@@ -2795,6 +2796,7 @@ Released 2018-09-13\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n [`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n [`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n+[`mod_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#mod_module_files\n [`module_inception`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\n [`module_name_repetitions`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions\n [`modulo_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_arithmetic\n@@ -2821,13 +2823,15 @@ Released 2018-09-13\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n [`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n+[`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n [`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n [`neg_cmp_op_on_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_cmp_op_on_partial_ord\n [`neg_multiply`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_multiply\n+[`negative_feature_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#negative_feature_names\n [`never_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#never_loop\n [`new_ret_no_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_ret_no_self\n [`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n@@ -2881,6 +2885,7 @@ Released 2018-09-13\n [`redundant_closure_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_closure_for_method_calls`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_for_method_calls\n [`redundant_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_else\n+[`redundant_feature_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_feature_names\n [`redundant_field_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n [`redundant_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern\n [`redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n@@ -2903,6 +2908,7 @@ Released 2018-09-13\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`self_named_constructors`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_constructors\n+[`self_named_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_module_files\n [`semicolon_if_nothing_returned`]: https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_if_nothing_returned\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse"}, {"sha": "2310370fb9fbe7eaed80f888f40633a2f8151fd3", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.56\"\n+version = \"0.1.57\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -32,11 +32,7 @@ tempfile = { version = \"3.1.0\", optional = true }\n cargo_metadata = \"0.12\"\n compiletest_rs = { version = \"0.6.0\", features = [\"tmp\"] }\n tester = \"0.9\"\n-serde = { version = \"1.0\", features = [\"derive\"] }\n-derive-new = \"0.5\"\n regex = \"1.4\"\n-quote = \"1\"\n-syn = { version = \"1\", features = [\"full\"] }\n # This is used by the `collect-metadata` alias.\n filetime = \"0.2\"\n \n@@ -45,6 +41,15 @@ filetime = \"0.2\"\n # for more information.\n rustc-workspace-hack = \"1.0.0\"\n \n+# UI test dependencies\n+clippy_utils = { path = \"clippy_utils\" }\n+derive-new = \"0.5\"\n+if_chain = \"1.0\"\n+itertools = \"0.10.1\"\n+quote = \"1\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+syn = { version = \"1\", features = [\"full\"] }\n+\n [build-dependencies]\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n "}, {"sha": "aaf404eadea11e9ac52730c83a8331fa1ded4e4e", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -45,13 +45,13 @@ or in Travis CI.\n One way to use Clippy is by installing Clippy through rustup as a cargo\n subcommand.\n \n-#### Step 1: Install rustup\n+#### Step 1: Install Rustup\n \n-You can install [rustup](https://rustup.rs/) on supported platforms. This will help\n+You can install [Rustup](https://rustup.rs/) on supported platforms. This will help\n us install Clippy and its dependencies.\n \n-If you already have rustup installed, update to ensure you have the latest\n-rustup and compiler:\n+If you already have Rustup installed, update to ensure you have the latest\n+Rustup and compiler:\n \n ```terminal\n rustup update"}, {"sha": "e05db7af58677cd0f30c84fabf39fd7c40780df0", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -17,7 +17,6 @@ pub mod fmt;\n pub mod new_lint;\n pub mod serve;\n pub mod setup;\n-pub mod stderr_length_check;\n pub mod update_lints;\n \n static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {"}, {"sha": "8fdeba9842af3e6f80070aa055e2a28dd70ff000", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -3,7 +3,7 @@\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};\n-use clippy_dev::{bless, fmt, new_lint, serve, setup, stderr_length_check, update_lints};\n+use clippy_dev::{bless, fmt, new_lint, serve, setup, update_lints};\n fn main() {\n     let matches = get_clap_config();\n \n@@ -33,9 +33,6 @@ fn main() {\n                 Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n             }\n         },\n-        (\"limit_stderr_length\", _) => {\n-            stderr_length_check::check();\n-        },\n         (\"setup\", Some(sub_command)) => match sub_command.subcommand() {\n             (\"intellij\", Some(matches)) => setup::intellij::setup_rustc_src(\n                 matches\n@@ -152,10 +149,6 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         .takes_value(true),\n                 ),\n         )\n-        .subcommand(\n-            SubCommand::with_name(\"limit_stderr_length\")\n-                .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n-        )\n         .subcommand(\n             SubCommand::with_name(\"setup\")\n                 .about(\"Support for setting up your personal development environment\")"}, {"sha": "e02b6f7da5f7b66e7653403d2f823984eb000ce4", "filename": "src/tools/clippy/clippy_dev/src/stderr_length_check.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fstderr_length_check.rs?ref=434cb437b55d61bcb54a01921de7ac752e6dee13", "patch": "@@ -1,51 +0,0 @@\n-use crate::clippy_project_root;\n-use std::ffi::OsStr;\n-use std::fs;\n-use std::path::{Path, PathBuf};\n-use walkdir::WalkDir;\n-\n-// The maximum length allowed for stderr files.\n-//\n-// We limit this because small files are easier to deal with than bigger files.\n-const LENGTH_LIMIT: usize = 200;\n-\n-pub fn check() {\n-    let exceeding_files: Vec<_> = exceeding_stderr_files();\n-\n-    if !exceeding_files.is_empty() {\n-        eprintln!(\"Error: stderr files exceeding limit of {} lines:\", LENGTH_LIMIT);\n-        for (path, count) in exceeding_files {\n-            println!(\"{}: {}\", path.display(), count);\n-        }\n-        std::process::exit(1);\n-    }\n-}\n-\n-fn exceeding_stderr_files() -> Vec<(PathBuf, usize)> {\n-    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n-    WalkDir::new(clippy_project_root().join(\"tests/ui\"))\n-        .into_iter()\n-        .filter_map(Result::ok)\n-        .filter(|f| !f.file_type().is_dir())\n-        .filter_map(|e| {\n-            let p = e.into_path();\n-            let count = count_linenumbers(&p);\n-            if p.extension() == Some(OsStr::new(\"stderr\")) && count > LENGTH_LIMIT {\n-                Some((p, count))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect()\n-}\n-\n-#[must_use]\n-fn count_linenumbers(filepath: &Path) -> usize {\n-    match fs::read(filepath) {\n-        Ok(content) => bytecount::count(&content, b'\\n'),\n-        Err(e) => {\n-            eprintln!(\"Failed to read file: {}\", e);\n-            0\n-        },\n-    }\n-}"}, {"sha": "3c28024bf926a4e1243ce0d52910223d28da0562", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,8 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-# begin automatic update\n-version = \"0.1.56\"\n-# end automatic update\n+version = \"0.1.57\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "fb54ac1ec511981595402d73dfd3bba329b3e903", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "modified", "additions": 70, "deletions": 54, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,8 +1,10 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{meets_msrv, msrvs};\n use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol;\n use std::f64::consts as f64;\n \n@@ -36,68 +38,82 @@ declare_clippy_lint! {\n     \"the approximate of a known float constant (in `std::fXX::consts`)\"\n }\n \n-// Tuples are of the form (constant, name, min_digits)\n-const KNOWN_CONSTS: [(f64, &str, usize); 18] = [\n-    (f64::E, \"E\", 4),\n-    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n-    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n-    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n-    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n-    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n-    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n-    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n-    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n-    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n-    (f64::LN_10, \"LN_10\", 5),\n-    (f64::LN_2, \"LN_2\", 5),\n-    (f64::LOG10_E, \"LOG10_E\", 5),\n-    (f64::LOG2_E, \"LOG2_E\", 5),\n-    (f64::LOG2_10, \"LOG2_10\", 5),\n-    (f64::LOG10_2, \"LOG10_2\", 5),\n-    (f64::PI, \"PI\", 3),\n-    (f64::SQRT_2, \"SQRT_2\", 5),\n+// Tuples are of the form (constant, name, min_digits, msrv)\n+const KNOWN_CONSTS: [(f64, &str, usize, Option<RustcVersion>); 19] = [\n+    (f64::E, \"E\", 4, None),\n+    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4, None),\n+    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5, None),\n+    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5, None),\n+    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5, None),\n+    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5, None),\n+    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5, None),\n+    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5, None),\n+    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5, None),\n+    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5, None),\n+    (f64::LN_2, \"LN_2\", 5, None),\n+    (f64::LN_10, \"LN_10\", 5, None),\n+    (f64::LOG2_10, \"LOG2_10\", 5, Some(msrvs::LOG2_10)),\n+    (f64::LOG2_E, \"LOG2_E\", 5, None),\n+    (f64::LOG10_2, \"LOG10_2\", 5, Some(msrvs::LOG10_2)),\n+    (f64::LOG10_E, \"LOG10_E\", 5, None),\n+    (f64::PI, \"PI\", 3, None),\n+    (f64::SQRT_2, \"SQRT_2\", 5, None),\n+    (f64::TAU, \"TAU\", 3, Some(msrvs::TAU)),\n ];\n \n-declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n+pub struct ApproxConstant {\n+    msrv: Option<RustcVersion>,\n+}\n \n-impl<'tcx> LateLintPass<'tcx> for ApproxConstant {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Lit(lit) = &e.kind {\n-            check_lit(cx, &lit.node, e);\n+impl ApproxConstant {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+\n+    fn check_lit(&self, cx: &LateContext<'_>, lit: &LitKind, e: &Expr<'_>) {\n+        match *lit {\n+            LitKind::Float(s, LitFloatType::Suffixed(fty)) => match fty {\n+                FloatTy::F32 => self.check_known_consts(cx, e, s, \"f32\"),\n+                FloatTy::F64 => self.check_known_consts(cx, e, s, \"f64\"),\n+            },\n+            LitKind::Float(s, LitFloatType::Unsuffixed) => self.check_known_consts(cx, e, s, \"f{32, 64}\"),\n+            _ => (),\n         }\n     }\n-}\n \n-fn check_lit(cx: &LateContext<'_>, lit: &LitKind, e: &Expr<'_>) {\n-    match *lit {\n-        LitKind::Float(s, LitFloatType::Suffixed(fty)) => match fty {\n-            FloatTy::F32 => check_known_consts(cx, e, s, \"f32\"),\n-            FloatTy::F64 => check_known_consts(cx, e, s, \"f64\"),\n-        },\n-        LitKind::Float(s, LitFloatType::Unsuffixed) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n-        _ => (),\n+    fn check_known_consts(&self, cx: &LateContext<'_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n+        let s = s.as_str();\n+        if s.parse::<f64>().is_ok() {\n+            for &(constant, name, min_digits, msrv) in &KNOWN_CONSTS {\n+                if is_approx_const(constant, &s, min_digits)\n+                    && msrv.as_ref().map_or(true, |msrv| meets_msrv(self.msrv.as_ref(), msrv))\n+                {\n+                    span_lint_and_help(\n+                        cx,\n+                        APPROX_CONSTANT,\n+                        e.span,\n+                        &format!(\"approximate value of `{}::consts::{}` found\", module, &name),\n+                        None,\n+                        \"consider using the constant directly\",\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n     }\n }\n \n-fn check_known_consts(cx: &LateContext<'_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n-    let s = s.as_str();\n-    if s.parse::<f64>().is_ok() {\n-        for &(constant, name, min_digits) in &KNOWN_CONSTS {\n-            if is_approx_const(constant, &s, min_digits) {\n-                span_lint(\n-                    cx,\n-                    APPROX_CONSTANT,\n-                    e.span,\n-                    &format!(\n-                        \"approximate value of `{}::consts::{}` found. \\\n-                         Consider using it directly\",\n-                        module, &name\n-                    ),\n-                );\n-                return;\n-            }\n+impl_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ApproxConstant {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Lit(lit) = &e.kind {\n+            self.check_lit(cx, &lit.node, e);\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n /// Returns `false` if the number of significant figures in `value` are"}, {"sha": "d834a1d317a0f1d7e9d3344fb764cc3a2ab866d4", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -118,7 +118,7 @@ enum AssertKind {\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n         if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n+        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block"}, {"sha": "47e5b0d583dabcee654d1613e6057a06459f5112", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -61,8 +61,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n             // do not lint if the closure is called using an iterator (see #1141)\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, _, args, _) = parent.kind;\n-                let caller = self.cx.typeck_results().expr_ty(&args[0]);\n+                if let ExprKind::MethodCall(_, _, [self_arg, ..], _) = &parent.kind;\n+                let caller = self.cx.typeck_results().expr_ty(self_arg);\n                 if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n                 if implements_trait(self.cx, caller, iter_id, &[]);\n                 then {"}, {"sha": "cdc192a47e48abebb325f95437ce48a1ee00dee6", "filename": "src/tools/clippy/clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,9 +1,11 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{ast_utils, is_direct_expn_of};\n-use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, higher, is_direct_expn_of, ty::implements_trait};\n+use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{Expr, ExprKind, Lit};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -28,45 +30,77 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BoolAssertComparison => [BOOL_ASSERT_COMPARISON]);\n \n-fn is_bool_lit(e: &Expr) -> bool {\n+fn is_bool_lit(e: &Expr<'_>) -> bool {\n     matches!(\n         e.kind,\n         ExprKind::Lit(Lit {\n-            kind: LitKind::Bool(_),\n+            node: LitKind::Bool(_),\n             ..\n         })\n     ) && !e.span.from_expansion()\n }\n \n-impl EarlyLintPass for BoolAssertComparison {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n+fn is_impl_not_trait_with_bool_out(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(e);\n+\n+    cx.tcx\n+        .lang_items()\n+        .not_trait()\n+        .filter(|trait_id| implements_trait(cx, ty, *trait_id, &[]))\n+        .and_then(|trait_id| {\n+            cx.tcx.associated_items(trait_id).find_by_name_and_kind(\n+                cx.tcx,\n+                Ident::from_str(\"Output\"),\n+                ty::AssocKind::Type,\n+                trait_id,\n+            )\n+        })\n+        .map_or(false, |assoc_item| {\n+            let proj = cx.tcx.mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n+            let nty = cx.tcx.normalize_erasing_regions(cx.param_env, proj);\n+\n+            nty.is_bool()\n+        })\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let macros = [\"assert_eq\", \"debug_assert_eq\"];\n         let inverted_macros = [\"assert_ne\", \"debug_assert_ne\"];\n \n         for mac in macros.iter().chain(inverted_macros.iter()) {\n-            if let Some(span) = is_direct_expn_of(e.span, mac) {\n-                if let Some([a, b]) = ast_utils::extract_assert_macro_args(e) {\n-                    let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+            if let Some(span) = is_direct_expn_of(expr.span, mac) {\n+                if let Some(args) = higher::extract_assert_macro_args(expr) {\n+                    if let [a, b, ..] = args[..] {\n+                        let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+\n+                        if nb_bool_args != 1 {\n+                            // If there are two boolean arguments, we definitely don't understand\n+                            // what's going on, so better leave things as is...\n+                            //\n+                            // Or there is simply no boolean and then we can leave things as is!\n+                            return;\n+                        }\n \n-                    if nb_bool_args != 1 {\n-                        // If there are two boolean arguments, we definitely don't understand\n-                        // what's going on, so better leave things as is...\n-                        //\n-                        // Or there is simply no boolean and then we can leave things as is!\n+                        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n+                            // At this point the expression which is not a boolean\n+                            // literal does not implement Not trait with a bool output,\n+                            // so we cannot suggest to rewrite our code\n+                            return;\n+                        }\n+\n+                        let non_eq_mac = &mac[..mac.len() - 3];\n+                        span_lint_and_sugg(\n+                            cx,\n+                            BOOL_ASSERT_COMPARISON,\n+                            span,\n+                            &format!(\"used `{}!` with a literal bool\", mac),\n+                            \"replace it with\",\n+                            format!(\"{}!(..)\", non_eq_mac),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                         return;\n                     }\n-\n-                    let non_eq_mac = &mac[..mac.len() - 3];\n-                    span_lint_and_sugg(\n-                        cx,\n-                        BOOL_ASSERT_COMPARISON,\n-                        span,\n-                        &format!(\"used `{}!` with a literal bool\", mac),\n-                        \"replace it with\",\n-                        format!(\"{}!(..)\", non_eq_mac),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return;\n                 }\n             }\n         }"}, {"sha": "a07cd5e5f4e53940be988f8fe12b8f968174d755", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                 return;\n             };\n             if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n+            if !is_local_used(cx, needle, arg_id);\n             then {\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n                         filter_recv.kind {"}, {"sha": "248b35b024ee1aa8a7a0b9f520c3ceab1b86f86f", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n             cx.typeck_results().expr_ty(expr),\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-    } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+    } else if let ExprKind::MethodCall(method_path, _, [self_arg, ..], _) = &expr.kind {\n         if_chain! {\n             if method_path.ident.name == sym!(cast);\n             if let Some(generic_args) = method_path.args;\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n             if !is_hir_ty_cfg_dependant(cx, cast_to);\n             then {\n                 let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                    (cx.typeck_results().expr_ty(self_arg), cx.typeck_results().expr_ty(expr));\n                 lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n             }\n         }"}, {"sha": "a4693fa213bc4a110470615ba12b9912754fe297", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{higher, is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::higher::IfLetOrMatch;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, MatchSource, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -56,11 +57,11 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n                         check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n                     }\n                 }\n-            }\n+            },\n             Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n                 check_arm(cx, false, pat, body, None, els);\n-            }\n-            None => {}\n+            },\n+            None => {},\n         }\n     }\n }\n@@ -71,7 +72,7 @@ fn check_arm<'tcx>(\n     outer_pat: &'tcx Pat<'tcx>,\n     outer_then_body: &'tcx Expr<'tcx>,\n     outer_guard: Option<&'tcx Guard<'tcx>>,\n-    outer_else_body: Option<&'tcx Expr<'tcx>>\n+    outer_else_body: Option<&'tcx Expr<'tcx>>,\n ) {\n     let inner_expr = strip_singleton_blocks(outer_then_body);\n     if_chain! {\n@@ -106,14 +107,13 @@ fn check_arm<'tcx>(\n             (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n         };\n         // the binding must not be used in the if guard\n-        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !used_visitor.check_expr(e));\n+        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !is_local_used(cx, *e, binding_id));\n         // ...or anywhere in the inner expression\n         if match inner {\n             IfLetOrMatch::IfLet(_, _, body, els) => {\n-                !used_visitor.check_expr(body) && els.map_or(true, |e| !used_visitor.check_expr(e))\n+                !is_local_used(cx, body, binding_id) && els.map_or(true, |e| !is_local_used(cx, e, binding_id))\n             },\n-            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| used_visitor.check_arm(arm)),\n+            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| is_local_used(cx, arm, binding_id)),\n         };\n         then {\n             let msg = format!(\n@@ -151,23 +151,6 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n     expr\n }\n \n-enum IfLetOrMatch<'hir> {\n-    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n-    /// scrutinee, pattern, then block, else block\n-    IfLet(&'hir Expr<'hir>, &'hir Pat<'hir>, &'hir Expr<'hir>, Option<&'hir Expr<'hir>>),\n-}\n-\n-impl<'hir> IfLetOrMatch<'hir> {\n-    fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n-        match expr.kind {\n-            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n-            _ => higher::IfLet::hir(cx, expr).map(|higher::IfLet { let_expr, let_pat, if_then, if_else }| {\n-                Self::IfLet(let_expr, let_pat, if_then, if_else)\n-            })\n-        }\n-    }\n-}\n-\n /// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n /// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {"}, {"sha": "d58e49491203c1da290327d0af845d72d2018024", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -148,7 +148,7 @@ declare_clippy_lint! {\n     /// };\n     /// ```\n     pub BRANCHES_SHARING_CODE,\n-    complexity,\n+    nursery,\n     \"`if` statement with shared code in all blocks\"\n }\n "}, {"sha": "b4c4ca016aace000f6e8d9ed438e83f5325b7b51", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,108 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{in_macro, is_automatically_derived, is_default_equivalent, remove_blocks};\n+use rustc_hir::{\n+    def::{DefKind, Res},\n+    Body, Expr, ExprKind, Impl, ImplItemKind, Item, ItemKind, Node, QPath,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects manual `std::default::Default` implementations that are identical to a derived implementation.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is less concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo {\n+    ///     bar: bool\n+    /// }\n+    ///\n+    /// impl std::default::Default for Foo {\n+    ///     fn default() -> Self {\n+    ///         Self {\n+    ///             bar: false\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// #[derive(Default)]\n+    /// struct Foo {\n+    ///     bar: bool\n+    /// }\n+    /// ```\n+    ///\n+    /// ### Known problems\n+    /// Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n+    /// in generic types and the user defined `impl` maybe is more generalized or\n+    /// specialized than what derive will produce. This lint can't detect the manual `impl`\n+    /// has exactly equal bounds, and therefore this lint is disabled for types with\n+    /// generic parameters.\n+    ///\n+    pub DERIVABLE_IMPLS,\n+    complexity,\n+    \"manual implementation of the `Default` trait which is equal to a derive\"\n+}\n+\n+declare_lint_pass!(DerivableImpls => [DERIVABLE_IMPLS]);\n+\n+fn is_path_self(e: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(QPath::Resolved(_, p)) = e.kind {\n+        matches!(p.res, Res::SelfCtor(..) | Res::Def(DefKind::Ctor(..), _))\n+    } else {\n+        false\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if_chain! {\n+            if let ItemKind::Impl(Impl {\n+                of_trait: Some(ref trait_ref),\n+                items: [child],\n+                ..\n+            }) = item.kind;\n+            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            if !is_automatically_derived(attrs);\n+            if !in_macro(item.span);\n+            if let Some(def_id) = trait_ref.trait_def_id();\n+            if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n+            if let impl_item_hir = child.id.hir_id();\n+            if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n+            if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n+            if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n+            if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            then {\n+                if cx.tcx.type_of(item.def_id).definitely_has_param_types_or_consts(cx.tcx) {\n+                    return;\n+                }\n+                let should_emit = match remove_blocks(func_expr).kind {\n+                    ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n+                    ExprKind::Call(callee, args)\n+                        if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),\n+                    ExprKind::Struct(_, fields, _) => fields.iter().all(|ef| is_default_equivalent(cx, ef.expr)),\n+                    _ => false,\n+                };\n+                if should_emit {\n+                    let path_string = cx.tcx.def_path_str(adt_def.did);\n+                    span_lint_and_help(\n+                        cx,\n+                        DERIVABLE_IMPLS,\n+                        item.span,\n+                        \"this `impl` can be derived\",\n+                        None,\n+                        &format!(\"try annotating `{}` with `#[derive(Default)]`\", path_string),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "8416b8440dfbe0bf99988c21d09aea8b60799d18", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -105,9 +105,6 @@ declare_clippy_lint! {\n     /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n     /// gets you.\n     ///\n-    /// ### Known problems\n-    /// Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// #[derive(Copy)]"}, {"sha": "ac6824672f66cbf90c13b7f7d9e6dfab2d009d4d", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -9,8 +9,9 @@ use clippy_utils::{\n use core::fmt::Write;\n use rustc_errors::Applicability;\n use rustc_hir::{\n+    hir_id::HirIdSet,\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -338,6 +339,8 @@ struct InsertSearcher<'cx, 'tcx> {\n     edits: Vec<Edit<'tcx>>,\n     /// A stack of loops the visitor is currently in.\n     loops: Vec<HirId>,\n+    /// Local variables created in the expression. These don't need to be captured.\n+    locals: HirIdSet,\n }\n impl<'tcx> InsertSearcher<'_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n@@ -385,13 +388,16 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 }\n             },\n             StmtKind::Expr(e) => self.visit_expr(e),\n-            StmtKind::Local(Local { init: Some(e), .. }) => {\n-                self.allow_insert_closure &= !self.in_tail_pos;\n-                self.in_tail_pos = false;\n-                self.is_single_insert = false;\n-                self.visit_expr(e);\n+            StmtKind::Local(l) => {\n+                self.visit_pat(l.pat);\n+                if let Some(e) = l.init {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.in_tail_pos = false;\n+                    self.is_single_insert = false;\n+                    self.visit_expr(e);\n+                }\n             },\n-            _ => {\n+            StmtKind::Item(_) => {\n                 self.allow_insert_closure &= !self.in_tail_pos;\n                 self.is_single_insert = false;\n             },\n@@ -473,6 +479,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n+                        self.visit_pat(arm.pat);\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n@@ -498,7 +505,8 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 },\n                 _ => {\n                     self.allow_insert_closure &= !self.in_tail_pos;\n-                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    self.allow_insert_closure &=\n+                        can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops, &self.locals);\n                     // Sub expressions are no longer in the tail position.\n                     self.is_single_insert = false;\n                     self.in_tail_pos = false;\n@@ -507,6 +515,12 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n             },\n         }\n     }\n+\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+        p.each_binding_or_first(&mut |_, id, _, _| {\n+            self.locals.insert(id);\n+        });\n+    }\n }\n \n struct InsertSearchResults<'tcx> {\n@@ -632,6 +646,7 @@ fn find_insert_calls(\n         in_tail_pos: true,\n         is_single_insert: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n     };\n     s.visit_expr(expr);\n     let allow_insert_closure = s.allow_insert_closure;"}, {"sha": "8714ce90164c8e3808a43192d4d979e854cab4ea", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -15,8 +15,8 @@ declare_clippy_lint! {\n     /// order of sub-expressions.\n     ///\n     /// ### Why is this bad?\n-    /// It is often confusing to read. In addition, the\n-    /// sub-expression evaluation order for Rust is not well documented.\n+    /// It is often confusing to read. As described [here](https://doc.rust-lang.org/reference/expressions.html?highlight=subexpression#evaluation-order-of-operands),\n+    /// the operands of these expressions are evaluated before applying the effects of the expression.\n     ///\n     /// ### Known problems\n     /// Code which intentionally depends on the evaluation"}, {"sha": "eef1407a80cf15e2209993cc948e44e229dc63be", "filename": "src/tools/clippy/clippy_lints/src/feature_name.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,164 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n+use rustc_hir::{Crate, CRATE_HIR_ID};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::DUMMY_SP;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n+    ///\n+    /// ### Why is this bad?\n+    /// These prefixes and suffixes have no significant meaning.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with feature name redundancy\n+    /// [features]\n+    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n+    /// use-abc = []  // redundant\n+    /// with-def = []   // redundant\n+    /// ghi-support = []   // redundant\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\", \"ghi\"]\n+    /// abc = []\n+    /// def = []\n+    /// ghi = []\n+    /// ```\n+    ///\n+    pub REDUNDANT_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a redundant feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for negative feature names with prefix `no-` or `not-`\n+    ///\n+    /// ### Why is this bad?\n+    /// Features are supposed to be additive, and negatively-named features violate it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with negative feature names\n+    /// [features]\n+    /// default = []\n+    /// no-abc = []\n+    /// not-def = []\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\"]\n+    /// abc = []\n+    /// def = []\n+    ///\n+    /// ```\n+    pub NEGATIVE_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a negative feature name\"\n+}\n+\n+declare_lint_pass!(FeatureName => [REDUNDANT_FEATURE_NAMES, NEGATIVE_FEATURE_NAMES]);\n+\n+static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n+static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n+\n+fn is_negative_prefix(s: &str) -> bool {\n+    s.starts_with(\"no\")\n+}\n+\n+fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n+    let is_negative = is_prefix && is_negative_prefix(substring);\n+    span_lint_and_help(\n+        cx,\n+        if is_negative {\n+            NEGATIVE_FEATURE_NAMES\n+        } else {\n+            REDUNDANT_FEATURE_NAMES\n+        },\n+        DUMMY_SP,\n+        &format!(\n+            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n+            substring,\n+            if is_prefix { \"prefix\" } else { \"suffix\" },\n+            feature,\n+            if is_negative { \"negative\" } else { \"redundant\" }\n+        ),\n+        None,\n+        &format!(\n+            \"consider renaming the feature to \\\"{}\\\"{}\",\n+            if is_prefix {\n+                feature.strip_prefix(substring)\n+            } else {\n+                feature.strip_suffix(substring)\n+            }\n+            .unwrap(),\n+            if is_negative {\n+                \", but make sure the feature adds functionality\"\n+            } else {\n+                \"\"\n+            }\n+        ),\n+    );\n+}\n+\n+impl LateLintPass<'_> for FeatureName {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        if is_lint_allowed(cx, REDUNDANT_FEATURE_NAMES, CRATE_HIR_ID)\n+            && is_lint_allowed(cx, NEGATIVE_FEATURE_NAMES, CRATE_HIR_ID)\n+        {\n+            return;\n+        }\n+\n+        let metadata = unwrap_cargo_metadata!(cx, REDUNDANT_FEATURE_NAMES, false);\n+\n+        for package in metadata.packages {\n+            let mut features: Vec<&String> = package.features.keys().collect();\n+            features.sort();\n+            for feature in features {\n+                let prefix_opt = {\n+                    let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n+                    if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n+                        Some(PREFIXES[i - 1])\n+                    } else {\n+                        None\n+                    }\n+                };\n+                if let Some(prefix) = prefix_opt {\n+                    lint(cx, feature, prefix, true);\n+                }\n+\n+                let suffix_opt: Option<&str> = {\n+                    let i = SUFFIXES.partition_point(|suffix| {\n+                        suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n+                    });\n+                    if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n+                        Some(SUFFIXES[i - 1])\n+                    } else {\n+                        None\n+                    }\n+                };\n+                if let Some(suffix) = suffix_opt {\n+                    lint(cx, feature, suffix, false);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_prefixes_sorted() {\n+    let mut sorted_prefixes = PREFIXES;\n+    sorted_prefixes.sort_unstable();\n+    assert_eq!(PREFIXES, sorted_prefixes);\n+    let mut sorted_suffixes = SUFFIXES;\n+    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n+    assert_eq!(SUFFIXES, sorted_suffixes);\n+}"}, {"sha": "eda611117babf9c5561b09dd4b6bea8d94164b10", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -332,8 +332,6 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n-\n-                    return;\n                 }\n             }\n         }\n@@ -364,22 +362,22 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n-                ref _lspan,\n-                largs,\n+                _lspan,\n+                [largs_0, largs_1, ..],\n                 _\n-            ) = add_lhs.kind;\n+            ) = &add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n-                ref _rspan,\n-                rargs,\n+                _rspan,\n+                [rargs_0, rargs_1, ..],\n                 _\n-            ) = add_rhs.kind;\n+            ) = &add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n-            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), &largs[1]);\n-            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), &rargs[1]);\n+            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), largs_1);\n+            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), rargs_1);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n-                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\")));\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, largs_0, \"..\"), Sugg::hir(cx, rargs_0, \"..\")));\n             }\n         }\n     }\n@@ -409,8 +407,8 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(path, _, method_args, _) = lhs.kind;\n-        if cx.typeck_results().expr_ty(&method_args[0]).is_floating_point();\n+        if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &lhs.kind;\n+        if cx.typeck_results().expr_ty(self_arg).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n             span_lint_and_sugg(\n@@ -421,7 +419,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 \"consider using\",\n                 format!(\n                     \"{}.exp_m1()\",\n-                    Sugg::hir(cx, &method_args[0], \"..\")\n+                    Sugg::hir(cx, self_arg, \"..\")\n                 ),\n                 Applicability::MachineApplicable,\n             );\n@@ -619,16 +617,16 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, _, largs, _) = lhs.kind;\n-        if let ExprKind::MethodCall(_, _, rargs, _) = rhs.kind;\n+        if let ExprKind::MethodCall(_, _, [largs_self, ..], _) = &lhs.kind;\n+        if let ExprKind::MethodCall(_, _, [rargs_self, ..], _) = &rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n                 SUBOPTIMAL_FLOPS,\n                 expr.span,\n                 \"log base can be expressed more clearly\",\n                 \"consider using\",\n-                format!(\"{}.log({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\"),),\n+                format!(\"{}.log({})\", Sugg::hir(cx, largs_self, \"..\"), Sugg::hir(cx, rargs_self, \"..\"),),\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "77d08081c07f1d2bf07911b33de74f4a9f0148ef", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -26,7 +26,6 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            return;\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,"}, {"sha": "ef72b88b3c7735fed581648e8df34c8ad250f253", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -138,12 +138,12 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(path, _span, [self_arg, ..], _) = &expr.kind;\n         if path.ident.as_str() == \"lock\";\n-        let ty = cx.typeck_results().expr_ty(&args[0]);\n+        let ty = cx.typeck_results().expr_ty(self_arg);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {\n-            Some(&args[0])\n+            Some(self_arg)\n         } else {\n             None\n         }"}, {"sha": "adcd78ed0d42745adc2e0cb2d6518a3f98c5243e", "filename": "src/tools/clippy/clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -46,10 +46,10 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n             if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr);\n-            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = let_pat.kind; //get operation\n+            if let ExprKind::MethodCall(_, ok_span, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "7f2c7b707f0b1290968371fbb65e45b4dd32b86d", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{path_to_local_id, visitors::LocalUsedVisitor};\n+use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -65,11 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n                 if let hir::ExprKind::If(hir::Expr { kind: hir::ExprKind::DropTemps(cond), ..}, then, else_) = if_.kind;\n-                let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n-                if !used_visitor.check_expr(cond);\n+                if !is_local_used(cx, *cond, canonical_id);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_visitor.check_expr(value);\n+                if !is_local_used(cx, value, canonical_id);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -148,15 +147,13 @@ fn check_assign<'tcx>(\n         if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n-            let mut v = LocalUsedVisitor::new(cx, decl);\n-\n-            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n-                return None;\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| is_local_used(cx, stmt, decl)) {\n+                None\n+            } else {\n+                Some(value)\n             }\n-\n-            return Some(value);\n+        } else {\n+            None\n         }\n     }\n-\n-    None\n }"}, {"sha": "92a13be81f411374547df641fe588a8220a80e58", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -187,6 +187,7 @@ mod dbg_macro;\n mod default;\n mod default_numeric_fallback;\n mod dereference;\n+mod derivable_impls;\n mod derive;\n mod disallowed_method;\n mod disallowed_script_idents;\n@@ -211,6 +212,7 @@ mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n+mod feature_name;\n mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n@@ -272,6 +274,7 @@ mod missing_const_for_fn;\n mod missing_doc;\n mod missing_enforced_import_rename;\n mod missing_inline;\n+mod module_style;\n mod modulo_arithmetic;\n mod multiple_crate_versions;\n mod mut_key;\n@@ -287,6 +290,7 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_for_each;\n+mod needless_option_as_deref;\n mod needless_pass_by_value;\n mod needless_question_mark;\n mod needless_update;\n@@ -584,6 +588,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         default::FIELD_REASSIGN_WITH_DEFAULT,\n         default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n         dereference::EXPLICIT_DEREF_METHODS,\n+        derivable_impls::DERIVABLE_IMPLS,\n         derive::DERIVE_HASH_XOR_EQ,\n         derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n         derive::EXPL_IMPL_CLONE_ON_COPY,\n@@ -625,6 +630,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         exit::EXIT,\n         explicit_write::EXPLICIT_WRITE,\n         fallible_impl_from::FALLIBLE_IMPL_FROM,\n+        feature_name::NEGATIVE_FEATURE_NAMES,\n+        feature_name::REDUNDANT_FEATURE_NAMES,\n         float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n         float_literal::EXCESSIVE_PRECISION,\n         float_literal::LOSSY_FLOAT_LITERAL,\n@@ -770,6 +777,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_SPLIT_ONCE,\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n@@ -822,6 +830,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n         missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES,\n         missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n+        module_style::MOD_MODULE_FILES,\n+        module_style::SELF_NAMED_MODULE_FILES,\n         modulo_arithmetic::MODULO_ARITHMETIC,\n         multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n         mut_key::MUTABLE_KEY_TYPE,\n@@ -840,6 +850,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         needless_continue::NEEDLESS_CONTINUE,\n         needless_for_each::NEEDLESS_FOR_EACH,\n+        needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF,\n         needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n         needless_question_mark::NEEDLESS_QUESTION_MARK,\n         needless_update::NEEDLESS_UPDATE,\n@@ -1031,6 +1042,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n         LintId::of(missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES),\n         LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n+        LintId::of(module_style::MOD_MODULE_FILES),\n+        LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n         LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n         LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n         LintId::of(panic_unimplemented::PANIC),\n@@ -1122,7 +1135,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(non_expressive_names::SIMILAR_NAMES),\n-        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n         LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(ranges::RANGE_MINUS_ONE),\n@@ -1193,10 +1205,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(comparison_chain::COMPARISON_CHAIN),\n-        LintId::of(copies::BRANCHES_SHARING_CODE),\n         LintId::of(copies::IFS_SAME_COND),\n         LintId::of(copies::IF_SAME_THEN_ELSE),\n         LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+        LintId::of(derivable_impls::DERIVABLE_IMPLS),\n         LintId::of(derive::DERIVE_HASH_XOR_EQ),\n         LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(doc::MISSING_SAFETY_DOC),\n@@ -1316,6 +1328,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::MAP_IDENTITY),\n@@ -1366,6 +1379,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_bool::NEEDLESS_BOOL),\n         LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n         LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(needless_update::NEEDLESS_UPDATE),\n         LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n@@ -1581,7 +1595,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(booleans::NONMINIMAL_BOOL),\n         LintId::of(casts::CHAR_LIT_AS_U8),\n         LintId::of(casts::UNNECESSARY_CAST),\n-        LintId::of(copies::BRANCHES_SHARING_CODE),\n+        LintId::of(derivable_impls::DERIVABLE_IMPLS),\n         LintId::of(double_comparison::DOUBLE_COMPARISONS),\n         LintId::of(double_parens::DOUBLE_PARENS),\n         LintId::of(duration_subsec::DURATION_SUBSEC),\n@@ -1614,6 +1628,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),\n@@ -1628,6 +1643,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_bool::BOOL_COMPARISON),\n         LintId::of(needless_bool::NEEDLESS_BOOL),\n         LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n         LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(needless_update::NEEDLESS_UPDATE),\n         LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n@@ -1779,13 +1795,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n         LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n+        LintId::of(feature_name::NEGATIVE_FEATURE_NAMES),\n+        LintId::of(feature_name::REDUNDANT_FEATURE_NAMES),\n         LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n         LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n     ]);\n \n     store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n         LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n+        LintId::of(copies::BRANCHES_SHARING_CODE),\n         LintId::of(disallowed_method::DISALLOWED_METHOD),\n         LintId::of(disallowed_type::DISALLOWED_TYPE),\n         LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n@@ -1797,6 +1816,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(mutex_atomic::MUTEX_INTEGER),\n         LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n+        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n         LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n         LintId::of(regex::TRIVIAL_REGEX),\n@@ -1835,7 +1855,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n-    store.register_late_pass(move || Box::new(types::Types::new(vec_box_size_threshold, type_complexity_threshold)));\n+    let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    store.register_late_pass(move || Box::new(types::Types::new(\n+        vec_box_size_threshold,\n+        type_complexity_threshold,\n+        avoid_breaking_exported_api,\n+    )));\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n     store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n     store.register_late_pass(|| Box::new(eq_op::EqOp));\n@@ -1846,9 +1871,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(ptr::Ptr));\n     store.register_late_pass(|| Box::new(ptr_eq::PtrEq));\n     store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n+    store.register_late_pass(|| Box::new(needless_option_as_deref::OptionNeedlessDeref));\n     store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n     store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n-    store.register_late_pass(|| Box::new(approx_const::ApproxConstant));\n     store.register_late_pass(|| Box::new(misc::MiscLints));\n     store.register_late_pass(|| Box::new(eta_reduction::EtaReduction));\n     store.register_late_pass(|| Box::new(identity_op::IdentityOp));\n@@ -1877,6 +1902,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n \n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n     store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n@@ -1920,6 +1946,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(panic_unimplemented::PanicUnimplemented));\n     store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n     store.register_late_pass(|| Box::new(derive::Derive));\n+    store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n     store.register_late_pass(|| Box::new(get_last_with_len::GetLastWithLen));\n     store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n     store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n@@ -2092,7 +2119,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(|| Box::new(manual_map::ManualMap));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n-    store.register_early_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_early_pass(move || Box::new(module_style::ModStyle));\n     store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n     let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(&disallowed_types)));\n@@ -2102,6 +2130,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n     store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n+    store.register_late_pass(move || Box::new(feature_name::FeatureName));\n }\n \n #[rustfmt::skip]"}, {"sha": "68bef2f4c8bbb351e808dcd6c78193e8896a5bc6", "filename": "src/tools/clippy/clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -66,9 +66,7 @@ pub(super) fn check<'tcx>(\n fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n-            !LocalUsedVisitor::new(cx, id).check_expr(body)\n-        },\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => !is_local_used(cx, body, id),\n         _ => false,\n     }\n }"}, {"sha": "5b6e27085d580986bd892ac46552dc6b2d253e11", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -2,6 +2,7 @@ use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -37,7 +38,8 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(cx, inner_expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+                = higher::IfLet::hir(cx, inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n             if path_to_local_id(let_expr, pat_hir_id);\n@@ -46,6 +48,8 @@ pub(super) fn check<'tcx>(\n             let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n+            // Ensure epxr in `if let` is not used afterwards\n+            if !is_local_used(cx, if_then, pat_hir_id);\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message"}, {"sha": "2860cb68f42f2c5bc74a371aa2a68ef2fb78209d", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -397,6 +397,21 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// One might think that modifying the mutable variable changes the loop bounds\n     ///\n+    /// ### Known problems\n+    /// False positive when mutation is followed by a `break`, but the `break` is not immediately\n+    /// after the mutation:\n+    ///\n+    /// ```rust\n+    /// let mut x = 5;\n+    /// for _ in 0..x {\n+    ///     x += 1; // x is a range bound that is mutated\n+    ///     ..; // some other expression\n+    ///     break; // leaves the loop, so mutation is not an issue\n+    /// }\n+    /// ```\n+    ///\n+    /// False positive on nested loops ([#6072](https://github.com/rust-lang/rust-clippy/issues/6072))\n+    ///\n     /// ### Example\n     /// ```rust\n     /// let mut foo = 42;\n@@ -580,8 +595,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some(higher::While { if_cond, if_then, .. }) = higher::While::hir(&expr) {\n-            while_immutable_condition::check(cx, if_cond, if_then);\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+            while_immutable_condition::check(cx, condition, body);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "358d53e8859d08d06a7b72ff565da1f0f5608118", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,24 +1,27 @@\n use super::MUT_RANGE_BOUND;\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{higher, path_to_local};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::{get_enclosing_block, higher, path_to_local};\n use if_chain::if_chain;\n-use rustc_hir::{BindingAnnotation, Expr, HirId, Node, PatKind};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, HirId, Node, PatKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n use rustc_middle::{mir::FakeReadCause, ty};\n use rustc_span::source_map::Span;\n use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        end: Some(end),\n-        ..\n-    }) = higher::Range::hir(arg)\n-    {\n-        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n-        if mut_ids[0].is_some() || mut_ids[1].is_some() {\n-            let (span_low, span_high) = check_for_mutation(cx, body, &mut_ids);\n+    if_chain! {\n+        if let Some(higher::Range {\n+            start: Some(start),\n+            end: Some(end),\n+            ..\n+        }) = higher::Range::hir(arg);\n+        let (mut_id_start, mut_id_end) = (check_for_mutability(cx, start), check_for_mutability(cx, end));\n+        if mut_id_start.is_some() || mut_id_end.is_some();\n+        then {\n+            let (span_low, span_high) = check_for_mutation(cx, body, mut_id_start, mut_id_end);\n             mut_warn_with_span(cx, span_low);\n             mut_warn_with_span(cx, span_high);\n         }\n@@ -27,11 +30,13 @@ pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n \n fn mut_warn_with_span(cx: &LateContext<'_>, span: Option<Span>) {\n     if let Some(sp) = span {\n-        span_lint(\n+        span_lint_and_note(\n             cx,\n             MUT_RANGE_BOUND,\n             sp,\n-            \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\",\n+            \"attempt to mutate range bound within loop\",\n+            None,\n+            \"the range of the loop is unchanged\",\n         );\n     }\n }\n@@ -51,12 +56,13 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n fn check_for_mutation<'tcx>(\n     cx: &LateContext<'tcx>,\n     body: &Expr<'_>,\n-    bound_ids: &[Option<HirId>],\n+    bound_id_start: Option<HirId>,\n+    bound_id_end: Option<HirId>,\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n         cx,\n-        hir_id_low: bound_ids[0],\n-        hir_id_high: bound_ids[1],\n+        hir_id_low: bound_id_start,\n+        hir_id_high: bound_id_end,\n         span_low: None,\n         span_high: None,\n     };\n@@ -70,6 +76,7 @@ fn check_for_mutation<'tcx>(\n         )\n         .walk_expr(body);\n     });\n+\n     delegate.mutation_span()\n }\n \n@@ -87,10 +94,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n     fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let PlaceBase::Local(id) = cmt.place.base {\n-                if Some(id) == self.hir_id_low {\n+                if Some(id) == self.hir_id_low && !BreakAfterExprVisitor::is_found(self.cx, diag_expr_id) {\n                     self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id));\n                 }\n-                if Some(id) == self.hir_id_high {\n+                if Some(id) == self.hir_id_high && !BreakAfterExprVisitor::is_found(self.cx, diag_expr_id) {\n                     self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id));\n                 }\n             }\n@@ -99,10 +106,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n \n     fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) {\n         if let PlaceBase::Local(id) = cmt.place.base {\n-            if Some(id) == self.hir_id_low {\n+            if Some(id) == self.hir_id_low && !BreakAfterExprVisitor::is_found(self.cx, diag_expr_id) {\n                 self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id));\n             }\n-            if Some(id) == self.hir_id_high {\n+            if Some(id) == self.hir_id_high && !BreakAfterExprVisitor::is_found(self.cx, diag_expr_id) {\n                 self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id));\n             }\n         }\n@@ -116,3 +123,52 @@ impl MutatePairDelegate<'_, '_> {\n         (self.span_low, self.span_high)\n     }\n }\n+\n+struct BreakAfterExprVisitor {\n+    hir_id: HirId,\n+    past_expr: bool,\n+    past_candidate: bool,\n+    break_after_expr: bool,\n+}\n+\n+impl BreakAfterExprVisitor {\n+    pub fn is_found(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+        let mut visitor = BreakAfterExprVisitor {\n+            hir_id,\n+            past_expr: false,\n+            past_candidate: false,\n+            break_after_expr: false,\n+        };\n+\n+        get_enclosing_block(cx, hir_id).map_or(false, |block| {\n+            visitor.visit_block(block);\n+            visitor.break_after_expr\n+        })\n+    }\n+}\n+\n+impl intravisit::Visitor<'tcx> for BreakAfterExprVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if self.past_candidate {\n+            return;\n+        }\n+\n+        if expr.hir_id == self.hir_id {\n+            self.past_expr = true;\n+        } else if self.past_expr {\n+            if matches!(&expr.kind, ExprKind::Break(..)) {\n+                self.break_after_expr = true;\n+            }\n+\n+            self.past_candidate = true;\n+        } else {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+}"}, {"sha": "f90ed7397e18e19c4d1d9899521684d2d69a0577", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -26,7 +26,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n         then {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            let mut applicability = Applicability::MachineApplicable;\n+            let mut applicability = Applicability::MaybeIncorrect;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n             let sugg = if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n@@ -113,7 +113,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                                     (stmt.span, String::new()),\n                                     (iter_call.span, iter_replacement)\n                                 ],\n-                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                                Applicability::MaybeIncorrect,\n                             );\n                         },\n                     );"}, {"sha": "e8f3550283a49c85e1411ed9106619dda5e1d8d8", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -2,10 +2,8 @@ use super::NEEDLESS_RANGE_LOOP;\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n-use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{\n-    contains_name, higher, is_integer_const, match_trait_method, path_to_local_id, paths, sugg, SpanlessEq,\n-};\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -256,43 +254,36 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n-            let index_used_directly = path_to_local_id(idx, self.var);\n-            let indexed_indirectly = {\n-                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                walk_expr(&mut used_visitor, idx);\n-                used_visitor.used\n-            };\n-            if indexed_indirectly || index_used_directly;\n+            if is_local_used(self.cx, idx, self.var);\n             then {\n                 if self.prefer_mutable {\n                     self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                 }\n+                let index_used_directly = matches!(idx.kind, ExprKind::Path(_));\n                 let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n                         let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n                         let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n                     Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n@@ -310,10 +301,10 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(meth, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(meth, _, [args_0, args_1, ..], _) = &expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n-            if !self.check(&args[1], &args[0], expr);\n+            if !self.check(args_1, args_0, expr);\n             then { return }\n         }\n "}, {"sha": "41956650c9f4e7c8a000926f8aa8d7d2b0894207", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -87,7 +87,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr.as_deref());\n+    let expr = once(block.expr);\n     let mut iter = stmts.chain(expr).flatten();\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n@@ -100,7 +100,7 @@ fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_lo\n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n         StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some(e),\n-        StmtKind::Local(local) => local.init.as_deref(),\n+        StmtKind::Local(local) => local.init,\n         StmtKind::Item(..) => None,\n     }\n }"}, {"sha": "1848f5b5de2f2fca48c3f2c1d1d2ce00ce6a9d3a", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -24,13 +24,13 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n             }\n         }\n \n-        if let ExprKind::Match(ref matchexpr, ref arms, MatchSource::Normal) = inner.kind {\n+        if let ExprKind::Match(matchexpr, arms, MatchSource::Normal) = inner.kind {\n             if arms.len() == 2\n                 && arms[0].guard.is_none()\n                 && arms[1].guard.is_none()\n-                && is_simple_break_expr(&arms[1].body)\n+                && is_simple_break_expr(arms[1].body)\n             {\n-                could_be_while_let(cx, expr, &arms[0].pat, matchexpr);\n+                could_be_while_let(cx, expr, arms[0].pat, matchexpr);\n             }\n         }\n     }"}, {"sha": "79527e3bfa92f1b4b790d88319de759db0d8de5d", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -14,12 +14,7 @@ use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n-        if let Some(higher::WhileLet {\n-            if_then,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::WhileLet::hir(expr);\n+        if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n         if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n         if let Res::Def(_, pat_did) = pat_path.res;"}, {"sha": "7627e0fb28956f3a61a0c8f513d03dad7c29033b", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -48,8 +48,7 @@ pub struct MacroRefData {\n impl MacroRefData {\n     pub fn new(name: String, callee: Span, cx: &LateContext<'_>) -> Self {\n         let sm = cx.sess().source_map();\n-        let mut path = sm.filename_for_diagnostics(&sm.span_to_filename(callee))\n-            .to_string();\n+        let mut path = sm.filename_for_diagnostics(&sm.span_to_filename(callee)).to_string();\n \n         // std lib paths are <::std::module::file type>\n         // so remove brackets, space and type."}, {"sha": "b5f573cb104e914a6cde3eab296f7da9b7842b0c", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "modified", "additions": 159, "deletions": 163, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,16 +1,18 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n+use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,176 +46,177 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_then,\n-            if_else: Some(if_else),\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            manage_lint(cx, expr, (&let_pat.kind, if_then), (&PatKind::Wild, if_else), let_expr);\n+        let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n+            Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),\n+            Some(IfLetOrMatch::Match(\n+                scrutinee,\n+                [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n+                _,\n+            )) => (scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body),\n+            _ => return,\n+        };\n+        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+            return;\n         }\n \n-        if let ExprKind::Match(scrutinee, [then @ Arm { guard: None, .. }, r#else @ Arm { guard: None, .. }], _) =\n-            expr.kind\n+        let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+            peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+        if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n         {\n-            manage_lint(\n-                cx,\n-                expr,\n-                (&then.pat.kind, then.body),\n-                (&r#else.pat.kind, r#else.body),\n-                scrutinee,\n-            );\n+            return;\n         }\n-    }\n-}\n-\n-fn manage_lint<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    then: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n-    r#else: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n-    scrut: &'tcx Expr<'_>,\n-) {\n-    if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-        return;\n-    }\n \n-    let (scrutinee_ty, ty_ref_count, ty_mutability) = peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrut));\n-    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n-    {\n-        return;\n-    }\n+        let expr_ctxt = expr.span.ctxt();\n+        let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+            try_parse_pattern(cx, then_pat, expr_ctxt),\n+            else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+        ) {\n+            (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+                (else_body, pattern, ref_count, false)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, true)\n+            },\n+            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+                (then_body, pattern, ref_count, false)\n+            },\n+            _ => return,\n+        };\n \n-    let (then_pat, then_expr) = then;\n-    let (else_pat, else_expr) = r#else;\n+        // Top level or patterns aren't allowed in closures.\n+        if matches!(some_pat.kind, PatKind::Or(_)) {\n+            return;\n+        }\n \n-    let expr_ctxt = expr.span.ctxt();\n-    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-        try_parse_pattern(cx, then_pat, expr_ctxt),\n-        try_parse_pattern(cx, else_pat, expr_ctxt),\n-    ) {\n-        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n-            (else_expr, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n-            (else_expr, pattern, ref_count, false)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_expr) => {\n-            (then_expr, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_expr) => {\n-            (then_expr, pattern, ref_count, false)\n-        },\n-        _ => return,\n-    };\n+        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+            Some(expr) => expr,\n+            None => return,\n+        };\n \n-    // Top level or patterns aren't allowed in closures.\n-    if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return;\n-    }\n+        // These two lints will go back and forth with each other.\n+        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+            && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+        {\n+            return;\n+        }\n \n-    let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n-        Some(expr) => expr,\n-        None => return,\n-    };\n+        // `map` won't perform any adjustments.\n+        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+            return;\n+        }\n \n-    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id) {\n-        return;\n-    }\n+        // Determine which binding mode to use.\n+        let explicit_ref = some_pat.contains_explicit_ref_binding();\n+        let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n \n-    // `map` won't perform any adjustments.\n-    if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n-        return;\n-    }\n+        let as_ref_str = match binding_ref {\n+            Some(Mutability::Mut) => \".as_mut()\",\n+            Some(Mutability::Not) => \".as_ref()\",\n+            None => \"\",\n+        };\n \n-    if !can_move_expr_to_closure(cx, some_expr) {\n-        return;\n-    }\n-\n-    // Determine which binding mode to use.\n-    let explicit_ref = some_pat.contains_explicit_ref_binding();\n-    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+        match can_move_expr_to_closure(cx, some_expr) {\n+            Some(captures) => {\n+                // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+                // TODO: check all the references made in the scrutinee expression. This will require interacting\n+                // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+                if let Some(binding_ref_mutability) = binding_ref {\n+                    let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                        ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                        _ => None,\n+                    });\n+                    if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                        match captures.get(l) {\n+                            Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                            Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                                return;\n+                            },\n+                            Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                        }\n+                    }\n+                }\n+            },\n+            None => return,\n+        };\n \n-    let as_ref_str = match binding_ref {\n-        Some(Mutability::Mut) => \".as_mut()\",\n-        Some(Mutability::Not) => \".as_ref()\",\n-        None => \"\",\n-    };\n+        let mut app = Applicability::MachineApplicable;\n \n-    let mut app = Applicability::MachineApplicable;\n+        // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+        // it's being passed by value.\n+        let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+        let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+        let scrutinee_str =\n+            if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                format!(\"({})\", scrutinee_str)\n+            } else {\n+                scrutinee_str.into()\n+            };\n \n-    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-    // it's being passed by value.\n-    let scrutinee = peel_hir_expr_refs(scrut).0;\n-    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({})\", scrutinee_str)\n-    } else {\n-        scrutinee_str.into()\n-    };\n+        let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+            match can_pass_as_func(cx, id, some_expr) {\n+                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                },\n+                _ => {\n+                    if path_to_local_id(some_expr, id)\n+                        && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                        && binding_ref.is_some()\n+                    {\n+                        return;\n+                    }\n \n-    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-        match can_pass_as_func(cx, id, some_expr) {\n-            Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n-                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-            },\n-            _ => {\n-                if path_to_local_id(some_expr, id)\n-                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                    && binding_ref.is_some()\n-                {\n-                    return;\n-                }\n+                    // `ref` and `ref mut` annotations were handled earlier.\n+                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    format!(\n+                        \"|{}{}| {}\",\n+                        annotation,\n+                        some_binding,\n+                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+                    )\n+                },\n+            }\n+        } else if !is_wild_none && explicit_ref.is_none() {\n+            // TODO: handle explicit reference annotations.\n+            format!(\n+                \"|{}| {}\",\n+                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+            )\n+        } else {\n+            // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+            return;\n+        };\n \n-                // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-                format!(\n-                    \"|{}{}| {}\",\n-                    annotation,\n-                    some_binding,\n-                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                )\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n+                format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+            } else {\n+                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n             },\n-        }\n-    } else if !is_wild_none && explicit_ref.is_none() {\n-        // TODO: handle explicit reference annotations.\n-        format!(\n-            \"|{}| {}\",\n-            snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-        )\n-    } else {\n-        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return;\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        MANUAL_MAP,\n-        expr.span,\n-        \"manual implementation of `Option::map`\",\n-        \"try this\",\n-        if is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-        } else {\n-            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-        },\n-        app,\n-    );\n+            app,\n+        );\n+    }\n }\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id (arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },\n@@ -235,28 +238,21 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(\n-    cx: &LateContext<'tcx>,\n-    pat_kind: &'tcx PatKind<'_>,\n-    ctxt: SyntaxContext,\n-) -> Option<OptionPat<'tcx>> {\n-    fn f(\n-        cx: &LateContext<'tcx>,\n-        pat_kind: &'tcx PatKind<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat_kind {\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(ref_pat, _) => f(cx, &ref_pat.kind, ref_count + 1, ctxt),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n             PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _) if is_lang_ctor(cx, qpath, OptionSome) => {\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat_kind, 0, ctxt)\n+    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression."}, {"sha": "2f1ff567e844f803c7e4f8930aefd1a5f1187eda", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::higher;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild,\n     meets_msrv, msrvs, path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n@@ -631,7 +631,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 check_match_single_binding(cx, ex, arms, expr);\n             }\n         }\n-        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n+        if let ExprKind::Match(ex, arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n         }\n         if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n@@ -959,9 +959,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                         // Looking for unused bindings (i.e.: `_e`)\n                         for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_')\n-                                    && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n-                                {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n                                     ident_bind_name = (&ident.name.as_str()).to_string();\n                                     matching_wild = true;\n                                 }\n@@ -1196,7 +1194,7 @@ where\n \n     let (first_sugg, msg, title);\n     let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n         first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n         msg = \"try\";\n         title = \"you don't need to add `&` to both the expression and the patterns\";\n@@ -1207,7 +1205,7 @@ where\n     }\n \n     let remaining_suggs = pats.filter_map(|pat| {\n-        if let PatKind::Ref(ref refp, _) = pat.kind {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n             Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n         } else {\n             None\n@@ -1367,7 +1365,7 @@ where\n                 find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n             });\n         then {\n-            if let Some(ref last_pat) = last_pat_opt {\n+            if let Some(last_pat) = last_pat_opt {\n                 if !is_wild(last_pat) {\n                     return false;\n                 }\n@@ -1829,13 +1827,13 @@ mod redundant_pattern_match {\n             ..\n         }) = higher::IfLet::hir(cx, expr)\n         {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some())\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n         }\n         if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-            find_sugg_for_match(cx, expr, op, arms)\n+            find_sugg_for_match(cx, expr, op, arms);\n         }\n         if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false)\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n         }\n     }\n "}, {"sha": "eb437dc47afb496e63b0bfc37e28a3d209a29f7d", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -28,11 +28,11 @@ declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n impl<'tcx> LateLintPass<'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Call(path_expr, args) = e.kind {\n+        if let ExprKind::Call(path_expr, [ref first_arg, ..]) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        let forgot_ty = cx.typeck_results().expr_ty(&args[0]);\n+                        let forgot_ty = cx.typeck_results().expr_ty(first_arg);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {\n                             span_lint(cx, MEM_FORGET, e.span, \"usage of `mem::forget` on `Drop` type\");"}, {"sha": "1e6057a8fe969eb177c0d3252175799bf3ba8b73", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 29, "deletions": 56, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, is_diag_trait_item, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::ty::is_non_aggregate_primitive_type;\n+use clippy_utils::{in_macro, is_default_equivalent, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -194,64 +194,37 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n     }\n }\n \n-/// Returns true if the `def_id` associated with the `path` is recognized as a \"default-equivalent\"\n-/// constructor from the std library\n-fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<'_>) -> bool {\n-    let std_types_symbols = &[\n-        sym::string_type,\n-        sym::vec_type,\n-        sym::vecdeque_type,\n-        sym::LinkedList,\n-        sym::hashmap_type,\n-        sym::BTreeMap,\n-        sym::hashset_type,\n-        sym::BTreeSet,\n-        sym::BinaryHeap,\n-    ];\n-\n-    if let QPath::TypeRelative(_, method) = path {\n-        if method.ident.name == sym::new {\n-            if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n-                if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n-                    return std_types_symbols\n-                        .iter()\n-                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n-                }\n-            }\n+fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n+    // disable lint for primitives\n+    let expr_type = cx.typeck_results().expr_ty_adjusted(src);\n+    if is_non_aggregate_primitive_type(expr_type) {\n+        return;\n+    }\n+    // disable lint for Option since it is covered in another lint\n+    if let ExprKind::Path(q) = &src.kind {\n+        if is_lang_ctor(cx, q, OptionNone) {\n+            return;\n         }\n     }\n-    false\n-}\n+    if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n+        span_lint_and_then(\n+            cx,\n+            MEM_REPLACE_WITH_DEFAULT,\n+            expr_span,\n+            \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n+            |diag| {\n+                if !in_macro(expr_span) {\n+                    let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n \n-fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if_chain! {\n-        if let ExprKind::Call(repl_func, _) = src.kind;\n-        if !in_external_macro(cx.tcx.sess, expr_span);\n-        if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-        if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n-        if is_diag_trait_item(cx, repl_def_id, sym::Default)\n-            || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n-\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MEM_REPLACE_WITH_DEFAULT,\n-                expr_span,\n-                \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n-                |diag| {\n-                    if !in_macro(expr_span) {\n-                        let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n-\n-                        diag.span_suggestion(\n-                            expr_span,\n-                            \"consider using\",\n-                            suggestion,\n-                            Applicability::MachineApplicable\n-                        );\n-                    }\n+                    diag.span_suggestion(\n+                        expr_span,\n+                        \"consider using\",\n+                        suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n-            );\n-        }\n+            },\n+        );\n     }\n }\n "}, {"sha": "bcf8d93b602ef2a7d03703f7864723af5806fca0", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_next.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet;\n+use clippy_utils::ty::implements_trait;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -16,7 +16,10 @@ pub(super) fn check<'tcx>(\n     filter_arg: &'tcx hir::Expr<'_>,\n ) {\n     // lint if caller of `.filter().next()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n+    let recv_impls_iterator = cx.tcx.get_diagnostic_item(sym::Iterator).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(recv), id, &[])\n+    });\n+    if recv_impls_iterator {\n         let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find(..)` instead\";\n         let filter_snippet = snippet(cx, filter_arg.span, \"..\");"}, {"sha": "e273186d0519022d5a7c1a9219cf1aa9625fd4a7", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_split_once.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,213 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n+use rustc_span::{symbol::sym, Span, SyntaxContext};\n+\n+use super::MANUAL_SPLIT_ONCE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+        return;\n+    }\n+\n+    let ctxt = expr.span.ctxt();\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(x) => x,\n+        None => return,\n+    };\n+    let (method_name, msg) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\")\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+    let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+    let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+    match usage.kind {\n+        IterUsageKind::NextTuple => {\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n+                app,\n+            );\n+        },\n+        IterUsageKind::Next => {\n+            let self_deref = {\n+                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n+                if adjust.is_empty() {\n+                    String::new()\n+                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n+                    || adjust\n+                        .iter()\n+                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n+                {\n+                    format!(\"&{}\", \"*\".repeat(adjust.len() - 1))\n+                } else {\n+                    \"*\".repeat(adjust.len() - 2)\n+                }\n+            };\n+            let sugg = if usage.unwrap_kind.is_some() {\n+                format!(\n+                    \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            } else {\n+                format!(\n+                    \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            };\n+\n+            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+        },\n+        IterUsageKind::Second => {\n+            let access_str = match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n+                Some(UnwrapKind::QuestionMark) => \"?.1\",\n+                None => \".map(|x| x.1)\",\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+enum IterUsageKind {\n+    Next,\n+    Second,\n+    NextTuple,\n+}\n+\n+enum UnwrapKind {\n+    Unwrap,\n+    QuestionMark,\n+}\n+\n+struct IterUsage {\n+    kind: IterUsageKind,\n+    unwrap_kind: Option<UnwrapKind>,\n+    span: Span,\n+}\n+\n+fn parse_iter_usage(\n+    cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n+    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+) -> Option<IterUsage> {\n+    let (kind, span) = match iter.next() {\n+        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+                (name, args)\n+            } else {\n+                return None;\n+            };\n+            let did = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n+            let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n+\n+            match (&*name.ident.as_str(), args) {\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next_tuple\", []) => {\n+                    if_chain! {\n+                        if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n+                        if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n+                        if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n+                        if let ty::Tuple(subs) = subs.type_at(0).kind();\n+                        if subs.len() == 2;\n+                        then {\n+                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                },\n+                (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                        let span = if name.ident.as_str() == \"nth\" {\n+                            e.span\n+                        } else {\n+                            if_chain! {\n+                                if let Some((_, Node::Expr(next_expr))) = iter.next();\n+                                if let ExprKind::MethodCall(next_name, _, [_], _) = next_expr.kind;\n+                                if next_name.ident.name == sym::next;\n+                                if next_expr.span.ctxt() == ctxt;\n+                                if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n+                                if cx.tcx.trait_of_item(next_id) == Some(iter_id);\n+                                then {\n+                                    next_expr.span\n+                                } else {\n+                                    return None;\n+                                }\n+                            }\n+                        };\n+                        match idx {\n+                            0 => (IterUsageKind::Next, span),\n+                            1 => (IterUsageKind::Second, span),\n+                            _ => return None,\n+                        }\n+                    } else {\n+                        return None;\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        },\n+        _ => return None,\n+    };\n+\n+    let (unwrap_kind, span) = if let Some((_, Node::Expr(e))) = iter.next() {\n+        match e.kind {\n+            ExprKind::Call(\n+                Expr {\n+                    kind: ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)),\n+                    ..\n+                },\n+                _,\n+            ) => {\n+                let parent_span = e.span.parent().unwrap();\n+                if parent_span.ctxt() == ctxt {\n+                    (Some(UnwrapKind::QuestionMark), parent_span)\n+                } else {\n+                    (None, span)\n+                }\n+            },\n+            _ if e.span.ctxt() != ctxt => (None, span),\n+            ExprKind::MethodCall(name, _, [_], _)\n+                if name.ident.name == sym::unwrap\n+                    && cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| is_diag_item_method(cx, id, sym::option_type)) =>\n+            {\n+                (Some(UnwrapKind::Unwrap), e.span)\n+            },\n+            _ => (None, span),\n+        }\n+    } else {\n+        (None, span)\n+    };\n+\n+    Some(IterUsage {\n+        kind,\n+        unwrap_kind,\n+        span,\n+    })\n+}"}, {"sha": "e89b2d295b92345f4f1173e0e19911c559cc3bca", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -33,6 +33,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_split_once;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n@@ -64,6 +65,7 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n@@ -1771,6 +1773,29 @@ declare_clippy_lint! {\n     \"manual implementation of `str::repeat`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `str::splitn(2, _)`\n+    ///\n+    /// **Why is this bad?** `split_once` is both clearer in intent and slightly more efficient.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n+    ///  let value = _.splitn(2, '=').nth(1)?;\n+    ///\n+    /// // Good\n+    /// let (key, value) = _.split_once('=')?;\n+    /// let value = _.split_once('=')?.1;\n+    /// ```\n+    pub MANUAL_SPLIT_ONCE,\n+    complexity,\n+    \"replace `.splitn(2, pat)` with `.split_once(pat)`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1848,7 +1873,8 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n-    EXTEND_WITH_DRAIN\n+    EXTEND_WITH_DRAIN,\n+    MANUAL_SPLIT_ONCE\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2176,8 +2202,18 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                 }\n             },\n-            (\"splitn\" | \"splitn_mut\" | \"rsplitn\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                suspicious_splitn::check(cx, name, expr, recv, count_arg);\n+            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n+                        manual_split_once::check(cx, name, expr, recv, pat_arg);\n+                    }\n+                }\n+            },\n+            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                }\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {"}, {"sha": "30ed1d665a907d1cf1bb8d4ea3208a0a48023e5b", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -96,9 +96,9 @@ pub(super) fn check<'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        if let hir::ExprKind::MethodCall(path, _, args, _) = &arg.kind {\n+        if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &arg.kind {\n             if path.ident.name == sym::len {\n-                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+                let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n \n                 match ty.kind() {\n                     ty::Slice(_) | ty::Array(_, _) | ty::Str => return,"}, {"sha": "1c546a15bf62b331a5993e378aee11e7c832dc72", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_note;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n@@ -8,25 +7,18 @@ use rustc_span::source_map::Spanned;\n \n use super::SUSPICIOUS_SPLITN;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    count_arg: &Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, count: u128) {\n     if_chain! {\n-        if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg);\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n         let lang_items = cx.tcx.lang_items();\n         if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n-            if (matches!(self_arg.kind, ExprKind::Array([]))\n+            if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-            ) && matches!(count_arg.kind, ExprKind::Lit(_))\n+\n             {\n                 return;\n             }"}, {"sha": "30d6665a920ba3e7d18adc58f98583af8f57e87f", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -24,9 +24,9 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(path, _, args, _) = expr.kind {\n-        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n-            Some(&args[0])\n+    if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind {\n+        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(self_arg)) {\n+            Some(self_arg)\n         } else {\n             None\n         }"}, {"sha": "538fa4e1678fc348b90da7ca3aaf22fb6ca5fc5a", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -513,12 +513,12 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, expressions, _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, [ref self_arg, ..], _) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)\n         then {\n-            return is_float(cx, &expressions[0]);\n+            return is_float(cx, self_arg);\n         }\n     }\n     false"}, {"sha": "80a930d0c547b368460ba8e0e965261b1f7da7d9", "filename": "src/tools/clippy/clippy_lints/src/module_style.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,178 @@\n+use std::{\n+    ffi::OsString,\n+    path::{Component, Path},\n+};\n+\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_lint::{EarlyContext, EarlyLintPass, Level, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{FileName, RealFileName, SourceFile, Span, SyntaxContext};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks that module layout uses only self named module files, bans mod.rs files.\n+    ///\n+    /// ### Why is this bad?\n+    /// Having multiple module layout styles in a project can be confusing.\n+    ///\n+    /// ### Example\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///     mod.rs\n+    ///   lib.rs\n+    /// ```\n+    /// Use instead:\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///   stuff.rs\n+    ///   lib.rs\n+    /// ```\n+    pub MOD_MODULE_FILES,\n+    restriction,\n+    \"checks that module layout is consistent\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks that module layout uses only mod.rs files.\n+    ///\n+    /// ### Why is this bad?\n+    /// Having multiple module layout styles in a project can be confusing.\n+    ///\n+    /// ### Example\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///   stuff.rs\n+    ///   lib.rs\n+    /// ```\n+    /// Use instead:\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///     mod.rs\n+    ///   lib.rs\n+    /// ```\n+\n+    pub SELF_NAMED_MODULE_FILES,\n+    restriction,\n+    \"checks that module layout is consistent\"\n+}\n+\n+pub struct ModStyle;\n+\n+impl_lint_pass!(ModStyle => [MOD_MODULE_FILES, SELF_NAMED_MODULE_FILES]);\n+\n+impl EarlyLintPass for ModStyle {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &ast::Crate) {\n+        if cx.builder.lint_level(MOD_MODULE_FILES).0 == Level::Allow\n+            && cx.builder.lint_level(SELF_NAMED_MODULE_FILES).0 == Level::Allow\n+        {\n+            return;\n+        }\n+\n+        let files = cx.sess.source_map().files();\n+\n+        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess.opts.working_dir {\n+            p.to_string_lossy()\n+        } else {\n+            return;\n+        };\n+\n+        // `folder_segments` is all unique folder path segments `path/to/foo.rs` gives\n+        // `[path, to]` but not foo\n+        let mut folder_segments = FxHashSet::default();\n+        // `mod_folders` is all the unique folder names that contain a mod.rs file\n+        let mut mod_folders = FxHashSet::default();\n+        // `file_map` maps file names to the full path including the file name\n+        // `{ foo => path/to/foo.rs, .. }\n+        let mut file_map = FxHashMap::default();\n+        for file in files.iter() {\n+            match &file.name {\n+                FileName::Real(RealFileName::LocalPath(lp))\n+                    if lp.to_string_lossy().starts_with(trim_to_src.as_ref()) =>\n+                {\n+                    let p = lp.to_string_lossy();\n+                    let path = Path::new(p.trim_start_matches(trim_to_src.as_ref()));\n+                    if let Some(stem) = path.file_stem() {\n+                        file_map.insert(stem.to_os_string(), (file, path.to_owned()));\n+                    }\n+                    process_paths_for_mod_files(path, &mut folder_segments, &mut mod_folders);\n+                    check_self_named_mod_exists(cx, path, file);\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        for folder in &folder_segments {\n+            if !mod_folders.contains(folder) {\n+                if let Some((file, path)) = file_map.get(folder) {\n+                    let mut correct = path.clone();\n+                    correct.pop();\n+                    correct.push(folder);\n+                    correct.push(\"mod.rs\");\n+                    cx.struct_span_lint(\n+                        SELF_NAMED_MODULE_FILES,\n+                        Span::new(file.start_pos, file.start_pos, SyntaxContext::root()),\n+                        |build| {\n+                            let mut lint =\n+                                build.build(&format!(\"`mod.rs` files are required, found `{}`\", path.display()));\n+                            lint.help(&format!(\"move `{}` to `{}`\", path.display(), correct.display(),));\n+                            lint.emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// For each `path` we add each folder component to `folder_segments` and if the file name\n+/// is `mod.rs` we add it's parent folder to `mod_folders`.\n+fn process_paths_for_mod_files(\n+    path: &Path,\n+    folder_segments: &mut FxHashSet<OsString>,\n+    mod_folders: &mut FxHashSet<OsString>,\n+) {\n+    let mut comp = path.components().rev().peekable();\n+    let _ = comp.next();\n+    if path.ends_with(\"mod.rs\") {\n+        mod_folders.insert(comp.peek().map(|c| c.as_os_str().to_owned()).unwrap_or_default());\n+    }\n+    let folders = comp\n+        .filter_map(|c| {\n+            if let Component::Normal(s) = c {\n+                Some(s.to_os_string())\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+    folder_segments.extend(folders);\n+}\n+\n+/// Checks every path for the presence of `mod.rs` files and emits the lint if found.\n+fn check_self_named_mod_exists(cx: &EarlyContext<'_>, path: &Path, file: &SourceFile) {\n+    if path.ends_with(\"mod.rs\") {\n+        let mut mod_file = path.to_path_buf();\n+        mod_file.pop();\n+        mod_file.set_extension(\"rs\");\n+\n+        cx.struct_span_lint(\n+            MOD_MODULE_FILES,\n+            Span::new(file.start_pos, file.start_pos, SyntaxContext::root()),\n+            |build| {\n+                let mut lint = build.build(&format!(\"`mod.rs` files are not allowed, found `{}`\", path.display()));\n+                lint.help(&format!(\"move `{}` to `{}`\", path.display(), mod_file.display(),));\n+                lint.emit();\n+            },\n+        );\n+    }\n+}"}, {"sha": "e9dcc7b227d7601a51cac5fd6869e5d5e9b9d3c1", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -47,9 +47,9 @@ declare_lint_pass!(MutMutexLock => [MUT_MUTEX_LOCK]);\n impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, method_span, args, _) = &ex.kind;\n+            if let ExprKind::MethodCall(path, method_span, [self_arg, ..], _) = &ex.kind;\n             if path.ident.name == sym!(lock);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n             if is_type_diagnostic_item(cx, inner_ty, sym!(mutex_type));\n             then {"}, {"sha": "5024a881d2aa8b10b63d586fc70b2b7fe688a99b", "filename": "src/tools/clippy/clippy_lints/src/needless_option_as_deref.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,66 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::in_macro;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TyS;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for no-op uses of Option::{as_deref,as_deref_mut},\n+    /// for example, `Option<&T>::as_deref()` returns the same type.\n+    ///\n+    /// ### Why is this bad?\n+    /// Redundant code and improving readability.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a = Some(&1);\n+    /// let b = a.as_deref(); // goes from Option<&i32> to Option<&i32>\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// let a = Some(&1);\n+    /// let b = a;\n+    /// ```\n+    pub NEEDLESS_OPTION_AS_DEREF,\n+    complexity,\n+    \"no-op use of `deref` or `deref_mut` method to `Option`.\"\n+}\n+\n+declare_lint_pass!(OptionNeedlessDeref=> [\n+    NEEDLESS_OPTION_AS_DEREF,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OptionNeedlessDeref {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() || in_macro(expr.span) {\n+            return;\n+        }\n+        let typeck = cx.typeck_results();\n+        let outer_ty = typeck.expr_ty(expr);\n+\n+        if_chain! {\n+            if is_type_diagnostic_item(cx,outer_ty,sym::option_type);\n+            if let ExprKind::MethodCall(path, _, [sub_expr], _) = expr.kind;\n+            let symbol = path.ident.as_str();\n+            if symbol==\"as_deref\" || symbol==\"as_deref_mut\";\n+            if TyS::same_type( outer_ty, typeck.expr_ty(sub_expr) );\n+            then{\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_OPTION_AS_DEREF,\n+                    expr.span,\n+                    \"derefed type is same as origin\",\n+                    \"try this\",\n+                    snippet_opt(cx,sub_expr.span).unwrap(),\n+                    Applicability::MachineApplicable\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "c5a5cde4b110fccbb874801a53cd72dcc9b2e747", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -96,28 +96,63 @@ impl<'tcx> LateLintPass<'tcx> for NoEffect {\n             if has_no_effect(cx, expr) {\n                 span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n-                let mut snippet = String::new();\n-                for e in reduced {\n+                for e in &reduced {\n                     if e.span.from_expansion() {\n                         return;\n                     }\n-                    if let Some(snip) = snippet_opt(cx, e.span) {\n-                        snippet.push_str(&snip);\n-                        snippet.push(';');\n-                    } else {\n-                        return;\n+                }\n+                if let ExprKind::Index(..) = &expr.kind {\n+                    let snippet;\n+                    if_chain! {\n+                        if let Some(arr) = snippet_opt(cx, reduced[0].span);\n+                        if let Some(func) = snippet_opt(cx, reduced[1].span);\n+                        then {\n+                            snippet = format!(\"assert!({}.len() > {});\", &arr, &func);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    span_lint_hir_and_then(\n+                        cx,\n+                        UNNECESSARY_OPERATION,\n+                        expr.hir_id,\n+                        stmt.span,\n+                        \"unnecessary operation\",\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                stmt.span,\n+                                \"statement can be written as\",\n+                                snippet,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        },\n+                    );\n+                } else {\n+                    let mut snippet = String::new();\n+                    for e in reduced {\n+                        if let Some(snip) = snippet_opt(cx, e.span) {\n+                            snippet.push_str(&snip);\n+                            snippet.push(';');\n+                        } else {\n+                            return;\n+                        }\n                     }\n+                    span_lint_hir_and_then(\n+                        cx,\n+                        UNNECESSARY_OPERATION,\n+                        expr.hir_id,\n+                        stmt.span,\n+                        \"unnecessary operation\",\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                stmt.span,\n+                                \"statement can be reduced to\",\n+                                snippet,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    );\n                 }\n-                span_lint_hir_and_then(\n-                    cx,\n-                    UNNECESSARY_OPERATION,\n-                    expr.hir_id,\n-                    stmt.span,\n-                    \"statement can be reduced\",\n-                    |diag| {\n-                        diag.span_suggestion(stmt.span, \"replace it with\", snippet, Applicability::MachineApplicable);\n-                    },\n-                );\n             }\n         }\n     }"}, {"sha": "5752342cf623b67e55292b5079b2c89ab43fa8cb", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -31,11 +31,11 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(path, _, arguments, _) = e.kind {\n-            let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n+        if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &e.kind {\n+            let obj_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n-                get_open_options(cx, &arguments[0], &mut options);\n+                get_open_options(cx, self_arg, &mut options);\n                 check_open_options(cx, &options, e.span);\n             }\n         }"}, {"sha": "15f6dcae8870b498563190acabdb263ff9e49e17", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -2,12 +2,14 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n+use clippy_utils::{\n+    can_move_expr_to_closure, eager_or_lazy, in_constant, in_macro, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n+    CaptureKind,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, UnOp};\n+use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -58,7 +60,7 @@ declare_clippy_lint! {\n     /// }, |foo| foo);\n     /// ```\n     pub OPTION_IF_LET_ELSE,\n-    pedantic,\n+    nursery,\n     \"reimplementation of Option::map_or\"\n }\n \n@@ -125,20 +127,30 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n+        if !in_constant(cx, expr.hir_id);\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+            = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(if_then);\n-        if !contains_return_break_continue_macro(if_else);\n+        if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n+        if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n+        if some_captures\n+            .iter()\n+            .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n+            .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_expr(if_then)?;\n             let none_body = extract_body_from_expr(if_else)?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n+                \"map_or\"\n+            } else {\n+                \"map_or_else\"\n+            };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n@@ -150,6 +162,24 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n                 _ => let_expr,\n             };\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if as_ref || as_mut {\n+                let e = peel_hir_expr_while(cond_expr, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(local_id), .. })) = e.kind {\n+                    match some_captures.get(local_id)\n+                        .or_else(|| (method_sugg == \"map_or_else\").then(|| ()).and_then(|_| none_captures.get(local_id)))\n+                    {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if as_mut => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),"}, {"sha": "e7bc24465908b43851b87e2af2483e6ac7758028", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n             }\n         }\n         if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n-            if let Some(ref expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n+            if let Some(expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n                 if in_external_macro(cx.sess(), let_pat.span) {\n                     return;\n                 }"}, {"sha": "cfb5287c6673fabe6a5a0642472916f768f9fe39", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -92,13 +92,13 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(path_segment, _, args, _) = expr.kind {\n-        if is_expr_ty_raw_ptr(cx, &args[0]) {\n+    if let ExprKind::MethodCall(path_segment, _, [arg_0, arg_1, ..], _) = &expr.kind {\n+        if is_expr_ty_raw_ptr(cx, arg_0) {\n             if path_segment.ident.name == sym::offset {\n-                return Some((&args[0], &args[1], Method::Offset));\n+                return Some((arg_0, arg_1, Method::Offset));\n             }\n             if path_segment.ident.name == sym!(wrapping_offset) {\n-                return Some((&args[0], &args[1], Method::WrappingOffset));\n+                return Some((arg_0, arg_1, Method::WrappingOffset));\n             }\n         }\n     }"}, {"sha": "e79cd7ed4ec4a969c95a2c0db407735712130d81", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -97,15 +97,16 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+                = higher::IfLet::hir(cx, expr);\n             if Self::is_option(cx, let_expr);\n \n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n             if is_lang_ctor(cx, path1, OptionSome);\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n-            if let ExprKind::Block(ref block, None) = if_then.kind;\n+            if let ExprKind::Block(block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);"}, {"sha": "cfa12ef3a321dd7ba04fbd992c819aaa24436ed7", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -625,7 +625,10 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 .flat_map(HybridBitSet::iter)\n                 .collect();\n \n-            if ContainsRegion(self.cx.tcx).visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+            if ContainsRegion(self.cx.tcx)\n+                .visit_ty(self.body.local_decls[*dest].ty)\n+                .is_break()\n+            {\n                 mutable_variables.push(*dest);\n             }\n "}, {"sha": "90e3c3f4b3e98f78121f2d23f43bc4a1c89148f6", "filename": "src/tools/clippy/clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -51,9 +51,7 @@ impl ReturnVisitor {\n \n impl<'ast> ast_visit::Visitor<'ast> for ReturnVisitor {\n     fn visit_expr(&mut self, ex: &'ast ast::Expr) {\n-        if let ast::ExprKind::Ret(_) = ex.kind {\n-            self.found_return = true;\n-        } else if let ast::ExprKind::Try(_) = ex.kind {\n+        if let ast::ExprKind::Ret(_) | ast::ExprKind::Try(_) = ex.kind {\n             self.found_return = true;\n         }\n "}, {"sha": "341b5a61631dff896fb93510799316fb6cb324a3", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -206,13 +206,10 @@ fn check_final_expr<'tcx>(\n         // an if/if let expr, check both exprs\n         // note, if without else is going to be a type checking error anyways\n         // (except for unit type functions) so we don't match it\n-        ExprKind::Match(_, arms, source) => match source {\n-            MatchSource::Normal => {\n-                for arm in arms.iter() {\n-                    check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n-                }\n-            },\n-            _ => (),\n+        ExprKind::Match(_, arms, MatchSource::Normal) => {\n+            for arm in arms.iter() {\n+                check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n+            }\n         },\n         ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),\n         _ => (),"}, {"sha": "13d8f954c44138cd1bad5835adac4d8f7251d496", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -345,9 +345,9 @@ declare_lint_pass!(StrToString => [STR_TO_STRING]);\n impl LateLintPass<'_> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, ty, ..) = ty.kind();\n             if *ty.kind() == ty::Str;\n             then {\n@@ -394,9 +394,9 @@ declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n impl LateLintPass<'_> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args, _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(self_arg);\n             if is_type_diagnostic_item(cx, ty, sym::string_type);\n             then {\n                 span_lint_and_help("}, {"sha": "b7414cec87cd2f3a6600d2525d61a3bea3625e88", "filename": "src/tools/clippy/clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -92,11 +92,11 @@ impl LateLintPass<'_> for ToStringInDisplay {\n         if_chain! {\n             if self.in_display_impl;\n             if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, [ref self_arg, ..], _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n-            if path_to_local_id(&args[0], self_hir_id);\n+            if path_to_local_id(self_arg, self_hir_id);\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "9588de8459cfe3f337b2351cc6afc5b6c6e8b800", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -295,6 +295,7 @@ declare_clippy_lint! {\n pub struct Types {\n     vec_box_size_threshold: u64,\n     type_complexity_threshold: u64,\n+    avoid_breaking_exported_api: bool,\n }\n \n impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, RC_MUTEX, TYPE_COMPLEXITY]);\n@@ -308,19 +309,31 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n             false\n         };\n \n+        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(id));\n+\n         self.check_fn_decl(\n             cx,\n             decl,\n             CheckTyContext {\n                 is_in_trait_impl,\n+                is_exported,\n                 ..CheckTyContext::default()\n             },\n         );\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let is_exported = cx.access_levels.is_exported(item.def_id);\n+\n         match item.kind {\n-            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(cx, ty, CheckTyContext::default()),\n+            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_exported,\n+                    ..CheckTyContext::default()\n+                },\n+            ),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n@@ -342,15 +355,31 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, field.ty, CheckTyContext::default());\n+        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n+\n+        self.check_ty(\n+            cx,\n+            field.ty,\n+            CheckTyContext {\n+                is_exported,\n+                ..CheckTyContext::default()\n+            },\n+        );\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n+        let is_exported = cx.access_levels.is_exported(item.def_id);\n+\n+        let context = CheckTyContext {\n+            is_exported,\n+            ..CheckTyContext::default()\n+        };\n+\n         match item.kind {\n             TraitItemKind::Const(ty, _) | TraitItemKind::Type(_, Some(ty)) => {\n-                self.check_ty(cx, ty, CheckTyContext::default());\n+                self.check_ty(cx, ty, context);\n             },\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, CheckTyContext::default()),\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, context),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n@@ -370,10 +399,11 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n }\n \n impl Types {\n-    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64) -> Self {\n+    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64, avoid_breaking_exported_api: bool) -> Self {\n         Self {\n             vec_box_size_threshold,\n             type_complexity_threshold,\n+            avoid_breaking_exported_api,\n         }\n     }\n \n@@ -410,17 +440,24 @@ impl Types {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n-                    let mut triggered = false;\n-                    triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n-                    triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= linked_list::check(cx, hir_ty, def_id);\n-                    triggered |= rc_mutex::check(cx, hir_ty, qpath, def_id);\n-\n-                    if triggered {\n-                        return;\n+                    if self.is_type_change_allowed(context) {\n+                        // All lints that are being checked in this block are guarded by\n+                        // the `avoid_breaking_exported_api` configuration. When adding a\n+                        // new lint, please also add the name to the configuration documentation\n+                        // in `clippy_lints::utils::conf.rs`\n+\n+                        let mut triggered = false;\n+                        triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n+                        triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= linked_list::check(cx, hir_ty, def_id);\n+                        triggered |= rc_mutex::check(cx, hir_ty, qpath, def_id);\n+\n+                        if triggered {\n+                            return;\n+                        }\n                     }\n                 }\n                 match *qpath {\n@@ -487,11 +524,21 @@ impl Types {\n             _ => {},\n         }\n     }\n+\n+    /// This function checks if the type is allowed to change in the current context\n+    /// based on the `avoid_breaking_exported_api` configuration\n+    fn is_type_change_allowed(&self, context: CheckTyContext) -> bool {\n+        !(context.is_exported && self.avoid_breaking_exported_api)\n+    }\n }\n \n+#[allow(clippy::struct_excessive_bools)]\n #[derive(Clone, Copy, Default)]\n struct CheckTyContext {\n     is_in_trait_impl: bool,\n+    /// `true` for types on local variables.\n     is_local: bool,\n+    /// `true` for types that are part of the public API.\n+    is_exported: bool,\n     is_nested_call: bool,\n }"}, {"sha": "12db7afb81ca113dd822582d6b16c65e815a3b39", "filename": "src/tools/clippy/clippy_lints/src/types/rc_mutex.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_ty_param_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n@@ -11,13 +11,14 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n     if_chain! {\n         if cx.tcx.is_diagnostic_item(sym::Rc, def_id) ;\n         if let Some(_) = is_ty_param_diagnostic_item(cx, qpath, sym!(mutex_type)) ;\n-\n-        then{\n-            span_lint(\n+        then {\n+            span_lint_and_help(\n                 cx,\n                 RC_MUTEX,\n                 hir_ty.span,\n-                \"found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\",\n+                \"usage of `Rc<Mutex<_>>`\",\n+                None,\n+                \"consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\",\n             );\n             return true;\n         }"}, {"sha": "ac7bdd6a1ebebf318c6e8eab2a46bbcb999b2328", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -54,7 +54,13 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         _ => return false,\n     };\n     let inner_span = match get_qpath_generic_tys(inner_qpath).next() {\n-        Some(ty) => ty.span,\n+        Some(ty) => {\n+            // Box<Box<dyn T>> is smaller than Box<dyn T> because of wide pointers\n+            if matches!(ty.kind, TyKind::TraitObject(..)) {\n+                return false;\n+            }\n+            ty.span\n+        },\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "095706165936237e7921422b29c23daa080bd84d", "filename": "src/tools/clippy/clippy_lints/src/undropped_manually_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -37,8 +37,8 @@ declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n \n impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(args) = match_function_call(cx, expr, &paths::DROP) {\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n+        if let Some([arg_0, ..]) = match_function_call(cx, expr, &paths::DROP) {\n+            let ty = cx.typeck_results().expr_ty(arg_0);\n             if is_type_lang_item(cx, ty, lang_items::LangItem::ManuallyDrop) {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "61670fe124e36f54055be9a58e1465e51ecfd9b1", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -218,7 +218,10 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n \n fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    matches!(ty.kind(), ty::Ref(..)) || ty.walk(cx.tcx).any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+    matches!(ty.kind(), ty::Ref(..))\n+        || ty\n+            .walk(cx.tcx)\n+            .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "f4808682b69279dc1e4445d7c00770c030748866", "filename": "src/tools/clippy/clippy_lints/src/unused_async.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, Item, ItemKind, YieldSource};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, YieldSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -57,11 +57,6 @@ impl<'a, 'tcx> Visitor<'tcx> for AsyncFnVisitor<'a, 'tcx> {\n }\n \n impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n-    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        if let ItemKind::Trait(..) = item.kind {\n-            return;\n-        }\n-    }\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,"}, {"sha": "031b182bd2fa0cdb68cad28c905db1ae5376dc6e", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -45,20 +45,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n \n         match expr.kind {\n             hir::ExprKind::Match(res, _, _) if is_try(cx, expr).is_some() => {\n-                if let hir::ExprKind::Call(func, args) = res.kind {\n+                if let hir::ExprKind::Call(func, [ref arg_0, ..]) = res.kind {\n                     if matches!(\n                         func.kind,\n                         hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::TryTraitBranch, _))\n                     ) {\n-                        check_map_error(cx, &args[0], expr);\n+                        check_map_error(cx, arg_0, expr);\n                     }\n                 } else {\n                     check_map_error(cx, res, expr);\n                 }\n             },\n-            hir::ExprKind::MethodCall(path, _, args, _) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, _, [ref arg_0, ..], _) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n-                    check_map_error(cx, &args[0], expr);\n+                    check_map_error(cx, arg_0, expr);\n                 },\n                 _ => (),\n             },"}, {"sha": "e7e249c79a2fad0f6f97e1a8110d62b41f763029", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use if_chain::if_chain;\n use rustc_hir::{Impl, ImplItem, ImplItemKind, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,8 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n-            let self_hir_id = self_param.pat.hir_id;\n-            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n+            if !is_local_used(cx, body, self_param.pat.hir_id);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "b2ab300c2e937faed6ef49aaff09957203807dfb", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 111, "deletions": 22, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, usage::is_potentially_mutated};\n+use clippy_utils::{differing_macro_contexts, path_to_local, usage::is_potentially_mutated};\n use if_chain::if_chain;\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnOp};\n+use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, PathSegment, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -74,26 +75,61 @@ struct UnwrappableVariablesVisitor<'a, 'tcx> {\n     unwrappables: Vec<UnwrapInfo<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n+\n+/// What kind of unwrappable this is.\n+#[derive(Copy, Clone, Debug)]\n+enum UnwrappableKind {\n+    Option,\n+    Result,\n+}\n+\n+impl UnwrappableKind {\n+    fn success_variant_pattern(self) -> &'static str {\n+        match self {\n+            UnwrappableKind::Option => \"Some(..)\",\n+            UnwrappableKind::Result => \"Ok(..)\",\n+        }\n+    }\n+\n+    fn error_variant_pattern(self) -> &'static str {\n+        match self {\n+            UnwrappableKind::Option => \"None\",\n+            UnwrappableKind::Result => \"Err(..)\",\n+        }\n+    }\n+}\n+\n /// Contains information about whether a variable can be unwrapped.\n #[derive(Copy, Clone, Debug)]\n struct UnwrapInfo<'tcx> {\n     /// The variable that is checked\n-    ident: &'tcx Path<'tcx>,\n+    local_id: HirId,\n+    /// The if itself\n+    if_expr: &'tcx Expr<'tcx>,\n     /// The check, like `x.is_ok()`\n     check: &'tcx Expr<'tcx>,\n+    /// The check's name, like `is_ok`\n+    check_name: &'tcx PathSegment<'tcx>,\n     /// The branch where the check takes place, like `if x.is_ok() { .. }`\n     branch: &'tcx Expr<'tcx>,\n     /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n     safe_to_unwrap: bool,\n+    /// What kind of unwrappable this is.\n+    kind: UnwrappableKind,\n+    /// If the check is the entire condition (`if x.is_ok()`) or only a part of it (`foo() &&\n+    /// x.is_ok()`)\n+    is_entire_condition: bool,\n }\n \n /// Collects the information about unwrappable variables from an if condition\n /// The `invert` argument tells us whether the condition is negated.\n fn collect_unwrap_info<'tcx>(\n     cx: &LateContext<'tcx>,\n+    if_expr: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n     branch: &'tcx Expr<'_>,\n     invert: bool,\n+    is_entire_condition: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     fn is_relevant_option_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n         is_type_diagnostic_item(cx, ty, sym::option_type) && [\"is_some\", \"is_none\"].contains(&method_name)\n@@ -106,18 +142,18 @@ fn collect_unwrap_info<'tcx>(\n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n             (false, BinOpKind::And | BinOpKind::BitAnd) | (true, BinOpKind::Or | BinOpKind::BitOr) => {\n-                let mut unwrap_info = collect_unwrap_info(cx, left, branch, invert);\n-                unwrap_info.append(&mut collect_unwrap_info(cx, right, branch, invert));\n+                let mut unwrap_info = collect_unwrap_info(cx, if_expr, left, branch, invert, false);\n+                unwrap_info.append(&mut collect_unwrap_info(cx, if_expr, right, branch, invert, false));\n                 return unwrap_info;\n             },\n             _ => (),\n         }\n     } else if let ExprKind::Unary(UnOp::Not, expr) = &expr.kind {\n-        return collect_unwrap_info(cx, expr, branch, !invert);\n+        return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n+            if let Some(local_id) = path_to_local(&args[0]);\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n@@ -129,19 +165,42 @@ fn collect_unwrap_info<'tcx>(\n                     _ => unreachable!(),\n                 };\n                 let safe_to_unwrap = unwrappable != invert;\n-                return vec![UnwrapInfo { ident: path, check: expr, branch, safe_to_unwrap }];\n+                let kind = if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+                    UnwrappableKind::Option\n+                } else {\n+                    UnwrappableKind::Result\n+                };\n+\n+                return vec![\n+                    UnwrapInfo {\n+                        local_id,\n+                        if_expr,\n+                        check: expr,\n+                        check_name: method_name,\n+                        branch,\n+                        safe_to_unwrap,\n+                        kind,\n+                        is_entire_condition,\n+                    }\n+                ]\n             }\n         }\n     }\n     Vec::new()\n }\n \n impl<'a, 'tcx> UnwrappableVariablesVisitor<'a, 'tcx> {\n-    fn visit_branch(&mut self, cond: &'tcx Expr<'_>, branch: &'tcx Expr<'_>, else_branch: bool) {\n+    fn visit_branch(\n+        &mut self,\n+        if_expr: &'tcx Expr<'_>,\n+        cond: &'tcx Expr<'_>,\n+        branch: &'tcx Expr<'_>,\n+        else_branch: bool,\n+    ) {\n         let prev_len = self.unwrappables.len();\n-        for unwrap_info in collect_unwrap_info(self.cx, cond, branch, else_branch) {\n-            if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n-                || is_potentially_mutated(unwrap_info.ident, branch, self.cx)\n+        for unwrap_info in collect_unwrap_info(self.cx, if_expr, cond, branch, else_branch, true) {\n+            if is_potentially_mutated(unwrap_info.local_id, cond, self.cx)\n+                || is_potentially_mutated(unwrap_info.local_id, branch, self.cx)\n             {\n                 // if the variable is mutated, we don't know whether it can be unwrapped:\n                 continue;\n@@ -163,32 +222,62 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         }\n         if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n             walk_expr(self, cond);\n-            self.visit_branch(cond, then, false);\n+            self.visit_branch(expr, cond, then, false);\n             if let Some(else_inner) = r#else {\n-                self.visit_branch(cond, else_inner, true);\n+                self.visit_branch(expr, cond, else_inner, true);\n             }\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n                 if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(None, path)) = args[0].kind;\n-                if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n-                let call_to_unwrap = method_name.ident.name == sym::unwrap;\n+                if let Some(id) = path_to_local(&args[0]);\n+                if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n+                let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);\n                 if let Some(unwrappable) = self.unwrappables.iter()\n-                    .find(|u| u.ident.res == path.res);\n+                    .find(|u| u.local_id == id);\n                 // Span contexts should not differ with the conditional branch\n                 if !differing_macro_contexts(unwrappable.branch.span, expr.span);\n                 if !differing_macro_contexts(unwrappable.branch.span, unwrappable.check.span);\n                 then {\n                     if call_to_unwrap == unwrappable.safe_to_unwrap {\n+                        let is_entire_condition = unwrappable.is_entire_condition;\n+                        let unwrappable_variable_name = self.cx.tcx.hir().name(unwrappable.local_id);\n+                        let suggested_pattern = if call_to_unwrap {\n+                            unwrappable.kind.success_variant_pattern()\n+                        } else {\n+                            unwrappable.kind.error_variant_pattern()\n+                        };\n+\n                         span_lint_and_then(\n                             self.cx,\n                             UNNECESSARY_UNWRAP,\n                             expr.span,\n-                            &format!(\"you checked before that `{}()` cannot fail, \\\n-                            instead of checking and unwrapping, it's better to use `if let` or `match`\",\n-                            method_name.ident.name),\n-                            |diag| { diag.span_label(unwrappable.check.span, \"the check is happening here\"); },\n+                            &format!(\n+                                \"called `{}` on `{}` after checking its variant with `{}`\",\n+                                method_name.ident.name,\n+                                unwrappable_variable_name,\n+                                unwrappable.check_name.ident.as_str(),\n+                            ),\n+                            |diag| {\n+                                if is_entire_condition {\n+                                    diag.span_suggestion(\n+                                        unwrappable.check.span.with_lo(unwrappable.if_expr.span.lo()),\n+                                        \"try\",\n+                                        format!(\n+                                            \"if let {} = {}\",\n+                                            suggested_pattern,\n+                                            unwrappable_variable_name,\n+                                        ),\n+                                        // We don't track how the unwrapped value is used inside the\n+                                        // block or suggest deleting the unwrap, so we can't offer a\n+                                        // fixable solution.\n+                                        Applicability::Unspecified,\n+                                    );\n+                                } else {\n+                                    diag.span_label(unwrappable.check.span, \"the check is happening here\");\n+                                    diag.help(\"try using `if let` or `match`\");\n+                                }\n+                            },\n                         );\n                     } else {\n                         span_lint_and_then("}, {"sha": "8651fa6fcf9eaddeee67be294468d6b9afd573f9", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -31,9 +31,6 @@ impl TryConf {\n     }\n }\n \n-/// Note that the configuration parsing currently doesn't support documentation that will\n-/// that spans over several lines. This will be possible with the new implementation\n-/// See (rust-clippy#7172)\n macro_rules! define_Conf {\n     ($(\n         $(#[doc = $doc:literal])+\n@@ -130,13 +127,12 @@ macro_rules! define_Conf {\n     };\n }\n \n-// N.B., this macro is parsed by util/lintlib.py\n define_Conf! {\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_VEC, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "43590cc786236f2640c751f69877b3ee4f96ca6b", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -142,7 +142,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::Let(ref pat, ref expr, _) => {\n+        hir::ExprKind::Let(pat, expr, _) => {\n             print_pat(cx, pat, indent + 1);\n             print_expr(cx, expr, indent + 1);\n         },"}, {"sha": "756c33d70c26d319769a023da4125fadd10c4a59", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n@@ -17,8 +18,8 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MatchSource, MutTy, Mutability, Node, Path, Stmt,\n-    StmtKind, Ty, TyKind, UnOp,\n+    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    TyKind, UnOp,\n };\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -503,10 +504,10 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n-            let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, ty, &paths::EARLY_CONTEXT)\n                 || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n@@ -1106,16 +1107,10 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        let (cond, then, els) = match expr.kind {\n-            ExprKind::If(cond, then, els) => (Some(cond), then, els.is_some()),\n-            ExprKind::Match(\n-                _,\n-                [arm, ..],\n-                MatchSource::IfLetDesugar {\n-                    contains_else_clause: els,\n-                },\n-            ) => (None, arm.body, els),\n-            _ => return,\n+        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n+            (cond, then, r#else.is_some())\n+        } else {\n+            return;\n         };\n         let then_block = match then.kind {\n             ExprKind::Block(block, _) => block,\n@@ -1131,7 +1126,6 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n         };\n         // check for `if a && b;`\n         if_chain! {\n-            if let Some(cond) = cond;\n             if let ExprKind::Binary(op, _, _) = cond.kind;\n             if op.node == BinOpKind::And;\n             if cx.sess().source_map().is_multiline(cond.span);\n@@ -1166,9 +1160,7 @@ fn check_nested_if_chains(\n         _ => return,\n     };\n     if_chain! {\n-        if matches!(tail.kind,\n-            ExprKind::If(_, _, None)\n-            | ExprKind::Match(.., MatchSource::IfLetDesugar { contains_else_clause: false }));\n+        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n         let sm = cx.sess().source_map();\n         if head\n             .iter()"}, {"sha": "188d0419c3993c9589b872ece99c6ee2e575a7e8", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -82,7 +82,7 @@ This lint has the following configuration variables:\n /// `default`\n macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n     () => {\n-        \"* {name}: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n+        \"* `{name}`: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n     };\n }\n \n@@ -786,8 +786,6 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n             }\n         };\n \n-        // TODO xFrednet 2021-03-01: support function arguments?\n-\n         intravisit::walk_expr(self, expr);\n     }\n }"}, {"sha": "d124d948b5e69d0b57210f5ffc1e588b786d6b41", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, ref addressee) = expr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n             if let Some(vec_args) = higher::VecArgs::hir(cx, addressee);\n             then {\n                 self.check_vec_macro(cx, &vec_args, mutability, expr.span);"}, {"sha": "4c038a997952aba3ff2fd6a14384e17d077badba", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,15 +1,11 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.56\"\n+version = \"0.1.57\"\n edition = \"2018\"\n publish = false\n \n [dependencies]\n if_chain = \"1.0.0\"\n-itertools = \"0.9\"\n-regex-syntax = \"0.6\"\n-serde = { version = \"1.0\", features = [\"derive\"] }\n-unicode-normalization = \"0.1\"\n rustc-semver=\"1.1.0\"\n \n [features]"}, {"sha": "9302e5c21faa4f7606d485726bcbf256aba1cfb8", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -21,7 +21,7 @@ fn docs_link(diag: &mut DiagnosticBuilder<'_>, lint: &'static Lint) {\n                 \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n                 &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n                     // extract just major + minor version and ignore patch versions\n-                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n+                    format!(\"rust-{}\", n.rsplit_once('.').unwrap().1)\n                 }),\n                 lint\n             ));"}, {"sha": "05a4a0143195080328d5d06788bb9d1bd75ffdc8", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 110, "deletions": 55, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -6,33 +6,38 @@ use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{Block, BorrowKind, Expr, ExprKind, LoopSource, Node, Pat, StmtKind, UnOp};\n+use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n pub struct ForLoop<'tcx> {\n+    /// `for` loop item\n     pub pat: &'tcx hir::Pat<'tcx>,\n+    /// `IntoIterator` argument\n     pub arg: &'tcx hir::Expr<'tcx>,\n+    /// `for` loop body\n     pub body: &'tcx hir::Expr<'tcx>,\n+    /// entire `for` loop span\n     pub span: Span,\n }\n \n impl<'tcx> ForLoop<'tcx> {\n     #[inline]\n+    /// Parses a desugared `for` loop\n     pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n         if_chain! {\n-            if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+            if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n             if let Some(first_arm) = arms.get(0);\n-            if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n+            if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n             if let Some(first_arg) = iterargs.get(0);\n             if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n-            if let hir::ExprKind::Loop(ref block, ..) = first_arm.body.kind;\n+            if let hir::ExprKind::Loop(block, ..) = first_arm.body.kind;\n             if block.expr.is_none();\n             if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-            if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n-            if let hir::StmtKind::Expr(ref body_expr) = body.kind;\n+            if let hir::StmtKind::Local(local) = let_stmt.kind;\n+            if let hir::StmtKind::Expr(body_expr) = body.kind;\n             then {\n                 return Some(Self {\n                     pat: &*local.pat,\n@@ -46,14 +51,19 @@ impl<'tcx> ForLoop<'tcx> {\n     }\n }\n \n+/// An `if` expression without `DropTemps`\n pub struct If<'hir> {\n+    /// `if` condition\n     pub cond: &'hir Expr<'hir>,\n-    pub r#else: Option<&'hir Expr<'hir>>,\n+    /// `if` then expression\n     pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> If<'hir> {\n     #[inline]\n+    /// Parses an `if` expression\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n@@ -64,21 +74,27 @@ impl<'hir> If<'hir> {\n             r#else,\n         ) = expr.kind\n         {\n-            Some(Self { cond, r#else, then })\n+            Some(Self { cond, then, r#else })\n         } else {\n             None\n         }\n     }\n }\n \n+/// An `if let` expression\n pub struct IfLet<'hir> {\n+    /// `if let` pattern\n     pub let_pat: &'hir Pat<'hir>,\n+    /// `if let` scrutinee\n     pub let_expr: &'hir Expr<'hir>,\n+    /// `if let` then expression\n     pub if_then: &'hir Expr<'hir>,\n+    /// `if let` else expression\n     pub if_else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> IfLet<'hir> {\n+    /// Parses an `if let` expression\n     pub fn hir(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n@@ -92,7 +108,14 @@ impl<'hir> IfLet<'hir> {\n             let hir = cx.tcx.hir();\n             let mut iter = hir.parent_iter(expr.hir_id);\n             if let Some((_, Node::Block(Block { stmts: [], .. }))) = iter.next() {\n-                if let Some((_, Node::Expr(Expr { kind: ExprKind::Loop(_, _, LoopSource::While, _), .. }))) = iter.next() {\n+                if let Some((\n+                    _,\n+                    Node::Expr(Expr {\n+                        kind: ExprKind::Loop(_, _, LoopSource::While, _),\n+                        ..\n+                    }),\n+                )) = iter.next()\n+                {\n                     // while loop desugar\n                     return None;\n                 }\n@@ -108,14 +131,49 @@ impl<'hir> IfLet<'hir> {\n     }\n }\n \n+/// An `if let` or `match` expression. Useful for lints that trigger on one or the other.\n+pub enum IfLetOrMatch<'hir> {\n+    /// Any `match` expression\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n+    /// scrutinee, pattern, then block, else block\n+    IfLet(\n+        &'hir Expr<'hir>,\n+        &'hir Pat<'hir>,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n+}\n+\n+impl<'hir> IfLetOrMatch<'hir> {\n+    /// Parses an `if let` or `match` expression\n+    pub fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n+        match expr.kind {\n+            ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n+            _ => IfLet::hir(cx, expr).map(\n+                |IfLet {\n+                     let_expr,\n+                     let_pat,\n+                     if_then,\n+                     if_else,\n+                 }| { Self::IfLet(let_expr, let_pat, if_then, if_else) },\n+            ),\n+        }\n+    }\n+}\n+\n+/// An `if` or `if let` expression\n pub struct IfOrIfLet<'hir> {\n+    /// `if` condition that is maybe a `let` expression\n     pub cond: &'hir Expr<'hir>,\n-    pub r#else: Option<&'hir Expr<'hir>>,\n+    /// `if` then expression\n     pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> IfOrIfLet<'hir> {\n     #[inline]\n+    /// Parses an `if` or `if let` expression\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(cond, then, r#else) = expr.kind {\n             if let ExprKind::DropTemps(new_cond) = cond.kind {\n@@ -126,7 +184,7 @@ impl<'hir> IfOrIfLet<'hir> {\n                 });\n             }\n             if let ExprKind::Let(..) = cond.kind {\n-                return Some(Self { cond, r#else, then });\n+                return Some(Self { cond, then, r#else });\n             }\n         }\n         None\n@@ -155,7 +213,7 @@ impl<'a> Range<'a> {\n         }\n \n         match expr.kind {\n-            hir::ExprKind::Call(ref path, ref args)\n+            hir::ExprKind::Call(path, args)\n                 if matches!(\n                     path.kind,\n                     hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n@@ -167,7 +225,7 @@ impl<'a> Range<'a> {\n                     limits: ast::RangeLimits::Closed,\n                 })\n             },\n-            hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+            hir::ExprKind::Struct(path, fields, None) => match &path {\n                 hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                     start: None,\n                     end: None,\n@@ -213,7 +271,7 @@ impl<'a> VecArgs<'a> {\n     /// from `vec!`.\n     pub fn hir(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<VecArgs<'a>> {\n         if_chain! {\n-            if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let hir::ExprKind::Call(fun, args) = expr.kind;\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             if is_expn_of(fun.span, \"vec\").is_some();\n             if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n@@ -225,10 +283,10 @@ impl<'a> VecArgs<'a> {\n                 else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                     // `vec![a, b, c]` case\n                     if_chain! {\n-                        if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n-                        if let hir::ExprKind::Array(ref args) = boxed.kind;\n+                        if let hir::ExprKind::Box(boxed) = args[0].kind;\n+                        if let hir::ExprKind::Array(args) = boxed.kind;\n                         then {\n-                            return Some(VecArgs::Vec(&*args));\n+                            return Some(VecArgs::Vec(args));\n                         }\n                     }\n \n@@ -247,14 +305,17 @@ impl<'a> VecArgs<'a> {\n     }\n }\n \n+/// A desugared `while` loop\n pub struct While<'hir> {\n-    pub if_cond: &'hir Expr<'hir>,\n-    pub if_then: &'hir Expr<'hir>,\n-    pub if_else: Option<&'hir Expr<'hir>>,\n+    /// `while` loop condition\n+    pub condition: &'hir Expr<'hir>,\n+    /// `while` loop body\n+    pub body: &'hir Expr<'hir>,\n }\n \n impl<'hir> While<'hir> {\n     #[inline]\n+    /// Parses a desugared `while` loop\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::Loop(\n             Block {\n@@ -263,11 +324,11 @@ impl<'hir> While<'hir> {\n                         kind:\n                             ExprKind::If(\n                                 Expr {\n-                                    kind: ExprKind::DropTemps(if_cond),\n+                                    kind: ExprKind::DropTemps(condition),\n                                     ..\n                                 },\n-                                if_then,\n-                                if_else_ref,\n+                                body,\n+                                _,\n                             ),\n                         ..\n                     }),\n@@ -278,59 +339,53 @@ impl<'hir> While<'hir> {\n             _,\n         ) = expr.kind\n         {\n-            let if_else = *if_else_ref;\n-            return Some(Self {\n-                if_cond,\n-                if_then,\n-                if_else,\n-            });\n+            return Some(Self { condition, body });\n         }\n         None\n     }\n }\n \n+/// A desugared `while let` loop\n pub struct WhileLet<'hir> {\n-    pub if_expr: &'hir Expr<'hir>,\n+    /// `while let` loop item pattern\n     pub let_pat: &'hir Pat<'hir>,\n+    /// `while let` loop scrutinee\n     pub let_expr: &'hir Expr<'hir>,\n+    /// `while let` loop body\n     pub if_then: &'hir Expr<'hir>,\n-    pub if_else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> WhileLet<'hir> {\n     #[inline]\n+    /// Parses a desugared `while let` loop\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::Loop(\n             Block {\n-                expr: Some(if_expr), ..\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::Let(let_pat, let_expr, _),\n+                                    ..\n+                                },\n+                                if_then,\n+                                _,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n             },\n             _,\n             LoopSource::While,\n             _,\n         ) = expr.kind\n         {\n-            if let Expr {\n-                kind:\n-                    ExprKind::If(\n-                        Expr {\n-                            kind: ExprKind::Let(let_pat, let_expr, _),\n-                            ..\n-                        },\n-                        if_then,\n-                        if_else_ref,\n-                    ),\n-                ..\n-            } = if_expr\n-            {\n-                let if_else = *if_else_ref;\n-                return Some(Self {\n-                    if_expr,\n-                    let_pat,\n-                    let_expr,\n-                    if_then,\n-                    if_else,\n-                });\n-            }\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+            });\n         }\n         None\n     }\n@@ -532,7 +587,7 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let Some(ref expr) = local.init;\n+        if let Some(expr) = local.init;\n         if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         then {\n             return true;"}, {"sha": "6e9a1de21eef5cb010d32f668a82565ba1713a35", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -232,9 +232,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprKind::Let(ref lp, ref le, _), &ExprKind::Let(ref rp, ref re, _)) => {\n-                self.eq_pat(lp, rp) && self.eq_expr(le, re)\n-            },\n+            (&ExprKind::Let(lp, le, _), &ExprKind::Let(rp, re, _)) => self.eq_pat(lp, rp) && self.eq_expr(le, re),\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n@@ -668,7 +666,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ExprKind::Let(ref pat, ref expr, _) => {\n+            ExprKind::Let(pat, expr, _) => {\n                 self.hash_expr(expr);\n                 self.hash_pat(pat);\n             },"}, {"sha": "757485d19d25ad6c01fa9cc9b93e80d129cf54de", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 327, "deletions": 30, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(rustc_private)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n@@ -62,23 +63,27 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n+use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::LangItem::{ResultErr, ResultOk};\n+use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n+    PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n-use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::binding::BindingMode;\n+use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -89,7 +94,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -255,7 +260,17 @@ pub fn in_macro(span: Span) -> bool {\n }\n \n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Block(Block { stmts: [], expr: None, .. }, _) | ExprKind::Tup([]))\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: None,\n+                ..\n+            },\n+            _\n+        ) | ExprKind::Tup([])\n+    )\n }\n \n /// Checks if given pattern is a wildcard (`_`)\n@@ -629,12 +644,106 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n     false\n }\n \n+/// Returns true if the `def_id` associated with the `path` is recognized as a \"default-equivalent\"\n+/// constructor from the std library\n+fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<'_>) -> bool {\n+    let std_types_symbols = &[\n+        sym::string_type,\n+        sym::vec_type,\n+        sym::vecdeque_type,\n+        sym::LinkedList,\n+        sym::hashmap_type,\n+        sym::BTreeMap,\n+        sym::hashset_type,\n+        sym::BTreeSet,\n+        sym::BinaryHeap,\n+    ];\n+\n+    if let QPath::TypeRelative(_, method) = path {\n+        if method.ident.name == sym::new {\n+            if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n+                if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n+                    return std_types_symbols\n+                        .iter()\n+                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did));\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns true if the expr is equal to `Default::default()` of it's type when evaluated.\n+/// It doesn't cover all cases, for example indirect function calls (some of std\n+/// functions are supported) but it is the best we have.\n+pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    match &e.kind {\n+        ExprKind::Lit(lit) => match lit.node {\n+            LitKind::Bool(false) | LitKind::Int(0, _) => true,\n+            LitKind::Str(s, _) => s.is_empty(),\n+            _ => false,\n+        },\n+        ExprKind::Tup(items) | ExprKind::Array(items) => items.iter().all(|x| is_default_equivalent(cx, x)),\n+        ExprKind::Repeat(x, _) => is_default_equivalent(cx, x),\n+        ExprKind::Call(repl_func, _) => if_chain! {\n+            if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n+            if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+            if is_diag_trait_item(cx, repl_def_id, sym::Default)\n+                || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n+            then {\n+                true\n+            }\n+            else {\n+                false\n+            }\n+        },\n+        ExprKind::Path(qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+/// Currently checks for:\n+/// * Break/Continue outside the given loop HIR ids.\n+/// * Yield/Return statments.\n+/// * Inline assembly.\n+/// * Usages of a field of a local where the type of the local can be partially moved.\n+///\n+/// For example, given the following function:\n+///\n+/// ```\n+/// fn f<'a>(iter: &mut impl Iterator<Item = (usize, &'a mut String)>) {\n+///     for item in iter {\n+///         let s = item.1;\n+///         if item.0 > 10 {\n+///             continue;\n+///         } else {\n+///             s.clear();\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// When called on the expression `item.0` this will return false unless the local `item` is in the\n+/// `ignore_locals` set. The type `(usize, &mut String)` can have the second element moved, so it\n+/// isn't always safe to move into a closure when only a single field is needed.\n+///\n+/// When called on the `continue` expression this will return false unless the outer loop expression\n+/// is in the `loop_ids` set.\n+///\n+/// Note that this check is not recursive, so passing the `if` expression will always return true\n+/// even though sub-expressions might return false.\n+pub fn can_move_expr_to_closure_no_visit(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    loop_ids: &[HirId],\n+    ignore_locals: &HirIdSet,\n+) -> bool {\n     match expr.kind {\n         ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n         | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n-            if jump_targets.contains(&id) =>\n+            if loop_ids.contains(&id) =>\n         {\n             true\n         },\n@@ -646,25 +755,170 @@ pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Exp\n         | ExprKind::LlvmInlineAsm(_) => false,\n         // Accessing a field of a local value can only be done if the type isn't\n         // partially moved.\n-        ExprKind::Field(base_expr, _)\n-            if matches!(\n-                base_expr.kind,\n-                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n-        {\n+        ExprKind::Field(\n+            &Expr {\n+                hir_id,\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Local(local_id),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            _,\n+        ) if !ignore_locals.contains(local_id) && can_partially_move_ty(cx, cx.typeck_results().node_type(hir_id)) => {\n             // TODO: check if the local has been partially moved. Assume it has for now.\n             false\n-        }\n+        },\n         _ => true,\n     }\n }\n \n-/// Checks if the expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+/// How a local is captured by a closure\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureKind {\n+    Value,\n+    Ref(Mutability),\n+}\n+impl CaptureKind {\n+    pub fn is_imm_ref(self) -> bool {\n+        self == Self::Ref(Mutability::Not)\n+    }\n+}\n+impl std::ops::BitOr for CaptureKind {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self::Output {\n+        match (self, rhs) {\n+            (CaptureKind::Value, _) | (_, CaptureKind::Value) => CaptureKind::Value,\n+            (CaptureKind::Ref(Mutability::Mut), CaptureKind::Ref(_))\n+            | (CaptureKind::Ref(_), CaptureKind::Ref(Mutability::Mut)) => CaptureKind::Ref(Mutability::Mut),\n+            (CaptureKind::Ref(Mutability::Not), CaptureKind::Ref(Mutability::Not)) => CaptureKind::Ref(Mutability::Not),\n+        }\n+    }\n+}\n+impl std::ops::BitOrAssign for CaptureKind {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+/// Given an expression referencing a local, determines how it would be captured in a closure.\n+/// Note as this will walk up to parent expressions until the capture can be determined it should\n+/// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n+/// function argument (other than a receiver).\n+pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+    fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n+        let mut capture = CaptureKind::Ref(Mutability::Not);\n+        pat.each_binding_or_first(&mut |_, id, span, _| match cx\n+            .typeck_results()\n+            .extract_binding_mode(cx.sess(), id, span)\n+            .unwrap()\n+        {\n+            BindingMode::BindByValue(_) if !is_copy(cx, cx.typeck_results().node_type(id)) => {\n+                capture = CaptureKind::Value;\n+            },\n+            BindingMode::BindByReference(Mutability::Mut) if capture != CaptureKind::Value => {\n+                capture = CaptureKind::Ref(Mutability::Mut);\n+            },\n+            _ => (),\n+        });\n+        capture\n+    }\n+\n+    debug_assert!(matches!(\n+        e.kind,\n+        ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(_), .. }))\n+    ));\n+\n+    let map = cx.tcx.hir();\n+    let mut child_id = e.hir_id;\n+    let mut capture = CaptureKind::Value;\n+    let mut capture_expr_ty = e;\n+\n+    for (parent_id, parent) in map.parent_iter(e.hir_id) {\n+        if let [Adjustment {\n+            kind: Adjust::Deref(_) | Adjust::Borrow(AutoBorrow::Ref(..)),\n+            target,\n+        }, ref adjust @ ..] = *cx\n+            .typeck_results()\n+            .adjustments()\n+            .get(child_id)\n+            .map_or(&[][..], |x| &**x)\n+        {\n+            if let rustc_ty::RawPtr(TypeAndMut { mutbl: mutability, .. }) | rustc_ty::Ref(_, _, mutability) =\n+                *adjust.last().map_or(target, |a| a.target).kind()\n+            {\n+                return CaptureKind::Ref(mutability);\n+            }\n+        }\n+\n+        match parent {\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n+                ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n+                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                    return CaptureKind::Ref(Mutability::Mut);\n+                },\n+                ExprKind::Field(..) => {\n+                    if capture == CaptureKind::Value {\n+                        capture_expr_ty = e;\n+                    }\n+                },\n+                ExprKind::Let(pat, ..) => {\n+                    let mutability = match pat_capture_kind(cx, pat) {\n+                        CaptureKind::Value => Mutability::Not,\n+                        CaptureKind::Ref(m) => m,\n+                    };\n+                    return CaptureKind::Ref(mutability);\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    let mut mutability = Mutability::Not;\n+                    for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {\n+                        match capture {\n+                            CaptureKind::Value => break,\n+                            CaptureKind::Ref(Mutability::Mut) => mutability = Mutability::Mut,\n+                            CaptureKind::Ref(Mutability::Not) => (),\n+                        }\n+                    }\n+                    return CaptureKind::Ref(mutability);\n+                },\n+                _ => break,\n+            },\n+            Node::Local(l) => match pat_capture_kind(cx, l.pat) {\n+                CaptureKind::Value => break,\n+                capture @ CaptureKind::Ref(_) => return capture,\n+            },\n+            _ => break,\n+        }\n+\n+        child_id = parent_id;\n+    }\n+\n+    if capture == CaptureKind::Value && is_copy(cx, cx.typeck_results().expr_ty(capture_expr_ty)) {\n+        // Copy types are never automatically captured by value.\n+        CaptureKind::Ref(Mutability::Not)\n+    } else {\n+        capture\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is. This will return a list of captures\n+/// if so, otherwise, `None`.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n+        // Stack of potential break targets contained in the expression.\n         loops: Vec<HirId>,\n+        /// Local variables created in the expression. These don't need to be captured.\n+        locals: HirIdSet,\n+        /// Whether this expression can be turned into a closure.\n         allow_closure: bool,\n+        /// Locals which need to be captured, and whether they need to be by value, reference, or\n+        /// mutable reference.\n+        captures: HirIdMap<CaptureKind>,\n     }\n     impl Visitor<'tcx> for V<'_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n@@ -676,24 +930,67 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n             if !self.allow_closure {\n                 return;\n             }\n-            if let ExprKind::Loop(b, ..) = e.kind {\n-                self.loops.push(e.hir_id);\n-                self.visit_block(b);\n-                self.loops.pop();\n-            } else {\n-                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n-                walk_expr(self, e);\n+\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, &Path { res: Res::Local(l), .. })) => {\n+                    if !self.locals.contains(&l) {\n+                        let cap = capture_local_usage(self.cx, e);\n+                        self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n+                    }\n+                },\n+                ExprKind::Closure(..) => {\n+                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id).to_def_id();\n+                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n+                        let local_id = match capture.place.base {\n+                            PlaceBase::Local(id) => id,\n+                            PlaceBase::Upvar(var) => var.var_path.hir_id,\n+                            _ => continue,\n+                        };\n+                        if !self.locals.contains(&local_id) {\n+                            let capture = match capture.info.capture_kind {\n+                                UpvarCapture::ByValue(_) => CaptureKind::Value,\n+                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                    BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n+                                    BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n+                                        CaptureKind::Ref(Mutability::Mut)\n+                                    },\n+                                },\n+                            };\n+                            self.captures\n+                                .entry(local_id)\n+                                .and_modify(|e| *e |= capture)\n+                                .or_insert(capture);\n+                        }\n+                    }\n+                },\n+                ExprKind::Loop(b, ..) => {\n+                    self.loops.push(e.hir_id);\n+                    self.visit_block(b);\n+                    self.loops.pop();\n+                },\n+                _ => {\n+                    self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n+                    walk_expr(self, e);\n+                },\n             }\n         }\n+\n+        fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+            p.each_binding_or_first(&mut |_, id, _, _| {\n+                self.locals.insert(id);\n+            });\n+        }\n     }\n \n     let mut v = V {\n         cx,\n         allow_closure: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n+        captures: HirIdMap::default(),\n     };\n     v.visit_expr(expr);\n-    v.allow_closure\n+    v.allow_closure.then(|| v.captures)\n }\n \n /// Returns the method names and argument list of nested method call expressions that make up\n@@ -1365,13 +1662,13 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n     while let Some(higher::IfOrIfLet { cond, then, r#else }) = higher::IfOrIfLet::hir(expr) {\n         conds.push(&*cond);\n-        if let ExprKind::Block(ref block, _) = then.kind {\n+        if let ExprKind::Block(block, _) = then.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(ref else_expr) = r#else {\n+        if let Some(else_expr) = r#else {\n             expr = else_expr;\n         } else {\n             break;\n@@ -1708,7 +2005,7 @@ pub fn peel_hir_expr_while<'tcx>(\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n     let mut remaining = count;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) if remaining != 0 => {\n             remaining -= 1;\n             Some(e)\n         },\n@@ -1722,7 +2019,7 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     let mut count = 0;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) => {\n             count += 1;\n             Some(e)\n         },"}, {"sha": "fa57dfbb57edccdc4d384af5ac4a0e226ab9ea2f", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -13,9 +13,12 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,53,0 { OR_PATTERNS }\n+    1,52,0 { STR_SPLIT_ONCE }\n     1,50,0 { BOOL_THEN }\n+    1,47,0 { TAU }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }\n+    1,43,0 { LOG2_10, LOG10_2 }\n     1,42,0 { MATCHES_MACRO }\n     1,41,0 { RE_REBALANCING_COHERENCE, RESULT_MAP_OR_ELSE }\n     1,40,0 { MEM_TAKE, NON_EXHAUSTIVE, OPTION_AS_DEREF }"}, {"sha": "d7e46c2d3eb9d2826966f19fc3d8f98b058a150d", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -68,6 +68,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n+pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]"}, {"sha": "6cb2bd7f6efba33928d8aae0c09aba3ccbd4071b", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -36,9 +36,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::Coerce(_) => {\n-                    panic!(\"coerce predicate on function: {:#?}\", predicate)\n-                },\n+                ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::Trait(pred) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;"}, {"sha": "ab05a0b423853f245ca00b5d2f940383da0d8ef9", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -329,7 +329,7 @@ fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     }\n }\n \n-// Copied from the rust standart library, and then edited\n+/// Copied from the rust standard library, and then edited\n macro_rules! forward_binop_impls_to_ref {\n     (impl $imp:ident, $method:ident for $t:ty, type Output = $o:ty) => {\n         impl $imp<$t> for &$t {"}, {"sha": "d6f9ebe89bc7fe44136d09231399edcde1f9b73a", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, TyCtxt, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -224,6 +224,13 @@ fn is_normalizable_helper<'tcx>(\n     result\n }\n \n+/// Returns true iff the given type is a non aggregate primitive (a bool or char, any integer or\n+/// floating-point number type). For checking aggregation of primitive types (e.g. tuples and slices\n+/// of primitive type) see `is_recursively_primitive_type`\n+pub fn is_non_aggregate_primitive_type(ty: Ty<'_>) -> bool {\n+    matches!(ty.kind(), ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_))\n+}\n+\n /// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n /// number type, a str, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {"}, {"sha": "098ec175fe2d91fcf530df7b6885c81d64e42fa1", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,10 +1,9 @@\n use crate as utils;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::HirIdSet;\n-use rustc_hir::{Expr, ExprKind, HirId, Path};\n+use rustc_hir::{Expr, ExprKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -35,12 +34,8 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n     Some(delegate.used_mutably)\n }\n \n-pub fn is_potentially_mutated<'tcx>(variable: &'tcx Path<'_>, expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> bool {\n-    if let Res::Local(id) = variable.res {\n-        mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n-    } else {\n-        true\n-    }\n+pub fn is_potentially_mutated<'tcx>(variable: HirId, expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> bool {\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&variable))\n }\n \n struct MutVarsDelegate {"}, {"sha": "503effbdad5725069eb4ddc268a08c80ae7b9014", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visito\n use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use std::ops::ControlFlow;\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n@@ -133,62 +134,6 @@ where\n     }\n }\n \n-pub struct LocalUsedVisitor<'hir> {\n-    hir: Map<'hir>,\n-    pub local_hir_id: HirId,\n-    pub used: bool,\n-}\n-\n-impl<'hir> LocalUsedVisitor<'hir> {\n-    pub fn new(cx: &LateContext<'hir>, local_hir_id: HirId) -> Self {\n-        Self {\n-            hir: cx.tcx.hir(),\n-            local_hir_id,\n-            used: false,\n-        }\n-    }\n-\n-    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n-        visit(self, t);\n-        std::mem::replace(&mut self.used, false)\n-    }\n-\n-    pub fn check_arm(&mut self, arm: &'hir Arm<'_>) -> bool {\n-        self.check(arm, Self::visit_arm)\n-    }\n-\n-    pub fn check_body(&mut self, body: &'hir Body<'_>) -> bool {\n-        self.check(body, Self::visit_body)\n-    }\n-\n-    pub fn check_expr(&mut self, expr: &'hir Expr<'_>) -> bool {\n-        self.check(expr, Self::visit_expr)\n-    }\n-\n-    pub fn check_stmt(&mut self, stmt: &'hir Stmt<'_>) -> bool {\n-        self.check(stmt, Self::visit_stmt)\n-    }\n-}\n-\n-impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n-    type Map = Map<'v>;\n-\n-    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n-        if self.used {\n-            return;\n-        }\n-        if path_to_local_id(expr, self.local_hir_id) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir)\n-    }\n-}\n-\n /// A type which can be visited.\n pub trait Visitable<'tcx> {\n     /// Calls the corresponding `visit_*` function on the visitor.\n@@ -203,7 +148,22 @@ macro_rules! visitable_ref {\n         }\n     };\n }\n+visitable_ref!(Arm, visit_arm);\n visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+\n+// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n+// where\n+//     I::Item: Visitable<'tcx>,\n+// {\n+//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+//         for x in self {\n+//             x.visit(visitor);\n+//         }\n+//     }\n+// }\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n@@ -260,3 +220,48 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n     v.visit_expr(&cx.tcx.hir().body(body).value);\n     v.found\n }\n+\n+/// Calls the given function for each usage of the given local.\n+pub fn for_each_local_usage<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    visitable: impl Visitable<'tcx>,\n+    id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'tcx, B, F> {\n+        map: Map<'tcx>,\n+        id: HirId,\n+        f: F,\n+        res: ControlFlow<B>,\n+    }\n+    impl<'tcx, B, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>> Visitor<'tcx> for V<'tcx, B, F> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.map)\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.res.is_continue() {\n+                if path_to_local_id(e, self.id) {\n+                    self.res = (self.f)(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        map: cx.tcx.hir(),\n+        id,\n+        f,\n+        res: ControlFlow::CONTINUE,\n+    };\n+    visitable.visit(&mut v);\n+    v.res\n+}\n+\n+/// Checks if the given local is used.\n+pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n+    for_each_local_usage(cx, visitable, id, |_| ControlFlow::BREAK).is_break()\n+}"}, {"sha": "004eb28b44640fb59ab3d43c31203ab97c622870", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -556,14 +556,15 @@ directory. Adding a configuration to a lint can be useful for thresholds or to c\n behavior that can be seen as a false positive for some users. Adding a configuration is done\n in the following steps:\n \n-1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n+1. Adding a new configuration entry to [clippy_lints::utils::conf](/clippy_lints/src/utils/conf.rs)\n     like this:\n     ```rust\n-    /// Lint: LINT_NAME. <The configuration field doc comment>\n+    /// Lint: LINT_NAME.\n+    ///\n+    /// <The configuration field doc comment>\n     (configuration_ident: Type = DefaultValue),\n     ```\n-    The configuration value and identifier should usually be the same. The doc comment will be\n-    automatically added to the lint documentation.\n+    The doc comment will be automatically added to the lint documentation.\n 2. Adding the configuration value to the lint impl struct:\n     1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n         generated with the `declare_lint_pass!` macro. This struct needs to be defined manually"}, {"sha": "1a6b7c8cb47a9db623f64fe5868d29d5f1dd5a40", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -11,6 +11,7 @@ You may need following tooltips to catch up with common operations.\n \n Useful Rustc dev guide links:\n - [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Diagnostic items](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html)\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n@@ -75,20 +76,21 @@ impl LateLintPass<'_> for MyStructLint {\n \n # Checking if a type implements a specific trait\n \n-There are two ways to do this, depending if the target trait is part of lang items.\n+There are three ways to do this, depending on if the target trait has a diagnostic item, lang item or neither.\n \n ```rust\n-use clippy_utils::{implements_trait, match_trait_method, paths};\n+use clippy_utils::{implements_trait, is_trait_method, match_trait_method, paths};\n+use rustc_span::symbol::sym;\n \n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // 1. Using expression and Clippy's convenient method\n-        // we use `match_trait_method` function from Clippy's toolbox\n-        if match_trait_method(cx, expr, &paths::INTO) {\n-            // `expr` implements `Into` trait\n+        // 1. Using diagnostic items with the expression\n+        // we use `is_trait_method` function from Clippy's utils\n+        if is_trait_method(cx, expr, sym::Iterator) {\n+            // method call in `expr` belongs to `Iterator` trait\n         }\n \n-        // 2. Using type context `TyCtxt`\n+        // 2. Using lang items with the expression type\n         let ty = cx.typeck_results().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n@@ -97,15 +99,20 @@ impl LateLintPass<'_> for MyStructLint {\n             .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n                 // `expr` implements `Drop` trait\n             }\n+\n+        // 3. Using the type path with the expression\n+        // we use `match_trait_method` function from Clippy's utils\n+        if match_trait_method(cx, expr, &paths::INTO) {\n+            // `expr` implements `Into` trait\n+        }\n     }\n }\n ```\n \n-> Prefer using lang items, if the target trait is available there.\n-\n-A list of defined paths for Clippy can be found in [paths.rs][paths]\n+> Prefer using diagnostic and lang items, if the target trait has one.\n \n We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n+A list of defined paths for Clippy can be found in [paths.rs][paths]\n \n # Checking if a type defines a specific method\n "}, {"sha": "ada033de6e3abe08ea16c946228514b4f95298ff", "filename": "src/tools/clippy/lintcheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Flintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Flintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -19,6 +19,7 @@ serde_json = {version = \"1.0\"}\n tar = {version = \"0.4.30\"}\n toml = {version = \"0.5\"}\n ureq = {version = \"2.0.0-rc3\"}\n+walkdir = {version = \"2.3.2\"}\n \n [features]\n deny-warnings = []"}, {"sha": "f1e03ba42966d9bd31e3597f6d00ef0e0e1fe7b3", "filename": "src/tools/clippy/lintcheck/src/main.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -21,6 +21,7 @@ use clap::{App, Arg, ArgMatches};\n use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n+use walkdir::{DirEntry, WalkDir};\n \n #[cfg(not(windows))]\n const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver\";\n@@ -193,32 +194,41 @@ impl CrateSource {\n                 }\n             },\n             CrateSource::Path { name, path, options } => {\n-                use fs_extra::dir;\n-\n-                // simply copy the entire directory into our target dir\n-                let copy_dest = PathBuf::from(format!(\"{}/\", LINTCHECK_SOURCES));\n+                // copy path into the dest_crate_root but skip directories that contain a CACHEDIR.TAG file.\n+                // The target/ directory contains a CACHEDIR.TAG file so it is the most commonly skipped directory\n+                // as a result of this filter.\n+                let dest_crate_root = PathBuf::from(LINTCHECK_SOURCES).join(name);\n+                if dest_crate_root.exists() {\n+                    println!(\"Deleting existing directory at {:?}\", dest_crate_root);\n+                    std::fs::remove_dir_all(&dest_crate_root).unwrap();\n+                }\n \n-                // the source path of the crate we copied,  ${copy_dest}/crate_name\n-                let crate_root = copy_dest.join(name); // .../crates/local_crate\n+                println!(\"Copying {:?} to {:?}\", path, dest_crate_root);\n \n-                if crate_root.exists() {\n-                    println!(\n-                        \"Not copying {} to {}, destination already exists\",\n-                        path.display(),\n-                        crate_root.display()\n-                    );\n-                } else {\n-                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n+                fn is_cache_dir(entry: &DirEntry) -> bool {\n+                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n+                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n+                        .unwrap_or(false)\n+                }\n \n-                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).unwrap_or_else(|_| {\n-                        panic!(\"Failed to copy from {}, to  {}\", path.display(), crate_root.display())\n-                    });\n+                for entry in WalkDir::new(path).into_iter().filter_entry(|e| !is_cache_dir(e)) {\n+                    let entry = entry.unwrap();\n+                    let entry_path = entry.path();\n+                    let relative_entry_path = entry_path.strip_prefix(path).unwrap();\n+                    let dest_path = dest_crate_root.join(relative_entry_path);\n+                    let metadata = entry_path.symlink_metadata().unwrap();\n+\n+                    if metadata.is_dir() {\n+                        std::fs::create_dir(dest_path).unwrap();\n+                    } else if metadata.is_file() {\n+                        std::fs::copy(entry_path, dest_path).unwrap();\n+                    }\n                 }\n \n                 Crate {\n                     version: String::from(\"local\"),\n                     name: name.clone(),\n-                    path: crate_root,\n+                    path: dest_crate_root,\n                     options: options.clone(),\n                 }\n             },"}, {"sha": "92bde3423a20a811c3c05cf0294f4b62c04bcc35", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-08-12\"\n+channel = \"nightly-2021-09-08\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "c63c47690d52ad9e9027ecfa6058217e09eae70f", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 85, "deletions": 74, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,10 +1,12 @@\n #![feature(test)] // compiletest_rs requires this attribute\n #![feature(once_cell)]\n-#![feature(try_blocks)]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use compiletest_rs as compiletest;\n use compiletest_rs::common::Mode as TestMode;\n \n+use std::collections::HashMap;\n use std::env::{self, remove_var, set_var, var_os};\n use std::ffi::{OsStr, OsString};\n use std::fs;\n@@ -16,6 +18,34 @@ mod cargo;\n // whether to run internal tests or not\n const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal-lints\");\n \n+/// All crates used in UI tests are listed here\n+static TEST_DEPENDENCIES: &[&str] = &[\n+    \"clippy_utils\",\n+    \"derive_new\",\n+    \"if_chain\",\n+    \"itertools\",\n+    \"quote\",\n+    \"regex\",\n+    \"serde\",\n+    \"serde_derive\",\n+    \"syn\",\n+];\n+\n+// Test dependencies may need an `extern crate` here to ensure that they show up\n+// in the depinfo file (otherwise cargo thinks they are unused)\n+#[allow(unused_extern_crates)]\n+extern crate clippy_utils;\n+#[allow(unused_extern_crates)]\n+extern crate derive_new;\n+#[allow(unused_extern_crates)]\n+extern crate if_chain;\n+#[allow(unused_extern_crates)]\n+extern crate itertools;\n+#[allow(unused_extern_crates)]\n+extern crate quote;\n+#[allow(unused_extern_crates)]\n+extern crate syn;\n+\n fn host_lib() -> PathBuf {\n     option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n }\n@@ -24,71 +54,58 @@ fn clippy_driver_path() -> PathBuf {\n     option_env!(\"CLIPPY_DRIVER_PATH\").map_or(cargo::TARGET_LIB.join(\"clippy-driver\"), PathBuf::from)\n }\n \n-// When we'll want to use `extern crate ..` for a dependency that is used\n-// both by the crate and the compiler itself, we can't simply pass -L flags\n-// as we'll get a duplicate matching versions. Instead, disambiguate with\n-// `--extern dep=path`.\n-// See https://github.com/rust-lang/rust-clippy/issues/4015.\n-//\n-// FIXME: We cannot use `cargo build --message-format=json` to resolve to dependency files.\n-//        Because it would force-rebuild if the options passed to `build` command is not the same\n-//        as what we manually pass to `cargo` invocation\n-fn third_party_crates() -> String {\n-    use std::collections::HashMap;\n-    static CRATES: &[&str] = &[\n-        \"clippy_lints\",\n-        \"clippy_utils\",\n-        \"if_chain\",\n-        \"quote\",\n-        \"regex\",\n-        \"serde\",\n-        \"serde_derive\",\n-        \"syn\",\n-    ];\n-    let dep_dir = cargo::TARGET_LIB.join(\"deps\");\n-    let mut crates: HashMap<&str, Vec<PathBuf>> = HashMap::with_capacity(CRATES.len());\n-    let mut flags = String::new();\n-    for entry in fs::read_dir(dep_dir).unwrap().flatten() {\n-        let path = entry.path();\n-        if let Some(name) = try {\n-            let name = path.file_name()?.to_str()?;\n-            let (name, _) = name.strip_suffix(\".rlib\")?.strip_prefix(\"lib\")?.split_once('-')?;\n-            CRATES.iter().copied().find(|&c| c == name)?\n-        } {\n-            flags += &format!(\" --extern {}={}\", name, path.display());\n-            crates.entry(name).or_default().push(path.clone());\n+/// Produces a string with an `--extern` flag for all UI test crate\n+/// dependencies.\n+///\n+/// The dependency files are located by parsing the depinfo file for this test\n+/// module. This assumes the `-Z binary-dep-depinfo` flag is enabled. All test\n+/// dependencies must be added to Cargo.toml at the project root. Test\n+/// dependencies that are not *directly* used by this test module require an\n+/// `extern crate` declaration.\n+fn extern_flags() -> String {\n+    let current_exe_depinfo = {\n+        let mut path = env::current_exe().unwrap();\n+        path.set_extension(\"d\");\n+        std::fs::read_to_string(path).unwrap()\n+    };\n+    let mut crates: HashMap<&str, &str> = HashMap::with_capacity(TEST_DEPENDENCIES.len());\n+    for line in current_exe_depinfo.lines() {\n+        // each dependency is expected to have a Makefile rule like `/path/to/crate-hash.rlib:`\n+        let parse_name_path = || {\n+            if line.starts_with(char::is_whitespace) {\n+                return None;\n+            }\n+            let path_str = line.strip_suffix(':')?;\n+            let path = Path::new(path_str);\n+            if !matches!(path.extension()?.to_str()?, \"rlib\" | \"so\" | \"dylib\" | \"dll\") {\n+                return None;\n+            }\n+            let (name, _hash) = path.file_stem()?.to_str()?.rsplit_once('-')?;\n+            // the \"lib\" prefix is not present for dll files\n+            let name = name.strip_prefix(\"lib\").unwrap_or(name);\n+            Some((name, path_str))\n+        };\n+        if let Some((name, path)) = parse_name_path() {\n+            if TEST_DEPENDENCIES.contains(&name) {\n+                // A dependency may be listed twice if it is available in sysroot,\n+                // and the sysroot dependencies are listed first. As of the writing,\n+                // this only seems to apply to if_chain.\n+                crates.insert(name, path);\n+            }\n         }\n     }\n-    crates.retain(|_, paths| paths.len() > 1);\n-    if !crates.is_empty() {\n-        let crate_names = crates.keys().map(|s| format!(\"`{}`\", s)).collect::<Vec<_>>().join(\", \");\n-        // add backslashes for an easy copy-paste `rm` command\n-        let paths = crates\n-            .into_values()\n-            .flatten()\n-            .map(|p| strip_current_dir(&p).display().to_string())\n-            .collect::<Vec<_>>()\n-            .join(\" \\\\\\n\");\n-        // Check which action should be done in order to remove compiled deps.\n-        // If pre-installed version of compiler is used, `cargo clean` will do.\n-        // Otherwise (for bootstrapped compiler), the dependencies directory\n-        // must be removed manually.\n-        let suggested_action = if std::env::var_os(\"RUSTC_BOOTSTRAP\").is_some() {\n-            \"removing the stageN-tools directory\"\n-        } else {\n-            \"running `cargo clean`\"\n-        };\n-\n-        panic!(\n-            \"\\n----------------------------------------------------------------------\\n\\\n-            ERROR: Found multiple rlibs for crates: {}\\n\\\n-            Try {} or remove the following files:\\n\\n{}\\n\\n\\\n-            For details on this error see https://github.com/rust-lang/rust-clippy/issues/7343\\n\\\n-            ----------------------------------------------------------------------\\n\",\n-            crate_names, suggested_action, paths\n-        );\n+    let not_found: Vec<&str> = TEST_DEPENDENCIES\n+        .iter()\n+        .copied()\n+        .filter(|n| !crates.contains_key(n))\n+        .collect();\n+    if !not_found.is_empty() {\n+        panic!(\"dependencies not found in depinfo: {:?}\", not_found);\n     }\n-    flags\n+    crates\n+        .into_iter()\n+        .map(|(name, path)| format!(\"--extern {}={} \", name, path))\n+        .collect()\n }\n \n fn default_config() -> compiletest::Config {\n@@ -104,11 +121,14 @@ fn default_config() -> compiletest::Config {\n         config.compile_lib_path = path;\n     }\n \n+    // Using `-L dependency={}` enforces that external dependencies are added with `--extern`.\n+    // This is valuable because a) it allows us to monitor what external dependencies are used\n+    // and b) it ensures that conflicting rlibs are resolved properly.\n     config.target_rustcflags = Some(format!(\n-        \"--emit=metadata -L {0} -L {1} -Dwarnings -Zui-testing {2}\",\n+        \"--emit=metadata -L dependency={} -L dependency={} -Dwarnings -Zui-testing {}\",\n         host_lib().join(\"deps\").display(),\n         cargo::TARGET_LIB.join(\"deps\").display(),\n-        third_party_crates(),\n+        extern_flags(),\n     ));\n \n     config.build_base = host_lib().join(\"test_build_base\");\n@@ -315,12 +335,3 @@ impl Drop for VarGuard {\n         }\n     }\n }\n-\n-fn strip_current_dir(path: &Path) -> &Path {\n-    if let Ok(curr) = env::current_dir() {\n-        if let Ok(stripped) = path.strip_prefix(curr) {\n-            return stripped;\n-        }\n-    }\n-    path\n-}"}, {"sha": "54f452172deb4a3f727e3a586fbd8f3266c45efe", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -6,6 +6,8 @@\n // Dogfood cannot run on Windows\n #![cfg(not(windows))]\n #![feature(once_cell)]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use std::lazy::SyncLazy;\n use std::path::PathBuf;"}, {"sha": "be42f1fbb2023b4bb5bd8d4e2937be64cafa6f80", "filename": "src/tools/clippy/tests/fmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,6 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n+\n use std::path::PathBuf;\n use std::process::Command;\n "}, {"sha": "7e3eff3c7324fc3b4f31b1d4443b576e3cd41883", "filename": "src/tools/clippy/tests/integration.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,4 +1,6 @@\n #![cfg(feature = \"integration\")]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n use std::ffi::OsStr;"}, {"sha": "b4d94dc983fec11fecc2efc20e8dbf006193ae07", "filename": "src/tools/clippy/tests/lint_message_convention.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Flint_message_convention.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,6 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n+\n use std::ffi::OsStr;\n use std::path::PathBuf;\n "}, {"sha": "bd342e390f52f3d065bdef329f2c082ed3f322c7", "filename": "src/tools/clippy/tests/missing-test-files.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fmissing-test-files.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,5 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n #![allow(clippy::assertions_on_constants)]\n \n use std::fs::{self, DirEntry};"}, {"sha": "97d51462a946fc3dd4d1c59acf17e5583b540858", "filename": "src/tools/clippy/tests/ui-cargo/feature_name/fail/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,21 @@\n+\n+# Content that triggers the lint goes here\n+\n+[package]\n+name = \"feature_name\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[workspace]\n+\n+[features]\n+use-qwq = []\n+use_qwq = []\n+with-owo = []\n+with_owo = []\n+qvq-support = []\n+qvq_support = []\n+no-qaq = []\n+no_qaq = []\n+not-orz = []\n+not_orz = []"}, {"sha": "64f01a98c90e9c0ab647d28b3a693cc86fd67ab9", "filename": "src/tools/clippy/tests/ui-cargo/feature_name/fail/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --crate-name=feature_name\n+#![warn(clippy::redundant_feature_names)]\n+#![warn(clippy::negative_feature_names)]\n+\n+fn main() {\n+    // test code goes here\n+}"}, {"sha": "b9e6cb49bc982fbcb1f1b909d0d65a7eaaf61076", "filename": "src/tools/clippy/tests/ui-cargo/feature_name/fail/src/main.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,44 @@\n+error: the \"no-\" prefix in the feature name \"no-qaq\" is negative\n+   |\n+   = note: `-D clippy::negative-feature-names` implied by `-D warnings`\n+   = help: consider renaming the feature to \"qaq\", but make sure the feature adds functionality\n+\n+error: the \"no_\" prefix in the feature name \"no_qaq\" is negative\n+   |\n+   = help: consider renaming the feature to \"qaq\", but make sure the feature adds functionality\n+\n+error: the \"not-\" prefix in the feature name \"not-orz\" is negative\n+   |\n+   = help: consider renaming the feature to \"orz\", but make sure the feature adds functionality\n+\n+error: the \"not_\" prefix in the feature name \"not_orz\" is negative\n+   |\n+   = help: consider renaming the feature to \"orz\", but make sure the feature adds functionality\n+\n+error: the \"-support\" suffix in the feature name \"qvq-support\" is redundant\n+   |\n+   = note: `-D clippy::redundant-feature-names` implied by `-D warnings`\n+   = help: consider renaming the feature to \"qvq\"\n+\n+error: the \"_support\" suffix in the feature name \"qvq_support\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qvq\"\n+\n+error: the \"use-\" prefix in the feature name \"use-qwq\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qwq\"\n+\n+error: the \"use_\" prefix in the feature name \"use_qwq\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qwq\"\n+\n+error: the \"with-\" prefix in the feature name \"with-owo\" is redundant\n+   |\n+   = help: consider renaming the feature to \"owo\"\n+\n+error: the \"with_\" prefix in the feature name \"with_owo\" is redundant\n+   |\n+   = help: consider renaming the feature to \"owo\"\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "cf947312bd4798b38f721d1fa879a00d4cb461b2", "filename": "src/tools/clippy/tests/ui-cargo/feature_name/pass/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,9 @@\n+\n+# This file should not trigger the lint\n+\n+[package]\n+name = \"feature_name\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[workspace]"}, {"sha": "64f01a98c90e9c0ab647d28b3a693cc86fd67ab9", "filename": "src/tools/clippy/tests/ui-cargo/feature_name/pass/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --crate-name=feature_name\n+#![warn(clippy::redundant_feature_names)]\n+#![warn(clippy::negative_feature_names)]\n+\n+fn main() {\n+    // test code goes here\n+}"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "91cd540a28fddc60cc7427a55ad9713bae39c034", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/bad/inner.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub mod stuff;"}, {"sha": "7713fa9d35c4a357a2ac0696d72e9989c320e194", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/bad/inner/stuff.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,3 @@\n+pub mod most;\n+\n+pub struct Inner;"}, {"sha": "5a5eaf9670f9012a40b67a6599ac5b0665cee131", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/bad/inner/stuff/most.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Snarks;"}, {"sha": "a12734db7cb5f3175c32bfb2c518ee5f78a7b27f", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/bad/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,3 @@\n+pub mod inner;\n+\n+pub struct Thing;"}, {"sha": "3e985d4e904c16984bb29ea97697979027380a79", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/main.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,9 @@\n+#![warn(clippy::self_named_module_files)]\n+\n+mod bad;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+    let _ = bad::inner::stuff::Inner;\n+    let _ = bad::inner::stuff::most::Snarks;\n+}"}, {"sha": "af4c298b310852bf997a072838f58a71efcfe3fb", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_mod/src/main.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,19 @@\n+error: `mod.rs` files are required, found `/bad/inner.rs`\n+  --> $DIR/bad/inner.rs:1:1\n+   |\n+LL | pub mod stuff;\n+   | ^\n+   |\n+   = note: `-D clippy::self-named-module-files` implied by `-D warnings`\n+   = help: move `/bad/inner.rs` to `/bad/inner/mod.rs`\n+\n+error: `mod.rs` files are required, found `/bad/inner/stuff.rs`\n+  --> $DIR/bad/inner/stuff.rs:1:1\n+   |\n+LL | pub mod most;\n+   | ^\n+   |\n+   = help: move `/bad/inner/stuff.rs` to `/bad/inner/stuff/mod.rs`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_no_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_no_mod/src/bad/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "c6e9045b8dc47c6c0d0911a6e26eacbb23d4c0ea", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_no_mod/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,7 @@\n+#![warn(clippy::mod_module_files)]\n+\n+mod bad;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+}"}, {"sha": "11e15db7fb96b47829251b95126dae9af8791466", "filename": "src/tools/clippy/tests/ui-cargo/module_style/fail_no_mod/src/main.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,11 @@\n+error: `mod.rs` files are not allowed, found `/bad/mod.rs`\n+  --> $DIR/bad/mod.rs:1:1\n+   |\n+LL | pub struct Thing;\n+   | ^\n+   |\n+   = note: `-D clippy::mod-module-files` implied by `-D warnings`\n+   = help: move `/bad/mod.rs` to `/bad.rs`\n+\n+error: aborting due to previous error\n+"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/src/bad/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "9e08715fc0522b411db17af915e310cd7557671e", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/src/main.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,10 @@\n+#![warn(clippy::self_named_module_files)]\n+\n+mod bad;\n+mod more;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+    let _ = more::foo::Foo;\n+    let _ = more::inner::Inner;\n+}"}, {"sha": "4a835673a596bcd05404f43d34082bf2785f2a9d", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/src/more/foo.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Foo;"}, {"sha": "aa84f78cc2ca19a90feb696d2daecdbce92793d7", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/src/more/inner/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Inner;"}, {"sha": "d79569f78ffbe60eea689a3c7afe69aaa9b1ff85", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_mod/src/more/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,2 @@\n+pub mod foo;\n+pub mod inner;"}, {"sha": "3c0896dd2cda7d921dceca29a1ca11f6b94df6f8", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_no_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"pass\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_no_mod/src/good.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "50211a340b91b38e8d5a1f27daca27c84ad7e839", "filename": "src/tools/clippy/tests/ui-cargo/module_style/pass_no_mod/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,7 @@\n+#![warn(clippy::mod_module_files)]\n+\n+mod good;\n+\n+fn main() {\n+    let _ = good::Thing;\n+}"}, {"sha": "2ae4d613507edce8b3c5c3145b6354c85fe64ba6", "filename": "src/tools/clippy/tests/ui/approx_const.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -57,4 +57,8 @@ fn main() {\n \n     let my_sq2 = 1.4142;\n     let no_sq2 = 1.414;\n+\n+    let my_tau = 6.2832;\n+    let almost_tau = 6.28;\n+    let no_tau = 6.3;\n }"}, {"sha": "4da1b8215ae0440bb6c90794c8c095364f66f130", "filename": "src/tools/clippy/tests/ui/approx_const.stderr", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fapprox_const.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,130 +1,187 @@\n-error: approximate value of `f{32, 64}::consts::E` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::E` found\n   --> $DIR/approx_const.rs:4:16\n    |\n LL |     let my_e = 2.7182;\n    |                ^^^^^^\n    |\n    = note: `-D clippy::approx-constant` implied by `-D warnings`\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::E` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::E` found\n   --> $DIR/approx_const.rs:5:20\n    |\n LL |     let almost_e = 2.718;\n    |                    ^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_1_PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_1_PI` found\n   --> $DIR/approx_const.rs:8:24\n    |\n LL |     let my_1_frac_pi = 0.3183;\n    |                        ^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_1_SQRT_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_1_SQRT_2` found\n   --> $DIR/approx_const.rs:11:28\n    |\n LL |     let my_frac_1_sqrt_2 = 0.70710678;\n    |                            ^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_1_SQRT_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_1_SQRT_2` found\n   --> $DIR/approx_const.rs:12:32\n    |\n LL |     let almost_frac_1_sqrt_2 = 0.70711;\n    |                                ^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_2_PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_2_PI` found\n   --> $DIR/approx_const.rs:15:24\n    |\n LL |     let my_frac_2_pi = 0.63661977;\n    |                        ^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_2_SQRT_PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_2_SQRT_PI` found\n   --> $DIR/approx_const.rs:18:27\n    |\n LL |     let my_frac_2_sq_pi = 1.128379;\n    |                           ^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_PI_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_PI_2` found\n   --> $DIR/approx_const.rs:21:24\n    |\n LL |     let my_frac_pi_2 = 1.57079632679;\n    |                        ^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_PI_3` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_PI_3` found\n   --> $DIR/approx_const.rs:24:24\n    |\n LL |     let my_frac_pi_3 = 1.04719755119;\n    |                        ^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_PI_4` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_PI_4` found\n   --> $DIR/approx_const.rs:27:24\n    |\n LL |     let my_frac_pi_4 = 0.785398163397;\n    |                        ^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_PI_6` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_PI_6` found\n   --> $DIR/approx_const.rs:30:24\n    |\n LL |     let my_frac_pi_6 = 0.523598775598;\n    |                        ^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::FRAC_PI_8` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::FRAC_PI_8` found\n   --> $DIR/approx_const.rs:33:24\n    |\n LL |     let my_frac_pi_8 = 0.3926990816987;\n    |                        ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LN_10` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LN_10` found\n   --> $DIR/approx_const.rs:36:20\n    |\n LL |     let my_ln_10 = 2.302585092994046;\n    |                    ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LN_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LN_2` found\n   --> $DIR/approx_const.rs:39:19\n    |\n LL |     let my_ln_2 = 0.6931471805599453;\n    |                   ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LOG10_E` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LOG10_E` found\n   --> $DIR/approx_const.rs:42:22\n    |\n LL |     let my_log10_e = 0.4342944819032518;\n    |                      ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LOG2_E` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LOG2_E` found\n   --> $DIR/approx_const.rs:45:21\n    |\n LL |     let my_log2_e = 1.4426950408889634;\n    |                     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LOG2_10` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LOG2_10` found\n   --> $DIR/approx_const.rs:48:19\n    |\n LL |     let log2_10 = 3.321928094887362;\n    |                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::LOG10_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::LOG10_2` found\n   --> $DIR/approx_const.rs:51:19\n    |\n LL |     let log10_2 = 0.301029995663981;\n    |                   ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::PI` found\n   --> $DIR/approx_const.rs:54:17\n    |\n LL |     let my_pi = 3.1415;\n    |                 ^^^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::PI` found\n   --> $DIR/approx_const.rs:55:21\n    |\n LL |     let almost_pi = 3.14;\n    |                     ^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: approximate value of `f{32, 64}::consts::SQRT_2` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::SQRT_2` found\n   --> $DIR/approx_const.rs:58:18\n    |\n LL |     let my_sq2 = 1.4142;\n    |                  ^^^^^^\n+   |\n+   = help: consider using the constant directly\n+\n+error: approximate value of `f{32, 64}::consts::TAU` found\n+  --> $DIR/approx_const.rs:61:18\n+   |\n+LL |     let my_tau = 6.2832;\n+   |                  ^^^^^^\n+   |\n+   = help: consider using the constant directly\n+\n+error: approximate value of `f{32, 64}::consts::TAU` found\n+  --> $DIR/approx_const.rs:62:22\n+   |\n+LL |     let almost_tau = 6.28;\n+   |                      ^^^^\n+   |\n+   = help: consider using the constant directly\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 23 previous errors\n "}, {"sha": "86a637ce3093c5ee936983cdc49c5477cab6cd52", "filename": "src/tools/clippy/tests/ui/auxiliary/option_helpers.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Foption_helpers.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -53,3 +53,12 @@ impl IteratorFalsePositives {\n         self.foo as usize\n     }\n }\n+\n+#[derive(Copy, Clone)]\n+pub struct IteratorMethodFalsePositives;\n+\n+impl IteratorMethodFalsePositives {\n+    pub fn filter(&self, _s: i32) -> std::vec::IntoIter<i32> {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "ec4d6f3ff840113829343f89f7ff45f2d9e45f8b", "filename": "src/tools/clippy/tests/ui/bool_assert_comparison.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::bool_assert_comparison)]\n \n+use std::ops::Not;\n+\n macro_rules! a {\n     () => {\n         true\n@@ -11,14 +13,67 @@ macro_rules! b {\n     };\n }\n \n+// Implements the Not trait but with an output type\n+// that's not bool. Should not suggest a rewrite\n+#[derive(Debug)]\n+enum ImplNotTraitWithoutBool {\n+    VariantX(bool),\n+    VariantY(u32),\n+}\n+\n+impl PartialEq<bool> for ImplNotTraitWithoutBool {\n+    fn eq(&self, other: &bool) -> bool {\n+        match *self {\n+            ImplNotTraitWithoutBool::VariantX(b) => b == *other,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Not for ImplNotTraitWithoutBool {\n+    type Output = Self;\n+\n+    fn not(self) -> Self::Output {\n+        match self {\n+            ImplNotTraitWithoutBool::VariantX(b) => ImplNotTraitWithoutBool::VariantX(!b),\n+            ImplNotTraitWithoutBool::VariantY(0) => ImplNotTraitWithoutBool::VariantY(1),\n+            ImplNotTraitWithoutBool::VariantY(_) => ImplNotTraitWithoutBool::VariantY(0),\n+        }\n+    }\n+}\n+\n+// This type implements the Not trait with an Output of\n+// type bool. Using assert!(..) must be suggested\n+#[derive(Debug)]\n+struct ImplNotTraitWithBool;\n+\n+impl PartialEq<bool> for ImplNotTraitWithBool {\n+    fn eq(&self, other: &bool) -> bool {\n+        false\n+    }\n+}\n+\n+impl Not for ImplNotTraitWithBool {\n+    type Output = bool;\n+\n+    fn not(self) -> Self::Output {\n+        true\n+    }\n+}\n+\n fn main() {\n+    let a = ImplNotTraitWithoutBool::VariantX(true);\n+    let b = ImplNotTraitWithBool;\n+\n     assert_eq!(\"a\".len(), 1);\n     assert_eq!(\"a\".is_empty(), false);\n     assert_eq!(\"\".is_empty(), true);\n     assert_eq!(true, \"\".is_empty());\n     assert_eq!(a!(), b!());\n     assert_eq!(a!(), \"\".is_empty());\n     assert_eq!(\"\".is_empty(), b!());\n+    assert_eq!(a, true);\n+    assert_eq!(b, true);\n \n     assert_ne!(\"a\".len(), 1);\n     assert_ne!(\"a\".is_empty(), false);\n@@ -27,6 +82,8 @@ fn main() {\n     assert_ne!(a!(), b!());\n     assert_ne!(a!(), \"\".is_empty());\n     assert_ne!(\"\".is_empty(), b!());\n+    assert_ne!(a, true);\n+    assert_ne!(b, true);\n \n     debug_assert_eq!(\"a\".len(), 1);\n     debug_assert_eq!(\"a\".is_empty(), false);\n@@ -35,6 +92,8 @@ fn main() {\n     debug_assert_eq!(a!(), b!());\n     debug_assert_eq!(a!(), \"\".is_empty());\n     debug_assert_eq!(\"\".is_empty(), b!());\n+    debug_assert_eq!(a, true);\n+    debug_assert_eq!(b, true);\n \n     debug_assert_ne!(\"a\".len(), 1);\n     debug_assert_ne!(\"a\".is_empty(), false);\n@@ -43,17 +102,21 @@ fn main() {\n     debug_assert_ne!(a!(), b!());\n     debug_assert_ne!(a!(), \"\".is_empty());\n     debug_assert_ne!(\"\".is_empty(), b!());\n+    debug_assert_ne!(a, true);\n+    debug_assert_ne!(b, true);\n \n     // assert with error messages\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+    assert_eq!(a, true, \"tadam {}\", false);\n \n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+    debug_assert_eq!(a, true, \"tadam {}\", false);\n }"}, {"sha": "da9b56aa7795d4e9c2396dabf655764996fab801", "filename": "src/tools/clippy/tests/ui/bool_assert_comparison.stderr", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbool_assert_comparison.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,112 +1,136 @@\n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:16:5\n+  --> $DIR/bool_assert_comparison.rs:69:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n    |\n    = note: `-D clippy::bool-assert-comparison` implied by `-D warnings`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:17:5\n+  --> $DIR/bool_assert_comparison.rs:70:5\n    |\n LL |     assert_eq!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:18:5\n+  --> $DIR/bool_assert_comparison.rs:71:5\n    |\n LL |     assert_eq!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:76:5\n+   |\n+LL |     assert_eq!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:24:5\n+  --> $DIR/bool_assert_comparison.rs:79:5\n    |\n LL |     assert_ne!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:25:5\n+  --> $DIR/bool_assert_comparison.rs:80:5\n    |\n LL |     assert_ne!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:26:5\n+  --> $DIR/bool_assert_comparison.rs:81:5\n    |\n LL |     assert_ne!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:86:5\n+   |\n+LL |     assert_ne!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:32:5\n+  --> $DIR/bool_assert_comparison.rs:89:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:33:5\n+  --> $DIR/bool_assert_comparison.rs:90:5\n    |\n LL |     debug_assert_eq!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:34:5\n+  --> $DIR/bool_assert_comparison.rs:91:5\n    |\n LL |     debug_assert_eq!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:96:5\n+   |\n+LL |     debug_assert_eq!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:40:5\n+  --> $DIR/bool_assert_comparison.rs:99:5\n    |\n LL |     debug_assert_ne!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:41:5\n+  --> $DIR/bool_assert_comparison.rs:100:5\n    |\n LL |     debug_assert_ne!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:42:5\n+  --> $DIR/bool_assert_comparison.rs:101:5\n    |\n LL |     debug_assert_ne!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:106:5\n+   |\n+LL |     debug_assert_ne!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:50:5\n+  --> $DIR/bool_assert_comparison.rs:111:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:51:5\n+  --> $DIR/bool_assert_comparison.rs:112:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:52:5\n+  --> $DIR/bool_assert_comparison.rs:113:5\n    |\n LL |     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:56:5\n+  --> $DIR/bool_assert_comparison.rs:118:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:57:5\n+  --> $DIR/bool_assert_comparison.rs:119:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:58:5\n+  --> $DIR/bool_assert_comparison.rs:120:5\n    |\n LL |     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "1d6366972dacfb529ce1e2295934d95adab58878", "filename": "src/tools/clippy/tests/ui/box_vec.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,10 @@\n #![warn(clippy::all)]\n-#![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n-#![allow(clippy::blacklisted_name)]\n+#![allow(\n+    clippy::boxed_local,\n+    clippy::needless_pass_by_value,\n+    clippy::blacklisted_name,\n+    unused\n+)]\n \n macro_rules! boxit {\n     ($init:expr, $x:ty) => {\n@@ -11,22 +15,22 @@ macro_rules! boxit {\n fn test_macro() {\n     boxit!(Vec::new(), Vec<u8>);\n }\n-pub fn test(foo: Box<Vec<bool>>) {\n-    println!(\"{:?}\", foo.get(0))\n-}\n+fn test(foo: Box<Vec<bool>>) {}\n \n-pub fn test2(foo: Box<dyn Fn(Vec<u32>)>) {\n+fn test2(foo: Box<dyn Fn(Vec<u32>)>) {\n     // pass if #31 is fixed\n     foo(vec![1, 2, 3])\n }\n \n-pub fn test_local_not_linted() {\n+fn test_local_not_linted() {\n     let _: Box<Vec<bool>>;\n }\n \n-fn main() {\n-    test(Box::new(Vec::new()));\n-    test2(Box::new(|v| println!(\"{:?}\", v)));\n-    test_macro();\n-    test_local_not_linted();\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test(foo: Box<Vec<bool>>) {}\n+pub fn pub_test_ret() -> Box<Vec<bool>> {\n+    Box::new(Vec::new())\n }\n+\n+fn main() {}"}, {"sha": "58c1f13fb877b1ba77deda63048b0ed41bf36314", "filename": "src/tools/clippy/tests/ui/box_vec.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbox_vec.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,8 +1,8 @@\n error: you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\n-  --> $DIR/box_vec.rs:14:18\n+  --> $DIR/box_vec.rs:18:14\n    |\n-LL | pub fn test(foo: Box<Vec<bool>>) {\n-   |                  ^^^^^^^^^^^^^^\n+LL | fn test(foo: Box<Vec<bool>>) {}\n+   |              ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::box-vec` implied by `-D warnings`\n    = help: `Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation"}, {"sha": "46c6f69708eb798b8973c0db01b8424dd3b9f102", "filename": "src/tools/clippy/tests/ui/checked_unwrap/complex_conditionals.stderr", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,4 +1,4 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:8:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -11,6 +11,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:9:9\n@@ -36,14 +37,16 @@ LL |     if x.is_ok() && y.is_err() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:11:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n    |                     ---------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:25:9\n@@ -54,14 +57,16 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:26:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n    |        --------- the check is happening here\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:27:9\n@@ -72,22 +77,26 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:28:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n    |                     --------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:32:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |        --------- the check is happening here\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:33:9\n@@ -107,23 +116,27 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:35:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                       --------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `z` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:36:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n LL |         z.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:37:9\n@@ -143,23 +156,27 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:46:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |        --------- the check is happening here\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:47:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                       --------- the check is happening here\n ...\n LL |         y.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:48:9\n@@ -179,14 +196,16 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         z.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `z` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:50:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n LL |         z.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: aborting due to 20 previous errors\n "}, {"sha": "542ab53300c029d44641bcb1b78d34752f8c1698", "filename": "src/tools/clippy/tests/ui/checked_unwrap/complex_conditionals_nested.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,8 +1,8 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/complex_conditionals_nested.rs:8:13\n    |\n LL |         if x.is_some() {\n-   |            ----------- the check is happening here\n+   |         -------------- help: try: `if let Some(..) = x`\n LL |             x.unwrap(); // unnecessary\n    |             ^^^^^^^^^^\n    |"}, {"sha": "ee3fdfabe9d8a8e255d5966ce924cb87f2744ae7", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -37,8 +37,10 @@ fn main() {\n     let x = Some(());\n     if x.is_some() {\n         x.unwrap(); // unnecessary\n+        x.expect(\"an error message\"); // unnecessary\n     } else {\n         x.unwrap(); // will panic\n+        x.expect(\"an error message\"); // will panic\n     }\n     if x.is_none() {\n         x.unwrap(); // will panic\n@@ -52,9 +54,11 @@ fn main() {\n     let mut x: Result<(), ()> = Ok(());\n     if x.is_ok() {\n         x.unwrap(); // unnecessary\n+        x.expect(\"an error message\"); // unnecessary\n         x.unwrap_err(); // will panic\n     } else {\n         x.unwrap(); // will panic\n+        x.expect(\"an error message\"); // will panic\n         x.unwrap_err(); // unnecessary\n     }\n     if x.is_err() {"}, {"sha": "82f269543800f3dfc62b006bd79a8e141270fca6", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.stderr", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,8 +1,8 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/simple_conditionals.rs:39:9\n    |\n LL |     if x.is_some() {\n-   |        ----------- the check is happening here\n+   |     -------------- help: try: `if let Some(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n    |\n@@ -12,8 +12,17 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: called `expect` on `x` after checking its variant with `is_some`\n+  --> $DIR/simple_conditionals.rs:40:9\n+   |\n+LL |     if x.is_some() {\n+   |     -------------- help: try: `if let Some(..) = x`\n+LL |         x.unwrap(); // unnecessary\n+LL |         x.expect(\"an error message\"); // unnecessary\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:41:9\n+  --> $DIR/simple_conditionals.rs:42:9\n    |\n LL |     if x.is_some() {\n    |        ----------- because of this check\n@@ -27,28 +36,37 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: this call to `expect()` will always panic\n+  --> $DIR/simple_conditionals.rs:43:9\n+   |\n+LL |     if x.is_some() {\n+   |        ----------- because of this check\n+...\n+LL |         x.expect(\"an error message\"); // will panic\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:44:9\n+  --> $DIR/simple_conditionals.rs:46:9\n    |\n LL |     if x.is_none() {\n    |        ----------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:46:9\n+error: called `unwrap` on `x` after checking its variant with `is_none`\n+  --> $DIR/simple_conditionals.rs:48:9\n    |\n LL |     if x.is_none() {\n-   |        ----------- the check is happening here\n+   |     -------------- help: try: `if let Some(..) = x`\n ...\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/simple_conditionals.rs:7:13\n    |\n LL |         if $a.is_some() {\n-   |            ------------ the check is happening here\n+   |         --------------- help: try: `if let Some(..) = x`\n LL |             $a.unwrap(); // unnecessary\n    |             ^^^^^^^^^^^\n ...\n@@ -57,75 +75,93 @@ LL |     m!(x);\n    |\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:54:9\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:56:9\n    |\n LL |     if x.is_ok() {\n-   |        --------- the check is happening here\n+   |     ------------ help: try: `if let Ok(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n+error: called `expect` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:57:9\n+   |\n+LL |     if x.is_ok() {\n+   |     ------------ help: try: `if let Ok(..) = x`\n+LL |         x.unwrap(); // unnecessary\n+LL |         x.expect(\"an error message\"); // unnecessary\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:55:9\n+  --> $DIR/simple_conditionals.rs:58:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n-LL |         x.unwrap(); // unnecessary\n+...\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:57:9\n+  --> $DIR/simple_conditionals.rs:60:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n ...\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:58:9\n+error: this call to `expect()` will always panic\n+  --> $DIR/simple_conditionals.rs:61:9\n+   |\n+LL |     if x.is_ok() {\n+   |        --------- because of this check\n+...\n+LL |         x.expect(\"an error message\"); // will panic\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:62:9\n    |\n LL |     if x.is_ok() {\n-   |        --------- the check is happening here\n+   |     ------------ help: try: `if let Err(..) = x`\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:61:9\n+  --> $DIR/simple_conditionals.rs:65:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:62:9\n+error: called `unwrap_err` on `x` after checking its variant with `is_err`\n+  --> $DIR/simple_conditionals.rs:66:9\n    |\n LL |     if x.is_err() {\n-   |        ---------- the check is happening here\n+   |     ------------- help: try: `if let Err(..) = x`\n LL |         x.unwrap(); // will panic\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:64:9\n+error: called `unwrap` on `x` after checking its variant with `is_err`\n+  --> $DIR/simple_conditionals.rs:68:9\n    |\n LL |     if x.is_err() {\n-   |        ---------- the check is happening here\n+   |     ------------- help: try: `if let Ok(..) = x`\n ...\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:65:9\n+  --> $DIR/simple_conditionals.rs:69:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n ...\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "336a743de726bf009387beaf5982b7a5c5a37285", "filename": "src/tools/clippy/tests/ui/derivable_impls.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,170 @@\n+use std::collections::HashMap;\n+\n+struct FooDefault<'a> {\n+    a: bool,\n+    b: i32,\n+    c: u64,\n+    d: Vec<i32>,\n+    e: FooND1,\n+    f: FooND2,\n+    g: HashMap<i32, i32>,\n+    h: (i32, Vec<i32>),\n+    i: [Vec<i32>; 3],\n+    j: [i32; 5],\n+    k: Option<i32>,\n+    l: &'a [i32],\n+}\n+\n+impl std::default::Default for FooDefault<'_> {\n+    fn default() -> Self {\n+        Self {\n+            a: false,\n+            b: 0,\n+            c: 0u64,\n+            d: vec![],\n+            e: Default::default(),\n+            f: FooND2::default(),\n+            g: HashMap::new(),\n+            h: (0, vec![]),\n+            i: [vec![], vec![], vec![]],\n+            j: [0; 5],\n+            k: None,\n+            l: &[],\n+        }\n+    }\n+}\n+\n+struct TupleDefault(bool, i32, u64);\n+\n+impl std::default::Default for TupleDefault {\n+    fn default() -> Self {\n+        Self(false, 0, 0u64)\n+    }\n+}\n+\n+struct FooND1 {\n+    a: bool,\n+}\n+\n+impl std::default::Default for FooND1 {\n+    fn default() -> Self {\n+        Self { a: true }\n+    }\n+}\n+\n+struct FooND2 {\n+    a: i32,\n+}\n+\n+impl std::default::Default for FooND2 {\n+    fn default() -> Self {\n+        Self { a: 5 }\n+    }\n+}\n+\n+struct FooNDNew {\n+    a: bool,\n+}\n+\n+impl FooNDNew {\n+    fn new() -> Self {\n+        Self { a: true }\n+    }\n+}\n+\n+impl Default for FooNDNew {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+struct FooNDVec(Vec<i32>);\n+\n+impl Default for FooNDVec {\n+    fn default() -> Self {\n+        Self(vec![5, 12])\n+    }\n+}\n+\n+struct StrDefault<'a>(&'a str);\n+\n+impl Default for StrDefault<'_> {\n+    fn default() -> Self {\n+        Self(\"\")\n+    }\n+}\n+\n+#[derive(Default)]\n+struct AlreadyDerived(i32, bool);\n+\n+macro_rules! mac {\n+    () => {\n+        0\n+    };\n+    ($e:expr) => {\n+        struct X(u32);\n+        impl Default for X {\n+            fn default() -> Self {\n+                Self($e)\n+            }\n+        }\n+    };\n+}\n+\n+mac!(0);\n+\n+struct Y(u32);\n+impl Default for Y {\n+    fn default() -> Self {\n+        Self(mac!())\n+    }\n+}\n+\n+struct RustIssue26925<T> {\n+    a: Option<T>,\n+}\n+\n+// We should watch out for cases where a manual impl is needed because a\n+// derive adds different type bounds (https://github.com/rust-lang/rust/issues/26925).\n+// For example, a struct with Option<T> does not require T: Default, but a derive adds\n+// that type bound anyways. So until #26925 get fixed we should disable lint\n+// for the following case\n+impl<T> Default for RustIssue26925<T> {\n+    fn default() -> Self {\n+        Self { a: None }\n+    }\n+}\n+\n+struct SpecializedImpl<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+impl<T: Default> Default for SpecializedImpl<T, T> {\n+    fn default() -> Self {\n+        Self {\n+            a: T::default(),\n+            b: T::default(),\n+        }\n+    }\n+}\n+\n+struct WithoutSelfCurly {\n+    a: bool,\n+}\n+\n+impl Default for WithoutSelfCurly {\n+    fn default() -> Self {\n+        WithoutSelfCurly { a: false }\n+    }\n+}\n+\n+struct WithoutSelfParan(bool);\n+\n+impl Default for WithoutSelfParan {\n+    fn default() -> Self {\n+        WithoutSelfParan(false)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4ed64fade026d1379667ccbff05bb1b7c20038fe", "filename": "src/tools/clippy/tests/ui/derivable_impls.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderivable_impls.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,77 @@\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:18:1\n+   |\n+LL | / impl std::default::Default for FooDefault<'_> {\n+LL | |     fn default() -> Self {\n+LL | |         Self {\n+LL | |             a: false,\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::derivable-impls` implied by `-D warnings`\n+   = help: try annotating `FooDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:39:1\n+   |\n+LL | / impl std::default::Default for TupleDefault {\n+LL | |     fn default() -> Self {\n+LL | |         Self(false, 0, 0u64)\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `TupleDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:91:1\n+   |\n+LL | / impl Default for StrDefault<'_> {\n+LL | |     fn default() -> Self {\n+LL | |         Self(\"\")\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `StrDefault` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:117:1\n+   |\n+LL | / impl Default for Y {\n+LL | |     fn default() -> Self {\n+LL | |         Self(mac!())\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `Y` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:156:1\n+   |\n+LL | / impl Default for WithoutSelfCurly {\n+LL | |     fn default() -> Self {\n+LL | |         WithoutSelfCurly { a: false }\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `WithoutSelfCurly` with `#[derive(Default)]`\n+\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:164:1\n+   |\n+LL | / impl Default for WithoutSelfParan {\n+LL | |     fn default() -> Self {\n+LL | |         WithoutSelfParan(false)\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: try annotating `WithoutSelfParan` with `#[derive(Default)]`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8a36ec833d76d3aa331b120d356507efe46168e1", "filename": "src/tools/clippy/tests/ui/entry.fixed", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -142,14 +142,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n-    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-        e.insert(v);\n-        foo();\n-    }\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n+    m.entry(k).or_insert_with(|| {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n+        v\n+    });\n }\n \n fn main() {}"}, {"sha": "d972a201ad76460e401c6a0ff613eab5e4f53af9", "filename": "src/tools/clippy/tests/ui/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -146,13 +146,12 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n     if !m.contains_key(&k) {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n         m.insert(k, v);\n-        foo();\n     }\n }\n "}, {"sha": "1076500498d32fe321a2de82c68e91514cae9ac8", "filename": "src/tools/clippy/tests/ui/entry.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -165,21 +165,23 @@ LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:153:5\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:151:5\n    |\n LL | /     if !m.contains_key(&k) {\n+LL | |         let x = (String::new(), String::new());\n+LL | |         let _ = x.0;\n LL | |         m.insert(k, v);\n-LL | |         foo();\n LL | |     }\n    | |_____^\n    |\n help: try this\n    |\n-LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-LL +         e.insert(v);\n-LL +         foo();\n-LL +     }\n+LL ~     m.entry(k).or_insert_with(|| {\n+LL +         let x = (String::new(), String::new());\n+LL +         let _ = x.0;\n+LL +         v\n+LL +     });\n    |\n \n error: aborting due to 10 previous errors"}, {"sha": "94979104556bc882267d230b41c535319d712bd8", "filename": "src/tools/clippy/tests/ui/entry_btree.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "080c1d959e89425d326ae8c05e8053128a347425", "filename": "src/tools/clippy/tests/ui/entry_btree.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5c6fcdf1a28c01f1ba0cbdd646bfb48453cde0e3", "filename": "src/tools/clippy/tests/ui/entry_btree.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fentry_btree.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,20 @@\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry_btree.rs:12:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL +         e.insert(v);\n+LL +         foo();\n+LL +     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "690ea810a6214072f1a1614304624f22cb30befc", "filename": "src/tools/clippy/tests/ui/linkedlist.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,6 +1,6 @@\n #![feature(associated_type_defaults)]\n #![warn(clippy::linkedlist)]\n-#![allow(dead_code, clippy::needless_pass_by_value)]\n+#![allow(unused, dead_code, clippy::needless_pass_by_value)]\n \n extern crate alloc;\n use alloc::collections::linked_list::LinkedList;\n@@ -20,24 +20,29 @@ impl Foo for LinkedList<u8> {\n     const BAR: Option<LinkedList<u8>> = None;\n }\n \n-struct Bar;\n+pub struct Bar {\n+    priv_linked_list_field: LinkedList<u8>,\n+    pub pub_linked_list_field: LinkedList<u8>,\n+}\n impl Bar {\n     fn foo(_: LinkedList<u8>) {}\n }\n \n-pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n-    println!(\"{:?}\", my_favourite_linked_list)\n-}\n-\n-pub fn test_ret() -> Option<LinkedList<u8>> {\n-    unimplemented!();\n+// All of these test should be trigger the lint because they are not\n+// part of the public api\n+fn test(my_favorite_linked_list: LinkedList<u8>) {}\n+fn test_ret() -> Option<LinkedList<u8>> {\n+    None\n }\n-\n-pub fn test_local_not_linted() {\n+fn test_local_not_linted() {\n     let _: LinkedList<u8>;\n }\n \n-fn main() {\n-    test(LinkedList::new());\n-    test_local_not_linted();\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test(the_most_awesome_linked_list: LinkedList<u8>) {}\n+pub fn pub_test_ret() -> Option<LinkedList<u8>> {\n+    None\n }\n+\n+fn main() {}"}, {"sha": "51327df13211879da10fb77801a1c6a2e44be1c2", "filename": "src/tools/clippy/tests/ui/linkedlist.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flinkedlist.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -40,28 +40,36 @@ LL |     const BAR: Option<LinkedList<u8>>;\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:25:15\n+  --> $DIR/linkedlist.rs:24:29\n+   |\n+LL |     priv_linked_list_field: LinkedList<u8>,\n+   |                             ^^^^^^^^^^^^^^\n+   |\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:28:15\n    |\n LL |     fn foo(_: LinkedList<u8>) {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:28:39\n+  --> $DIR/linkedlist.rs:33:34\n    |\n-LL | pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n-   |                                       ^^^^^^^^^^^^^^\n+LL | fn test(my_favorite_linked_list: LinkedList<u8>) {}\n+   |                                  ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:32:29\n+  --> $DIR/linkedlist.rs:34:25\n    |\n-LL | pub fn test_ret() -> Option<LinkedList<u8>> {\n-   |                             ^^^^^^^^^^^^^^\n+LL | fn test_ret() -> Option<LinkedList<u8>> {\n+   |                         ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "7db6b730963c94f6399e4ff2a69921b2a0d3ff61", "filename": "src/tools/clippy/tests/ui/manual_flatten.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -91,6 +91,19 @@ fn main() {\n         }\n     }\n \n+    struct Test {\n+        a: usize,\n+    }\n+\n+    let mut vec_of_struct = [Some(Test { a: 1 }), None];\n+\n+    // Usage of `if let` expression should not trigger lint\n+    for n in vec_of_struct.iter_mut() {\n+        if let Some(z) = n {\n+            *n = None;\n+        }\n+    }\n+\n     // Using manual flatten should not trigger the lint\n     for n in vec![Some(1), Some(2), Some(3)].iter().flatten() {\n         println!(\"{}\", n);"}, {"sha": "8cc12149403d32aa22aaba2618c187eb65ea5c20", "filename": "src/tools/clippy/tests/ui/manual_map_option_2.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = Some(0).map(|x| {\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        });\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = s.as_ref().map(|x| {\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        });\n+}"}, {"sha": "0862b201ead4b7290f600e6b27454a8a1b72dc4a", "filename": "src/tools/clippy/tests/ui/manual_map_option_2.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = match Some(0) {\n+        Some(x) => Some({\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        }),\n+        None => None,\n+    };\n+}"}, {"sha": "711ff6c4a4b095dfc5da5efd75116e4b2fa5445d", "filename": "src/tools/clippy/tests/ui/manual_map_option_2.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option_2.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,43 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:8:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             let y = (String::new(), String::new());\n+LL | |             (x, y.0)\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     let _ = Some(0).map(|x| {\n+LL +             let y = (String::new(), String::new());\n+LL +             (x, y.0)\n+LL ~         });\n+   |\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:50:13\n+   |\n+LL |       let _ = match &s {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     let _ = s.as_ref().map(|x| {\n+LL +             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL ~         });\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3a0332939d409a8237572e97d489bce948b44817", "filename": "src/tools/clippy/tests/ui/manual_split_once.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let (_, _) = \"key=value\".split_once('=').unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = &\"key=value\";\n+    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n+        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once(\"key=value\")?.1;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+}"}, {"sha": "e6093b63fe8d428e348760d6a496a3ae4d433090", "filename": "src/tools/clippy/tests/ui/manual_split_once.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = \"key=value\".splitn(2, '=').next();\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+    let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.splitn(2, '=').next().unwrap();\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.splitn(2, '=').nth(0).unwrap();\n+\n+    let s = &\"key=value\";\n+    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.splitn(2, \"key=value\").next()?;\n+        let _ = s.splitn(2, \"key=value\").nth(1)?;\n+        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}"}, {"sha": "4f15196b469e1f73d713f527edca2c57b22af889", "filename": "src/tools/clippy/tests/ui/manual_split_once.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_split_once.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,82 @@\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:13:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+   |\n+   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:15:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:16:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:17:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:18:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:18\n+   |\n+LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:22:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:25:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:28:13\n+   |\n+LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:31:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:32:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:33:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:49:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "b609ba659467f527f4bcc0b54120c75d5bf66791", "filename": "src/tools/clippy/tests/ui/mem_replace.fixed", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -51,9 +51,29 @@ fn replace_with_default() {\n \n     let mut binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n     let _ = std::mem::take(&mut binary_heap);\n+\n+    let mut tuple = (vec![1, 2], BinaryHeap::<i32>::new());\n+    let _ = std::mem::take(&mut tuple);\n+\n+    let mut refstr = \"hello\";\n+    let _ = std::mem::take(&mut refstr);\n+\n+    let mut slice: &[i32] = &[1, 2, 3];\n+    let _ = std::mem::take(&mut slice);\n+}\n+\n+// lint is disabled for primitives because in this case `take`\n+// has no clear benefit over `replace` and sometimes is harder to read\n+fn dont_lint_primitive() {\n+    let mut pbool = true;\n+    let _ = std::mem::replace(&mut pbool, false);\n+\n+    let mut pint = 5;\n+    let _ = std::mem::replace(&mut pint, 0);\n }\n \n fn main() {\n     replace_option_with_none();\n     replace_with_default();\n+    dont_lint_primitive();\n }"}, {"sha": "93f6dcdec83b96b3a8ad49ce9d8c043e24bb71e6", "filename": "src/tools/clippy/tests/ui/mem_replace.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -51,9 +51,29 @@ fn replace_with_default() {\n \n     let mut binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n     let _ = std::mem::replace(&mut binary_heap, BinaryHeap::new());\n+\n+    let mut tuple = (vec![1, 2], BinaryHeap::<i32>::new());\n+    let _ = std::mem::replace(&mut tuple, (vec![], BinaryHeap::new()));\n+\n+    let mut refstr = \"hello\";\n+    let _ = std::mem::replace(&mut refstr, \"\");\n+\n+    let mut slice: &[i32] = &[1, 2, 3];\n+    let _ = std::mem::replace(&mut slice, &[]);\n+}\n+\n+// lint is disabled for primitives because in this case `take`\n+// has no clear benefit over `replace` and sometimes is harder to read\n+fn dont_lint_primitive() {\n+    let mut pbool = true;\n+    let _ = std::mem::replace(&mut pbool, false);\n+\n+    let mut pint = 5;\n+    let _ = std::mem::replace(&mut pint, 0);\n }\n \n fn main() {\n     replace_option_with_none();\n     replace_with_default();\n+    dont_lint_primitive();\n }"}, {"sha": "90dc6c95f858295cef40d0fc6f27fa6b60fa7e85", "filename": "src/tools/clippy/tests/ui/mem_replace.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmem_replace.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -98,5 +98,23 @@ error: replacing a value of type `T` with `T::default()` is better expressed usi\n LL |     let _ = std::mem::replace(&mut binary_heap, BinaryHeap::new());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut binary_heap)`\n \n-error: aborting due to 16 previous errors\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:56:13\n+   |\n+LL |     let _ = std::mem::replace(&mut tuple, (vec![], BinaryHeap::new()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut tuple)`\n+\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:59:13\n+   |\n+LL |     let _ = std::mem::replace(&mut refstr, \"\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut refstr)`\n+\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:62:13\n+   |\n+LL |     let _ = std::mem::replace(&mut slice, &[]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut slice)`\n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "c441b35b9920390c89edfc6ac504716cf25eae2f", "filename": "src/tools/clippy/tests/ui/methods.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -32,7 +32,7 @@ use std::ops::Mul;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n \n-use option_helpers::IteratorFalsePositives;\n+use option_helpers::{IteratorFalsePositives, IteratorMethodFalsePositives};\n \n struct Lt<'a> {\n     foo: &'a u32,\n@@ -131,6 +131,9 @@ fn filter_next() {\n     // Check that we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.filter().next();\n+\n+    let foo = IteratorMethodFalsePositives {};\n+    let _ = foo.filter(42).next();\n }\n \n fn main() {"}, {"sha": "8d9fc5a864d751bf30b27da1990348ab0eb5c205", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -4,6 +4,11 @@\n \n use std::ops::{Deref, RangeFrom};\n \n+fn approx_const() {\n+    let log2_10 = 3.321928094887362;\n+    let log10_2 = 0.301029995663981;\n+}\n+\n fn cloned_instead_of_copied() {\n     let _ = [1].iter().cloned();\n }"}, {"sha": "360dcfb230c6563a6c5de5d5b6e322f70473dac5", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,12 +1,12 @@\n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:160:24\n+  --> $DIR/min_rust_version_attr.rs:165:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::manual-strip` implied by `-D warnings`\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:159:9\n+  --> $DIR/min_rust_version_attr.rs:164:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,13 +17,13 @@ LL ~             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n    |\n \n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:172:24\n+  --> $DIR/min_rust_version_attr.rs:177:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:171:9\n+  --> $DIR/min_rust_version_attr.rs:176:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui/missing-doc-crate.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate.stderr?ref=434cb437b55d61bcb54a01921de7ac752e6dee13"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui/missing_const_for_fn/cant_be_const.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr?ref=434cb437b55d61bcb54a01921de7ac752e6dee13"}, {"sha": "e1ae1ef928223bf748cd6c21c5bf2af27d962a43", "filename": "src/tools/clippy/tests/ui/mut_range_bound.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,14 +1,6 @@\n #![allow(unused)]\n \n-fn main() {\n-    mut_range_bound_upper();\n-    mut_range_bound_lower();\n-    mut_range_bound_both();\n-    mut_range_bound_no_mutation();\n-    immut_range_bound();\n-    mut_borrow_range_bound();\n-    immut_borrow_range_bound();\n-}\n+fn main() {}\n \n fn mut_range_bound_upper() {\n     let mut m = 4;\n@@ -61,3 +53,32 @@ fn immut_range_bound() {\n         continue;\n     } // no warning\n }\n+\n+fn mut_range_bound_break() {\n+    let mut m = 4;\n+    for i in 0..m {\n+        if m == 4 {\n+            m = 5; // no warning because of immediate break\n+            break;\n+        }\n+    }\n+}\n+\n+fn mut_range_bound_no_immediate_break() {\n+    let mut m = 4;\n+    for i in 0..m {\n+        m = 2; // warning because it is not immediately followed by break\n+        if m == 4 {\n+            break;\n+        }\n+    }\n+\n+    let mut n = 3;\n+    for i in n..10 {\n+        if n == 4 {\n+            n = 1; // FIXME: warning because is is not immediately followed by break\n+            let _ = 2;\n+            break;\n+        }\n+    }\n+}"}, {"sha": "4b5a3fc1e418cded8f6b05a5b5c80ffb162ca4e5", "filename": "src/tools/clippy/tests/ui/mut_range_bound.stderr", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_range_bound.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,34 +1,59 @@\n-error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n-  --> $DIR/mut_range_bound.rs:16:9\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:8:9\n    |\n LL |         m = 5;\n    |         ^\n    |\n    = note: `-D clippy::mut-range-bound` implied by `-D warnings`\n+   = note: the range of the loop is unchanged\n \n-error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n-  --> $DIR/mut_range_bound.rs:23:9\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:15:9\n    |\n LL |         m *= 2;\n    |         ^\n+   |\n+   = note: the range of the loop is unchanged\n \n-error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n-  --> $DIR/mut_range_bound.rs:31:9\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:23:9\n    |\n LL |         m = 5;\n    |         ^\n+   |\n+   = note: the range of the loop is unchanged\n \n-error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n-  --> $DIR/mut_range_bound.rs:32:9\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:24:9\n    |\n LL |         n = 7;\n    |         ^\n+   |\n+   = note: the range of the loop is unchanged\n \n-error: attempt to mutate range bound within loop; note that the range of the loop is unchanged\n-  --> $DIR/mut_range_bound.rs:46:22\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:38:22\n    |\n LL |         let n = &mut m; // warning\n    |                      ^\n+   |\n+   = note: the range of the loop is unchanged\n+\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:70:9\n+   |\n+LL |         m = 2; // warning because it is not immediately followed by break\n+   |         ^\n+   |\n+   = note: the range of the loop is unchanged\n+\n+error: attempt to mutate range bound within loop\n+  --> $DIR/mut_range_bound.rs:79:13\n+   |\n+LL |             n = 1; // FIXME: warning because is is not immediately followed by break\n+   |             ^\n+   |\n+   = note: the range of the loop is unchanged\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "d721452ae88803431fd289feb9e223100b16f3ea", "filename": "src/tools/clippy/tests/ui/needless_option_as_deref.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+#[warn(clippy::needless_option_as_deref)]\n+\n+fn main() {\n+    // should lint\n+    let _: Option<&usize> = Some(&1);\n+    let _: Option<&mut usize> = Some(&mut 1);\n+\n+    // should not lint\n+    let _ = Some(Box::new(1)).as_deref();\n+    let _ = Some(Box::new(1)).as_deref_mut();\n+}"}, {"sha": "bb15512adf6aa6c656bba664d822be00aa44364b", "filename": "src/tools/clippy/tests/ui/needless_option_as_deref.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+#[warn(clippy::needless_option_as_deref)]\n+\n+fn main() {\n+    // should lint\n+    let _: Option<&usize> = Some(&1).as_deref();\n+    let _: Option<&mut usize> = Some(&mut 1).as_deref_mut();\n+\n+    // should not lint\n+    let _ = Some(Box::new(1)).as_deref();\n+    let _ = Some(Box::new(1)).as_deref_mut();\n+}"}, {"sha": "5dd507b4a71e8fef8207e5ac6b1b579cac4f9b28", "filename": "src/tools/clippy/tests/ui/needless_option_as_deref.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_option_as_deref.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -0,0 +1,16 @@\n+error: derefed type is same as origin\n+  --> $DIR/needless_option_as_deref.rs:7:29\n+   |\n+LL |     let _: Option<&usize> = Some(&1).as_deref();\n+   |                             ^^^^^^^^^^^^^^^^^^^ help: try this: `Some(&1)`\n+   |\n+   = note: `-D clippy::needless-option-as-deref` implied by `-D warnings`\n+\n+error: derefed type is same as origin\n+  --> $DIR/needless_option_as_deref.rs:8:33\n+   |\n+LL |     let _: Option<&mut usize> = Some(&mut 1).as_deref_mut();\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(&mut 1)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d1815d0aec331692f66945f584d298fdb9e8d839", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -86,4 +87,65 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = Some(0).map_or(0, |x| loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        });\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = Some(0).map_or_else(|| s.len(), |x| s.len() + x);\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = Some(0).map_or(1, |x| {\n+        let s = s;\n+        s.len() + x\n+    });\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "a15627338cb4aaeaa8460c83d03f5e30f5c86c2d", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -105,4 +106,71 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = if let Some(x) = Some(0) {\n+        loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        }\n+    } else {\n+        0\n+    };\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        1\n+    };\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "ed748ee8b39e4422c034f9a96982316dbb256745", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:7:5\n+  --> $DIR/option_if_let_else.rs:8:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,19 +11,19 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:27:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:27:13\n+  --> $DIR/option_if_let_else.rs:28:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -43,13 +43,13 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:34:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:34:13\n+  --> $DIR/option_if_let_else.rs:35:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:40:13\n+  --> $DIR/option_if_let_else.rs:41:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -89,7 +89,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:49:5\n+  --> $DIR/option_if_let_else.rs:50:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -108,7 +108,7 @@ LL +     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:62:13\n+  --> $DIR/option_if_let_else.rs:63:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:71:13\n+  --> $DIR/option_if_let_else.rs:72:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -143,10 +143,58 @@ LL ~     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:100:13\n+  --> $DIR/option_if_let_else.rs:101:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:110:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         loop {\n+LL | |             if x == 0 {\n+LL | |                 break x;\n+...  |\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(0, |x| loop {\n+LL +             if x == 0 {\n+LL +                 break x;\n+LL +             }\n+LL ~         });\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:138:13\n+   |\n+LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:142:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         let s = s;\n+LL | |         s.len() + x\n+LL | |     } else {\n+LL | |         1\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(1, |x| {\n+LL +         let s = s;\n+LL +         s.len() + x\n+LL ~     });\n+   |\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "48fd58c9a49332cef60a8961fea442a958846978", "filename": "src/tools/clippy/tests/ui/proc_macro.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fproc_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fproc_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fproc_macro.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,10 +1,11 @@\n-error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly\n+error: approximate value of `f{32, 64}::consts::PI` found\n   --> $DIR/proc_macro.rs:10:14\n    |\n LL |     let _x = 3.14;\n    |              ^^^^\n    |\n    = note: `#[deny(clippy::approx_constant)]` on by default\n+   = help: consider using the constant directly\n \n error: aborting due to previous error\n "}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui/rc_buffer_redefined_string.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_buffer_redefined_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/434cb437b55d61bcb54a01921de7ac752e6dee13/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_buffer_redefined_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_buffer_redefined_string.stderr?ref=434cb437b55d61bcb54a01921de7ac752e6dee13"}, {"sha": "18e8a2e01e0227cc02478346c42822a45e4b1314", "filename": "src/tools/clippy/tests/ui/rc_mutex.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,13 +1,17 @@\n #![warn(clippy::rc_mutex)]\n-#![allow(clippy::blacklisted_name)]\n+#![allow(unused, clippy::blacklisted_name)]\n \n use std::rc::Rc;\n use std::sync::Mutex;\n \n-pub struct MyStruct {\n+pub struct MyStructWithPrivItem {\n     foo: Rc<Mutex<i32>>,\n }\n \n+pub struct MyStructWithPubItem {\n+    pub foo: Rc<Mutex<i32>>,\n+}\n+\n pub struct SubT<T> {\n     foo: T,\n }\n@@ -17,18 +21,16 @@ pub enum MyEnum {\n     Two,\n }\n \n-pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n-\n-pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+// All of these test should be trigger the lint because they are not\n+// part of the public api\n+fn test1<T>(foo: Rc<Mutex<T>>) {}\n+fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n \n-pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test1<T>(foo: Rc<Mutex<T>>) {}\n+pub fn pub_test2(foo: Rc<Mutex<MyEnum>>) {}\n+pub fn pub_test3(foo: Rc<Mutex<SubT<usize>>>) {}\n \n-fn main() {\n-    test1(Rc::new(Mutex::new(1)));\n-    test2(Rc::new(Mutex::new(MyEnum::One)));\n-    test3(Rc::new(Mutex::new(SubT { foo: 1 })));\n-\n-    let _my_struct = MyStruct {\n-        foo: Rc::new(Mutex::new(1)),\n-    };\n-}\n+fn main() {}"}, {"sha": "fe84361d781622b746522ed52e138bac237b2f46", "filename": "src/tools/clippy/tests/ui/rc_mutex.stderr", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frc_mutex.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,28 +1,35 @@\n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+error: usage of `Rc<Mutex<_>>`\n   --> $DIR/rc_mutex.rs:8:10\n    |\n LL |     foo: Rc<Mutex<i32>>,\n    |          ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::rc-mutex` implied by `-D warnings`\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:20:22\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:26:18\n    |\n-LL | pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n-   |                      ^^^^^^^^^^^^\n+LL | fn test1<T>(foo: Rc<Mutex<T>>) {}\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:22:19\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:27:15\n+   |\n+LL | fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+   |               ^^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n-   |                   ^^^^^^^^^^^^^^^^^\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:24:19\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:28:15\n+   |\n+LL | fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n error: aborting due to 4 previous errors\n "}, {"sha": "52fbc91e325555a9c808f57a47e76cc48e893363", "filename": "src/tools/clippy/tests/ui/redundant_allocation.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -77,4 +77,24 @@ mod outer_arc {\n     }\n }\n \n+// https://github.com/rust-lang/rust-clippy/issues/7487\n+mod box_dyn {\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub trait T {}\n+\n+    struct S {\n+        a: Box<Box<dyn T>>,\n+        b: Rc<Box<dyn T>>,\n+        c: Arc<Box<dyn T>>,\n+    }\n+\n+    pub fn test_box(_: Box<Box<dyn T>>) {}\n+    pub fn test_rc(_: Rc<Box<dyn T>>) {}\n+    pub fn test_arc(_: Arc<Box<dyn T>>) {}\n+    pub fn test_rc_box(_: Rc<Box<Box<dyn T>>>) {}\n+}\n+\n fn main() {}"}, {"sha": "c3b10e5f5e679df879418117c4840aa6268b07dd", "filename": "src/tools/clippy/tests/ui/redundant_allocation.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_allocation.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -134,5 +134,14 @@ LL |     pub fn arc_test9<T>(foo: Arc<Rc<T>>) -> Arc<Rc<SubT<T>>> {\n    = note: `Rc<SubT<T>>` is already on the heap, `Arc<Rc<SubT<T>>>` makes an extra allocation\n    = help: consider using just `Arc<SubT<T>>` or `Rc<SubT<T>>`\n \n-error: aborting due to 15 previous errors\n+error: usage of `Rc<Box<Box<dyn T>>>`\n+  --> $DIR/redundant_allocation.rs:97:27\n+   |\n+LL |     pub fn test_rc_box(_: Rc<Box<Box<dyn T>>>) {}\n+   |                           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Box<Box<dyn T>>` is already on the heap, `Rc<Box<Box<dyn T>>>` makes an extra allocation\n+   = help: consider using just `Rc<Box<dyn T>>` or `Box<Box<dyn T>>`\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "bf0ec8deb3458bccdc65a4151a8237241f6a0626", "filename": "src/tools/clippy/tests/ui/unnecessary_operation.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.fixed?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -62,10 +62,10 @@ fn main() {\n     get_number();\n     5;get_number();\n     42;get_number();\n-    [42, 55];get_usize();\n+    assert!([42, 55].len() > get_usize());\n     42;get_number();\n     get_number();\n-    [42; 55];get_usize();\n+    assert!([42; 55].len() > get_usize());\n     get_number();\n     String::from(\"blah\");\n "}, {"sha": "f66d08ecb8281bb9f5cd357b6482ebb8b9f9d714", "filename": "src/tools/clippy/tests/ui/unnecessary_operation.stderr", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_operation.stderr?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,128 +1,128 @@\n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:51:5\n    |\n LL |     Tuple(get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n    |\n    = note: `-D clippy::unnecessary-operation` implied by `-D warnings`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:52:5\n    |\n LL |     Struct { field: get_number() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:53:5\n    |\n LL |     Struct { ..get_struct() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_struct();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_struct();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:54:5\n    |\n LL |     Enum::Tuple(get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:55:5\n    |\n LL |     Enum::Struct { field: get_number() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:56:5\n    |\n LL |     5 + get_number();\n-   |     ^^^^^^^^^^^^^^^^^ help: replace it with: `5;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:57:5\n    |\n LL |     *&get_number();\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:58:5\n    |\n LL |     &get_number();\n-   |     ^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:59:5\n    |\n LL |     (5, 6, get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `5;6;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;6;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:60:5\n    |\n LL |     box get_number();\n-   |     ^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:61:5\n    |\n LL |     get_number()..;\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:62:5\n    |\n LL |     ..get_number();\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:63:5\n    |\n LL |     5..get_number();\n-   |     ^^^^^^^^^^^^^^^^ help: replace it with: `5;get_number();`\n+   |     ^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:64:5\n    |\n LL |     [42, get_number()];\n-   |     ^^^^^^^^^^^^^^^^^^^ help: replace it with: `42;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `42;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:65:5\n    |\n LL |     [42, 55][get_usize()];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `[42, 55];get_usize();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: statement can be written as: `assert!([42, 55].len() > get_usize());`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:66:5\n    |\n LL |     (42, get_number()).1;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `42;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `42;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:67:5\n    |\n LL |     [get_number(); 55];\n-   |     ^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:68:5\n    |\n LL |     [42; 55][get_usize()];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `[42; 55];get_usize();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: statement can be written as: `assert!([42; 55].len() > get_usize());`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:69:5\n    |\n LL | /     {\n LL | |         get_number()\n LL | |     };\n-   | |______^ help: replace it with: `get_number();`\n+   | |______^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:72:5\n    |\n LL | /     FooString {\n LL | |         s: String::from(\"blah\"),\n LL | |     };\n-   | |______^ help: replace it with: `String::from(\"blah\");`\n+   | |______^ help: statement can be reduced to: `String::from(\"blah\");`\n \n error: aborting due to 20 previous errors\n "}, {"sha": "77102b8cac0c977e9621dc9bcc1bf1c6bcb5c11d", "filename": "src/tools/clippy/tests/versioncheck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7636fbce7eb25b3178842499588bb121b781b4f5/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs?ref=7636fbce7eb25b3178842499588bb121b781b4f5", "patch": "@@ -1,4 +1,7 @@\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n #![allow(clippy::single_match_else)]\n+\n use rustc_tools_util::VersionInfo;\n \n #[test]"}]}