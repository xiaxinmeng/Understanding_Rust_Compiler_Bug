{"sha": "e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNWUyZTA2MDBlMTMwMjJhZDMwYzFmNmM3ZGRmZGZkNThlOWVmYTE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-01T22:29:06Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-14T22:41:28Z"}, "message": "make autoderef steps a query", "tree": {"sha": "765b517e0b97ffd0764602da3fabf378203ed177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/765b517e0b97ffd0764602da3fabf378203ed177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "html_url": "https://github.com/rust-lang/rust/commit/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2", "html_url": "https://github.com/rust-lang/rust/commit/be2bb4fa1d5788ba1d2df757090daf5fa75df4a2"}], "stats": {"total": 158, "additions": 110, "deletions": 48}, "files": [{"sha": "61efdc820462756552d5fa5428b83172e068d7aa", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -666,6 +666,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n+    [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n \n     [input] TargetFeaturesWhitelist,\n "}, {"sha": "e67497915d7cb6a210b60a2a4e1985cbe8939a56", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::sync::Lrc;\n+use infer::canonical::{Canonical, QueryResponse};\n+use ty::Ty;\n+\n+#[derive(Debug)]\n+pub struct CandidateStep<'tcx> {\n+    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    pub autoderefs: usize,\n+    // true if the type results from a dereference of a raw pointer.\n+    // when assembling candidates, we include these steps, but not when\n+    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    pub from_unsafe_deref: bool,\n+    pub unsize: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct MethodAutoderefStepsResult<'tcx> {\n+    /// The valid autoderef steps that could be find.\n+    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    /// If Some(T), a type autoderef reported an error on.\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>\n+}\n+\n+#[derive(Debug)]\n+pub struct MethodAutoderefBadTy<'tcx> {\n+    pub reached_raw_pointer: bool,\n+    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+}\n+\n+impl_stable_hash_for!(struct MethodAutoderefBadTy<'tcx> {\n+    reached_raw_pointer, ty\n+});\n+\n+impl_stable_hash_for!(struct MethodAutoderefStepsResult<'tcx> {\n+    steps, opt_bad_ty\n+});\n+\n+impl_stable_hash_for!(struct CandidateStep<'tcx> {\n+    self_ty, autoderefs, from_unsafe_deref, unsize\n+});"}, {"sha": "b11cb7377645c3a5344e21c60dce6526998e52f2", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -21,6 +21,7 @@ use ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n+pub mod method_autoderef;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n pub mod outlives_bounds;"}, {"sha": "b320c29dfada5f10a1aad4301ab1bbab70eb06b9", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -827,6 +827,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_pre\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::method_autoderef_steps<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing autoderef types for `{:?}`\", goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"looking up the whitelist of target features\".into()"}, {"sha": "0e6810face5285b6a716782945c6124a7c139c27", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -40,6 +40,7 @@ use traits::query::{\n     CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n+use traits::query::method_autoderef::MethodAutoderefStepsResult;\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::query::outlives_bounds::OutlivesBound;\n@@ -668,6 +669,10 @@ define_queries! { <'tcx>\n \n         [] fn substitute_normalize_and_test_predicates:\n             substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+\n+        [] fn method_autoderef_steps: MethodAutoderefSteps(\n+            CanonicalTyGoal<'tcx>\n+        ) -> MethodAutoderefStepsResult<'tcx>,\n     },\n \n     Other {"}, {"sha": "3fac2db281bb9fcfba6e5796dd39909334f49fec", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -1089,6 +1089,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeOpNormalizePolyFnSig |\n         DepKind::TypeOpNormalizeFnSig |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n+        DepKind::MethodAutoderefSteps |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |\n "}, {"sha": "5ecbfcd132cf31c7310d6c1c30ca93ba55e43fe2", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -39,6 +39,7 @@ use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     suggest::provide(providers);\n+    probe::provide(providers);\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "539c33cc14ae9c3de5ae00cf02df0ede9d35eb55", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e25e2e0600e13022ad30c1f6c7ddfdfd58e9efa1", "patch": "@@ -19,12 +19,16 @@ use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n use rustc::lint;\n use rustc::session::config::nightly_options;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, ParamEnv, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n+use rustc::traits::query::{CanonicalTyGoal};\n+use rustc::traits::query::method_autoderef::{CandidateStep, MethodAutoderefStepsResult};\n+use rustc::traits::query::method_autoderef::{MethodAutoderefBadTy};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n@@ -34,7 +38,7 @@ use rustc::infer::canonical::{OriginalQueryValues};\n use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n-use syntax_pos::{Span, symbol::Symbol};\n+use syntax_pos::{DUMMY_SP, Span, symbol::Symbol};\n use std::iter;\n use std::mem;\n use std::ops::Deref;\n@@ -59,7 +63,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// This is the OriginalQueryValues for the steps queries\n     /// that are answered in steps.\n     orig_steps_var_values: OriginalQueryValues<'tcx>,\n-    steps: Rc<Vec<CandidateStep<'gcx>>>,\n+    steps: Lrc<Vec<CandidateStep<'gcx>>>,\n \n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n@@ -90,19 +94,6 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-struct CandidateStep<'gcx> {\n-    self_ty: Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>,\n-    autoderefs: usize,\n-    // true if the type results from a dereference of a raw pointer.\n-    // when assembling candidates, we include these steps, but not when\n-    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n-    from_unsafe_deref: bool,\n-    unsize: bool,\n-}\n-\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n@@ -260,11 +251,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty =\n-            self.infcx.canonicalize_query(&(self.param_env, self_ty), &mut orig_values);\n+            self.infcx.canonicalize_query(\n+                &ParamEnvAnd {\n+                    param_env: self.param_env,\n+                    value: self_ty\n+                }, &mut orig_values);\n \n-        // FIXME: consider caching this \"whole op\" here.\n         let steps = if mode == Mode::MethodCall {\n-            create_steps_inner(self.tcx.global_tcx(), span, param_env_and_self_ty)\n+            self.tcx.method_autoderef_steps(param_env_and_self_ty)\n         } else {\n             self.infcx.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n@@ -273,30 +267,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // special handling for this \"trivial case\" is a good idea.\n \n                 let infcx = &self.infcx;\n-                let ((_, self_ty), canonical_inference_vars) =\n+                let (ParamEnvAnd {\n+                    param_env: _,\n+                    value: self_ty\n+                }, canonical_inference_vars) =\n                     infcx.instantiate_canonical_with_fresh_inference_vars(\n                         span, &param_env_and_self_ty);\n-                debug!(\"param_env_and_self_ty={:?} self_ty={:?}\", param_env_and_self_ty, self_ty);\n-                CreateStepsResult {\n-                    steps: vec![CandidateStep {\n+                debug!(\"probe_op: Mode::Path, param_env_and_self_ty={:?} self_ty={:?}\",\n+                       param_env_and_self_ty, self_ty);\n+                MethodAutoderefStepsResult {\n+                    steps: Lrc::new(vec![CandidateStep {\n                         self_ty: self.make_query_response_with_obligations_pending(\n                             canonical_inference_vars, self_ty),\n                         autoderefs: 0,\n                         from_unsafe_deref: false,\n                         unsize: false,\n-                    }],\n+                    }]),\n                     opt_bad_ty: None\n                 }\n             })\n         };\n \n         // If we encountered an `_` type or an error type during autoderef, this is\n         // ambiguous.\n-        if let Some(CreateStepsBadTy { reached_raw_pointer, ty }) = &steps.opt_bad_ty {\n+        if let Some(autoderef_bad_ty) = &steps.opt_bad_ty {\n+            let MethodAutoderefBadTy { reached_raw_pointer, ref ty } = **autoderef_bad_ty;\n             if is_suggestion.0 {\n                 // Ambiguity was encountered during a suggestion. Just keep going.\n                 debug!(\"ProbeContext: encountered ambiguity in suggestion\");\n-            } else if *reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n+            } else if reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n                 // this case used to be allowed by the compiler,\n                 // so we do a future-compat lint here for the 2015 edition\n                 // (see https://github.com/rust-lang/rust/issues/46906)\n@@ -337,7 +336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             let mut probe_cx = ProbeContext::new(\n                 self, span, mode, method_name, return_type, orig_values,\n-                Rc::new(steps.steps), is_suggestion,\n+                steps.steps, is_suggestion,\n             );\n \n             probe_cx.assemble_inherent_candidates();\n@@ -352,27 +351,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-struct CreateStepsResult<'gcx> {\n-    steps: Vec<CandidateStep<'gcx>>,\n-    opt_bad_ty: Option<CreateStepsBadTy<'gcx>>\n-}\n-\n-#[derive(Debug)]\n-struct CreateStepsBadTy<'gcx> {\n-    reached_raw_pointer: bool,\n-    ty: Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>,\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n-fn create_steps_inner<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                      span: Span,\n-                                      pe_and_self_ty: Canonical<'gcx, (ParamEnv<'gcx>, Ty<'gcx>)>)\n-                                      -> CreateStepsResult<'gcx>\n+fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                          goal: CanonicalTyGoal<'tcx>)\n+                                          -> MethodAutoderefStepsResult<'gcx>\n {\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let ((param_env, self_ty), inference_vars) =\n-            infcx.instantiate_canonical_with_fresh_inference_vars(span, &pe_and_self_ty);\n-        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, span, self_ty)\n+    debug!(\"method_autoderef_steps({:?})\", goal);\n+\n+    tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n+        let ParamEnvAnd { param_env, value: self_ty } = goal;\n+\n+        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, DUMMY_SP, self_ty)\n             .include_raw_pointers();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef.by_ref()\n@@ -396,7 +388,7 @@ fn create_steps_inner<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let opt_bad_ty = match final_ty.sty {\n             ty::Infer(ty::TyVar(_)) |\n             ty::Error => {\n-                Some(CreateStepsBadTy {\n+                Some(MethodAutoderefBadTy {\n                     reached_raw_pointer,\n                     ty: infcx.make_query_response_with_obligations_pending(\n                         inference_vars, final_ty)\n@@ -420,9 +412,12 @@ fn create_steps_inner<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n             _ => None\n         };\n \n-        debug!(\"create_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n+        debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n \n-        CreateStepsResult { steps, opt_bad_ty }\n+        MethodAutoderefStepsResult {\n+            steps: Lrc::new(steps),\n+            opt_bad_ty: opt_bad_ty.map(Lrc::new)\n+        }\n     })\n }\n "}]}