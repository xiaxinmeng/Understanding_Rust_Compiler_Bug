{"sha": "1ec2c136b35bd4660cba778346f8df7daf2ab173", "node_id": "C_kwDOAAsO6NoAKDFlYzJjMTM2YjM1YmQ0NjYwY2JhNzc4MzQ2ZjhkZjdkYWYyYWIxNzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T12:56:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-17T12:56:19Z"}, "message": "Auto merge of #95779 - cjgillot:ast-lifetimes-undeclared, r=petrochenkov\n\nReport undeclared lifetimes during late resolution.\n\nFirst step in https://github.com/rust-lang/rust/pull/91557\n\nWe reuse the rib design of the current resolution framework. Specific `LifetimeRib` and `LifetimeRibKind` types are introduced. The most important variant is `LifetimeRibKind::Generics`, which happens each time we encounter something which may introduce generic lifetime parameters. It can be an item or a `for<...>` binder. The `LifetimeBinderKind` specifies how this rib behaves with respect to in-band lifetimes.\n\nr? `@petrochenkov`", "tree": {"sha": "3a0923df3630bd8753561b81e704834eb3b9da88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a0923df3630bd8753561b81e704834eb3b9da88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec2c136b35bd4660cba778346f8df7daf2ab173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec2c136b35bd4660cba778346f8df7daf2ab173", "html_url": "https://github.com/rust-lang/rust/commit/1ec2c136b35bd4660cba778346f8df7daf2ab173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec2c136b35bd4660cba778346f8df7daf2ab173/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af68f7182e11de7eced78078313e9ba0436db84e", "url": "https://api.github.com/repos/rust-lang/rust/commits/af68f7182e11de7eced78078313e9ba0436db84e", "html_url": "https://github.com/rust-lang/rust/commit/af68f7182e11de7eced78078313e9ba0436db84e"}, {"sha": "e628df9b0b0310fb293c75e75ad19c72f92381f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e628df9b0b0310fb293c75e75ad19c72f92381f8", "html_url": "https://github.com/rust-lang/rust/commit/e628df9b0b0310fb293c75e75ad19c72f92381f8"}], "stats": {"total": 2641, "additions": 1859, "deletions": 782}, "files": [{"sha": "d925c6dd3549aa5da8b01d7a80858bd1dccaf8d1", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -35,7 +35,7 @@ pub enum FnCtxt {\n #[derive(Copy, Clone, Debug)]\n pub enum FnKind<'a> {\n     /// E.g., `fn foo()`, `fn foo(&self)`, or `extern \"Abi\" fn foo()`.\n-    Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),\n+    Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, &'a Generics, Option<&'a Block>),\n \n     /// E.g., `|x, y| body`.\n     Closure(&'a FnDecl, &'a Expr),\n@@ -44,7 +44,7 @@ pub enum FnKind<'a> {\n impl<'a> FnKind<'a> {\n     pub fn header(&self) -> Option<&'a FnHeader> {\n         match *self {\n-            FnKind::Fn(_, _, sig, _, _) => Some(&sig.header),\n+            FnKind::Fn(_, _, sig, _, _, _) => Some(&sig.header),\n             FnKind::Closure(_, _) => None,\n         }\n     }\n@@ -58,7 +58,7 @@ impl<'a> FnKind<'a> {\n \n     pub fn decl(&self) -> &'a FnDecl {\n         match self {\n-            FnKind::Fn(_, _, sig, _, _) => &sig.decl,\n+            FnKind::Fn(_, _, sig, _, _, _) => &sig.decl,\n             FnKind::Closure(decl, _) => decl,\n         }\n     }\n@@ -295,8 +295,8 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             walk_list!(visitor, visit_expr, expr);\n         }\n         ItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n-            visitor.visit_generics(generics);\n-            let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n+            let kind =\n+                FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n         ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n@@ -561,8 +561,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             walk_list!(visitor, visit_expr, expr);\n         }\n         ForeignItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n-            visitor.visit_generics(generics);\n-            let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, body.as_deref());\n+            let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n         ForeignItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n@@ -644,7 +643,8 @@ pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &\n \n pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Span) {\n     match kind {\n-        FnKind::Fn(_, _, sig, _, body) => {\n+        FnKind::Fn(_, _, sig, _, generics, body) => {\n+            visitor.visit_generics(generics);\n             visitor.visit_fn_header(&sig.header);\n             walk_fn_decl(visitor, &sig.decl);\n             walk_list!(visitor, visit_block, body);\n@@ -667,8 +667,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             walk_list!(visitor, visit_expr, expr);\n         }\n         AssocItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n-            visitor.visit_generics(generics);\n-            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, body.as_deref());\n+            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n         AssocItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {"}, {"sha": "9cb205074e7eaf6b9a81413042c3127e991a14bd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -484,7 +484,7 @@ enum ParenthesizedGenericArgs {\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n #[derive(Copy, Clone, Debug)]\n-enum AnonymousLifetimeMode {\n+pub enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n     ///\n@@ -1835,7 +1835,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Output lifetime like `'_`:\n             for (span, node_id) in lifetimes_to_define {\n                 let param = this.fresh_lifetime_to_generic_param(span, node_id);\n-                lifetime_params.push((span, hir::LifetimeName::Implicit(false)));\n+                lifetime_params.push((span, hir::LifetimeName::Implicit));\n                 generic_params.push(param);\n             }\n             let generic_params = this.arena.alloc_from_iter(generic_params);\n@@ -2017,16 +2017,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    hir::LifetimeName::Implicit(_)\n-                    | hir::LifetimeName::Underscore\n-                    | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                        hir::ParamName::Plain(lt.name.ident())\n+                    }\n                     hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n                         self.sess.diagnostic().span_bug(\n                             param.ident.span,\n                             \"object-lifetime-default should not occur here\",\n                         );\n                     }\n-                    hir::LifetimeName::Error => ParamName::Error,\n+                    hir::LifetimeName::Static | hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n                 let kind =\n@@ -2397,27 +2397,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span, false),\n+            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n         }\n     }\n \n     /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n     /// return an \"error lifetime\".\n     fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n-        let (id, msg, label) = match id {\n-            Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),\n-\n-            None => (\n-                self.resolver.next_node_id(),\n-                \"`&` without an explicit lifetime name cannot be used here\",\n-                \"explicit lifetime name needed here\",\n-            ),\n-        };\n-\n-        let mut err = struct_span_err!(self.sess, span, E0637, \"{}\", msg,);\n-        err.span_label(span, label);\n-        err.emit();\n-\n+        let id = id.unwrap_or_else(|| self.resolver.next_node_id());\n         self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n     }\n \n@@ -2429,12 +2416,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &'s mut self,\n         span: Span,\n         count: usize,\n-        param_mode: ParamMode,\n     ) -> impl Iterator<Item = hir::Lifetime> + Captures<'a> + Captures<'s> + Captures<'hir> {\n-        (0..count).map(move |_| self.elided_path_lifetime(span, param_mode))\n+        (0..count).map(move |_| self.elided_path_lifetime(span))\n     }\n \n-    fn elided_path_lifetime(&mut self, span: Span, param_mode: ParamMode) -> hir::Lifetime {\n+    fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n             AnonymousLifetimeMode::CreateParameter => {\n                 // We should have emitted E0726 when processing this path above\n@@ -2450,7 +2436,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n             // later, at which point a suitable error will be emitted.\n             AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                self.new_implicit_lifetime(span, param_mode == ParamMode::Explicit)\n+                self.new_implicit_lifetime(span)\n             }\n         }\n     }\n@@ -2493,11 +2479,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         r\n     }\n \n-    fn new_implicit_lifetime(&mut self, span: Span, missing: bool) -> hir::Lifetime {\n+    fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n             hir_id: self.next_id(),\n             span: self.lower_span(span),\n-            name: hir::LifetimeName::Implicit(missing),\n+            name: hir::LifetimeName::Implicit,\n         }\n     }\n }\n@@ -2600,7 +2586,7 @@ fn lifetimes_from_impl_trait_bounds(\n \n         fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n             let name = match lifetime.name {\n-                hir::LifetimeName::Implicit(_) | hir::LifetimeName::Underscore => {\n+                hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n                     if self.collect_elided_lifetimes {\n                         // Use `'_` for both implicit and underscore lifetimes in\n                         // `type Foo<'_> = impl SomeTrait<'_>;`."}, {"sha": "8bf4b8fcc3975347c926a41373d56f359fb65b97", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -290,47 +290,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n             };\n             generic_args.args = self\n-                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes, param_mode)\n+                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes)\n                 .map(GenericArg::Lifetime)\n                 .chain(generic_args.args.into_iter())\n                 .collect();\n-            // In create-parameter mode we error here because we don't want to support\n-            // deprecated impl elision in new features like impl elision and `async fn`,\n-            // both of which work using the `CreateParameter` mode:\n-            //\n-            //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-            //     async fn foo(_: std::cell::Ref<u32>) { ... }\n             if let (ParamMode::Explicit, AnonymousLifetimeMode::CreateParameter) =\n                 (param_mode, self.anonymous_lifetime_mode)\n             {\n-                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n-                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n-                let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no generic args, our suggestion can include the angle brackets.\n-                    (true, format!(\"<{}>\", anon_lt_suggestion))\n-                } else {\n-                    // Otherwise we'll insert a `'_, ` right after the opening bracket.\n-                    (false, format!(\"{}, \", anon_lt_suggestion))\n-                };\n-                let insertion_sp = elided_lifetime_span.shrink_to_hi();\n-                let mut err = struct_span_err!(\n-                    self.sess,\n-                    path_span,\n-                    E0726,\n-                    \"implicit elided lifetime not allowed here\"\n-                );\n-                rustc_errors::add_elided_lifetime_in_path_suggestion(\n-                    &self.sess.source_map(),\n-                    &mut err,\n-                    expected_lifetimes,\n-                    path_span,\n-                    incl_angl_brckt,\n-                    insertion_sp,\n-                    suggestion,\n-                );\n-                err.note(\"assuming a `'static` lifetime...\");\n-                err.emit();\n+                // Late resolver should have issued the error.\n+                self.sess\n+                    .delay_span_bug(elided_lifetime_span, \"implicit lifetime not allowed here\");\n             }\n         }\n "}, {"sha": "8d815e95528825a269a56f88619e9102631d5cc4", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -91,16 +91,18 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n-    fn with_tilde_const_allowed(&mut self, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_tilde_const_allowed, true);\n+    fn with_tilde_const(&mut self, allowed: bool, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.is_tilde_const_allowed, allowed);\n         f(self);\n         self.is_tilde_const_allowed = old;\n     }\n \n+    fn with_tilde_const_allowed(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.with_tilde_const(true, f)\n+    }\n+\n     fn with_banned_tilde_const(&mut self, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_tilde_const_allowed, false);\n-        f(self);\n-        self.is_tilde_const_allowed = old;\n+        self.with_tilde_const(false, f)\n     }\n \n     fn with_let_management(\n@@ -1202,12 +1204,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 self.visit_vis(&item.vis);\n                 self.visit_ident(item.ident);\n-                if let Const::Yes(_) = sig.header.constness {\n-                    self.with_tilde_const_allowed(|this| this.visit_generics(generics));\n-                } else {\n-                    self.visit_generics(generics);\n-                }\n-                let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n+                let kind =\n+                    FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n                 self.visit_fn(kind, item.span, item.id);\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return; // Avoid visiting again.\n@@ -1555,13 +1553,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             FnSig { span: sig_span, header: FnHeader { ext: Extern::Implicit, .. }, .. },\n             _,\n             _,\n+            _,\n         ) = fk\n         {\n             self.maybe_lint_missing_abi(*sig_span, id);\n         }\n \n         // Functions without bodies cannot have patterns.\n-        if let FnKind::Fn(ctxt, _, sig, _, None) = fk {\n+        if let FnKind::Fn(ctxt, _, sig, _, _, None) = fk {\n             Self::check_decl_no_pat(&sig.decl, |span, ident, mut_ident| {\n                 let (code, msg, label) = match ctxt {\n                     FnCtxt::Foreign => (\n@@ -1596,7 +1595,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             });\n         }\n \n-        visit::walk_fn(self, fk, span);\n+        let tilde_const_allowed =\n+            matches!(fk.header(), Some(FnHeader { constness: Const::Yes(_), .. }))\n+                || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n+\n+        self.with_tilde_const(tilde_const_allowed, |this| visit::walk_fn(this, fk, span));\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n@@ -1670,9 +1673,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             {\n                 self.visit_vis(&item.vis);\n                 self.visit_ident(item.ident);\n-                self.with_tilde_const_allowed(|this| this.visit_generics(generics));\n-                let kind =\n-                    FnKind::Fn(FnCtxt::Assoc(ctxt), item.ident, sig, &item.vis, body.as_deref());\n+                let kind = FnKind::Fn(\n+                    FnCtxt::Assoc(ctxt),\n+                    item.ident,\n+                    sig,\n+                    &item.vis,\n+                    generics,\n+                    body.as_deref(),\n+                );\n                 self.visit_fn(kind, item.span, item.id);\n             }\n             _ => self"}, {"sha": "459d4a783e40f06042bbd4f5660e5e35c53622a7", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -575,7 +575,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit(_) => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "d7c5df7d8e26eed42b608e4cd20514555e3b67f5", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1511,35 +1511,17 @@ pub fn add_elided_lifetime_in_path_suggestion(\n     path_span: Span,\n     incl_angl_brckt: bool,\n     insertion_span: Span,\n-    anon_lts: String,\n ) {\n-    let (replace_span, suggestion) = if incl_angl_brckt {\n-        (insertion_span, anon_lts)\n-    } else {\n-        // When possible, prefer a suggestion that replaces the whole\n-        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n-        // at a point (which makes for an ugly/confusing label)\n-        if let Ok(snippet) = source_map.span_to_snippet(path_span) {\n-            // But our spans can get out of whack due to macros; if the place we think\n-            // we want to insert `'_` isn't even within the path expression's span, we\n-            // should bail out of making any suggestion rather than panicking on a\n-            // subtract-with-overflow or string-slice-out-out-bounds (!)\n-            // FIXME: can we do better?\n-            if insertion_span.lo().0 < path_span.lo().0 {\n-                return;\n-            }\n-            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n-            if insertion_index > snippet.len() {\n-                return;\n-            }\n-            let (before, after) = snippet.split_at(insertion_index);\n-            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n-        } else {\n-            (insertion_span, anon_lts)\n-        }\n-    };\n-    diag.span_suggestion(\n-        replace_span,\n+    diag.span_label(path_span, format!(\"expected lifetime parameter{}\", pluralize!(n)));\n+    if source_map.span_to_snippet(insertion_span).is_err() {\n+        // Do not try to suggest anything if generated by a proc-macro.\n+        return;\n+    }\n+    let anon_lts = vec![\"'_\"; n].join(\", \");\n+    let suggestion =\n+        if incl_angl_brckt { format!(\"<{}>\", anon_lts) } else { format!(\"{}, \", anon_lts) };\n+    diag.span_suggestion_verbose(\n+        insertion_span.shrink_to_hi(),\n         &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n         suggestion,\n         Applicability::MachineApplicable,"}, {"sha": "b3de86662eb09dc71da34f0f7187bab0bf975458", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -95,7 +95,7 @@ pub enum LifetimeName {\n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     ///\n     /// The bool indicates whether the user should have written something.\n-    Implicit(bool),\n+    Implicit,\n \n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n@@ -125,7 +125,7 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit(_)\n+            | LifetimeName::Implicit\n             | LifetimeName::Error => Ident::empty(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n@@ -136,7 +136,7 @@ impl LifetimeName {\n     pub fn is_elided(&self) -> bool {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault\n-            | LifetimeName::Implicit(_)\n+            | LifetimeName::Implicit\n             | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as"}, {"sha": "8689e2c2afab36fd504eaf3c203bc09226bb8872", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -528,7 +528,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         | LifetimeName::Param(ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n-        | LifetimeName::Implicit(_)\n+        | LifetimeName::Implicit\n         | LifetimeName::ImplicitObjectLifetimeDefault\n         | LifetimeName::Underscore => {}\n     }"}, {"sha": "77fe76af2de21ce7d777168524540788f5145347", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -441,6 +441,7 @@ impl EarlyLintPass for UnsafeCode {\n             _,\n             ast::FnSig { header: ast::FnHeader { unsafety: ast::Unsafe::Yes(_), .. }, .. },\n             _,\n+            _,\n             body,\n         ) = fk\n         {"}, {"sha": "152c53dac7ff8d0790927205cf418116d336d06a", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -21,7 +21,8 @@ use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast::util::unicode::TEXT_FLOW_CONTROL_CHARS;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{struct_span_err, Applicability, MultiSpan, SuggestionStyle};\n+use rustc_errors::{add_elided_lifetime_in_path_suggestion, struct_span_err};\n+use rustc_errors::{Applicability, MultiSpan, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n@@ -665,6 +666,21 @@ pub trait LintContext: Sized {\n                 ) => {\n                     db.span_note(span_def, \"the macro is defined here\");\n                 }\n+                BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                    n,\n+                    path_span,\n+                    incl_angl_brckt,\n+                    insertion_span,\n+                ) => {\n+                    add_elided_lifetime_in_path_suggestion(\n+                        sess.source_map(),\n+                        &mut db,\n+                        n,\n+                        path_span,\n+                        incl_angl_brckt,\n+                        insertion_span,\n+                    );\n+                }\n                 BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n                     db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n                 }"}, {"sha": "b4262f184c8c43bc294cdfab261af6dd83872976", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -158,7 +158,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         // Explicitly check for lints associated with 'closure_id', since\n         // it does not have a corresponding AST node\n-        if let ast_visit::FnKind::Fn(_, _, sig, _, _) = fk {\n+        if let ast_visit::FnKind::Fn(_, _, sig, _, _, _) = fk {\n             if let ast::Async::Yes { closure_id, .. } = sig.header.asyncness {\n                 self.check_id(closure_id);\n             }\n@@ -284,6 +284,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         ast_visit::walk_path(self, p);\n     }\n \n+    fn visit_path_segment(&mut self, path_span: Span, s: &'a ast::PathSegment) {\n+        self.check_id(s.id);\n+        ast_visit::walk_path_segment(self, path_span, s);\n+    }\n+\n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         run_early_pass!(self, check_attribute, attr);\n     }"}, {"sha": "4debbf26be63b1063c7c9dc855f0153662416756", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -418,6 +418,7 @@ pub enum BuiltinLintDiagnostics {\n     AbsPathWithModule(Span),\n     ProcMacroDeriveResolutionFallback(Span),\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n+    ElidedLifetimesInPaths(usize, Span, bool, Span),\n     UnknownCrateTypes(Span, String, String),\n     UnusedImports(String, Vec<(Span, String)>, Option<Span>),\n     RedundantImport(Vec<(Span, bool)>, Ident),"}, {"sha": "063b15e643d9c96f5f27bb1a6ba597e40bfe1f66", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -521,11 +521,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != kw::Empty {\n                             // `crate_name` should not be interpreted as relative.\n-                            module_path.push(Segment {\n-                                ident: Ident { name: kw::PathRoot, span: source.ident.span },\n-                                id: Some(self.r.next_node_id()),\n-                                has_generic_args: false,\n-                            });\n+                            module_path.push(Segment::from_ident_and_id(\n+                                Ident { name: kw::PathRoot, span: source.ident.span },\n+                                self.r.next_node_id(),\n+                            ));\n                             source.ident.name = crate_name;\n                         }\n                         if rename.is_none() {"}, {"sha": "1e8cca6122c4c58724bad81648e96417624a6073", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -133,8 +133,10 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     }\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n-        if let FnKind::Fn(_, _, sig, _, body) = fn_kind {\n+        if let FnKind::Fn(_, _, sig, _, generics, body) = fn_kind {\n             if let Async::Yes { closure_id, return_impl_trait_id, .. } = sig.header.asyncness {\n+                self.visit_generics(generics);\n+\n                 let return_impl_trait_id =\n                     self.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n "}, {"sha": "84fe0ec83d26c3c075dc332a7b7982f03d8e655a", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1402,7 +1402,7 @@ impl<'a> Resolver<'a> {\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n-        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n+        for (i, &Segment { ident, id, .. }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n                 if finalize.is_some() {"}, {"sha": "9bc5d63ca179e0b580d1645dd5db690dcd7940e8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 893, "deletions": 321, "changes": 1214, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -21,10 +21,11 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n@@ -188,6 +189,68 @@ impl<'a, R> Rib<'a, R> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum LifetimeRibKind {\n+    /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n+    Item,\n+\n+    /// This rib declares generic parameters.\n+    Generics { span: Span, kind: LifetimeBinderKind },\n+\n+    /// For **Modern** cases, create a new anonymous region parameter\n+    /// and reference that.\n+    ///\n+    /// For **Dyn Bound** cases, pass responsibility to\n+    /// `resolve_lifetime` code.\n+    ///\n+    /// For **Deprecated** cases, report an error.\n+    AnonymousCreateParameter,\n+\n+    /// Give a hard error when either `&` or `'_` is written. Used to\n+    /// rule out things like `where T: Foo<'_>`. Does not imply an\n+    /// error on default object bounds (e.g., `Box<dyn Foo>`).\n+    AnonymousReportError,\n+\n+    /// Pass responsibility to `resolve_lifetime` code for all cases.\n+    AnonymousPassThrough,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum LifetimeBinderKind {\n+    BareFnType,\n+    PolyTrait,\n+    WhereBound,\n+    Item,\n+    Function,\n+    ImplBlock,\n+}\n+\n+impl LifetimeBinderKind {\n+    fn descr(self) -> &'static str {\n+        use LifetimeBinderKind::*;\n+        match self {\n+            BareFnType => \"type\",\n+            PolyTrait => \"bound\",\n+            WhereBound => \"bound\",\n+            Item => \"item\",\n+            ImplBlock => \"impl block\",\n+            Function => \"function\",\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct LifetimeRib {\n+    kind: LifetimeRibKind,\n+    bindings: IdentMap<()>,\n+}\n+\n+impl LifetimeRib {\n+    fn new(kind: LifetimeRibKind) -> LifetimeRib {\n+        LifetimeRib { bindings: Default::default(), kind }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n crate enum AliasPossibility {\n     No,\n@@ -422,6 +485,9 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a, NodeId>>,\n \n+    /// The current set of local scopes for lifetimes.\n+    lifetime_ribs: Vec<LifetimeRib>,\n+\n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n@@ -446,7 +512,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         let prev = replace(&mut self.diagnostic_metadata.current_item, Some(item));\n         // Always report errors in items we just entered.\n         let old_ignore = replace(&mut self.in_func_body, false);\n-        self.resolve_item(item);\n+        self.with_lifetime_rib(LifetimeRibKind::Item, |this| this.resolve_item(item));\n         self.in_func_body = old_ignore;\n         self.diagnostic_metadata.current_item = prev;\n     }\n@@ -481,6 +547,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         let prev = self.diagnostic_metadata.current_trait_object;\n         let prev_ty = self.diagnostic_metadata.current_type_path;\n         match ty.kind {\n+            TyKind::Rptr(None, _) => {\n+                // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n+                // NodeId `ty.id`.\n+                let span = self.r.session.source_map().next_point(ty.span.shrink_to_lo());\n+                self.resolve_elided_lifetime(ty.id, span);\n+            }\n             TyKind::Path(ref qself, ref path) => {\n                 self.diagnostic_metadata.current_type_path = Some(ty);\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n@@ -500,48 +572,102 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             TyKind::TraitObject(ref bounds, ..) => {\n                 self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n             }\n+            TyKind::BareFn(ref bare_fn) => {\n+                let span = if bare_fn.generic_params.is_empty() {\n+                    ty.span.shrink_to_lo()\n+                } else {\n+                    ty.span\n+                };\n+                self.with_generic_param_rib(\n+                    &bare_fn.generic_params,\n+                    NormalRibKind,\n+                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::BareFnType, span },\n+                    |this| {\n+                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                            this.visit_generic_param_vec(&bare_fn.generic_params, false);\n+                            visit::walk_fn_decl(this, &bare_fn.decl);\n+                        });\n+                    },\n+                );\n+                self.diagnostic_metadata.current_trait_object = prev;\n+                return;\n+            }\n             _ => (),\n         }\n         visit::walk_ty(self, ty);\n         self.diagnostic_metadata.current_trait_object = prev;\n         self.diagnostic_metadata.current_type_path = prev_ty;\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n-        self.smart_resolve_path(\n-            tref.trait_ref.ref_id,\n-            None,\n-            &tref.trait_ref.path,\n-            PathSource::Trait(AliasPossibility::Maybe),\n+    fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, _: &'ast TraitBoundModifier) {\n+        let span =\n+            if tref.bound_generic_params.is_empty() { tref.span.shrink_to_lo() } else { tref.span };\n+        self.with_generic_param_rib(\n+            &tref.bound_generic_params,\n+            NormalRibKind,\n+            LifetimeRibKind::Generics { kind: LifetimeBinderKind::PolyTrait, span },\n+            |this| {\n+                this.visit_generic_param_vec(&tref.bound_generic_params, false);\n+                this.smart_resolve_path(\n+                    tref.trait_ref.ref_id,\n+                    None,\n+                    &tref.trait_ref.path,\n+                    PathSource::Trait(AliasPossibility::Maybe),\n+                );\n+                this.visit_trait_ref(&tref.trait_ref);\n+            },\n         );\n-        visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n-            ForeignItemKind::Fn(box Fn { ref generics, .. })\n-            | ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    visit::walk_foreign_item(this, foreign_item);\n+            ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n+                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+                    this.with_generic_param_rib(\n+                        &generics.params,\n+                        ItemRibKind(HasGenericParams::Yes),\n+                        LifetimeRibKind::Generics {\n+                            kind: LifetimeBinderKind::Item,\n+                            span: generics.span,\n+                        },\n+                        |this| visit::walk_foreign_item(this, foreign_item),\n+                    )\n+                });\n+            }\n+            ForeignItemKind::Fn(box Fn { ref generics, .. }) => {\n+                self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+                    this.with_generic_param_rib(\n+                        &generics.params,\n+                        ItemRibKind(HasGenericParams::Yes),\n+                        LifetimeRibKind::Generics {\n+                            kind: LifetimeBinderKind::Function,\n+                            span: generics.span,\n+                        },\n+                        |this| visit::walk_foreign_item(this, foreign_item),\n+                    )\n                 });\n             }\n             ForeignItemKind::Static(..) => {\n-                self.with_item_rib(HasGenericParams::No, |this| {\n+                self.with_item_rib(|this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n             ForeignItemKind::MacCall(..) => {\n-                visit::walk_foreign_item(self, foreign_item);\n+                panic!(\"unexpanded macro in resolve!\")\n             }\n         }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, _: NodeId) {\n         let rib_kind = match fn_kind {\n             // Bail if the function is foreign, and thus cannot validly have\n             // a body, or if there's no body for some other reason.\n-            FnKind::Fn(FnCtxt::Foreign, _, sig, ..) | FnKind::Fn(_, _, sig, .., None) => {\n-                // We don't need to deal with patterns in parameters, because\n-                // they are not possible for foreign or bodiless functions.\n-                self.visit_fn_header(&sig.header);\n-                visit::walk_fn_decl(self, &sig.decl);\n+            FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n+            | FnKind::Fn(_, _, sig, _, generics, None) => {\n+                self.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                    // We don't need to deal with patterns in parameters, because\n+                    // they are not possible for foreign or bodiless functions.\n+                    this.visit_fn_header(&sig.header);\n+                    this.visit_generics(generics);\n+                    visit::walk_fn_decl(this, &sig.decl);\n+                });\n                 return;\n             }\n             FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n@@ -559,109 +685,60 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.with_rib(ValueNS, rib_kind, |this| {\n             // Create a label rib for the function.\n             this.with_label_rib(rib_kind, |this| {\n-                // Add each argument to the rib.\n-                this.resolve_params(&declaration.inputs);\n+                let async_node_id = fn_kind.header().and_then(|h| h.asyncness.opt_return_id());\n \n-                visit::walk_fn_ret_ty(this, &declaration.output);\n+                if let FnKind::Fn(_, _, _, _, generics, _) = fn_kind {\n+                    this.visit_generics(generics);\n+                }\n+\n+                if async_node_id.is_some() {\n+                    // In `async fn`, argument-position elided lifetimes\n+                    // must be transformed into fresh generic parameters so that\n+                    // they can be applied to the opaque `impl Trait` return type.\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n+                        // Add each argument to the rib.\n+                        this.resolve_params(&declaration.inputs)\n+                    });\n+\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        visit::walk_fn_ret_ty(this, &declaration.output)\n+                    });\n+                } else {\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        // Add each argument to the rib.\n+                        this.resolve_params(&declaration.inputs);\n+\n+                        visit::walk_fn_ret_ty(this, &declaration.output);\n+                    });\n+                };\n \n                 // Ignore errors in function bodies if this is rustdoc\n                 // Be sure not to set this until the function signature has been resolved.\n                 let previous_state = replace(&mut this.in_func_body, true);\n                 // Resolve the function body, potentially inside the body of an async closure\n-                match fn_kind {\n-                    FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n-                    FnKind::Closure(_, body) => this.visit_expr(body),\n-                };\n+                this.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough,\n+                    |this| match fn_kind {\n+                        FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n+                        FnKind::Closure(_, body) => this.visit_expr(body),\n+                    },\n+                );\n \n                 debug!(\"(resolving function) leaving function\");\n                 this.in_func_body = previous_state;\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n     }\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        self.resolve_lifetime(lifetime)\n+    }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n-        // For type parameter defaults, we have to ban access\n-        // to following type parameters, as the InternalSubsts can only\n-        // provide previous type parameters as they're built. We\n-        // put all the parameters on the ban list and then remove\n-        // them one by one as they are processed and become available.\n-        let mut forward_ty_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n-        let mut forward_const_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                GenericParamKind::Type { .. } => {\n-                    forward_ty_ban_rib\n-                        .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    forward_const_ban_rib\n-                        .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n-                }\n-                GenericParamKind::Lifetime => {}\n-            }\n-        }\n-\n-        // rust-lang/rust#61631: The type `Self` is essentially\n-        // another type parameter. For ADTs, we consider it\n-        // well-defined only after all of the ADT type parameters have\n-        // been provided. Therefore, we do not allow use of `Self`\n-        // anywhere in ADT type parameter defaults.\n-        //\n-        // (We however cannot ban `Self` for defaults on *all* generic\n-        // lists; e.g. trait generics can usefully refer to `Self`,\n-        // such as in the case of `trait Add<Rhs = Self>`.)\n-        if self.diagnostic_metadata.current_self_item.is_some() {\n-            // (`Some` if + only if we are in ADT's generics.)\n-            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n-        }\n-\n-        for param in &generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime => self.visit_generic_param(param),\n-                GenericParamKind::Type { ref default } => {\n-                    for bound in &param.bounds {\n-                        self.visit_param_bound(bound);\n-                    }\n-\n-                    if let Some(ref ty) = default {\n-                        self.ribs[TypeNS].push(forward_ty_ban_rib);\n-                        self.ribs[ValueNS].push(forward_const_ban_rib);\n-                        self.visit_ty(ty);\n-                        forward_const_ban_rib = self.ribs[ValueNS].pop().unwrap();\n-                        forward_ty_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                    }\n-\n-                    // Allow all following defaults to refer to this type parameter.\n-                    forward_ty_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n-                }\n-                GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n-                    // Const parameters can't have param bounds.\n-                    assert!(param.bounds.is_empty());\n-\n-                    self.ribs[TypeNS].push(Rib::new(ConstParamTyRibKind));\n-                    self.ribs[ValueNS].push(Rib::new(ConstParamTyRibKind));\n-                    self.visit_ty(ty);\n-                    self.ribs[TypeNS].pop().unwrap();\n-                    self.ribs[ValueNS].pop().unwrap();\n-\n-                    if let Some(ref expr) = default {\n-                        self.ribs[TypeNS].push(forward_ty_ban_rib);\n-                        self.ribs[ValueNS].push(forward_const_ban_rib);\n-                        self.visit_anon_const(expr);\n-                        forward_const_ban_rib = self.ribs[ValueNS].pop().unwrap();\n-                        forward_ty_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                    }\n-\n-                    // Allow all following defaults to refer to this const parameter.\n-                    forward_const_ban_rib\n-                        .bindings\n-                        .remove(&Ident::with_dummy_span(param.ident.name));\n-                }\n-            }\n-        }\n+        self.visit_generic_param_vec(\n+            &generics.params,\n+            self.diagnostic_metadata.current_self_item.is_some(),\n+        );\n         for p in &generics.where_clause.predicates {\n             self.visit_where_predicate(p);\n         }\n@@ -720,11 +797,52 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n \n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n+        if let Some(ref args) = path_segment.args {\n+            match &**args {\n+                GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n+                GenericArgs::Parenthesized(..) => self\n+                    .with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                        visit::walk_generic_args(this, path_span, args)\n+                    }),\n+            }\n+        }\n+    }\n+\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         debug!(\"visit_where_predicate {:?}\", p);\n         let previous_value =\n             replace(&mut self.diagnostic_metadata.current_where_predicate, Some(p));\n-        visit::walk_where_predicate(self, p);\n+        self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                ref bounded_ty,\n+                ref bounds,\n+                ref bound_generic_params,\n+                span: predicate_span,\n+                ..\n+            }) = p\n+            {\n+                let span = if bound_generic_params.is_empty() {\n+                    predicate_span.shrink_to_lo()\n+                } else {\n+                    *predicate_span\n+                };\n+                this.with_generic_param_rib(\n+                    &bound_generic_params,\n+                    NormalRibKind,\n+                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::WhereBound, span },\n+                    |this| {\n+                        this.visit_generic_param_vec(&bound_generic_params, false);\n+                        this.visit_ty(bounded_ty);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound)\n+                        }\n+                    },\n+                );\n+            } else {\n+                visit::walk_where_predicate(this, p);\n+            }\n+        });\n         self.diagnostic_metadata.current_where_predicate = previous_value;\n     }\n \n@@ -762,6 +880,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n             label_ribs: Vec::new(),\n+            lifetime_ribs: Vec::new(),\n             current_trait_ref: None,\n             diagnostic_metadata: DiagnosticMetadata::default(),\n             // errors at module scope should always be reported\n@@ -864,6 +983,319 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    fn visit_generic_param_vec(&mut self, params: &'ast Vec<GenericParam>, add_self_upper: bool) {\n+        // For type parameter defaults, we have to ban access\n+        // to following type parameters, as the InternalSubsts can only\n+        // provide previous type parameters as they're built. We\n+        // put all the parameters on the ban list and then remove\n+        // them one by one as they are processed and become available.\n+        let mut forward_ty_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n+        let mut forward_const_ban_rib = Rib::new(ForwardGenericParamBanRibKind);\n+        for param in params.iter() {\n+            match param.kind {\n+                GenericParamKind::Type { .. } => {\n+                    forward_ty_ban_rib\n+                        .bindings\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                }\n+                GenericParamKind::Const { .. } => {\n+                    forward_const_ban_rib\n+                        .bindings\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                }\n+                GenericParamKind::Lifetime => {}\n+            }\n+        }\n+\n+        // rust-lang/rust#61631: The type `Self` is essentially\n+        // another type parameter. For ADTs, we consider it\n+        // well-defined only after all of the ADT type parameters have\n+        // been provided. Therefore, we do not allow use of `Self`\n+        // anywhere in ADT type parameter defaults.\n+        //\n+        // (We however cannot ban `Self` for defaults on *all* generic\n+        // lists; e.g. trait generics can usefully refer to `Self`,\n+        // such as in the case of `trait Add<Rhs = Self>`.)\n+        if add_self_upper {\n+            // (`Some` if + only if we are in ADT's generics.)\n+            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n+        }\n+\n+        self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+            for param in params {\n+                match param.kind {\n+                    GenericParamKind::Lifetime => {\n+                        for bound in &param.bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                    }\n+                    GenericParamKind::Type { ref default } => {\n+                        for bound in &param.bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+\n+                        if let Some(ref ty) = default {\n+                            this.ribs[TypeNS].push(forward_ty_ban_rib);\n+                            this.ribs[ValueNS].push(forward_const_ban_rib);\n+                            this.visit_ty(ty);\n+                            forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n+                            forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n+                        }\n+\n+                        // Allow all following defaults to refer to this type parameter.\n+                        forward_ty_ban_rib\n+                            .bindings\n+                            .remove(&Ident::with_dummy_span(param.ident.name));\n+                    }\n+                    GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+                        // Const parameters can't have param bounds.\n+                        assert!(param.bounds.is_empty());\n+\n+                        this.ribs[TypeNS].push(Rib::new(ConstParamTyRibKind));\n+                        this.ribs[ValueNS].push(Rib::new(ConstParamTyRibKind));\n+                        this.visit_ty(ty);\n+                        this.ribs[TypeNS].pop().unwrap();\n+                        this.ribs[ValueNS].pop().unwrap();\n+\n+                        if let Some(ref expr) = default {\n+                            this.ribs[TypeNS].push(forward_ty_ban_rib);\n+                            this.ribs[ValueNS].push(forward_const_ban_rib);\n+                            this.visit_anon_const(expr);\n+                            forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n+                            forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n+                        }\n+\n+                        // Allow all following defaults to refer to this const parameter.\n+                        forward_const_ban_rib\n+                            .bindings\n+                            .remove(&Ident::with_dummy_span(param.ident.name));\n+                    }\n+                }\n+            }\n+        })\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self, work))]\n+    fn with_lifetime_rib<T>(\n+        &mut self,\n+        kind: LifetimeRibKind,\n+        work: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        self.lifetime_ribs.push(LifetimeRib::new(kind));\n+        let ret = work(self);\n+        self.lifetime_ribs.pop();\n+        ret\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        let ident = lifetime.ident;\n+\n+        if ident.name == kw::StaticLifetime {\n+            return;\n+        }\n+\n+        if ident.name == kw::UnderscoreLifetime {\n+            return self.resolve_anonymous_lifetime(lifetime, false);\n+        }\n+\n+        let mut indices = (0..self.lifetime_ribs.len()).rev();\n+        for i in &mut indices {\n+            let rib = &self.lifetime_ribs[i];\n+            let normalized_ident = ident.normalize_to_macros_2_0();\n+            if let Some(_) = rib.bindings.get_key_value(&normalized_ident) {\n+                return;\n+            }\n+\n+            if let LifetimeRibKind::Item = rib.kind {\n+                break;\n+            }\n+        }\n+\n+        let mut outer_res = None;\n+        for i in indices {\n+            let rib = &self.lifetime_ribs[i];\n+            let normalized_ident = ident.normalize_to_macros_2_0();\n+            if let Some((&outer, _)) = rib.bindings.get_key_value(&normalized_ident) {\n+                outer_res = Some(outer);\n+                break;\n+            }\n+        }\n+\n+        self.emit_undeclared_lifetime_error(lifetime, outer_res);\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_anonymous_lifetime(&mut self, lifetime: &Lifetime, elided: bool) {\n+        debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n+\n+        for i in (0..self.lifetime_ribs.len()).rev() {\n+            let rib = &mut self.lifetime_ribs[i];\n+            match rib.kind {\n+                LifetimeRibKind::AnonymousReportError => {\n+                    let (msg, note) = if elided {\n+                        (\n+                            \"`&` without an explicit lifetime name cannot be used here\",\n+                            \"explicit lifetime name needed here\",\n+                        )\n+                    } else {\n+                        (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n+                    };\n+                    rustc_errors::struct_span_err!(\n+                        self.r.session,\n+                        lifetime.ident.span,\n+                        E0637,\n+                        \"{}\",\n+                        msg,\n+                    )\n+                    .span_label(lifetime.ident.span, note)\n+                    .emit();\n+\n+                    return;\n+                }\n+                LifetimeRibKind::AnonymousCreateParameter\n+                | LifetimeRibKind::AnonymousPassThrough\n+                | LifetimeRibKind::Item => return,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_elided_lifetime(&mut self, anchor_id: NodeId, span: Span) {\n+        let id = self.r.next_node_id();\n+        let lt = Lifetime { id, ident: Ident::new(kw::UnderscoreLifetime, span) };\n+        self.resolve_anonymous_lifetime(&lt, true);\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_elided_lifetimes_in_path(\n+        &mut self,\n+        path_id: NodeId,\n+        partial_res: PartialRes,\n+        path: &[Segment],\n+        source: PathSource<'_>,\n+        finalize: Finalize,\n+    ) {\n+        let Some(path_span) = finalize.path_span() else {\n+            return;\n+        };\n+        let proj_start = path.len() - partial_res.unresolved_segments();\n+        for (i, segment) in path.iter().enumerate() {\n+            if segment.has_lifetime_args {\n+                continue;\n+            }\n+            let Some(segment_id) = segment.id else {\n+                continue;\n+            };\n+\n+            // Figure out if this is a type/trait segment,\n+            // which may need lifetime elision performed.\n+            let type_def_id = match partial_res.base_res() {\n+                Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                    self.r.parent(def_id).unwrap()\n+                }\n+                Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                    self.r.parent(def_id).unwrap()\n+                }\n+                Res::Def(DefKind::Struct, def_id)\n+                | Res::Def(DefKind::Union, def_id)\n+                | Res::Def(DefKind::Enum, def_id)\n+                | Res::Def(DefKind::TyAlias, def_id)\n+                | Res::Def(DefKind::Trait, def_id)\n+                    if i + 1 == proj_start =>\n+                {\n+                    def_id\n+                }\n+                _ => continue,\n+            };\n+\n+            let expected_lifetimes = self.r.item_generics_num_lifetimes(type_def_id);\n+            if expected_lifetimes == 0 {\n+                continue;\n+            }\n+\n+            let missing = match source {\n+                PathSource::Trait(..) | PathSource::TraitItem(..) | PathSource::Type => true,\n+                PathSource::Expr(..)\n+                | PathSource::Pat\n+                | PathSource::Struct\n+                | PathSource::TupleStruct(..) => false,\n+            };\n+            let mut error = false;\n+            for rib in self.lifetime_ribs.iter().rev() {\n+                match rib.kind {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    LifetimeRibKind::AnonymousCreateParameter => {\n+                        error = true;\n+                        break;\n+                    }\n+                    // `PassThrough` is the normal case.\n+                    // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n+                    // is unsuitable here, as these can occur from missing lifetime parameters in a\n+                    // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n+                    // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n+                    // later, at which point a suitable error will be emitted.\n+                    LifetimeRibKind::AnonymousPassThrough\n+                    | LifetimeRibKind::AnonymousReportError\n+                    | LifetimeRibKind::Item => break,\n+                    _ => {}\n+                }\n+            }\n+\n+            if !missing {\n+                continue;\n+            }\n+\n+            let elided_lifetime_span = if segment.has_generic_args {\n+                // If there are brackets, but not generic arguments, then use the opening bracket\n+                segment.args_span.with_hi(segment.args_span.lo() + BytePos(1))\n+            } else {\n+                // If there are no brackets, use the identifier span.\n+                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n+                // originating from macros, since the segment's span might be from a macro arg.\n+                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n+            };\n+            if error {\n+                let sess = self.r.session;\n+                let mut err = rustc_errors::struct_span_err!(\n+                    sess,\n+                    path_span,\n+                    E0726,\n+                    \"implicit elided lifetime not allowed here\"\n+                );\n+                rustc_errors::add_elided_lifetime_in_path_suggestion(\n+                    sess.source_map(),\n+                    &mut err,\n+                    expected_lifetimes,\n+                    path_span,\n+                    !segment.has_generic_args,\n+                    elided_lifetime_span,\n+                );\n+                err.note(\"assuming a `'static` lifetime...\");\n+                err.emit();\n+            } else {\n+                self.r.lint_buffer.buffer_lint_with_diagnostic(\n+                    lint::builtin::ELIDED_LIFETIMES_IN_PATHS,\n+                    segment_id,\n+                    elided_lifetime_span,\n+                    \"hidden lifetime parameters in types are deprecated\",\n+                    lint::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                        expected_lifetimes,\n+                        path_span,\n+                        !segment.has_generic_args,\n+                        elided_lifetime_span,\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+\n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n     /// label and reports an error if the label is not found or is unreachable.\n     fn resolve_label(&self, mut label: Ident) -> Option<NodeId> {\n@@ -944,15 +1376,20 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_adt(&mut self, item: &'ast Item, generics: &'ast Generics) {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n-            this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                let item_def_id = this.r.local_def_id(item.id).to_def_id();\n-                this.with_self_rib(\n-                    Res::SelfTy { trait_: None, alias_to: Some((item_def_id, false)) },\n-                    |this| {\n-                        visit::walk_item(this, item);\n-                    },\n-                );\n-            });\n+            this.with_generic_param_rib(\n+                &generics.params,\n+                ItemRibKind(HasGenericParams::Yes),\n+                LifetimeRibKind::Generics { kind: LifetimeBinderKind::Item, span: generics.span },\n+                |this| {\n+                    let item_def_id = this.r.local_def_id(item.id).to_def_id();\n+                    this.with_self_rib(\n+                        Res::SelfTy { trait_: None, alias_to: Some((item_def_id, false)) },\n+                        |this| {\n+                            visit::walk_item(this, item);\n+                        },\n+                    );\n+                },\n+            );\n         });\n     }\n \n@@ -1004,18 +1441,33 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n         match item.kind {\n-            ItemKind::TyAlias(box TyAlias { ref generics, .. })\n-            | ItemKind::Fn(box Fn { ref generics, .. }) => {\n-                self.compute_num_lifetime_params(item.id, generics);\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    visit::walk_item(this, item)\n-                });\n+            ItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_item(this, item),\n+                );\n+            }\n+\n+            ItemKind::Fn(box Fn { ref generics, .. }) => {\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Function,\n+                        span: generics.span,\n+                    },\n+                    |this| visit::walk_item(this, item),\n+                );\n             }\n \n             ItemKind::Enum(_, ref generics)\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics) => {\n-                self.compute_num_lifetime_params(item.id, generics);\n                 self.resolve_adt(item, generics);\n             }\n \n@@ -1026,72 +1478,113 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 items: ref impl_items,\n                 ..\n             }) => {\n-                self.compute_num_lifetime_params(item.id, generics);\n                 self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n             }\n \n             ItemKind::Trait(box Trait { ref generics, ref bounds, ref items, .. }) => {\n-                self.compute_num_lifetime_params(item.id, generics);\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let def = this.r.local_def_id(item.id).to_def_id();\n-                    this.with_self_rib(Res::SelfTy { trait_: Some(def), alias_to: None }, |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-\n-                        let walk_assoc_item = |this: &mut Self, generics, item| {\n-                            this.with_generic_param_rib(generics, AssocItemRibKind, |this| {\n-                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n-                            });\n-                        };\n-\n-                        this.with_trait_items(items, |this| {\n-                            for item in items {\n-                                match &item.kind {\n-                                    AssocItemKind::Const(_, ty, default) => {\n-                                        this.visit_ty(ty);\n-                                        // Only impose the restrictions of `ConstRibKind` for an\n-                                        // actual constant expression in a provided default.\n-                                        if let Some(expr) = default {\n-                                            // We allow arbitrary const expressions inside of associated consts,\n-                                            // even if they are potentially not const evaluatable.\n-                                            //\n-                                            // Type parameters can already be used and as associated consts are\n-                                            // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(\n-                                                IsRepeatExpr::No,\n-                                                true,\n-                                                None,\n-                                                |this| this.visit_expr(expr),\n-                                            );\n-                                        }\n-                                    }\n-                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                        walk_assoc_item(this, generics, item);\n-                                    }\n-                                    AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n-                                        walk_assoc_item(this, generics, item);\n-                                    }\n-                                    AssocItemKind::MacCall(_) => {\n-                                        panic!(\"unexpanded macro in resolve!\")\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| {\n+                        let local_def_id = this.r.local_def_id(item.id).to_def_id();\n+                        this.with_self_rib(\n+                            Res::SelfTy { trait_: Some(local_def_id), alias_to: None },\n+                            |this| {\n+                                this.visit_generics(generics);\n+                                walk_list!(this, visit_param_bound, bounds);\n+\n+                                let walk_assoc_item =\n+                                    |this: &mut Self,\n+                                     generics: &Generics,\n+                                     kind,\n+                                     item: &'ast AssocItem| {\n+                                        this.with_generic_param_rib(\n+                                            &generics.params,\n+                                            AssocItemRibKind,\n+                                            LifetimeRibKind::Generics { span: generics.span, kind },\n+                                            |this| {\n+                                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n+                                            },\n+                                        );\n+                                    };\n+\n+                                this.with_trait_items(items, |this| {\n+                                    for item in items {\n+                                        match &item.kind {\n+                                            AssocItemKind::Const(_, ty, default) => {\n+                                                this.visit_ty(ty);\n+                                                // Only impose the restrictions of `ConstRibKind` for an\n+                                                // actual constant expression in a provided default.\n+                                                if let Some(expr) = default {\n+                                                    // We allow arbitrary const expressions inside of associated consts,\n+                                                    // even if they are potentially not const evaluatable.\n+                                                    //\n+                                                    // Type parameters can already be used and as associated consts are\n+                                                    // not used as part of the type system, this is far less surprising.\n+                                                    this.with_constant_rib(\n+                                                        IsRepeatExpr::No,\n+                                                        true,\n+                                                        None,\n+                                                        |this| this.visit_expr(expr),\n+                                                    );\n+                                                }\n+                                            }\n+                                            AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                                                walk_assoc_item(\n+                                                    this,\n+                                                    generics,\n+                                                    LifetimeBinderKind::Function,\n+                                                    item,\n+                                                );\n+                                            }\n+                                            AssocItemKind::TyAlias(box TyAlias {\n+                                                generics,\n+                                                ..\n+                                            }) => {\n+                                                walk_assoc_item(\n+                                                    this,\n+                                                    generics,\n+                                                    LifetimeBinderKind::Item,\n+                                                    item,\n+                                                );\n+                                            }\n+                                            AssocItemKind::MacCall(_) => {\n+                                                panic!(\"unexpanded macro in resolve!\")\n+                                            }\n+                                        };\n                                     }\n-                                };\n-                            }\n-                        });\n-                    });\n-                });\n+                                });\n+                            },\n+                        );\n+                    },\n+                );\n             }\n \n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.compute_num_lifetime_params(item.id, generics);\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n-                    let def = this.r.local_def_id(item.id).to_def_id();\n-                    this.with_self_rib(Res::SelfTy { trait_: Some(def), alias_to: None }, |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-                    });\n-                });\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    ItemRibKind(HasGenericParams::Yes),\n+                    LifetimeRibKind::Generics {\n+                        kind: LifetimeBinderKind::Item,\n+                        span: generics.span,\n+                    },\n+                    |this| {\n+                        let local_def_id = this.r.local_def_id(item.id).to_def_id();\n+                        this.with_self_rib(\n+                            Res::SelfTy { trait_: Some(local_def_id), alias_to: None },\n+                            |this| {\n+                                this.visit_generics(generics);\n+                                walk_list!(this, visit_param_bound, bounds);\n+                            },\n+                        );\n+                    },\n+                );\n             }\n \n             ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n@@ -1101,7 +1594,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n-                self.with_item_rib(HasGenericParams::No, |this| {\n+                self.with_item_rib(|this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n                         let constant_item_kind = match item.kind {\n@@ -1137,13 +1630,19 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n-    fn with_generic_param_rib<'c, F>(&'c mut self, generics: &'c Generics, kind: RibKind<'a>, f: F)\n-    where\n+    fn with_generic_param_rib<'c, F>(\n+        &'c mut self,\n+        params: &'c Vec<GenericParam>,\n+        kind: RibKind<'a>,\n+        lifetime_kind: LifetimeRibKind,\n+        f: F,\n+    ) where\n         F: FnOnce(&mut Self),\n     {\n         debug!(\"with_generic_param_rib\");\n         let mut function_type_rib = Rib::new(kind);\n         let mut function_value_rib = Rib::new(kind);\n+        let mut function_lifetime_rib = LifetimeRib::new(lifetime_kind);\n         let mut seen_bindings = FxHashMap::default();\n \n         // We also can't shadow bindings from the parent item\n@@ -1160,43 +1659,73 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             add_bindings_for_ns(TypeNS);\n         }\n \n-        for param in &generics.params {\n-            if let GenericParamKind::Lifetime = param.kind {\n-                continue;\n-            }\n-\n+        for param in params {\n             let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n             match seen_bindings.entry(ident) {\n                 Entry::Occupied(entry) => {\n                     let span = *entry.get();\n                     let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n-                    self.report_error(param.ident.span, err);\n+                    if !matches!(param.kind, GenericParamKind::Lifetime) {\n+                        self.report_error(param.ident.span, err);\n+                    }\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(param.ident.span);\n                 }\n             }\n \n+            if param.ident.name == kw::UnderscoreLifetime {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    param.ident.span,\n+                    E0637,\n+                    \"`'_` cannot be used here\"\n+                )\n+                .span_label(param.ident.span, \"`'_` is a reserved lifetime name\")\n+                .emit();\n+                continue;\n+            }\n+\n+            if param.ident.name == kw::StaticLifetime {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    param.ident.span,\n+                    E0262,\n+                    \"invalid lifetime parameter name: `{}`\",\n+                    param.ident,\n+                )\n+                .span_label(param.ident.span, format!(\"'static is a reserved lifetime name\"))\n+                .emit();\n+                continue;\n+            }\n+\n+            let def_id = self.r.local_def_id(param.id);\n+\n             // Plain insert (no renaming).\n             let (rib, def_kind) = match param.kind {\n                 GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n                 GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n-                _ => unreachable!(),\n+                GenericParamKind::Lifetime => {\n+                    function_lifetime_rib.bindings.insert(ident, ());\n+                    continue;\n+                }\n             };\n-            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n+            let res = Res::Def(def_kind, def_id.to_def_id());\n             self.r.record_partial_res(param.id, PartialRes::new(res));\n             rib.bindings.insert(ident, res);\n         }\n \n+        self.lifetime_ribs.push(function_lifetime_rib);\n         self.ribs[ValueNS].push(function_value_rib);\n         self.ribs[TypeNS].push(function_type_rib);\n \n         f(self);\n \n         self.ribs[TypeNS].pop();\n         self.ribs[ValueNS].pop();\n+        self.lifetime_ribs.pop();\n     }\n \n     fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n@@ -1205,9 +1734,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib(&mut self, has_generic_params: HasGenericParams, f: impl FnOnce(&mut Self)) {\n-        let kind = ItemRibKind(has_generic_params);\n-        self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n+    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+        let kind = ItemRibKind(HasGenericParams::No);\n+        self.with_lifetime_rib(LifetimeRibKind::Item, |this| {\n+            this.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n+        })\n     }\n \n     // HACK(min_const_generics,const_evaluatable_unchecked): We\n@@ -1318,128 +1849,137 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n+        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::ImplBlock }, |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n-                // Resolve the trait reference, if necessary.\n-                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.r.local_def_id(item_id);\n-\n-                    // Register the trait definitions from here.\n-                    if let Some(trait_id) = trait_id {\n-                        this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n-                    }\n-\n-                    let item_def_id = item_def_id.to_def_id();\n-                    let res =\n-                        Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n-                    this.with_self_rib(res, |this| {\n-                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n-                            // Resolve type arguments in the trait path.\n-                            visit::walk_trait_ref(this, trait_ref);\n+                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n+                    // Resolve the trait reference, if necessary.\n+                    this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n+                        let item_def_id = this.r.local_def_id(item_id);\n+\n+                        // Register the trait definitions from here.\n+                        if let Some(trait_id) = trait_id {\n+                            this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n                         }\n-                        // Resolve the self type.\n-                        this.visit_ty(self_type);\n-                        // Resolve the generic parameters.\n-                        this.visit_generics(generics);\n-                        // Resolve the items within the impl.\n-                        this.with_current_self_type(self_type, |this| {\n-                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n-                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                for item in impl_items {\n-                                    use crate::ResolutionError::*;\n-                                    match &item.kind {\n-                                        AssocItemKind::Const(_default, _ty, _expr) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::Const\");\n-                                            // If this is a trait impl, ensure the const\n-                                            // exists in trait\n-                                            this.check_trait_item(\n-                                                item.id,\n-                                                item.ident,\n-                                                &item.kind,\n-                                                ValueNS,\n-                                                item.span,\n-                                                |i, s, c| ConstNotMemberOfTrait(i, s, c),\n-                                            );\n-\n-                                            // We allow arbitrary const expressions inside of associated consts,\n-                                            // even if they are potentially not const evaluatable.\n-                                            //\n-                                            // Type parameters can already be used and as associated consts are\n-                                            // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(\n-                                                IsRepeatExpr::No,\n-                                                true,\n-                                                None,\n-                                                |this| {\n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::Fn\");\n-                                            // We also need a new scope for the impl item type parameters.\n-                                            this.with_generic_param_rib(\n-                                                generics,\n-                                                AssocItemRibKind,\n-                                                |this| {\n-                                                    // If this is a trait impl, ensure the method\n-                                                    // exists in trait\n-                                                    this.check_trait_item(\n-                                                        item.id,\n-                                                        item.ident,\n-                                                        &item.kind,\n-                                                        ValueNS,\n-                                                        item.span,\n-                                                        |i, s, c| MethodNotMemberOfTrait(i, s, c),\n-                                                    );\n-\n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::TyAlias(box TyAlias {\n-                                            generics, ..\n-                                        }) => {\n-                                            debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n-                                            // We also need a new scope for the impl item type parameters.\n-                                            this.with_generic_param_rib(\n-                                                generics,\n-                                                AssocItemRibKind,\n-                                                |this| {\n-                                                    // If this is a trait impl, ensure the type\n-                                                    // exists in trait\n-                                                    this.check_trait_item(\n-                                                        item.id,\n-                                                        item.ident,\n-                                                        &item.kind,\n-                                                        TypeNS,\n-                                                        item.span,\n-                                                        |i, s, c| TypeNotMemberOfTrait(i, s, c),\n-                                                    );\n \n-                                                    visit::walk_assoc_item(\n-                                                        this,\n-                                                        item,\n-                                                        AssocCtxt::Impl,\n-                                                    )\n-                                                },\n-                                            );\n-                                        }\n-                                        AssocItemKind::MacCall(_) => {\n-                                            panic!(\"unexpanded macro in resolve!\")\n-                                        }\n-                                    }\n-                                }\n-                            });\n+                        let item_def_id = item_def_id.to_def_id();\n+                        let res =\n+                            Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n+                        this.with_self_rib(res, |this| {\n+                            if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                                // Resolve type arguments in the trait path.\n+                                visit::walk_trait_ref(this, trait_ref);\n+                            }\n+                            // Resolve the self type.\n+                            this.visit_ty(self_type);\n+                            // Resolve the generic parameters.\n+                            this.visit_generics(generics);\n+\n+                            // Resolve the items within the impl.\n+                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough,\n+                                |this| {\n+                                    this.with_current_self_type(self_type, |this| {\n+                                        this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                            debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n+                                            for item in impl_items {\n+                                                use crate::ResolutionError::*;\n+                                                match &item.kind {\n+                                                    AssocItemKind::Const(_default, _ty, _expr) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::Const\");\n+                                                        // If this is a trait impl, ensure the const\n+                                                        // exists in trait\n+                                                        this.check_trait_item(\n+                                                            item.id,\n+                                                            item.ident,\n+                                                            &item.kind,\n+                                                            ValueNS,\n+                                                            item.span,\n+                                                            |i, s, c| ConstNotMemberOfTrait(i, s, c),\n+                                                        );\n+\n+                                                        // We allow arbitrary const expressions inside of associated consts,\n+                                                        // even if they are potentially not const evaluatable.\n+                                                        //\n+                                                        // Type parameters can already be used and as associated consts are\n+                                                        // not used as part of the type system, this is far less surprising.\n+                                                        this.with_constant_rib(\n+                                                            IsRepeatExpr::No,\n+                                                            true,\n+                                                            None,\n+                                                            |this| {\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::Fn\");\n+                                                        // We also need a new scope for the impl item type parameters.\n+                                                        this.with_generic_param_rib(\n+                                                            &generics.params,\n+                                                            AssocItemRibKind,\n+                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Function },\n+                                                            |this| {\n+                                                                // If this is a trait impl, ensure the method\n+                                                                // exists in trait\n+                                                                this.check_trait_item(\n+                                                                    item.id,\n+                                                                    item.ident,\n+                                                                    &item.kind,\n+                                                                    ValueNS,\n+                                                                    item.span,\n+                                                                    |i, s, c| MethodNotMemberOfTrait(i, s, c),\n+                                                                );\n+\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::TyAlias(box TyAlias {\n+                                                        generics, ..\n+                                                    }) => {\n+                                                        debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n+                                                        // We also need a new scope for the impl item type parameters.\n+                                                        this.with_generic_param_rib(\n+                                                            &generics.params,\n+                                                            AssocItemRibKind,\n+                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Item },\n+                                                            |this| {\n+                                                                // If this is a trait impl, ensure the type\n+                                                                // exists in trait\n+                                                                this.check_trait_item(\n+                                                                    item.id,\n+                                                                    item.ident,\n+                                                                    &item.kind,\n+                                                                    TypeNS,\n+                                                                    item.span,\n+                                                                    |i, s, c| TypeNotMemberOfTrait(i, s, c),\n+                                                                );\n+\n+                                                                visit::walk_assoc_item(\n+                                                                    this,\n+                                                                    item,\n+                                                                    AssocCtxt::Impl,\n+                                                                )\n+                                                            },\n+                                                        );\n+                                                    }\n+                                                    AssocItemKind::MacCall(_) => {\n+                                                        panic!(\"unexpanded macro in resolve!\")\n+                                                    }\n+                                                }\n+                                            }\n+                                        });\n+                                    });\n+                                },\n+                            );\n                         });\n                     });\n                 });\n@@ -2117,6 +2657,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             self.r.record_partial_res(id, partial_res);\n         }\n \n+        self.resolve_elided_lifetimes_in_path(id, partial_res, path, source, finalize);\n         partial_res\n     }\n \n@@ -2576,20 +3117,51 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             Some((ident.name, ns)),\n         )\n     }\n+}\n+\n+struct LifetimeCountVisitor<'a, 'b> {\n+    r: &'b mut Resolver<'a>,\n+}\n \n-    fn compute_num_lifetime_params(&mut self, id: NodeId, generics: &Generics) {\n-        let def_id = self.r.local_def_id(id);\n-        let count = generics\n-            .params\n-            .iter()\n-            .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime { .. }))\n-            .count();\n-        self.r.item_generics_num_lifetimes.insert(def_id, count);\n+/// Walks the whole crate in DFS order, visiting each item, counting the declared number of\n+/// lifetime generic parameters.\n+impl<'ast> Visitor<'ast> for LifetimeCountVisitor<'_, '_> {\n+    fn visit_item(&mut self, item: &'ast Item) {\n+        match &item.kind {\n+            ItemKind::TyAlias(box TyAlias { ref generics, .. })\n+            | ItemKind::Fn(box Fn { ref generics, .. })\n+            | ItemKind::Enum(_, ref generics)\n+            | ItemKind::Struct(_, ref generics)\n+            | ItemKind::Union(_, ref generics)\n+            | ItemKind::Impl(box Impl { ref generics, .. })\n+            | ItemKind::Trait(box Trait { ref generics, .. })\n+            | ItemKind::TraitAlias(ref generics, _) => {\n+                let def_id = self.r.local_def_id(item.id);\n+                let count = generics\n+                    .params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime { .. }))\n+                    .count();\n+                self.r.item_generics_num_lifetimes.insert(def_id, count);\n+            }\n+\n+            ItemKind::Mod(..)\n+            | ItemKind::ForeignMod(..)\n+            | ItemKind::Static(..)\n+            | ItemKind::Const(..)\n+            | ItemKind::Use(..)\n+            | ItemKind::ExternCrate(..)\n+            | ItemKind::MacroDef(..)\n+            | ItemKind::GlobalAsm(..)\n+            | ItemKind::MacCall(..) => {}\n+        }\n+        visit::walk_item(self, item)\n     }\n }\n \n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n+        visit::walk_crate(&mut LifetimeCountVisitor { r: self }, krate);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {"}, {"sha": "0bae141ce26c85759c179ef0617b68ddbb4c2e24", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 97, "deletions": 95, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,6 +1,7 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n+use crate::late::{LifetimeBinderKind, LifetimeRibKind};\n use crate::path_names_to_string;\n use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n@@ -1793,83 +1794,118 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             (*ident, within_scope)\n         })\n     }\n-}\n \n-impl<'tcx> LifetimeContext<'_, 'tcx> {\n-    crate fn report_missing_lifetime_specifiers(\n+    crate fn emit_undeclared_lifetime_error(\n         &self,\n-        spans: Vec<Span>,\n-        count: usize,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            self.tcx.sess,\n-            spans,\n-            E0106,\n-            \"missing lifetime specifier{}\",\n-            pluralize!(count)\n-        )\n-    }\n+        lifetime_ref: &ast::Lifetime,\n+        outer_lifetime_ref: Option<Ident>,\n+    ) {\n+        debug_assert_ne!(lifetime_ref.ident.name, kw::UnderscoreLifetime);\n+        let mut err = if let Some(outer) = outer_lifetime_ref {\n+            let mut err = struct_span_err!(\n+                self.r.session,\n+                lifetime_ref.ident.span,\n+                E0401,\n+                \"can't use generic parameters from outer item\",\n+            );\n+            err.span_label(lifetime_ref.ident.span, \"use of generic parameter from outer item\");\n+            err.span_label(outer.span, \"lifetime parameter from outer item\");\n+            err\n+        } else {\n+            let mut err = struct_span_err!(\n+                self.r.session,\n+                lifetime_ref.ident.span,\n+                E0261,\n+                \"use of undeclared lifetime name `{}`\",\n+                lifetime_ref.ident\n+            );\n+            err.span_label(lifetime_ref.ident.span, \"undeclared lifetime\");\n+            err\n+        };\n+        let mut suggest_note = true;\n \n-    crate fn emit_undeclared_lifetime_error(&self, lifetime_ref: &hir::Lifetime) {\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            lifetime_ref.span,\n-            E0261,\n-            \"use of undeclared lifetime name `{}`\",\n-            lifetime_ref\n-        );\n-        err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n-        let mut suggested_spans = vec![];\n-        for missing in &self.missing_named_lifetime_spots {\n-            match missing {\n-                MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) = generics.params.iter().find(|p| {\n-                        !matches!(\n-                            p.kind,\n-                            hir::GenericParamKind::Type { synthetic: true, .. }\n-                                | hir::GenericParamKind::Lifetime {\n-                                    kind: hir::LifetimeParamKind::Elided,\n-                                }\n-                        )\n-                    }) {\n-                        (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n-                    } else {\n-                        (generics.span, format!(\"<{}>\", lifetime_ref))\n-                    };\n-                    if suggested_spans.contains(&span) {\n+        for rib in self.lifetime_ribs.iter().rev() {\n+            match rib.kind {\n+                LifetimeRibKind::Generics { span, kind } => {\n+                    if !span.can_be_used_for_suggestions() && suggest_note {\n+                        suggest_note = false; // Avoid displaying the same help multiple times.\n+                        err.span_label(\n+                            span,\n+                            &format!(\n+                                \"lifetime `{}` is missing in item created through this procedural macro\",\n+                                lifetime_ref.ident,\n+                            ),\n+                        );\n                         continue;\n                     }\n-                    suggested_spans.push(span);\n-                    if span.can_be_used_for_suggestions() {\n+\n+                    let higher_ranked = matches!(\n+                        kind,\n+                        LifetimeBinderKind::BareFnType\n+                            | LifetimeBinderKind::PolyTrait\n+                            | LifetimeBinderKind::WhereBound\n+                    );\n+                    let (span, sugg) = if span.is_empty() {\n+                        let sugg = format!(\n+                            \"{}<{}>{}\",\n+                            if higher_ranked { \"for\" } else { \"\" },\n+                            lifetime_ref.ident,\n+                            if higher_ranked { \" \" } else { \"\" },\n+                        );\n+                        (span, sugg)\n+                    } else {\n+                        let span =\n+                            self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n+                        let sugg = format!(\"{}, \", lifetime_ref.ident);\n+                        (span, sugg)\n+                    };\n+                    if higher_ranked {\n                         err.span_suggestion(\n                             span,\n-                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n+                            &format!(\n+                                \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                                kind.descr(),\n+                                lifetime_ref\n+                            ),\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        err.note_once(\n+                            \"for more information on higher-ranked polymorphism, visit \\\n+                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                        );\n+                    } else {\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref.ident),\n                             sugg,\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                 }\n-                MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                    err.span_suggestion(\n-                        *span,\n-                        &format!(\n-                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                            span_type.descr(),\n-                            lifetime_ref\n-                        ),\n-                        span_type.suggestion(&lifetime_ref.to_string()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.note(\n-                        \"for more information on higher-ranked polymorphism, visit \\\n-                         https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                    );\n-                }\n+                LifetimeRibKind::Item => break,\n                 _ => {}\n             }\n         }\n+\n         err.emit();\n     }\n+}\n+\n+impl<'tcx> LifetimeContext<'_, 'tcx> {\n+    crate fn report_missing_lifetime_specifiers(\n+        &self,\n+        spans: Vec<Span>,\n+        count: usize,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        struct_span_err!(\n+            self.tcx.sess,\n+            spans,\n+            E0106,\n+            \"missing lifetime specifier{}\",\n+            pluralize!(count)\n+        )\n+    }\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     crate fn report_elision_failure(\n@@ -1950,38 +1986,6 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n     }\n \n-    crate fn report_elided_lifetime_in_ty(&self, lifetime_refs: &[&hir::Lifetime]) {\n-        let Some(missing_lifetime) = lifetime_refs.iter().find(|lt| {\n-            lt.name == hir::LifetimeName::Implicit(true)\n-        }) else { return };\n-\n-        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n-        spans.sort();\n-        let mut spans_dedup = spans.clone();\n-        spans_dedup.dedup();\n-        let spans_with_counts: Vec<_> = spans_dedup\n-            .into_iter()\n-            .map(|sp| (sp, spans.iter().filter(|nsp| *nsp == &sp).count()))\n-            .collect();\n-\n-        self.tcx.struct_span_lint_hir(\n-            rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS,\n-            missing_lifetime.hir_id,\n-            spans,\n-            |lint| {\n-                let mut db = lint.build(\"hidden lifetime parameters in types are deprecated\");\n-                self.add_missing_lifetime_specifiers_label(\n-                    &mut db,\n-                    spans_with_counts,\n-                    &FxHashSet::from_iter([kw::UnderscoreLifetime]),\n-                    Vec::new(),\n-                    &[],\n-                );\n-                db.emit();\n-            },\n-        );\n-    }\n-\n     // FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n     // generics. We are disallowing this until we can decide on how we want to handle non-'static\n     // lifetimes in const generics. See issue #74052 for discussion.\n@@ -2416,9 +2420,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         );\n         let is_allowed_lifetime = matches!(\n             lifetime_ref.name,\n-            hir::LifetimeName::Implicit(_)\n-                | hir::LifetimeName::Static\n-                | hir::LifetimeName::Underscore\n+            hir::LifetimeName::Implicit | hir::LifetimeName::Static | hir::LifetimeName::Underscore\n         );\n \n         if !self.tcx.lazy_normalization() && is_anon_const && !is_allowed_lifetime {"}, {"sha": "d5f2e2db1e39b1851754fbbc0fed7d35c36b81fb", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -164,9 +164,6 @@ crate struct LifetimeContext<'a, 'tcx> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n-    is_in_fn_syntax: bool,\n-\n     is_in_const_generic: bool,\n \n     /// Indicates that we only care about the definition of a trait. This should\n@@ -455,7 +452,6 @@ fn do_resolve(\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n         labels_in_fn: vec![],\n@@ -874,8 +870,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n-                let was_in_fn_syntax = self.is_in_fn_syntax;\n-                self.is_in_fn_syntax = true;\n                 let lifetime_span: Option<Span> =\n                     c.generic_params.iter().rev().find_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => Some(param.span),\n@@ -917,7 +911,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n-                self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n@@ -928,7 +921,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 });\n                 match lifetime.name {\n-                    LifetimeName::Implicit(_) => {\n+                    LifetimeName::Implicit => {\n                         // For types like `dyn Foo`, we should\n                         // generate a special form of elided.\n                         span_bug!(ty.span, \"object-lifetime-default expected, not implicit\",);\n@@ -1805,7 +1798,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n             labels_in_fn,\n@@ -2320,7 +2312,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n-            self.emit_undeclared_lifetime_error(lifetime_ref);\n+            self.tcx.sess.delay_span_bug(\n+                lifetime_ref.span,\n+                &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n+            );\n         }\n     }\n \n@@ -2336,10 +2331,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n \n         if generic_args.parenthesized {\n-            let was_in_fn_syntax = self.is_in_fn_syntax;\n-            self.is_in_fn_syntax = true;\n             self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n-            self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n@@ -2963,9 +2955,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n-                Scope::Body { .. } => break Ok(()),\n+                Scope::Body { .. } => return,\n \n-                Scope::Root => break Err(None),\n+                Scope::Root => break None,\n \n                 Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n@@ -2992,15 +2984,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         self.insert_lifetime(lifetime_ref, lifetime);\n                     }\n-                    break Ok(());\n+                    return;\n                 }\n \n                 Scope::Elision { elide: Elide::Exact(l), .. } => {\n                     let lifetime = l.shifted(late_depth);\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n                     }\n-                    break Ok(());\n+                    return;\n                 }\n \n                 Scope::Elision { elide: Elide::Error(ref e), ref s, .. } => {\n@@ -3025,10 +3017,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             _ => break,\n                         }\n                     }\n-                    break Err(Some(&e[..]));\n+                    break Some(&e[..]);\n                 }\n \n-                Scope::Elision { elide: Elide::Forbid, .. } => break Err(None),\n+                Scope::Elision { elide: Elide::Forbid, .. } => break None,\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n@@ -3038,14 +3030,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let error = match error {\n-            Ok(()) => {\n-                self.report_elided_lifetime_in_ty(lifetime_refs);\n-                return;\n-            }\n-            Err(error) => error,\n-        };\n-\n         // If we specifically need the `scope_for_path` map, then we're in the\n         // diagnostic pass and we don't want to emit more errors.\n         if self.map.scope_for_path.is_some() {\n@@ -3130,18 +3114,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n                 if name == kw::UnderscoreLifetime || name == kw::StaticLifetime {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        lifetime_i.span,\n-                        E0262,\n-                        \"invalid lifetime parameter name: `{}`\",\n-                        lifetime_i.name.ident(),\n-                    );\n-                    err.span_label(\n+                    self.tcx.sess.delay_span_bug(\n                         lifetime_i.span,\n-                        format!(\"{} is a reserved lifetime name\", name),\n+                        &format!(\"invalid lifetime parameter name: `{}`\", lifetime_i.name.ident()),\n                     );\n-                    err.emit();\n                 }\n             }\n \n@@ -3190,7 +3166,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 ))\n                                 .emit();\n                         }\n-                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit(_) => {\n+                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n                         hir::LifetimeName::ImplicitObjectLifetimeDefault => {"}, {"sha": "eed54370e23310bcc61b3071b6915ab2bb5f6f68", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -11,6 +11,7 @@\n #![feature(drain_filter)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n@@ -27,7 +28,7 @@ pub use rustc_hir::def::{Namespace, PerNS};\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n-use rustc_ast::{Crate, Expr, ExprKind, LitKind, Path};\n+use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n@@ -282,6 +283,9 @@ pub struct Segment {\n     /// Signals whether this `PathSegment` has generic arguments. Used to avoid providing\n     /// nonsensical suggestions.\n     has_generic_args: bool,\n+    /// Signals whether this `PathSegment` has lifetime arguments.\n+    has_lifetime_args: bool,\n+    args_span: Span,\n }\n \n impl Segment {\n@@ -290,7 +294,23 @@ impl Segment {\n     }\n \n     fn from_ident(ident: Ident) -> Segment {\n-        Segment { ident, id: None, has_generic_args: false }\n+        Segment {\n+            ident,\n+            id: None,\n+            has_generic_args: false,\n+            has_lifetime_args: false,\n+            args_span: DUMMY_SP,\n+        }\n+    }\n+\n+    fn from_ident_and_id(ident: Ident, id: NodeId) -> Segment {\n+        Segment {\n+            ident,\n+            id: Some(id),\n+            has_generic_args: false,\n+            has_lifetime_args: false,\n+            args_span: DUMMY_SP,\n+        }\n     }\n \n     fn names_to_string(segments: &[Segment]) -> String {\n@@ -300,7 +320,28 @@ impl Segment {\n \n impl<'a> From<&'a ast::PathSegment> for Segment {\n     fn from(seg: &'a ast::PathSegment) -> Segment {\n-        Segment { ident: seg.ident, id: Some(seg.id), has_generic_args: seg.args.is_some() }\n+        let has_generic_args = seg.args.is_some();\n+        let (args_span, has_lifetime_args) = if let Some(args) = seg.args.as_deref() {\n+            match args {\n+                GenericArgs::AngleBracketed(args) => {\n+                    let found_lifetimes = args\n+                        .args\n+                        .iter()\n+                        .any(|arg| matches!(arg, AngleBracketedArg::Arg(GenericArg::Lifetime(_))));\n+                    (args.span, found_lifetimes)\n+                }\n+                GenericArgs::Parenthesized(args) => (args.span, true),\n+            }\n+        } else {\n+            (DUMMY_SP, false)\n+        };\n+        Segment {\n+            ident: seg.ident,\n+            id: Some(seg.id),\n+            has_generic_args,\n+            has_lifetime_args,\n+            args_span,\n+        }\n     }\n }\n \n@@ -1358,9 +1399,17 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn next_node_id(&mut self) -> NodeId {\n-        let next =\n-            self.next_node_id.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n-        mem::replace(&mut self.next_node_id, ast::NodeId::from_u32(next))\n+        let start = self.next_node_id;\n+        let next = start.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_u32(next);\n+        start\n+    }\n+\n+    pub fn next_node_ids(&mut self, count: usize) -> std::ops::Range<NodeId> {\n+        let start = self.next_node_id;\n+        let end = start.as_usize().checked_add(count).expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_usize(end);\n+        start..self.next_node_id\n     }\n \n     pub fn lint_buffer(&mut self) -> &mut LintBuffer {"}, {"sha": "5e0c8c299891093d2067028a0bd25e7ad30bab06", "filename": "src/test/ui/async-await/async-fn-path-elision.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,9 +2,13 @@ error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/async-fn-path-elision.rs:5:20\n    |\n LL | async fn error(lt: HasLifetime) {\n-   |                    ^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                    ^^^^^^^^^^^ expected lifetime parameter\n    |\n    = note: assuming a `'static` lifetime...\n+help: indicate the anonymous lifetime\n+   |\n+LL | async fn error(lt: HasLifetime<'_>) {\n+   |                               ++++\n \n error: aborting due to previous error\n "}, {"sha": "1792d8db292c47ee798f144a1973477bcb6c1297", "filename": "src/test/ui/generic-associated-types/gat-in-trait-path-undeclared-lifetime.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path-undeclared-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path-undeclared-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgat-in-trait-path-undeclared-lifetime.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,9 +2,17 @@ error[E0261]: use of undeclared lifetime name `'x`\n   --> $DIR/gat-in-trait-path-undeclared-lifetime.rs:8:35\n    |\n LL |   fn _f(arg : Box<dyn for<'a> X<Y<'x> = &'a [u32]>>) {}\n-   |        -                          ^^ undeclared lifetime\n-   |        |\n-   |        help: consider introducing lifetime `'x` here: `<'x>`\n+   |                                   ^^ undeclared lifetime\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'x` lifetime\n+   |\n+LL |   fn _f(arg : Box<dyn for<'x, 'a> X<Y<'x> = &'a [u32]>>) {}\n+   |                           +++\n+help: consider introducing lifetime `'x` here\n+   |\n+LL |   fn _f<'x>(arg : Box<dyn for<'a> X<Y<'x> = &'a [u32]>>) {}\n+   |        ++++\n \n error[E0582]: binding for associated type `Y` references lifetime `'a`, which does not appear in the trait input types\n   --> $DIR/gat-in-trait-path-undeclared-lifetime.rs:8:33"}, {"sha": "a4bb361900fe166f61a1adbc88d2d8af4f7160cb", "filename": "src/test/ui/generic-associated-types/generic_associated_type_undeclared_lifetimes.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric_associated_type_undeclared_lifetimes.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -4,14 +4,19 @@ error[E0261]: use of undeclared lifetime name `'b`\n LL |         + Deref<Target = Self::Item<'b>>;\n    |                                     ^^ undeclared lifetime\n    |\n-help: consider introducing lifetime `'b` here\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n    |\n-LL | trait Iterable<'b> {\n-   |               ++++\n+LL |         + for<'b> Deref<Target = Self::Item<'b>>;\n+   |           +++++++\n help: consider introducing lifetime `'b` here\n    |\n LL |     type Iter<'b, 'a>: Iterator<Item = Self::Item<'a>>\n    |               +++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | trait Iterable<'b> {\n+   |               ++++\n \n error[E0261]: use of undeclared lifetime name `'undeclared`\n   --> $DIR/generic_associated_type_undeclared_lifetimes.rs:11:41\n@@ -21,12 +26,12 @@ LL |     fn iter<'a>(&'a self) -> Self::Iter<'undeclared>;\n    |\n help: consider introducing lifetime `'undeclared` here\n    |\n-LL | trait Iterable<'undeclared> {\n-   |               +++++++++++++\n-help: consider introducing lifetime `'undeclared` here\n-   |\n LL |     fn iter<'undeclared, 'a>(&'a self) -> Self::Iter<'undeclared>;\n    |             ++++++++++++\n+help: consider introducing lifetime `'undeclared` here\n+   |\n+LL | trait Iterable<'undeclared> {\n+   |               +++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5725b660ab2342505f0e8aead790ab2081be77e4", "filename": "src/test/ui/generic-associated-types/issue-67510.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -4,9 +4,9 @@ trait X {\n     type Y<'a>;\n }\n \n-fn f(x: Box<dyn X<Y<'a>=&'a ()>>) {}\n-  //~^ ERROR: use of undeclared lifetime name `'a`\n-  //~| ERROR: use of undeclared lifetime name `'a`\n-\n+fn f(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+//~^ ERROR: use of undeclared lifetime name `'a`\n+//~| ERROR: use of undeclared lifetime name `'a`\n+//~| ERROR: the trait `X` cannot be made into an object [E0038]\n \n fn main() {}"}, {"sha": "8aeda22bad75ffc1a853a844c88ccc78409a6916", "filename": "src/test/ui/generic-associated-types/issue-67510.stderr", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-67510.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,19 +1,50 @@\n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/issue-67510.rs:7:21\n    |\n-LL | fn f(x: Box<dyn X<Y<'a>=&'a ()>>) {}\n-   |     -               ^^ undeclared lifetime\n-   |     |\n-   |     help: consider introducing lifetime `'a` here: `<'a>`\n+LL | fn f(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+   |                     ^^ undeclared lifetime\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn f(x: Box<dyn for<'a> X<Y<'a> = &'a ()>>) {}\n+   |                 +++++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | fn f<'a>(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+   |     ++++\n \n error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/issue-67510.rs:7:26\n+  --> $DIR/issue-67510.rs:7:28\n+   |\n+LL | fn f(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+   |                            ^^ undeclared lifetime\n+   |\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn f(x: Box<dyn for<'a> X<Y<'a> = &'a ()>>) {}\n+   |                 +++++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | fn f<'a>(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+   |     ++++\n+\n+error[E0038]: the trait `X` cannot be made into an object\n+  --> $DIR/issue-67510.rs:7:13\n+   |\n+LL | fn f(x: Box<dyn X<Y<'a> = &'a ()>>) {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^ `X` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/issue-67510.rs:4:10\n    |\n-LL | fn f(x: Box<dyn X<Y<'a>=&'a ()>>) {}\n-   |     -                    ^^ undeclared lifetime\n-   |     |\n-   |     help: consider introducing lifetime `'a` here: `<'a>`\n+LL | trait X {\n+   |       - this trait cannot be made into an object...\n+LL |     type Y<'a>;\n+   |          ^ ...because it contains the generic associated type `Y`\n+   = help: consider moving `Y` to another trait\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0261`.\n+Some errors have detailed explanations: E0038, E0261.\n+For more information about an error, try `rustc --explain E0038`."}, {"sha": "448d7ec2873955bb67aaf6b7da37d509c59e3b01", "filename": "src/test/ui/generic-associated-types/issue-70304.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -12,13 +12,10 @@ impl Document for DocumentImpl {\n     type Cursor<'a> = DocCursorImpl<'a>;\n \n     fn cursor(&self) -> Self::Cursor<'_> {\n-        DocCursorImpl {\n-            document: &self,\n-        }\n+        DocCursorImpl { document: &self }\n     }\n }\n \n-\n trait DocCursor<'a> {}\n \n struct DocCursorImpl<'a> {\n@@ -35,7 +32,6 @@ where\n     _phantom: std::marker::PhantomData<&'d ()>,\n }\n \n-\n impl<'d, Cursor> Lexer<'d, Cursor>\n where\n     Cursor: DocCursor<'d>,\n@@ -44,15 +40,12 @@ where\n     where\n         Doc: Document<Cursor<'d> = Cursor>,\n     {\n-        Lexer {\n-            cursor: document.cursor(),\n-            _phantom: std::marker::PhantomData,\n-        }\n+        Lexer { cursor: document.cursor(), _phantom: std::marker::PhantomData }\n     }\n }\n \n fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n-                                       //~^ ERROR: missing lifetime specifier\n+    //~^ ERROR: missing lifetime specifier\n     DocumentImpl {}\n }\n "}, {"sha": "c5f59a24057d24747704ea38c570f0d2950ecd87", "filename": "src/test/ui/generic-associated-types/issue-70304.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,5 +1,5 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/issue-70304.rs:54:41\n+  --> $DIR/issue-70304.rs:47:41\n    |\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n    |                                         ^^ expected named lifetime parameter"}, {"sha": "33332e760f5823f3ec4ac018cb8f55426a43f2cb", "filename": "src/test/ui/generics/generic-extern-lifetime.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-extern-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-extern-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fgeneric-extern-lifetime.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,7 +2,9 @@ error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/generic-extern-lifetime.rs:6:26\n    |\n LL |     pub fn life2<'b>(x: &'a i32, y: &'b i32);\n-   |                          ^^ undeclared lifetime\n+   |                  -       ^^ undeclared lifetime\n+   |                  |\n+   |                  help: consider introducing lifetime `'a` here: `'a,`\n \n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/generic-extern-lifetime.rs:8:37\n@@ -13,20 +15,27 @@ LL |     pub fn life4<'b>(x: for<'c> fn(&'a i32));\n    = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n help: consider making the type lifetime-generic with a new `'a` lifetime\n    |\n-LL |     pub fn life4<'b>(x: for<'c, 'a> fn(&'a i32));\n-   |                               ++++\n+LL |     pub fn life4<'b>(x: for<'a, 'c> fn(&'a i32));\n+   |                             +++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL |     pub fn life4<'a, 'b>(x: for<'c> fn(&'a i32));\n+   |                  +++\n \n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/generic-extern-lifetime.rs:11:39\n    |\n LL |     pub fn life7<'b>() -> for<'c> fn(&'a i32);\n    |                                       ^^ undeclared lifetime\n    |\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n help: consider making the type lifetime-generic with a new `'a` lifetime\n    |\n-LL |     pub fn life7<'b>() -> for<'c, 'a> fn(&'a i32);\n-   |                                 ++++\n+LL |     pub fn life7<'b>() -> for<'a, 'c> fn(&'a i32);\n+   |                               +++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL |     pub fn life7<'a, 'b>() -> for<'c> fn(&'a i32);\n+   |                  +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0b7d3f1e851e385785915daa7eee142e45e1bea0", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,9 +2,13 @@ error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/path-elided.rs:7:18\n    |\n LL | impl MyTrait for Foo {\n-   |                  ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                  ^^^ expected lifetime parameter\n    |\n    = note: assuming a `'static` lifetime...\n+help: indicate the anonymous lifetime\n+   |\n+LL | impl MyTrait for Foo<'_> {\n+   |                     ++++\n \n error: aborting due to previous error\n "}, {"sha": "c3e76d9cb5a030d3a5fa557df3ae1d6dfdb061ff", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,9 +1,8 @@\n #![allow(warnings)]\n \n-trait MyTrait<'a> { }\n+trait MyTrait<'a> {}\n \n-impl MyTrait for u32 {\n-    //~^ ERROR implicit elided lifetime not allowed here\n-}\n+impl MyTrait for u32 {}\n+//~^ ERROR implicit elided lifetime not allowed here\n \n fn main() {}"}, {"sha": "412bba6be7167a2af0c5ca8cf1d8c7a9daa8b0fb", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,10 +1,14 @@\n error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/trait-elided.rs:5:6\n    |\n-LL | impl MyTrait for u32 {\n-   |      ^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+LL | impl MyTrait for u32 {}\n+   |      ^^^^^^^ expected lifetime parameter\n    |\n    = note: assuming a `'static` lifetime...\n+help: indicate the anonymous lifetime\n+   |\n+LL | impl MyTrait<'_> for u32 {}\n+   |             ++++\n \n error: aborting due to previous error\n "}, {"sha": "0de170161b514a06b0a3576a2ab9c309be34c7a3", "filename": "src/test/ui/issues/issue-10412.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,16 +1,20 @@\n-trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n-    fn serialize(val : &'self T) -> Vec<u8>; //~ ERROR lifetimes cannot use keyword names\n-    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n+trait Serializable<'self, T> {\n+    //~^ ERROR lifetimes cannot use keyword names\n+    fn serialize(val: &'self T) -> Vec<u8>; //~ ERROR lifetimes cannot use keyword names\n+    fn deserialize(repr: &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n }\n \n-impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+impl<'self> Serializable<str> for &'self str {\n     //~^ ERROR lifetimes cannot use keyword names\n+    //~| ERROR lifetimes cannot use keyword names\n     //~| ERROR implicit elided lifetime not allowed here\n-    //~| ERROR the size for values of type `str` cannot be known at compilation time\n-    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n+    //~| ERROR the size for values of type `str` cannot be known at compilation time [E0277]\n+    fn serialize(val: &'self str) -> Vec<u8> {\n+        //~^ ERROR lifetimes cannot use keyword names\n         vec![1]\n     }\n-    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n+    fn deserialize(repr: &[u8]) -> &'self str {\n+        //~^ ERROR lifetimes cannot use keyword names\n         \"hi\"\n     }\n }"}, {"sha": "46b9fd541adfa59f07df1d46b90611b4cd2594c1", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -5,51 +5,55 @@ LL | trait Serializable<'self, T> {\n    |                    ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:2:25\n+  --> $DIR/issue-10412.rs:3:24\n    |\n-LL |     fn serialize(val : &'self T) -> Vec<u8>;\n-   |                         ^^^^^\n+LL |     fn serialize(val: &'self T) -> Vec<u8>;\n+   |                        ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:3:38\n+  --> $DIR/issue-10412.rs:4:37\n    |\n-LL |     fn deserialize(repr : &[u8]) -> &'self T;\n-   |                                      ^^^^^\n+LL |     fn deserialize(repr: &[u8]) -> &'self T;\n+   |                                     ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:6:6\n+  --> $DIR/issue-10412.rs:7:6\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n    |      ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:6:36\n+  --> $DIR/issue-10412.rs:7:36\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n    |                                    ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:10:25\n+  --> $DIR/issue-10412.rs:12:24\n    |\n-LL |     fn serialize(val : &'self str) -> Vec<u8> {\n-   |                         ^^^^^\n+LL |     fn serialize(val: &'self str) -> Vec<u8> {\n+   |                        ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:13:37\n+  --> $DIR/issue-10412.rs:16:37\n    |\n LL |     fn deserialize(repr: &[u8]) -> &'self str {\n    |                                     ^^^^^\n \n error[E0726]: implicit elided lifetime not allowed here\n-  --> $DIR/issue-10412.rs:6:13\n+  --> $DIR/issue-10412.rs:7:13\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n-   |             ^^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Serializable<'_, str>`\n+   |             ^^^^^^^^^^^^^^^^^ expected lifetime parameter\n    |\n    = note: assuming a `'static` lifetime...\n+help: indicate the anonymous lifetime\n+   |\n+LL | impl<'self> Serializable<'_, str> for &'self str {\n+   |                          +++\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n-  --> $DIR/issue-10412.rs:6:13\n+  --> $DIR/issue-10412.rs:7:13\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n    |             ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time"}, {"sha": "6ccf008c003e4182b2f0adbd14d5084392e5ce40", "filename": "src/test/ui/lifetimes/issue-91763.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flifetimes%2Fissue-91763.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flifetimes%2Fissue-91763.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-91763.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,13 +2,17 @@ error: hidden lifetime parameters in types are deprecated\n   --> $DIR/issue-91763.rs:8:20\n    |\n LL | fn f() -> Ptr<Thing>;\n-   |                    ^ expected named lifetime parameter\n+   |                    ^ expected lifetime parameter\n    |\n note: the lint level is defined here\n   --> $DIR/issue-91763.rs:3:9\n    |\n LL | #![deny(elided_lifetimes_in_paths)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: indicate the anonymous lifetime\n+   |\n+LL | fn f() -> Ptr<Thing><'_>;\n+   |                     ++++\n \n error: aborting due to previous error\n "}, {"sha": "0d6ade41511fdcbd8766581e7b922090d1c75079", "filename": "src/test/ui/lifetimes/undeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -9,6 +9,8 @@ LL |     a: &'b str,\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:3:9\n    |\n+LL | #[derive(Eq, PartialEq)]\n+   |          -- lifetime `'b` is missing in item created through this procedural macro\n LL | struct Test {\n    |            - help: consider introducing lifetime `'b` here: `<'b>`\n LL |     a: &'b str,\n@@ -22,12 +24,12 @@ LL |     fn foo(&'b self) {}\n    |\n help: consider introducing lifetime `'b` here\n    |\n-LL | impl<'b> T for Test {\n-   |     ++++\n-help: consider introducing lifetime `'b` here\n-   |\n LL |     fn foo<'b>(&'b self) {}\n    |           ++++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b> T for Test {\n+   |     ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ac98b5896ca7bfade498e1ebc03b64a7d1154565", "filename": "src/test/ui/lint/force-warn/allowed-by-default-lint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fforce-warn%2Fallowed-by-default-lint.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,13 +2,13 @@ warning: hidden lifetime parameters in types are deprecated\n   --> $DIR/allowed-by-default-lint.rs:9:12\n    |\n LL | fn foo(x: &Foo) {}\n-   |            ^^^ expected named lifetime parameter\n+   |            ^^^ expected lifetime parameter\n    |\n    = note: requested on the command line with `--force-warn elided-lifetimes-in-paths`\n-help: consider using the `'_` lifetime\n+help: indicate the anonymous lifetime\n    |\n LL | fn foo(x: &Foo<'_>) {}\n-   |            ~~~~~~~\n+   |               ++++\n \n warning: 1 warning emitted\n "}, {"sha": "da1c740c4a3448830b1b634edbb7d61e8537235c", "filename": "src/test/ui/lint/reasons.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Freasons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Freasons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -19,9 +19,9 @@ pub struct CheaterDetectionMechanism {}\n impl fmt::Debug for CheaterDetectionMechanism {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         //~^ WARN hidden lifetime parameters in types are deprecated\n-        //~| NOTE expected named lifetime parameter\n+        //~| NOTE expected lifetime parameter\n         //~| NOTE explicit anonymous lifetimes aid\n-        //~| HELP consider using the `'_` lifetime\n+        //~| HELP indicate the anonymous lifetime\n         fmt.debug_struct(\"CheaterDetectionMechanism\").finish()\n     }\n }"}, {"sha": "cd8412153f101475ef168d61d5c47a2755249164", "filename": "src/test/ui/lint/reasons.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,18 +2,20 @@ warning: hidden lifetime parameters in types are deprecated\n   --> $DIR/reasons.rs:20:34\n    |\n LL |     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-   |                                  ^^^^^^^^^ expected named lifetime parameter\n+   |                             -----^^^^^^^^^\n+   |                             |\n+   |                             expected lifetime parameter\n    |\n    = note: explicit anonymous lifetimes aid reasoning about ownership\n note: the lint level is defined here\n   --> $DIR/reasons.rs:4:9\n    |\n LL | #![warn(elided_lifetimes_in_paths,\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: consider using the `'_` lifetime\n+help: indicate the anonymous lifetime\n    |\n LL |     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-   |                                  ~~~~~~~~~~~~~\n+   |                                           ++++\n \n warning: variable `Social_exchange_psychology` should have a snake case name\n   --> $DIR/reasons.rs:30:9"}, {"sha": "ba7231070a0f428697d74e17a9b7bf1eda0a0a3e", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,3 +1,6 @@\n fn main() {\n-    0.clone::<'a>(); //~ ERROR use of undeclared lifetime name `'a`\n+    0.clone::<'a>();\n+    //~^ ERROR use of undeclared lifetime name `'a`\n+    //~| WARN cannot specify lifetime arguments explicitly if late bound\n+    //~| WARN this was previously accepted by the compiler\n }"}, {"sha": "78af19586a1b7751168243c4883e2bdf735310a2", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -6,6 +6,21 @@ LL | fn main() {\n LL |     0.clone::<'a>();\n    |               ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/method-call-lifetime-args-unresolved.rs:2:15\n+   |\n+LL |     0.clone::<'a>();\n+   |               ^^\n+   |\n+  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |              - the late bound lifetime parameter is introduced here\n+   |\n+   = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "da316c6ef5e435c82b61b25b19bfa1ebb9505e08", "filename": "src/test/ui/regions/regions-name-static.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-name-static.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,5 +1,6 @@\n-struct Foo<'static> { //~ ERROR invalid lifetime parameter name: `'static`\n-    x: &'static isize\n+struct Foo<'static> {\n+    //~^ ERROR invalid lifetime parameter name: `'static`\n+    x: &'static isize,\n }\n \n fn main() {}"}, {"sha": "7b6ede19341b4953f141faa58f48252bc3f6d3c2", "filename": "src/test/ui/regions/regions-name-undeclared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -23,14 +23,14 @@ fn bar<'a>(x: &'a isize) {\n     let y: &'a isize = x;\n \n     // &'a is not visible to *items*:\n-    type X = Option<&'a isize>; //~ ERROR undeclared lifetime\n+    type X = Option<&'a isize>; //~ ERROR can't use generic parameters from outer item\n     enum E {\n-        E1(&'a isize) //~ ERROR undeclared lifetime\n+        E1(&'a isize) //~ ERROR can't use generic parameters from outer item\n     }\n     struct S {\n-        f: &'a isize //~ ERROR undeclared lifetime\n+        f: &'a isize //~ ERROR can't use generic parameters from outer item\n     }\n-    fn f(a: &'a isize) { } //~ ERROR undeclared lifetime\n+    fn f(a: &'a isize) { } //~ ERROR can't use generic parameters from outer item\n \n     // &'a CAN be declared on functions and used then:\n     fn g<'a>(a: &'a isize) { } // OK"}, {"sha": "532603de5f783f2b8d4939b2977d9f09be01fff7", "filename": "src/test/ui/regions/regions-name-undeclared.stderr", "status": "modified", "additions": 58, "deletions": 46, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-name-undeclared.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,19 +1,3 @@\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/regions-name-undeclared.rs:28:13\n-   |\n-LL |     enum E {\n-   |           - help: consider introducing lifetime `'a` here: `<'a>`\n-LL |         E1(&'a isize)\n-   |             ^^ undeclared lifetime\n-\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/regions-name-undeclared.rs:31:13\n-   |\n-LL |     struct S {\n-   |             - help: consider introducing lifetime `'a` here: `<'a>`\n-LL |         f: &'a isize\n-   |             ^^ undeclared lifetime\n-\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:16:24\n    |\n@@ -22,12 +6,12 @@ LL |     fn m4(&self, arg: &'b isize) { }\n    |\n help: consider introducing lifetime `'b` here\n    |\n-LL | impl<'b, 'a> Foo<'a> {\n-   |      +++\n-help: consider introducing lifetime `'b` here\n-   |\n LL |     fn m4<'b>(&self, arg: &'b isize) { }\n    |          ++++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b, 'a> Foo<'a> {\n+   |      +++\n \n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:17:12\n@@ -37,12 +21,12 @@ LL |     fn m5(&'b self) { }\n    |\n help: consider introducing lifetime `'b` here\n    |\n-LL | impl<'b, 'a> Foo<'a> {\n-   |      +++\n-help: consider introducing lifetime `'b` here\n-   |\n LL |     fn m5<'b>(&'b self) { }\n    |          ++++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b, 'a> Foo<'a> {\n+   |      +++\n \n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:18:27\n@@ -52,26 +36,54 @@ LL |     fn m6(&self, arg: Foo<'b>) { }\n    |\n help: consider introducing lifetime `'b` here\n    |\n-LL | impl<'b, 'a> Foo<'a> {\n-   |      +++\n-help: consider introducing lifetime `'b` here\n-   |\n LL |     fn m6<'b>(&self, arg: Foo<'b>) { }\n    |          ++++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | impl<'b, 'a> Foo<'a> {\n+   |      +++\n \n-error[E0261]: use of undeclared lifetime name `'a`\n+error[E0401]: can't use generic parameters from outer item\n   --> $DIR/regions-name-undeclared.rs:26:22\n    |\n+LL | fn bar<'a>(x: &'a isize) {\n+   |        -- lifetime parameter from outer item\n+...\n LL |     type X = Option<&'a isize>;\n-   |           -          ^^ undeclared lifetime\n+   |           -          ^^ use of generic parameter from outer item\n    |           |\n    |           help: consider introducing lifetime `'a` here: `<'a>`\n \n-error[E0261]: use of undeclared lifetime name `'a`\n+error[E0401]: can't use generic parameters from outer item\n+  --> $DIR/regions-name-undeclared.rs:28:13\n+   |\n+LL | fn bar<'a>(x: &'a isize) {\n+   |        -- lifetime parameter from outer item\n+...\n+LL |     enum E {\n+   |           - help: consider introducing lifetime `'a` here: `<'a>`\n+LL |         E1(&'a isize)\n+   |             ^^ use of generic parameter from outer item\n+\n+error[E0401]: can't use generic parameters from outer item\n+  --> $DIR/regions-name-undeclared.rs:31:13\n+   |\n+LL | fn bar<'a>(x: &'a isize) {\n+   |        -- lifetime parameter from outer item\n+...\n+LL |     struct S {\n+   |             - help: consider introducing lifetime `'a` here: `<'a>`\n+LL |         f: &'a isize\n+   |             ^^ use of generic parameter from outer item\n+\n+error[E0401]: can't use generic parameters from outer item\n   --> $DIR/regions-name-undeclared.rs:33:14\n    |\n+LL | fn bar<'a>(x: &'a isize) {\n+   |        -- lifetime parameter from outer item\n+...\n LL |     fn f(a: &'a isize) { }\n-   |         -    ^^ undeclared lifetime\n+   |         -    ^^ use of generic parameter from outer item\n    |         |\n    |         help: consider introducing lifetime `'a` here: `<'a>`\n \n@@ -90,30 +102,29 @@ LL | ...                   &'b isize,\n    |                        ^^ undeclared lifetime\n    |\n    = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL |             b: Box<dyn for<'b, 'a> FnOnce(&'a isize,\n+   |                            +++\n help: consider introducing lifetime `'b` here\n    |\n LL | fn fn_types<'b>(a: &'a isize,\n    |            ++++\n-help: consider making the bound lifetime-generic with a new `'b` lifetime\n-   |\n-LL |             b: Box<dyn for<'a, 'b> FnOnce(&'a isize,\n-   |                              ++++\n \n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/regions-name-undeclared.rs:46:36\n    |\n LL | ...                   &'b isize)>,\n    |                        ^^ undeclared lifetime\n    |\n-   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL |             b: Box<dyn for<'b, 'a> FnOnce(&'a isize,\n+   |                            +++\n help: consider introducing lifetime `'b` here\n    |\n LL | fn fn_types<'b>(a: &'a isize,\n    |            ++++\n-help: consider making the bound lifetime-generic with a new `'b` lifetime\n-   |\n-LL |             b: Box<dyn for<'a, 'b> FnOnce(&'a isize,\n-   |                              ++++\n \n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/regions-name-undeclared.rs:47:17\n@@ -132,13 +143,14 @@ LL |     async fn buggy(&self) -> &'a str {\n    |\n help: consider introducing lifetime `'a` here\n    |\n-LL | impl<'a> Bug {\n-   |     ++++\n-help: consider introducing lifetime `'a` here\n-   |\n LL |     async fn buggy<'a>(&self) -> &'a str {\n    |                   ++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | impl<'a> Bug {\n+   |     ++++\n \n error: aborting due to 12 previous errors\n \n-For more information about this error, try `rustc --explain E0261`.\n+Some errors have detailed explanations: E0261, E0401.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "a761ec5916745d5a5df8bcdd450159165eed0abb", "filename": "src/test/ui/suggestions/fn-missing-lifetime-in-item.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-missing-lifetime-in-item.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -5,14 +5,14 @@ LL | struct S1<F: Fn(&i32, &i32) -> &'a i32>(F);\n    |                                 ^^ undeclared lifetime\n    |\n    = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n-help: consider introducing lifetime `'a` here\n-   |\n-LL | struct S1<'a, F: Fn(&i32, &i32) -> &'a i32>(F);\n-   |           +++\n help: consider making the bound lifetime-generic with a new `'a` lifetime\n    |\n LL | struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n    |              +++++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | struct S1<'a, F: Fn(&i32, &i32) -> &'a i32>(F);\n+   |           +++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/fn-missing-lifetime-in-item.rs:2:32"}, {"sha": "0ae629676fec7dfe4525a2fe36ab9403484a6e55", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -0,0 +1,106 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:38:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n+   |\n+LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                            ------ hidden type `[closure@$DIR/missing-lifetimes-in-signature.rs:19:5: 22:6]` captures the anonymous lifetime defined here\n+...\n+LL | /     move || {\n+LL | |\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                                   ++++\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:32:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:26:26\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                          ^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:55:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:49:34\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                  ^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:65:9\n+   |\n+LL | /         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+   | |_________^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:47\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                               ^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:77:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:72:34\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                  ^^^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:77:5\n+   |\n+LL |   fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                    ------ help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ lifetime `'a` required\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:89:5\n+   |\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `G: 'a`...\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0621, E0700.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "647b343fe06947c43727e39ec7b84c87a1ad5e73", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -14,28 +14,31 @@ impl Get<usize> for Foo {\n \n fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n     move || {\n+        //~^ ERROR hidden type for `impl Trait` captures lifetime\n         *dest = g.get();\n     }\n }\n \n // After applying suggestion for `foo`:\n fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n+    //~^ ERROR the parameter type `G` may not live long enough\n     move || {\n         *dest = g.get();\n     }\n }\n \n-\n // After applying suggestion for `bar`:\n-fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ //~ ERROR undeclared lifetime\n+fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR undeclared lifetime name `'a`\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n     move || {\n         *dest = g.get();\n@@ -44,9 +47,11 @@ where\n \n // After applying suggestion for `baz`:\n fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n+    //~^ ERROR the parameter type `G` may not live long enough\n     move || {\n         *dest = g.get();\n     }\n@@ -55,6 +60,8 @@ where\n // Same as above, but show that we pay attention to lifetime names from parent item\n impl<'a> Foo {\n     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+        //~^ ERROR the parameter type `G` may not live long enough\n+        //~| ERROR the parameter type `G` may not live long enough\n         move || {\n             *dest = g.get();\n         }\n@@ -63,8 +70,9 @@ impl<'a> Foo {\n \n // After applying suggestion for `qux`:\n fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+//~^ ERROR explicit lifetime required in the type of `dest`\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n     move || {\n         *dest = g.get();\n@@ -73,19 +81,20 @@ where\n \n // Potential incorrect attempt:\n fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+//~^ ERROR the parameter type `G` may not live long enough\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n+    //~^ ERROR the parameter type `G` may not live long enough\n     move || {\n         *dest = g.get();\n     }\n }\n \n-\n // We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:\n fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n     move || {\n         *dest = g.get();\n@@ -95,7 +104,7 @@ where\n // This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:\n fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a\n where\n-    G: Get<T>\n+    G: Get<T>,\n {\n     move || {\n         *dest = g.get();"}, {"sha": "6d538dfd609a80b47df0c180df5646e31308b387", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 226, "deletions": 3, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,11 +1,234 @@\n error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/missing-lifetimes-in-signature.rs:36:11\n+  --> $DIR/missing-lifetimes-in-signature.rs:38:11\n    |\n LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        -  ^^ undeclared lifetime\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error: aborting due to previous error\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n+   |\n+LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                            ------ hidden type `[closure@$DIR/missing-lifetimes-in-signature.rs:19:5: 22:6]` captures the anonymous lifetime defined here\n+...\n+LL | /     move || {\n+LL | |\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^\n+   |\n+help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                                   ++++\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:26:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:26:26\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                          ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:32:5: 34:6]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:26:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        ~~~~~                                                   ++++\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:30:1\n+   |\n+LL | / {\n+LL | |\n+LL | |     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:26:26\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                          ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:32:5: 34:6]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:30:1\n+   |\n+LL | / {\n+LL | |\n+LL | |     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+LL | | }\n+   | |_^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL ~ fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL |\n+LL | where\n+LL |     G: Get<T>,\n+LL | {\n+LL |\n+ ...\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:49:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:49:34\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                  ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:55:5: 57:6]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:49:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n+   |        +++     ~~~~~~~                                                  ++++\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:53:1\n+   |\n+LL | / {\n+LL | |\n+LL | |     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:49:34\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                  ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:55:5: 57:6]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:53:1\n+   |\n+LL | / {\n+LL | |\n+LL | |     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+LL | | }\n+   | |_^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL ~ fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL |\n+LL | where\n+LL |     G: Get<T>,\n+LL | {\n+LL |\n+ ...\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:47\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                               ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:65:9: 67:10]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL |     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n+   |            +++     ~~~~~~~                                                           ++++\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:77\n+   |\n+LL |       fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |  _____________________________________________________________________________^\n+LL | |\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime defined here...\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:47\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                               ^^^^^^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:65:9: 67:10]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:62:77\n+   |\n+LL |       fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |  _____________________________________________________________________________^\n+LL | |\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL ~     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+LL |\n+LL |\n+LL |         move || {\n+LL |             *dest = g.get();\n+LL |         }\n+ ...\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:72:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                  ------     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required\n+   |                                  |\n+   |                                  help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:83:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |            -                               ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:89:5: 91:6]` will meet its required lifetime bounds\n+   |            |\n+   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:87:1\n+   |\n+LL |   fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |              - help: consider adding an explicit lifetime bound...: `G: 'a`\n+...\n+LL | / {\n+LL | |\n+LL | |     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+LL | | }\n+   | |_^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:89:5: 91:6]` will meet its required lifetime bounds\n+\n+error: aborting due to 11 previous errors\n \n-For more information about this error, try `rustc --explain E0261`.\n+Some errors have detailed explanations: E0261, E0309, E0621, E0700.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "b0de8bf6aa4f267d578e319fff1bf448dac14d9d", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -18,5 +18,7 @@ type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n //~^ ERROR use of undeclared lifetime name `'a`\n \n fn my_fun() -> Return<()> {}\n+//~^ ERROR non-defining opaque type use in defining scope\n+//~| ERROR non-defining opaque type use in defining scope\n \n fn main() {}"}, {"sha": "d038fbbe1b40a191fc35a9da4cccccc9f95293f7", "filename": "src/test/ui/type-alias-impl-trait/issue-69136-inner-lifetime-resolve-error.stderr", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-69136-inner-lifetime-resolve-error.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,10 +2,42 @@ error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:65\n    |\n LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n-   |             -                                                   ^^ undeclared lifetime\n-   |             |\n-   |             help: consider introducing lifetime `'a` here: `'a,`\n+   |                                                                 ^^ undeclared lifetime\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | type Return<A> = impl for<'a> WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+   |                       +++++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | type Return<'a, A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+   |             +++\n+\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:20:27\n+   |\n+LL | fn my_fun() -> Return<()> {}\n+   |                           ^^\n+   |\n+note: used non-generic type `()` for generic parameter\n+  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:13\n+   |\n+LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+   |             ^\n+\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:20:27\n+   |\n+LL | fn my_fun() -> Return<()> {}\n+   |                           ^^\n+   |\n+note: used non-generic type `()` for generic parameter\n+  --> $DIR/issue-69136-inner-lifetime-resolve-error.rs:17:13\n+   |\n+LL | type Return<A> = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\n+   |             ^\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "74dc331b00a5ce797c70091012def3c127f39ea9", "filename": "src/test/ui/underscore-lifetime/in-binder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fin-binder.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -10,22 +10,22 @@ impl<'_> IceCube<'_> {}\n //~^ ERROR `'_` cannot be used here\n \n struct Struct<'_> {\n-//~^ ERROR `'_` cannot be used here\n+    //~^ ERROR `'_` cannot be used here\n     v: Vec<&'static char>\n }\n \n enum Enum<'_> {\n-//~^ ERROR `'_` cannot be used here\n+    //~^ ERROR `'_` cannot be used here\n     Variant\n }\n \n union Union<'_> {\n-//~^ ERROR `'_` cannot be used here\n+    //~^ ERROR `'_` cannot be used here\n     a: u32\n }\n \n trait Trait<'_> {\n-//~^ ERROR `'_` cannot be used here\n+    //~^ ERROR `'_` cannot be used here\n }\n \n fn foo<'_>() {"}, {"sha": "16d198725523e0436817ef0c5144e3a3a3fa1311", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -2,9 +2,13 @@ error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:13:16\n    |\n LL | impl Trait for Ref {}\n-   |                ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |                ^^^ expected lifetime parameter\n    |\n    = note: assuming a `'static` lifetime...\n+help: indicate the anonymous lifetime\n+   |\n+LL | impl Trait for Ref<'_> {}\n+   |                   ++++\n \n error: incompatible lifetime on type\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:21"}, {"sha": "e8df02fbad62f3590c792544a85d29c697414904", "filename": "src/test/ui/where-clauses/where-lifetime-resolution.stderr", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-lifetime-resolution.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,20 +1,41 @@\n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/where-lifetime-resolution.rs:6:38\n    |\n-LL | fn f() where\n-   |     - help: consider introducing lifetime `'a` here: `<'a>`\n-LL |     for<'a> dyn Trait1<'a>: Trait1<'a>, // OK\n LL |     (dyn for<'a> Trait1<'a>): Trait1<'a>,\n    |                                      ^^ undeclared lifetime\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |     (dyn for<'a> Trait1<'a>): for<'a> Trait1<'a>,\n+   |                               +++++++\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL |     for<'a> (dyn for<'a> Trait1<'a>): Trait1<'a>,\n+   |     +++++++\n+help: consider introducing lifetime `'a` here\n+   |\n+LL | fn f<'a>() where\n+   |     ++++\n \n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/where-lifetime-resolution.rs:8:52\n    |\n-LL | fn f() where\n-   |     - help: consider introducing lifetime `'b` here: `<'b>`\n-...\n LL |     for<'a> dyn for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n    |                                                    ^^ undeclared lifetime\n+   |\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL |     for<'a> dyn for<'b> Trait2<'a, 'b>: for<'b> Trait2<'a, 'b>,\n+   |                                         +++++++\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL |     for<'b, 'a> dyn for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n+   |         +++\n+help: consider introducing lifetime `'b` here\n+   |\n+LL | fn f<'b>() where\n+   |     ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0d2cb77855be1198a45f9ee31bb930a56312e151", "filename": "src/tools/clippy/tests/ui/unused_unit.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_unit.stderr?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -1,8 +1,8 @@\n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:28\n+  --> $DIR/unused_unit.rs:19:58\n    |\n LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                            ^^^^^^ help: remove the `-> ()`\n+   |                                                          ^^^^^^ help: remove the `-> ()`\n    |\n note: the lint level is defined here\n   --> $DIR/unused_unit.rs:12:9\n@@ -11,16 +11,16 @@ LL | #![deny(clippy::unused_unit)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:20:18\n+  --> $DIR/unused_unit.rs:19:28\n    |\n-LL |     where G: Fn() -> () {\n-   |                  ^^^^^^ help: remove the `-> ()`\n+LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n+   |                            ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n-  --> $DIR/unused_unit.rs:19:58\n+  --> $DIR/unused_unit.rs:20:18\n    |\n-LL |     pub fn get_unit<F: Fn() -> (), G>(&self, f: F, _g: G) -> ()\n-   |                                                          ^^^^^^ help: remove the `-> ()`\n+LL |     where G: Fn() -> () {\n+   |                  ^^^^^^ help: remove the `-> ()`\n \n error: unneeded unit return type\n   --> $DIR/unused_unit.rs:21:26"}, {"sha": "ad2502b041840ca04036fe025f2b299532f6292c", "filename": "src/tools/rustfmt/src/items.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -204,12 +204,11 @@ impl<'a> FnSig<'a> {\n \n     pub(crate) fn from_fn_kind(\n         fn_kind: &'a visit::FnKind<'_>,\n-        generics: &'a ast::Generics,\n         decl: &'a ast::FnDecl,\n         defaultness: ast::Defaultness,\n     ) -> FnSig<'a> {\n         match *fn_kind {\n-            visit::FnKind::Fn(fn_ctxt, _, fn_sig, vis, _) => match fn_ctxt {\n+            visit::FnKind::Fn(fn_ctxt, _, fn_sig, vis, generics, _) => match fn_ctxt {\n                 visit::FnCtxt::Assoc(..) => {\n                     let mut fn_sig = FnSig::from_method_sig(fn_sig, generics, vis);\n                     fn_sig.defaultness = defaultness;\n@@ -3180,8 +3179,14 @@ impl Rewrite for ast::ForeignItem {\n                     let inner_attrs = inner_attributes(&self.attrs);\n                     let fn_ctxt = visit::FnCtxt::Foreign;\n                     visitor.visit_fn(\n-                        visit::FnKind::Fn(fn_ctxt, self.ident, sig, &self.vis, Some(body)),\n-                        generics,\n+                        visit::FnKind::Fn(\n+                            fn_ctxt,\n+                            self.ident,\n+                            sig,\n+                            &self.vis,\n+                            generics,\n+                            Some(body),\n+                        ),\n                         &sig.decl,\n                         self.span,\n                         defaultness,"}, {"sha": "1621eb406b10f35514e24ae78cdc466fbd92d662", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec2c136b35bd4660cba778346f8df7daf2ab173/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=1ec2c136b35bd4660cba778346f8df7daf2ab173", "patch": "@@ -382,7 +382,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn visit_fn(\n         &mut self,\n         fk: visit::FnKind<'_>,\n-        generics: &ast::Generics,\n         fd: &ast::FnDecl,\n         s: Span,\n         defaultness: ast::Defaultness,\n@@ -391,12 +390,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         let indent = self.block_indent;\n         let block;\n         let rewrite = match fk {\n-            visit::FnKind::Fn(_, ident, _, _, Some(ref b)) => {\n+            visit::FnKind::Fn(_, ident, _, _, _, Some(ref b)) => {\n                 block = b;\n                 self.rewrite_fn_before_block(\n                     indent,\n                     ident,\n-                    &FnSig::from_fn_kind(&fk, generics, fd, defaultness),\n+                    &FnSig::from_fn_kind(&fk, fd, defaultness),\n                     mk_sp(s.lo(), b.span.lo()),\n                 )\n             }\n@@ -552,8 +551,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                             _ => visit::FnCtxt::Foreign,\n                         };\n                         self.visit_fn(\n-                            visit::FnKind::Fn(fn_ctxt, item.ident, sig, &item.vis, Some(body)),\n-                            generics,\n+                            visit::FnKind::Fn(\n+                                fn_ctxt,\n+                                item.ident,\n+                                sig,\n+                                &item.vis,\n+                                generics,\n+                                Some(body),\n+                            ),\n                             &sig.decl,\n                             item.span,\n                             defaultness,\n@@ -642,8 +647,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     let inner_attrs = inner_attributes(&ai.attrs);\n                     let fn_ctxt = visit::FnCtxt::Assoc(assoc_ctxt);\n                     self.visit_fn(\n-                        visit::FnKind::Fn(fn_ctxt, ai.ident, sig, &ai.vis, Some(body)),\n-                        generics,\n+                        visit::FnKind::Fn(fn_ctxt, ai.ident, sig, &ai.vis, generics, Some(body)),\n                         &sig.decl,\n                         ai.span,\n                         defaultness,"}]}