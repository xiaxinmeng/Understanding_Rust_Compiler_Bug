{"sha": "eb50e75729bce449272ffb3bfbca2f7234f2ae13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNTBlNzU3MjliY2U0NDkyNzJmZmIzYmZiY2EyZjcyMzRmMmFlMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T15:07:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T15:07:59Z"}, "message": "Auto merge of #54599 - nikomatsakis:issue-54593-impl-Trait, r=eddyb\n\nuse closure def-id in returns, but base def-id in locals\n\nThe refactorings to  handle `let x: impl Trait`  wound up breaking `impl Trait` in closure return types. I think there are some deeper problems with the code in question, but this a least should make @eddyb's example work.\n\nFixes #54593\n\nr? @eddyb", "tree": {"sha": "e77070558ed0b335adc2d9f60776fc9dcc212b0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e77070558ed0b335adc2d9f60776fc9dcc212b0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb50e75729bce449272ffb3bfbca2f7234f2ae13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb50e75729bce449272ffb3bfbca2f7234f2ae13", "html_url": "https://github.com/rust-lang/rust/commit/eb50e75729bce449272ffb3bfbca2f7234f2ae13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb50e75729bce449272ffb3bfbca2f7234f2ae13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9653f790333d1270f36f1614e85d8a7b54193e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/9653f790333d1270f36f1614e85d8a7b54193e75", "html_url": "https://github.com/rust-lang/rust/commit/9653f790333d1270f36f1614e85d8a7b54193e75"}, {"sha": "bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "html_url": "https://github.com/rust-lang/rust/commit/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9"}], "stats": {"total": 42, "additions": 37, "deletions": 5}, "files": [{"sha": "942f19965bf375d75402e94541a29d57f3edc521", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=eb50e75729bce449272ffb3bfbca2f7234f2ae13", "patch": "@@ -70,6 +70,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n+            self.mir_def_id,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {"}, {"sha": "ef4cc3452b1ef9e1222f463e1cc019c085a82243", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=eb50e75729bce449272ffb3bfbca2f7234f2ae13", "patch": "@@ -901,6 +901,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    /// Try to relate `sub <: sup`; if this fails, instantiate opaque\n+    /// variables in `sub` with their inferred definitions and try\n+    /// again. This is used for opaque types in places (e.g., `let x:\n+    /// impl Foo = ..`).\n     fn sub_types_or_anon(\n         &mut self,\n         sub: Ty<'tcx>,\n@@ -910,7 +914,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) -> Fallible<()> {\n         if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n             if let TyKind::Opaque(..) = sup.sty {\n-                return self.eq_opaque_type_and_type(sub, sup, locations, category);\n+                // When you have `let x: impl Foo = ...` in a closure,\n+                // the resulting inferend values are stored with the\n+                // def-id of the base function.\n+                let parent_def_id = self.tcx().closure_base_def_id(self.mir_def_id);\n+                return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n             }\n@@ -958,13 +966,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n         anon_ty: Ty<'tcx>,\n+        anon_owner_def_id: DefId,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n+        debug!(\n+            \"eq_opaque_type_and_type( \\\n+             revealed_ty={:?}, \\\n+             anon_ty={:?})\",\n+            revealed_ty, anon_ty\n+        );\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n-        let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n             category,\n@@ -975,7 +990,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     let dummy_body_id = ObligationCause::dummy().body_id;\n                     let (output_ty, opaque_type_map) =\n                         obligations.add(infcx.instantiate_opaque_types(\n-                            parent_def_id,\n+                            anon_owner_def_id,\n                             dummy_body_id,\n                             param_env,\n                             &anon_ty,\n@@ -996,8 +1011,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n-                            opaque_decl.concrete_ty, opaque_defn_ty\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty,\n+                            infcx.resolve_type_vars_if_possible(&opaque_decl.concrete_ty),\n+                            opaque_defn_ty\n                         );\n                         obligations.add(infcx\n                             .at(&ObligationCause::dummy(), param_env)"}, {"sha": "cb5f78bd6fc0f3c620795d8f6bbfdc4ec22671ef", "filename": "src/test/ui/impl-trait/closure-calling-parent-fn.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb50e75729bce449272ffb3bfbca2f7234f2ae13/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs?ref=eb50e75729bce449272ffb3bfbca2f7234f2ae13", "patch": "@@ -0,0 +1,14 @@\n+#![feature(nll)]\n+\n+// Regression test for #54593: the MIR type checker was going wrong\n+// when a closure returns the `impl Copy` from its parent fn. It was\n+// (incorrectly) replacing the `impl Copy` in its return type with the\n+// hidden type (`()`) but that type resulted from a recursive call to\n+// `foo` and hence is treated opaquely within the closure body.  This\n+// resulted in a failed subtype relationship.\n+//\n+// run-pass\n+\n+fn foo() -> impl Copy { || foo(); }\n+fn bar() -> impl Copy { || bar(); }\n+fn main() { }"}]}