{"sha": "cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjFkZjc0OWU4NDhjMmQwZTBhODdmYTYxNDBhYTdjNzQyMjBiODA=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-02-02T06:04:55Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-02-02T06:04:55Z"}, "message": "Enable more fs tests on Windows", "tree": {"sha": "68d9ad401a38faf0880a17dd2201a6effc1608f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68d9ad401a38faf0880a17dd2201a6effc1608f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "html_url": "https://github.com/rust-lang/rust/commit/cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b16fbe79ac29fc5ce604c89736352ca2765c7d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/b16fbe79ac29fc5ce604c89736352ca2765c7d78", "html_url": "https://github.com/rust-lang/rust/commit/b16fbe79ac29fc5ce604c89736352ca2765c7d78"}], "stats": {"total": 314, "additions": 143, "deletions": 171}, "files": [{"sha": "63980f39c48984dfa7955413431d628b3f71ac5b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 72, "deletions": 57, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "patch": "@@ -1253,20 +1253,7 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n-    _remove_dir_all(path.as_ref())\n-}\n-\n-fn _remove_dir_all(path: &Path) -> io::Result<()> {\n-    for child in try!(read_dir(path)) {\n-        let child = try!(child).path();\n-        let stat = try!(symlink_metadata(&*child));\n-        if stat.is_dir() {\n-            try!(remove_dir_all(&*child));\n-        } else {\n-            try!(remove_file(&*child));\n-        }\n-    }\n-    remove_dir(path)\n+    fs_imp::remove_dir_all(path.as_ref())\n }\n \n /// Returns an iterator over the entries within a directory.\n@@ -1477,19 +1464,25 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n \n #[cfg(test)]\n mod tests {\n-    #![allow(deprecated)] //rand\n-\n     use prelude::v1::*;\n     use io::prelude::*;\n \n     use env;\n     use fs::{self, File, OpenOptions};\n     use io::{ErrorKind, SeekFrom};\n-    use path::PathBuf;\n-    use path::Path as Path2;\n+    use path::{Path, PathBuf};\n     use rand::{self, StdRng, Rng};\n     use str;\n \n+    #[cfg(windows)]\n+    use os::windows::fs::{symlink_dir, symlink_file, symlink_junction};\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_dir;\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_file;\n+    #[cfg(unix)]\n+    use os::unix::fs::symlink as symlink_junction;\n+\n     macro_rules! check { ($e:expr) => (\n         match $e {\n             Ok(t) => t,\n@@ -1513,7 +1506,7 @@ mod tests {\n             p.join(path)\n         }\n \n-        fn path<'a>(&'a self) -> &'a Path2 {\n+        fn path<'a>(&'a self) -> &'a Path {\n             let TempDir(ref p) = *self;\n             p\n         }\n@@ -1536,6 +1529,24 @@ mod tests {\n         TempDir(ret)\n     }\n \n+    // Several test fail on windows if the user does not have permission to create symlinks (the\n+    // `SeCreateSymbolicLinkPrivilege`). Instead of disabling these test on Windows, use this\n+    // function to test whether we have permission, and return otherwise. This way, we still don't\n+    // run these tests most of the time, but at least we do if the user has the right permissions.\n+    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n+        let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n+\n+        match symlink_file(r\"nonexisting_target\", link) {\n+            Ok(_) => true,\n+            Err(ref err) =>\n+                if err.to_string().contains(\"A required privilege is not held by the client.\") {\n+                    false\n+                } else {\n+                    true\n+                }\n+        }\n+    }\n+\n     #[test]\n     fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n@@ -1566,8 +1577,9 @@ mod tests {\n         if cfg!(unix) {\n             error!(result, \"o such file or directory\");\n         }\n-        // error!(result, \"couldn't open path as file\");\n-        // error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n+        if cfg!(windows) {\n+            error!(result, \"The system cannot find the file specified\");\n+        }\n     }\n \n     #[test]\n@@ -1580,8 +1592,9 @@ mod tests {\n         if cfg!(unix) {\n             error!(result, \"o such file or directory\");\n         }\n-        // error!(result, \"couldn't unlink path\");\n-        // error!(result, format!(\"path={}\", filename.display()));\n+        if cfg!(windows) {\n+            error!(result, \"The system cannot find the file specified\");\n+        }\n     }\n \n     #[test]\n@@ -1787,6 +1800,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n@@ -1843,19 +1857,13 @@ mod tests {\n         let result = fs::create_dir_all(&file);\n \n         assert!(result.is_err());\n-        // error!(result, \"couldn't recursively mkdir\");\n-        // error!(result, \"couldn't create directory\");\n-        // error!(result, \"mode=0700\");\n-        // error!(result, format!(\"path={}\", file.display()));\n     }\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        check!(fs::create_dir_all(&Path2::new(\"/\")));\n+        check!(fs::create_dir_all(&Path::new(\"/\")));\n     }\n \n-    // FIXME(#12795) depends on lstat to work on windows\n-    #[cfg(not(windows))]\n     #[test]\n     fn recursive_rmdir() {\n         let tmpdir = tmpdir();\n@@ -1867,7 +1875,7 @@ mod tests {\n         check!(fs::create_dir_all(&dtt));\n         check!(fs::create_dir_all(&d2));\n         check!(check!(File::create(&canary)).write(b\"foo\"));\n-        check!(fs::soft_link(&d2, &dt.join(\"d2\")));\n+        check!(symlink_junction(&d2, &dt.join(\"d2\")));\n         check!(fs::remove_dir_all(&d1));\n \n         assert!(!d1.is_dir());\n@@ -1876,8 +1884,8 @@ mod tests {\n \n     #[test]\n     fn unicode_path_is_dir() {\n-        assert!(Path2::new(\".\").is_dir());\n-        assert!(!Path2::new(\"test/stdtest/fs.rs\").is_dir());\n+        assert!(Path::new(\".\").is_dir());\n+        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n         let tmpdir = tmpdir();\n \n@@ -1895,21 +1903,21 @@ mod tests {\n \n     #[test]\n     fn unicode_path_exists() {\n-        assert!(Path2::new(\".\").exists());\n-        assert!(!Path2::new(\"test/nonexistent-bogus-path\").exists());\n+        assert!(Path::new(\".\").exists());\n+        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(&format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n         check!(fs::create_dir(&unicode));\n         assert!(unicode.exists());\n-        assert!(!Path2::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-        let from = Path2::new(\"test/nonexistent-bogus-path\");\n-        let to = Path2::new(\"test/other-bogus-path\");\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n+        let to = Path::new(\"test/other-bogus-path\");\n \n         match fs::copy(&from, &to) {\n             Ok(..) => panic!(),\n@@ -1923,7 +1931,7 @@ mod tests {\n     #[test]\n     fn copy_src_does_not_exist() {\n         let tmpdir = tmpdir();\n-        let from = Path2::new(\"test/nonexistent-bogus-path\");\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = tmpdir.join(\"out.txt\");\n         check!(check!(File::create(&to)).write(b\"hello\"));\n         assert!(fs::copy(&from, &to).is_err());\n@@ -2014,34 +2022,34 @@ mod tests {\n         assert_eq!(v, b\"carrot\".to_vec());\n     }\n \n-    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n-        check!(fs::soft_link(&input, &out));\n-        // if cfg!(not(windows)) {\n-        //     assert_eq!(check!(lstat(&out)).kind, FileType::Symlink);\n-        //     assert_eq!(check!(out.lstat()).kind, FileType::Symlink);\n-        // }\n+        check!(symlink_file(&input, &out));\n+        assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n         assert_eq!(check!(fs::metadata(&out)).len(),\n                    check!(fs::metadata(&input)).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n     }\n \n-    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     #[test]\n     fn symlink_noexist() {\n+        // Symlinks can point to things that don't exist\n         let tmpdir = tmpdir();\n-        // symlinks can point to things that don't exist\n-        check!(fs::soft_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n-        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))),\n-                   tmpdir.join(\"foo\"));\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n+        // Use a relative path for testing. Symlinks get normalized by Windows, so we may not get\n+        // the same path back for absolute paths\n+        check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n+        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(), \"foo\");\n     }\n \n     #[test]\n@@ -2312,9 +2320,10 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn realpath_works() {\n         let tmpdir = tmpdir();\n+        if !got_symlink_permission(&tmpdir) { return };\n+\n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let file = tmpdir.join(\"test\");\n         let dir = tmpdir.join(\"test2\");\n@@ -2323,8 +2332,8 @@ mod tests {\n \n         File::create(&file).unwrap();\n         fs::create_dir(&dir).unwrap();\n-        fs::soft_link(&file, &link).unwrap();\n-        fs::soft_link(&dir, &linkdir).unwrap();\n+        symlink_file(&file, &link).unwrap();\n+        symlink_dir(&dir, &linkdir).unwrap();\n \n         assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n \n@@ -2336,11 +2345,11 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn realpath_works_tricky() {\n         let tmpdir = tmpdir();\n-        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+        if !got_symlink_permission(&tmpdir) { return };\n \n+        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let a = tmpdir.join(\"a\");\n         let b = a.join(\"b\");\n         let c = b.join(\"c\");\n@@ -2351,8 +2360,14 @@ mod tests {\n         fs::create_dir_all(&b).unwrap();\n         fs::create_dir_all(&d).unwrap();\n         File::create(&f).unwrap();\n-        fs::soft_link(\"../d/e\", &c).unwrap();\n-        fs::soft_link(\"../f\", &e).unwrap();\n+        if cfg!(not(windows)) {\n+            symlink_dir(\"../d/e\", &c).unwrap();\n+            symlink_file(\"../f\", &e).unwrap();\n+        }\n+        if cfg!(windows) {\n+            symlink_dir(r\"..\\d\\e\", &c).unwrap();\n+            symlink_file(r\"..\\f\", &e).unwrap();\n+        }\n \n         assert_eq!(fs::canonicalize(&c).unwrap(), f);\n         assert_eq!(fs::canonicalize(&e).unwrap(), f);"}, {"sha": "f7989d3571015056f2f7e6a0188024995853bd8c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "patch": "@@ -510,6 +510,19 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    for child in try!(readdir(path)) {\n+        let child = try!(child).path();\n+        let stat = try!(lstat(&*child));\n+        if stat.file_type().is_dir() {\n+            try!(remove_dir_all(&*child));\n+        } else {\n+            try!(unlink(&*child));\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();"}, {"sha": "17d9bf329df16fb3df1cd0239dc311533a5ba3b2", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 58, "deletions": 114, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb1df749e848c2d0e0a87fa6140aa7c74220b80/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "patch": "@@ -517,6 +517,25 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    for child in try!(readdir(path)) {\n+        let child = try!(child).path();\n+        let stat = try!(lstat(&*child));\n+        if stat.data.dwFileAttributes & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n+            if stat.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+                // remove junctions and directory symlinks with rmdir\n+                try!(rmdir(&*child));\n+            } else {\n+                try!(remove_dir_all(&*child));\n+            }\n+        } else {\n+            // remove files and file symlinks\n+            try!(unlink(&*child));\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let file = try!(File::open_reparse_point(p, false));\n     file.readlink()\n@@ -635,124 +654,49 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     Ok(size as u64)\n }\n \n-#[test]\n-fn directory_junctions_are_directories() {\n-    use ffi::OsStr;\n-    use env;\n-    use rand::{self, Rng};\n-    use vec::Vec;\n-\n-    macro_rules! t {\n-        ($e:expr) => (match $e {\n-            Ok(e) => e,\n-            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n-        })\n-    }\n+pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    symlink_junction_inner(src.as_ref(), dst.as_ref())\n+}\n \n+// Creating a directory junction on windows involves dealing with reparse\n+// points and the DeviceIoControl function, and this code is a skeleton of\n+// what can be found here:\n+//\n+// http://www.flexhex.com/docs/articles/hard-links.phtml\n+fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n     let d = DirBuilder::new();\n-    let p = env::temp_dir();\n-    let mut r = rand::thread_rng();\n-    let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n-    let foo = ret.join(\"foo\");\n-    let bar = ret.join(\"bar\");\n-    t!(d.mkdir(&ret));\n-    t!(d.mkdir(&foo));\n-    t!(d.mkdir(&bar));\n-\n-    t!(create_junction(&bar, &foo));\n-    let metadata = stat(&bar);\n-    t!(delete_junction(&bar));\n-\n-    t!(rmdir(&foo));\n-    t!(rmdir(&bar));\n-    t!(rmdir(&ret));\n-\n-    let metadata = t!(metadata);\n-    assert!(metadata.file_type().is_dir());\n-\n-    // Creating a directory junction on windows involves dealing with reparse\n-    // points and the DeviceIoControl function, and this code is a skeleton of\n-    // what can be found here:\n-    //\n-    // http://www.flexhex.com/docs/articles/hard-links.phtml\n-    fn create_junction(src: &Path, dst: &Path) -> io::Result<()> {\n-        let f = try!(opendir(src, true));\n-        let h = f.handle().raw();\n+    try!(d.mkdir(&junction));\n+    let f = try!(File::open_reparse_point(junction, true));\n+    let h = f.handle().raw();\n \n-        unsafe {\n-            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let mut db = data.as_mut_ptr()\n-                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            let buf = &mut (*db).ReparseTarget as *mut _;\n-            let mut i = 0;\n-            let v = br\"\\??\\\";\n-            let v = v.iter().map(|x| *x as u16);\n-            for c in v.chain(dst.as_os_str().encode_wide()) {\n-                *buf.offset(i) = c;\n-                i += 1;\n-            }\n-            *buf.offset(i) = 0;\n+    unsafe {\n+        let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut db = data.as_mut_ptr()\n+                        as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+        let buf = &mut (*db).ReparseTarget as *mut _;\n+        let mut i = 0;\n+        // FIXME: this conversion is very hacky\n+        let v = br\"\\??\\\";\n+        let v = v.iter().map(|x| *x as u16);\n+        for c in v.chain(target.as_os_str().encode_wide()) {\n+            *buf.offset(i) = c;\n             i += 1;\n-            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n-            (*db).ReparseDataLength =\n-                    (*db).ReparseTargetLength as c::DWORD + 12;\n-\n-            let mut ret = 0;\n-            cvt(c::DeviceIoControl(h as *mut _,\n-                                   c::FSCTL_SET_REPARSE_POINT,\n-                                   data.as_ptr() as *mut _,\n-                                   (*db).ReparseDataLength + 8,\n-                                   ptr::null_mut(), 0,\n-                                   &mut ret,\n-                                   ptr::null_mut())).map(|_| ())\n-        }\n-    }\n-\n-    fn opendir(p: &Path, write: bool) -> io::Result<File> {\n-        unsafe {\n-            let mut token = ptr::null_mut();\n-            let mut tp: c::TOKEN_PRIVILEGES = mem::zeroed();\n-            try!(cvt(c::OpenProcessToken(c::GetCurrentProcess(),\n-                                         c::TOKEN_ADJUST_PRIVILEGES,\n-                                         &mut token)));\n-            let name: &OsStr = if write {\n-                \"SeRestorePrivilege\".as_ref()\n-            } else {\n-                \"SeBackupPrivilege\".as_ref()\n-            };\n-            let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n-            try!(cvt(c::LookupPrivilegeValueW(ptr::null(),\n-                                              name.as_ptr(),\n-                                              &mut tp.Privileges[0].Luid)));\n-            tp.PrivilegeCount = 1;\n-            tp.Privileges[0].Attributes = c::SE_PRIVILEGE_ENABLED;\n-            let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as c::DWORD;\n-            try!(cvt(c::AdjustTokenPrivileges(token, c::FALSE, &mut tp, size,\n-                                              ptr::null_mut(), ptr::null_mut())));\n-            try!(cvt(c::CloseHandle(token)));\n-\n-            File::open_reparse_point(p, write)\n-        }\n-    }\n-\n-    fn delete_junction(p: &Path) -> io::Result<()> {\n-        unsafe {\n-            let f = try!(opendir(p, true));\n-            let h = f.handle().raw();\n-            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let mut db = data.as_mut_ptr()\n-                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n-            let mut bytes = 0;\n-            cvt(c::DeviceIoControl(h as *mut _,\n-                                   c::FSCTL_DELETE_REPARSE_POINT,\n-                                   data.as_ptr() as *mut _,\n-                                   (*db).ReparseDataLength + 8,\n-                                   ptr::null_mut(), 0,\n-                                   &mut bytes,\n-                                   ptr::null_mut())).map(|_| ())\n         }\n+        *buf.offset(i) = 0;\n+        i += 1;\n+        (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n+        (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;\n+        (*db).ReparseTargetLength = ((i - 1) * 2) as c::WORD;\n+        (*db).ReparseDataLength =\n+                (*db).ReparseTargetLength as c::DWORD + 12;\n+\n+        let mut ret = 0;\n+        cvt(c::DeviceIoControl(h as *mut _,\n+                               c::FSCTL_SET_REPARSE_POINT,\n+                               data.as_ptr() as *mut _,\n+                               (*db).ReparseDataLength + 8,\n+                               ptr::null_mut(), 0,\n+                               &mut ret,\n+                               ptr::null_mut())).map(|_| ())\n     }\n }"}]}