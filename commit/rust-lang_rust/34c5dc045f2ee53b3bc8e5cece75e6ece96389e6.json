{"sha": "34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzVkYzA0NWYyZWU1M2IzYmM4ZTVjZWNlNzVlNmVjZTk2Mzg5ZTY=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-07T15:14:40Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:09Z"}, "message": "Generalized base.rs#call_memcpy and everything that it uses\n\nGeneralized operand.rs#nontemporal_store and fixed tidy issues\n\nGeneralized operand.rs#nontemporal_store's implem even more\nWith a BuilderMethod trait implemented by Builder for LLVM\n\nCleaned builder.rs : no more code duplication, no more ValueTrait\n\nFull traitification of builder.rs", "tree": {"sha": "9c536bb2727ff84a356346f37163b395099603ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c536bb2727ff84a356346f37163b395099603ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "html_url": "https://github.com/rust-lang/rust/commit/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83b2152ce40ed4f1340ed541236609511fc7e89c", "url": "https://api.github.com/repos/rust-lang/rust/commits/83b2152ce40ed4f1340ed541236609511fc7e89c", "html_url": "https://github.com/rust-lang/rust/commit/83b2152ce40ed4f1340ed541236609511fc7e89c"}], "stats": {"total": 1105, "additions": 792, "deletions": 313}, "files": [{"sha": "a31bc877c9f5fa602f3de125c42b275f29a000cd", "filename": ".atom-build.yml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/.atom-build.yml", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/.atom-build.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.atom-build.yml?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -0,0 +1 @@\n+cmd: ./x.py -i check"}, {"sha": "b4aa6495da899e47ea2b0ab638fde265caee1c74", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -19,6 +19,8 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n+use traits::BuilderMethods;\n+\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n@@ -119,7 +121,7 @@ impl LlvmType for Reg {\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(Type::i8(cx), self.size.bytes())\n+                Type::vector::<Value>(Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n@@ -143,7 +145,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array(rest_ll_unit, rest_count);\n+                return Type::array::<Value>(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -167,7 +169,12 @@ impl LlvmType for CastTarget {\n \n pub trait ArgTypeExt<'ll, 'tcx> {\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'tcx, &'ll Value>);\n+    fn store(\n+        &self,\n+        bx: &Builder<'_, 'll, 'tcx>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    );\n     fn store_fn_arg(\n         &self,\n         bx: &Builder<'_, 'll, 'tcx>,\n@@ -187,7 +194,12 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'tcx, &'ll Value>) {\n+    fn store(\n+        &self,\n+        bx: &Builder<'_, 'll, 'tcx>,\n+        val: &'ll Value,\n+        dst: PlaceRef<'tcx, &'ll Value>,\n+    ) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -663,9 +675,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n \n         if self.variadic {\n-            Type::variadic_func(&llargument_tys, llreturn_ty)\n+            Type::variadic_func::<Value>(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func(&llargument_tys, llreturn_ty)\n+            Type::func::<Value>(&llargument_tys, llreturn_ty)\n         }\n     }\n "}, {"sha": "441888583eaee962b659f2d8cc4177a7ebd3d15e", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -16,6 +16,7 @@ use builder::Builder;\n use value::Value;\n \n use rustc::hir;\n+use traits::BuilderMethods;\n \n use mir::place::PlaceRef;\n use mir::operand::OperandValue;"}, {"sha": "8004b7ba88ea825c65f3906091d00c901ca8a159", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -127,7 +127,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n         .filter(|l| !l.is_empty())\n }\n \n-pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_, &'ll Value>, llfn: &'ll Value) {\n     let cpu = llvm_util::target_cpu(cx.tcx.sess);\n     let target_cpu = CString::new(cpu).unwrap();\n     llvm::AddFunctionAttrStringValue("}, {"sha": "e8d5812816ea21ca96e45da9bed5fb23fbede8c4", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -49,6 +49,7 @@ use context::{is_pie_binary, get_reloc_model};\n use common::{C_bytes_in_context, val_ty};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n+use value::Value;\n \n use std::any::Any;\n use std::ffi::{CString, CStr};\n@@ -2574,7 +2575,7 @@ fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::M\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        let i8p_ty = Type::i8p_llcx(llcx);\n+        let i8p_ty = Type::i8p_llcx::<Value>(llcx);\n         let globals = base::iter_globals(llmod)\n             .filter(|&val| {\n                 llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&"}, {"sha": "f268d3dd86fc10a7ed4647be031284466b539376", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -75,6 +75,8 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n \n+use traits::BuilderMethods;\n+\n use std::any::Any;\n use std::cmp;\n use std::ffi::CString;\n@@ -86,7 +88,7 @@ use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use rustc::hir::{self, CodegenFnAttrs};\n \n-use value::Value;\n+use value::{Value, ValueTrait};\n \n use mir::operand::OperandValue;\n \n@@ -387,9 +389,14 @@ pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate(bx: &Builder<'_, 'll, '_>, val: &'ll Value) -> &'ll Value {\n-    if val_ty(val) == Type::i1(bx.cx) {\n-        bx.zext(val, Type::i8(bx.cx))\n+pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll,\n+    Value : ?Sized,\n+    Builder: BuilderMethods<'a, 'll, 'tcx, Value>>(\n+    bx: &Builder,\n+    val: &'ll Value\n+) -> &'ll Value where Value : ValueTrait {\n+    if val_ty(val) == Type::i1(bx.cx()) {\n+        bx.zext(val, Type::i8(bx.cx()))\n     } else {\n         val\n     }\n@@ -417,45 +424,49 @@ pub fn to_immediate_scalar(\n     val\n }\n \n-pub fn call_memcpy(\n-    bx: &Builder<'_, 'll, '_>,\n+pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n+    Value : ?Sized,\n+    Builder: BuilderMethods<'a, 'll, 'tcx, Value>>(\n+    bx: &Builder,\n     dst: &'ll Value,\n     dst_align: Align,\n     src: &'ll Value,\n     src_align: Align,\n     n_bytes: &'ll Value,\n     flags: MemFlags,\n-) {\n+) where Value : ValueTrait {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n         let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n         bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n-    let cx = bx.cx;\n+    let cx = bx.cx();\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n     let volatile = flags.contains(MemFlags::VOLATILE);\n     bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n }\n \n-pub fn memcpy_ty(\n-    bx: &Builder<'_, 'll, 'tcx>,\n+pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll,\n+    Value : ?Sized,\n+    Builder: BuilderMethods<'a, 'll, 'tcx, Value>>(\n+    bx: &Builder,\n     dst: &'ll Value,\n     dst_align: Align,\n     src: &'ll Value,\n     src_align: Align,\n     layout: TyLayout<'tcx>,\n     flags: MemFlags,\n-) {\n+) where Value : ValueTrait {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx, size), flags);\n+    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx(), size), flags);\n }\n \n pub fn call_memset(\n@@ -545,7 +556,8 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n     ) {\n-        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n+        let llfty =\n+            Type::func::<Value>(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,"}, {"sha": "f8074db438830dc8d82e736919399119d13adf59", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 187, "deletions": 172, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n use rustc::session::{config, Session};\n use rustc_data_structures::small_c_str::SmallCStr;\n+use traits::BuilderMethods;\n \n use std::borrow::Cow;\n use std::ops::Range;\n@@ -54,8 +55,12 @@ bitflags! {\n     }\n }\n \n-impl Builder<'a, 'll, 'tcx> {\n-    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n+impl BuilderMethods<'a, 'll, 'tcx, Value> for Builder<'a, 'll, 'tcx> {\n+    fn new_block<'b>(\n+        cx: &'a CodegenCx<'ll, 'tcx>,\n+        llfn: &'ll Value,\n+        name: &'b str\n+    ) -> Self {\n         let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = SmallCStr::new(name);\n@@ -69,7 +74,7 @@ impl Builder<'a, 'll, 'tcx> {\n         bx\n     }\n \n-    pub fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n             llvm::LLVMCreateBuilderInContext(cx.llcx)\n@@ -80,84 +85,84 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'll, 'tcx> {\n+    fn build_sibling_block<'b>(&self, name: &'b str) -> Self {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n-    pub fn sess(&self) -> &Session {\n+    fn sess(&self) -> &Session {\n         self.cx.sess()\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.cx.tcx\n     }\n \n-    pub fn llfn(&self) -> &'ll Value {\n+    fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n     }\n \n-    pub fn llbb(&self) -> &'ll BasicBlock {\n+    fn llbb(&self) -> &'ll BasicBlock {\n         unsafe {\n             llvm::LLVMGetInsertBlock(self.llbuilder)\n         }\n     }\n \n     fn count_insn(&self, category: &str) {\n-        if self.cx.sess().codegen_stats() {\n-            self.cx.stats.borrow_mut().n_llvm_insns += 1;\n+        if self.cx().sess().codegen_stats() {\n+            self.cx().stats.borrow_mut().n_llvm_insns += 1;\n         }\n-        if self.cx.sess().count_llvm_insns() {\n-            *self.cx.stats\n-                    .borrow_mut()\n-                    .llvm_insns\n-                    .entry(category.to_string())\n-                    .or_insert(0) += 1;\n+        if self.cx().sess().count_llvm_insns() {\n+            *self.cx().stats\n+                      .borrow_mut()\n+                      .llvm_insns\n+                      .entry(category.to_string())\n+                      .or_insert(0) += 1;\n         }\n     }\n \n-    pub fn set_value_name(&self, value: &'ll Value, name: &str) {\n+    fn set_value_name(&self, value: &'ll Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    pub fn position_at_end(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_end(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn position_at_start(&self, llbb: &'ll BasicBlock) {\n+    fn position_at_start(&self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n-    pub fn ret_void(&self) {\n+    fn ret_void(&self) {\n         self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n-    pub fn ret(&self, v: &'ll Value) {\n+    fn ret(&self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    pub fn br(&self, dest: &'ll BasicBlock) {\n+    fn br(&self, dest: &'ll BasicBlock) {\n         self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n     }\n \n-    pub fn cond_br(\n+    fn cond_br(\n         &self,\n         cond: &'ll Value,\n         then_llbb: &'ll BasicBlock,\n@@ -169,7 +174,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn switch(\n+    fn switch(\n         &self,\n         v: &'ll Value,\n         else_llbb: &'ll BasicBlock,\n@@ -180,7 +185,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn invoke(&self,\n+    fn invoke(&self,\n                   llfn: &'ll Value,\n                   args: &[&'ll Value],\n                   then: &'ll BasicBlock,\n@@ -207,29 +212,29 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn unreachable(&self) {\n+    fn unreachable(&self) {\n         self.count_insn(\"unreachable\");\n         unsafe {\n             llvm::LLVMBuildUnreachable(self.llbuilder);\n         }\n     }\n \n     /* Arithmetic */\n-    pub fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -238,21 +243,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -261,21 +266,21 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -285,42 +290,42 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    pub fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -329,28 +334,28 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -359,78 +364,78 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn neg(&self, v: &'ll Value) -> &'ll Value {\n+    fn neg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn fneg(&self, v: &'ll Value) -> &'ll Value {\n+    fn fneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn not(&self, v: &'ll Value) -> &'ll Value {\n+    fn not(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -445,7 +450,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn array_alloca(&self,\n+    fn array_alloca(&self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n                         name: &str,\n@@ -464,7 +469,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -473,7 +478,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n+    fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -482,7 +487,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, size: Size) -> &'ll Value {\n+    fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, size: Size) -> &'ll Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n@@ -493,7 +498,7 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    pub fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n+    fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n         if self.sess().target.target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n@@ -516,18 +521,18 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nonnull_metadata(&self, load: &'ll Value) {\n+    fn nonnull_metadata(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    pub fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n-    pub fn store_with_flags(\n+    fn store_with_flags(\n         &self,\n         val: &'ll Value,\n         ptr: &'ll Value,\n@@ -561,8 +566,8 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n-                        order: AtomicOrdering, size: Size) {\n+   fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n+                   order: AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n@@ -573,153 +578,139 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+    fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n-        assert_eq!(idx as c_uint as u64, idx);\n-        unsafe {\n-            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n-        }\n-    }\n-\n     /* Casts */\n-    pub fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n-        unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n-        }\n-    }\n-\n-    pub fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    pub fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+    fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"pointercast\");\n+\n+    fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    pub fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"intcast\");\n+    fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"pointercast\");\n         unsafe {\n-            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n-    pub fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    pub fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n+    fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n+    fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -731,10 +722,10 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                           inputs: &[&'ll Value], output: &'ll Type,\n-                           volatile: bool, alignstack: bool,\n-                           dia: AsmDialect) -> Option<&'ll Value> {\n+    fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n+                       inputs: &[&'ll Value], output: &'ll Type,\n+                       volatile: bool, alignstack: bool,\n+                       dia: AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -748,7 +739,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func(&argtys[..], output);\n+        let fty = Type::func::<Value>(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -764,24 +755,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n-        self.count_insn(\"call\");\n-\n-        debug!(\"Call {:?} with args ({:?})\",\n-               llfn,\n-               args);\n-\n-        let args = self.check_call(\"call\", llfn, args);\n-        let bundle = bundle.map(|b| &*b.raw);\n-\n-        unsafe {\n-            llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n-                                    args.len() as c_uint, bundle, noname())\n-        }\n-    }\n-\n-    pub fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n+    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n                   src: &'ll Value, src_align: u64,\n                   size: &'ll Value, is_volatile: bool) -> &'ll Value {\n         unsafe {\n@@ -790,7 +764,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn memmove(&self, dst: &'ll Value, dst_align: u64,\n+    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n                   src: &'ll Value, src_align: u64,\n                   size: &'ll Value, is_volatile: bool) -> &'ll Value {\n         unsafe {\n@@ -799,22 +773,22 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    pub fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+    fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n             instr.expect(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\")\n         }\n     }\n \n-    pub fn select(\n+    fn select(\n         &self, cond: &'ll Value,\n         then_val: &'ll Value,\n         else_val: &'ll Value,\n@@ -826,21 +800,21 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    pub fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    pub fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n+    fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n-    pub fn insert_element(\n+    fn insert_element(\n         &self, vec: &'ll Value,\n         elt: &'ll Value,\n         idx: &'ll Value,\n@@ -851,24 +825,24 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n+    fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n+    fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(Type::vector::<Value>(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n+            let vec_i32_ty = Type::vector::<Value>(Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n \n-    pub fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -879,7 +853,7 @@ impl Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n@@ -890,68 +864,68 @@ impl Builder<'a, 'll, 'tcx> {\n             instr\n         }\n     }\n-    pub fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n-    pub fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    pub fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n-    pub fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n+    fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n-    pub fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+    fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n-    pub fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n+    fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n+    fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n                        idx: u64) -> &'ll Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n@@ -961,7 +935,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n+    fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n@@ -970,27 +944,27 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n+    fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    pub fn set_cleanup(&self, landing_pad: &'ll Value) {\n+    fn set_cleanup(&self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    pub fn resume(&self, exn: &'ll Value) -> &'ll Value {\n+    fn resume(&self, exn: &'ll Value) -> &'ll Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n-    pub fn cleanup_pad(&self,\n+    fn cleanup_pad(&self,\n                        parent: Option<&'ll Value>,\n                        args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"cleanuppad\");\n@@ -1005,7 +979,7 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for cleanuppad\")\n     }\n \n-    pub fn cleanup_ret(\n+    fn cleanup_ret(\n         &self, cleanup: &'ll Value,\n         unwind: Option<&'ll BasicBlock>,\n     ) -> &'ll Value {\n@@ -1016,7 +990,7 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for cleanupret\")\n     }\n \n-    pub fn catch_pad(&self,\n+    fn catch_pad(&self,\n                      parent: &'ll Value,\n                      args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"catchpad\");\n@@ -1029,15 +1003,15 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    pub fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n+    fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n         };\n         ret.expect(\"LLVM does not have support for catchret\")\n     }\n \n-    pub fn catch_switch(\n+    fn catch_switch(\n         &self,\n         parent: Option<&'ll Value>,\n         unwind: Option<&'ll BasicBlock>,\n@@ -1053,20 +1027,20 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    pub fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n+    fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    pub fn set_personality_fn(&self, personality: &'ll Value) {\n+    fn set_personality_fn(&self, personality: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n     }\n \n     // Atomic Operations\n-    pub fn atomic_cmpxchg(\n+    fn atomic_cmpxchg(\n         &self,\n         dst: &'ll Value,\n         cmp: &'ll Value,\n@@ -1080,7 +1054,7 @@ impl Builder<'a, 'll, 'tcx> {\n                                              order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(\n+    fn atomic_rmw(\n         &self,\n         op: AtomicRmwBinOp,\n         dst: &'ll Value,\n@@ -1092,26 +1066,26 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n+    fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope) {\n         unsafe {\n             llvm::LLVMRustBuildAtomicFence(self.llbuilder, order, scope);\n         }\n     }\n \n-    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n+    fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n+    fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    pub fn set_invariant_load(&self, load: &'ll Value) {\n+    fn set_invariant_load(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n@@ -1181,11 +1155,11 @@ impl Builder<'a, 'll, 'tcx> {\n         Cow::Owned(casted_args)\n     }\n \n-    pub fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    pub fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n+    fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n@@ -1212,4 +1186,45 @@ impl Builder<'a, 'll, 'tcx> {\n         let ptr = self.pointercast(ptr, Type::i8p(self.cx));\n         self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n     }\n+\n+    fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n+                bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value {\n+        self.count_insn(\"call\");\n+\n+        debug!(\"Call {:?} with args ({:?})\",\n+               llfn,\n+               args);\n+\n+        let args = self.check_call(\"call\", llfn, args);\n+        let bundle = bundle.map(|b| &*b.raw);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                bundle, noname()\n+            )\n+        }\n+    }\n+\n+    fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"zext\");\n+        unsafe {\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n+        }\n+    }\n+\n+    fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n+        self.count_insn(\"structgep\");\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe {\n+            llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n+        }\n+    }\n+\n+    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, &'ll Value> {\n+        &self.cx\n+    }\n }"}, {"sha": "66f14322fc6725b65c7ca275d9d2a418be4d54d1", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -23,11 +23,12 @@ use consts;\n use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use value::Value;\n+use value::{Value, ValueTrait};\n \n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n+use traits::BuilderMethods;\n \n use libc::{c_uint, c_char};\n \n@@ -110,9 +111,9 @@ impl Funclet<'ll> {\n     }\n }\n \n-pub fn val_ty(v: &'ll Value) -> &'ll Type {\n+pub fn val_ty<Value : ?Sized>(v: &'ll Value) -> &'ll Type where Value : ValueTrait {\n     unsafe {\n-        llvm::LLVMTypeOf(v)\n+        llvm::LLVMTypeOf(v.to_llvm())\n     }\n }\n \n@@ -123,21 +124,21 @@ pub fn C_null(t: &'ll Type) -> &'ll Value {\n     }\n }\n \n-pub fn C_undef(t: &'ll Type) -> &'ll Value {\n+pub fn C_undef<Value : ?Sized>(t: &'ll Type) -> &'ll Value where Value : ValueTrait {\n     unsafe {\n-        llvm::LLVMGetUndef(t)\n+        Value::of_llvm(llvm::LLVMGetUndef(t))\n     }\n }\n \n-pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n+pub fn C_int<Value : ?Sized>(t: &'ll Type, i: i64) -> &'ll Value where Value : ValueTrait {\n     unsafe {\n-        llvm::LLVMConstInt(t, i as u64, True)\n+        Value::of_llvm(llvm::LLVMConstInt(t, i as u64, True))\n     }\n }\n \n-pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n+pub fn C_uint<Value : ?Sized>(t: &'ll Type, i: u64) -> &'ll Value where Value : ValueTrait {\n     unsafe {\n-        llvm::LLVMConstInt(t, i, False)\n+        Value::of_llvm(llvm::LLVMConstInt(t, i, False))\n     }\n }\n \n@@ -148,11 +149,17 @@ pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n     }\n }\n \n-pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n+pub fn C_bool<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    val: bool\n+) -> &'ll Value where Value : ValueTrait {\n     C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n+pub fn C_i32<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    i: i32\n+) -> &'ll Value where Value : ValueTrait {\n     C_int(Type::i32(cx), i as i64)\n }\n \n@@ -164,7 +171,10 @@ pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n+pub fn C_usize<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    i: u64\n+) -> &'ll Value where Value : ValueTrait {\n     let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow"}, {"sha": "ed9a9e3209ba2ea5927ceaef5b88875323f964b1", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -18,7 +18,7 @@ use callee;\n use base;\n use declare;\n use monomorphize::Instance;\n-use value::Value;\n+use value::{Value, ValueTrait};\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n             None\n         };\n \n-        let isize_ty = Type::ix_llcx(llcx, tcx.data_layout.pointer_size.bits());\n+        let isize_ty = Type::ix_llcx::<Value>(llcx, tcx.data_layout.pointer_size.bits());\n \n         CodegenCx {\n             tcx,\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n+impl<'b, 'tcx, Value : ?Sized> CodegenCx<'b, 'tcx, &'b Value> where Value : ValueTrait {\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n@@ -327,7 +327,9 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n \n         declare_intrinsic(self, key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n     }\n+}\n \n+impl<'b, 'tcx> CodegenCx<'b, 'tcx, &'b Value> {\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -377,7 +379,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func(&[], Type::i32(self));\n+                let fty = Type::variadic_func::<Value>(&[], Type::i32(self));\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n@@ -478,28 +480,31 @@ impl LayoutOf for CodegenCx<'ll, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n+fn declare_intrinsic<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    key: &str\n+) -> Option<&'ll Value> where Value : ValueTrait {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n+                let f = declare::declare_cfn(cx, $name, Type::func::<Value>(&[], $ret));\n+                llvm::SetUnnamedAddr(f.to_llvm(), false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func::<Value>(&[], $ret));\n+                llvm::SetUnnamedAddr(f.to_llvm(), false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n-                llvm::SetUnnamedAddr(f, false);\n+                let f = declare::declare_cfn(cx, $name, Type::func::<Value>(&[$($arg),*], $ret));\n+                llvm::SetUnnamedAddr(f.to_llvm(), false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -520,14 +525,14 @@ fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n-    let t_v2f32 = Type::vector(t_f32, 2);\n-    let t_v4f32 = Type::vector(t_f32, 4);\n-    let t_v8f32 = Type::vector(t_f32, 8);\n-    let t_v16f32 = Type::vector(t_f32, 16);\n+    let t_v2f32 = Type::vector::<Value>(t_f32, 2);\n+    let t_v4f32 = Type::vector::<Value>(t_f32, 4);\n+    let t_v8f32 = Type::vector::<Value>(t_f32, 8);\n+    let t_v16f32 = Type::vector::<Value>(t_f32, 16);\n \n-    let t_v2f64 = Type::vector(t_f64, 2);\n-    let t_v4f64 = Type::vector(t_f64, 4);\n-    let t_v8f64 = Type::vector(t_f64, 8);\n+    let t_v2f64 = Type::vector::<Value>(t_f64, 2);\n+    let t_v4f64 = Type::vector::<Value>(t_f64, 4);\n+    let t_v8f64 = Type::vector::<Value>(t_f64, 8);\n \n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);"}, {"sha": "9d02738fcbdd0b69604e6c18a2e37daab20d5574", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -18,6 +18,7 @@ use declare;\n use rustc::session::config::DebugInfo;\n use type_::Type;\n use value::Value;\n+use traits::BuilderMethods;\n \n use syntax::attr;\n \n@@ -55,7 +56,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(Type::i8(cx),\n+            let llvm_type = Type::array::<Value>(Type::i8(cx),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,"}, {"sha": "bce722b4b43ecca817f9f828ab613f98f345bd1a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -45,6 +45,7 @@ use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use rustc::ty::layout::{self, LayoutOf};\n+use traits::BuilderMethods;\n \n pub mod gdb;\n mod utils;"}, {"sha": "bd8c165d508fcba658561898413a7796ae48515f", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -17,6 +17,7 @@ use super::FunctionDebugContext;\n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n+use traits::BuilderMethods;\n \n use libc::c_uint;\n use syntax_pos::{Span, Pos};\n@@ -78,7 +79,10 @@ impl InternalDebugLocation<'ll> {\n     }\n }\n \n-pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDebugLocation<'ll>) {\n+pub fn set_debug_location(\n+    bx: &Builder<'_, 'll, '_>,\n+    debug_location: InternalDebugLocation<'ll>\n+) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, col } => {\n             // For MSVC, set the column number to zero."}, {"sha": "d06801518935c5c5f0f89c5a923fea2703fc4dc1", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -31,7 +31,7 @@ use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use type_::Type;\n-use value::Value;\n+use value::{Value, ValueTrait};\n \n \n /// Declare a global value.\n@@ -51,12 +51,12 @@ pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'l\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-fn declare_raw_fn(\n-    cx: &CodegenCx<'ll, '_>,\n+fn declare_raw_fn<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n     name: &str,\n     callconv: llvm::CallConv,\n     ty: &'ll Type,\n-) -> &'ll Value {\n+) -> &'ll Value where Value : ValueTrait {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = SmallCStr::new(name);\n     let llfn = unsafe {\n@@ -105,7 +105,7 @@ fn declare_raw_fn(\n \n     attributes::non_lazy_bind(cx.sess(), llfn);\n \n-    llfn\n+    Value::of_llvm(llfn)\n }\n \n \n@@ -116,7 +116,11 @@ fn declare_raw_fn(\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-pub fn declare_cfn(cx: &CodegenCx<'ll, '_>, name: &str, fn_type: &'ll Type) -> &'ll Value {\n+pub fn declare_cfn<Value : ?Sized>(\n+    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    name: &str,\n+    fn_type: &'ll Type\n+) -> &'ll Value where Value : ValueTrait {\n     declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n@@ -168,7 +172,7 @@ pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Opti\n /// Declare a private global\n ///\n /// Use this function when you intend to define a global without a name.\n-pub fn define_private_global(cx: &CodegenCx<'ll, '_>, ty: &'ll Type) -> &'ll Value {\n+pub fn define_private_global(cx: &CodegenCx<'ll, '_, &'ll Value>, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMRustInsertPrivateGlobal(cx.llmod, ty)\n     }"}, {"sha": "9144e3f07a13355aff3337a3016306ace25282a0", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -21,9 +21,13 @@ use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n+use traits::BuilderMethods;\n \n-pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Option<&'ll Value>)\n-                                       -> (&'ll Value, &'ll Value) {\n+pub fn size_and_align_of_dst(\n+    bx: &Builder<'_, 'll, 'tcx>,\n+    t: Ty<'tcx>,\n+    info: Option<&'ll Value>\n+) -> (&'ll Value, &'ll Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, info);\n     if bx.cx.type_is_sized(t) {"}, {"sha": "48afda73d792a7711e9f8ecf3464df90659197c1", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -31,6 +31,8 @@ use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n \n+use traits::BuilderMethods;\n+\n use rustc::session::Session;\n use syntax_pos::Span;\n \n@@ -591,7 +593,7 @@ pub fn codegen_intrinsic_call(\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector(elem, length as u64)]\n+                        vec![Type::vector::<Value>(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n@@ -640,7 +642,10 @@ pub fn codegen_intrinsic_call(\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n-                        vec![bx.bitcast(arg.immediate(), Type::vector(llvm_elem, length as u64))]\n+                        vec![\n+                            bx.bitcast(arg.immediate(),\n+                            Type::vector::<Value>(llvm_elem, length as u64))\n+                        ]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n@@ -668,7 +673,7 @@ pub fn codegen_intrinsic_call(\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 Type::func(&inputs, outputs));\n+                                                 Type::func::<Value>(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -1155,7 +1160,7 @@ fn generic_simd_intrinsic(\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(i1, m_len as u64);\n+        let i1xn = Type::vector::<Value>(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1296,7 +1301,7 @@ fn generic_simd_intrinsic(\n             elem_ty = elem_ty.ptr_to();\n             no_pointers -= 1;\n         }\n-        Type::vector(elem_ty, vec_len as u64)\n+        Type::vector::<Value>(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1379,7 +1384,7 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1xn = Type::vector::<Value>(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1394,8 +1399,11 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n-                                                  llvm_elem_vec_ty], llvm_elem_vec_ty));\n+                                     Type::func::<Value>(&[\n+                                         llvm_pointer_vec_ty,\n+                                         alignment_ty,\n+                                         mask_ty,\n+                                         llvm_elem_vec_ty], llvm_elem_vec_ty));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n                         None);\n@@ -1476,7 +1484,7 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(i1, in_len as u64);\n+            let i1xn = Type::vector::<Value>(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1493,7 +1501,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func(&[llvm_elem_vec_ty,\n+                                     Type::func::<Value>(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n                                                   mask_ty], ret_t));\n@@ -1628,7 +1636,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n                     // boolean reductions operate on vectors of i1s:\n                     let i1 = Type::i1(bx.cx);\n-                    let i1xn = Type::vector(i1, in_len as u64);\n+                    let i1xn = Type::vector::<Value>(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {"}, {"sha": "1baab9b0c4d476ed875e541f3301d2955c07eb9f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -102,6 +102,8 @@ mod back {\n     pub mod wasm;\n }\n \n+mod traits;\n+\n mod abi;\n mod allocator;\n mod asm;"}, {"sha": "70856a99ce79c55b89bedb88d68fd1634fc3a4f5", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -17,6 +17,8 @@ use monomorphize;\n use type_::Type;\n use value::Value;\n \n+use traits::BuilderMethods;\n+\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n@@ -48,7 +50,11 @@ impl<'a, 'tcx> VirtualIndex {\n         ptr\n     }\n \n-    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: &'ll Value) -> &'ll Value {\n+    pub fn get_usize(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        llvtable: &'ll Value\n+    ) -> &'ll Value {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n "}, {"sha": "5f7f138cb6eb2e33a2c724fc6900840b473d867e", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -26,6 +26,8 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n \n+use traits::BuilderMethods;\n+\n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n@@ -98,16 +100,17 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             }\n         };\n \n-        let funclet_br = |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n-            let (lltarget, is_cleanupret) = lltarget(this, target);\n-            if is_cleanupret {\n-                // micro-optimization: generate a `ret` rather than a jump\n-                // to a trampoline.\n-                bx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n-            } else {\n-                bx.br(lltarget);\n-            }\n-        };\n+        let funclet_br =\n+            |this: &mut Self, bx: Builder<'_, 'll, '_, &'ll Value>, target: mir::BasicBlock| {\n+                let (lltarget, is_cleanupret) = lltarget(this, target);\n+                if is_cleanupret {\n+                    // micro-optimization: generate a `ret` rather than a jump\n+                    // to a trampoline.\n+                    bx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                } else {\n+                    bx.br(lltarget);\n+                }\n+            };\n \n         let do_call = |\n             this: &mut Self,\n@@ -843,7 +846,10 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'tcx, &'ll Value> {\n+    fn get_personality_slot(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot"}, {"sha": "62fce894cf7a9582cc5a8f3f1f39edf7094b3824", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -26,6 +26,7 @@ use type_::Type;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use value::Value;\n+use traits::BuilderMethods;\n \n use super::super::callee;\n use super::FunctionCx;"}, {"sha": "526c8f75f4943ea8ac14ff2ec7f9124a761da8fe", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -26,6 +26,7 @@ use monomorphize::Instance;\n use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n use type_::Type;\n use value::Value;\n+use traits::BuilderMethods;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -119,7 +120,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         )\n     }\n \n-    pub fn set_debug_loc(&mut self, bx: &Builder<'_, 'll, '_>, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(\n+        &mut self,\n+        bx: &Builder<'_, 'll, '_, &'ll Value>,\n+        source_info: mir::SourceInfo\n+    ) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n     }"}, {"sha": "e640b72cd44587a5c58e4e9c60d64a9b3eb77ceb", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -21,6 +21,8 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use glue;\n \n+use traits::BuilderMethods;\n+\n use std::fmt;\n \n use super::{FunctionCx, LocalRef};\n@@ -260,7 +262,11 @@ impl OperandValue<&'ll Value> {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n+    pub fn volatile_store(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        dest: PlaceRef<'tcx, &'ll Value>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n@@ -271,14 +277,23 @@ impl OperandValue<&'ll Value> {\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n+}\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx, &'ll Value>) {\n+impl<'a, 'll: 'a, 'tcx: 'll, Value : ?Sized> OperandValue<&'ll Value> where\n+    Value : ValueTrait,\n+    Builder<'a, 'll, 'tcx, &'ll Value>: BuilderMethods<'a, 'll, 'tcx, Value>\n+{\n+    pub fn nontemporal_store(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        dest: PlaceRef<'tcx, &'ll Value>\n+    ) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags(\n+    fn store_with_flags<Builder: BuilderMethods<'a, 'll, 'tcx, Value>>(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n+        bx: &Builder,\n         dest: PlaceRef<'tcx, &'ll Value>,\n         flags: MemFlags,\n     ) {\n@@ -309,11 +324,13 @@ impl OperandValue<&'ll Value> {\n             }\n         }\n     }\n+}\n \n+impl OperandValue<&'ll Value> {\n     pub fn store_unsized(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx>,\n-        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        indirect_dest: PlaceRef<'tcx, &'ll Value>\n     ) {\n         debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);\n         let flags = MemFlags::empty();\n@@ -334,13 +351,13 @@ impl OperandValue<&'ll Value> {\n         let min_align = Align::from_bits(8, 8).unwrap();\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n-        let (llsize, _) = glue::size_and_align_of_dst(&bx, unsized_ty, Some(llextra));\n+        let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n         let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n-        base::call_memcpy(&bx, lldst, max_align, llptr, min_align, llsize, flags);\n+        base::call_memcpy(bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n         let indirect_operand = OperandValue::Pair(lldst, llextra);\n-        indirect_operand.store(&bx, indirect_dest);\n+        indirect_operand.store(bx, indirect_dest);\n     }\n }\n "}, {"sha": "b9bd07499651ea291da4805d84375e83e1ac7ce6", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -23,6 +23,8 @@ use value::Value;\n use glue;\n use mir::constant::const_alloc_to_llvm;\n \n+use traits::BuilderMethods;\n+\n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n@@ -280,7 +282,11 @@ impl PlaceRef<'tcx, &'ll Value> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n+    pub fn codegen_get_discr(\n+        self,\n+        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        cast_to: Ty<'tcx>\n+    ) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi.is_uninhabited() {\n             return C_undef(cast_to);"}, {"sha": "017b13410cd53c36b279449b4417f90af9752a90", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -28,6 +28,8 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n \n+use traits::BuilderMethods;\n+\n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -178,12 +180,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn codegen_rvalue_unsized(\n-        &mut self,\n-        bx: Builder<'a, 'll, 'tcx>,\n-        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n-        rvalue: &mir::Rvalue<'tcx>,\n-    ) -> Builder<'a, 'll, 'tcx> {\n+    pub fn codegen_rvalue_unsized(&mut self,\n+                        bx: Builder<'a, 'll, 'tcx, &'ll Value>,\n+                        indirect_dest: PlaceRef<'tcx, &'ll Value>,\n+                        rvalue: &mir::Rvalue<'tcx>)\n+                        -> Builder<'a, 'll, 'tcx, &'ll Value>\n+    {\n         debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n                indirect_dest.llval, rvalue);\n \n@@ -198,11 +200,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         }\n     }\n \n-    pub fn codegen_rvalue_operand(&mut self,\n-                                bx: Builder<'a, 'll, 'tcx>,\n-                                rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx, &'ll Value>)\n-    {\n+    pub fn codegen_rvalue_operand(\n+        &mut self,\n+        bx: Builder<'a, 'll, 'tcx, &'ll Value>,\n+        rvalue: &mir::Rvalue<'tcx>\n+    ) -> (Builder<'a, 'll, 'tcx, &'ll Value>, OperandRef<'tcx, &'ll Value>) {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n         match *rvalue {\n@@ -750,7 +752,11 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder<'_, 'll, '_>, ty: Ty) -> &'ll Value {\n+fn get_overflow_intrinsic(\n+    oop: OverflowOp,\n+    bx: &Builder<'_, 'll, '_, &'ll Value>,\n+    ty: Ty\n+) -> &'ll Value {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{Int, Uint};"}, {"sha": "a3aea7b9180a1e81b312439054b4577bb7b64752", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -12,6 +12,7 @@ use rustc::mir;\n \n use asm;\n use builder::Builder;\n+use traits::BuilderMethods;\n \n use super::FunctionCx;\n use super::LocalRef;"}, {"sha": "2a6dbe9944d49b4f5a502717408222e4f6740ae8", "filename": "src/librustc_codegen_llvm/traits.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftraits.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n+use llvm::{IntPredicate, RealPredicate, OperandBundleDef};\n+use llvm::{self, BasicBlock};\n+use common::*;\n+use type_::Type;\n+use libc::c_char;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::layout::{Align, Size};\n+use rustc::session::Session;\n+use builder::MemFlags;\n+\n+use std::borrow::Cow;\n+use std::ops::Range;\n+\n+\n+pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll, Value : ?Sized> {\n+    fn new_block<'b>(\n+        cx: &'a CodegenCx<'ll, 'tcx, &'ll Value>,\n+        llfn: &'ll Value,\n+        name: &'b str\n+    ) -> Self;\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx, &'ll Value>) -> Self;\n+    fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n+    fn sess(&self) -> &Session;\n+    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, &'ll Value>;\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn llfn(&self) -> &'ll Value;\n+    fn llbb(&self) -> &'ll BasicBlock;\n+    fn count_insn(&self, category: &str);\n+\n+    fn set_value_name(&self, value: &'ll Value, name: &str);\n+    fn position_at_end(&self, llbb: &'ll BasicBlock);\n+    fn position_at_start(&self, llbb: &'ll BasicBlock);\n+    fn ret_void(&self);\n+    fn ret(&self, v: &'ll Value);\n+    fn br(&self, dest: &'ll BasicBlock);\n+    fn cond_br(\n+        &self,\n+        cond: &'ll Value,\n+        then_llbb: &'ll BasicBlock,\n+        else_llbb: &'ll BasicBlock,\n+    );\n+    fn switch(\n+        &self,\n+        v: &'ll Value,\n+        else_llbb: &'ll BasicBlock,\n+        num_cases: usize,\n+    ) -> &'ll Value;\n+    fn invoke(\n+        &self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        then: &'ll BasicBlock,\n+        catch: &'ll BasicBlock,\n+        bundle: Option<&OperandBundleDef<'ll>>\n+    ) -> &'ll Value;\n+    fn unreachable(&self);\n+    fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn neg(&self, v: &'ll Value) -> &'ll Value;\n+    fn fneg(&self, v: &'ll Value) -> &'ll Value;\n+    fn not(&self, v: &'ll Value) -> &'ll Value;\n+\n+    fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value;\n+    fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value;\n+    fn array_alloca(\n+        &self,\n+        ty: &'ll Type,\n+        len: &'ll Value,\n+        name: &str,\n+        align: Align\n+    ) -> &'ll Value;\n+\n+    fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value;\n+    fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value;\n+    fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, size: Size) -> &'ll Value;\n+\n+    fn range_metadata(&self, load: &'ll Value, range: Range<u128>);\n+    fn nonnull_metadata(&self, load: &'ll Value);\n+\n+    fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value;\n+    fn store_with_flags(\n+        &self,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n+        align: Align,\n+        flags: MemFlags,\n+    ) -> &'ll Value;\n+    fn atomic_store(\n+        &self,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n+        order: AtomicOrdering,\n+        size: Size\n+    );\n+\n+    fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value;\n+    fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value;\n+    fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value;\n+\n+    fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+    fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value;\n+    fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+\n+    fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+\n+    fn empty_phi(&self, ty: &'ll Type) -> &'ll Value;\n+    fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value;\n+    fn inline_asm_call(\n+        &self,\n+        asm: *const c_char,\n+        cons: *const c_char,\n+        inputs: &[&'ll Value],\n+        output: &'ll Type,\n+        volatile: bool,\n+        alignstack: bool,\n+        dia: AsmDialect\n+    ) -> Option<&'ll Value>;\n+\n+\n+    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value;\n+    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n+                  src: &'ll Value, src_align: u64,\n+                  size: &'ll Value, is_volatile: bool) -> &'ll Value;\n+\n+    fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value;\n+    fn select(\n+        &self, cond: &'ll Value,\n+        then_val: &'ll Value,\n+        else_val: &'ll Value,\n+    ) -> &'ll Value;\n+\n+    fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value;\n+    fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value;\n+    fn insert_element(\n+        &self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value;\n+    fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value;\n+    fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value;\n+    fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value;\n+    fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value;\n+    fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value;\n+    fn insert_value(\n+        &self,\n+        agg_val: &'ll Value,\n+        elt: &'ll Value,\n+        idx: u64\n+    ) -> &'ll Value;\n+\n+    fn landing_pad(\n+        &self,\n+        ty: &'ll Type,\n+        pers_fn: &'ll Value,\n+        num_clauses: usize\n+    ) -> &'ll Value;\n+    fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value);\n+    fn set_cleanup(&self, landing_pad: &'ll Value);\n+    fn resume(&self, exn: &'ll Value) -> &'ll Value;\n+    fn cleanup_pad(\n+        &self,\n+        parent: Option<&'ll Value>,\n+        args: &[&'ll Value]\n+    ) -> &'ll Value;\n+    fn cleanup_ret(\n+        &self, cleanup: &'ll Value,\n+        unwind: Option<&'ll BasicBlock>,\n+    ) -> &'ll Value;\n+    fn catch_pad(\n+        &self,\n+        parent: &'ll Value,\n+        args: &[&'ll Value]\n+    ) -> &'ll Value;\n+    fn catch_ret(&self, pad: &'ll Value, unwind: &'ll BasicBlock) -> &'ll Value;\n+    fn catch_switch(\n+        &self,\n+        parent: Option<&'ll Value>,\n+        unwind: Option<&'ll BasicBlock>,\n+        num_handlers: usize,\n+    ) -> &'ll Value;\n+    fn add_handler(&self, catch_switch: &'ll Value, handler: &'ll BasicBlock);\n+    fn set_personality_fn(&self, personality: &'ll Value);\n+\n+    fn atomic_cmpxchg(\n+        &self,\n+        dst: &'ll Value,\n+        cmp: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+        failure_order: AtomicOrdering,\n+        weak: llvm::Bool,\n+    ) -> &'ll Value;\n+    fn atomic_rmw(\n+        &self,\n+        op: AtomicRmwBinOp,\n+        dst: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+    ) -> &'ll Value;\n+    fn atomic_fence(&self, order: AtomicOrdering, scope: SynchronizationScope);\n+    fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: &'ll BasicBlock);\n+    fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock);\n+    fn set_invariant_load(&self, load: &'ll Value);\n+\n+    fn check_store(\n+        &self,\n+        val: &'ll Value,\n+        ptr: &'ll Value\n+    ) -> &'ll Value;\n+    fn check_call<'b>(\n+        &self,\n+        typ: &str,\n+        llfn: &'ll Value,\n+        args: &'b [&'ll Value]\n+    ) -> Cow<'b, [&'ll Value]>;\n+    fn lifetime_start(&self, ptr: &'ll Value, size: Size);\n+    fn lifetime_end(&self, ptr: &'ll Value, size: Size);\n+\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size);\n+\n+    fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n+                bundle: Option<&OperandBundleDef<'ll>>) -> &'ll Value;\n+    fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value;\n+}"}, {"sha": "44162ef0a50427ef070b976fc49ce17fbbebcbf0", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 85, "deletions": 29, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -16,6 +16,7 @@ use llvm;\n use llvm::{Bool, False, True, TypeKind};\n \n use context::CodegenCx;\n+use value::{Value, ValueTrait};\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n@@ -40,107 +41,143 @@ impl fmt::Debug for Type {\n }\n \n impl Type {\n-    pub fn void(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn void<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMVoidTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn metadata(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn metadata<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i1(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i1<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMInt1TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i8(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i8<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMInt8TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+    pub fn i8_llcx<Value : ?Sized>(llcx: &llvm::Context) -> &Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMInt8TypeInContext(llcx)\n         }\n     }\n \n-    pub fn i16(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i16<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n+\n             llvm::LLVMInt16TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i32<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMInt32TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i64<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMInt64TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i128(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i128<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMIntTypeInContext(cx.llcx, 128)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(cx: &CodegenCx<'ll, '_>, num_bits: u64) -> &'ll Type {\n+    pub fn ix<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+        num_bits: u64\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n+    pub fn ix_llcx<Value : ?Sized>(\n+        llcx: &llvm::Context,\n+        num_bits: u64\n+    ) -> &Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n         }\n     }\n \n-    pub fn f32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn f32<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMFloatTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn f64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn f64<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         unsafe {\n             llvm::LLVMDoubleTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn bool(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn bool<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         Type::i8(cx)\n     }\n \n-    pub fn char(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn char<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         Type::i32(cx)\n     }\n \n-    pub fn i8p(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn i8p<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait {\n         Type::i8(cx).ptr_to()\n     }\n \n-    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n-        Type::i8_llcx(llcx).ptr_to()\n+    pub fn i8p_llcx<Value : ?Sized>(llcx: &llvm::Context) -> &Type where Value : ValueTrait  {\n+        Type::i8_llcx::<Value>(llcx).ptr_to()\n     }\n \n-    pub fn isize(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn isize<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait  {\n         cx.isize_ty\n     }\n \n-    pub fn c_int(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+    pub fn c_int<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>\n+    ) -> &'ll Type where Value : ValueTrait  {\n         match &cx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(cx),\n             \"32\" => Type::i32(cx),\n@@ -149,7 +186,10 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::IntTy) -> &'ll Type {\n+    pub fn int_from_ty<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+        t: ast::IntTy\n+    ) -> &'ll Type where Value : ValueTrait  {\n         match t {\n             ast::IntTy::Isize => cx.isize_ty,\n             ast::IntTy::I8 => Type::i8(cx),\n@@ -160,7 +200,10 @@ impl Type {\n         }\n     }\n \n-    pub fn uint_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::UintTy) -> &'ll Type {\n+    pub fn uint_from_ty<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+        t: ast::UintTy\n+    ) -> &'ll Type where Value : ValueTrait  {\n         match t {\n             ast::UintTy::Usize => cx.isize_ty,\n             ast::UintTy::U8 => Type::i8(cx),\n@@ -171,28 +214,41 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::FloatTy) -> &'ll Type {\n+    pub fn float_from_ty<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+        t: ast::FloatTy\n+    ) -> &'ll Type where Value : ValueTrait  {\n         match t {\n             ast::FloatTy::F32 => Type::f32(cx),\n             ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n-    pub fn func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    pub fn func<Value : ?Sized>(\n+        args: &[&'ll Type],\n+        ret: &'ll Type\n+    ) -> &'ll Type where Value : ValueTrait  {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, False)\n         }\n     }\n \n-    pub fn variadic_func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    pub fn variadic_func<Value : ?Sized>(\n+        args: &[&'ll Type],\n+        ret: &'ll Type\n+    ) -> &'ll Type where Value : ValueTrait  {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, True)\n         }\n     }\n \n-    pub fn struct_(cx: &CodegenCx<'ll, '_>, els: &[&'ll Type], packed: bool) -> &'ll Type {\n+    pub fn struct_<Value : ?Sized>(\n+        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+        els: &[&'ll Type],\n+        packed: bool\n+    ) -> &'ll Type where Value : ValueTrait  {\n         unsafe {\n             llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n@@ -208,13 +264,13 @@ impl Type {\n     }\n \n \n-    pub fn array(ty: &Type, len: u64) -> &Type {\n+    pub fn array<Value : ?Sized>(ty: &Type, len: u64) -> &Type where Value : ValueTrait  {\n         unsafe {\n             llvm::LLVMRustArrayType(ty, len)\n         }\n     }\n \n-    pub fn vector(ty: &Type, len: u64) -> &Type {\n+    pub fn vector<Value : ?Sized>(ty: &Type, len: u64) -> &Type where Value : ValueTrait  {\n         unsafe {\n             llvm::LLVMVectorType(ty, len as c_uint)\n         }\n@@ -307,7 +363,7 @@ impl Type {\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(Type::from_integer(cx, unit), size / unit_size)\n+        Type::array::<Value>(Type::from_integer(cx, unit), size / unit_size)\n     }\n \n     pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {"}, {"sha": "07a0878c7a7c934f5d2e1c0405b457288afe90bd", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n+use value::Value;\n \n use std::fmt::Write;\n \n@@ -40,7 +41,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 return Type::x86_mmx(cx)\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector(element, count);\n+                return Type::vector::<Value>(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n@@ -93,7 +94,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n+            Type::array::<Value>(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {"}, {"sha": "1b789f67b57b9c0c0cfd8d70d03699293d0459d7", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5dc045f2ee53b3bc8e5cece75e6ece96389e6/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=34c5dc045f2ee53b3bc8e5cece75e6ece96389e6", "patch": "@@ -15,15 +15,25 @@ use llvm;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n-pub trait ValueTrait: fmt::Debug {}\n+pub trait ValueTrait: fmt::Debug {\n+    fn to_llvm(&self) -> &llvm::Value;\n+    fn of_llvm(&llvm::Value) -> &Self;\n+}\n \n impl PartialEq for Value {\n     fn eq(&self, other: &Self) -> bool {\n         self as *const _ == other as *const _\n     }\n }\n \n-impl ValueTrait for Value {}\n+impl ValueTrait for Value {\n+    fn to_llvm(&self) -> &llvm::Value {\n+        &self\n+    }\n+    fn of_llvm(v: &llvm::Value) -> &Self {\n+        &v\n+    }\n+}\n \n impl Eq for Value {}\n "}]}