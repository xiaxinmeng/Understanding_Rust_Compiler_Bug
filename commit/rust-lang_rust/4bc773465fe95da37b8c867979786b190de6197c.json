{"sha": "4bc773465fe95da37b8c867979786b190de6197c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYzc3MzQ2NWZlOTVkYTM3YjhjODY3OTc5Nzg2YjE5MGRlNjE5N2M=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-21T00:19:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-27T16:58:39Z"}, "message": "Basic multithreading support. The infinite loops test successfully maxes out the CPU.", "tree": {"sha": "668f9398ab5f977a5dfac6c9e9b807540fe745d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/668f9398ab5f977a5dfac6c9e9b807540fe745d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bc773465fe95da37b8c867979786b190de6197c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc773465fe95da37b8c867979786b190de6197c", "html_url": "https://github.com/rust-lang/rust/commit/4bc773465fe95da37b8c867979786b190de6197c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bc773465fe95da37b8c867979786b190de6197c/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91eadfd1ea1544513258fc30bf94ef384db2ad90", "url": "https://api.github.com/repos/rust-lang/rust/commits/91eadfd1ea1544513258fc30bf94ef384db2ad90", "html_url": "https://github.com/rust-lang/rust/commit/91eadfd1ea1544513258fc30bf94ef384db2ad90"}], "stats": {"total": 208, "additions": 178, "deletions": 30}, "files": [{"sha": "f1666b2e7a7541c59ceaba1f863e38b20263584d", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -95,7 +95,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     dom->root_task->start(main_fn, (uintptr_t)args->args);\n \n-    int ret = dom->start_main_loop();\n+    int ret = dom->start_main_loops(8);\n     delete args;\n     kernel->destroy_domain(dom);\n     kernel->join_all_domains();"}, {"sha": "7b5467ddeb17adb557fdaf04bcd2ad711134000d", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -47,16 +47,14 @@ rust_dom::~rust_dom() {\n \n void\n rust_dom::activate(rust_task *task) {\n-    curr_task = task;\n-\n     context ctx;\n \n     task->ctx.next = &ctx;\n     DLOG(this, task, \"descheduling...\");\n+    scheduler_lock.unlock();\n     task->ctx.swap(ctx);\n+    scheduler_lock.lock();\n     DLOG(this, task, \"task has returned\");\n-\n-    curr_task = NULL;\n }\n \n void\n@@ -211,10 +209,13 @@ rust_dom::schedule_task() {\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n     if (running_tasks.length() > 0) {\n-        size_t i = rand(&rctx);\n-        i %= running_tasks.length();\n-        if (running_tasks[i]->yield_timer.has_timed_out()) {\n-            return (rust_task *)running_tasks[i];\n+        size_t k = rand(&rctx);\n+        // Look around for a runnable task, starting at k.\n+        for(size_t j = 0; j < running_tasks.length(); ++j) {\n+            size_t  i = (j + k) % running_tasks.length();\n+            if (running_tasks[i]->can_schedule()) {\n+                return (rust_task *)running_tasks[i];\n+            }\n         }\n     }\n     return NULL;\n@@ -261,15 +262,20 @@ rust_dom::log_state() {\n  * drop to zero.\n  */\n int\n-rust_dom::start_main_loop() {\n+rust_dom::start_main_loop(int id) {\n+    scheduler_lock.lock();\n+\n     // Make sure someone is watching, to pull us out of infinite loops.\n     rust_timer timer(this);\n \n-    DLOG(this, dom, \"started domain loop\");\n+    DLOG(this, dom, \"started domain loop %d\", id);\n \n     while (number_of_live_tasks() > 0) {\n         A(this, kernel->is_deadlocked() == false, \"deadlock\");\n \n+        DLOG(this, dom, \"worker %d, number_of_live_tasks = %d\",\n+             id, number_of_live_tasks());\n+\n         drain_incoming_message_queue(true);\n \n         rust_task *scheduled_task = schedule_task();\n@@ -281,8 +287,11 @@ rust_dom::start_main_loop() {\n         if (scheduled_task == NULL) {\n             log_state();\n             DLOG(this, task,\n-                \"all tasks are blocked, scheduler yielding ...\");\n+                 \"all tasks are blocked, scheduler id %d yielding ...\",\n+                 id);\n+            scheduler_lock.unlock();\n             sync::sleep(100);\n+            scheduler_lock.lock();\n             DLOG(this, task,\n                 \"scheduler resuming ...\");\n             continue;\n@@ -303,15 +312,21 @@ rust_dom::start_main_loop() {\n \n         interrupt_flag = 0;\n \n+        DLOG(this, task,\n+             \"Running task %p on worker %d\",\n+             scheduled_task, id);\n+        scheduled_task->active = true;\n         activate(scheduled_task);\n+        scheduled_task->active = false;\n \n         DLOG(this, task,\n-                 \"returned from task %s @0x%\" PRIxPTR\n-                 \" in state '%s', sp=0x%\" PRIxPTR,\n-                 scheduled_task->name,\n-                 (uintptr_t)scheduled_task,\n-                 scheduled_task->state->name,\n-                 scheduled_task->rust_sp);\n+             \"returned from task %s @0x%\" PRIxPTR\n+             \" in state '%s', sp=0x%, worker id=%d\" PRIxPTR,\n+             scheduled_task->name,\n+             (uintptr_t)scheduled_task,\n+             scheduled_task->state->name,\n+             scheduled_task->rust_sp,\n+             id);\n \n         /*\n           // These invariants are no longer valid, as rust_sp is not\n@@ -341,10 +356,32 @@ rust_dom::start_main_loop() {\n         reap_dead_tasks();\n     }\n \n-    DLOG(this, dom, \"finished main-loop (dom.rval = %d)\", rval);\n+    DLOG(this, dom, \"finished main-loop %d (dom.rval = %d)\", id, rval);\n+\n+    scheduler_lock.unlock();\n     return rval;\n }\n \n+int rust_dom::start_main_loops(int num_threads)\n+{\n+    dom_worker *worker = NULL;\n+    \n+    // -1, because this thread will also be a worker.\n+    for(int i = 0; i < num_threads - 1; ++i) {\n+        worker = new dom_worker(i + 1, this);\n+        worker->start();\n+        threads.push(worker);\n+    }\n+    \n+    start_main_loop(0);\n+\n+    while(threads.pop(&worker)) {\n+        worker->join();\n+        delete worker;\n+    }\n+\n+    return rval;\n+}\n \n rust_crate_cache *\n rust_dom::get_cache() {\n@@ -353,14 +390,26 @@ rust_dom::get_cache() {\n \n rust_task *\n rust_dom::create_task(rust_task *spawner, const char *name) {\n+    scheduler_lock.lock();\n     rust_task *task =\n         new (this) rust_task (this, &newborn_tasks, spawner, name);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n     newborn_tasks.append(task);\n+    scheduler_lock.unlock();\n     return task;\n }\n \n+rust_dom::dom_worker::dom_worker(int id, rust_dom *owner)\n+    : id(id), owner(owner)\n+{\n+}\n+\n+void rust_dom::dom_worker::run()\n+{\n+    owner->start_main_loop(id);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "7f9fa7a2901ed41577141a8cde1a254f984521d8", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -96,11 +96,25 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     void reap_dead_tasks();\n     rust_task *schedule_task();\n \n-    int start_main_loop();\n+    int start_main_loop(int id);\n+    int start_main_loops(int num_threads);\n \n     void log_state();\n \n     rust_task *create_task(rust_task *spawner, const char *name);\n+\n+    class dom_worker : public rust_thread {\n+        int id;\n+        rust_dom *owner;\n+\n+    public:\n+        dom_worker(int id, rust_dom *owner);\n+\n+        virtual void run();\n+    };\n+\n+    lock_and_signal scheduler_lock;\n+    array_list<dom_worker *> threads;\n };\n \n inline rust_log &"}, {"sha": "f42f40510bd99258960d5125c77b4507267d4541", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -70,7 +70,8 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n     list_index(-1),\n     rendezvous_ptr(0),\n     alarm(this),\n-    handle(NULL)\n+    handle(NULL),\n+    active(false)\n {\n     LOGPTR(dom, \"new task\", (uintptr_t)this);\n     DLOG(dom, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n@@ -123,17 +124,12 @@ struct spawn_args {\n                        uintptr_t, uintptr_t);\n };\n \n-// TODO: rewrite this in LLVM assembly so we can be sure the calling\n-// conventions will match.\n extern \"C\" CDECL\n void task_start_wrapper(spawn_args *a)\n {\n     rust_task *task = a->task;\n     int rval = 42;\n     \n-    // This is used by the context switching code. LLVM generates fastcall\n-    // functions, but ucontext needs cdecl functions. This massages the\n-    // calling conventions into the right form.\n     a->f(&rval, task, a->a3, a->a4);\n \n     LOG(task, task, \"task exited with value %d\", rval);\n@@ -174,7 +170,10 @@ rust_task::start(uintptr_t spawnee_fn,\n     ctx.call((void *)task_start_wrapper, a, sp);\n \n     yield_timer.reset(0);\n-    transition(&dom->newborn_tasks, &dom->running_tasks);\n+    {\n+        scoped_lock sync(dom->scheduler_lock);\n+        transition(&dom->newborn_tasks, &dom->running_tasks);\n+    }\n }\n \n void\n@@ -425,7 +424,10 @@ rust_task::block(rust_cond *on, const char* name) {\n     A(dom, cond == NULL, \"Cannot block an already blocked task.\");\n     A(dom, on != NULL, \"Cannot block on a NULL object.\");\n \n-    transition(&dom->running_tasks, &dom->blocked_tasks);\n+    {\n+        scoped_lock sync(dom->scheduler_lock);\n+        transition(&dom->running_tasks, &dom->blocked_tasks);\n+    }\n     cond = on;\n     cond_name = name;\n }\n@@ -437,14 +439,18 @@ rust_task::wakeup(rust_cond *from) {\n                         (uintptr_t) cond, (uintptr_t) from);\n     A(dom, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n \n-    transition(&dom->blocked_tasks, &dom->running_tasks);\n+    {\n+        scoped_lock sync(dom->scheduler_lock);\n+        transition(&dom->blocked_tasks, &dom->running_tasks);\n+    }\n     I(dom, cond == from);\n     cond = NULL;\n     cond_name = \"none\";\n }\n \n void\n rust_task::die() {\n+    scoped_lock sync(dom->scheduler_lock);\n     transition(&dom->running_tasks, &dom->dead_tasks);\n }\n \n@@ -482,6 +488,11 @@ rust_task::get_handle() {\n     return handle;\n }\n \n+bool rust_task::can_schedule()\n+{\n+    return yield_timer.has_timed_out() && !active;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "db3c0367adb53f7d30f3e899fd97f34c62d818ed", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -50,6 +50,10 @@ rust_task : public maybe_proxy<rust_task>,\n     rust_handle<rust_task> *handle;\n \n     context ctx;\n+    \n+    // This flag indicates that a worker is either currently running the task\n+    // or is about to run this task.\n+    bool active;\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n     rust_task(rust_dom *dom,\n@@ -111,6 +115,8 @@ rust_task : public maybe_proxy<rust_task>,\n \n     frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n     rust_crate_cache * get_crate_cache();\n+\n+    bool can_schedule();\n };\n \n //"}, {"sha": "337a1efa4bc90fa44d3d4e69f7537267599f3421", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -41,13 +41,16 @@ void lock_and_signal::lock() {\n     EnterCriticalSection(&_cs);\n #else\n     CHECKED(pthread_mutex_lock(&_mutex));\n+    _holding_thread = pthread_self();\n+    _locked = true;\n #endif\n }\n \n void lock_and_signal::unlock() {\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n #else\n+    _locked = false;\n     CHECKED(pthread_mutex_unlock(&_mutex));\n #endif\n }\n@@ -100,6 +103,26 @@ void lock_and_signal::signal_all() {\n #endif\n }\n \n+bool lock_and_signal::lock_held_by_current_thread()\n+{\n+#if defined(__WIN32__)\n+    // TODO: implement this functionality for win32.\n+    return false;\n+#else\n+    return _locked && _holding_thread == pthread_self();\n+#endif\n+}\n+\n+scoped_lock::scoped_lock(lock_and_signal &lock)\n+    : lock(lock)\n+{\n+    lock.lock();\n+}\n+\n+scoped_lock::~scoped_lock()\n+{\n+    lock.unlock();\n+}\n \n //\n // Local Variables:"}, {"sha": "2794027d5c73f73fc4a4c1e0a4632e90b02b3d90", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++ -*-\n #ifndef LOCK_AND_SIGNAL_H\n #define LOCK_AND_SIGNAL_H\n \n@@ -8,6 +9,9 @@ class lock_and_signal {\n #else\n     pthread_cond_t _cond;\n     pthread_mutex_t _mutex;\n+\n+    pthread_t _holding_thread;\n+    bool _locked;\n #endif\n public:\n     lock_and_signal();\n@@ -19,6 +23,16 @@ class lock_and_signal {\n     void timed_wait(size_t timeout_in_ns);\n     void signal();\n     void signal_all();\n+\n+    bool lock_held_by_current_thread();\n+};\n+\n+class scoped_lock {\n+  lock_and_signal &lock;\n+  \n+public:\n+  scoped_lock(lock_and_signal &lock);\n+  ~scoped_lock();\n };\n \n #endif /* LOCK_AND_SIGNAL_H */"}, {"sha": "18a957edd603f8e59cbd3c7ae5719f7421e9ab6a", "filename": "src/rt/test/rust_test_runtime.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Ftest%2Frust_test_runtime.cpp?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -53,7 +53,7 @@ rust_task_test::worker::run() {\n         kernel->create_domain(\"test\");\n     rust_dom *domain = handle->referent();\n     domain->root_task->start((uintptr_t)&task_entry, (uintptr_t)NULL);\n-    domain->start_main_loop();\n+    domain->start_main_loop(0);\n     kernel->destroy_domain(domain);\n }\n "}, {"sha": "495594cf7e68a819d585926f735025752ccc8886", "filename": "src/rt/util/array_list.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Futil%2Farray_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Futil%2Farray_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Farray_list.h?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++ -*-\n #ifndef ARRAY_LIST_H\n #define ARRAY_LIST_H\n "}, {"sha": "0c36604328fabaa85e57237fb54fdb1a02f0b611", "filename": "src/rt/util/indexed_list.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Futil%2Findexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Frt%2Futil%2Findexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Findexed_list.h?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++ -*-\n #ifndef INDEXED_LIST_H\n #define INDEXED_LIST_H\n "}, {"sha": "be9fed9ea1c834ff092d75a6da69b2d70fffc877", "filename": "src/test/run-pass/infinite-loops.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bc773465fe95da37b8c867979786b190de6197c/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bc773465fe95da37b8c867979786b190de6197c/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfinite-loops.rs?ref=4bc773465fe95da37b8c867979786b190de6197c", "patch": "@@ -0,0 +1,29 @@\n+/*\n+  A simple way to make sure threading works. This should use all the\n+  CPU cycles an any machines that we're likely to see for a while.\n+*/\n+\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+\n+use std;\n+import std::task::join;\n+\n+fn loop(int n) {\n+  let task t1;\n+  let task t2;\n+\n+  if(n > 0) {\n+    t1 = spawn loop(n - 1);\n+    t2 = spawn loop(n - 1);\n+  }\n+\n+  while(true) {}\n+}\n+\n+fn main() {\n+  let task t = spawn loop(5);\n+  join(t);\n+}"}]}