{"sha": "4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiN2FlOWZlZGMyMTU0YTMxZjA0NDAwYmFiYjFkZDBhOTNkZmZkMTY=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T13:24:04Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T14:26:25Z"}, "message": "generate Debug for enums", "tree": {"sha": "f3c74a25a118339d8c89f66c2e2d65567a122b5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c74a25a118339d8c89f66c2e2d65567a122b5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "html_url": "https://github.com/rust-lang/rust/commit/4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b7ae9fedc2154a31f04400babb1dd0a93dffd16/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1f2c7adcd926fdbe6b5ce10dcdc059acc147b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f2c7adcd926fdbe6b5ce10dcdc059acc147b3e", "html_url": "https://github.com/rust-lang/rust/commit/a1f2c7adcd926fdbe6b5ce10dcdc059acc147b3e"}], "stats": {"total": 81, "additions": 80, "deletions": 1}, "files": [{"sha": "8c3a5d25d9bba281462426c2ea252ade588ec590", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4b7ae9fedc2154a31f04400babb1dd0a93dffd16/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7ae9fedc2154a31f04400babb1dd0a93dffd16/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "patch": "@@ -181,7 +181,37 @@ fn impl_def_from_trait(\n fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n     match adt {\n         ast::Adt::Union(_) => {} // `Debug` cannot be derived for unions, so no default impl can be provided.\n-        ast::Adt::Enum(enum_) => {} // TODO\n+        ast::Adt::Enum(enum_) => {\n+            if let Some(list) = enum_.variant_list() {\n+                let mut arms = vec![];\n+                for variant in list.variants() {\n+                    let name = variant.name().unwrap();\n+\n+                    // => Self::<Variant>\n+                    let first = make::ext::ident_path(\"Self\");\n+                    let second = make::ext::ident_path(&format!(\"{}\", name));\n+                    let pat = make::path_pat(make::path_concat(first, second));\n+\n+                    // => write!(f, \"<Variant>\")\n+                    let target = make::expr_path(make::ext::ident_path(\"f\").into());\n+                    let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                    let args = make::arg_list(vec![target, fmt_string]);\n+                    let target = make::expr_path(make::ext::ident_path(\"write\"));\n+                    let expr = make::expr_macro_call(target, args);\n+\n+                    // => Self::<Variant> => write!(f, \"<Variant>\"),\n+                    arms.push(make::match_arm(Some(pat.into()), None, expr.into()));\n+                }\n+\n+                // => match self { ... }\n+                let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                let list = make::match_arm_list(arms);\n+                let expr = make::expr_match(f_path, list);\n+\n+                let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+                ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n+            }\n+        }\n         ast::Adt::Struct(strukt) => match strukt.field_list() {\n             Some(ast::FieldList::RecordFieldList(field_list)) => {\n                 let name = format!(\"\\\"{}\\\"\", annotated_name);\n@@ -383,6 +413,52 @@ impl fmt::Debug for Foo {\n         f.debug_struct(\"Foo\").finish()\n     }\n }\n+\"#,\n+        )\n+    }\n+    #[test]\n+    fn add_custom_impl_debug_enum() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+mod fmt {\n+    pub struct Error;\n+    pub type Result = Result<(), Error>;\n+    pub struct Formatter<'a>;\n+    pub trait Debug {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n+}\n+\n+#[derive(Debu$0g)]\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            r#\"\n+mod fmt {\n+    pub struct Error;\n+    pub type Result = Result<(), Error>;\n+    pub struct Formatter<'a>;\n+    pub trait Debug {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n+    }\n+}\n+\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+impl fmt::Debug for Foo {\n+    $0fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+        Self::Bar => write!(f, \"Bar\"),\n+        Self::Baz => write!(f, \"Baz\"),\n+        }\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "87faac0aa324506760a71cd89c356d81d9b8dba8", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b7ae9fedc2154a31f04400babb1dd0a93dffd16/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7ae9fedc2154a31f04400babb1dd0a93dffd16/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=4b7ae9fedc2154a31f04400babb1dd0a93dffd16", "patch": "@@ -311,6 +311,9 @@ pub fn expr_method_call(\n ) -> ast::Expr {\n     expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n }\n+pub fn expr_macro_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n+    expr_from_text(&format!(\"{}!{}\", f, arg_list))\n+}\n pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n     expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n }"}]}