{"sha": "5cae7a046922375352ca1ee33ae00df2123972ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYWU3YTA0NjkyMjM3NTM1MmNhMWVlMzNhZTAwZGYyMTIzOTcyYWQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-07T16:45:13Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-13T21:48:21Z"}, "message": "Check activation points as the place where mutable borrows become relevant.\n\nSince we are now checking activation points, I removed one of the\nchecks at the reservation point. (You can see the effect this had on\ntwo-phase-reservation-sharing-interference-2.rs)\n\nAlso, since we now have checks at both the reservation point and the\nactivation point, we sometimes would observe duplicate errors (since\neither one independently interferes with another mutable borrow).  To\ndeal with this, I used a similar strategy to one used as discussed on\nissue #45360: keep a set of errors reported (in this case for\nreservations), and then avoid doing the checks for the corresponding\nactivations. (This does mean that some errors could get masked, namely\nfor conflicting borrows that start after the reservation but still\nconflict with the activation, which is unchecked when there was an\nerror for the reservation. But this seems like a reasonable price to\npay.)", "tree": {"sha": "39a8b73704a310309342282c7cf6a888403f2b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39a8b73704a310309342282c7cf6a888403f2b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cae7a046922375352ca1ee33ae00df2123972ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cae7a046922375352ca1ee33ae00df2123972ad", "html_url": "https://github.com/rust-lang/rust/commit/5cae7a046922375352ca1ee33ae00df2123972ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cae7a046922375352ca1ee33ae00df2123972ad/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18aedf6b23db6f409f8d3073ab0c8ca923e9b141", "url": "https://api.github.com/repos/rust-lang/rust/commits/18aedf6b23db6f409f8d3073ab0c8ca923e9b141", "html_url": "https://github.com/rust-lang/rust/commit/18aedf6b23db6f409f8d3073ab0c8ca923e9b141"}], "stats": {"total": 207, "additions": 192, "deletions": 15}, "files": [{"sha": "e9d5bd365e2b31b1db1898a44eedb3edd74c4ac2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 120, "deletions": 4, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5cae7a046922375352ca1ee33ae00df2123972ad", "patch": "@@ -36,6 +36,7 @@ use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n use dataflow::{ActiveBorrows, Reservations};\n+use dataflow::indexes::{BorrowIndex};\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -222,6 +223,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         },\n         storage_dead_or_drop_error_reported_l: FxHashSet(),\n         storage_dead_or_drop_error_reported_s: FxHashSet(),\n+        reservation_error_reported: FxHashSet(),\n     };\n \n     let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n@@ -287,6 +289,14 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     storage_dead_or_drop_error_reported_l: FxHashSet<Local>,\n     /// Same as the above, but for statics (thread-locals)\n     storage_dead_or_drop_error_reported_s: FxHashSet<DefId>,\n+    /// This field keeps track of when borrow conflict errors are reported\n+    /// for reservations, so that we don't report seemingly duplicate\n+    /// errors for corresponding activations\n+    ///\n+    /// FIXME: Ideally this would be a set of BorrowIndex, not Places,\n+    /// but it is currently inconvenient to track down the BorrowIndex\n+    /// at the time we detect and report a reservation error.\n+    reservation_error_reported: FxHashSet<Place<'tcx>>,\n }\n \n // Check that:\n@@ -318,6 +328,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             flow_state\n         );\n         let span = stmt.source_info.span;\n+\n+        self.check_activations(location, span, flow_state);\n+\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 // NOTE: NLL RFC calls for *shallow* write; using Deep\n@@ -424,6 +437,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             flow_state\n         );\n         let span = term.source_info.span;\n+\n+        self.check_activations(location, span, flow_state);\n+\n         match term.kind {\n             TerminatorKind::SwitchInt {\n                 ref discr,\n@@ -557,7 +573,7 @@ enum Control {\n }\n \n use self::ShallowOrDeep::{Deep, Shallow};\n-use self::ReadOrWrite::{Read, Write};\n+use self::ReadOrWrite::{Activation, Read, Reservation, Write};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n@@ -592,6 +608,12 @@ enum ReadOrWrite {\n     /// new values or otherwise invalidated (for example, it could be\n     /// de-initialized, as in a move operation).\n     Write(WriteKind),\n+\n+    /// For two-phase borrows, we distinguish a reservation (which is treated\n+    /// like a Read) from an activation (which is treated like a write), and\n+    /// each of those is furthermore distinguished from Reads/Writes above.\n+    Reservation(WriteKind),\n+    Activation(WriteKind, BorrowIndex),\n }\n \n /// Kind of read access to a value\n@@ -680,6 +702,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> AccessErrorsReported {\n         let (sd, rw) = kind;\n \n+        if let Activation(_, borrow_index) = rw {\n+            if self.reservation_error_reported.contains(&place_span.0) {\n+                debug!(\"skipping access_place for activation of invalid reservation \\\n+                        place: {:?} borrow_index: {:?}\", place_span.0, borrow_index);\n+                return AccessErrorsReported { mutability_error: false, conflict_error: false };\n+            }\n+        }\n+\n         let mutability_error =\n             self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n         let conflict_error =\n@@ -702,9 +732,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (sd, place_span.0),\n             flow_state,\n             |this, index, borrow| match (rw, borrow.kind) {\n-                (Read(_), BorrowKind::Shared) => Control::Continue,\n+                // Obviously an activation is compatible with its own reservation;\n+                // so don't check if they interfere.\n+                (Activation(_, activating), _) if index.is_reservation() &&\n+                    activating == index.borrow_index() => Control::Continue,\n \n-                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n+                (Read(_), BorrowKind::Shared) |\n+                (Reservation(..), BorrowKind::Shared) => Control::Continue,\n+\n+                (Read(kind), BorrowKind::Unique) |\n+                (Read(kind), BorrowKind::Mut) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n                     if this.tcx.sess.opts.debugging_opts.two_phase_borrows &&\n                         index.is_reservation()\n@@ -734,13 +771,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                     Control::Break\n                 }\n+\n+                (Reservation(kind), BorrowKind::Unique) |\n+                (Reservation(kind), BorrowKind::Mut) |\n+                (Activation(kind, _), _) |\n                 (Write(kind), _) => {\n+\n+                    match rw {\n+                        Reservation(_) => {\n+                            debug!(\"recording invalid reservation of \\\n+                                    place: {:?}\", place_span.0);\n+                            this.reservation_error_reported.insert(place_span.0.clone());\n+                        }\n+                        Activation(_, activating) => {\n+                            debug!(\"observing check_place for activation of \\\n+                                    borrow_index: {:?}\", activating);\n+                        }\n+                        Read(..) | Write(..) => {}\n+                    }\n+\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n+\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n@@ -827,16 +883,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let access_kind = match bk {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut => {\n-                        (Deep, Write(WriteKind::MutableBorrow(bk)))\n+                        let wk = WriteKind::MutableBorrow(bk);\n+                        if self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+                            (Deep, Reservation(wk))\n+                        } else {\n+                            (Deep, Write(wk))\n+                        }\n                     }\n                 };\n+\n                 self.access_place(\n                     context,\n                     (place, span),\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n+\n                 self.check_if_path_is_moved(\n                     context,\n                     InitializationRequiringAction::Borrow,\n@@ -1007,6 +1070,49 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             )\n         }\n     }\n+\n+    fn check_activations(&mut self,\n+                         location: Location,\n+                         span: Span,\n+                         flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+    {\n+        if !self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+            return;\n+        }\n+\n+        // Two-phase borrow support: For each activation that is newly\n+        // generated at this statement, check if it interferes with\n+        // another borrow.\n+        let domain = flow_state.borrows.operator();\n+        let data = domain.borrows();\n+        flow_state.borrows.each_gen_bit(|gen| {\n+            if gen.is_activation() && // must be activation,\n+                !flow_state.borrows.contains(&gen) // and newly generated.\n+            {\n+                let borrow_index = gen.borrow_index();\n+                let borrow = &data[borrow_index];\n+                // currently the flow analysis registers\n+                // activations for both mutable and immutable\n+                // borrows. So make sure we are talking about a\n+                // mutable borrow before we check it.\n+                match borrow.kind {\n+                    BorrowKind::Shared => return,\n+                    BorrowKind::Unique |\n+                    BorrowKind::Mut => {}\n+                }\n+\n+                self.access_place(ContextKind::Activation.new(location),\n+                                  (&borrow.borrowed_place, span),\n+                                  (Deep, Activation(WriteKind::MutableBorrow(borrow.kind),\n+                                                    borrow_index)),\n+                                  LocalMutationIsAllowed::No,\n+                                  flow_state);\n+                // We do not need to call `check_if_path_is_moved`\n+                // again, as we already called it when we made the\n+                // initial reservation.\n+            }\n+        });\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -1250,11 +1356,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         let mut error_reported = false;\n         match kind {\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique)) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n                 if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut)) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n                 self.is_mutable(place, is_local_mutation_allowed)\n             {\n@@ -1277,6 +1385,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 err.emit();\n             },\n+            Reservation(WriteKind::Mutate) |\n             Write(WriteKind::Mutate) => {\n                 if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n@@ -1298,6 +1407,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n+            Reservation(WriteKind::Move) |\n+            Reservation(WriteKind::StorageDeadOrDrop) |\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Shared)) |\n             Write(WriteKind::Move) |\n             Write(WriteKind::StorageDeadOrDrop) |\n             Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n@@ -1312,6 +1424,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                 }\n             }\n+\n+            Activation(..) => {} // permission checks are done at Reservation point.\n+\n             Read(ReadKind::Borrow(BorrowKind::Unique)) |\n             Read(ReadKind::Borrow(BorrowKind::Mut)) |\n             Read(ReadKind::Borrow(BorrowKind::Shared)) |\n@@ -1892,6 +2007,7 @@ struct Context {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ContextKind {\n+    Activation,\n     AssignLhs,\n     AssignRhs,\n     SetDiscrim,"}, {"sha": "b6f5e17f1f609f2e62cf7055cae5630c03f0f268", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=5cae7a046922375352ca1ee33ae00df2123972ad", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// This is an important corner case pointed out by Niko: one is\n+// allowed to initiate a shared borrow during a reservation, but it\n+// *must end* before the activation occurs.\n+//\n+// FIXME: for clarity, diagnostics for these cases might be better off\n+// if they specifically said \"cannot activate mutable borrow of `x`\"\n+\n+#![allow(dead_code)]\n+\n+fn read(_: &i32) { }\n+\n+fn ok() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    { let z = &x; read(z); }\n+    *y += 1;\n+}\n+\n+fn not_ok() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let z = &x;\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    read(z);\n+}\n+\n+fn should_be_ok_with_nll() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let z = &x;\n+    read(z);\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    // (okay with nll today)\n+}\n+\n+fn should_also_eventually_be_ok_with_nll() {\n+    let mut x = 3;\n+    let y = &mut x;\n+    let _z = &x;\n+    *y += 1;\n+    //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+}\n+\n+fn main() { }"}, {"sha": "fc9100c8a9a865f493319b2bd9444b82222e844f", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference-2.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cae7a046922375352ca1ee33ae00df2123972ad/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs?ref=5cae7a046922375352ca1ee33ae00df2123972ad", "patch": "@@ -15,24 +15,23 @@\n // This is similar to two-phase-reservation-sharing-interference.rs\n // in that it shows a reservation that overlaps with a shared borrow.\n //\n-// However, it is also more immediately concerning because one would\n-// intutively think that if run-pass/borrowck/two-phase-baseline.rs\n-// works, then this *should* work too.\n+// Currently, this test fails with lexical lifetimes, but succeeds\n+// with non-lexical lifetimes. (The reason is because the activation\n+// of the mutable borrow ends up overlapping with a lexically-scoped\n+// shared borrow; but a non-lexical shared borrow can end before the\n+// activation occurs.)\n //\n-// As before, the current implementation is (probably) more\n-// conservative than is necessary.\n-//\n-// So this test is just making a note of the current behavior, with\n-// the caveat that in the future, the rules may be loosened, at which\n-// point this test might be thrown out.\n+// So this test is just making a note of the current behavior.\n+\n+#![feature(rustc_attrs)]\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //[nll]~ ERROR compilation successful\n     let mut v = vec![0, 1, 2];\n     let shared = &v;\n \n     v.push(shared.len());\n     //[lxl]~^  ERROR cannot borrow `v` as mutable because it is also borrowed as immutable [E0502]\n-    //[nll]~^^ ERROR cannot borrow `v` as mutable because it is also borrowed as immutable [E0502]\n \n     assert_eq!(v, [0, 1, 2, 3]);\n }"}]}