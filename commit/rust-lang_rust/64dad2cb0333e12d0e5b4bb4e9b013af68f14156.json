{"sha": "64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZGFkMmNiMDMzM2UxMmQwZTViNGJiNGU5YjAxM2FmNjhmMTQxNTY=", "commit": {"author": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-12T17:31:13Z"}, "committer": {"name": "Alan Andrade", "email": "alan.andradec@gmail.com", "date": "2014-05-24T01:52:06Z"}, "message": "Cleanup lifetime guide\nClean pointers guide", "tree": {"sha": "25232ed5bba0b7dcabc77dae53b1a084df1a6085", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25232ed5bba0b7dcabc77dae53b1a084df1a6085"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "html_url": "https://github.com/rust-lang/rust/commit/64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64dad2cb0333e12d0e5b4bb4e9b013af68f14156/comments", "author": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alan-andrade", "id": 97609, "node_id": "MDQ6VXNlcjk3NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/97609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alan-andrade", "html_url": "https://github.com/alan-andrade", "followers_url": "https://api.github.com/users/alan-andrade/followers", "following_url": "https://api.github.com/users/alan-andrade/following{/other_user}", "gists_url": "https://api.github.com/users/alan-andrade/gists{/gist_id}", "starred_url": "https://api.github.com/users/alan-andrade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alan-andrade/subscriptions", "organizations_url": "https://api.github.com/users/alan-andrade/orgs", "repos_url": "https://api.github.com/users/alan-andrade/repos", "events_url": "https://api.github.com/users/alan-andrade/events{/privacy}", "received_events_url": "https://api.github.com/users/alan-andrade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44626874574db4040f3fc2964a35ddf50927ef1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/44626874574db4040f3fc2964a35ddf50927ef1a", "html_url": "https://github.com/rust-lang/rust/commit/44626874574db4040f3fc2964a35ddf50927ef1a"}], "stats": {"total": 396, "additions": 92, "deletions": 304}, "files": [{"sha": "e0e33337c9a7a006138bc9947442528aa852805e", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 69, "deletions": 156, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/64dad2cb0333e12d0e5b4bb4e9b013af68f14156/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/64dad2cb0333e12d0e5b4bb4e9b013af68f14156/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "patch": "@@ -3,14 +3,12 @@\n # Introduction\n \n References are one of the more flexible and powerful tools available in\n-Rust. A reference can point anywhere: into the managed or exchange\n-heap, into the stack, and even into the interior of another data structure. A\n-reference is as flexible as a C pointer or C++ reference. However,\n-unlike C and C++ compilers, the Rust compiler includes special static checks\n-that ensure that programs use references safely. Another advantage of\n-references is that they are invisible to the garbage collector, so\n-working with references helps reduce the overhead of automatic memory\n-management.\n+Rust. They can point anywhere: into the heap, stack, and even into the\n+interior of another data structure. A reference is as flexible as a C pointer\n+or C++ reference.\n+\n+Unlike C and C++ compilers, the Rust compiler includes special static\n+checks that ensure that programs use references safely.\n \n Despite their complete safety, a reference's representation at runtime\n is the same as that of an ordinary pointer in a C program. They introduce zero\n@@ -26,7 +24,7 @@ through several examples.\n \n References, sometimes known as *borrowed pointers*, are only valid for\n a limited duration. References never claim any kind of ownership\n-over the data that they point to: instead, they are used for cases\n+over the data that they point to, instead, they are used for cases\n where you would like to use data for a short time.\n \n As an example, consider a simple struct type `Point`:\n@@ -36,27 +34,23 @@ struct Point {x: f64, y: f64}\n ~~~\n \n We can use this simple definition to allocate points in many different ways. For\n-example, in this code, each of these three local variables contains a\n-point, but allocated in a different place:\n+example, in this code, each of these local variables contains a point,\n+but allocated in a different place:\n \n ~~~\n # struct Point {x: f64, y: f64}\n-let on_the_stack :  Point     =     Point {x: 3.0, y: 4.0};\n-let managed_box  : @Point     =    @Point {x: 5.0, y: 1.0};\n-let owned_box    : Box<Point> = box Point {x: 7.0, y: 9.0};\n+let on_the_stack : Point      =     Point {x: 3.0, y: 4.0};\n+let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance between any\n-two points, no matter where they were stored. For example, we might like to\n-compute the distance between `on_the_stack` and `managed_box`, or between\n-`managed_box` and `owned_box`. One option is to define a function that takes\n-two arguments of type `Point`\u2014that is, it takes the points by value. But if we\n-define it this way, calling the function will cause the points to be\n-copied. For points, this is probably not so bad, but often copies are\n+two points, no matter where they were stored. One option is to define a function\n+that takes two arguments of type `Point`\u2014that is, it takes the points __by value__.\n+But if we define it this way, calling the function will cause the points __to be\n+copied__. For points, this is probably not so bad, but often copies are\n expensive. Worse, if the data type contains mutable fields, copying can change\n-the semantics of your program in unexpected ways. So we'd like to define a\n-function that takes the points by pointer. We can use references to do\n-this:\n+the semantics of your program in unexpected ways. So we'd like to define\n+a function that takes the points just as a __reference__/__borrowed pointer__.\n \n ~~~\n # struct Point {x: f64, y: f64}\n@@ -68,30 +62,27 @@ fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n }\n ~~~\n \n-Now we can call `compute_distance()` in various ways:\n+Now we can call `compute_distance()`\n \n ~~~\n # struct Point {x: f64, y: f64}\n # let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n-# let managed_box  :    @Point  =    @Point{x: 5.0, y: 1.0};\n-# let owned_box    : Box<Point> = box Point{x: 7.0, y: 9.0};\n+# let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, managed_box);\n-compute_distance(managed_box, owned_box);\n+compute_distance(&on_the_stack, on_the_heap);\n ~~~\n \n Here, the `&` operator takes the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we have created an alias: that is, another\n+`on_the_stack`, because we have created __an alias__: that is, another\n name for the same data.\n \n-In contrast, we can pass the boxes `managed_box` and `owned_box` to\n-`compute_distance` directly. The compiler automatically converts a box like\n-`@Point` or `~Point` to a reference like `&Point`. This is another form\n-of borrowing: in this case, the caller lends the contents of the managed or\n-owned box to the callee.\n+In contrast, we can pass `on_the_heap` to `compute_distance` directly.\n+The compiler automatically converts a box like `Box<Point>` to a reference like\n+`&Point`. This is another form of borrowing: in this case, the caller lends\n+the contents of the box to the callee.\n \n Whenever a caller lends data to a callee, there are some limitations on what\n the caller can do with the original. For example, if the contents of a\n@@ -134,10 +125,10 @@ let on_the_stack2 : &Point = &tmp;\n \n # Taking the address of fields\n \n-As in C, the `&` operator is not limited to taking the address of\n+The `&` operator is not limited to taking the address of\n local variables. It can also take the address of fields or\n individual array elements. For example, consider this type definition\n-for `rectangle`:\n+for `Rectangle`:\n \n ~~~\n struct Point {x: f64, y: f64} // as before\n@@ -153,9 +144,7 @@ Now, as before, we can define rectangles in a few different ways:\n # struct Rectangle {origin: Point, size: Size}\n let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n                                   size: Size {w: 3.0, h: 4.0}};\n-let rect_managed =    @Rectangle {origin: Point {x: 3.0, y: 4.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-let rect_owned   = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n+let rect_heap    = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n                                   size: Size {w: 3.0, h: 4.0}};\n ~~~\n \n@@ -167,109 +156,29 @@ operator. For example, I could write:\n # struct Size {w: f64, h: f64} // as before\n # struct Rectangle {origin: Point, size: Size}\n # let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_managed = @Rectangle {origin: Point {x: 3.0, y: 4.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_owned = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n+# let rect_heap   = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n # fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&rect_stack.origin, &rect_managed.origin);\n+compute_distance(&rect_stack.origin, &rect_heap.origin);\n ~~~\n \n which would borrow the field `origin` from the rectangle on the stack\n-as well as from the managed box, and then compute the distance between them.\n+as well as from the owned box, and then compute the distance between them.\n \n-# Borrowing managed boxes and rooting\n+# Lifetimes\n \n-We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n-and owned. Up till this point, we\u2019ve glossed over issues of\n-safety. As stated in the introduction, at runtime a reference\n-is simply a pointer, nothing more. Therefore, avoiding C's problems\n-with dangling pointers requires a compile-time safety check.\n+We\u2019ve seen a few examples of borrowing data. Up till this point, we\u2019ve glossed\n+over issues of safety. As stated in the introduction, at runtime a reference\n+is simply a pointer, nothing more. Therefore, avoiding C's problems with\n+dangling pointers requires a compile-time safety check.\n \n-The basis for the check is the notion of _lifetimes_. A lifetime is a\n+The basis for the check is the notion of __lifetimes__. A lifetime is a\n static approximation of the span of execution during which the pointer\n is valid: it always corresponds to some expression or block within the\n-program. Code inside that expression can use the pointer without\n-restrictions. But if the pointer escapes from that expression (for\n-example, if the expression contains an assignment expression that\n-assigns the pointer to a mutable field of a data structure with a\n-broader scope than the pointer itself), the compiler reports an\n-error. We'll be discussing lifetimes more in the examples to come, and\n-a more thorough introduction is also available.\n-\n-When the `&` operator creates a reference, the compiler must\n-ensure that the pointer remains valid for its entire\n-lifetime. Sometimes this is relatively easy, such as when taking the\n-address of a local variable or a field that is stored on the stack:\n-\n-~~~\n-struct X { f: int }\n-fn example1() {\n-    let mut x = X { f: 3 };\n-    let y = &mut x.f;  // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-Here, the lifetime of the reference `y` is simply L, the\n-remainder of the function body. The compiler need not do any other\n-work to prove that code will not free `x.f`. This is true even if the\n-code mutates `x`.\n-\n-The situation gets more complex when borrowing data inside heap boxes:\n-\n-~~~\n-# struct X { f: int }\n-fn example2() {\n-    let mut x = @X { f: 3 };\n-    let y = &x.f;      // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-In this example, the value `x` is a heap box, and `y` is therefore a\n-pointer into that heap box. Again the lifetime of `y` is L, the\n-remainder of the function body. But there is a crucial difference:\n-suppose `x` were to be reassigned during the lifetime L? If the\n-compiler isn't careful, the managed box could become *unrooted*, and\n-would therefore be subject to garbage collection. A heap box that is\n-unrooted is one such that no pointer values in the heap point to\n-it. It would violate memory safety for the box that was originally\n-assigned to `x` to be garbage-collected, since a non-heap\n-pointer *`y`* still points into it.\n-\n-> *Note:* Our current implementation implements the garbage collector\n-> using reference counting and cycle detection.\n-\n-For this reason, whenever an `&` expression borrows the interior of a\n-managed box stored in a mutable location, the compiler inserts a\n-temporary that ensures that the managed box remains live for the\n-entire lifetime. So, the above example would be compiled as if it were\n-written\n-\n-~~~\n-# struct X { f: int }\n-fn example2() {\n-    let mut x = @X {f: 3};\n-    let x1 = x;\n-    let y = &x1.f;     // -+ L\n-    // ...             //  |\n-}                      // -+\n-~~~\n-\n-Now if `x` is reassigned, the pointer `y` will still remain valid. This\n-process is called *rooting*.\n-\n-# Borrowing owned boxes\n-\n-The previous example demonstrated *rooting*, the process by which the\n-compiler ensures that managed boxes remain live for the duration of a\n-borrow. Unfortunately, rooting does not work for borrows of owned\n-boxes, because it is not possible to have two references to an owned\n-box.\n-\n-For owned boxes, therefore, the compiler will only allow a borrow *if\n-the compiler can guarantee that the owned box will not be reassigned\n-or moved for the lifetime of the pointer*. This does not necessarily\n-mean that the owned box is stored in immutable memory. For example,\n+program.\n+\n+The compiler will only allow a borrow *if it can guarantee that the data will\n+not be reassigned or moved for the lifetime of the pointer*. This does not\n+necessarily mean that the data is stored in immutable memory. For example,\n the following function is legal:\n \n ~~~\n@@ -294,7 +203,7 @@ and `x` is declared as mutable. However, the compiler can prove that\n and in fact is mutated later in the function.\n \n It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any owned box\n+variable. The reason is that the runtime system frees any box\n _as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n@@ -337,31 +246,34 @@ Once the reassignment occurs, the memory will look like this:\n                              +---------+\n ~~~\n \n-Here you can see that the variable `y` still points at the old box,\n-which has been freed.\n+Here you can see that the variable `y` still points at the old `f`\n+property of Foo, which has been freed.\n \n In fact, the compiler can apply the same kind of reasoning to any\n-memory that is _(uniquely) owned by the stack frame_. So we could\n+memory that is (uniquely) owned by the stack frame. So we could\n modify the previous example to introduce additional owned pointers\n and structs, and the compiler will still be able to detect possible\n-mutations:\n+mutations. This time, we'll use an analogy to illustrate the concept.\n \n ~~~ {.ignore}\n fn example3() -> int {\n-    struct R { g: int }\n-    struct S { f: Box<R> }\n+    struct House { owner: Box<Person> }\n+    struct Person { age: int }\n \n-    let mut x = box S {f: box R {g: 3}};\n-    let y = &x.f.g;\n-    x = box S {f: box R {g: 4}};  // Error reported here.\n-    x.f = box R {g: 5};           // Error reported here.\n-    *y\n+    let mut house = box House {\n+        owner: box Person {age: 30}\n+    };\n+\n+    let owner_age = &house.owner.age;\n+    house = box House {owner: box Person {age: 40}};  // Error reported here.\n+    house.owner = box Person {age: 50};               // Error reported here.\n+    *owner_age\n }\n ~~~\n \n-In this case, two errors are reported, one when the variable `x` is\n-modified and another when `x.f` is modified. Either modification would\n-invalidate the pointer `y`.\n+In this case, two errors are reported, one when the variable `house` is\n+modified and another when `house.owner` is modified. Either modification would\n+invalidate the pointer `owner_age`.\n \n # Borrowing and enums\n \n@@ -412,7 +324,7 @@ circle constant][tau] and not that dreadfully outdated notion of pi).\n \n The second match is more interesting. Here we match against a\n rectangle and extract its size: but rather than copy the `size`\n-struct, we use a by-reference binding to create a pointer to it. In\n+struct, we use a __by-reference binding__ to create a pointer to it. In\n other words, a pattern binding like `ref size` binds the name `size`\n to a pointer of type `&size` into the _interior of the enum_.\n \n@@ -526,12 +438,12 @@ time one that does not compile:\n \n ~~~ {.ignore}\n struct Point {x: f64, y: f64}\n-fn get_x_sh(p: @Point) -> &f64 {\n+fn get_x_sh(p: &Point) -> &f64 {\n     &p.x // Error reported here\n }\n ~~~\n \n-Here, the function `get_x_sh()` takes a managed box as input and\n+Here, the function `get_x_sh()` takes a reference as input and\n returns a reference. As before, the lifetime of the reference\n that will be returned is a parameter (specified by the\n caller). That means that `get_x_sh()` promises to return a reference\n@@ -540,17 +452,18 @@ subtly different from the first example, which promised to return a\n pointer that was valid for as long as its pointer argument was valid.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a managed box. The presence of this expression\n-implies that the compiler must guarantee that, so long as the\n-resulting pointer is valid, the managed box will not be reclaimed by\n-the garbage collector. But recall that `get_x_sh()` also promised to\n+address of a field of a Point. The presence of this expression\n+implies that the compiler must guarantee that , so long as the\n+resulting pointer is valid, the original Point won't be moved or changed.\n+\n+But recall that `get_x_sh()` also promised to\n return a pointer that was valid for as long as the caller wanted it to\n be. Clearly, `get_x_sh()` is not in a position to make both of these\n guarantees; in fact, it cannot guarantee that the pointer will remain\n valid at all once it returns, as the parameter `p` may or may not be\n live in the caller. Therefore, the compiler will report an error here.\n \n-In general, if you borrow a managed (or owned) box to create a\n+In general, if you borrow a structs or boxes to create a\n reference, it will only be valid within the function\n and cannot be returned. This is why the typical way to return references\n is to take references as input (the only other case in"}, {"sha": "bee1dbcd2ce90345186977f7390014f1a0fe0017", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 23, "deletions": 148, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/64dad2cb0333e12d0e5b4bb4e9b013af68f14156/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/64dad2cb0333e12d0e5b4bb4e9b013af68f14156/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=64dad2cb0333e12d0e5b4bb4e9b013af68f14156", "patch": "@@ -5,7 +5,7 @@ are also one of the more confusing topics for newcomers to Rust. They can also\n be confusing for people coming from other languages that support pointers, such\n as C++. This guide will help you understand this important topic.\n \n-# You don't actually need pointers\n+# You don't actually need pointers, use references\n \n I have good news for you: you probably don't need to care about pointers,\n especially as you're getting started. Think of it this way: Rust is a language\n@@ -37,7 +37,7 @@ error: mismatched types: expected `&int` but found `<generic integer #0>` (expec\n \n What gives? It needs a pointer! Therefore I have to use pointers!\"\n \n-Turns out, you don't. All you need is a reference. Try this on for size:\n+Turns out, you don't. __All you need is a reference__. Try this on for size:\n \n ~~~rust\n # fn succ(x: &int) -> int { *x + 1 }\n@@ -74,22 +74,22 @@ Here are the use-cases for pointers. I've prefixed them with the name of the\n pointer that satisfies that use-case:\n \n 1. Owned: `Box<Trait>` must be a pointer, because you don't know the size of the\n-object, so indirection is mandatory.\n+object, so indirection is mandatory. Notation might change once Rust\n+support DST fully so we recommend you stay tuned.\n+\n 2. Owned: You need a recursive data structure. These can be infinite sized, so\n indirection is mandatory.\n+\n 3. Owned: A very, very, very rare situation in which you have a *huge* chunk of\n data that you wish to pass to many methods. Passing a pointer will make this\n more efficient. If you're coming from another language where this technique is\n common, such as C++, please read \"A note...\" below.\n-4. Managed: Having only a single owner to a piece of data would be inconvenient\n-or impossible. This is only often useful when a program is very large or very\n-complicated. Using a managed pointer will activate Rust's garbage collection\n-mechanism.\n-5. Reference: You're writing a function, and you need a pointer, but you don't\n+\n+4. Reference: You're writing a function, and you need a pointer, but you don't\n care about its ownership. If you make the argument a reference, callers\n can send in whatever kind they want.\n \n-Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n+Four exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n of pointers in Rust: use them for a deliberate purpose, not just to make the\n compiler happy.\n \n@@ -165,6 +165,7 @@ approximation of owned pointers follows:\n \n 1. Only one owned pointer may exist to a particular place in memory. It may be\n borrowed from that owner, however.\n+\n 2. The Rust compiler uses static analysis to determine where the pointer is in\n scope, and handles allocating and de-allocating that memory. Owned pointers are\n not garbage collected.\n@@ -204,6 +205,10 @@ The inner lists _must_ be an owned pointer, because we can't know how many\n elements are in the list. Without knowing the length, we don't know the size,\n and therefore require the indirection that pointers offer.\n \n+> Note: Nil is just part of the List enum and even though is being used\n+> to represent the concept of \"nothing\", you shouldn't think of it as\n+> NULL. Rust doesn't have NULL.\n+\n ## Efficiency\n \n This should almost never be a concern, but because creating an owned pointer\n@@ -248,81 +253,6 @@ fn main() {\n Now it'll be copying a pointer-sized chunk of memory rather than the whole\n struct.\n \n-# Managed Pointers\n-\n-> **Note**: the `@` form of managed pointers is deprecated and behind a\n-> feature gate (it requires a `#![feature(managed_pointers)]` attribute on\n-> the crate root). There are replacements, currently\n-> there is `std::rc::Rc` and `std::gc::Gc` for shared ownership via reference\n-> counting and garbage collection respectively.\n-\n-Managed pointers, notated by an `@`, are used when having a single owner for\n-some data isn't convenient or possible. This generally happens when your\n-program is very large and complicated.\n-\n-For example, let's say you're using an owned pointer, and you want to do this:\n-\n-~~~rust{.ignore}\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n-\n-fn main() {\n-    let a = box Point { x: 10, y: 20 };\n-    let b = a;\n-    println!(\"{}\", b.x);\n-    println!(\"{}\", a.x);\n-}\n-~~~\n-\n-You'll get this error:\n-\n-~~~ {.notrust}\n-test.rs:10:20: 10:21 error: use of moved value: `a`\n-test.rs:10     println!(\"{}\", a.x);\n-                              ^\n-note: in expansion of format_args!\n-<std-macros>:158:27: 158:81 note: expansion site\n-<std-macros>:157:5: 159:6 note: in expansion of println!\n-test.rs:10:5: 10:25 note: expansion site\n-test.rs:8:9: 8:10 note: `a` moved here because it has type `Box<Point>`, which is moved by default (use `ref` to override)\n-test.rs:8     let b = a;\n-                  ^\n-~~~\n-\n-As the message says, owned pointers only allow for one owner at a time. When you assign `a` to `b`, `a` becomes invalid. Change your code to this, however:\n-\n-~~~rust\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n-\n-fn main() {\n-    let a = @Point { x: 10, y: 20 };\n-    let b = a;\n-    println!(\"{}\", b.x);\n-    println!(\"{}\", a.x);\n-}\n-~~~\n-\n-And it works:\n-\n-~~~ {.notrust}\n-10\n-10\n-~~~\n-\n-So why not just use managed pointers everywhere? There are two big drawbacks to\n-managed pointers:\n-\n-1. They activate Rust's garbage collector. Other pointer types don't share this\n-drawback.\n-2. You cannot pass this data to another task. Shared ownership across\n-concurrency boundaries is the source of endless pain in other languages, so\n-Rust does not let you do this.\n-\n # References\n \n References are the third major kind of pointer Rust supports. They are\n@@ -346,16 +276,17 @@ fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n }\n \n fn main() {\n-    let origin =    @Point { x: 0.0, y: 0.0 };\n+    let origin =    &Point { x: 0.0, y: 0.0 };\n     let p1     = box Point { x: 5.0, y: 3.0 };\n \n     println!(\"{:?}\", compute_distance(origin, p1));\n }\n ~~~\n \n This prints `5.83095189`. You can see that the `compute_distance` function\n-takes in two references, but we give it a managed and unique pointer. Of\n-course, if this were a real program, we wouldn't have any of these pointers,\n+takes in two references, but we give it a stack allocated reference and an\n+owned box reference.\n+Of course, if this were a real program, we wouldn't have any of these pointers,\n they're just there to demonstrate the concepts.\n \n So how is this hard? Well, because we're ignoring ownership, the compiler needs\n@@ -364,9 +295,11 @@ safety, a reference's representation at runtime is the same as that of\n an ordinary pointer in a C program. They introduce zero overhead. The compiler\n does all safety checks at compile time.\n \n-This theory is called 'region pointers,' and involve a concept called\n-'lifetimes'. Here's the simple explanation: would you expect this code to\n-compile?\n+This theory is called 'region pointers' and you can read more about it\n+[here](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n+Region pointers evolved into what we know today as 'lifetimes'.\n+\n+Here's the simple explanation: would you expect this code to compile?\n \n ~~~rust{.ignore}\n fn main() {\n@@ -428,64 +361,6 @@ hard for a computer, too! There is an entire [guide devoted to references\n and lifetimes](guide-lifetimes.html) that goes into lifetimes in\n great detail, so if you want the full details, check that out.\n \n-# Returning Pointers\n-\n-We've talked a lot about functions that accept various kinds of pointers, but\n-what about returning them? In general, it is better to let the caller decide\n-how to use a function's output, instead of assuming a certain type of pointer\n-is best.\n-\n-What does that mean? Don't do this:\n-\n-~~~rust\n-fn foo(x: Box<int>) -> Box<int> {\n-    return box *x;\n-}\n-\n-fn main() {\n-    let x = box 5;\n-    let y = foo(x);\n-}\n-~~~\n-\n-Do this:\n-\n-~~~rust\n-fn foo(x: Box<int>) -> int {\n-    return *x;\n-}\n-\n-fn main() {\n-    let x = box 5;\n-    let y = box foo(x);\n-}\n-~~~\n-\n-This gives you flexibility, without sacrificing performance. For example, this will\n-also work:\n-\n-~~~rust\n-fn foo(x: Box<int>) -> int {\n-    return *x;\n-}\n-\n-fn main() {\n-    let x = box 5;\n-    let y = @foo(x);\n-}\n-~~~\n-\n-You may think that this gives us terrible performance: return a value and then\n-immediately box it up?!?! Isn't that the worst of both worlds? Rust is smarter\n-than that. There is no copy in this code. `main` allocates enough room for the\n-`@int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n-the value straight into that pointer. This writes the return value directly into\n-the allocated box.\n-\n-This is important enough that it bears repeating: pointers are not for optimizing\n-returning values from your code. Allow the caller to choose how they want to\n-use your output.\n-\n \n # Related Resources\n "}]}