{"sha": "2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "node_id": "C_kwDOAAsO6NoAKDJhNzA0MzllZjA4MGY5YjBhMmJmMDhkMTI0MDM1YWMxMjBjNmUwZWU", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T19:36:24Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `overlapping_arms`", "tree": {"sha": "34a1721e3832fc9c407ea48a703a3d98126b8681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34a1721e3832fc9c407ea48a703a3d98126b8681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "html_url": "https://github.com/rust-lang/rust/commit/2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a70439ef080f9b0a2bf08d124035ac120c6e0ee/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3dd909e0f2900420915f55a3f6cea6000b18cad", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3dd909e0f2900420915f55a3f6cea6000b18cad", "html_url": "https://github.com/rust-lang/rust/commit/f3dd909e0f2900420915f55a3f6cea6000b18cad"}], "stats": {"total": 364, "additions": 186, "deletions": 178}, "files": [{"sha": "a7fc399bfe2292dd7f551e46f11437d6845fc427", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 178, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/2a70439ef080f9b0a2bf08d124035ac120c6e0ee/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a70439ef080f9b0a2bf08d124035ac120c6e0ee/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n@@ -19,18 +18,18 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n     self as hir, Arm, BindingAnnotation, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n-    PatKind, PathSegment, QPath, RangeEnd, TyKind,\n+    PatKind, PathSegment, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, VariantDef};\n+use rustc_middle::ty::{self, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, symbol::kw, Span};\n-use std::cmp::Ordering;\n+use rustc_span::{sym, symbol::kw};\n \n mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n+mod overlapping_arms;\n mod redundant_pattern_match;\n mod single_match;\n \n@@ -632,7 +631,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n             single_match::check(cx, ex, arms, expr);\n             match_bool::check(cx, ex, arms, expr);\n-            check_overlapping_arms(cx, ex, arms);\n+            overlapping_arms::check(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_wild_enum_match(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n@@ -710,24 +709,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        if !ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&ranges) {\n-                span_lint_and_note(\n-                    cx,\n-                    MATCH_OVERLAPPING_ARM,\n-                    start.span,\n-                    \"some ranges overlap\",\n-                    Some(end.span),\n-                    \"overlaps with this\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n     let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n     if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n@@ -1219,59 +1200,6 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n     None\n }\n \n-/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n-    arms.iter()\n-        .filter_map(|arm| {\n-            if let Arm { pat, guard: None, .. } = *arm {\n-                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n-                    };\n-                    let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n-                    };\n-\n-                    let lhs_val = lhs_const.int_value(cx, ty)?;\n-                    let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n-                    let rhs_bound = match range_end {\n-                        RangeEnd::Included => EndBound::Included(rhs_val),\n-                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n-                    };\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (lhs_val, rhs_bound),\n-                    });\n-                }\n-\n-                if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (value, EndBound::Included(value)),\n-                    });\n-                }\n-            }\n-            None\n-        })\n-        .collect()\n-}\n-\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum EndBound<T> {\n-    Included(T),\n-    Excluded(T),\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-struct SpannedRange<T> {\n-    pub span: Span,\n-    pub node: (T, EndBound<T>),\n-}\n-\n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n@@ -1317,104 +1245,3 @@ where\n     }\n     ref_count > 1\n }\n-\n-fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-where\n-    T: Copy + Ord,\n-{\n-    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-    enum BoundKind {\n-        EndExcluded,\n-        Start,\n-        EndIncluded,\n-    }\n-\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n-\n-    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n-        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n-        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n-            let RangeBound(self_value, self_kind, _) = *self;\n-            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n-        }\n-    }\n-\n-    let mut values = Vec::with_capacity(2 * ranges.len());\n-\n-    for r @ SpannedRange { node: (start, end), .. } in ranges {\n-        values.push(RangeBound(*start, BoundKind::Start, r));\n-        values.push(match end {\n-            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n-            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n-        });\n-    }\n-\n-    values.sort();\n-\n-    let mut started = vec![];\n-\n-    for RangeBound(_, kind, range) in values {\n-        match kind {\n-            BoundKind::Start => started.push(range),\n-            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n-                let mut overlap = None;\n-\n-                while let Some(last_started) = started.pop() {\n-                    if last_started == range {\n-                        break;\n-                    }\n-                    overlap = Some(last_started);\n-                }\n-\n-                if let Some(first_overlapping) = overlap {\n-                    return Some((range, first_overlapping));\n-                }\n-            },\n-        }\n-    }\n-\n-    None\n-}\n-\n-#[test]\n-fn test_overlapping() {\n-    use rustc_span::source_map::DUMMY_SP;\n-\n-    let sp = |s, e| SpannedRange {\n-        span: DUMMY_SP,\n-        node: (s, e),\n-    };\n-\n-    assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n-    assert_eq!(\n-        None,\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        None,\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(10, EndBound::Included(11))\n-        ],)\n-    );\n-    assert_eq!(\n-        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(6, EndBound::Included(11))\n-        ],)\n-    );\n-}"}, {"sha": "7e658126690299787f1410a713533a78d8c60a06", "filename": "clippy_lints/src/matches/overlapping_arms.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/2a70439ef080f9b0a2bf08d124035ac120c6e0ee/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a70439ef080f9b0a2bf08d124035ac120c6e0ee/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "patch": "@@ -0,0 +1,181 @@\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use core::cmp::Ordering;\n+use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+use super::MATCH_OVERLAPPING_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n+                span_lint_and_note(\n+                    cx,\n+                    MATCH_OVERLAPPING_ARM,\n+                    start.span,\n+                    \"some ranges overlap\",\n+                    Some(end.span),\n+                    \"overlaps with this\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { pat, guard: None, .. } = *arm {\n+                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n+                    let lhs_const = match lhs {\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                    };\n+                    let rhs_const = match rhs {\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                    };\n+\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n+\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n+                    };\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (lhs_val, rhs_bound),\n+                    });\n+                }\n+\n+                if let PatKind::Lit(value) = pat.kind {\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (value, EndBound::Included(value)),\n+                    });\n+                }\n+            }\n+            None\n+        })\n+        .collect()\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct SpannedRange<T> {\n+    pub span: Span,\n+    pub node: (T, EndBound<T>),\n+}\n+\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+where\n+    T: Copy + Ord,\n+{\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2 * ranges.len());\n+\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n+    }\n+\n+    values.sort();\n+\n+    let mut started = vec![];\n+\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n+                let mut overlap = None;\n+\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n+                        break;\n+                    }\n+                    overlap = Some(last_started);\n+                }\n+\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n+                }\n+            },\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn test_overlapping() {\n+    use rustc_span::source_map::DUMMY_SP;\n+\n+    let sp = |s, e| SpannedRange {\n+        span: DUMMY_SP,\n+        node: (s, e),\n+    };\n+\n+    assert_eq!(None, overlapping::<u8>(&[]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n+    assert_eq!(\n+        None,\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        None,\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n+        ],)\n+    );\n+    assert_eq!(\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n+        ],)\n+    );\n+}"}]}