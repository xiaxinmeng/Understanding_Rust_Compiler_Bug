{"sha": "119307a83e12291a3fc126735d6bd0292c443464", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTMwN2E4M2UxMjI5MWEzZmMxMjY3MzVkNmJkMDI5MmM0NDM0NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T19:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T19:41:36Z"}, "message": "Auto merge of #67764 - Centril:rollup-ycbq3os, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #67574 (Extract `rustc_ast_lowering` crate from `rustc`)\n - #67685 (Constify Result)\n - #67702 (Add symbol normalization for proc_macro_server.)\n - #67730 (Cleanup pattern type checking, fix diagnostics bugs (+ improvements))\n - #67744 (parser: reduce diversity in error handling mechanisms)\n - #67748 (Use function attribute \"frame-pointer\" instead of \"no-frame-pointer-elim\")\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "55fd1622f4eb31b54cf1efdf4a76529f5c0dff15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55fd1622f4eb31b54cf1efdf4a76529f5c0dff15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119307a83e12291a3fc126735d6bd0292c443464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119307a83e12291a3fc126735d6bd0292c443464", "html_url": "https://github.com/rust-lang/rust/commit/119307a83e12291a3fc126735d6bd0292c443464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119307a83e12291a3fc126735d6bd0292c443464/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "769eb2194acf23d3f3f8e8dcdd436bb69bfffc49", "url": "https://api.github.com/repos/rust-lang/rust/commits/769eb2194acf23d3f3f8e8dcdd436bb69bfffc49", "html_url": "https://github.com/rust-lang/rust/commit/769eb2194acf23d3f3f8e8dcdd436bb69bfffc49"}, {"sha": "40579d15db6928837a11a6f744cedc3e7f21ce07", "url": "https://api.github.com/repos/rust-lang/rust/commits/40579d15db6928837a11a6f744cedc3e7f21ce07", "html_url": "https://github.com/rust-lang/rust/commit/40579d15db6928837a11a6f744cedc3e7f21ce07"}], "stats": {"total": 1240, "additions": 731, "deletions": 509}, "files": [{"sha": "947c0b8f465b94f1dbbe4e65b6dfd278507043f7", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -3358,6 +3358,22 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc_ast_lowering\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_errors\",\n+ \"rustc_index\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+]\n+\n [[package]]\n name = \"rustc_builtin_macros\"\n version = \"0.0.0\"\n@@ -3578,6 +3594,7 @@ dependencies = [\n  \"once_cell\",\n  \"rustc\",\n  \"rustc-rayon\",\n+ \"rustc_ast_lowering\",\n  \"rustc_builtin_macros\",\n  \"rustc_codegen_llvm\",\n  \"rustc_codegen_ssa\",\n@@ -3783,6 +3800,7 @@ dependencies = [\n  \"bitflags\",\n  \"log\",\n  \"rustc\",\n+ \"rustc_ast_lowering\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n  \"rustc_errors\","}, {"sha": "8e1273c3172d3a4fbaa463b86bfeaa7bc53801eb", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -76,6 +76,7 @@\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n #![feature(const_ptr_offset_from)]\n+#![feature(const_result)]\n #![feature(const_type_name)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]"}, {"sha": "5cfc81097dd44a3b9b7a5e3381c5e08ab34bbe7c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -278,9 +278,10 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[must_use = \"if you intended to assert that this is ok, consider `.unwrap()` instead\"]\n+    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_ok(&self) -> bool {\n+    pub const fn is_ok(&self) -> bool {\n         match *self {\n             Ok(_) => true,\n             Err(_) => false,\n@@ -303,9 +304,10 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[must_use = \"if you intended to assert that this is err, consider `.unwrap_err()` instead\"]\n+    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_err(&self) -> bool {\n+    pub const fn is_err(&self) -> bool {\n         !self.is_ok()\n     }\n \n@@ -446,8 +448,9 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ref(&self) -> Result<&T, &E> {\n+    pub const fn as_ref(&self) -> Result<&T, &E> {\n         match *self {\n             Ok(ref x) => Ok(x),\n             Err(ref x) => Err(x),"}, {"sha": "dfd06da969b571b98e02f593363a25d61bf95cc6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -39,7 +39,6 @@ pub mod def;\n pub mod def_id;\n pub mod intravisit;\n pub mod itemlikevisit;\n-pub mod lowering;\n pub mod map;\n pub mod pat_util;\n pub mod print;\n@@ -599,7 +598,7 @@ pub enum SyntheticTyParamKind {\n pub struct WhereClause<'hir> {\n     pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates isn't empty.\n-    span: Span,\n+    pub span: Span,\n }\n \n impl WhereClause<'_> {"}, {"sha": "b3a79c0883358895c38b36484d36d500bad2a7d0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -581,10 +581,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n     ) {\n         match cause.code {\n-            ObligationCauseCode::MatchExpressionArmPattern { span, ty } => {\n+            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n+                let ty = self.resolve_vars_if_possible(&root_ty);\n                 if ty.is_suggestable() {\n                     // don't show type `_`\n-                    err.span_label(span, format!(\"this match expression has type `{}`\", ty));\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n                 }\n                 if let Some(ty::error::ExpectedFound { found, .. }) = exp_found {\n                     if ty.is_box() && ty.boxed_ty() == found {\n@@ -599,11 +600,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n+            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n+                err.span_label(span, \"expected due to this\");\n+            }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n-                discrim_hir_id,\n+                scrut_hir_id,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n@@ -612,16 +616,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let discrim_expr = self.tcx.hir().expect_expr(discrim_hir_id);\n-                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.kind {\n+                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n+                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n                             self.in_progress_tables\n                                 .and_then(|tables| tables.borrow().expr_ty_opt(arg_expr))\n                         } else {\n-                            bug!(\"try desugaring w/out call expr as discriminant\");\n+                            bug!(\"try desugaring w/out call expr as scrutinee\");\n                         };\n \n-                        match discrim_ty {\n+                        match scrut_ty {\n                             Some(ty) if expected == ty => {\n                                 let source_map = self.tcx.sess.source_map();\n                                 err.span_suggestion("}, {"sha": "76588dfa5e25e041afde0d71cb5873be8ff0a8b9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -28,7 +28,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(arbitrary_self_types)]\n-#![feature(array_value_iter)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "fa6e93d867b4ef6ed5f7b9e0d7efdd09829b82d8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -523,7 +523,7 @@ pub enum BuiltinLintDiagnostics {\n     DeprecatedMacro(Option<Symbol>, Span),\n }\n \n-pub(crate) fn add_elided_lifetime_in_path_suggestion(\n+pub fn add_elided_lifetime_in_path_suggestion(\n     sess: &Session,\n     db: &mut DiagnosticBuilder<'_>,\n     n: usize,"}, {"sha": "5819e7aa5c25dc8391c59d4aca708632ba8ce89c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2580,7 +2580,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable\n             | ObligationCauseCode::MatchExpressionArm { .. }\n-            | ObligationCauseCode::MatchExpressionArmPattern { .. }\n+            | ObligationCauseCode::Pattern { .. }\n             | ObligationCauseCode::IfExpression { .. }\n             | ObligationCauseCode::IfExpressionWithNoElse\n             | ObligationCauseCode::MainFunctionType"}, {"sha": "fe373e02e10f368cbdfb96a3df20b391f60e6b30", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -249,10 +249,14 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Computing common supertype in the arms of a match expression\n     MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n-    /// Computing common supertype in the pattern guard for the arms of a match expression\n-    MatchExpressionArmPattern {\n-        span: Span,\n-        ty: Ty<'tcx>,\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n     },\n \n     /// Constants in patterns must have `Structural` type.\n@@ -311,7 +315,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n-    pub discrim_hir_id: hir::HirId,\n+    pub scrut_hir_id: hir::HirId,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "c439f20d640024d4784c1ec58b6ba85470ea643a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -511,18 +511,18 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n-                discrim_hir_id,\n+                scrut_hir_id,\n             }) => tcx.lift(&last_ty).map(|last_ty| {\n                 super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                     arm_span,\n                     source,\n                     prior_arms: prior_arms.clone(),\n                     last_ty,\n-                    discrim_hir_id,\n+                    scrut_hir_id,\n                 })\n             }),\n-            super::MatchExpressionArmPattern { span, ty } => {\n-                tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n+            super::Pattern { span, root_ty, origin_expr } => {\n+                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n             }\n             super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n                 Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))"}, {"sha": "664d41c45f2a2433aa59f2887f497f8104984523", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ast_lowering\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_ast_lowering\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc = { path = \"../librustc\" }\n+rustc_target = { path = \"../librustc_target\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+syntax = { path = \"../libsyntax\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "a3e2bc04bd5fbbe270f51875c6026e61aef20b5b", "filename": "src/librustc_ast_lowering/expr.rs", "status": "renamed", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,16 +1,16 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n-use crate::hir;\n-use crate::hir::def::Res;\n \n+use rustc::bug;\n+use rustc::hir;\n+use rustc::hir::def::Res;\n use rustc_data_structures::thin_vec::ThinVec;\n-\n+use rustc_error_codes::*;\n+use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::symbol::{sym, Symbol};\n use syntax::ast::*;\n use syntax::attr;\n use syntax::ptr::P as AstP;\n-use syntax::source_map::{respan, DesugaringKind, Span, Spanned};\n-use syntax::symbol::{sym, Symbol};\n-\n-use rustc_error_codes::*;\n+use syntax::{span_err, struct_span_err};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -82,11 +82,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n             }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprKind::Loop(\n-                    this.lower_block(body, false),\n-                    this.lower_label(opt_label),\n-                    hir::LoopSource::Loop,\n-                )\n+                hir::ExprKind::Loop(this.lower_block(body, false), opt_label, hir::LoopSource::Loop)\n             }),\n             ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n             ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n@@ -123,10 +119,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_closure(capture_clause, movability, decl, body, fn_decl_span)\n                 }\n             }\n-            ExprKind::Block(ref blk, opt_label) => hir::ExprKind::Block(\n-                self.lower_block(blk, opt_label.is_some()),\n-                self.lower_label(opt_label),\n-            ),\n+            ExprKind::Block(ref blk, opt_label) => {\n+                hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n+            }\n             ExprKind::Assign(ref el, ref er, span) => {\n                 hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n             }\n@@ -407,11 +402,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(\n-            self.block_expr(self.arena.alloc(match_expr)),\n-            self.lower_label(opt_label),\n-            source,\n-        )\n+        hir::ExprKind::Loop(self.block_expr(self.arena.alloc(match_expr)), opt_label, source)\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n@@ -836,10 +827,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n-        label.map(|label| hir::Label { ident: label.ident })\n-    }\n-\n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n         let target_id = match destination {\n             Some((id, _)) => {\n@@ -857,7 +844,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                 .into(),\n         };\n-        hir::Destination { label: self.lower_label(destination.map(|(_, label)| label)), target_id }\n+        hir::Destination { label: destination.map(|(_, label)| label), target_id }\n     }\n \n     fn lower_jump_destination(&mut self, id: NodeId, opt_label: Option<Label>) -> hir::Destination {\n@@ -1100,8 +1087,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         // `[opt_ident]: loop { ... }`\n-        let kind =\n-            hir::ExprKind::Loop(loop_block, self.lower_label(opt_label), hir::LoopSource::ForLoop);\n+        let kind = hir::ExprKind::Loop(loop_block, opt_label, hir::LoopSource::ForLoop);\n         let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n             kind,", "previous_filename": "src/librustc/hir/lowering/expr.rs"}, {"sha": "c1eb8be0f8aadc3888fca95b873a88bac5f45d96", "filename": "src/librustc_ast_lowering/item.rs", "status": "renamed", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,28 +1,25 @@\n-use super::AnonymousLifetimeMode;\n-use super::ImplTraitContext;\n-use super::ImplTraitPosition;\n-use super::ImplTraitTypeIdVisitor;\n-use super::LoweringContext;\n-use super::ParamMode;\n-\n-use crate::arena::Arena;\n-use crate::hir;\n-use crate::hir::def::{DefKind, Res};\n-use crate::hir::def_id::DefId;\n-use crate::util::nodemap::NodeMap;\n-\n+use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n+use super::{ImplTraitContext, ImplTraitPosition, ImplTraitTypeIdVisitor};\n+\n+use rustc::arena::Arena;\n+use rustc::bug;\n+use rustc::hir;\n+use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::def_id::DefId;\n+use rustc::util::nodemap::NodeMap;\n+use rustc_error_codes::*;\n+use rustc_span::source_map::{respan, DesugaringKind};\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::Span;\n use rustc_target::spec::abi;\n-\n-use smallvec::SmallVec;\n-use std::collections::BTreeSet;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::source_map::{respan, DesugaringKind};\n-use syntax::symbol::{kw, sym};\n+use syntax::struct_span_err;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::Span;\n \n-use rustc_error_codes::*;\n+use log::debug;\n+use smallvec::{smallvec, SmallVec};\n+use std::collections::BTreeSet;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n@@ -1429,7 +1426,7 @@ pub(super) struct GenericsCtor<'hir> {\n     span: Span,\n }\n \n-impl GenericsCtor<'hir> {\n+impl<'hir> GenericsCtor<'hir> {\n     pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> hir::Generics<'hir> {\n         hir::Generics {\n             params: arena.alloc_from_iter(self.params),", "previous_filename": "src/librustc/hir/lowering/item.rs"}, {"sha": "a9214f31e7d2e85b2d04f0652dfc15dd17c7142e", "filename": "src/librustc_ast_lowering/lib.rs", "status": "renamed", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -32,45 +32,47 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n-use crate::hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use crate::hir::map::{DefKey, DefPathData, Definitions};\n-use crate::hir::{self, ParamName};\n-use crate::hir::{ConstArg, GenericArg};\n-use crate::lint;\n-use crate::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n-use crate::middle::cstore::CrateStore;\n-use crate::session::config::nightly_options;\n-use crate::session::Session;\n-use crate::util::captures::Captures;\n-use crate::util::common::FN_OUTPUT_NAME;\n-use crate::util::nodemap::{DefIdMap, NodeMap};\n-use errors::Applicability;\n+#![feature(array_value_iter)]\n+\n+use rustc::arena::Arena;\n+use rustc::dep_graph::DepGraph;\n+use rustc::hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n+use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::map::{DefKey, DefPathData, Definitions};\n+use rustc::hir::{self, ConstArg, GenericArg, ParamName};\n+use rustc::lint;\n+use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n+use rustc::middle::cstore::CrateStore;\n+use rustc::session::config::nightly_options;\n+use rustc::session::Session;\n+use rustc::util::captures::Captures;\n+use rustc::util::common::FN_OUTPUT_NAME;\n+use rustc::util::nodemap::{DefIdMap, NodeMap};\n+use rustc::{bug, span_bug};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n+use rustc_error_codes::*;\n+use rustc_errors::Applicability;\n use rustc_index::vec::IndexVec;\n-\n-use smallvec::SmallVec;\n-use std::collections::BTreeMap;\n-use std::mem;\n+use rustc_span::hygiene::ExpnId;\n+use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::Span;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::errors;\n use syntax::print::pprust;\n use syntax::ptr::P as AstP;\n use syntax::sess::ParseSess;\n-use syntax::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n-use syntax::symbol::{kw, sym, Symbol};\n use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::hygiene::ExpnId;\n-use syntax_pos::Span;\n+use syntax::{help, struct_span_err, walk_list};\n \n-use rustc_error_codes::*;\n+use log::{debug, trace};\n+use smallvec::{smallvec, SmallVec};\n+use std::collections::BTreeMap;\n+use std::mem;\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => ({\n@@ -84,7 +86,7 @@ mod item;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n-pub struct LoweringContext<'a, 'hir: 'a> {\n+struct LoweringContext<'a, 'hir: 'a> {\n     crate_root: Option<Symbol>,\n \n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n@@ -235,13 +237,13 @@ enum ImplTraitPosition {\n     Other,\n }\n \n-impl<'b, 'a> ImplTraitContext<'b, 'a> {\n+impl<'a> ImplTraitContext<'_, 'a> {\n     #[inline]\n     fn disallowed() -> Self {\n         ImplTraitContext::Disallowed(ImplTraitPosition::Other)\n     }\n \n-    fn reborrow(&'c mut self) -> ImplTraitContext<'c, 'a> {\n+    fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n@@ -372,8 +374,8 @@ struct ImplTraitTypeIdVisitor<'a> {\n     ids: &'a mut SmallVec<[NodeId; 1]>,\n }\n \n-impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n-    fn visit_ty(&mut self, ty: &'a Ty) {\n+impl Visitor<'_> for ImplTraitTypeIdVisitor<'_> {\n+    fn visit_ty(&mut self, ty: &Ty) {\n         match ty.kind {\n             TyKind::Typeof(_) | TyKind::BareFn(_) => return,\n \n@@ -383,7 +385,7 @@ impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &PathSegment) {\n         if let Some(ref p) = path_segment.args {\n             if let GenericArgs::Parenthesized(_) = **p {\n                 return;\n@@ -687,7 +689,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.resolver.get_import_res(id).present_items()\n     }\n \n-    fn diagnostic(&self) -> &errors::Handler {\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n         self.sess.diagnostic()\n     }\n \n@@ -3288,7 +3290,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n }\n \n-fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId> {\n+fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'_>>) -> Vec<hir::BodyId> {\n     // Sorting by span ensures that we get things in order within a\n     // file, and also puts the files in a sensible order.\n     let mut body_ids: Vec<_> = bodies.keys().cloned().collect();\n@@ -3303,7 +3305,7 @@ struct GenericArgsCtor<'hir> {\n     parenthesized: bool,\n }\n \n-impl GenericArgsCtor<'hir> {\n+impl<'hir> GenericArgsCtor<'hir> {\n     fn is_empty(&self) -> bool {\n         self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }", "previous_filename": "src/librustc/hir/lowering.rs"}, {"sha": "942ba9f868c60c9677c06300cb6005a2055c410d", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -66,12 +66,21 @@ fn naked(val: &'ll Value, is_naked: bool) {\n \n pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().must_not_eliminate_frame_pointers() {\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            const_cstr!(\"no-frame-pointer-elim\"),\n-            const_cstr!(\"true\"),\n-        );\n+        if llvm_util::get_major_version() >= 8 {\n+            llvm::AddFunctionAttrStringValue(\n+                llfn,\n+                llvm::AttributePlace::Function,\n+                const_cstr!(\"frame-pointer\"),\n+                const_cstr!(\"all\"),\n+            );\n+        } else {\n+            llvm::AddFunctionAttrStringValue(\n+                llfn,\n+                llvm::AttributePlace::Function,\n+                const_cstr!(\"no-frame-pointer-elim\"),\n+                const_cstr!(\"true\"),\n+            );\n+        }\n     }\n }\n "}, {"sha": "37374d707192772140b0c4ab3ac055f84f264863", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -890,12 +890,12 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n     Ok(match name {\n         sym::item => match p.parse_item()? {\n             Some(i) => token::NtItem(i),\n-            None => return Err(p.fatal(\"expected an item keyword\")),\n+            None => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n         },\n         sym::block => token::NtBlock(p.parse_block()?),\n         sym::stmt => match p.parse_stmt()? {\n             Some(s) => token::NtStmt(s),\n-            None => return Err(p.fatal(\"expected a statement\")),\n+            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n         },\n         sym::pat => token::NtPat(p.parse_pat(None)?),\n         sym::expr => token::NtExpr(p.parse_expr()?),\n@@ -909,7 +909,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n                 token::NtIdent(Ident::new(name, span), is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n-                return Err(p.fatal(&format!(\"expected ident, found {}\", &token_str)));\n+                let msg = &format!(\"expected ident, found {}\", &token_str);\n+                return Err(p.struct_span_err(p.token.span, msg));\n             }\n         }\n         sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n@@ -920,7 +921,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n                 token::NtLifetime(p.expect_lifetime().ident)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n-                return Err(p.fatal(&format!(\"expected a lifetime, found `{}`\", &token_str)));\n+                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                return Err(p.struct_span_err(p.token.span, msg));\n             }\n         }\n         // this is not supposed to happen, since it has been checked"}, {"sha": "b41490011af3faf87ce70bc51a4a1c8e6b3fa04c", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,5 +1,6 @@\n use crate::base::ExtCtxt;\n \n+use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use syntax::ast;\n use syntax::print::pprust;\n@@ -327,6 +328,7 @@ impl Ident {\n         }\n     }\n     fn new(sym: Symbol, is_raw: bool, span: Span) -> Ident {\n+        let sym = nfc_normalize(&sym.as_str());\n         let string = sym.as_str();\n         if !Self::is_valid(&string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)"}, {"sha": "4926cb230814d977f219653d61533555c5e477de", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -20,6 +20,7 @@ rustc_parse = { path = \"../librustc_parse\" }\n syntax_pos = { path = \"../librustc_span\", package = \"rustc_span\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }\n+rustc_ast_lowering = { path = \"../librustc_ast_lowering\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "c412aa17e4e59e595c25ccc3d34234b3f6149114", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -7,7 +7,6 @@ use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n-use rustc::hir::lowering::lower_crate;\n use rustc::lint;\n use rustc::middle::cstore::{CrateStore, MetadataLoader, MetadataLoaderDyn};\n use rustc::middle::{self, stability};\n@@ -442,8 +441,14 @@ pub fn lower_to_hir<'res, 'tcx>(\n ) -> Result<hir::map::Forest<'tcx>> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n-        let nt_to_tokenstream = rustc_parse::nt_to_tokenstream;\n-        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream, arena);\n+        let hir_crate = rustc_ast_lowering::lower_crate(\n+            sess,\n+            &dep_graph,\n+            &krate,\n+            resolver,\n+            rustc_parse::nt_to_tokenstream,\n+            arena,\n+        );\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);"}, {"sha": "a57e98bd2207fe7f8ab0fe9a5eda84b6c98afe1d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -16,8 +16,8 @@ use std::{f32, f64, i16, i32, i64, i8, u16, u32, u64, u8};\n \n use rustc_target::spec::abi::Abi;\n use syntax::errors::Applicability;\n-use syntax::symbol::sym;\n use syntax::{ast, attr, source_map};\n+use syntax_pos::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::hir;"}, {"sha": "30ec202e0ffe39eea6de489acf4f0eb68bec2868", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -220,7 +220,7 @@ impl<'a> StringReader<'a> {\n                 if is_raw_ident {\n                     ident_start = ident_start + BytePos(2);\n                 }\n-                let sym = self.nfc_symbol_from(ident_start);\n+                let sym = nfc_normalize(self.str_from(ident_start));\n                 if is_raw_ident {\n                     let span = self.mk_sp(start, self.pos);\n                     if !sym.can_be_raw() {\n@@ -469,20 +469,6 @@ impl<'a> StringReader<'a> {\n         Symbol::intern(self.str_from_to(start, end))\n     }\n \n-    /// As symbol_from, with the text normalized into Unicode NFC form.\n-    fn nfc_symbol_from(&self, start: BytePos) -> Symbol {\n-        use unicode_normalization::{is_nfc_quick, IsNormalized, UnicodeNormalization};\n-        debug!(\"taking an normalized ident from {:?} to {:?}\", start, self.pos);\n-        let sym = self.str_from(start);\n-        match is_nfc_quick(sym.chars()) {\n-            IsNormalized::Yes => Symbol::intern(sym),\n-            _ => {\n-                let sym_str: String = sym.chars().nfc().collect();\n-                Symbol::intern(&sym_str)\n-            }\n-        }\n-    }\n-\n     /// Slice of the source text spanning from `start` up to but excluding `end`.\n     fn str_from_to(&self, start: BytePos, end: BytePos) -> &str {\n         &self.src[self.src_index(start)..self.src_index(end)]\n@@ -651,3 +637,14 @@ impl<'a> StringReader<'a> {\n         }\n     }\n }\n+\n+pub fn nfc_normalize(string: &str) -> Symbol {\n+    use unicode_normalization::{is_nfc_quick, IsNormalized, UnicodeNormalization};\n+    match is_nfc_quick(string.chars()) {\n+        IsNormalized::Yes => Symbol::intern(string),\n+        _ => {\n+            let normalized_str: String = string.chars().nfc().collect();\n+            Symbol::intern(&normalized_str)\n+        }\n+    }\n+}"}, {"sha": "26df4f1c090d65ccc347eef23fdb23d6501b9933", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -46,7 +46,8 @@ impl<'a> Parser<'a> {\n                 token::DocComment(s) => {\n                     let attr = self.mk_doc_comment(s);\n                     if attr.style != ast::AttrStyle::Outer {\n-                        let mut err = self.fatal(\"expected outer doc comment\");\n+                        let span = self.token.span;\n+                        let mut err = self.struct_span_err(span, \"expected outer doc comment\");\n                         err.note(\n                             \"inner doc comments like this (starting with \\\n                                   `//!` or `/*!`) can only appear before items\",\n@@ -133,7 +134,7 @@ impl<'a> Parser<'a> {\n                             \"previous outer attribute\"\n                         };\n \n-                        let mut diagnostic = self.diagnostic().struct_span_err(attr_sp, reason);\n+                        let mut diagnostic = self.struct_span_err(attr_sp, reason);\n \n                         if let Some(prev_attr_sp) = prev_attr_sp {\n                             diagnostic\n@@ -156,7 +157,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 let token_str = pprust::token_to_string(&self.token);\n-                return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n+                let msg = &format!(\"expected `#`, found `{}`\", token_str);\n+                return Err(self.struct_span_err(self.token.span, msg));\n             }\n         };\n \n@@ -231,8 +233,7 @@ impl<'a> Parser<'a> {\n \n         if !lit.kind.is_unsuffixed() {\n             let msg = \"suffixed literals are not allowed in attributes\";\n-            self.diagnostic()\n-                .struct_span_err(lit.span, msg)\n+            self.struct_span_err(lit.span, msg)\n                 .help(\n                     \"instead of using a suffixed literal \\\n                                     (1u8, 1.0f32, etc.), use an unsuffixed version \\\n@@ -332,6 +333,6 @@ impl<'a> Parser<'a> {\n \n         let found = pprust::token_to_string(&self.token);\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n-        Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n+        Err(self.struct_span_err(self.token.span, &msg))\n     }\n }"}, {"sha": "05754357bc82210c0dde8e7deb9db4abf1bbd657", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -157,14 +157,6 @@ crate enum ConsumeClosingDelim {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.span_fatal(self.token.span, m)\n-    }\n-\n-    crate fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n-    }\n-\n     pub(super) fn span_fatal_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -173,14 +165,6 @@ impl<'a> Parser<'a> {\n         err.span_err(sp, self.diagnostic())\n     }\n \n-    pub(super) fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.token.span, m)\n-    }\n-\n-    pub(super) fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n-        self.sess.span_diagnostic.span_err(sp, m)\n-    }\n-\n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n@@ -298,7 +282,7 @@ impl<'a> Parser<'a> {\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n-        let mut err = self.fatal(&msg_exp);\n+        let mut err = self.struct_span_err(self.token.span, &msg_exp);\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n             self.prev_span\n@@ -502,18 +486,17 @@ impl<'a> Parser<'a> {\n             let span = lo.until(self.token.span);\n \n             let total_num_of_gt = number_of_gt + number_of_shr * 2;\n-            self.diagnostic()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.struct_span_err(\n+                span,\n+                &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n+            )\n+            .span_suggestion(\n+                span,\n+                &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n         }\n     }\n \n@@ -762,8 +745,7 @@ impl<'a> Parser<'a> {\n         path.span = ty_span.to(self.prev_span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n-        self.diagnostic()\n-            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n+        self.struct_span_err(path.span, \"missing angle brackets in associated item path\")\n             .span_suggestion(\n                 // This is a best-effort recovery.\n                 path.span,\n@@ -1271,7 +1253,8 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = super::token_descr(&self.token);\n-        let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n+        let msg = &format!(\"expected `;` or `{{`, found {}\", token_str);\n+        let mut err = self.struct_span_err(self.token.span, msg);\n         err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n     }"}, {"sha": "ab7c156e3706d85fcb30c8badf7380b6720a07be", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -283,7 +283,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(span, aopexpr, AttrVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n-                    self.bug(\"AssocOp should have been handled by special case\")\n+                    self.span_bug(span, \"AssocOp should have been handled by special case\")\n                 }\n             };\n \n@@ -822,7 +822,11 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n-                self.span_err(args.span(), \"field expressions may not have generic arguments\");\n+                self.struct_span_err(\n+                    args.span(),\n+                    \"field expressions may not have generic arguments\",\n+                )\n+                .emit();\n             }\n \n             let span = lo.to(self.prev_span);\n@@ -1133,7 +1137,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n             let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n-            self.span_fatal(self.token.span, &msg)\n+            self.struct_span_err(self.token.span, &msg)\n         })\n     }\n \n@@ -1446,9 +1450,7 @@ impl<'a> Parser<'a> {\n         self.struct_span_err(sp, \"missing condition for `if` expression\")\n             .span_label(sp, \"expected if condition here\")\n             .emit();\n-        let expr = self.mk_expr_err(span);\n-        let stmt = self.mk_stmt(span, ast::StmtKind::Expr(expr));\n-        self.mk_block(vec![stmt], BlockCheckMode::Default, span)\n+        self.mk_block_err(span)\n     }\n \n     /// Parses the condition of a `if` or `while` expression.\n@@ -1915,8 +1917,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.diagnostic()\n-            .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+        self.struct_span_err(self.token.span, \"expected `:`, found `=`\")\n             .span_suggestion(\n                 field_name.span.shrink_to_hi().to(self.token.span),\n                 \"replace equals symbol with a colon\","}, {"sha": "e5a7361b12ab7bb4021996c79fef3ff039ec1fa8", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -306,8 +306,7 @@ impl<'a> Parser<'a> {\n                 // possible public struct definition where `struct` was forgotten\n                 let ident = self.parse_ident().unwrap();\n                 let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n-                let mut err =\n-                    self.diagnostic().struct_span_err(sp, \"missing `struct` for struct definition\");\n+                let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n                 err.span_suggestion_short(\n                     sp,\n                     &msg,\n@@ -335,7 +334,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                let mut err = self.struct_span_err(sp, &msg);\n                 if !ambiguous {\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n                     let suggestion =\n@@ -375,7 +374,7 @@ impl<'a> Parser<'a> {\n                     (\"fn` or `struct\", \"function or struct\", true)\n                 };\n                 let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.diagnostic().struct_span_err(sp, &msg);\n+                let mut err = self.struct_span_err(sp, &msg);\n                 if !ambiguous {\n                     err.span_suggestion_short(\n                         sp,\n@@ -446,9 +445,7 @@ impl<'a> Parser<'a> {\n         // FAILURE TO PARSE ITEM\n         match visibility.node {\n             VisibilityKind::Inherited => {}\n-            _ => {\n-                return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n-            }\n+            _ => return Err(self.struct_span_err(self.prev_span, \"unmatched visibility `pub`\")),\n         }\n \n         if !attributes_allowed && !attrs.is_empty() {\n@@ -466,7 +463,7 @@ impl<'a> Parser<'a> {\n             _ => \"expected item after attributes\",\n         };\n \n-        let mut err = self.diagnostic().struct_span_err(self.prev_span, message);\n+        let mut err = self.struct_span_err(self.prev_span, message);\n         if attrs.last().unwrap().is_doc_comment() {\n             err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n         }\n@@ -536,7 +533,6 @@ impl<'a> Parser<'a> {\n         //        ^^ `sp` below will point to this\n         let sp = prev_span.between(self.prev_span);\n         let mut err = self\n-            .diagnostic()\n             .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n         err.span_label(sp, expected_kinds);\n         err\n@@ -619,7 +615,7 @@ impl<'a> Parser<'a> {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n-                        self.span_err(ty_first.span, \"expected a trait, found type\");\n+                        self.struct_span_err(ty_first.span, \"expected a trait, found type\").emit();\n                         err_path(ty_first.span)\n                     }\n                 };\n@@ -1349,10 +1345,11 @@ impl<'a> Parser<'a> {\n             body\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self.fatal(&format!(\n+            let msg = &format!(\n                 \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n                 token_str\n-            ));\n+            );\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n             return Err(err);\n         };\n@@ -1375,8 +1372,8 @@ impl<'a> Parser<'a> {\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self\n-                .fatal(&format!(\"expected `where` or `{{` after union name, found {}\", token_str));\n+            let msg = &format!(\"expected `where` or `{{` after union name, found {}\", token_str);\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n         };\n@@ -1412,10 +1409,8 @@ impl<'a> Parser<'a> {\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n             let token_str = super::token_descr(&self.token);\n-            let mut err = self.fatal(&format!(\n-                \"expected `where`, or `{{` after struct name, found {}\",\n-                token_str\n-            ));\n+            let msg = &format!(\"expected `where`, or `{{` after struct name, found {}\", token_str);\n+            let mut err = self.struct_span_err(self.token.span, msg);\n             err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n             return Err(err);\n         }\n@@ -1603,9 +1598,8 @@ impl<'a> Parser<'a> {\n             VisibilityKind::Inherited => {}\n             _ => {\n                 let mut err = if self.token.is_keyword(sym::macro_rules) {\n-                    let mut err = self\n-                        .diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n+                    let mut err =\n+                        self.struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n                     err.span_suggestion(\n                         sp,\n                         \"try exporting the macro\",\n@@ -1614,9 +1608,8 @@ impl<'a> Parser<'a> {\n                     );\n                     err\n                 } else {\n-                    let mut err = self\n-                        .diagnostic()\n-                        .struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n+                    let mut err =\n+                        self.struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n                     err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n                     err\n                 };"}, {"sha": "ec6468f4f0a329c81e6b50a94e227124b3d0f58a", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -884,7 +884,8 @@ impl<'a> Parser<'a> {\n     pub fn bump(&mut self) {\n         if self.prev_token_kind == PrevTokenKind::Eof {\n             // Bumping after EOF is a bad sign, usually an infinite loop.\n-            self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n+            let msg = \"attempted to bump the parser past EOF (may be stuck in a loop)\";\n+            self.span_bug(self.token.span, msg);\n         }\n \n         self.prev_span = self.meta_var_span.take().unwrap_or(self.token.span);\n@@ -1056,8 +1057,7 @@ impl<'a> Parser<'a> {\n                     _ => unreachable!(),\n                 };\n                 let span = self.prev_span.to(self.token.span);\n-                self.diagnostic()\n-                    .struct_span_fatal(span, &format!(\"unknown macro variable `{}`\", name))\n+                self.struct_span_err(span, &format!(\"unknown macro variable `{}`\", name))\n                     .span_label(span, \"unknown macro variable\")\n                     .emit();\n                 self.bump();"}, {"sha": "84ffa6f7fcd8fddeffec44c835c8e4dc34e2eec3", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -81,7 +81,8 @@ impl<'a> Parser<'a> {\n         if !self.eat(term) {\n             let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n+                let msg = &format!(\"expected item, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n                 err.span_label(self.token.span, \"expected item\");\n                 return Err(err);\n             }\n@@ -129,7 +130,7 @@ impl<'a> Parser<'a> {\n             DirectoryOwnership::UnownedViaBlock => {\n                 let msg = \"Cannot declare a non-inline module inside a block \\\n                     unless it has a path attribute\";\n-                let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n+                let mut err = self.struct_span_err(id_sp, msg);\n                 if paths.path_exists {\n                     let msg = format!(\n                         \"Maybe `use` the module `{}` instead of redeclaring it\",\n@@ -140,9 +141,8 @@ impl<'a> Parser<'a> {\n                 Err(err)\n             }\n             DirectoryOwnership::UnownedViaMod => {\n-                let mut err = self\n-                    .diagnostic()\n-                    .struct_span_err(id_sp, \"cannot declare a new module at this location\");\n+                let mut err =\n+                    self.struct_span_err(id_sp, \"cannot declare a new module at this location\");\n                 if !id_sp.is_dummy() {\n                     let src_path = self.sess.source_map().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n@@ -263,7 +263,7 @@ impl<'a> Parser<'a> {\n                 err.push_str(\" -> \");\n             }\n             err.push_str(&path.to_string_lossy());\n-            return Err(self.span_fatal(id_sp, &err[..]));\n+            return Err(self.struct_span_err(id_sp, &err[..]));\n         }\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);"}, {"sha": "e608b86c76a29447201b8d63d5fc7ce75e3a0779", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -673,7 +673,7 @@ impl<'a> Parser<'a> {\n         let expected = expected.unwrap_or(\"pattern\");\n         let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n-        let mut err = self.fatal(&msg);\n+        let mut err = self.struct_span_err(self.token.span, &msg);\n         err.span_label(self.token.span, format!(\"expected {}\", expected));\n \n         let sp = self.sess.source_map().start_point(self.token.span);\n@@ -699,8 +699,7 @@ impl<'a> Parser<'a> {\n         let range_span = lo.to(end.span);\n         let begin = self.mk_expr(range_span, ExprKind::Err, AttrVec::new());\n \n-        self.diagnostic()\n-            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+        self.struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n             .span_suggestion(\n                 range_span,\n                 \"try using the minimum value for the type\",\n@@ -722,18 +721,17 @@ impl<'a> Parser<'a> {\n             // Parsing e.g. `X..`.\n             let range_span = begin.span.to(self.prev_span);\n \n-            self.diagnostic()\n-                .struct_span_err(\n-                    range_span,\n-                    &format!(\"`X{}` range patterns are not supported\", form),\n-                )\n-                .span_suggestion(\n-                    range_span,\n-                    \"try using the maximum value for the type\",\n-                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n+            self.struct_span_err(\n+                range_span,\n+                &format!(\"`X{}` range patterns are not supported\", form),\n+            )\n+            .span_suggestion(\n+                range_span,\n+                \"try using the maximum value for the type\",\n+                format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n \n             Ok(self.mk_expr(range_span, ExprKind::Err, AttrVec::new()))\n         }\n@@ -798,7 +796,9 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n-            return Err(self.span_fatal(self.prev_span, \"expected identifier, found enum pattern\"));\n+            return Err(\n+                self.struct_span_err(self.prev_span, \"expected identifier, found enum pattern\")\n+            );\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n@@ -807,12 +807,8 @@ impl<'a> Parser<'a> {\n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n     fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            let msg = \"unexpected `{` after qualified path\";\n-            let mut err = self.fatal(msg);\n-            err.span_label(self.token.span, msg);\n-            return Err(err);\n+            return self.error_qpath_before_pat(&path, \"{\");\n         }\n-\n         self.bump();\n         let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n             e.emit();\n@@ -826,15 +822,22 @@ impl<'a> Parser<'a> {\n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            let msg = \"unexpected `(` after qualified path\";\n-            let mut err = self.fatal(msg);\n-            err.span_label(self.token.span, msg);\n-            return Err(err);\n+            return self.error_qpath_before_pat(&path, \"(\");\n         }\n         let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n+    /// Error when there's a qualified path, e.g. `<Foo as Bar>::Baz`\n+    /// as the path of e.g., a tuple or record struct pattern.\n+    fn error_qpath_before_pat(&mut self, path: &Path, token: &str) -> PResult<'a, PatKind> {\n+        let msg = &format!(\"unexpected `{}` after qualified path\", token);\n+        let mut err = self.struct_span_err(self.token.span, msg);\n+        err.span_label(self.token.span, msg);\n+        err.span_label(path.span, \"the qualified path\");\n+        Err(err)\n+    }\n+\n     /// Parses the fields of a struct-like pattern.\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<FieldPat>, bool)> {\n         let mut fields = Vec::new();\n@@ -877,7 +880,8 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n                 let token_str = super::token_descr(&self.token);\n-                let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n+                let msg = &format!(\"expected `}}`, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n \n                 err.span_label(self.token.span, \"expected `}`\");\n                 let mut comma_sp = None;"}, {"sha": "325ad56cd2a43ff896dddaf1459234135e7187b2", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -93,7 +93,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {\n-                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n+                self.struct_span_err(path.span, \"unexpected generic arguments in path\").emit();\n             }\n             path\n         });\n@@ -325,24 +325,23 @@ impl<'a> Parser<'a> {\n \n                 // Make a span over ${unmatched angle bracket count} characters.\n                 let span = lo.with_hi(lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count));\n-                self.diagnostic()\n-                    .struct_span_err(\n-                        span,\n-                        &format!(\n-                            \"unmatched angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                    )\n-                    .span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"remove extra angle bracket{}\",\n-                            pluralize!(snapshot.unmatched_angle_bracket_count)\n-                        ),\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.struct_span_err(\n+                    span,\n+                    &format!(\n+                        \"unmatched angle bracket{}\",\n+                        pluralize!(snapshot.unmatched_angle_bracket_count)\n+                    ),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"remove extra angle bracket{}\",\n+                        pluralize!(snapshot.unmatched_angle_bracket_count)\n+                    ),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n \n                 // Try again without unmatched angle bracket characters.\n                 self.parse_generic_args()\n@@ -407,9 +406,11 @@ impl<'a> Parser<'a> {\n                     if self.token.is_bool_lit() {\n                         self.parse_literal_maybe_minus()?\n                     } else {\n-                        return Err(\n-                            self.fatal(\"identifiers may currently not be used for const generics\")\n-                        );\n+                        let span = self.token.span;\n+                        let msg = \"identifiers may currently not be used for const generics\";\n+                        self.struct_span_err(span, msg).emit();\n+                        let block = self.mk_block_err(span);\n+                        self.mk_expr(span, ast::ExprKind::Block(block, None), ast::AttrVec::new())\n                     }\n                 } else {\n                     self.parse_literal_maybe_minus()?"}, {"sha": "bf092ed14e342e7e802fb827d39dafa80648b780", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -193,7 +193,8 @@ impl<'a> Parser<'a> {\n             if self.prev_token_kind == PrevTokenKind::DocComment {\n                 self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.span_err(self.token.span, \"expected statement after outer attribute\");\n+                self.struct_span_err(self.token.span, \"expected statement after outer attribute\")\n+                    .emit();\n             }\n         }\n     }\n@@ -324,7 +325,7 @@ impl<'a> Parser<'a> {\n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n         let sp = self.token.span;\n         let tok = super::token_descr(&self.token);\n-        let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+        let mut e = self.struct_span_err(sp, &format!(\"expected `{{`, found {}\", tok));\n         let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n         // Check to see if the user has written something like\n@@ -397,10 +398,7 @@ impl<'a> Parser<'a> {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n-                    Some(self.mk_stmt(\n-                        self.token.span,\n-                        StmtKind::Expr(self.mk_expr_err(self.token.span)),\n-                    ))\n+                    Some(self.mk_stmt_err(self.token.span))\n                 }\n                 Ok(stmt) => stmt,\n             };\n@@ -478,4 +476,12 @@ impl<'a> Parser<'a> {\n     pub(super) fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n         Stmt { id: DUMMY_NODE_ID, kind, span }\n     }\n+\n+    fn mk_stmt_err(&self, span: Span) -> Stmt {\n+        self.mk_stmt(span, StmtKind::Expr(self.mk_expr_err(span)))\n+    }\n+\n+    pub(super) fn mk_block_err(&self, span: Span) -> P<Block> {\n+        self.mk_block(vec![self.mk_stmt_err(span)], BlockCheckMode::Default, span)\n+    }\n }"}, {"sha": "4f7bcf01e1b82ca8906f93defb2f05ae04bea2aa", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -175,7 +175,9 @@ impl<'a> Parser<'a> {\n                 {\n                     let path = match bounds.remove(0) {\n                         GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n-                        GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                        GenericBound::Outlives(..) => {\n+                            self.span_bug(ty.span, \"unexpected lifetime bound\")\n+                        }\n                     };\n                     self.parse_remaining_bounds(Vec::new(), path, lo, true)\n                 }"}, {"sha": "00ca06872c99ea4e8771bffc3eaf788e26a62f91", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -15,10 +15,11 @@ bitflags = \"1.2.1\"\n log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n rustc_expand = { path = \"../librustc_expand\" }\n-rustc = { path = \"../librustc\" }\n arena = { path = \"../libarena\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n syntax_pos = { path = \"../librustc_span\", package = \"rustc_span\" }\n+rustc = { path = \"../librustc\" }\n+rustc_ast_lowering = { path = \"../librustc_ast_lowering\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "069029d097b50d58e243bd3fed7f06122390d844", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::def::Namespace::*;\n use rustc::hir::def::{self, CtorKind, CtorOf, DefKind, ExportMap, NonMacroAttrKind, PartialRes};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::Definitions;\n-use rustc::hir::{self, Bool, Char, Float, Int, PrimTy, Str, Uint};\n+use rustc::hir::{Bool, Char, Float, Int, PrimTy, Str, Uint};\n use rustc::hir::{GlobMap, TraitMap};\n use rustc::lint;\n use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n@@ -1028,7 +1028,7 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n \n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n-impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn cstore(&self) -> &dyn CrateStore {\n         self.cstore()\n     }"}, {"sha": "841dd226b40583166b06679d04abb21459c68a21", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -11,7 +11,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        discrim: &'tcx hir::Expr<'tcx>,\n+        scrut: &'tcx hir::Expr<'tcx>,\n         arms: &'tcx [hir::Arm<'tcx>],\n         expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n@@ -27,7 +27,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Type check the descriminant and get its type.\n-        let discrim_ty = if force_scrutinee_bool {\n+        let scrut_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //\n             // 1. That default match bindings are *not* accepted in the condition of an\n@@ -36,9 +36,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n             //\n             // FIXME(60707): Consider removing hack with principled solution.\n-            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool, |_| {})\n+            self.check_expr_has_type_or_error(scrut, self.tcx.types.bool, |_| {})\n         } else {\n-            self.demand_discriminant_type(arms, discrim)\n+            self.demand_scrutinee_type(arms, scrut)\n         };\n \n         // If there are no arms, that is a diverging match; a special case.\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Otherwise, we have to union together the types that the\n         // arms produce and so forth.\n-        let discrim_diverges = self.diverges.get();\n+        let scrut_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n         // rust-lang/rust#55810: Typecheck patterns first (via eager\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .map(|arm| {\n                 let mut all_pats_diverge = Diverges::WarnedAlways;\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_top(&arm.pat, discrim_ty, Some(discrim.span));\n+                self.check_pat_top(&arm.pat, scrut_ty, Some(scrut.span), true);\n                 all_pats_diverge &= self.diverges.get();\n \n                 // As discussed with @eddyb, this is for disabling unreachable_code\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             source: match_src,\n                             prior_arms: other_arms.clone(),\n                             last_ty: prior_arm_ty.unwrap(),\n-                            discrim_hir_id: discrim.hir_id,\n+                            scrut_hir_id: scrut.hir_id,\n                         }),\n                     ),\n                 };\n@@ -186,8 +186,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n         }\n \n-        // We won't diverge unless the discriminant or all arms diverge.\n-        self.diverges.set(discrim_diverges | all_arms_diverge);\n+        // We won't diverge unless the scrutinee or all arms diverge.\n+        self.diverges.set(scrut_diverges | all_arms_diverge);\n \n         coercion.complete(self)\n     }\n@@ -388,14 +388,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn demand_discriminant_type(\n+    fn demand_scrutinee_type(\n         &self,\n         arms: &'tcx [hir::Arm<'tcx>],\n-        discrim: &'tcx hir::Expr<'tcx>,\n+        scrut: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Not entirely obvious: if matches may create ref bindings, we want to\n-        // use the *precise* type of the discriminant, *not* some supertype, as\n-        // the \"discriminant type\" (issue #23116).\n+        // use the *precise* type of the scrutinee, *not* some supertype, as\n+        // the \"scrutinee type\" (issue #23116).\n         //\n         // arielb1 [writes here in this comment thread][c] that there\n         // is certainly *some* potential danger, e.g., for an example\n@@ -454,17 +454,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         if let Some(m) = contains_ref_bindings {\n-            self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))\n+            self.check_expr_with_needs(scrut, Needs::maybe_mut_place(m))\n         } else {\n             // ...but otherwise we want to use any supertype of the\n-            // discriminant. This is sort of a workaround, see note (*) in\n+            // scrutinee. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            let discrim_ty = self.next_ty_var(TypeVariableOrigin {\n+            let scrut_ty = self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::TypeInference,\n-                span: discrim.span,\n+                span: scrut.span,\n             });\n-            self.check_expr_has_type_or_error(discrim, discrim_ty, |_| {});\n-            discrim_ty\n+            self.check_expr_has_type_or_error(scrut, scrut_ty, |_| {});\n+            scrut_ty\n         }\n     }\n }"}, {"sha": "48403687aabdc23c9351f30b607ba86d5df291f2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,13 +1,13 @@\n use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause};\n \n use errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::{self, is_range_literal, print, Node};\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::{self, AssocItem, Ty};\n-use syntax::symbol::sym;\n use syntax::util::parser::PREC_POSTFIX;\n+use syntax_pos::symbol::sym;\n use syntax_pos::Span;\n \n use super::method::probe;\n@@ -79,35 +79,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn demand_eqtype_pat_diag(\n-        &self,\n-        cause_span: Span,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let cause = if let Some(span) = match_expr_span {\n-            self.cause(\n-                cause_span,\n-                ObligationCauseCode::MatchExpressionArmPattern { span, ty: expected },\n-            )\n-        } else {\n-            self.misc(cause_span)\n-        };\n-        self.demand_eqtype_with_origin(&cause, expected, actual)\n-    }\n-\n-    pub fn demand_eqtype_pat(\n-        &self,\n-        cause_span: Span,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n-    ) {\n-        self.demand_eqtype_pat_diag(cause_span, expected, actual, match_expr_span)\n-            .map(|mut err| err.emit());\n-    }\n-\n     pub fn demand_coerce(\n         &self,\n         expr: &hir::Expr<'_>,"}, {"sha": "042c2fbd13a62e094a1e9f2a89d8c2c796f20f91", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1268,13 +1268,17 @@ fn check_fn<'a, 'tcx>(\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n+    let tcx = fcx.tcx;\n+    let sess = tcx.sess;\n+    let hir = tcx.hir();\n+\n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n-    fn_sig = fcx.tcx.mk_fn_sig(\n+    fn_sig = tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n         fn_sig.c_variadic,\n@@ -1284,7 +1288,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    fn_maybe_err(fcx.tcx, span, fn_sig.abi);\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n \n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n@@ -1293,37 +1297,39 @@ fn check_fn<'a, 'tcx>(\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n-    let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did = fcx.tcx.require_lang_item(\n+        let va_list_did = tcx.require_lang_item(\n             lang_items::VaListTypeLangItem,\n             Some(body.params.last().unwrap().span),\n         );\n-        let region = fcx.tcx.mk_region(ty::ReScope(region::Scope {\n+        let region = tcx.mk_region(ty::ReScope(region::Scope {\n             id: body.value.hir_id.local_id,\n             data: region::ScopeData::CallSite,\n         }));\n \n-        Some(fcx.tcx.type_of(va_list_did).subst(fcx.tcx, &[region.into()]))\n+        Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n     } else {\n         None\n     };\n \n     // Add formal parameters.\n-    for (param_ty, param) in fn_sig.inputs().iter().copied().chain(maybe_va_list).zip(body.params) {\n+    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n+    let inputs_fn = fn_sig.inputs().iter().copied();\n+    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n         // Check the pattern.\n-        fcx.check_pat_top(&param.pat, param_ty, None);\n+        fcx.check_pat_top(&param.pat, param_ty, try { inputs_hir?.get(idx)?.span }, false);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n             fcx.require_type_is_sized(param_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n@@ -1384,11 +1390,11 @@ fn check_fn<'a, 'tcx>(\n     fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n \n     // Check that the main return type implements the termination trait.\n-    if let Some(term_id) = fcx.tcx.lang_items().termination() {\n-        if let Some((def_id, EntryFnType::Main)) = fcx.tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+    if let Some(term_id) = tcx.lang_items().termination() {\n+        if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n+            let main_id = hir.as_local_hir_id(def_id).unwrap();\n             if main_id == fn_id {\n-                let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n                 let cause = traits::ObligationCause::new(\n@@ -1407,15 +1413,15 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n+        if panic_impl_did == hir.local_def_id(fn_id) {\n+            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].kind {\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n@@ -1430,52 +1436,50 @@ fn check_fn<'a, 'tcx>(\n                     };\n \n                     if !arg_is_panic_info {\n-                        fcx.tcx\n-                            .sess\n-                            .span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(span, \"should have no type parameters\");\n+                                sess.span_err(span, \"should have no type parameters\");\n                             }\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+                sess.err(\"language item required, but not found: `panic_info`\");\n             }\n         }\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id) {\n+            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].kind {\n                         ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n                         _ => false,\n                     };\n \n                     if !arg_is_alloc_layout {\n-                        fcx.tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(\n+                                sess.span_err(\n                                     span,\n                                     \"`#[alloc_error_handler]` function should have no type \\\n                                      parameters\",\n@@ -1484,11 +1488,11 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+                sess.err(\"language item required, but not found: `alloc_layout`\");\n             }\n         }\n     }\n@@ -4304,18 +4308,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Type check a `let` statement.\n     pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n-        let t = self.local_ty(local.span, local.hir_id).decl_ty;\n-        self.write_ty(local.hir_id, t);\n+        // Determine and write the type which we'll check the pattern against.\n+        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n+        self.write_ty(local.hir_id, ty);\n \n+        // Type check the initializer.\n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n-            self.overwrite_local_ty_if_err(local, t, init_ty);\n+            self.overwrite_local_ty_if_err(local, ty, init_ty);\n         }\n \n-        self.check_pat_top(&local.pat, t, None);\n+        // Does the expected pattern type originate from an expression and what is the span?\n+        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n+            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+        };\n+\n+        // Type check the pattern. Override if necessary to avoid knock-on errors.\n+        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n-        self.overwrite_local_ty_if_err(local, t, pat_ty);\n+        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n     }\n \n     fn overwrite_local_ty_if_err(\n@@ -4325,7 +4340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n-            // Override the types everywhere with `types.err` to avoid knock down errors.\n+            // Override the types everywhere with `types.err` to avoid knock on errors.\n             self.write_ty(local.hir_id, ty);\n             self.write_ty(local.pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };"}, {"sha": "759118933960367a89a1159a027a9e331fd9b95c", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 124, "deletions": 81, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::{self, HirId, Pat, PatKind};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::traits::Pattern;\n use rustc::ty::subst::GenericArg;\n use rustc::ty::{self, BindingMode, Ty, TypeFoldable};\n use syntax::ast;\n@@ -29,39 +30,97 @@ pointers. If you encounter this error you should try to avoid dereferencing the\n You can read more about trait objects in the Trait Objects section of the Reference: \\\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_pat_top(\n-        &self,\n-        pat: &'tcx Pat<'tcx>,\n-        expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, discrim_span);\n-    }\n-\n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+/// Information about the expected type at the top level of type checking a pattern.\n+///\n+/// **NOTE:** This is only for use by diagnostics. Do NOT use for type checking logic!\n+#[derive(Copy, Clone)]\n+struct TopInfo<'tcx> {\n+    /// The `expected` type at the top level of type checking a pattern.\n+    expected: Ty<'tcx>,\n+    /// Was the origin of the `span` from a scrutinee expression?\n+    ///\n+    /// Otherwise there is no scrutinee and it could be e.g. from the type of a formal parameter.\n+    origin_expr: bool,\n+    /// The span giving rise to the `expected` type, if one could be provided.\n+    ///\n+    /// If `origin_expr` is `true`, then this is the span of the scrutinee as in:\n+    ///\n+    /// - `match scrutinee { ... }`\n+    /// - `let _ = scrutinee;`\n+    ///\n+    /// This is used to point to add context in type errors.\n+    /// In the following example, `span` corresponds to the `a + b` expression:\n     ///\n     /// ```text\n     /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n+    ///  --> src/main.rs:L:C\n     ///   |\n-    /// 4 |    let temp: usize = match a + b {\n+    /// L |    let temp: usize = match a + b {\n     ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n+    /// L |         Ok(num) => num,\n     ///   |         ^^^^^^^ expected `usize`, found enum `std::result::Result`\n     ///   |\n     ///   = note: expected type `usize`\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n+    span: Option<Span>,\n+}\n+\n+impl<'tcx> FnCtxt<'_, 'tcx> {\n+    fn demand_eqtype_pat_diag(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        let cause = self.cause(cause_span, code);\n+        self.demand_eqtype_with_origin(&cause, expected, actual)\n+    }\n+\n+    fn demand_eqtype_pat(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) {\n+        self.demand_eqtype_pat_diag(cause_span, expected, actual, ti).map(|mut err| err.emit());\n+    }\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type check the given top level pattern against the `expected` type.\n+    ///\n+    /// If a `Some(span)` is provided and `origin_expr` holds,\n+    /// then the `span` represents the scrutinee's span.\n+    /// The scrutinee is found in e.g. `match scrutinee { ... }` and `let pat = scrutinee;`.\n+    ///\n+    /// Otherwise, `Some(span)` represents the span of a type expression\n+    /// which originated the `expected` type.\n+    pub fn check_pat_top(\n+        &self,\n+        pat: &'tcx Pat<'tcx>,\n+        expected: Ty<'tcx>,\n+        span: Option<Span>,\n+        origin_expr: bool,\n+    ) {\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n+        self.check_pat(pat, expected, def_bm, TopInfo { expected, origin_expr, span });\n+    }\n+\n+    /// Type check the given `pat` against the `expected` type\n+    /// with the provided `def_bm` (default binding mode).\n+    ///\n+    /// Outside of this module, `check_pat_top` should always be used.\n+    /// Conversely, inside this module, `check_pat_top` should never be used.\n     fn check_pat(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n@@ -72,60 +131,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n         let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n \n-        let ty = match &pat.kind {\n+        let ty = match pat.kind {\n             PatKind::Wild => expected,\n-            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, ti),\n             PatKind::Range(begin, end, _) => {\n-                match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n+                match self.check_pat_range(pat.span, begin, end, expected, ti) {\n                     None => return,\n                     Some(ty) => ty,\n                 }\n             }\n             PatKind::Binding(ba, var_id, _, sub) => {\n-                let sub = sub.as_deref();\n-                self.check_pat_ident(pat, *ba, *var_id, sub, expected, def_bm, discrim_span)\n+                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, ti)\n             }\n-            PatKind::TupleStruct(qpath, subpats, ddpos) => self.check_pat_tuple_struct(\n-                pat,\n-                qpath,\n-                subpats,\n-                *ddpos,\n-                expected,\n-                def_bm,\n-                discrim_span,\n-            ),\n-            PatKind::Path(qpath) => {\n+            PatKind::TupleStruct(ref qpath, subpats, ddpos) => {\n+                self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n+            }\n+            PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n             }\n-            PatKind::Struct(qpath, fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n+            PatKind::Struct(ref qpath, fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n-                for pat in *pats {\n-                    self.check_pat(pat, expected, def_bm, discrim_span);\n+                for pat in pats {\n+                    self.check_pat(pat, expected, def_bm, ti);\n                 }\n                 expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, *elements, *ddpos, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Box(inner) => {\n-                self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n+                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, ti)\n             }\n+            PatKind::Box(inner) => self.check_pat_box(pat.span, inner, expected, def_bm, ti),\n             PatKind::Ref(inner, mutbl) => {\n-                self.check_pat_ref(pat, inner, *mutbl, expected, def_bm, discrim_span)\n+                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, ti)\n             }\n             PatKind::Slice(before, slice, after) => {\n-                let slice = slice.as_deref();\n-                self.check_pat_slice(\n-                    pat.span,\n-                    *before,\n-                    slice,\n-                    *after,\n-                    expected,\n-                    def_bm,\n-                    discrim_span,\n-                )\n+                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, ti)\n             }\n         };\n \n@@ -302,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lt: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // We've already computed the type above (when checking for a non-ref pat),\n         // so avoid computing it again.\n@@ -336,7 +377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // then that's equivalent to there existing a LUB.\n         if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n             err.emit_unless(\n-                discrim_span\n+                ti.span\n                     .filter(|&s| {\n                         // In the case of `if`- and `while`-expressions we've already checked\n                         // that `scrutinee: bool`. We know that the pattern is `true`,\n@@ -356,7 +397,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         rhs: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         let lhs_ty = self.check_expr(lhs);\n         let rhs_ty = self.check_expr(rhs);\n@@ -377,7 +418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x_span, y_span, x_ty, y_ty| {\n-            self.demand_eqtype_pat_diag(x_span, expected, x_ty, discrim_span).map(|mut err| {\n+            self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n                 self.endpoint_has_type(&mut err, y_span, y_ty);\n                 err.emit();\n             });\n@@ -451,7 +492,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sub: Option<&'tcx Pat<'tcx>>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n@@ -481,17 +522,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected\n             }\n         };\n-        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, ti);\n \n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n             let vt = self.local_ty(pat.span, var_id).decl_ty;\n-            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, discrim_span);\n+            self.check_pat(&p, expected, def_bm, ti);\n         }\n \n         local_ty\n@@ -570,24 +611,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n         {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        if self\n+            .check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm, ti)\n         {\n             pat_ty\n         } else {\n@@ -638,12 +680,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        match_arm_pat_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+                self.check_pat(&pat, tcx.types.err, def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -704,7 +746,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n         // Type-check the tuple struct pattern against the expected type.\n-        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, match_arm_pat_span);\n+        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, ti);\n         let had_err = diag.is_some();\n         diag.map(|mut err| err.emit());\n \n@@ -718,7 +760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n+                self.check_pat(&subpat, field_ty, def_bm, ti);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -822,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let mut expected_len = elements.len();\n@@ -849,12 +891,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // further errors being emitted when using the bindings. #50333\n             let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(elem, &tcx.types.err, def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, ti);\n             }\n             pat_ty\n         }\n@@ -869,6 +911,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         def_bm: BindingMode,\n+        ti: TopInfo<'tcx>,\n     ) -> bool {\n         let tcx = self.tcx;\n \n@@ -918,7 +961,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, None);\n+            self.check_pat(&field.pat, field_ty, def_bm, ti);\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1095,7 +1138,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         inner: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n@@ -1106,12 +1149,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span: inner.span,\n             });\n             let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, discrim_span);\n+            self.demand_eqtype_pat(span, expected, box_ty, ti);\n             (box_ty, inner_ty)\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         box_ty\n     }\n \n@@ -1122,7 +1165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n@@ -1157,7 +1200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         rptr_ty\n     }\n \n@@ -1186,7 +1229,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         after: &'tcx [&'tcx Pat<'tcx>],\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n@@ -1211,15 +1254,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n+            self.check_pat(&slice, slice_ty, def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         expected\n     }"}, {"sha": "f06fe1e4bf2113ccbd6ec5e23caa3ead106e8136", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -65,6 +65,7 @@ This API is completely unstable and subject to change.\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(slice_patterns)]\n+#![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "4c94a601f33fd960cf3fd7e82c6e461a9f1908bf", "filename": "src/test/codegen/force-frame-pointers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fcodegen%2Fforce-frame-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fcodegen%2Fforce-frame-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fforce-frame-pointers.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,7 +1,7 @@\n-//\n+// min-llvm-version 8.0\n // compile-flags: -C no-prepopulate-passes -C force-frame-pointers=y\n \n #![crate_type=\"lib\"]\n \n-// CHECK: attributes #{{.*}} \"no-frame-pointer-elim\"=\"true\"\n+// CHECK: attributes #{{.*}} \"frame-pointer\"=\"all\"\n pub fn foo() {}"}, {"sha": "e4e6d5ca2b850d69d86a2880857a1f5bdc06674a", "filename": "src/test/codegen/instrument-mcount.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fcodegen%2Finstrument-mcount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fcodegen%2Finstrument-mcount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finstrument-mcount.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -1,7 +1,8 @@\n+// min-llvm-version 8.0\n // ignore-tidy-linelength\n // compile-flags: -Z instrument-mcount\n \n #![crate_type = \"lib\"]\n \n-// CHECK: attributes #{{.*}} \"instrument-function-entry-inlined\"=\"{{.*}}mcount{{.*}}\" \"no-frame-pointer-elim\"=\"true\"\n+// CHECK: attributes #{{.*}} \"frame-pointer\"=\"all\" \"instrument-function-entry-inlined\"=\"{{.*}}mcount{{.*}}\"\n pub fn foo() {}"}, {"sha": "416f055251b04076e82cd19c78a8ae76978dbdab", "filename": "src/test/ui/block-result/issue-13624.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -10,7 +10,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13624.rs:20:9\n    |\n LL |       match enum_struct_variant {\n-   |             ------------------- this match expression has type `()`\n+   |             ------------------- this expression has type `()`\n LL |         a::Enum::EnumStructVariant { x, y, z } => {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `a::Enum`\n "}, {"sha": "c78166f411d2855d8c3fb287720631bc7b7fe71c", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -44,7 +44,9 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:42:13\n    |\n LL |     let box box x = box 1isize as Box<dyn T>;\n-   |             ^^^^^ expected trait `T`, found struct `std::boxed::Box`\n+   |             ^^^^^   ------------------------ this expression has type `std::boxed::Box<dyn T>`\n+   |             |\n+   |             expected trait `T`, found struct `std::boxed::Box`\n    |\n    = note: expected trait object `dyn T`\n                     found struct `std::boxed::Box<_>`"}, {"sha": "39c0676373794b45135c49e01d9b0412963e7ba6", "filename": "src/test/ui/error-codes/E0308-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/E0308-4.rs:4:15\n    |\n LL |     match x {\n-   |           - this match expression has type `u8`\n+   |           - this expression has type `u8`\n LL |         0u8..=3i8 => (),\n    |         ---   ^^^ expected `u8`, found `i8`\n    |         |"}, {"sha": "76ae7241ff2771959a918eccf81ac291061ea71b", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99.., _] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "5c96f8041feb26cf84ac88905d3518225d3e173e", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -14,7 +14,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99..] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "17e10324db18187df60dbbd0010c941f59070a18", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:12\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |            ^ expected struct `std::ops::Range`, found integer\n    |\n@@ -19,7 +19,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:15\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               ^^  --- this is of type `{integer}`\n    |               |\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:19\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               --  ^^^ expected struct `std::ops::Range`, found integer\n    |               |"}, {"sha": "57533ba5e370b86d35ce9fa6eab0c1fd31af61ef", "filename": "src/test/ui/issues/issue-11844.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-11844.rs:6:9\n    |\n LL |     match a {\n-   |           - this match expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n+   |           - this expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n LL |         Ok(a) =>\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "60c4cceac51bef60570b9aaa89475b0e573c7a04", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:6:5\n    |\n LL |   match t {\n-   |         - this match expression has type `std::result::Result<_, {integer}>`\n+   |         - this expression has type `std::result::Result<_, {integer}>`\n LL |     Some(k) => match k {\n    |     ^^^^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "52d9e2a91b971e9d849faa03e71562b45f925bef", "filename": "src/test/ui/issues/issue-13466.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:8:9\n    |\n LL |     let _x: usize = match Some(1) {\n-   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+   |                           ------- this expression has type `std::option::Option<{integer}>`\n LL |         Ok(u) => u,\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:14:9\n    |\n LL |     let _x: usize = match Some(1) {\n-   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+   |                           ------- this expression has type `std::option::Option<{integer}>`\n ...\n LL |         Err(e) => panic!(e)\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`"}, {"sha": "cf155f428c6a0606769b9918a0f194719319ee2b", "filename": "src/test/ui/issues/issue-14541.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-14541.rs:5:9\n    |\n LL |     let Vec3 { y: _, z: _ } = v;\n-   |         ^^^^^^^^^^^^^^^^^^^ expected struct `Vec2`, found struct `Vec3`\n+   |         ^^^^^^^^^^^^^^^^^^^   - this expression has type `Vec2`\n+   |         |\n+   |         expected struct `Vec2`, found struct `Vec3`\n \n error: aborting due to previous error\n "}, {"sha": "b3f0907b81d2595406b87aa7f099a2e02c35be0a", "filename": "src/test/ui/issues/issue-15896.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-15896.rs:11:11\n    |\n LL |     let u = match e {\n-   |                   - this match expression has type `main::R`\n+   |                   - this expression has type `main::E`\n LL |         E::B(\n LL |           Tau{t: x},\n    |           ^^^^^^^^^ expected enum `main::R`, found struct `main::Tau`"}, {"sha": "6878600b0298338535d7e1dd7216e62e5be0a670", "filename": "src/test/ui/issues/issue-16338.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-16338.rs:7:9\n    |\n LL |     let Slice { data: data, len: len } = \"foo\";\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `Slice`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `&str`\n+   |         |\n+   |         expected `str`, found struct `Slice`\n    |\n    = note: expected type `str`\n             found struct `Slice<_>`"}, {"sha": "f8ea0907099a5d0a39f4228f6978271258ff5dfb", "filename": "src/test/ui/issues/issue-16401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-16401.rs:8:9\n    |\n LL |     match () {\n-   |           -- this match expression has type `()`\n+   |           -- this expression has type `()`\n LL |         Slice { data: data, len: len } => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `Slice`\n    |"}, {"sha": "713e4b5ccd57575720f08173d3ef8b782f0b85f9", "filename": "src/test/ui/issues/issue-3680.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-3680.rs:3:9\n    |\n LL |     match None {\n-   |           ---- this match expression has type `std::option::Option<_>`\n+   |           ---- this expression has type `std::option::Option<_>`\n LL |         Err(_) => ()\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "361369e68bc0869238375f4c2747ea4e9cca7499", "filename": "src/test/ui/issues/issue-37026.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -8,7 +8,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:7:9\n    |\n LL |     let empty_struct::XEmpty6(..) = ();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `empty_struct::XEmpty6`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found struct `empty_struct::XEmpty6`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c47e8689436ee1e7ee3dea504ef8e95c0e2ea35c", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -29,7 +29,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:33:9\n    |\n LL |     match (true, false) {\n-   |           ------------- this match expression has type `(bool, bool)`\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         box (true, false) => ()\n    |         ^^^^^^^^^^^^^^^^^ expected tuple, found struct `std::boxed::Box`\n    |"}, {"sha": "314d1fddbd76a5ff9598bc3505d44d46e69cba3e", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-5358-1.rs:6:9\n    |\n LL |     match S(Either::Left(5)) {\n-   |           ------------------ this match expression has type `S`\n+   |           ------------------ this expression has type `S`\n LL |         Either::Right(_) => {}\n    |         ^^^^^^^^^^^^^^^^ expected struct `S`, found enum `Either`\n    |"}, {"sha": "a4f1ac94825d59f38388fc00de6ee1fdef528e94", "filename": "src/test/ui/issues/issue-57741-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-57741-1.rs:14:9\n    |\n LL |     let y = match x {\n-   |                   - this match expression has type `std::boxed::Box<u32>`\n+   |                   - this expression has type `std::boxed::Box<u32>`\n LL |         S::A { a } | S::B { b: a } => a,\n    |         ^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n    |\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-57741-1.rs:14:22\n    |\n LL |     let y = match x {\n-   |                   - this match expression has type `std::boxed::Box<u32>`\n+   |                   - this expression has type `std::boxed::Box<u32>`\n LL |         S::A { a } | S::B { b: a } => a,\n    |                      ^^^^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n    |"}, {"sha": "6f9e5b08a833f1990dc0ae107d28132f5e33e648", "filename": "src/test/ui/issues/issue-57741.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<T>`\n+   |                   this expression has type `std::boxed::Box<T>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         T::A(a) | T::B(a) => a,\n    |         ^^^^^^^ expected struct `std::boxed::Box`, found enum `T`\n@@ -18,7 +18,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<T>`\n+   |                   this expression has type `std::boxed::Box<T>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         T::A(a) | T::B(a) => a,\n    |                   ^^^^^^^ expected struct `std::boxed::Box`, found enum `T`\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<S>`\n+   |                   this expression has type `std::boxed::Box<S>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         S::A { a } | S::B { b: a } => a,\n    |         ^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n@@ -46,7 +46,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<S>`\n+   |                   this expression has type `std::boxed::Box<S>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         S::A { a } | S::B { b: a } => a,\n    |                      ^^^^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`"}, {"sha": "6e8ea6bf618f2fdb1a86ba90a83c755a3135326f", "filename": "src/test/ui/issues/issue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-67037-pat-tup-scrut-ty-diff-less-fields.rs:19:9\n    |\n LL |     let P() = U {};\n-   |         ^^^ expected struct `U`, found struct `P`\n+   |         ^^^   ---- this expression has type `U`\n+   |         |\n+   |         expected struct `U`, found struct `P`\n    |\n    = note: expected struct `U`\n               found struct `P<_>`"}, {"sha": "590dd40c65364238fb48e0d2ad48099a7d846c47", "filename": "src/test/ui/issues/issue-7092.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-7092.rs:6:9\n    |\n LL |     match x {\n-   |           - this match expression has type `Whatever`\n+   |           - this expression has type `Whatever`\n LL |         Some(field) =>\n    |         ^^^^^^^^^^^ expected enum `Whatever`, found enum `std::option::Option`\n    |"}, {"sha": "a475bd5e5819c7a4e9d844e2fb9c659882203e43", "filename": "src/test/ui/match/match-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/match-struct.rs:6:9\n    |\n LL |     match (S { a: 1 }) {\n-   |           ------------ this match expression has type `S`\n+   |           ------------ this expression has type `S`\n LL |         E::C(_) => (),\n    |         ^^^^^^^ expected struct `S`, found enum `E`\n "}, {"sha": "31f77bdff8b1f00d63f4e312acfcec3a9ab1eb7b", "filename": "src/test/ui/match/match-tag-unary.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn main() { let x: A = A::A(0); match x { B::B(y) => { } } }\n    |                                       -   ^^^^^^^ expected enum `A`, found enum `B`\n    |                                       |\n-   |                                       this match expression has type `A`\n+   |                                       this expression has type `A`\n \n error: aborting due to previous error\n "}, {"sha": "2306fb352738f80ef17a57d06ce6e1f8522f1e4c", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -9,6 +9,8 @@ LL |         (0, ref y) | (y, 0) => {}\n error[E0308]: mismatched types\n   --> $DIR/E0409.rs:5:23\n    |\n+LL |     match x {\n+   |           - this expression has type `({integer}, {integer})`\n LL |         (0, ref y) | (y, 0) => {}\n    |                       ^ expected `&{integer}`, found integer\n "}, {"sha": "948c91370d0d41496df712a5588f239ab8457917", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -94,7 +94,9 @@ error[E0308]: mismatched types\n   --> $DIR/already-bound-name.rs:33:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                               ^ expected integer, found enum `E`\n+   |                               ^                    ------- this expression has type `E<E<{integer}>>`\n+   |                               |\n+   |                               expected integer, found enum `E`\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`"}, {"sha": "7c1638ff94d0f636bf3a3191bcb642c551eaa67e", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -60,7 +60,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:13:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                         ^^^^^^^^^ types differ in mutability\n+   |                         ^^^^^^^^^   -------------------- expected due to this\n+   |                         |\n+   |                         types differ in mutability\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n@@ -69,7 +71,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:16:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                               ^^^^^^^^^ types differ in mutability\n+   |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n+   |                               |\n+   |                               types differ in mutability\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`"}, {"sha": "bc288e06250751d914801818d0240c36253341cb", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/or-pattern-mismatch.rs:3:68\n    |\n LL | fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-   |                                                                    ^ expected `usize`, found `isize`\n+   |                   ---------------- this expression has type `Blah` ^ expected `usize`, found `isize`\n \n error: aborting due to previous error\n "}, {"sha": "f6d2bee0e15600a300d1d8e4de5915ba78e7bfb3", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -112,3 +112,4 @@ fn main() {}\n #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n //~^ ERROR expected statement after outer attribute\n #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n+//~^ ERROR expected statement after outer attribute"}, {"sha": "0123006418a3a71545846f7bcc420649e7155a25", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -410,5 +410,11 @@ error: expected statement after outer attribute\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                            ^\n \n-error: aborting due to 56 previous errors\n+error: expected statement after outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:114:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n+   |                                             ^\n+\n+error: aborting due to 57 previous errors\n "}, {"sha": "d6fdf353f07af3f9e5c790d31b61aabcfd3b9eac", "filename": "src/test/ui/parser/brace-after-qualified-path-in-match.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,9 @@ error: unexpected `{` after qualified path\n   --> $DIR/brace-after-qualified-path-in-match.rs:3:27\n    |\n LL |         <T as Trait>::Type{key: value} => (),\n-   |                           ^ unexpected `{` after qualified path\n+   |         ------------------^ unexpected `{` after qualified path\n+   |         |\n+   |         the qualified path\n \n error: aborting due to previous error\n "}, {"sha": "af21f9195467ae0511287ecd646031ae0f95a982", "filename": "src/test/ui/parser/paren-after-qualified-path-in-match.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,9 @@ error: unexpected `(` after qualified path\n   --> $DIR/paren-after-qualified-path-in-match.rs:3:27\n    |\n LL |         <T as Trait>::Type(2) => (),\n-   |                           ^ unexpected `(` after qualified path\n+   |         ------------------^ unexpected `(` after qualified path\n+   |         |\n+   |         the qualified path\n \n error: aborting due to previous error\n "}, {"sha": "8ff4f948a05ec5132610e1f5d5d82dca9797906c", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -17,7 +17,7 @@ error[E0308]: mismatched types\n   --> $DIR/pat-tuple-5.rs:5:10\n    |\n LL |     match (0, 1) {\n-   |           ------ this match expression has type `({integer}, {integer})`\n+   |           ------ this expression has type `({integer}, {integer})`\n LL |         (PAT ..) => {}\n    |          ^^^ expected tuple, found `u8`\n    |"}, {"sha": "3fed64c191a8a2de52c518513935c66e64aa1cd6", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -425,8 +425,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:23:16\n    |\n LL |     if let X.. .0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -457,8 +458,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:36:16\n    |\n LL |     if let X..=.0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -489,8 +491,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:52:17\n    |\n LL |     if let X... .0 = 0 {}\n-   |            -    ^^ expected integer, found floating-point number\n-   |            |\n+   |            -    ^^   - this expression has type `u8`\n+   |            |    |\n+   |            |    expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns"}, {"sha": "1d18214de7f08ac263ba45ad14965c389b0f7b7e", "filename": "src/test/ui/pattern/pat-struct-field-expr-has-type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,9 @@\n+struct S {\n+    f: u8,\n+}\n+\n+fn main() {\n+    match (S { f: 42 }) {\n+        S { f: Ok(_) } => {} //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "d57a8a0dbc1813ef299b788abad195e00215ac4c", "filename": "src/test/ui/pattern/pat-struct-field-expr-has-type.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-struct-field-expr-has-type.rs:7:16\n+   |\n+LL |     match (S { f: 42 }) {\n+   |           ------------- this expression has type `S`\n+LL |         S { f: Ok(_) } => {}\n+   |                ^^^^^ expected `u8`, found enum `std::result::Result`\n+   |\n+   = note: expected type `u8`\n+              found enum `std::result::Result<_, _>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "54336b3492321f5459ae1fd797c44a563dbc2d13", "filename": "src/test/ui/pattern/pat-type-err-formal-param.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,8 @@\n+// Test the `.span_label(..)` to the type when there's a\n+// type error in a pattern due to a the formal parameter.\n+\n+fn main() {}\n+\n+struct Tuple(u8);\n+\n+fn foo(Tuple(_): String) {} //~ ERROR mismatched types"}, {"sha": "2d7eb62faef2bb272697ec7adf116950f06baf93", "filename": "src/test/ui/pattern/pat-type-err-formal-param.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-formal-param.rs:8:8\n+   |\n+LL | fn foo(Tuple(_): String) {}\n+   |        ^^^^^^^^  ------ expected due to this\n+   |        |\n+   |        expected struct `std::string::String`, found struct `Tuple`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6e9850b655cb9f67183e68062a65699525443aeb", "filename": "src/test/ui/pattern/pat-type-err-let-stmt.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,16 @@\n+// Test the `.span_label` to the type / scrutinee\n+// when there's a type error in checking a pattern.\n+\n+fn main() {\n+    // We want to point at the `Option<u8>`.\n+    let Ok(0): Option<u8> = 42u8;\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // We want to point at the `Option<u8>`.\n+    let Ok(0): Option<u8>;\n+    //~^ ERROR mismatched types\n+\n+    // We want to point at the scrutinee.\n+    let Ok(0) = 42u8; //~ ERROR mismatched types\n+}"}, {"sha": "d75fa3f247c451cc47bc7a81a8303e8edd597be5", "filename": "src/test/ui/pattern/pat-type-err-let-stmt.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -0,0 +1,49 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:6:29\n+   |\n+LL |     let Ok(0): Option<u8> = 42u8;\n+   |                ----------   ^^^^\n+   |                |            |\n+   |                |            expected enum `std::option::Option`, found `u8`\n+   |                |            help: try using a variant of the expected enum: `Some(42u8)`\n+   |                expected due to this\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found type `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:6:9\n+   |\n+LL |     let Ok(0): Option<u8> = 42u8;\n+   |         ^^^^^  ---------- expected due to this\n+   |         |\n+   |         expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found enum `std::result::Result<_, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:11:9\n+   |\n+LL |     let Ok(0): Option<u8>;\n+   |         ^^^^^  ---------- expected due to this\n+   |         |\n+   |         expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found enum `std::result::Result<_, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:15:9\n+   |\n+LL |     let Ok(0) = 42u8;\n+   |         ^^^^^   ---- this expression has type `u8`\n+   |         |\n+   |         expected `u8`, found enum `std::result::Result`\n+   |\n+   = note: expected type `u8`\n+              found enum `std::result::Result<_, _>`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "60f76796c03969717613163d2a4b186361bdedf7", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -28,7 +28,7 @@ error[E0308]: mismatched types\n   --> $DIR/pattern-error-continue.rs:22:9\n    |\n LL |     match 'c' {\n-   |           --- this match expression has type `char`\n+   |           --- this expression has type `char`\n LL |         S { .. } => (),\n    |         ^^^^^^^^ expected `char`, found struct `S`\n "}, {"sha": "15425da69bcc48595ddf2221f181ae5aa6c4d812", "filename": "src/test/ui/pattern/pattern-tyvar.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/pattern-tyvar.rs:5:18\n    |\n LL |     match t {\n-   |           - this match expression has type `std::option::Option<std::vec::Vec<isize>>`\n+   |           - this expression has type `Bar`\n LL |       Bar::T1(_, Some::<isize>(x)) => {\n    |                  ^^^^^^^^^^^^^^^^ expected struct `std::vec::Vec`, found `isize`\n    |"}, {"sha": "61d1001ce9154f154e0665d3b26b9c3a653a7ecd", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -23,18 +23,24 @@ LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:7:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:16:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:25:36\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n    |                                    ^^^^^ types differ in mutability\n    |"}, {"sha": "5c87f7c684f3b0695c6c4b63f76e80a8cc2ae398", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -86,6 +86,8 @@ LL |         (CONST1, _) | (_, Const2) => ()\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-names.rs:19:19\n    |\n+LL |     match x {\n+   |           - this expression has type `(E, E)`\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |                   ^^^^^ expected enum `E`, found `&E`\n "}, {"sha": "7170adca60dc345b4c6516512a59d687ed7e3340", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -630,7 +630,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:67:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -650,7 +650,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:71:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -697,7 +697,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:86:12\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -818,7 +818,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:131:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -838,7 +838,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:135:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -885,7 +885,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:150:15\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -961,7 +961,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:198:10\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |          |\n    |          expected `bool`, found struct `std::ops::Range`\n    |"}, {"sha": "8cfa118a2dac2a3964028fe3e4aaba814d357429", "filename": "src/test/ui/structs/structure-constructor-type-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -86,7 +86,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:54:9\n    |\n LL |     match (Point { x: 1, y: 2 }) {\n-   |           ---------------------- this match expression has type `Point<{integer}>`\n+   |           ---------------------- this expression has type `Point<{integer}>`\n LL |         PointF::<u32> { .. } => {}\n    |         ^^^^^^^^^^^^^^^^^^^^ expected integer, found `f32`\n    |\n@@ -97,7 +97,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:59:9\n    |\n LL |     match (Point { x: 1, y: 2 }) {\n-   |           ---------------------- this match expression has type `Point<{integer}>`\n+   |           ---------------------- this expression has type `Point<{integer}>`\n LL |         PointF { .. } => {}\n    |         ^^^^^^^^^^^^^ expected integer, found `f32`\n    |\n@@ -108,7 +108,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:67:9\n    |\n LL |     match (Pair { x: 1, y: 2 }) {\n-   |           --------------------- this match expression has type `Pair<{integer}, {integer}>`\n+   |           --------------------- this expression has type `Pair<{integer}, {integer}>`\n LL |         PairF::<u32> { .. } => {}\n    |         ^^^^^^^^^^^^^^^^^^^ expected integer, found `f32`\n    |"}, {"sha": "1634fdde7d29504a048100fccebcb26b9244aa61", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/119307a83e12291a3fc126735d6bd0292c443464/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr?ref=119307a83e12291a3fc126735d6bd0292c443464", "patch": "@@ -5,11 +5,12 @@ LL |         Some(vec![_x]) => (),\n    |              ^^^^^^^^\n    |              |\n    |              unexpected `(` after qualified path\n+   |              the qualified path\n    |              in this macro invocation\n    |              help: use a slice pattern here instead: `[_x]`\n    |\n    = help: for more information, see https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}