{"sha": "ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOTNiNjk1ZDFmYzgzNDBkNTIwYWVhMWFkMjJlMWQzNTkzMGUxZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T23:47:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:45Z"}, "message": "MIR typeck: refactor to track region constraints", "tree": {"sha": "929415126327a42b082a94bd6a42872ccef9588b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/929415126327a42b082a94bd6a42872ccef9588b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "html_url": "https://github.com/rust-lang/rust/commit/ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad93b695d1fc8340d520aea1ad22e1d35930e1e2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37945fe3e89951a92c5abd110e8fa1a368c7eed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/37945fe3e89951a92c5abd110e8fa1a368c7eed9", "html_url": "https://github.com/rust-lang/rust/commit/37945fe3e89951a92c5abd110e8fa1a368c7eed9"}], "stats": {"total": 322, "additions": 250, "deletions": 72}, "files": [{"sha": "a9e36a5740fdace9fc283098ed0c889c810530d6", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad93b695d1fc8340d520aea1ad22e1d35930e1e2/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad93b695d1fc8340d520aea1ad22e1d35930e1e2/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "patch": "@@ -896,3 +896,11 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> RegionConstraintData<'tcx> {\n+    /// True if this region constraint data contains no constraints.\n+    pub fn is_empty(&self) -> bool {\n+        let RegionConstraintData { constraints, verifys, givens } = self;\n+        constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+    }\n+}"}, {"sha": "a3dbcefd0e0caf1572c175f82e685216bd43e7f7", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 242, "deletions": 72, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/ad93b695d1fc8340d520aea1ad22e1d35930e1e2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad93b695d1fc8340d520aea1ad22e1d35930e1e2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ad93b695d1fc8340d520aea1ad22e1d35930e1e2", "patch": "@@ -11,7 +11,8 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n-use rustc::infer::{InferCtxt, InferOk, InferResult, UnitResult};\n+use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime,\n+                   RegionConstraintData, UnitResult};\n use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n@@ -28,6 +29,34 @@ use transform::{MirPass, MirSource};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+/// Type checks the given `mir` in the context of the inference\n+/// context `infcx`. Returns any region constraints that have yet to\n+/// be proven.\n+///\n+/// This phase of type-check ought to be infallible -- this is because\n+/// the original, HIR-based type-check succeeded. So if any errors\n+/// occur here, we will get a `bug!` reported.\n+pub fn type_check<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'gcx>,\n+    mir: &Mir<'tcx>,\n+) -> MirTypeckRegionConstraints<'tcx> {\n+    let mut checker = TypeChecker::new(infcx, body_id, param_env);\n+    let errors_reported = {\n+        let mut verifier = TypeVerifier::new(&mut checker, mir);\n+        verifier.visit_mir(mir);\n+        verifier.errors_reported\n+    };\n+\n+    if !errors_reported {\n+        // if verifier failed, don't do further checks to avoid ICEs\n+        checker.typeck_mir(mir);\n+    }\n+\n+    checker.constraints\n+}\n+\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     tcx.sess.diagnostic().span_bug(span, msg);\n }\n@@ -128,7 +157,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.needs_infer() || ty.has_escaping_regions() || ty.references_error() {\n+        if ty.has_escaping_regions() || ty.references_error() {\n             span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n         } else {\n             ty\n@@ -145,7 +174,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(lvalue, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty, location);\n-                if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty, location) {\n+                if let Err(terr) = self.cx\n+                    .eq_types(self.last_span, ty, sty, location.at_self())\n+                {\n                     span_mirbug!(\n                         self,\n                         lvalue,\n@@ -267,16 +298,18 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(lvalue, fty);\n                 match self.field_ty(lvalue, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(span, ty, fty, location) {\n-                        span_mirbug!(\n-                            self,\n-                            lvalue,\n-                            \"bad field access ({:?}: {:?}): {:?}\",\n-                            ty,\n-                            fty,\n-                            terr\n-                        );\n-                    },\n+                    Ok(ty) => {\n+                        if let Err(terr) = self.cx.eq_types(span, ty, fty, location.at_self()) {\n+                            span_mirbug!(\n+                                self,\n+                                lvalue,\n+                                \"bad field access ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                fty,\n+                                terr\n+                            );\n+                        }\n+                    }\n                     Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n                         self,\n                         lvalue,\n@@ -364,12 +397,61 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n }\n \n+/// The MIR type checker. Visits the MIR and enforces all the\n+/// constraints needed for it to be valid and well-typed. Along the\n+/// way, it accrues region constraints -- these can later be used by\n+/// NLL region checking.\n pub struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n+    constraints: MirTypeckRegionConstraints<'tcx>,\n+}\n+\n+/// A collection of region constraints that must be satisfied for the\n+/// program to be considered well-typed.\n+#[derive(Default)]\n+pub struct MirTypeckRegionConstraints<'tcx> {\n+    /// In general, the type-checker is not responsible for enforcing\n+    /// liveness constraints; this job falls to the region inferencer,\n+    /// which performs a liveness analysis. However, in some limited\n+    /// cases, the MIR type-checker creates temporary regions that do\n+    /// not otherwise appear in the MIR -- in particular, the\n+    /// late-bound regions that it instantiates at call-sites -- and\n+    /// hence it must report on their liveness constraints.\n+    pub liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n+\n+    /// During the course of type-checking, we will accumulate region\n+    /// constraints due to performing subtyping operations or solving\n+    /// traits. These are accumulated into this vector for later use.\n+    pub outlives_sets: Vec<OutlivesSet<'tcx>>,\n+}\n+\n+/// Outlives relationships between regions and types created at a\n+/// particular point within the control-flow graph.\n+pub struct OutlivesSet<'tcx> {\n+    /// The locations associated with these constraints.\n+    pub locations: Locations,\n+\n+    /// Constraints generated. In terms of the NLL RFC, when you have\n+    /// a constraint `R1: R2 @ P`, the data in there specifies things\n+    /// like `R1: R2`.\n+    pub data: RegionConstraintData<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Locations {\n+    /// The location in the MIR that generated these constraints.\n+    /// This is intended for error reporting and diagnosis; the\n+    /// constraints may *take effect* at a distinct spot.\n+    pub from_location: Location,\n+\n+    /// The constraints must be met at this location. In terms of the\n+    /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n+    /// is the `P` value.\n+    pub at_location: Location,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -384,44 +466,62 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             body_id,\n             param_env,\n             reported_errors: FxHashSet(),\n+            constraints: MirTypeckRegionConstraints::default(),\n         }\n     }\n \n     fn misc(&self, span: Span) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::misc(span, self.body_id)\n     }\n \n-    fn fully_perform_op<OP, R>(&self, op: OP) -> Result<R, TypeError<'tcx>>\n+    fn fully_perform_op<OP, R>(\n+        &mut self,\n+        locations: Locations,\n+        op: OP,\n+    ) -> Result<R, TypeError<'tcx>>\n     where\n-        OP: FnOnce() -> InferResult<'tcx, R>,\n+        OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n     {\n         let mut fulfill_cx = FulfillmentContext::new();\n-        let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op())?;\n+        let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n         fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n         if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {\n             span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n-        } // FIXME propagate\n+        }\n+\n+        let data = self.infcx.take_and_reset_region_constraints();\n+        if !data.is_empty() {\n+            self.constraints\n+                .outlives_sets\n+                .push(OutlivesSet { locations, data });\n+        }\n+\n         Ok(value)\n     }\n \n-    fn sub_types(&self, sub: Ty<'tcx>, sup: Ty<'tcx>, _at_location: Location) -> UnitResult<'tcx> {\n-        self.fully_perform_op(|| {\n-            self.infcx\n-                .at(&self.misc(self.last_span), self.param_env)\n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+    ) -> UnitResult<'tcx> {\n+        self.fully_perform_op(locations, |this| {\n+            this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n                 .sup(sup, sub)\n         })\n     }\n \n     fn eq_types(\n-        &self,\n+        &mut self,\n         _span: Span,\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n-        _at_location: Location,\n+        locations: Locations,\n     ) -> UnitResult<'tcx> {\n-        self.fully_perform_op(|| {\n-            self.infcx\n-                .at(&self.misc(self.last_span), self.param_env)\n+        self.fully_perform_op(locations, |this| {\n+            this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n                 .eq(b, a)\n         })\n     }\n@@ -437,7 +537,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty, location.successor_within_block()) {\n+                if let Err(terr) =\n+                    self.sub_types(rv_ty, lv_ty, location.at_successor_within_block())\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -482,7 +584,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_terminator(&mut self, mir: &Mir<'tcx>, term: &Terminator<'tcx>, location: Location) {\n+    fn check_terminator(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        term_location: Location,\n+    ) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n@@ -505,7 +612,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                if let Err(terr) = self.sub_types(rv_ty, lv_ty, target.start_location()) {\n+                let locations = Locations {\n+                    from_location: term_location,\n+                    at_location: target.start_location(),\n+                };\n+                if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -520,7 +631,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // *both* blocks, so we need to ensure that it holds\n                 // at both locations.\n                 if let Some(unwind) = unwind {\n-                    if let Err(terr) = self.sub_types(rv_ty, lv_ty, unwind.start_location()) {\n+                    let locations = Locations {\n+                        from_location: term_location,\n+                        at_location: unwind.start_location(),\n+                    };\n+                    if let Err(terr) = self.sub_types(rv_ty, lv_ty, locations) {\n                         span_mirbug!(\n                             self,\n                             term,\n@@ -538,7 +653,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty, location) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.at_self()) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -568,14 +683,31 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let sig = tcx.erase_late_bound_regions(&sig);\n-                let sig = self.normalize(&sig, location);\n-                self.check_call_dest(mir, term, &sig, destination);\n+                let (sig, map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    term.source_info.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    &sig,\n+                );\n+                let sig = self.normalize(&sig, term_location);\n+                self.check_call_dest(mir, term, &sig, destination, term_location);\n+\n+                // The ordinary liveness rules will ensure that all\n+                // regions in the type of the callee are live here. We\n+                // then further constrain the late-bound regions that\n+                // were instantiated at the call site to be live as\n+                // well. The resulting is that all the input (and\n+                // output) types in the signature must be live, since\n+                // all the inputs that fed into it were live.\n+                for &late_bound_region in map.values() {\n+                    self.constraints\n+                        .liveness_set\n+                        .push((late_bound_region, term_location));\n+                }\n \n                 if self.is_box_free(func) {\n-                    self.check_box_free_inputs(mir, term, &sig, args, location);\n+                    self.check_box_free_inputs(mir, term, &sig, args, term_location);\n                 } else {\n-                    self.check_call_inputs(mir, term, &sig, args, location);\n+                    self.check_call_inputs(mir, term, &sig, args, term_location);\n                 }\n             }\n             TerminatorKind::Assert {\n@@ -599,16 +731,18 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let value_ty = value.ty(mir, tcx);\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n-                    Some(ty) => if let Err(terr) = self.sub_types(value_ty, ty, location) {\n-                        span_mirbug!(\n-                            self,\n-                            term,\n-                            \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n-                            value_ty,\n-                            ty,\n-                            terr\n-                        );\n-                    },\n+                    Some(ty) => {\n+                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.at_self()) {\n+                            span_mirbug!(\n+                                self,\n+                                term,\n+                                \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n+                                value_ty,\n+                                ty,\n+                                terr\n+                            );\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -620,14 +754,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         destination: &Option<(Lvalue<'tcx>, BasicBlock)>,\n+        term_location: Location,\n     ) {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) =\n-                    self.sub_types(sig.output(), dest_ty, target_block.start_location())\n-                {\n+                let locations = Locations {\n+                    from_location: term_location,\n+                    at_location: target_block.start_location(),\n+                };\n+                if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -653,15 +790,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         args: &[Operand<'tcx>],\n-        location: Location,\n+        term_location: Location,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n         if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, location) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.at_self()) {\n                 span_mirbug!(\n                     self,\n                     term,\n@@ -699,7 +836,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         args: &[Operand<'tcx>],\n-        location: Location,\n+        term_location: Location,\n     ) {\n         debug!(\"check_box_free_inputs\");\n \n@@ -733,7 +870,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, location) {\n+        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, term_location.at_self()) {\n             span_mirbug!(\n                 self,\n                 term,\n@@ -834,7 +971,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Mir<'gcx>, local: Local, local_decl: &LocalDecl<'gcx>) {\n+    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -850,7 +987,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         let span = local_decl.source_info.span;\n         let ty = local_decl.ty;\n-        if !ty.is_sized(self.tcx().global_tcx(), self.param_env, span) {\n+\n+        // Erase the regions from `ty` to get a global type.  The\n+        // `Sized` bound in no way depends on precise regions, so this\n+        // shouldn't affect `is_sized`.\n+        let gcx = self.tcx().global_tcx();\n+        let erased_ty = gcx.lift(&self.tcx().erase_regions(&ty)).unwrap();\n+        if !erased_ty.is_sized(gcx, self.param_env, span) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough\n@@ -868,7 +1011,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'gcx>) {\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n@@ -894,16 +1037,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n-    fn normalize<T>(&mut self, value: &T, _location: Location) -> T\n+    fn normalize<T>(&mut self, value: &T, location: Location) -> T\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n-        self.fully_perform_op(|| {\n-            let mut selcx = traits::SelectionContext::new(self.infcx);\n-            let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n+        self.fully_perform_op(location.at_self(), |this| {\n+            let mut selcx = traits::SelectionContext::new(this.infcx);\n+            let cause = traits::ObligationCause::misc(this.last_span, ast::CRATE_NODE_ID);\n             let traits::Normalized { value, obligations } =\n-                traits::normalize(&mut selcx, self.param_env, cause, value);\n+                traits::normalize(&mut selcx, this.param_env, cause, value);\n             Ok(InferOk { value, obligations })\n         }).unwrap()\n     }\n@@ -924,16 +1066,44 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, id, param_env);\n-            {\n-                let mut verifier = TypeVerifier::new(&mut checker, mir);\n-                verifier.visit_mir(mir);\n-                if verifier.errors_reported {\n-                    // don't do further checks to avoid ICEs\n-                    return;\n-                }\n-            }\n-            checker.typeck_mir(mir);\n+            let _region_constraint_sets = type_check(&infcx, id, param_env, mir);\n+\n+            // For verification purposes, we just ignore the resulting\n+            // region constraint sets. Not our problem. =)\n         });\n     }\n }\n+\n+trait AtLocation {\n+    /// Creates a `Locations` where `self` is both the from-location\n+    /// and the at-location. This means that any required region\n+    /// relationships must hold upon entering the statement/terminator\n+    /// indicated by `self`. This is typically used when processing\n+    /// \"inputs\" to the given location.\n+    fn at_self(self) -> Locations;\n+\n+    /// Creates a `Locations` where `self` is the from-location and\n+    /// its successor within the block is the at-location. This means\n+    /// that any required region relationships must hold only upon\n+    /// **exiting** the statement/terminator indicated by `self`. This\n+    /// is for example used when you have a `lv = rv` statement: it\n+    /// indicates that the `typeof(rv) <: typeof(lv)` as of the\n+    /// **next** statement.\n+    fn at_successor_within_block(self) -> Locations;\n+}\n+\n+impl AtLocation for Location {\n+    fn at_self(self) -> Locations {\n+        Locations {\n+            from_location: self,\n+            at_location: self,\n+        }\n+    }\n+\n+    fn at_successor_within_block(self) -> Locations {\n+        Locations {\n+            from_location: self,\n+            at_location: self.successor_within_block(),\n+        }\n+    }\n+}"}]}