{"sha": "17426835d8c6d4b58692820b789e402fc8b89936", "node_id": "C_kwDOAAsO6NoAKDE3NDI2ODM1ZDhjNmQ0YjU4NjkyODIwYjc4OWU0MDJmYzhiODk5MzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T12:26:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T12:26:39Z"}, "message": "Auto merge of #14972 - HKalbasi:mir-fix, r=HKalbasi\n\nFix `unused-mut` false positive for `Box`", "tree": {"sha": "0ea9649f6fa2784e98e5b64df3885256c11f395f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ea9649f6fa2784e98e5b64df3885256c11f395f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17426835d8c6d4b58692820b789e402fc8b89936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17426835d8c6d4b58692820b789e402fc8b89936", "html_url": "https://github.com/rust-lang/rust/commit/17426835d8c6d4b58692820b789e402fc8b89936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17426835d8c6d4b58692820b789e402fc8b89936/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5c34a80e37984b422cf0370654ed393db73c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5c34a80e37984b422cf0370654ed393db73c70", "html_url": "https://github.com/rust-lang/rust/commit/9d5c34a80e37984b422cf0370654ed393db73c70"}, {"sha": "0408af6453e2bf9850731db2963ec5fb68dccc91", "url": "https://api.github.com/repos/rust-lang/rust/commits/0408af6453e2bf9850731db2963ec5fb68dccc91", "html_url": "https://github.com/rust-lang/rust/commit/0408af6453e2bf9850731db2963ec5fb68dccc91"}], "stats": {"total": 95, "additions": 83, "deletions": 12}, "files": [{"sha": "a0ea1cc5ef7d95d3d009d41b69c0a2f381ff43e2", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/17426835d8c6d4b58692820b789e402fc8b89936/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17426835d8c6d4b58692820b789e402fc8b89936/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=17426835d8c6d4b58692820b789e402fc8b89936", "patch": "@@ -78,7 +78,7 @@ pub fn borrowck_query(\n         .map(|body| {\n             let body = body?;\n             Ok(BorrowckResult {\n-                mutability_of_locals: mutability_of_locals(&body),\n+                mutability_of_locals: mutability_of_locals(db, &body),\n                 moved_out_of_ref: moved_out_of_ref(db, &body),\n                 mir_body: body,\n             })\n@@ -186,10 +186,7 @@ fn moved_out_of_ref(db: &dyn HirDatabase, body: &MirBody) -> Vec<MovedOutOfRef>\n     result\n }\n \n-fn is_place_direct(lvalue: &Place) -> bool {\n-    !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n-}\n-\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ProjectionCase {\n     /// Projection is a local\n     Direct,\n@@ -199,12 +196,14 @@ enum ProjectionCase {\n     Indirect,\n }\n \n-fn place_case(lvalue: &Place) -> ProjectionCase {\n+fn place_case(db: &dyn HirDatabase, body: &MirBody, lvalue: &Place) -> ProjectionCase {\n     let mut is_part_of = false;\n-    for proj in lvalue.projection.iter().rev() {\n+    let mut ty = body.locals[lvalue.local].ty.clone();\n+    for proj in lvalue.projection.iter() {\n         match proj {\n-            ProjectionElem::Deref => return ProjectionCase::Indirect, // It's indirect\n-            ProjectionElem::ConstantIndex { .. }\n+            ProjectionElem::Deref if ty.as_adt().is_none() => return ProjectionCase::Indirect, // It's indirect in case of reference and raw\n+            ProjectionElem::Deref // It's direct in case of `Box<T>`\n+            | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(_)\n             | ProjectionElem::TupleOrClosureField(_)\n@@ -213,6 +212,23 @@ fn place_case(lvalue: &Place) -> ProjectionCase {\n             }\n             ProjectionElem::OpaqueCast(_) => (),\n         }\n+        ty = proj.projected_ty(\n+            ty,\n+            db,\n+            |c, subst, f| {\n+                let (def, _) = db.lookup_intern_closure(c.into());\n+                let infer = db.infer(def);\n+                let (captures, _) = infer.closure_info(&c);\n+                let parent_subst = ClosureSubst(subst).parent_subst();\n+                captures\n+                    .get(f)\n+                    .expect(\"broken closure field\")\n+                    .ty\n+                    .clone()\n+                    .substitute(Interner, parent_subst)\n+            },\n+            body.owner.module(db.upcast()).krate(),\n+        );\n     }\n     if is_part_of {\n         ProjectionCase::DirectPart\n@@ -300,7 +316,10 @@ fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<Local\n     result\n }\n \n-fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n+fn mutability_of_locals(\n+    db: &dyn HirDatabase,\n+    body: &MirBody,\n+) -> ArenaMap<LocalId, MutabilityReason> {\n     let mut result: ArenaMap<LocalId, MutabilityReason> =\n         body.locals.iter().map(|x| (x.0, MutabilityReason::Not)).collect();\n     let mut push_mut_span = |local, span| match &mut result[local] {\n@@ -313,7 +332,7 @@ fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n         for statement in &block.statements {\n             match &statement.kind {\n                 StatementKind::Assign(place, value) => {\n-                    match place_case(place) {\n+                    match place_case(db, body, place) {\n                         ProjectionCase::Direct => {\n                             if ever_init_map.get(place.local).copied().unwrap_or_default() {\n                                 push_mut_span(place.local, statement.span);\n@@ -328,7 +347,7 @@ fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n                         ProjectionCase::Indirect => (),\n                     }\n                     if let Rvalue::Ref(BorrowKind::Mut { .. }, p) = value {\n-                        if is_place_direct(p) {\n+                        if place_case(db, body, p) != ProjectionCase::Indirect {\n                             push_mut_span(p.local, statement.span);\n                         }\n                     }"}, {"sha": "8795afc2d9739e6b4a56827b3d831323725f33d3", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/17426835d8c6d4b58692820b789e402fc8b89936/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17426835d8c6d4b58692820b789e402fc8b89936/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=17426835d8c6d4b58692820b789e402fc8b89936", "patch": "@@ -993,6 +993,58 @@ fn f() {\n         );\n     }\n \n+    #[test]\n+    fn boxes() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: coerce_unsized, deref_mut, slice\n+use core::ops::{Deref, DerefMut};\n+use core::{marker::Unsize, ops::CoerceUnsized};\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized> {\n+    inner: *mut T,\n+}\n+impl<T> Box<T> {\n+    fn new(t: T) -> Self {\n+        #[rustc_box]\n+        Box::new(t)\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for Box<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+impl<T: ?Sized> DerefMut for Box<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n+}\n+\n+fn f() {\n+    let x = Box::new(5);\n+    x = Box::new(7);\n+  //^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let x = Box::new(5);\n+    *x = 7;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let mut y = Box::new(5);\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    *x = *y;\n+  //^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let x = Box::new(5);\n+    let closure = || *x = 2;\n+                    //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn allow_unused_mut_for_identifiers_starting_with_underline() {\n         check_diagnostics("}]}