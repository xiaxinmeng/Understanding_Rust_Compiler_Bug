{"sha": "81423a3866fb6cd4cadd28ed49273d7e22d48c17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNDIzYTM4NjZmYjZjZDRjYWRkMjhlZDQ5MjczZDdlMjJkNDhjMTc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-27T04:35:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T03:43:59Z"}, "message": "Add deserializable and more types to serialization2", "tree": {"sha": "28bbbf3b65f82dc7554c8b7371ed46f8a381c75e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28bbbf3b65f82dc7554c8b7371ed46f8a381c75e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81423a3866fb6cd4cadd28ed49273d7e22d48c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81423a3866fb6cd4cadd28ed49273d7e22d48c17", "html_url": "https://github.com/rust-lang/rust/commit/81423a3866fb6cd4cadd28ed49273d7e22d48c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81423a3866fb6cd4cadd28ed49273d7e22d48c17/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a950f394dbe3275c4879dc1f26f78a096f93e28", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a950f394dbe3275c4879dc1f26f78a096f93e28", "html_url": "https://github.com/rust-lang/rust/commit/0a950f394dbe3275c4879dc1f26f78a096f93e28"}], "stats": {"total": 847, "additions": 581, "deletions": 266}, "files": [{"sha": "3ed6426b829f178ff5aebc9b701c3d66f3d0a348", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -384,7 +384,25 @@ impl Serializer: serialization2::Serializer {\n         fail ~\"Unimplemented: serializing a float\";\n     }\n \n-    fn emit_str(&self, v: &str) { self.wr_tagged_str(EsStr as uint, v) }\n+    fn emit_char(&self, _v: char) {\n+        fail ~\"Unimplemented: serializing a char\";\n+    }\n+\n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr_tagged_str(EsStr as uint, v)\n+    }\n+\n+    fn emit_owned_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_managed_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_borrowed(&self, f: fn()) { f() }\n+    fn emit_owned(&self, f: fn()) { f() }\n+    fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n         self._emit_label(name);\n@@ -397,25 +415,33 @@ impl Serializer: serialization2::Serializer {\n     }\n     fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n \n-    fn emit_vec(&self, len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n         do self.wr_tag(EsVec as uint) {\n             self._emit_tagged_uint(EsVecLen, len);\n             f()\n         }\n     }\n \n+    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n+    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n     fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n         self.wr_tag(EsVecElt as uint, f)\n     }\n \n-    fn emit_box(&self, f: fn()) { f() }\n-    fn emit_uniq(&self, f: fn()) { f() }\n     fn emit_rec(&self, f: fn()) { f() }\n-    fn emit_rec_field(&self, f_name: &str, _f_idx: uint, f: fn()) {\n-        self._emit_label(f_name);\n+    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n+    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+        self._emit_label(name);\n         f()\n     }\n-    fn emit_tup(&self, _sz: uint, f: fn()) { f() }\n+\n+    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n     fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n }\n \n@@ -525,9 +551,22 @@ impl Deserializer: serialization2::Deserializer {\n     fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n     fn read_float(&self) -> float { fail ~\"read_float()\"; }\n \n-    fn read_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n+\n+    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n \n     // Compound types:\n+    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_owned()\");\n+        f()\n+    }\n+\n+    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_managed()\");\n+        f()\n+    }\n+\n     fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         self._check_label(name);\n@@ -548,8 +587,17 @@ impl Deserializer: serialization2::Deserializer {\n         f()\n     }\n \n-    fn read_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_vec()\");\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_owned_vec()\");\n+        do self.push_doc(self.next_doc(EsVec)) {\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            f(len)\n+        }\n+    }\n+\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_managed_vec()\");\n         do self.push_doc(self.next_doc(EsVec)) {\n             let len = self._next_uint(EsVecLen);\n             debug!(\"  len=%u\", len);\n@@ -562,30 +610,24 @@ impl Deserializer: serialization2::Deserializer {\n         self.push_doc(self.next_doc(EsVecElt), f)\n     }\n \n-    fn read_box<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_box()\");\n+    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_rec()\");\n         f()\n     }\n \n-    fn read_uniq<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_uniq()\");\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n+        debug!(\"read_struct(name=%s)\", name);\n         f()\n     }\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n-        f()\n-    }\n-\n-    fn read_rec_field<T>(&self, f_name: &str, f_idx: uint,\n-                         f: fn() -> T) -> T {\n-        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n-        self._check_label(f_name);\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+        self._check_label(name);\n         f()\n     }\n \n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(sz=%u)\", sz);\n+    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(len=%u)\", len);\n         f()\n     }\n \n@@ -595,7 +637,6 @@ impl Deserializer: serialization2::Deserializer {\n     }\n }\n \n-\n // ___________________________________________________________________________\n // Testing\n "}, {"sha": "d3713bdb29d57e5d216c2bef5d81a6e6b17bb665", "filename": "src/libstd/json.rs", "status": "modified", "additions": 114, "deletions": 62, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -92,10 +92,15 @@ pub impl Serializer: serialization2::Serializer {\n         self.wr.write_str(float::to_str(v, 6u));\n     }\n \n-    fn emit_str(&self, v: &str) {\n-        let s = escape_str(v);\n-        self.wr.write_str(s);\n-    }\n+    fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n+\n+    fn emit_borrowed_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n+    fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n+    fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n+\n+    fn emit_borrowed(&self, f: fn()) { f() }\n+    fn emit_owned(&self, f: fn()) { f() }\n+    fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n         if name != \"option\" { fail ~\"only supports option enum\" }\n@@ -112,32 +117,41 @@ pub impl Serializer: serialization2::Serializer {\n         f()\n     }\n \n-    fn emit_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n         self.wr.write_char('[');\n         f();\n         self.wr.write_char(']');\n     }\n-\n+    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n     fn emit_vec_elt(&self, idx: uint, f: fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         f()\n     }\n \n-    fn emit_box(&self, f: fn()) { f() }\n-    fn emit_uniq(&self, f: fn()) { f() }\n     fn emit_rec(&self, f: fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n-    fn emit_rec_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, f: fn()) {\n+        self.wr.write_char('{');\n+        f();\n+        self.wr.write_char('}');\n+    }\n+    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n-    fn emit_tup(&self, sz: uint, f: fn()) {\n-        self.emit_vec(sz, f);\n+\n+    fn emit_tup(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f);\n     }\n     fn emit_tup_elt(&self, idx: uint, f: fn()) {\n         self.emit_vec_elt(idx, f)\n@@ -182,7 +196,15 @@ pub impl PrettySerializer: serialization2::Serializer {\n         self.wr.write_str(float::to_str(v, 6u));\n     }\n \n-    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n+    fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n+\n+    fn emit_borrowed_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n+    fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n+    fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n+\n+    fn emit_borrowed(&self, f: fn()) { f() }\n+    fn emit_owned(&self, f: fn()) { f() }\n+    fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n         if name != \"option\" { fail ~\"only supports option enum\" }\n@@ -199,14 +221,19 @@ pub impl PrettySerializer: serialization2::Serializer {\n         f()\n     }\n \n-    fn emit_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n         self.wr.write_char('[');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char(']');\n     }\n-\n+    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n     fn emit_vec_elt(&self, idx: uint, f: fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n@@ -217,16 +244,17 @@ pub impl PrettySerializer: serialization2::Serializer {\n         f()\n     }\n \n-    fn emit_box(&self, f: fn()) { f() }\n-    fn emit_uniq(&self, f: fn()) { f() }\n     fn emit_rec(&self, f: fn()) {\n         self.wr.write_char('{');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char('}');\n     }\n-    fn emit_rec_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, f: fn()) {\n+        self.emit_rec(f)\n+    }\n+    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -238,43 +266,39 @@ pub impl PrettySerializer: serialization2::Serializer {\n         f();\n     }\n     fn emit_tup(&self, sz: uint, f: fn()) {\n-        self.emit_vec(sz, f);\n+        self.emit_borrowed_vec(sz, f);\n     }\n     fn emit_tup_elt(&self, idx: uint, f: fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n }\n \n-pub fn to_serializer<S: serialization2::Serializer>(ser: &S, json: &Json) {\n-    match *json {\n-        Number(f) => ser.emit_float(f),\n-        String(ref s) => ser.emit_str(*s),\n-        Boolean(b) => ser.emit_bool(b),\n-        List(v) => {\n-            do ser.emit_vec(v.len()) || {\n-                for v.eachi |i, elt| {\n-                    ser.emit_vec_elt(i, || to_serializer(ser, elt))\n-                }\n-            }\n-        }\n-        Object(ref o) => {\n-            do ser.emit_rec || {\n-                let mut idx = 0;\n-                for o.each |key, value| {\n-                    do ser.emit_rec_field(*key, idx) {\n-                        to_serializer(ser, value);\n+pub impl Json: serialization2::Serializable {\n+    fn serialize<S: serialization2::Serializer>(&self, s: &S) {\n+        match *self {\n+            Number(v) => v.serialize(s),\n+            String(ref v) => v.serialize(s),\n+            Boolean(v) => v.serialize(s),\n+            List(v) => v.serialize(s),\n+            Object(ref v) => {\n+                do s.emit_rec || {\n+                    let mut idx = 0;\n+                    for v.each |key, value| {\n+                        do s.emit_field(*key, idx) {\n+                            value.serialize(s);\n+                        }\n+                        idx += 1;\n                     }\n-                    idx += 1;\n                 }\n-            }\n+            },\n+            Null => s.emit_nil(),\n         }\n-        Null => ser.emit_nil(),\n     }\n }\n \n /// Serializes a json value into a io::writer\n pub fn to_writer(wr: io::Writer, json: &Json) {\n-    to_serializer(&Serializer(wr), json)\n+    json.serialize(&Serializer(wr))\n }\n \n /// Serializes a json value into a string\n@@ -284,7 +308,7 @@ pub fn to_str(json: &Json) -> ~str {\n \n /// Serializes a json value into a io::writer\n pub fn to_pretty_writer(wr: io::Writer, json: &Json) {\n-    to_serializer(&PrettySerializer(wr), json)\n+    json.serialize(&PrettySerializer(wr))\n }\n \n /// Serializes a json value into a string\n@@ -736,14 +760,35 @@ pub impl Deserializer: serialization2::Deserializer {\n         }\n     }\n \n-    fn read_str(&self) -> ~str {\n-        debug!(\"read_str\");\n+    fn read_char(&self) -> char {\n+        let v = str::chars(self.read_owned_str());\n+        if v.len() != 1 { fail ~\"string must have one character\" }\n+        v[0]\n+    }\n+\n+    fn read_owned_str(&self) -> ~str {\n+        debug!(\"read_owned_str\");\n         match *self.pop() {\n             String(ref s) => copy *s,\n             _ => fail ~\"not a string\"\n         }\n     }\n \n+    fn read_managed_str(&self) -> @str {\n+        // FIXME(#3604): There's no way to convert from a ~str to a @str.\n+        fail ~\"read_managed_str()\";\n+    }\n+\n+    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_owned()\");\n+        f()\n+    }\n+\n+    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_managed()\");\n+        f()\n+    }\n+\n     fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         if name != ~\"option\" { fail ~\"only supports the option enum\" }\n@@ -765,8 +810,19 @@ pub impl Deserializer: serialization2::Deserializer {\n         f()\n     }\n \n-    fn read_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_vec()\");\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_owned_vec()\");\n+        let len = match *self.peek() {\n+            List(list) => list.len(),\n+            _ => fail ~\"not a list\",\n+        };\n+        let res = f(len);\n+        self.pop();\n+        res\n+    }\n+\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n             _ => fail ~\"not a list\",\n@@ -790,34 +846,30 @@ pub impl Deserializer: serialization2::Deserializer {\n         }\n     }\n \n-    fn read_box<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_box()\");\n-        f()\n-    }\n-\n-    fn read_uniq<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_uniq()\");\n-        f()\n-    }\n-\n     fn read_rec<T>(&self, f: fn() -> T) -> T {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_rec_field<T>(&self, f_name: &str, f_idx: uint,\n-                         f: fn() -> T) -> T {\n-        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n+    fn read_struct<T>(&self, _name: &str, f: fn() -> T) -> T {\n+        debug!(\"read_struct()\");\n+        let value = f();\n+        self.pop();\n+        value\n+    }\n+\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_rec_field(%s, idx=%u)\", name, idx);\n         let top = self.peek();\n         match *top {\n             Object(ref obj) => {\n                 // FIXME(#3148) This hint should not be necessary.\n                 let obj: &self/~Object = obj;\n \n-                match obj.find_ref(&(f_name.to_unique())) {\n-                    None => fail fmt!(\"no such field: %s\", f_name),\n+                match obj.find_ref(&name.to_unique()) {\n+                    None => fail fmt!(\"no such field: %s\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f()\n@@ -834,8 +886,8 @@ pub impl Deserializer: serialization2::Deserializer {\n         }\n     }\n \n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(sz=%u)\", sz);\n+    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n         value"}, {"sha": "87af519eb123d98ed16b8216944806aa574d6c8d", "filename": "src/libstd/prettyprint2.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fprettyprint2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fprettyprint2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint2.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -12,7 +12,7 @@ pub fn Serializer(wr: io::Writer) -> Serializer {\n     Serializer { wr: wr }\n }\n \n-impl Serializer: serialization2::Serializer {\n+pub impl Serializer: serialization2::Serializer {\n     fn emit_nil(&self) {\n         self.wr.write_str(~\"()\")\n     }\n@@ -73,10 +73,37 @@ impl Serializer: serialization2::Serializer {\n         self.wr.write_str(fmt!(\"%?_f32\", v));\n     }\n \n-    fn emit_str(&self, v: &str) {\n+    fn emit_char(&self, v: char) {\n         self.wr.write_str(fmt!(\"%?\", v));\n     }\n \n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"&%?\", v));\n+    }\n+\n+    fn emit_owned_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"~%?\", v));\n+    }\n+\n+    fn emit_managed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"@%?\", v));\n+    }\n+\n+    fn emit_borrowed(&self, f: fn()) {\n+        self.wr.write_str(~\"&\");\n+        f();\n+    }\n+\n+    fn emit_owned(&self, f: fn()) {\n+        self.wr.write_str(~\"~\");\n+        f();\n+    }\n+\n+    fn emit_managed(&self, f: fn()) {\n+        self.wr.write_str(~\"@\");\n+        f();\n+    }\n+\n     fn emit_enum(&self, _name: &str, f: fn()) {\n         f();\n     }\n@@ -94,24 +121,26 @@ impl Serializer: serialization2::Serializer {\n         f();\n     }\n \n-    fn emit_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"[\");\n+    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"&[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n+    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"~[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_box(&self, f: fn()) {\n-        self.wr.write_str(~\"@\");\n+    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"@[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_uniq(&self, f: fn()) {\n-        self.wr.write_str(~\"~\");\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n@@ -121,14 +150,20 @@ impl Serializer: serialization2::Serializer {\n         self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_rec_field(&self, f_name: &str, f_idx: uint, f: fn()) {\n-        if f_idx > 0u { self.wr.write_str(~\", \"); }\n-        self.wr.write_str(f_name);\n+    fn emit_struct(&self, name: &str, f: fn()) {\n+        self.wr.write_str(fmt!(\"%s {\", name));\n+        f();\n+        self.wr.write_str(~\"}\");\n+    }\n+\n+    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        self.wr.write_str(name);\n         self.wr.write_str(~\": \");\n         f();\n     }\n \n-    fn emit_tup(&self, _sz: uint, f: fn()) {\n+    fn emit_tup(&self, _len: uint, f: fn()) {\n         self.wr.write_str(~\"(\");\n         f();\n         self.wr.write_str(~\")\");"}, {"sha": "5173ef163a22aef06ea3fd6787bea0dbcaa8efa9", "filename": "src/libstd/serialization2.rs", "status": "modified", "additions": 181, "deletions": 27, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -24,19 +24,30 @@ pub trait Serializer {\n     fn emit_float(&self, v: float);\n     fn emit_f64(&self, v: f64);\n     fn emit_f32(&self, v: f32);\n-    fn emit_str(&self, v: &str);\n+    fn emit_char(&self, v: char);\n+    fn emit_borrowed_str(&self, v: &str);\n+    fn emit_owned_str(&self, v: &str);\n+    fn emit_managed_str(&self, v: &str);\n \n     // Compound types:\n+    fn emit_borrowed(&self, f: fn());\n+    fn emit_owned(&self, f: fn());\n+    fn emit_managed(&self, f: fn());\n+\n     fn emit_enum(&self, name: &str, f: fn());\n     fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n     fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n-    fn emit_vec(&self, len: uint, f: fn());\n+\n+    fn emit_borrowed_vec(&self, len: uint, f: fn());\n+    fn emit_owned_vec(&self, len: uint, f: fn());\n+    fn emit_managed_vec(&self, len: uint, f: fn());\n     fn emit_vec_elt(&self, idx: uint, f: fn());\n-    fn emit_box(&self, f: fn());\n-    fn emit_uniq(&self, f: fn());\n+\n     fn emit_rec(&self, f: fn());\n-    fn emit_rec_field(&self, f_name: &str, f_idx: uint, f: fn());\n-    fn emit_tup(&self, sz: uint, f: fn());\n+    fn emit_struct(&self, name: &str, f: fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+\n+    fn emit_tup(&self, len: uint, f: fn());\n     fn emit_tup_elt(&self, idx: uint, f: fn());\n }\n \n@@ -57,176 +68,291 @@ pub trait Deserializer {\n     fn read_f64(&self) -> f64;\n     fn read_f32(&self) -> f32;\n     fn read_float(&self) -> float;\n-    fn read_str(&self) -> ~str;\n+    fn read_char(&self) -> char;\n+    fn read_owned_str(&self) -> ~str;\n+    fn read_managed_str(&self) -> @str;\n \n     // Compound types:\n     fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n     fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T>(&self, f: fn(uint) -> T) -> T;\n+\n+    fn read_owned<T>(&self, f: fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: fn() -> T) -> T;\n+\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n     fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T>(&self, f: fn() -> T) -> T;\n-    fn read_uniq<T>(&self, f: fn() -> T) -> T;\n+\n     fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_rec_field<T>(&self, f_name: &str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n+\n     fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n pub trait Serializable {\n     fn serialize<S: Serializer>(&self, s: &S);\n+}\n+\n+pub trait Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n }\n \n pub impl uint: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n+}\n+\n+pub impl uint: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n         d.read_uint()\n     }\n }\n \n pub impl u8: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl u8: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n         d.read_u8()\n     }\n }\n \n pub impl u16: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+pub impl u16: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n         d.read_u16()\n     }\n }\n \n pub impl u32: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+pub impl u32: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n         d.read_u32()\n     }\n }\n \n pub impl u64: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+pub impl u64: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n         d.read_u64()\n     }\n }\n \n pub impl int: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+pub impl int: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n         d.read_int()\n     }\n }\n \n pub impl i8: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+pub impl i8: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n         d.read_i8()\n     }\n }\n \n pub impl i16: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+pub impl i16: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n         d.read_i16()\n     }\n }\n \n pub impl i32: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+pub impl i32: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n         d.read_i32()\n     }\n }\n \n pub impl i64: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n+}\n+\n+pub impl i64: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n         d.read_i64()\n     }\n }\n \n+pub impl &str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n pub impl ~str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_str(*self) }\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n+}\n+\n+pub impl ~str: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n-        d.read_str()\n+        d.read_owned_str()\n+    }\n+}\n+\n+pub impl @str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n+}\n+\n+pub impl @str: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n+        d.read_managed_str()\n     }\n }\n \n pub impl float: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n+}\n+\n+pub impl float: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n         d.read_float()\n     }\n }\n \n pub impl f32: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n+}\n+\n+pub impl f32: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n         d.read_f32() }\n }\n \n pub impl f64: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n+}\n+\n+pub impl f64: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n         d.read_f64()\n     }\n }\n \n pub impl bool: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n+}\n+\n+pub impl bool: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n         d.read_bool()\n     }\n }\n \n pub impl (): Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n+}\n+\n+pub impl (): Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n         d.read_nil()\n     }\n }\n \n-pub impl<T: Serializable> @T: Serializable {\n+pub impl<T: Serializable> &T: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_box(|| (*self).serialize(s))\n-    }\n-\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n-        d.read_box(|| @deserialize(d))\n+        s.emit_borrowed(|| (**self).serialize(s))\n     }\n }\n \n pub impl<T: Serializable> ~T: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_uniq(|| (*self).serialize(s))\n+        s.emit_owned(|| (**self).serialize(s))\n     }\n+}\n \n+pub impl<T: Deserializable> ~T: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n-        d.read_uniq(|| ~deserialize(d))\n+        d.read_owned(|| ~deserialize(d))\n+    }\n+}\n+\n+pub impl<T: Serializable> @T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_managed(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<T: Deserializable> @T: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n+        d.read_managed(|| @deserialize(d))\n+    }\n+}\n+\n+pub impl<T: Serializable> &[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n     }\n }\n \n pub impl<T: Serializable> ~[T]: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_vec(self.len()) {\n+        do s.emit_owned_vec(self.len()) {\n             for self.eachi |i, e| {\n                 s.emit_vec_elt(i, || e.serialize(s))\n             }\n         }\n     }\n+}\n \n+pub impl<T: Deserializable> ~[T]: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n-        do d.read_vec |len| {\n+        do d.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n                 d.read_vec_elt(i, || deserialize(d))\n             }\n         }\n     }\n }\n \n+pub impl<T: Serializable> @[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> @[T]: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n pub impl<T: Serializable> Option<T>: Serializable {\n     fn serialize<S: Serializer>(&self, s: &S) {\n         do s.emit_enum(~\"option\") {\n@@ -240,7 +366,9 @@ pub impl<T: Serializable> Option<T>: Serializable {\n             }\n         }\n     }\n+}\n \n+pub impl<T: Deserializable> Option<T>: Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n         do d.read_enum(~\"option\") {\n             do d.read_enum_variant |i| {\n@@ -268,7 +396,12 @@ pub impl<\n             }\n         }\n     }\n+}\n \n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable\n+> (T0, T1): Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n         do d.read_tup(2) {\n             (\n@@ -295,7 +428,13 @@ pub impl<\n             }\n         }\n     }\n+}\n \n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable\n+> (T0, T1, T2): Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n         do d.read_tup(3) {\n             (\n@@ -325,7 +464,14 @@ pub impl<\n             }\n         }\n     }\n+}\n \n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable\n+> (T0, T1, T2, T3): Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n         do d.read_tup(4) {\n             (\n@@ -358,7 +504,15 @@ pub impl<\n             }\n         }\n     }\n+}\n \n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable,\n+    T4: Deserializable\n+> (T0, T1, T2, T3, T4): Deserializable {\n     static fn deserialize<D: Deserializer>(&self, d: &D)\n       -> (T0, T1, T2, T3, T4) {\n         do d.read_tup(5) {\n@@ -379,12 +533,12 @@ pub impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n }\n \n pub impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n-        do self.emit_vec(v.len()) {\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n+        do self.emit_owned_vec(v.len()) {\n             for v.eachi |i, e| {\n                 do self.emit_vec_elt(i) {\n                     f(e)\n@@ -400,7 +554,7 @@ pub trait DeserializerHelpers {\n \n pub impl<D: Deserializer> D: DeserializerHelpers {\n     fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_vec |len| {\n+        do self.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n                 self.read_vec_elt(i, || f())\n             }"}, {"sha": "d4a1a44893646367a3bc5ab9179f97963abd14fb", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 128, "deletions": 61, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -9,14 +9,16 @@ For example, a type like:\n \n     type node_id = uint;\n \n-would generate two functions like:\n+would generate two implementations like:\n \n     impl node_id: Serializable {\n-        fn serialize<S: Serializer>(s: S) {\n+        fn serialize<S: Serializer>(s: &S) {\n             s.emit_uint(self)\n         }\n+    }\n \n-        static fn deserialize<D: Deserializer>(d: D) -> node_id {\n+    impl node_id: Deserializable {\n+        static fn deserialize<D: Deserializer>(d: &D) -> node_id {\n             d.read_uint()\n         }\n     }\n@@ -29,18 +31,20 @@ references other non-built-in types.  A type definition like:\n would yield functions like:\n \n     impl<T: Serializable> spanned<T>: Serializable {\n-        fn serialize<S: Serializer>(s: S) {\n+        fn serialize<S: Serializer>(s: &S) {\n             do s.emit_rec {\n-                s.emit_rec_field(\"node\", 0, self.node.serialize(s));\n-                s.emit_rec_field(\"span\", 1, self.span.serialize(s));\n+                s.emit_field(\"node\", 0, self.node.serialize(s));\n+                s.emit_field(\"span\", 1, self.span.serialize(s));\n             }\n         }\n+    }\n \n-        static fn deserialize<D: Deserializer>(d: D) -> spanned<T> {\n+    impl<T: Deserializable> spanned<T>: Deserializable {\n+        static fn deserialize<D: Deserializer>(d: &D) -> spanned<T> {\n             do d.read_rec {\n                 {\n-                    node: d.read_rec_field(~\"node\", 0, || deserialize(d)),\n-                    span: d.read_rec_field(~\"span\", 1, || deserialize(d)),\n+                    node: d.read_field(~\"node\", 0, || deserialize(d)),\n+                    span: d.read_field(~\"span\", 1, || deserialize(d)),\n                 }\n             }\n         }\n@@ -87,22 +91,22 @@ fn expand(cx: ext_ctxt,\n     do vec::flat_map(in_items) |item| {\n         match item.node {\n             ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n-                ~[\n-                    filter_attrs(*item),\n-                    mk_rec_impl(cx, item.span, item.ident, fields, tps),\n-                ]\n+                vec::append(\n+                    ~[filter_attrs(*item)],\n+                    mk_rec_impl(cx, item.span, item.ident, fields, tps)\n+                )\n             },\n             ast::item_class(@{ fields, _}, tps) => {\n-                ~[\n-                    filter_attrs(*item),\n-                    mk_struct_impl(cx, item.span, item.ident, fields, tps),\n-                ]\n+                vec::append(\n+                    ~[filter_attrs(*item)],\n+                    mk_struct_impl(cx, item.span, item.ident, fields, tps)\n+                )\n             },\n             ast::item_enum(enum_def, tps) => {\n-                ~[\n-                    filter_attrs(*item),\n-                    mk_enum_impl(cx, item.span, item.ident, enum_def, tps),\n-                ]\n+                vec::append(\n+                    ~[filter_attrs(*item)],\n+                    mk_enum_impl(cx, item.span, item.ident, enum_def, tps)\n+                )\n             },\n             _ => {\n                 cx.span_err(span, ~\"#[auto_serialize2] can only be applied \\\n@@ -152,22 +156,11 @@ fn mk_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n+    path: @ast::path,\n     tps: ~[ast::ty_param],\n-    ser_body: @ast::expr,\n-    deser_body: @ast::expr\n+    f: fn(@ast::ty) -> @ast::method\n ) -> @ast::item {\n-    // Make a path to the std::serialization2::Serializable trait.\n-    let path = cx.path(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization2\"),\n-            cx.ident_of(~\"Serializable\"),\n-        ]\n-    );\n-\n-    // All the type parameters need to bound to\n-    // std::serialization::Serializable.\n+    // All the type parameters need to bound to the trait.\n     let trait_tps = do tps.map |tp| {\n         let t_bound = ast::bound_trait(@{\n             id: cx.next_id(),\n@@ -194,23 +187,72 @@ fn mk_impl(\n         tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n     );\n \n-    let methods = ~[\n-        mk_ser_method(cx, span, cx.expr_blk(ser_body)),\n-        mk_deser_method(cx, span, ty, cx.expr_blk(deser_body)),\n-    ];\n-\n     @{\n         // This is a new-style impl declaration.\n         // XXX: clownshoes\n         ident: ast::token::special_idents::clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, methods),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n         vis: ast::public,\n         span: span,\n     }\n }\n \n+fn mk_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization2::Serializable trait.\n+    let path = cx.path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization2\"),\n+            cx.ident_of(~\"Serializable\"),\n+        ]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        path,\n+        tps,\n+        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n+    )\n+}\n+\n+fn mk_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization2::Deserializable trait.\n+    let path = cx.path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization2\"),\n+            cx.ident_of(~\"Deserializable\"),\n+        ]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        path,\n+        tps,\n+        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n+    )\n+}\n+\n fn mk_ser_method(\n     cx: ext_ctxt,\n     span: span,\n@@ -352,7 +394,7 @@ fn mk_rec_impl(\n     ident: ast::ident,\n     fields: ~[ast::ty_field],\n     tps: ~[ast::ty_param]\n-) -> @ast::item {\n+) -> ~[@ast::item] {\n     // Records and structs don't have the same fields types, but they share\n     // enough that if we extract the right subfields out we can share the\n     // serialization generator code.\n@@ -365,11 +407,26 @@ fn mk_rec_impl(\n     };\n \n     let ser_body = mk_ser_fields(cx, span, fields);\n+\n+    // ast for `__s.emit_rec($(ser_body))`\n+    let ser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_rec\")\n+        ),\n+        ~[ser_body]\n+    );\n+\n     let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n          cx.expr(span, ast::expr_rec(fields, None))\n     };\n \n-    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+    ~[\n+        mk_ser_impl(cx, span, ident, tps, ser_body),\n+        mk_deser_impl(cx, span, ident, tps, deser_body),\n+    ]\n }\n \n fn mk_struct_impl(\n@@ -378,7 +435,7 @@ fn mk_struct_impl(\n     ident: ast::ident,\n     fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n-) -> @ast::item {\n+) -> ~[@ast::item] {\n     // Records and structs don't have the same fields types, but they share\n     // enough that if we extract the right subfields out we can share the\n     // serialization generator code.\n@@ -400,11 +457,26 @@ fn mk_struct_impl(\n     };\n \n     let ser_body = mk_ser_fields(cx, span, fields);\n+\n+    // ast for `__s.emit_struct($(name), $(ser_body))`\n+    let ser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_struct\")\n+        ),\n+        ~[cx.lit_str(span, @cx.str_of(ident)), ser_body]\n+    );\n+\n     let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n         cx.expr(span, ast::expr_struct(cx.path(span, ~[ident]), fields, None))\n     };\n \n-    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+    ~[\n+        mk_ser_impl(cx, span, ident, tps, ser_body),\n+        mk_deser_impl(cx, span, ident, tps, deser_body),\n+    ]\n }\n \n fn mk_ser_fields(\n@@ -430,14 +502,14 @@ fn mk_ser_fields(\n             )\n         );\n \n-        // ast for `__s.emit_rec_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n             cx.expr_call(\n                 span,\n                 cx.expr_field(\n                     span,\n                     cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_rec_field\")\n+                    cx.ident_of(~\"emit_field\")\n                 ),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n@@ -448,16 +520,8 @@ fn mk_ser_fields(\n         )\n     };\n \n-    // ast for `__s.emit_rec(|| $(stmts))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_rec\")\n-        ),\n-        ~[cx.lambda_stmts(span, stmts)]\n-    )\n+    // ast for `|| $(stmts)`\n+    cx.lambda_stmts(span, stmts)\n }\n \n fn mk_deser_fields(\n@@ -482,13 +546,13 @@ fn mk_deser_fields(\n             )\n         );\n \n-        // ast for `__d.read_rec_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n         let expr: @ast::expr = cx.expr_call(\n             span,\n             cx.expr_field(\n                 span,\n                 cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_rec_field\")\n+                cx.ident_of(~\"read_field\")\n             ),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n@@ -521,7 +585,7 @@ fn mk_enum_impl(\n     ident: ast::ident,\n     enum_def: ast::enum_def,\n     tps: ~[ast::ty_param]\n-) -> @ast::item {\n+) -> ~[@ast::item] {\n     let ser_body = mk_enum_ser_body(\n         cx,\n         span,\n@@ -536,7 +600,10 @@ fn mk_enum_impl(\n         enum_def.variants\n     );\n \n-    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+    ~[\n+        mk_ser_impl(cx, span, ident, tps, ser_body),\n+        mk_deser_impl(cx, span, ident, tps, deser_body),\n+    ]\n }\n \n fn ser_variant("}, {"sha": "286b0eba5a1582e2a2775766de723df5fa0a520a", "filename": "src/test/run-pass/auto_serialize2-box.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0a950f394dbe3275c4879dc1f26f78a096f93e28/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a950f394dbe3275c4879dc1f26f78a096f93e28/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs?ref=0a950f394dbe3275c4879dc1f26f78a096f93e28", "patch": "@@ -1,71 +0,0 @@\n-extern mod std;\n-\n-// These tests used to be separate files, but I wanted to refactor all\n-// the common code.\n-\n-use cmp::Eq;\n-use std::ebml2;\n-use io::Writer;\n-use std::serialization2::{Serializer, Serializable, deserialize};\n-use std::prettyprint2;\n-\n-fn test_ser_and_deser<A:Eq Serializable>(\n-    a1: A,\n-    expected: ~str\n-) {\n-    // check the pretty printer:\n-    let s = do io::with_str_writer |w| {\n-        a1.serialize(&prettyprint2::Serializer(w))\n-    };\n-    debug!(\"s == %?\", s);\n-    assert s == expected;\n-\n-    // check the EBML serializer:\n-    let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = &ebml2::Serializer(wr);\n-        a1.serialize(ebml_w)\n-    };\n-    let d = ebml2::Doc(@bytes);\n-    let a2: A = deserialize(&ebml2::Deserializer(d));\n-    assert a1 == a2;\n-}\n-\n-#[auto_serialize2]\n-enum Expr {\n-    Val(uint),\n-    Plus(@Expr, @Expr),\n-    Minus(@Expr, @Expr)\n-}\n-\n-impl Expr : cmp::Eq {\n-    pure fn eq(other: &Expr) -> bool {\n-        match self {\n-            Val(e0a) => {\n-                match *other {\n-                    Val(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Plus(e0a, e1a) => {\n-                match *other {\n-                    Plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Minus(e0a, e1a) => {\n-                match *other {\n-                    Minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(other: &Expr) -> bool { !self.eq(other) }\n-}\n-\n-fn main() {\n-    test_ser_and_deser(Plus(@Minus(@Val(3u), @Val(10u)),\n-                            @Plus(@Val(22u), @Val(5u))),\n-                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n-                        @Plus(@Val(22u), @Val(5u)))\");\n-}"}, {"sha": "8328c4a5126868a49a361b2ef93ea9b2d7c80570", "filename": "src/test/run-pass/auto_serialize2.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81423a3866fb6cd4cadd28ed49273d7e22d48c17/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs?ref=81423a3866fb6cd4cadd28ed49273d7e22d48c17", "patch": "@@ -6,14 +6,13 @@ extern mod std;\n use cmp::Eq;\n use std::ebml2;\n use io::Writer;\n-use std::serialization2::{Serializer, Serializable, deserialize};\n+use std::serialization2::{Serializable, Deserializable, deserialize};\n use std::prettyprint2;\n \n-fn test_ser_and_deser<A:Eq Serializable>(\n+fn test_ser_and_deser<A:Eq Serializable Deserializable>(\n     a1: A,\n     expected: ~str\n ) {\n-\n     // check the pretty printer:\n     let s = do io::with_str_writer |w| {\n         a1.serialize(&prettyprint2::Serializer(w))\n@@ -31,6 +30,39 @@ fn test_ser_and_deser<A:Eq Serializable>(\n     assert a1 == a2;\n }\n \n+#[auto_serialize2]\n+enum Expr {\n+    Val(uint),\n+    Plus(@Expr, @Expr),\n+    Minus(@Expr, @Expr)\n+}\n+\n+impl Expr : cmp::Eq {\n+    pure fn eq(other: &Expr) -> bool {\n+        match self {\n+            Val(e0a) => {\n+                match *other {\n+                    Val(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Plus(e0a, e1a) => {\n+                match *other {\n+                    Plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            Minus(e0a, e1a) => {\n+                match *other {\n+                    Minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Expr) -> bool { !self.eq(other) }\n+}\n+\n impl AnEnum : cmp::Eq {\n     pure fn eq(other: &AnEnum) -> bool {\n         self.v == other.v\n@@ -101,15 +133,20 @@ enum Quark<T> {\n enum CLike { A, B, C }\n \n fn main() {\n+    test_ser_and_deser(Plus(@Minus(@Val(3u), @Val(10u)),\n+                            @Plus(@Val(22u), @Val(5u))),\n+                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n+                        @Plus(@Val(22u), @Val(5u)))\");\n+\n     test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n                        ~\"{lo: 0u, hi: 5u, node: 22u}\");\n \n     test_ser_and_deser(AnEnum({v: ~[1u, 2u, 3u]}),\n-                       ~\"AnEnum({v: [1u, 2u, 3u]})\");\n+                       ~\"AnEnum({v: ~[1u, 2u, 3u]})\");\n \n     test_ser_and_deser({x: 3u, y: 5u}, ~\"{x: 3u, y: 5u}\");\n \n-    test_ser_and_deser(~[1u, 2u, 3u], ~\"[1u, 2u, 3u]\");\n+    test_ser_and_deser(@[1u, 2u, 3u], ~\"@[1u, 2u, 3u]\");\n \n     test_ser_and_deser(Top(22u), ~\"Top(22u)\");\n     test_ser_and_deser(Bottom(222u), ~\"Bottom(222u)\");"}]}