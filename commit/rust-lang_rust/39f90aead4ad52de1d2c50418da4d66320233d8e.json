{"sha": "39f90aead4ad52de1d2c50418da4d66320233d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjkwYWVhZDRhZDUyZGUxZDJjNTA0MThkYTRkNjYzMjAyMzNkOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-01T20:21:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-01T20:21:47Z"}, "message": "auto merge of #18474 : alexcrichton/rust/no-more-traits, r=aturon\n\nAs part of the collections reform RFC, this commit removes all collections\r\ntraits in favor of inherent methods on collections themselves. All methods\r\nshould continue to be available on all collections.\r\n\r\nThis is a breaking change with all of the collections traits being removed and\r\nno longer being in the prelude. In order to update old code you should move the\r\ntrait implementations to inherent implementations directly on the type itself.\r\n\r\nNote that some traits had default methods which will also need to be implemented\r\nto maintain backwards compatibility.\r\n\r\n[breaking-change]\r\ncc #18424", "tree": {"sha": "6ffff6a5ffbd64e9da3d9d947b88f442f396f50c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ffff6a5ffbd64e9da3d9d947b88f442f396f50c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f90aead4ad52de1d2c50418da4d66320233d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f90aead4ad52de1d2c50418da4d66320233d8e", "html_url": "https://github.com/rust-lang/rust/commit/39f90aead4ad52de1d2c50418da4d66320233d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f90aead4ad52de1d2c50418da4d66320233d8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0547a407aa03b9f1c03843aead617a2e8c5d1147", "url": "https://api.github.com/repos/rust-lang/rust/commits/0547a407aa03b9f1c03843aead617a2e8c5d1147", "html_url": "https://github.com/rust-lang/rust/commit/0547a407aa03b9f1c03843aead617a2e8c5d1147"}, {"sha": "21ac985af44f4e2470ef6f4c0eb4d72daf5a6497", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ac985af44f4e2470ef6f4c0eb4d72daf5a6497", "html_url": "https://github.com/rust-lang/rust/commit/21ac985af44f4e2470ef6f4c0eb4d72daf5a6497"}], "stats": {"total": 4031, "additions": 2462, "deletions": 1569}, "files": [{"sha": "a212f22f899290bd0643994f7e4a88b7a0f0485b", "filename": "src/libcollections/bench.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::*;\n+use std::rand;\n+use std::rand::Rng;\n+use test::Bencher;\n+\n+pub fn insert_rand_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n+                        insert: |&mut M, uint|,\n+                        remove: |&mut M, uint|) {\n+    // setup\n+    let mut rng = rand::weak_rng();\n+\n+    for _ in range(0, n) {\n+        insert(map, rng.gen::<uint>() % n);\n+    }\n+\n+    // measure\n+    b.iter(|| {\n+        let k = rng.gen::<uint>() % n;\n+        insert(map, k);\n+        remove(map, k);\n+    })\n+}\n+\n+pub fn insert_seq_n<M>(n: uint, map: &mut M, b: &mut Bencher,\n+                       insert: |&mut M, uint|,\n+                       remove: |&mut M, uint|) {\n+    // setup\n+    for i in range(0u, n) {\n+        insert(map, i * 2);\n+    }\n+\n+    // measure\n+    let mut i = 1;\n+    b.iter(|| {\n+        insert(map, i);\n+        remove(map, i);\n+        i = (i + 2) % n;\n+    })\n+}\n+\n+pub fn find_rand_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n+                         insert: |&mut M, uint|,\n+                         find: |&M, uint| -> T) {\n+    // setup\n+    let mut rng = rand::weak_rng();\n+    let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n+\n+    for k in keys.iter() {\n+        insert(map, *k);\n+    }\n+\n+    rng.shuffle(keys.as_mut_slice());\n+\n+    // measure\n+    let mut i = 0;\n+    b.iter(|| {\n+        let t = find(map, keys[i]);\n+        i = (i + 1) % n;\n+        t\n+    })\n+}\n+\n+pub fn find_seq_n<M, T>(n: uint, map: &mut M, b: &mut Bencher,\n+                        insert: |&mut M, uint|,\n+                        find: |&M, uint| -> T) {\n+    // setup\n+    for i in range(0u, n) {\n+        insert(map, i);\n+    }\n+\n+    // measure\n+    let mut i = 0;\n+    b.iter(|| {\n+        let x = find(map, i);\n+        i = (i + 1) % n;\n+        x\n+    })\n+}"}, {"sha": "26e0c73724c6aa461f1128d4cf63d16bd093a610", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -70,7 +70,6 @@ use core::slice;\n use core::u32;\n use std::hash;\n \n-use {Mutable, Set, MutableSet, MutableSeq};\n use vec::Vec;\n \n type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n@@ -755,6 +754,20 @@ impl Bitv {\n         }\n         self.set(insert_pos, elem);\n     }\n+\n+    /// Return the total number of bits in this vector\n+    #[inline]\n+    pub fn len(&self) -> uint { self.nbits }\n+\n+    /// Returns true if there are no bits in this vector\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears all bits in this vector.\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        for w in self.storage.iter_mut() { *w = 0u32; }\n+    }\n }\n \n /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n@@ -804,18 +817,6 @@ impl Default for Bitv {\n     fn default() -> Bitv { Bitv::new() }\n }\n \n-impl Collection for Bitv {\n-    #[inline]\n-    fn len(&self) -> uint { self.nbits }\n-}\n-\n-impl Mutable for Bitv {\n-    #[inline]\n-    fn clear(&mut self) {\n-        for w in self.storage.iter_mut() { *w = 0u32; }\n-    }\n-}\n-\n impl FromIterator<bool> for Bitv {\n     fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n@@ -1466,61 +1467,45 @@ impl BitvSet {\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n-}\n-\n-impl fmt::Show for BitvSet {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n-        let mut first = true;\n-        for n in self.iter() {\n-            if !first {\n-                try!(write!(fmt, \", \"));\n-            }\n-            try!(write!(fmt, \"{}\", n));\n-            first = false;\n-        }\n-        write!(fmt, \"}}\")\n-    }\n-}\n \n-impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n-    fn hash(&self, state: &mut S) {\n-        for pos in self.iter() {\n-            pos.hash(state);\n-        }\n+    /// Return the number of set bits in this set.\n+    #[inline]\n+    pub fn len(&self) -> uint  {\n+        let &BitvSet(ref bitv) = self;\n+        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n     }\n-}\n \n-impl Collection for BitvSet {\n+    /// Returns whether there are no bits set in this set\n     #[inline]\n-    fn len(&self) -> uint  {\n+    pub fn is_empty(&self) -> bool {\n         let &BitvSet(ref bitv) = self;\n-        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n+        bitv.storage.iter().all(|&n| n == 0)\n     }\n-}\n \n-impl Mutable for BitvSet {\n+    /// Clears all bits in this set\n     #[inline]\n-    fn clear(&mut self) {\n+    pub fn clear(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.clear();\n     }\n-}\n \n-impl Set<uint> for BitvSet {\n+    /// Returns `true` if this set contains the specified integer.\n     #[inline]\n-    fn contains(&self, value: &uint) -> bool {\n+    pub fn contains(&self, value: &uint) -> bool {\n         let &BitvSet(ref bitv) = self;\n         *value < bitv.nbits && bitv.get(*value)\n     }\n \n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n     #[inline]\n-    fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n+    /// Returns `true` if the set is a subset of another.\n     #[inline]\n-    fn is_subset(&self, other: &BitvSet) -> bool {\n+    pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let &BitvSet(ref self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n \n@@ -1531,14 +1516,15 @@ impl Set<uint> for BitvSet {\n         self_bitv.mask_words(other_bitv.storage.len()).all(|(_, w)| w == 0)\n     }\n \n+    /// Returns `true` if the set is a superset of another.\n     #[inline]\n-    fn is_superset(&self, other: &BitvSet) -> bool {\n+    pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n-}\n \n-impl MutableSet<uint> for BitvSet {\n-    fn insert(&mut self, value: uint) -> bool {\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n         }\n@@ -1554,7 +1540,9 @@ impl MutableSet<uint> for BitvSet {\n         return true;\n     }\n \n-    fn remove(&mut self, value: &uint) -> bool {\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n         }\n@@ -1564,6 +1552,29 @@ impl MutableSet<uint> for BitvSet {\n     }\n }\n \n+impl fmt::Show for BitvSet {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt, \"{{\"));\n+        let mut first = true;\n+        for n in self.iter() {\n+            if !first {\n+                try!(write!(fmt, \", \"));\n+            }\n+            try!(write!(fmt, \"{}\", n));\n+            first = false;\n+        }\n+        write!(fmt, \"}}\")\n+    }\n+}\n+\n+impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n+    fn hash(&self, state: &mut S) {\n+        for pos in self.iter() {\n+            pos.hash(state);\n+        }\n+    }\n+}\n+\n /// An iterator for `BitvSet`.\n pub struct BitPositions<'a> {\n     set: &'a BitvSet,\n@@ -1643,7 +1654,6 @@ mod tests {\n     use std::rand::Rng;\n     use test::Bencher;\n \n-    use {Set, Mutable, MutableSet, MutableSeq};\n     use bitv::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;"}, {"sha": "4570d49ba0ace81482d402acb88ed10f282293f1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 186, "deletions": 37, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -23,11 +23,8 @@ use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n \n-use {Deque, Map, MutableMap, Mutable, MutableSeq};\n use ringbuf::RingBuf;\n \n-\n-\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -145,17 +142,46 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             b: b,\n         }\n     }\n-}\n \n-impl<K: Ord, V> Map<K, V> for BTreeMap<K, V> {\n+    /// Clears the map, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) {\n+        let b = self.b;\n+        // avoid recursive destructors by manually traversing the tree\n+        for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n+    }\n+\n     // Searching in a B-Tree is pretty straightforward.\n     //\n     // Start at the root. Try to find the key in the current node. If we find it, return it.\n     // If it's not in there, follow the edge *before* the smallest key larger than\n     // the search key. If no such key exists (they're *all* smaller), then just take the last\n     // edge in the node. If we're in a leaf and we don't find our key, then it's not\n     // in the tree.\n-    fn find(&self, key: &K) -> Option<&V> {\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.find(&1), Some(&\"a\"));\n+    /// assert_eq!(map.find(&2), None);\n+    /// ```\n+    pub fn find(&self, key: &K) -> Option<&V> {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -170,11 +196,41 @@ impl<K: Ord, V> Map<K, V> for BTreeMap<K, V> {\n             }\n         }\n     }\n-}\n \n-impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// match map.find_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n     // See `find` for implementation notes, this is basically a copy-paste with mut's added\n-    fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -218,7 +274,23 @@ impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n     // 2) While ODS may potentially return the pair we *just* inserted after\n     // the split, we will never do this. Again, this shouldn't effect the analysis.\n \n-    fn swap(&mut self, key: K, mut value: V) -> Option<V> {\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    pub fn swap(&mut self, key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n         // because as far as Rust is concerned, we can mutate aliased data with such a\n@@ -266,6 +338,25 @@ impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n         }\n     }\n \n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n+    /// not already exist in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.insert(2u, \"value\"), true);\n+    /// assert_eq!(map.insert(2, \"value2\"), false);\n+    /// assert_eq!(map[2], \"value2\");\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, key: K, value: V) -> bool {\n+        self.swap(key, value).is_none()\n+    }\n+\n     // Deletion is the most complicated operation for a B-Tree.\n     //\n     // First we do the same kind of search described in\n@@ -301,7 +392,20 @@ impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n     //      the underflow handling process on the parent. If merging merges the last two children\n     //      of the root, then we replace the root with the merged node.\n \n-    fn pop(&mut self, key: &K) -> Option<V> {\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.pop(&1), Some(\"a\"));\n+    /// assert_eq!(map.pop(&1), None);\n+    /// ```\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -322,6 +426,24 @@ impl<K: Ord, V> MutableMap<K, V> for BTreeMap<K, V> {\n             }\n         }\n     }\n+\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.remove(&1u), false);\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), true);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, key: &K) -> bool {\n+        self.pop(key).is_some()\n+    }\n }\n \n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n@@ -331,7 +453,6 @@ mod stack {\n     use core::prelude::*;\n     use super::BTreeMap;\n     use super::super::node::*;\n-    use {MutableMap, MutableSeq};\n     use vec::Vec;\n \n     type StackItem<K, V> = (*mut Node<K, V>, uint);\n@@ -603,20 +724,6 @@ mod stack {\n     }\n }\n \n-impl<K, V> Collection for BTreeMap<K, V> {\n-    fn len(&self) -> uint {\n-        self.length\n-    }\n-}\n-\n-impl<K: Ord, V> Mutable for BTreeMap<K, V> {\n-    fn clear(&mut self) {\n-        let b = self.b;\n-        // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n-    }\n-}\n-\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -950,6 +1057,34 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_, v)| v)\n     }\n+\n+    /// Return the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1u, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1u, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n@@ -993,7 +1128,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n mod test {\n     use std::prelude::*;\n \n-    use {Map, MutableMap};\n     use super::{BTreeMap, Occupied, Vacant};\n \n     #[test]\n@@ -1199,58 +1333,73 @@ mod bench {\n     use test::{Bencher, black_box};\n \n     use super::BTreeMap;\n-    use MutableMap;\n-    use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n+    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        insert_rand_n(100, &mut m, b);\n+        insert_rand_n(100, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        insert_rand_n(10_000, &mut m, b);\n+        insert_rand_n(10_000, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        insert_seq_n(100, &mut m, b);\n+        insert_seq_n(100, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        insert_seq_n(10_000, &mut m, b);\n+        insert_seq_n(10_000, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        find_rand_n(100, &mut m, b);\n+        find_rand_n(100, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        find_rand_n(10_000, &mut m, b);\n+        find_rand_n(10_000, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        find_seq_n(100, &mut m, b);\n+        find_seq_n(100, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n-        find_seq_n(10_000, &mut m, b);\n+        find_seq_n(10_000, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {"}, {"sha": "a15d31ba2842abd044225644b377c21383637b2d", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -15,7 +15,6 @@ use core::prelude::*;\n \n use core::{slice, mem, ptr};\n use core::iter::Zip;\n-use MutableSeq;\n \n use vec;\n use vec::Vec;"}, {"sha": "eac74098758ae2b0f924dbac53e913543e1fe193", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 141, "deletions": 21, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -20,8 +20,6 @@ use core::{iter, fmt};\n use core::iter::Peekable;\n use core::fmt::Show;\n \n-use {Mutable, Set, MutableSet, MutableMap, Map};\n-\n /// A set based on a B-Tree.\n ///\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n@@ -109,30 +107,104 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n-}\n-\n-impl<T> Collection for BTreeSet<T> {\n-    fn len(&self) -> uint {\n-        self.map.len()\n-    }\n-}\n \n-impl<T: Ord> Mutable for BTreeSet<T> {\n-    fn clear(&mut self) {\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut v = BTreeSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1i);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut v = BTreeSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut v = BTreeSet::new();\n+    /// v.insert(1i);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) {\n         self.map.clear()\n     }\n-}\n \n-impl<T: Ord> Set<T> for BTreeSet<T> {\n-    fn contains(&self, value: &T) -> bool {\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    pub fn contains(&self, value: &T) -> bool {\n         self.map.find(value).is_some()\n     }\n \n-    fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let a: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: BTreeSet<int> = BTreeSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n-    fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let sup: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -156,14 +228,63 @@ impl<T: Ord> Set<T> for BTreeSet<T> {\n         }\n         true\n     }\n-}\n \n-impl<T: Ord> MutableSet<T> for BTreeSet<T>{\n-    fn insert(&mut self, value: T) -> bool {\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let sub: BTreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let mut set: BTreeSet<int> = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2i), true);\n+    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    pub fn insert(&mut self, value: T) -> bool {\n         self.map.insert(value, ())\n     }\n \n-    fn remove(&mut self, value: &T) -> bool {\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(2i);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    pub fn remove(&mut self, value: &T) -> bool {\n         self.map.remove(value)\n     }\n }\n@@ -273,7 +394,6 @@ impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n mod test {\n     use std::prelude::*;\n \n-    use {Set, MutableSet};\n     use super::BTreeSet;\n     use std::hash;\n "}, {"sha": "d7970ed8d60c3ebe42085960305154faee362f07", "filename": "src/libcollections/deque.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0547a407aa03b9f1c03843aead617a2e8c5d1147/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547a407aa03b9f1c03843aead617a2e8c5d1147/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=0547a407aa03b9f1c03843aead617a2e8c5d1147", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Container traits for collections.\n-\n-#[cfg(test)]\n-pub mod bench {\n-    use std::prelude::*;\n-    use std::rand;\n-    use std::rand::Rng;\n-    use test::Bencher;\n-    use MutableMap;\n-\n-    pub fn insert_rand_n<M: MutableMap<uint, uint>>(n: uint,\n-                                                    map: &mut M,\n-                                                    b: &mut Bencher) {\n-        // setup\n-        let mut rng = rand::weak_rng();\n-\n-        map.clear();\n-        for _ in range(0, n) {\n-            map.insert(rng.gen::<uint>() % n, 1);\n-        }\n-\n-        // measure\n-        b.iter(|| {\n-            let k = rng.gen::<uint>() % n;\n-            map.insert(k, 1);\n-            map.remove(&k);\n-        })\n-    }\n-\n-    pub fn insert_seq_n<M: MutableMap<uint, uint>>(n: uint,\n-                                                   map: &mut M,\n-                                                   b: &mut Bencher) {\n-        // setup\n-        map.clear();\n-        for i in range(0u, n) {\n-            map.insert(i*2, 1);\n-        }\n-\n-        // measure\n-        let mut i = 1;\n-        b.iter(|| {\n-            map.insert(i, 1);\n-            map.remove(&i);\n-            i = (i + 2) % n;\n-        })\n-    }\n-\n-    pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,\n-                                                map: &mut M,\n-                                                b: &mut Bencher) {\n-        // setup\n-        let mut rng = rand::weak_rng();\n-        let mut keys = Vec::from_fn(n, |_| rng.gen::<uint>() % n);\n-\n-        for k in keys.iter() {\n-            map.insert(*k, 1);\n-        }\n-\n-        rng.shuffle(keys.as_mut_slice());\n-\n-        // measure\n-        let mut i = 0;\n-        b.iter(|| {\n-            map.find(&keys[i]);\n-            i = (i + 1) % n;\n-        })\n-    }\n-\n-    pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,\n-                                               map: &mut M,\n-                                               b: &mut Bencher) {\n-        // setup\n-        for i in range(0u, n) {\n-            map.insert(i, 1);\n-        }\n-\n-        // measure\n-        let mut i = 0;\n-        b.iter(|| {\n-            let x = map.find(&i);\n-            i = (i + 1) % n;\n-            x\n-        })\n-     }\n-}\n-"}, {"sha": "a1e286d1245749470c6ebf4ba42af2eb1ff445fd", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 101, "deletions": 85, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -31,8 +31,6 @@ use core::mem;\n use core::ptr;\n use std::hash::{Writer, Hash};\n \n-use {Mutable, Deque, MutableSeq};\n-\n /// A doubly-linked list.\n pub struct DList<T> {\n     length: uint,\n@@ -129,34 +127,6 @@ fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n     Some(next)\n }\n \n-impl<T> Collection for DList<T> {\n-    /// Returns `true` if the `DList` is empty.\n-    ///\n-    /// This operation should compute in O(1) time.\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.list_head.is_none()\n-    }\n-\n-    /// Returns the length of the `DList`.\n-    ///\n-    /// This operation should compute in O(1) time.\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.length\n-    }\n-}\n-\n-impl<T> Mutable for DList<T> {\n-    /// Removes all elements from the `DList`.\n-    ///\n-    /// This operation should compute in O(n) time.\n-    #[inline]\n-    fn clear(&mut self) {\n-        *self = DList::new()\n-    }\n-}\n-\n // private methods\n impl<T> DList<T> {\n     /// Add a Node first in the list\n@@ -217,60 +187,6 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T> Deque<T> for DList<T> {\n-    /// Provides a reference to the front element, or `None` if the list is\n-    /// empty.\n-    #[inline]\n-    fn front<'a>(&'a self) -> Option<&'a T> {\n-        self.list_head.as_ref().map(|head| &head.value)\n-    }\n-\n-    /// Provides a mutable reference to the front element, or `None` if the list\n-    /// is empty.\n-    #[inline]\n-    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.list_head.as_mut().map(|head| &mut head.value)\n-    }\n-\n-    /// Provides a reference to the back element, or `None` if the list is\n-    /// empty.\n-    #[inline]\n-    fn back<'a>(&'a self) -> Option<&'a T> {\n-        self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n-    }\n-\n-    /// Provides a mutable reference to the back element, or `None` if the list\n-    /// is empty.\n-    #[inline]\n-    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.list_tail.resolve().map(|tail| &mut tail.value)\n-    }\n-\n-    /// Adds an element first in the list.\n-    ///\n-    /// This operation should compute in O(1) time.\n-    fn push_front(&mut self, elt: T) {\n-        self.push_front_node(box Node::new(elt))\n-    }\n-\n-    /// Removes the first element and returns it, or `None` if the list is\n-    /// empty.\n-    ///\n-    /// This operation should compute in O(1) time.\n-    fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|box Node{value, ..}| value)\n-    }\n-}\n-\n-impl<T> MutableSeq<T> for DList<T> {\n-    fn push(&mut self, elt: T) {\n-        self.push_back_node(box Node::new(elt))\n-    }\n-    fn pop(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|box Node{value, ..}| value)\n-    }\n-}\n-\n impl<T> Default for DList<T> {\n     #[inline]\n     fn default() -> DList<T> { DList::new() }\n@@ -495,6 +411,107 @@ impl<T> DList<T> {\n     pub fn into_iter(self) -> MoveItems<T> {\n         MoveItems{list: self}\n     }\n+\n+    /// Returns `true` if the `DList` is empty.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.list_head.is_none()\n+    }\n+\n+    /// Returns the length of the `DList`.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        self.length\n+    }\n+\n+    /// Removes all elements from the `DList`.\n+    ///\n+    /// This operation should compute in O(n) time.\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        *self = DList::new()\n+    }\n+\n+    /// Provides a reference to the front element, or `None` if the list is\n+    /// empty.\n+    #[inline]\n+    pub fn front<'a>(&'a self) -> Option<&'a T> {\n+        self.list_head.as_ref().map(|head| &head.value)\n+    }\n+\n+    /// Provides a mutable reference to the front element, or `None` if the list\n+    /// is empty.\n+    #[inline]\n+    pub fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        self.list_head.as_mut().map(|head| &mut head.value)\n+    }\n+\n+    /// Provides a reference to the back element, or `None` if the list is\n+    /// empty.\n+    #[inline]\n+    pub fn back<'a>(&'a self) -> Option<&'a T> {\n+        self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n+    }\n+\n+    /// Provides a mutable reference to the back element, or `None` if the list\n+    /// is empty.\n+    #[inline]\n+    pub fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        self.list_tail.resolve().map(|tail| &mut tail.value)\n+    }\n+\n+    /// Adds an element first in the list.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    pub fn push_front(&mut self, elt: T) {\n+        self.push_front_node(box Node::new(elt))\n+    }\n+\n+    /// Removes the first element and returns it, or `None` if the list is\n+    /// empty.\n+    ///\n+    /// This operation should compute in O(1) time.\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        self.pop_front_node().map(|box Node{value, ..}| value)\n+    }\n+\n+    /// Appends an element to the back of a list\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut d = DList::new();\n+    /// d.push(1i);\n+    /// d.push(3);\n+    /// assert_eq!(3, *d.back().unwrap());\n+    /// ```\n+    pub fn push(&mut self, elt: T) {\n+        self.push_back_node(box Node::new(elt))\n+    }\n+\n+    /// Removes the last element from a list and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut d = DList::new();\n+    /// assert_eq!(d.pop(), None);\n+    /// d.push(1i);\n+    /// d.push(3);\n+    /// assert_eq!(d.pop(), Some(3));\n+    /// ```\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.pop_back_node().map(|box Node{value, ..}| value)\n+    }\n }\n \n impl<T: Ord> DList<T> {\n@@ -745,7 +762,6 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use {Deque, MutableSeq};\n     use super::{DList, Node, ListInsertion};\n     use vec::Vec;\n "}, {"sha": "b78c1897b065939bccc66aa11b05fc3bbcf72198", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -157,8 +157,6 @@ mod test {\n \n     use enum_set::{EnumSet, CLike};\n \n-    use MutableSeq;\n-\n     #[deriving(PartialEq, Show)]\n     #[repr(uint)]\n     enum Foo {"}, {"sha": "dd105c44ad336ebd779fb177806a5e02baa2da80", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -279,8 +279,6 @@ mod tests {\n     use super::super::{Hash, Writer};\n     use super::{SipState, hash, hash_with_keys};\n \n-    use MutableSeq;\n-\n     // Hash just the bytes of the slice, without length prefix\n     struct Bytes<'a>(&'a [u8]);\n "}, {"sha": "e28bc766480153d992f4b03ebd48ed96d9c81bfc", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 458, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -37,11 +37,8 @@ extern crate alloc;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-use core::prelude::Option;\n-\n pub use bitv::{Bitv, BitvSet};\n pub use btree::{BTreeMap, BTreeSet};\n-pub use core::prelude::Collection;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n pub use priority_queue::PriorityQueue;\n@@ -69,457 +66,7 @@ pub mod string;\n pub mod vec;\n pub mod hash;\n \n-mod deque;\n-\n-/// A mutable container type.\n-pub trait Mutable: Collection {\n-    /// Clears the container, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    fn clear(&mut self);\n-}\n-\n-/// A key-value store where values may be looked up by their keys. This trait\n-/// provides basic operations to operate on these stores.\n-pub trait Map<K, V>: Collection {\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.find(&\"a\"), Some(&1i));\n-    /// assert_eq!(map.find(&\"b\"), None);\n-    /// ```\n-    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.contains_key(&\"a\"), true);\n-    /// assert_eq!(map.contains_key(&\"b\"), false);\n-    /// ```\n-    #[inline]\n-    fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n-    }\n-}\n-\n-/// A key-value store (map) where the values can be modified.\n-pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(\"key\", 2i), true);\n-    /// assert_eq!(map.insert(\"key\", 9i), false);\n-    /// assert_eq!(map[\"key\"], 9i);\n-    /// ```\n-    #[inline]\n-    fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.remove(&\"key\"), false);\n-    /// map.insert(\"key\", 2i);\n-    /// assert_eq!(map.remove(&\"key\"), true);\n-    /// ```\n-    #[inline]\n-    fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n-    }\n-\n-    /// Inserts a key-value pair into the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is\n-    /// returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.swap(\"a\", 37i), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.swap(\"a\", 37i), Some(1i));\n-    /// assert_eq!(map[\"a\"], 37i);\n-    /// ```\n-    fn swap(&mut self, k: K, v: V) -> Option<V>;\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.pop(&\"a\"), Some(1i));\n-    /// assert_eq!(map.pop(&\"a\"), None);\n-    /// ```\n-    fn pop(&mut self, k: &K) -> Option<V>;\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// match map.find_mut(&\"a\") {\n-    ///     Some(x) => *x = 7i,\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(map[\"a\"], 7i);\n-    /// ```\n-    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n-}\n-\n-/// A group of objects which are each distinct from one another. This\n-/// trait represents actions which can be performed on sets to iterate over\n-/// them.\n-pub trait Set<T>: Collection {\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let set: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    fn contains(&self, value: &T) -> bool;\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: HashSet<int> = HashSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    fn is_disjoint(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sup: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    fn is_subset(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sub: HashSet<int> = [1i, 2].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    fn is_superset(&self, other: &Self) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n-}\n-\n-/// A mutable collection of values which are distinct from one another that\n-/// can be mutated.\n-pub trait MutableSet<T>: Set<T> + Mutable {\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    fn insert(&mut self, value: T) -> bool;\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// set.insert(2i);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    fn remove(&mut self, value: &T) -> bool;\n-}\n-\n-pub trait MutableSeq<T>: Mutable {\n-    /// Appends an element to the back of a collection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n-    /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n-    /// ```\n-    fn push(&mut self, t: T);\n-\n-    /// Removes the last element from a collection and returns it, or `None` if\n-    /// it is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut vec = vec!(1i, 2, 3);\n-    /// assert_eq!(vec.pop(), Some(3));\n-    /// assert_eq!(vec, vec!(1, 2));\n-    /// ```\n-    fn pop(&mut self) -> Option<T>;\n-}\n-\n-/// A double-ended sequence that allows querying, insertion and deletion at both\n-/// ends.\n-///\n-/// # Example\n-///\n-/// With a `Deque` we can simulate a queue efficiently:\n-///\n-/// ```\n-/// use std::collections::{RingBuf, Deque};\n-///\n-/// let mut queue = RingBuf::new();\n-/// queue.push(1i);\n-/// queue.push(2i);\n-/// queue.push(3i);\n-///\n-/// // Will print 1, 2, 3\n-/// while !queue.is_empty() {\n-///     let x = queue.pop_front().unwrap();\n-///     println!(\"{}\", x);\n-/// }\n-/// ```\n-///\n-/// We can also simulate a stack:\n-///\n-/// ```\n-/// use std::collections::{RingBuf, Deque};\n-///\n-/// let mut stack = RingBuf::new();\n-/// stack.push_front(1i);\n-/// stack.push_front(2i);\n-/// stack.push_front(3i);\n-///\n-/// // Will print 3, 2, 1\n-/// while !stack.is_empty() {\n-///     let x = stack.pop_front().unwrap();\n-///     println!(\"{}\", x);\n-/// }\n-/// ```\n-///\n-/// And of course we can mix and match:\n-///\n-/// ```\n-/// use std::collections::{DList, Deque};\n-///\n-/// let mut deque = DList::new();\n-///\n-/// // Init deque with 1, 2, 3, 4\n-/// deque.push_front(2i);\n-/// deque.push_front(1i);\n-/// deque.push(3i);\n-/// deque.push(4i);\n-///\n-/// // Will print (1, 4) and (2, 3)\n-/// while !deque.is_empty() {\n-///     let f = deque.pop_front().unwrap();\n-///     let b = deque.pop().unwrap();\n-///     println!(\"{}\", (f, b));\n-/// }\n-/// ```\n-pub trait Deque<T> : MutableSeq<T> {\n-    /// Provides a reference to the front element, or `None` if the sequence is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{RingBuf, Deque};\n-    ///\n-    /// let mut d = RingBuf::new();\n-    /// assert_eq!(d.front(), None);\n-    ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n-    /// assert_eq!(d.front(), Some(&1i));\n-    /// ```\n-    fn front<'a>(&'a self) -> Option<&'a T>;\n-\n-    /// Provides a mutable reference to the front element, or `None` if the\n-    /// sequence is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{RingBuf, Deque};\n-    ///\n-    /// let mut d = RingBuf::new();\n-    /// assert_eq!(d.front_mut(), None);\n-    ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n-    /// match d.front_mut() {\n-    ///     Some(x) => *x = 9i,\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(d.front(), Some(&9i));\n-    /// ```\n-    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-\n-    /// Provides a reference to the back element, or `None` if the sequence is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{DList, Deque};\n-    ///\n-    /// let mut d = DList::new();\n-    /// assert_eq!(d.back(), None);\n-    ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n-    /// assert_eq!(d.back(), Some(&2i));\n-    /// ```\n-    fn back<'a>(&'a self) -> Option<&'a T>;\n-\n-    /// Provides a mutable reference to the back element, or `None` if the\n-    /// sequence is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{DList, Deque};\n-    ///\n-    /// let mut d = DList::new();\n-    /// assert_eq!(d.back(), None);\n-    ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n-    /// match d.back_mut() {\n-    ///     Some(x) => *x = 9i,\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(d.back(), Some(&9i));\n-    /// ```\n-    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-\n-    /// Inserts an element first in the sequence.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{DList, Deque};\n-    ///\n-    /// let mut d = DList::new();\n-    /// d.push_front(1i);\n-    /// d.push_front(2i);\n-    /// assert_eq!(d.front(), Some(&2i));\n-    /// ```\n-    fn push_front(&mut self, elt: T);\n-\n-    /// Removes the first element and returns it, or `None` if the sequence is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::{RingBuf, Deque};\n-    ///\n-    /// let mut d = RingBuf::new();\n-    /// d.push(1i);\n-    /// d.push(2i);\n-    ///\n-    /// assert_eq!(d.pop_front(), Some(1i));\n-    /// assert_eq!(d.pop_front(), Some(2i));\n-    /// assert_eq!(d.pop_front(), None);\n-    /// ```\n-    fn pop_front(&mut self) -> Option<T>;\n-}\n+#[cfg(test)] mod bench;\n \n // FIXME(#14344) this shouldn't be necessary\n #[doc(hidden)]\n@@ -532,8 +79,4 @@ mod std {\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n     pub use hash;           // deriving(Hash)\n-\n-    pub mod collections {\n-        pub use MutableSeq;\n-    }\n }"}, {"sha": "885b5c99c450108ba28173c70f7199bf05440840", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -159,7 +159,6 @@ use core::default::Default;\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n-use {Mutable, MutableSeq};\n use slice;\n use vec::Vec;\n \n@@ -171,16 +170,6 @@ pub struct PriorityQueue<T> {\n     data: Vec<T>,\n }\n \n-impl<T: Ord> Collection for PriorityQueue<T> {\n-    /// Returns the length of the queue.\n-    fn len(&self) -> uint { self.data.len() }\n-}\n-\n-impl<T: Ord> Mutable for PriorityQueue<T> {\n-    /// Drops all items from the queue.\n-    fn clear(&mut self) { self.data.truncate(0) }\n-}\n-\n impl<T: Ord> Default for PriorityQueue<T> {\n     #[inline]\n     fn default() -> PriorityQueue<T> { PriorityQueue::new() }\n@@ -504,6 +493,15 @@ impl<T: Ord> PriorityQueue<T> {\n         let len = self.len();\n         self.siftdown_range(pos, len);\n     }\n+\n+    /// Returns the length of the queue.\n+    pub fn len(&self) -> uint { self.data.len() }\n+\n+    /// Returns true if the queue contains no elements\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Drops all items from the queue.\n+    pub fn clear(&mut self) { self.data.truncate(0) }\n }\n \n /// `PriorityQueue` iterator.\n@@ -545,7 +543,6 @@ mod tests {\n \n     use priority_queue::PriorityQueue;\n     use vec::Vec;\n-    use MutableSeq;\n \n     #[test]\n     fn test_iterator() {"}, {"sha": "3c4c3fce61d774835fb0b482c1763ca4fe6b9699", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 227, "deletions": 85, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -22,7 +22,6 @@ use core::iter;\n use core::slice;\n use std::hash::{Writer, Hash};\n \n-use {Deque, Mutable, MutableSeq};\n use vec::Vec;\n \n static INITIAL_CAPACITY: uint = 8u; // 2^3\n@@ -36,86 +35,6 @@ pub struct RingBuf<T> {\n     elts: Vec<Option<T>>\n }\n \n-impl<T> Collection for RingBuf<T> {\n-    /// Returns the number of elements in the `RingBuf`.\n-    fn len(&self) -> uint { self.nelts }\n-}\n-\n-impl<T> Mutable for RingBuf<T> {\n-    /// Clears the `RingBuf`, removing all values.\n-    fn clear(&mut self) {\n-        for x in self.elts.iter_mut() { *x = None }\n-        self.nelts = 0;\n-        self.lo = 0;\n-    }\n-}\n-\n-impl<T> Deque<T> for RingBuf<T> {\n-    /// Returns a reference to the first element in the `RingBuf`.\n-    fn front<'a>(&'a self) -> Option<&'a T> {\n-        if self.nelts > 0 { Some(&self[0]) } else { None }\n-    }\n-\n-    /// Returns a mutable reference to the first element in the `RingBuf`.\n-    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n-    }\n-\n-    /// Returns a reference to the last element in the `RingBuf`.\n-    fn back<'a>(&'a self) -> Option<&'a T> {\n-        if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n-    }\n-\n-    /// Returns a mutable reference to the last element in the `RingBuf`.\n-    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        let nelts = self.nelts;\n-        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n-    }\n-\n-    /// Removes and returns the first element in the `RingBuf`, or `None` if it\n-    /// is empty.\n-    fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts[self.lo].take();\n-        if result.is_some() {\n-            self.lo = (self.lo + 1u) % self.elts.len();\n-            self.nelts -= 1u;\n-        }\n-        result\n-    }\n-\n-    /// Prepends an element to the `RingBuf`.\n-    fn push_front(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n-        }\n-        if self.lo == 0u {\n-            self.lo = self.elts.len() - 1u;\n-        } else { self.lo -= 1u; }\n-        self.elts[self.lo] = Some(t);\n-        self.nelts += 1u;\n-    }\n-}\n-\n-impl<T> MutableSeq<T> for RingBuf<T> {\n-    fn push(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n-        }\n-        let hi = self.raw_index(self.nelts);\n-        self.elts[hi] = Some(t);\n-        self.nelts += 1u;\n-    }\n-    fn pop(&mut self) -> Option<T> {\n-        if self.nelts > 0 {\n-            self.nelts -= 1;\n-            let hi = self.raw_index(self.nelts);\n-            self.elts[hi].take()\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n@@ -151,7 +70,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[deprecated = \"use indexing instead: `buf[index] = value`\"]\n-    pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n+    pub fn get_mut(&mut self, i: uint) -> &mut T {\n         &mut self[i]\n     }\n \n@@ -219,7 +138,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+    pub fn iter(&self) -> Items<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n@@ -240,7 +159,7 @@ impl<T> RingBuf<T> {\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+    pub fn iter_mut(&mut self) -> MutItems<T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n         let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n \n@@ -268,6 +187,230 @@ impl<T> RingBuf<T> {\n             }\n         }\n     }\n+\n+    /// Returns the number of elements in the `RingBuf`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.push(1i);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.nelts }\n+\n+    /// Returns true if the buffer contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// assert!(v.is_empty());\n+    /// v.push_front(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the buffer, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// v.push(1i);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) {\n+        for x in self.elts.iter_mut() { *x = None }\n+        self.nelts = 0;\n+        self.lo = 0;\n+    }\n+\n+    /// Provides a reference to the front element, or `None` if the sequence is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.front(), None);\n+    ///\n+    /// d.push(1i);\n+    /// d.push(2i);\n+    /// assert_eq!(d.front(), Some(&1i));\n+    /// ```\n+    pub fn front(&self) -> Option<&T> {\n+        if self.nelts > 0 { Some(&self[0]) } else { None }\n+    }\n+\n+    /// Provides a mutable reference to the front element, or `None` if the\n+    /// sequence is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.front_mut(), None);\n+    ///\n+    /// d.push(1i);\n+    /// d.push(2i);\n+    /// match d.front_mut() {\n+    ///     Some(x) => *x = 9i,\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(d.front(), Some(&9i));\n+    /// ```\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n+        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n+    }\n+\n+    /// Provides a reference to the back element, or `None` if the sequence is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.back(), None);\n+    ///\n+    /// d.push(1i);\n+    /// d.push(2i);\n+    /// assert_eq!(d.back(), Some(&2i));\n+    /// ```\n+    pub fn back(&self) -> Option<&T> {\n+        if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n+    }\n+\n+    /// Provides a mutable reference to the back element, or `None` if the\n+    /// sequence is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.back(), None);\n+    ///\n+    /// d.push(1i);\n+    /// d.push(2i);\n+    /// match d.back_mut() {\n+    ///     Some(x) => *x = 9i,\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(d.back(), Some(&9i));\n+    /// ```\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n+        let nelts = self.nelts;\n+        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n+    }\n+\n+    /// Removes the first element and returns it, or `None` if the sequence is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// d.push(1i);\n+    /// d.push(2i);\n+    ///\n+    /// assert_eq!(d.pop_front(), Some(1i));\n+    /// assert_eq!(d.pop_front(), Some(2i));\n+    /// assert_eq!(d.pop_front(), None);\n+    /// ```\n+    pub fn pop_front(&mut self) -> Option<T> {\n+        let result = self.elts[self.lo].take();\n+        if result.is_some() {\n+            self.lo = (self.lo + 1u) % self.elts.len();\n+            self.nelts -= 1u;\n+        }\n+        result\n+    }\n+\n+    /// Inserts an element first in the sequence.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// d.push_front(1i);\n+    /// d.push_front(2i);\n+    /// assert_eq!(d.front(), Some(&2i));\n+    /// ```\n+    pub fn push_front(&mut self, t: T) {\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        }\n+        if self.lo == 0u {\n+            self.lo = self.elts.len() - 1u;\n+        } else { self.lo -= 1u; }\n+        self.elts[self.lo] = Some(t);\n+        self.nelts += 1u;\n+    }\n+\n+    /// Appends an element to the back of a buffer\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push(1i);\n+    /// buf.push(3);\n+    /// assert_eq!(3, *buf.back().unwrap());\n+    /// ```\n+    pub fn push(&mut self, t: T) {\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        }\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi] = Some(t);\n+        self.nelts += 1u;\n+    }\n+\n+    /// Removes the last element from a buffer and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// assert_eq!(buf.pop(), None);\n+    /// buf.push(1i);\n+    /// buf.push(3);\n+    /// assert_eq!(buf.pop(), Some(3));\n+    /// ```\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.nelts > 0 {\n+            self.nelts -= 1;\n+            let hi = self.raw_index(self.nelts);\n+            self.elts[hi].take()\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// `RingBuf` iterator.\n@@ -513,7 +656,6 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use {Deque, Mutable, MutableSeq};\n     use super::RingBuf;\n     use vec::Vec;\n "}, {"sha": "107dc3e5c28b72330045d79cb31ca735d285a89c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -92,12 +92,11 @@ use core::cmp;\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::prelude::{Clone, Collection, Greater, Iterator, Less, None, Option};\n+use core::prelude::{Clone, Greater, Iterator, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n use core::iter::{range_step, MultiplicativeIterator};\n \n-use MutableSeq;\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, ImmutableSlice, ImmutablePartialEqSlice};\n@@ -762,7 +761,6 @@ mod tests {\n     use std::rt;\n     use slice::*;\n \n-    use {Mutable, MutableSeq};\n     use vec::Vec;\n \n     fn square(n: uint) -> uint { n * n }\n@@ -2175,7 +2173,6 @@ mod bench {\n     use test::Bencher;\n \n     use vec::Vec;\n-    use MutableSeq;\n \n     #[bench]\n     fn iterator(b: &mut Bencher) {"}, {"sha": "b2e018743da7d54897728afdc0adb07bc79e3260", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 223, "deletions": 96, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -21,7 +21,6 @@ use core::iter;\n use core::iter::{Enumerate, FilterMap};\n use core::mem::replace;\n \n-use {Mutable, Map, MutableMap, MutableSeq};\n use {vec, slice};\n use vec::Vec;\n use hash;\n@@ -65,90 +64,6 @@ pub struct SmallIntMap<T> {\n     v: Vec<Option<T>>,\n }\n \n-impl<V> Collection for SmallIntMap<V> {\n-    /// Returns the number of elements in the map.\n-    fn len(&self) -> uint {\n-        self.v.iter().filter(|elt| elt.is_some()).count()\n-    }\n-\n-    /// Returns`true` if there are no elements in the map.\n-    fn is_empty(&self) -> bool {\n-        self.v.iter().all(|elt| elt.is_none())\n-    }\n-}\n-\n-impl<V> Mutable for SmallIntMap<V> {\n-    /// Clears the map, removing all key-value pairs.\n-    fn clear(&mut self) { self.v.clear() }\n-}\n-\n-impl<V> Map<uint, V> for SmallIntMap<V> {\n-    /// Returns a reference to the value corresponding to the key.\n-    fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n-        if *key < self.v.len() {\n-            match *self.v.index_mut(key) {\n-              Some(ref mut value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    fn insert(&mut self, key: uint, value: V) -> bool {\n-        let exists = self.contains_key(&key);\n-        let len = self.v.len();\n-        if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n-        }\n-        self.v[key] = Some(value);\n-        !exists\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    fn remove(&mut self, key: &uint) -> bool {\n-        self.pop(key).is_some()\n-    }\n-\n-    /// Inserts a key-value pair into the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise `None` is returned.\n-    fn swap(&mut self, key: uint, value: V) -> Option<V> {\n-        match self.find_mut(&key) {\n-            Some(loc) => { return Some(replace(loc, value)); }\n-            None => ()\n-        }\n-        self.insert(key, value);\n-        return None;\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    fn pop(&mut self, key: &uint) -> Option<V> {\n-        if *key >= self.v.len() {\n-            return None;\n-        }\n-        self.v[*key].take()\n-    }\n-}\n-\n impl<V> Default for SmallIntMap<V> {\n     #[inline]\n     fn default() -> SmallIntMap<V> { SmallIntMap::new() }\n@@ -295,6 +210,204 @@ impl<V> SmallIntMap<V> {\n             v.map(|v| (i, v))\n         })\n     }\n+\n+    /// Return the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut a = SmallIntMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint {\n+        self.v.iter().filter(|elt| elt.is_some()).count()\n+    }\n+\n+    /// Return true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut a = SmallIntMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        self.v.iter().all(|elt| elt.is_none())\n+    }\n+\n+    /// Clears the map, removing all key-value pairs.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut a = SmallIntMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) { self.v.clear() }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.find(&1), Some(&\"a\"));\n+    /// assert_eq!(map.find(&2), None);\n+    /// ```\n+    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// match map.find_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n+    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n+        if *key < self.v.len() {\n+            match *(&mut self.v[*key]) {\n+              Some(ref mut value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n+    /// not already exist in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// assert_eq!(map.insert(2, \"value\"), true);\n+    /// assert_eq!(map.insert(2, \"value2\"), false);\n+    /// assert_eq!(map[2], \"value2\");\n+    /// ```\n+    pub fn insert(&mut self, key: uint, value: V) -> bool {\n+        let exists = self.contains_key(&key);\n+        let len = self.v.len();\n+        if len <= key {\n+            self.v.grow_fn(key - len + 1, |_| None);\n+        }\n+        self.v[key] = Some(value);\n+        !exists\n+    }\n+\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// assert_eq!(map.remove(&1), false);\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), true);\n+    /// ```\n+    pub fn remove(&mut self, key: &uint) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n+        match self.find_mut(&key) {\n+            Some(loc) => { return Some(replace(loc, value)); }\n+            None => ()\n+        }\n+        self.insert(key, value);\n+        return None;\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.pop(&1), Some(\"a\"));\n+    /// assert_eq!(map.pop(&1), None);\n+    /// ```\n+    pub fn pop(&mut self, key: &uint) -> Option<V> {\n+        if *key >= self.v.len() {\n+            return None;\n+        }\n+        self.v[*key].take()\n+    }\n }\n \n impl<V:Clone> SmallIntMap<V> {\n@@ -499,7 +612,6 @@ mod test_map {\n     use vec::Vec;\n     use hash;\n \n-    use {Map, MutableMap, Mutable, MutableSeq};\n     use super::SmallIntMap;\n \n     #[test]\n@@ -869,57 +981,72 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use super::SmallIntMap;\n-    use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n+    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n-    // Find seq\n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        insert_rand_n(100, &mut m, b);\n+        insert_rand_n(100, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        insert_rand_n(10_000, &mut m, b);\n+        insert_rand_n(10_000, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        insert_seq_n(100, &mut m, b);\n+        insert_seq_n(100, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        insert_seq_n(10_000, &mut m, b);\n+        insert_seq_n(10_000, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        find_rand_n(100, &mut m, b);\n+        find_rand_n(100, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        find_rand_n(10_000, &mut m, b);\n+        find_rand_n(10_000, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        find_seq_n(100, &mut m, b);\n+        find_seq_n(100, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : SmallIntMap<uint> = SmallIntMap::new();\n-        find_seq_n(10_000, &mut m, b);\n+        find_seq_n(10_000, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n }"}, {"sha": "297ba71d252d7cf1c99769a21da6639b20d004bd", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -59,12 +59,11 @@ use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n use core::kinds::Sized;\n-use core::prelude::{Char, Clone, Collection, Eq, Equiv, ImmutableSlice};\n+use core::prelude::{Char, Clone, Eq, Equiv, ImmutableSlice};\n use core::prelude::{Iterator, MutableSlice, None, Option, Ord, Ordering};\n use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n use core::prelude::{range};\n \n-use {Deque, MutableSeq};\n use hash;\n use ringbuf::RingBuf;\n use string::String;\n@@ -464,6 +463,14 @@ impl<'a> MaybeOwned<'a> {\n             Owned(_) => false\n         }\n     }\n+\n+    /// Return the number of bytes in this string.\n+    #[inline]\n+    pub fn len(&self) -> uint { self.as_slice().len() }\n+\n+    /// Returns true if the string contains no bytes\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n /// Trait for moving into a `MaybeOwned`.\n@@ -561,11 +568,6 @@ impl<'a> StrAllocating for MaybeOwned<'a> {\n     }\n }\n \n-impl<'a> Collection for MaybeOwned<'a> {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n impl<'a> Clone for MaybeOwned<'a> {\n     #[inline]\n     fn clone(&self) -> MaybeOwned<'a> {\n@@ -782,7 +784,6 @@ mod tests {\n     use std::option::{Some, None};\n     use std::ptr::RawPtr;\n     use std::iter::{Iterator, DoubleEndedIterator};\n-    use {Collection, MutableSeq};\n \n     use super::*;\n     use std::slice::{AsSlice, ImmutableSlice};\n@@ -2142,14 +2143,16 @@ mod tests {\n \n     #[test]\n     fn test_str_container() {\n-        fn sum_len<S: Collection>(v: &[S]) -> uint {\n+        fn sum_len(v: &[&str]) -> uint {\n             v.iter().map(|x| x.len()).sum()\n         }\n \n         let s = String::from_str(\"01234\");\n         assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([String::from_str(\"01\"), String::from_str(\"2\"),\n-                               String::from_str(\"34\"), String::from_str(\"\")]));\n+        assert_eq!(5, sum_len([String::from_str(\"01\").as_slice(),\n+                               String::from_str(\"2\").as_slice(),\n+                               String::from_str(\"34\").as_slice(),\n+                               String::from_str(\"\").as_slice()]));\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n \n@@ -2232,7 +2235,8 @@ mod bench {\n     use test::black_box;\n     use super::*;\n     use std::iter::{Iterator, DoubleEndedIterator};\n-    use std::collections::Collection;\n+    use std::str::StrSlice;\n+    use std::slice::ImmutableSlice;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {"}, {"sha": "b3c83ba55598b419041464b2fdbc962f547d285d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -22,7 +22,6 @@ use core::ops;\n // FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait\n use core::raw::Slice as RawSlice;\n \n-use {Mutable, MutableSeq};\n use hash;\n use slice::CloneableVector;\n use str;\n@@ -626,22 +625,43 @@ impl String {\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n-}\n \n-#[experimental = \"collection traits will probably be removed\"]\n-impl Collection for String {\n+    /// Return the number of bytes in this string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = \"foo\".to_string();\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n     #[inline]\n     #[stable]\n-    fn len(&self) -> uint {\n-        self.vec.len()\n-    }\n-}\n+    pub fn len(&self) -> uint { self.vec.len() }\n \n-#[experimental = \"collection traits will probably be removed\"]\n-impl Mutable for String {\n+    /// Returns true if the string contains no bytes\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut v = String::new();\n+    /// assert!(v.is_empty());\n+    /// v.push('a');\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Truncates the string, returning it to 0 length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut s = \"foo\".to_string();\n+    /// s.clear();\n+    /// assert!(s.is_empty());\n+    /// ```\n     #[inline]\n     #[stable]\n-    fn clear(&mut self) {\n+    pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n }\n@@ -830,7 +850,6 @@ mod tests {\n     use std::prelude::*;\n     use test::Bencher;\n \n-    use {Mutable, MutableSeq};\n     use str;\n     use str::{Str, StrSlice, Owned};\n     use super::{as_string, String};"}, {"sha": "7e6efcb3d1266485c205686786f227244e9a3f31", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 381, "deletions": 106, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -44,7 +44,6 @@ use core::mem::{replace, swap};\n use core::ptr;\n use std::hash::{Writer, Hash};\n \n-use {Mutable, Set, MutableSet, MutableMap, Map, MutableSeq};\n use vec::Vec;\n \n /// This is implemented as an AA tree, which is a simplified variation of\n@@ -206,45 +205,6 @@ impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V> Collection for TreeMap<K, V> {\n-    fn len(&self) -> uint { self.length }\n-}\n-\n-impl<K: Ord, V> Mutable for TreeMap<K, V> {\n-    fn clear(&mut self) {\n-        self.root = None;\n-        self.length = 0\n-    }\n-}\n-\n-impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n-    // See comments on tree_find_with\n-    #[inline]\n-    fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n-        tree_find_with(&self.root, |k2| key.cmp(k2))\n-    }\n-}\n-\n-impl<K: Ord, V> MutableMap<K, V> for TreeMap<K, V> {\n-    // See comments on tree_find_with_mut\n-    #[inline]\n-    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n-        tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n-    }\n-\n-    fn swap(&mut self, key: K, value: V) -> Option<V> {\n-        let ret = insert(&mut self.root, key, value);\n-        if ret.is_none() { self.length += 1 }\n-        ret\n-    }\n-\n-    fn pop(&mut self, key: &K) -> Option<V> {\n-        let ret = remove(&mut self.root, key);\n-        if ret.is_some() { self.length -= 1 }\n-        ret\n-    }\n-}\n-\n impl<K: Ord, V> Default for TreeMap<K,V> {\n     #[inline]\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n@@ -444,6 +404,184 @@ impl<K: Ord, V> TreeMap<K, V> {\n             remaining: length\n         }\n     }\n+\n+    /// Return the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut a = TreeMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1u, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut a = TreeMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1u, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the map, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut a = TreeMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) {\n+        self.root = None;\n+        self.length = 0\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.find(&1), Some(&\"a\"));\n+    /// assert_eq!(map.find(&2), None);\n+    /// ```\n+    #[inline]\n+    pub fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n+        tree_find_with(&self.root, |k2| key.cmp(k2))\n+    }\n+\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// match map.find_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n+    #[inline]\n+    pub fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n+        tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n+    }\n+\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n+    /// not already exist in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// assert_eq!(map.insert(2u, \"value\"), true);\n+    /// assert_eq!(map.insert(2, \"value2\"), false);\n+    /// assert_eq!(map[2], \"value2\");\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, key: K, value: V) -> bool {\n+        self.swap(key, value).is_none()\n+    }\n+\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// assert_eq!(map.remove(&1u), false);\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), true);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, key: &K) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        let ret = insert(&mut self.root, key, value);\n+        if ret.is_none() { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.pop(&1), Some(\"a\"));\n+    /// assert_eq!(map.pop(&1), None);\n+    /// ```\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n+        let ret = remove(&mut self.root, key);\n+        if ret.is_some() { self.length -= 1 }\n+        ret\n+    }\n }\n \n impl<K, V> TreeMap<K, V> {\n@@ -1062,59 +1200,6 @@ impl<T: Ord + Show> Show for TreeSet<T> {\n     }\n }\n \n-impl<T: Ord> Collection for TreeSet<T> {\n-    #[inline]\n-    fn len(&self) -> uint { self.map.len() }\n-}\n-\n-impl<T: Ord> Mutable for TreeSet<T> {\n-    #[inline]\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl<T: Ord> Set<T> for TreeSet<T> {\n-    #[inline]\n-    fn contains(&self, value: &T) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        self.intersection(other).next().is_none()\n-    }\n-\n-    fn is_subset(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n-\n-            b = y.next();\n-        }\n-        true\n-    }\n-}\n-\n-impl<T: Ord> MutableSet<T> for TreeSet<T> {\n-    #[inline]\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    #[inline]\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n impl<T: Ord> Default for TreeSet<T> {\n     #[inline]\n     fn default() -> TreeSet<T> { TreeSet::new() }\n@@ -1320,6 +1405,184 @@ impl<T: Ord> TreeSet<T> {\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1i);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// v.insert(1i);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &T) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+        self.intersection(other).next().is_none()\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+        let mut a = x.next();\n+        let mut b = y.next();\n+        while a.is_some() {\n+            if b.is_none() {\n+                return false;\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            match b1.cmp(a1) {\n+                Less => (),\n+                Greater => return false,\n+                Equal => a = x.next(),\n+            }\n+\n+            b = y.next();\n+        }\n+        true\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2i), true);\n+    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(2i);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n /// A lazy forward iterator over a set.\n@@ -1676,7 +1939,6 @@ mod test_treemap {\n     use std::rand::Rng;\n     use std::rand;\n \n-    use {Map, MutableMap, Mutable, MutableSeq};\n     use super::{TreeMap, TreeNode};\n \n     #[test]\n@@ -2195,59 +2457,73 @@ mod bench {\n     use test::{Bencher, black_box};\n \n     use super::TreeMap;\n-    use MutableMap;\n-    use deque::bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n+    use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n-    // Find seq\n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_rand_n(100, &mut m, b);\n+        insert_rand_n(100, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_rand_n(10_000, &mut m, b);\n+        insert_rand_n(10_000, &mut m, b,\n+                      |m, i| { m.insert(i, 1); },\n+                      |m, i| { m.remove(&i); });\n     }\n \n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_seq_n(100, &mut m, b);\n+        insert_seq_n(100, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        insert_seq_n(10_000, &mut m, b);\n+        insert_seq_n(10_000, &mut m, b,\n+                     |m, i| { m.insert(i, 1); },\n+                     |m, i| { m.remove(&i); });\n     }\n \n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_rand_n(100, &mut m, b);\n+        find_rand_n(100, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_rand_n(10_000, &mut m, b);\n+        find_rand_n(10_000, &mut m, b,\n+                    |m, i| { m.insert(i, 1); },\n+                    |m, i| { m.find(&i); });\n     }\n \n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_seq_n(100, &mut m, b);\n+        find_seq_n(100, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n-        find_seq_n(10_000, &mut m, b);\n+        find_seq_n(10_000, &mut m, b,\n+                   |m, i| { m.insert(i, 1); },\n+                   |m, i| { m.find(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n@@ -2286,7 +2562,6 @@ mod test_set {\n     use std::prelude::*;\n     use std::hash;\n \n-    use {Set, MutableSet, Mutable, MutableMap, MutableSeq};\n     use super::{TreeMap, TreeSet};\n \n     #[test]"}, {"sha": "7a8cc5df55a278a88359db1a11dded11e2e83789", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 364, "deletions": 116, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -29,7 +29,6 @@ use core::uint;\n use core::iter;\n use std::hash::{Writer, Hash};\n \n-use {Mutable, Map, MutableMap, Set, MutableSet};\n use slice::{Items, MutItems};\n use slice;\n \n@@ -126,72 +125,6 @@ impl<T: Show> Show for TrieMap<T> {\n     }\n }\n \n-impl<T> Collection for TrieMap<T> {\n-    /// Returns the number of elements in the map.\n-    #[inline]\n-    fn len(&self) -> uint { self.length }\n-}\n-\n-impl<T> Mutable for TrieMap<T> {\n-    /// Clears the map, removing all values.\n-    #[inline]\n-    fn clear(&mut self) {\n-        self.root = TrieNode::new();\n-        self.length = 0;\n-    }\n-}\n-\n-impl<T> Map<uint, T> for TrieMap<T> {\n-    /// Returns a reference to the value corresponding to the key.\n-    #[inline]\n-    fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n-        let mut node: &'a TrieNode<T> = &self.root;\n-        let mut idx = 0;\n-        loop {\n-            match node.children[chunk(*key, idx)] {\n-              Internal(ref x) => node = &**x,\n-              External(stored, ref value) => {\n-                if stored == *key {\n-                    return Some(value)\n-                } else {\n-                    return None\n-                }\n-              }\n-              Nothing => return None\n-            }\n-            idx += 1;\n-        }\n-    }\n-}\n-\n-impl<T> MutableMap<uint, T> for TrieMap<T> {\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    #[inline]\n-    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n-        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n-    }\n-\n-    /// Inserts a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    fn swap(&mut self, key: uint, value: T) -> Option<T> {\n-        let ret = insert(&mut self.root.count,\n-                         &mut self.root.children[chunk(key, 0)],\n-                         key, value, 1);\n-        if ret.is_none() { self.length += 1 }\n-        ret\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    fn pop(&mut self, key: &uint) -> Option<T> {\n-        let ret = remove(&mut self.root.count,\n-                         &mut self.root.children[chunk(*key, 0)],\n-                         *key, 1);\n-        if ret.is_some() { self.length -= 1 }\n-        ret\n-    }\n-}\n-\n impl<T> Default for TrieMap<T> {\n     #[inline]\n     fn default() -> TrieMap<T> { TrieMap::new() }\n@@ -294,6 +227,205 @@ impl<T> TrieMap<T> {\n \n         iter\n     }\n+\n+    /// Return the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut a = TrieMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut a = TrieMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the map, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut a = TrieMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.root = TrieNode::new();\n+        self.length = 0;\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.find(&1), Some(&\"a\"));\n+    /// assert_eq!(map.find(&2), None);\n+    /// ```\n+    #[inline]\n+    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n+        let mut node: &'a TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        loop {\n+            match node.children[chunk(*key, idx)] {\n+              Internal(ref x) => node = &**x,\n+              External(stored, ref value) => {\n+                if stored == *key {\n+                    return Some(value)\n+                } else {\n+                    return None\n+                }\n+              }\n+              Nothing => return None\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// map.insert(1, \"a\");\n+    /// match map.find_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n+    #[inline]\n+    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n+        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n+    }\n+\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n+    /// not already exist in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// assert_eq!(map.insert(2, \"value\"), true);\n+    /// assert_eq!(map.insert(2, \"value2\"), false);\n+    /// assert_eq!(map[2], \"value2\");\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, key: uint, value: T) -> bool {\n+        self.swap(key, value).is_none()\n+    }\n+\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// assert_eq!(map.remove(&1), false);\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), true);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, key: &uint) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+        let ret = insert(&mut self.root.count,\n+                         &mut self.root.children[chunk(key, 0)],\n+                         key, value, 1);\n+        if ret.is_none() { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    ///\n+    /// let mut map = TrieMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.pop(&1), Some(\"a\"));\n+    /// assert_eq!(map.pop(&1), None);\n+    /// ```\n+    pub fn pop(&mut self, key: &uint) -> Option<T> {\n+        let ret = remove(&mut self.root.count,\n+                         &mut self.root.children[chunk(*key, 0)],\n+                         *key, 1);\n+        if ret.is_some() { self.length -= 1 }\n+        ret\n+    }\n }\n \n // FIXME #5846 we want to be able to choose between &x and &mut x\n@@ -569,52 +701,6 @@ impl Show for TrieSet {\n     }\n }\n \n-impl Collection for TrieSet {\n-    /// Returns the number of elements in the set.\n-    #[inline]\n-    fn len(&self) -> uint { self.map.len() }\n-}\n-\n-impl Mutable for TrieSet {\n-    /// Clears the set, removing all values.\n-    #[inline]\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl Set<uint> for TrieSet {\n-    #[inline]\n-    fn contains(&self, value: &uint) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    #[inline]\n-    fn is_disjoint(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| !other.contains(&v))\n-    }\n-\n-    #[inline]\n-    fn is_subset(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| other.contains(&v))\n-    }\n-\n-    #[inline]\n-    fn is_superset(&self, other: &TrieSet) -> bool {\n-        other.is_subset(self)\n-    }\n-}\n-\n-impl MutableSet<uint> for TrieSet {\n-    #[inline]\n-    fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ())\n-    }\n-\n-    #[inline]\n-    fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value)\n-    }\n-}\n-\n impl Default for TrieSet {\n     #[inline]\n     fn default() -> TrieSet { TrieSet::new() }\n@@ -714,6 +800,171 @@ impl TrieSet {\n     pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n         SetItems{iter: self.map.upper_bound(val)}\n     }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &uint) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| !other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_subset(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    #[inline]\n+    pub fn is_superset(&self, other: &TrieSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: uint) -> bool {\n+        self.map.insert(value, ())\n+    }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &uint) -> bool {\n+        self.map.remove(value)\n+    }\n }\n \n impl FromIterator<uint> for TrieSet {\n@@ -1026,7 +1277,6 @@ mod test_map {\n     use std::uint;\n     use std::hash;\n \n-    use {MutableMap, Map, MutableSeq};\n     use super::{TrieMap, TrieNode, Internal, External, Nothing};\n \n     fn check_integrity<T>(trie: &TrieNode<T>) {\n@@ -1442,7 +1692,6 @@ mod bench_map {\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n \n-    use MutableMap;\n     use super::TrieMap;\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n@@ -1559,7 +1808,6 @@ mod test_set {\n     use std::prelude::*;\n     use std::uint;\n \n-    use {MutableSet, Set, MutableSeq};\n     use super::TrieSet;\n \n     #[test]"}, {"sha": "d7ec3836eb26477fb9c37472c7a463d1ca2ef97b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 96, "deletions": 71, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -27,7 +27,6 @@ use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use {Mutable, MutableSeq};\n use slice::{CloneableVector};\n \n /// An owned, growable vector.\n@@ -530,15 +529,6 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Collection stability\"]\n-impl<T> Collection for Vec<T> {\n-    #[inline]\n-    #[stable]\n-    fn len(&self) -> uint {\n-        self.len\n-    }\n-}\n-\n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n@@ -969,15 +959,107 @@ impl<T> Vec<T> {\n             self.push(f(i));\n         }\n     }\n-}\n \n-#[experimental = \"waiting on Mutable stability\"]\n-impl<T> Mutable for Vec<T> {\n+    /// Appends an element to the back of a collection.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the number of elements in the vector overflows a `uint`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1i, 2);\n+    /// vec.push(3);\n+    /// assert_eq!(vec, vec!(1, 2, 3));\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    pub fn push(&mut self, value: T) {\n+        if mem::size_of::<T>() == 0 {\n+            // zero-size types consume no memory, so we can't rely on the address space running out\n+            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n+            unsafe { mem::forget(value); }\n+            return\n+        }\n+        if self.len == self.cap {\n+            let old_size = self.cap * mem::size_of::<T>();\n+            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n+            if old_size > size { panic!(\"capacity overflow\") }\n+            unsafe {\n+                self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n+            }\n+            self.cap = max(self.cap, 2) * 2;\n+        }\n+\n+        unsafe {\n+            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n+            ptr::write(&mut *end, value);\n+            self.len += 1;\n+        }\n+    }\n+\n+    /// Removes the last element from a vector and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec![1i, 2, 3];\n+    /// assert_eq!(vec.pop(), Some(3));\n+    /// assert_eq!(vec, vec![1, 2]);\n+    /// ```\n     #[inline]\n     #[stable]\n-    fn clear(&mut self) {\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            unsafe {\n+                self.len -= 1;\n+                Some(ptr::read(self.as_slice().unsafe_get(self.len())))\n+            }\n+        }\n+    }\n+\n+    /// Clears the vector, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut v = vec![1i, 2, 3];\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    pub fn clear(&mut self) {\n         self.truncate(0)\n     }\n+\n+    /// Return the number of elements in the vector\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = vec![1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    pub fn len(&self) -> uint { self.len }\n+\n+    /// Returns true if the vector contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut v = Vec::new();\n+    /// assert!(v.is_empty());\n+    /// v.push(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1141,61 +1223,6 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on MutableSeq stability\"]\n-impl<T> MutableSeq<T> for Vec<T> {\n-    /// Appends an element to the back of a collection.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the number of elements in the vector overflows a `uint`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n-    /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    fn push(&mut self, value: T) {\n-        if mem::size_of::<T>() == 0 {\n-            // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n-            unsafe { mem::forget(value); }\n-            return\n-        }\n-        if self.len == self.cap {\n-            let old_size = self.cap * mem::size_of::<T>();\n-            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size { panic!(\"capacity overflow\") }\n-            unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n-            }\n-            self.cap = max(self.cap, 2) * 2;\n-        }\n-\n-        unsafe {\n-            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n-            ptr::write(&mut *end, value);\n-            self.len += 1;\n-        }\n-    }\n-\n-    #[inline]\n-    #[stable]\n-    fn pop(&mut self) -> Option<T> {\n-        if self.len == 0 {\n-            None\n-        } else {\n-            unsafe {\n-                self.len -= 1;\n-                Some(ptr::read(self.as_slice().unsafe_get(self.len())))\n-            }\n-        }\n-    }\n-}\n-\n /// An iterator that moves out of a vector.\n pub struct MoveItems<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n@@ -1636,8 +1663,6 @@ mod tests {\n     use test::Bencher;\n     use super::{as_vec, unzip, raw, Vec};\n \n-    use MutableSeq;\n-\n     struct DropCounter<'a> {\n         count: &'a mut int\n     }"}, {"sha": "3b9f8f58a20544f8a6cfdbae2559cb81581131cb", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -18,7 +18,7 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::range_step;\n-use collections::Collection;\n+use slice::ImmutableSlice;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;"}, {"sha": "7d87e03c134102724ea3d2956729bf6b2114314b", "filename": "src/libcore/collections.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0547a407aa03b9f1c03843aead617a2e8c5d1147/src%2Flibcore%2Fcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0547a407aa03b9f1c03843aead617a2e8c5d1147/src%2Flibcore%2Fcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcollections.rs?ref=0547a407aa03b9f1c03843aead617a2e8c5d1147", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Traits for generic collections\n-\n-/// A trait to represent the abstract idea of a container. The only concrete\n-/// knowledge known is the number of elements contained within.\n-pub trait Collection {\n-    /// Return the number of elements in the container\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    fn len(&self) -> uint;\n-\n-    /// Return true if the container contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let s = String::new();\n-    /// assert!(s.is_empty());\n-    /// ```\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}"}, {"sha": "f51d3948757c7d39fbf17eb7290f366907f9fffc", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -11,14 +11,12 @@\n #![allow(missing_docs)]\n \n use char;\n-use collections::Collection;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::MutableSlice;\n-use slice;\n+use slice::{mod, ImmutableSlice, MutableSlice};\n use str::StrSlice;\n \n /// A flag that specifies whether to use exponential (scientific) notation."}, {"sha": "74b39a7058c0a4339eaad92f2eca4c10401651b8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -14,7 +14,6 @@\n \n use any;\n use cell::{Cell, Ref, RefMut};\n-use collections::Collection;\n use iter::{Iterator, range};\n use kinds::{Copy, Sized};\n use mem;"}, {"sha": "190e1ecea592138ced3e505286bb5f2655840a0e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -14,11 +14,10 @@\n \n #![allow(unsigned_negation)]\n \n-use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{MutableSlice};\n+use slice::{ImmutableSlice, MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]"}, {"sha": "7c5c54c6d8abc8ff00bfab59cf7e903cc5b7508f", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -102,7 +102,6 @@ pub mod ops;\n pub mod cmp;\n pub mod clone;\n pub mod default;\n-pub mod collections;\n \n /* Core types and methods on primitives */\n "}, {"sha": "64917fb2541b948f12c5f490f40fcb73a4c1059e", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -50,7 +50,6 @@ pub use char::Char;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n-pub use collections::Collection;\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};"}, {"sha": "317a6e224bce99ba1ae1ceafae35524f2aef6aec", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -36,7 +36,6 @@\n \n use mem::transmute;\n use clone::Clone;\n-use collections::Collection;\n use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Less, Equal, Greater, Equiv};\n use cmp;\n use default::Default;\n@@ -234,6 +233,29 @@ pub trait ImmutableSlice<T> for Sized? {\n     /// ```\n     #[unstable = \"waiting on unboxed closures\"]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n+\n+    /// Return the number of elements in the slice\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[experimental = \"not triaged yet\"]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[experimental = \"not triaged yet\"]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n #[unstable]\n@@ -372,6 +394,9 @@ impl<T> ImmutableSlice<T> for [T] {\n         }\n         return NotFound(base);\n     }\n+\n+    #[inline]\n+    fn len(&self) -> uint { self.repr().len }\n }\n \n \n@@ -886,24 +911,6 @@ impl<'a,T> AsSlice<T> for &'a [T] {\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n \n-#[experimental = \"trait is experimental\"]\n-impl<'a, T> Collection for &'a [T] {\n-    /// Returns the length of a slice.\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<'a, T> Collection for &'a mut [T] {\n-    /// Returns the length of a slice.\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n #[unstable = \"waiting for DST\"]\n impl<'a, T> Default for &'a [T] {\n     fn default() -> &'a [T] { &[] }\n@@ -1508,7 +1515,6 @@ pub mod raw {\n /// Operations on `[u8]`.\n #[experimental = \"needs review\"]\n pub mod bytes {\n-    use collections::Collection;\n     use kinds::Sized;\n     use ptr;\n     use slice::{ImmutableSlice, MutableSlice};"}, {"sha": "dd8c7e9660af78945e5954a12621e2e20254ace9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -22,7 +22,6 @@ use char::Char;\n use clone::Clone;\n use cmp;\n use cmp::{PartialEq, Eq};\n-use collections::Collection;\n use default::Default;\n use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n@@ -1057,7 +1056,6 @@ const TAG_CONT_U8: u8 = 0b1000_0000u8;\n /// Unsafe operations\n pub mod raw {\n     use mem;\n-    use collections::Collection;\n     use ptr::RawPtr;\n     use raw::Slice;\n     use slice::{ImmutableSlice};\n@@ -1121,7 +1119,6 @@ Section: Trait implementations\n #[allow(missing_docs)]\n pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n-    use collections::Collection;\n     use iter::Iterator;\n     use option::{Option, Some};\n     use ops;\n@@ -1199,13 +1196,6 @@ impl<'a> Str for &'a str {\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n }\n \n-impl<'a> Collection for &'a str {\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n /// Methods for string slices\n pub trait StrSlice for Sized? {\n     /// Returns true if one string contains another\n@@ -1827,6 +1817,28 @@ pub trait StrSlice for Sized? {\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     fn utf16_units<'a>(&'a self) -> Utf16CodeUnits<'a>;\n+\n+    /// Return the number of bytes in this string\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"foo\".len(), 3);\n+    /// assert_eq!(\"\u0192oo\".len(), 4);\n+    /// ```\n+    #[experimental = \"not triaged yet\"]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if this slice contains no bytes\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert!(\"\".is_empty());\n+    /// ```\n+    #[inline]\n+    #[experimental = \"not triaged yet\"]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n #[inline(never)]\n@@ -2179,6 +2191,9 @@ impl StrSlice for str {\n     fn utf16_units(&self) -> Utf16CodeUnits {\n         Utf16CodeUnits{ chars: self.chars(), extra: 0}\n     }\n+\n+    #[inline]\n+    fn len(&self) -> uint { self.repr().len }\n }\n \n impl<'a> Default for &'a str {"}, {"sha": "d465d1407513b7af16ab38f00fdbdfa491e3516c", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::Collection;\n use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n@@ -62,6 +61,10 @@ impl<'a,T> MaybeOwnedVector<'a,T> {\n             &Borrowed(ref v) => v.iter(),\n         }\n     }\n+\n+    pub fn len(&self) -> uint { self.as_slice().len() }\n+\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n@@ -145,12 +148,6 @@ impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n     }\n }\n \n-impl<'a, T> Collection for MaybeOwnedVector<'a, T> {\n-    fn len(&self) -> uint {\n-        self.as_slice().len()\n-    }\n-}\n-\n impl<'a> BytesContainer for MaybeOwnedVector<'a, u8> {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_slice()"}, {"sha": "df5bfccd18d63a6c3317cb3efc928bc776ce1561", "filename": "src/libregex/re.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -772,14 +772,14 @@ impl<'t> Captures<'t> {\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n         re.replace_all(text.as_slice(), NoExpand(\"$\"))\n     }\n-}\n \n-impl<'t> Collection for Captures<'t> {\n     /// Returns the number of captured groups.\n     #[inline]\n-    fn len(&self) -> uint {\n-        self.locs.len() / 2\n-    }\n+    pub fn len(&self) -> uint { self.locs.len() / 2 }\n+\n+    /// Returns if there are no captured groups.\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n /// An iterator over capture groups for a particular match of a regular"}, {"sha": "dd88eb3251b63e0af5470cdc0b481915ca22b321", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -108,7 +108,6 @@ pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n \n #[cfg(test)]\n mod test {\n-    use core::collections::Collection;\n     use core::str::StrSlice;\n     use core::slice::{MutableSlice, ImmutableSlice};\n "}, {"sha": "7dbddd3f5df33baaa467b22ea3b7e16475ae4c94", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -45,7 +45,6 @@\n \n #![allow(unsigned_negation)]\n \n-use std::collections::Map;\n use std::num::Int;\n use std::rc::Rc;\n "}, {"sha": "cf807cb22bc2a61443f84ac3f079b0ca66328560", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -184,17 +184,17 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n /// }\n /// ```\n #[inline(always)]\n-pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n-    cache: &RefCell<M>,\n+pub fn memoized<T: Clone + Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n+    cache: &RefCell<HashMap<T, U, H>>,\n     arg: T,\n     f: |T| -> U\n ) -> U {\n     memoized_with_key(cache, arg, f, |arg| arg.clone())\n }\n \n #[inline(always)]\n-pub fn memoized_with_key<T, K, U: Clone, M: MutableMap<K, U>>(\n-    cache: &RefCell<M>,\n+pub fn memoized_with_key<T, K: Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n+    cache: &RefCell<HashMap<K, U, H>>,\n     arg: T,\n     f: |T| -> U,\n     k: |&T| -> K"}, {"sha": "ce27decb136c06a6b55ec873b3824ab2e2e7d36a", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -15,7 +15,6 @@\n use core::prelude::*;\n \n use alloc::boxed::Box;\n-use collections::MutableSeq;\n use collections::vec::Vec;\n use core::atomic;\n use core::mem;"}, {"sha": "6a2e09c3ac6db6c1b561733102cf135b6ceb7820", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -76,7 +76,7 @@ use collections::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;\n-use core::prelude::{Clone, Collection, Drop, Eq, ImmutableSlice, Iterator};\n+use core::prelude::{Clone, Drop, Eq, ImmutableSlice, Iterator};\n use core::prelude::{MutableSlice, None, Option, Ordering, PartialEq};\n use core::prelude::{PartialOrd, RawPtr, Some, StrSlice, range};\n use core::ptr;\n@@ -259,6 +259,16 @@ impl CString {\n         self.buf\n     }\n \n+    /// Return the number of bytes in the CString (not including the NUL\n+    /// terminator).\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        unsafe { libc::strlen(self.buf) as uint }\n+    }\n+\n+    /// Returns if there are no bytes in this string\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl Drop for CString {\n@@ -271,14 +281,6 @@ impl Drop for CString {\n     }\n }\n \n-impl Collection for CString {\n-    /// Return the number of bytes in the CString (not including the NUL terminator).\n-    #[inline]\n-    fn len(&self) -> uint {\n-        unsafe { libc::strlen(self.buf) as uint }\n-    }\n-}\n-\n impl fmt::Show for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         String::from_utf8_lossy(self.as_bytes_no_nul()).fmt(f)"}, {"sha": "796f9af659630ce0a44c2af8d67a61634dd7bfe3", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -42,7 +42,6 @@ use core::prelude::*;\n \n use alloc::heap;\n use collections::treemap::TreeMap;\n-use collections::MutableMap;\n use core::cmp;\n use core::kinds::marker;\n use core::mem;\n@@ -261,8 +260,6 @@ impl<T: 'static> KeyValue<T> {\n     /// assert_eq!(*key.get().unwrap(), 3);\n     /// ```\n     pub fn get(&'static self) -> Option<Ref<T>> {\n-        use collections::Map;\n-\n         let map = match unsafe { get_local_map() } {\n             Some(map) => map,\n             None => return None,"}, {"sha": "6b64959a8436bb2a38ccb2e07c7681a174f6ac45", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -14,7 +14,6 @@\n \n #![experimental]\n \n-use collections::Collection;\n use core::kinds::Sized;\n use fmt;\n use iter::Iterator;"}, {"sha": "fd605bb2b5cc278e5c1c532ec8cfe2fdcd65ba04", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -35,7 +35,6 @@\n \n #![experimental]\n \n-use collections::Collection;\n use kinds::Send;\n use mem;\n use ops::Drop;\n@@ -143,6 +142,12 @@ impl<T> CVec<T> {\n         self.dtor = None;\n         self.base\n     }\n+\n+    /// Returns the number of items in this vector.\n+    pub fn len(&self) -> uint { self.len }\n+\n+    /// Returns whether this vector is empty.\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> AsSlice<T> for CVec<T> {\n@@ -154,10 +159,6 @@ impl<T> AsSlice<T> for CVec<T> {\n     }\n }\n \n-impl<T> Collection for CVec<T> {\n-    fn len(&self) -> uint { self.len }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "596e483c2f6d3b2555404ab686a9f965c98beea6", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 213, "deletions": 81, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -12,7 +12,6 @@\n \n use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n-use collections::{Collection, Mutable, MutableSet, Map, MutableMap};\n use default::Default;\n use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n@@ -471,86 +470,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Collection for HashMap<K, V, H> {\n-    /// Return the number of elements in the map.\n-    fn len(&self) -> uint { self.table.size() }\n-}\n-\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n-    /// Clear the map, removing all key-value pairs. Keeps the allocated memory\n-    /// for reuse.\n-    fn clear(&mut self) {\n-        // Prevent reallocations from happening from now on. Makes it possible\n-        // for the map to be reused but has a downside: reserves permanently.\n-        self.resize_policy.reserve(self.table.size());\n-\n-        let cap = self.table.capacity();\n-        let mut buckets = Bucket::first(&mut self.table);\n-\n-        while buckets.index() != cap {\n-            buckets = match buckets.peek() {\n-                Empty(b)  => b.next(),\n-                Full(full) => {\n-                    let (b, _, _) = full.take();\n-                    b.next()\n-                }\n-            };\n-        }\n-    }\n-}\n-\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n-    fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n-        self.search(k).map(|bucket| {\n-            let (_, v) = bucket.into_refs();\n-            v\n-        })\n-    }\n-\n-    fn contains_key(&self, k: &K) -> bool {\n-        self.search(k).is_some()\n-    }\n-}\n-\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n-    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n-        match self.search_mut(k) {\n-            Some(bucket) => {\n-                let (_, v) = bucket.into_mut_refs();\n-                Some(v)\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    fn swap(&mut self, k: K, v: V) -> Option<V> {\n-        let hash = self.make_hash(&k);\n-        let potential_new_size = self.table.size() + 1;\n-        self.make_some_room(potential_new_size);\n-\n-        let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n-            retval = Some(replace(val_ref, val));\n-        });\n-        retval\n-    }\n-\n-\n-    fn pop(&mut self, k: &K) -> Option<V> {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        let potential_new_size = self.table.size() - 1;\n-        self.make_some_room(potential_new_size);\n-\n-        self.search_mut(k).map(|bucket| {\n-            let (_k, val) = pop_internal(bucket);\n-            val\n-        })\n-    }\n-}\n-\n impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// Create an empty HashMap.\n     ///\n@@ -1064,6 +983,219 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         let hash = self.make_hash(&key);\n         search_entry_hashed(&mut self.table, hash, key)\n     }\n+\n+    /// Return the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1u, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.table.size() }\n+\n+    /// Return true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1u, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) {\n+        // Prevent reallocations from happening from now on. Makes it possible\n+        // for the map to be reused but has a downside: reserves permanently.\n+        self.resize_policy.reserve(self.table.size());\n+\n+        let cap = self.table.capacity();\n+        let mut buckets = Bucket::first(&mut self.table);\n+\n+        while buckets.index() != cap {\n+            buckets = match buckets.peek() {\n+                Empty(b)  => b.next(),\n+                Full(full) => {\n+                    let (b, _, _) = full.take();\n+                    b.next()\n+                }\n+            };\n+        }\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.find(&1), Some(&\"a\"));\n+    /// assert_eq!(map.find(&2), None);\n+    /// ```\n+    pub fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+        self.search(k).map(|bucket| {\n+            let (_, v) = bucket.into_refs();\n+            v\n+        })\n+    }\n+\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    pub fn contains_key(&self, k: &K) -> bool {\n+        self.search(k).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// match map.find_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n+    pub fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+        match self.search_mut(k) {\n+            Some(bucket) => {\n+                let (_, v) = bucket.into_mut_refs();\n+                Some(v)\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    /// Inserts a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Returns `true` if the key did\n+    /// not already exist in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// assert_eq!(map.insert(2u, \"value\"), true);\n+    /// assert_eq!(map.insert(2, \"value2\"), false);\n+    /// assert_eq!(map[2], \"value2\");\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, key: K, value: V) -> bool {\n+        self.swap(key, value).is_none()\n+    }\n+\n+    /// Removes a key-value pair from the map. Returns `true` if the key\n+    /// was present in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// assert_eq!(map.remove(&1u), false);\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), true);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, key: &K) -> bool {\n+        self.pop(key).is_some()\n+    }\n+\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n+        let hash = self.make_hash(&k);\n+        let potential_new_size = self.table.size() + 1;\n+        self.make_some_room(potential_new_size);\n+\n+        let mut retval = None;\n+        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n+            retval = Some(replace(val_ref, val));\n+        });\n+        retval\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1u, \"a\");\n+    /// assert_eq!(map.pop(&1), Some(\"a\"));\n+    /// assert_eq!(map.pop(&1), None);\n+    /// ```\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        let potential_new_size = self.table.size() - 1;\n+        self.make_some_room(potential_new_size);\n+\n+        self.search_mut(k).map(|bucket| {\n+            let (_k, val) = pop_internal(bucket);\n+            val\n+        })\n+    }\n }\n \n fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)"}, {"sha": "69f3812425f64216a5ab5b4a40634d2c67d85aaf", "filename": "src/libstd/collections/hashmap/set.rs", "status": "modified", "additions": 149, "deletions": 25, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -12,7 +12,6 @@\n \n use clone::Clone;\n use cmp::{Eq, Equiv, PartialEq};\n-use collections::{Collection, Mutable, Set, MutableSet, Map, MutableMap};\n use core::kinds::Sized;\n use default::Default;\n use fmt::Show;\n@@ -376,44 +375,170 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))\n     }\n-}\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|key| other.contains(key))\n-    }\n-}\n-\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1u);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    pub fn len(&self) -> uint { self.map.len() }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n-    fn len(&self) -> uint { self.map.len() }\n-}\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1u);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n-    fn clear(&mut self) { self.map.clear() }\n-}\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// v.insert(1u);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    pub fn clear(&mut self) { self.map.clear() }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n-    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let set: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n-    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: HashSet<uint> = HashSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n \n-    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let sup: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: HashSet<uint> = HashSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let sub: HashSet<uint> = [1, 2].iter().map(|&x| x).collect();\n+    /// let mut set: HashSet<uint> = HashSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    #[inline]\n+    pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2u), true);\n+    /// assert_eq!(set.insert(2), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// set.insert(2u);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n+    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+        if self.len() != other.len() { return false; }\n \n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+        self.iter().all(|key| other.contains(key))\n+    }\n }\n \n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+\n impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n@@ -471,7 +596,6 @@ mod test_set {\n \n     use super::HashSet;\n     use slice::ImmutablePartialEqSlice;\n-    use collections::Collection;\n \n     #[test]\n     fn test_disjoint() {"}, {"sha": "93e649f9355dd8946aba5b9d56a982b7df0802b2", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -38,7 +38,7 @@\n //! ```\n \n use cmp::{PartialEq, Eq};\n-use collections::{HashMap, Collection, Mutable, MutableMap};\n+use collections::HashMap;\n use fmt;\n use hash::Hash;\n use iter::{range, Iterator};\n@@ -288,6 +288,15 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n             (*(*node).next).prev = node;\n         }\n     }\n+\n+    /// Return the number of key-value pairs in the cache.\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns whether the cache is currently empty.\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clear the cache of all key-value pairs.\n+    pub fn clear(&mut self) { self.map.clear(); }\n }\n \n impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n@@ -311,20 +320,6 @@ impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     }\n }\n \n-impl<K: Hash + Eq, V> Collection for LruCache<K, V> {\n-    /// Return the number of key-value pairs in the cache.\n-    fn len(&self) -> uint {\n-        self.map.len()\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> Mutable for LruCache<K, V> {\n-    /// Clear the cache of all key-value pairs.\n-    fn clear(&mut self) {\n-        self.map.clear();\n-    }\n-}\n-\n #[unsafe_destructor]\n impl<K, V> Drop for LruCache<K, V> {\n     fn drop(&mut self) {"}, {"sha": "be9e22ee9d14c9972e1b592eb955d4e9c369e922", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -328,8 +328,6 @@\n \n #![experimental]\n \n-pub use core_collections::{Collection, Mutable, Map, MutableMap};\n-pub use core_collections::{Set, MutableSet, Deque, MutableSeq};\n pub use core_collections::{Bitv, BitvSet, BTreeMap, BTreeSet, DList, EnumSet};\n pub use core_collections::{PriorityQueue, RingBuf, SmallIntMap};\n pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet};"}, {"sha": "4c133fc73973904c77ea9a11b0ece68b497d5cff", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -20,7 +20,6 @@ A simple wrapper over the platform's dynamic library facilities\n #![allow(missing_docs)]\n \n use clone::Clone;\n-use collections::MutableSeq;\n use c_str::ToCStr;\n use iter::Iterator;\n use mem;\n@@ -280,7 +279,6 @@ pub mod dl {\n #[cfg(target_os = \"windows\")]\n pub mod dl {\n     use c_str::ToCStr;\n-    use collections::MutableSeq;\n     use iter::Iterator;\n     use libc;\n     use os;"}, {"sha": "49c688da31cbfaedccc29639bddae8eef69ade5b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -13,7 +13,6 @@\n //! Buffering wrappers for I/O traits\n \n use cmp;\n-use collections::Collection;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use ops::Drop;"}, {"sha": "c925208c3eee79c104e64863faba74140c6ae3fd", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -10,7 +10,6 @@\n \n use clone::Clone;\n use cmp;\n-use collections::Collection;\n use comm::{Sender, Receiver};\n use io;\n use option::{None, Some};"}, {"sha": "6d0b8ebc3d9c4348956ca3b546f5f60aa1ade184", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -15,7 +15,6 @@\n // FIXME: Not sure how this should be structured\n // FIXME: Iteration should probably be considered separately\n \n-use collections::{Collection, MutableSeq};\n use io::{IoError, IoResult, Reader};\n use io;\n use iter::Iterator;\n@@ -502,7 +501,6 @@ mod test {\n mod bench {\n     extern crate test;\n \n-    use collections::Collection;\n     use prelude::*;\n     use self::test::Bencher;\n "}, {"sha": "c8524676a6dd4bb0a087d0db99910e8ae8b012e7", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -54,7 +54,6 @@ fs::unlink(&path);\n \n use c_str::ToCStr;\n use clone::Clone;\n-use collections::{Collection, MutableSeq};\n use io::standard_error;\n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};"}, {"sha": "601043658176450ad665fb339b9901635787c0c9", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -13,13 +13,11 @@\n //! Readers and Writers for in-memory buffers\n \n use cmp::min;\n-use collections::Collection;\n use option::None;\n use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice;\n-use slice::AsSlice;\n+use slice::{mod, AsSlice, ImmutableSlice};\n use vec::Vec;\n \n const BUF_CAPACITY: uint = 128;"}, {"sha": "c6f237ff1da349be6c7aa122de24fc2f4eabdfb8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -222,7 +222,6 @@ responding to errors that may occur while attempting to read the numbers.\n #![deny(unused_must_use)]\n \n use char::Char;\n-use collections::Collection;\n use default::Default;\n use fmt;\n use int;"}, {"sha": "f4f3be13f6675d515e176fbd53afad48d50074c0", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -15,13 +15,12 @@\n \n #![allow(missing_docs)]\n \n-use collections::Collection;\n use fmt;\n use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableSlice, MutableSlice};\n+use slice::{MutableCloneableSlice, MutableSlice, ImmutableSlice};\n \n pub type Port = u16;\n "}, {"sha": "30ecf2284df76089d29c5db44a2b3a2a43f8e40c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -14,7 +14,6 @@\n \n use char;\n use clone::Clone;\n-use collections::{Collection, MutableSeq};\n use num::{NumCast, Zero, One, cast, Int};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;"}, {"sha": "5b3c872d2b726597f5e533f6f7344847b4858dae", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -32,7 +32,6 @@\n #![allow(non_snake_case)]\n \n use clone::Clone;\n-use collections::{Collection, MutableSeq};\n use fmt;\n use io::{IoResult, IoError};\n use iter::Iterator;"}, {"sha": "62105c0d90ea7f4071dee276c7d74526f08549fc", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -67,7 +67,6 @@ println!(\"path exists: {}\", path.exists());\n \n #![experimental]\n \n-use collections::{Collection, MutableSeq};\n use c_str::CString;\n use clone::Clone;\n use fmt;"}, {"sha": "e090d9d709801cd8783f8ca462549a433b91923f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -13,7 +13,6 @@\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use collections::{Collection, MutableSeq};\n use from_str::FromStr;\n use hash;\n use io::Writer;"}, {"sha": "f0d1ecf9d24bcf18b96427f8348f4853c1ce8084", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -16,7 +16,6 @@ use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use collections::{Collection, MutableSeq};\n use from_str::FromStr;\n use hash;\n use io::Writer;"}, {"sha": "b2ff29c0f7eef816df98a868cc54783ba81705ad", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -65,8 +65,6 @@\n #[doc(no_inline)] pub use clone::Clone;\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[doc(no_inline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n-#[doc(no_inline)] pub use collections::{Collection, Mutable, Map, MutableMap, MutableSeq};\n-#[doc(no_inline)] pub use collections::{Set, MutableSet};\n #[doc(no_inline)] pub use iter::{FromIterator, Extendable, ExactSize};\n #[doc(no_inline)] pub use iter::{Iterator, DoubleEndedIterator};\n #[doc(no_inline)] pub use iter::{RandomAccessIterator, CloneableIterator};"}, {"sha": "b7b0858123042be37ac5f89ba48dd4d1396319d4", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -62,15 +62,14 @@ mod imp {\n mod imp {\n     extern crate libc;\n \n-    use collections::Collection;\n     use io::{IoResult};\n     use kinds::marker;\n     use mem;\n     use os;\n     use rand::Rng;\n     use result::{Ok};\n     use self::libc::{c_int, size_t};\n-    use slice::MutableSlice;\n+    use slice::{ImmutableSlice, MutableSlice};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -130,7 +129,6 @@ mod imp {\n mod imp {\n     extern crate libc;\n \n-    use core_collections::Collection;\n     use io::{IoResult, IoError};\n     use mem;\n     use ops::Drop;\n@@ -139,7 +137,7 @@ mod imp {\n     use result::{Ok, Err};\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n-    use slice::MutableSlice;\n+    use slice::{ImmutableSlice, MutableSlice};\n \n     type HCRYPTPROV = LONG_PTR;\n "}, {"sha": "c1bb6970f7150c161024b969e88907d4a6974522", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -10,10 +10,10 @@\n \n //! A wrapper around any Reader to treat it as an RNG.\n \n-use collections::Collection;\n use io::Reader;\n use rand::Rng;\n use result::{Ok, Err};\n+use slice::ImmutableSlice;\n \n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required."}, {"sha": "5d7aa0509c5d84e7496fdef396e0e102a626c796", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -12,7 +12,6 @@\n \n #![allow(non_camel_case_types)]\n \n-use collections::Collection;\n use from_str::from_str;\n use io::{IoResult, Writer};\n use iter::Iterator;\n@@ -390,7 +389,6 @@ mod imp {\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n     fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use collections::Collection;\n         use iter::Iterator;\n         use os;\n         use path::GenericPath;\n@@ -659,7 +657,6 @@ mod imp {\n #[allow(dead_code, non_snake_case)]\n mod imp {\n     use c_str::CString;\n-    use core_collections::Collection;\n     use intrinsics;\n     use io::{IoResult, Writer};\n     use libc;"}, {"sha": "11b8b974dcf7978fe013f1d1e073a8c48d80b40e", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -55,7 +55,7 @@ use core::prelude::*;\n use alloc::arc::Arc;\n use alloc::heap::{allocate, deallocate};\n use alloc::boxed::Box;\n-use collections::{Vec, MutableSeq};\n+use collections::Vec;\n use core::kinds::marker;\n use core::mem::{forget, min_align_of, size_of, transmute};\n use core::ptr;"}, {"sha": "facf204983b42e8d0145b09f13f0a87f9bf9a987", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -22,7 +22,7 @@ use core::finally::Finally;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n-use collections::{Vec, MutableSeq};\n+use collections::Vec;\n \n use mutex;\n use comm::{Receiver, Sender, channel};"}, {"sha": "f622e2d611276a0d5e041f91edd263762222b9b2", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -112,6 +112,10 @@ impl<T> OwnedSlice<T> {\n     pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n         self.iter().map(f).collect()\n     }\n+\n+    pub fn len(&self) -> uint { self.len }\n+\n+    pub fn is_empty(&self) -> bool { self.len == 0 }\n }\n \n impl<T> Default for OwnedSlice<T> {\n@@ -140,10 +144,6 @@ impl<T: PartialEq> PartialEq for OwnedSlice<T> {\n \n impl<T: Eq> Eq for OwnedSlice<T> {}\n \n-impl<T> Collection for OwnedSlice<T> {\n-    fn len(&self) -> uint { self.len }\n-}\n-\n impl<T> FromIterator<T> for OwnedSlice<T> {\n     fn from_iter<I: Iterator<T>>(mut iter: I) -> OwnedSlice<T> {\n         OwnedSlice::from_vec(iter.collect())"}, {"sha": "56ee6c7b9158c7bede5b37e748ca7ea6211c1de3", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -25,16 +25,6 @@ enum SmallVectorRepr<T> {\n     Many(Vec<T>),\n }\n \n-impl<T> Collection for SmallVector<T> {\n-    fn len(&self) -> uint {\n-        match self.repr {\n-            Zero => 0,\n-            One(..) => 1,\n-            Many(ref vals) => vals.len()\n-        }\n-    }\n-}\n-\n impl<T> FromIterator<T> for SmallVector<T> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> SmallVector<T> {\n         let mut v = SmallVector::zero();\n@@ -131,6 +121,16 @@ impl<T> SmallVector<T> {\n         };\n         MoveItems { repr: repr }\n     }\n+\n+    pub fn len(&self) -> uint {\n+        match self.repr {\n+            Zero => 0,\n+            One(..) => 1,\n+            Many(ref vals) => vals.len()\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n pub struct MoveItems<T> {"}, {"sha": "4bad631798fb24a4058540c61fce7e8caed7966f", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -19,7 +19,7 @@\n \n use core::clone::Clone;\n use core::cmp;\n-use core::collections::Collection;\n+use core::slice::ImmutableSlice;\n use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n use core::kinds::Sized;\n use core::option::{Option, None, Some};"}, {"sha": "3933a33446d6346e520191d258c35c335ce74690", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -22,7 +22,29 @@ fn timed(label: &str, f: ||) {\n     println!(\"  {}: {}\", label, end - start);\n }\n \n-fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n+trait MutableMap {\n+    fn insert(&mut self, k: uint, v: uint);\n+    fn remove(&mut self, k: &uint) -> bool;\n+    fn find(&self, k: &uint) -> Option<&uint>;\n+}\n+\n+impl MutableMap for TreeMap<uint, uint> {\n+    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+}\n+impl MutableMap for HashMap<uint, uint> {\n+    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+}\n+impl MutableMap for TrieMap<uint> {\n+    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+}\n+\n+fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Ascending integers:\");\n \n     timed(\"insert\", || {\n@@ -44,7 +66,7 @@ fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     });\n }\n \n-fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n+fn descending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Descending integers:\");\n \n     timed(\"insert\", || {\n@@ -66,7 +88,7 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     });\n }\n \n-fn vector<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n+fn vector<M: MutableMap>(map: &mut M, n_keys: uint, dist: &[uint]) {\n     timed(\"insert\", || {\n         for i in range(0u, n_keys) {\n             map.insert(dist[i], i + 1);"}, {"sha": "4833467922b76abb7040a0a76ff6e9facaaa76e0", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -16,6 +16,7 @@ extern crate time;\n \n use std::collections::bitv::BitvSet;\n use std::collections::TreeSet;\n+use std::hash::Hash;\n use std::collections::HashSet;\n use std::os;\n use std::uint;\n@@ -37,6 +38,28 @@ fn timed(result: &mut f64, op: ||) {\n     *result = (end - start);\n }\n \n+trait MutableSet<T> {\n+    fn insert(&mut self, k: T);\n+    fn remove(&mut self, k: &T) -> bool;\n+    fn contains(&self, k: &T) -> bool;\n+}\n+\n+impl<T: Hash + Eq> MutableSet<T> for HashSet<T> {\n+    fn insert(&mut self, k: T) { self.insert(k); }\n+    fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n+    fn contains(&self, k: &T) -> bool { self.contains(k) }\n+}\n+impl<T: Ord> MutableSet<T> for TreeSet<T> {\n+    fn insert(&mut self, k: T) { self.insert(k); }\n+    fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n+    fn contains(&self, k: &T) -> bool { self.contains(k) }\n+}\n+impl MutableSet<uint> for BitvSet {\n+    fn insert(&mut self, k: uint) { self.insert(k); }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n+    fn contains(&self, k: &uint) -> bool { self.contains(k) }\n+}\n+\n impl Results {\n     pub fn bench_int<T:MutableSet<uint>,\n                      R: rand::Rng>("}, {"sha": "3c784c3b770e4f847884dcedc12b5bf86e040b4c", "filename": "src/test/compile-fail/issue-16562.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16562.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -15,6 +15,8 @@ struct Col<D, C> {\n     col: C,\n }\n \n+trait Collection { fn len(&self) -> uint; }\n+\n impl<T, M: MatrixShape> Collection for Col<M, uint> {\n //~^ ERROR unable to infer enough type information\n     fn len(&self) -> uint {"}, {"sha": "134f58951bab2117e4472c72454b7c880b3aa9be", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -12,6 +12,8 @@ trait ListItem<'a> {\n     fn list_name() -> &'a str;\n }\n \n+trait Collection { fn len(&self) -> uint; }\n+\n struct List<'a, T: ListItem<'a>> {\n //~^ ERROR the parameter type `T` may not live long enough; consider adding an explicit lifetime bo\n //~^^ NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at"}, {"sha": "b1116a4cca62bbf44b08fbe8a4ab2337a4d8c469", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -12,11 +12,15 @@ extern crate collections;\n \n use std::collections::HashMap;\n \n+trait Map<K, V> {}\n+\n+impl<K, V> Map<K, V> for HashMap<K, V> {}\n+\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n     let x: Box<HashMap<int, int>> = box HashMap::new();\n     let x: Box<Map<int, int>> = x;\n     let y: Box<Map<uint, int>> = box x;\n-    //~^ ERROR the trait `collections::Map<uint, int>` is not implemented\n+    //~^ ERROR the trait `Map<uint, int>` is not implemented\n }"}, {"sha": "b5892c3f1230545e4c7f0175a003dfff9361b1a3", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -46,18 +46,9 @@ impl<T> cat<T> {\n             return false;\n         }\n     }\n-}\n-\n-impl<T> Collection for cat<T> {\n     fn len(&self) -> uint { self.meows as uint }\n     fn is_empty(&self) -> bool { self.meows == 0 }\n-}\n-\n-impl<T> Mutable for cat<T> {\n     fn clear(&mut self) {}\n-}\n-\n-impl<T> Map<int, T> for cat<T> {\n     fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n     fn find(&self, k: &int) -> Option<&T> {\n@@ -67,9 +58,6 @@ impl<T> Map<int, T> for cat<T> {\n             None\n         }\n     }\n-}\n-\n-impl<T> MutableMap<int, T> for cat<T> {\n     fn insert(&mut self, k: int, _: T) -> bool {\n         self.meows += k;\n         true"}, {"sha": "39995db5a2f546d03ca7f1919782bedc32770cc5", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -11,7 +11,6 @@\n \n extern crate collections;\n use std::collections::RingBuf;\n-use std::collections::Deque;\n \n pub fn main() {\n     let mut q = RingBuf::new();"}, {"sha": "1edce811bcb2107e5a9d59555dc8c1aae24cc8ba", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -10,7 +10,6 @@\n \n extern crate collections;\n \n-use std::collections::{Map, MutableMap};\n use std::str::{SendStr, Owned, Slice};\n use std::collections::HashMap;\n use std::option::Some;"}, {"sha": "f73ab8f52d7ed32f9cbea446735c8968aa653c36", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f90aead4ad52de1d2c50418da4d66320233d8e/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=39f90aead4ad52de1d2c50418da4d66320233d8e", "patch": "@@ -10,7 +10,6 @@\n \n extern crate collections;\n \n-use std::collections::{ Map, MutableMap};\n use std::str::{SendStr, Owned, Slice};\n use std::to_string::ToString;\n use self::collections::TreeMap;"}]}