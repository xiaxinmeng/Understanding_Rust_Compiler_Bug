{"sha": "066d44bc0d1680e2094867631920104049fd4948", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmQ0NGJjMGQxNjgwZTIwOTQ4Njc2MzE5MjAxMDQwNDlmZDQ5NDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-22T15:40:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "refactor the `targeted_by_break` field\n\nIn master, this field was an arbitrary node-id (in fact, an id for\nsomething that doesn't even exist in the HIR -- the `catch` node).\nBreaks targeting this block used that id. In the newer system, this\nfield is a boolean, and any breaks targeted this block will use the\nid of the block.", "tree": {"sha": "b842cac4183bb0ca4584e28a0adab26662874032", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b842cac4183bb0ca4584e28a0adab26662874032"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066d44bc0d1680e2094867631920104049fd4948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066d44bc0d1680e2094867631920104049fd4948", "html_url": "https://github.com/rust-lang/rust/commit/066d44bc0d1680e2094867631920104049fd4948", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066d44bc0d1680e2094867631920104049fd4948/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a47fa1d3d4594ddd3077d0e73d29aa056493b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a47fa1d3d4594ddd3077d0e73d29aa056493b0d", "html_url": "https://github.com/rust-lang/rust/commit/6a47fa1d3d4594ddd3077d0e73d29aa056493b0d"}], "stats": {"total": 274, "additions": 143, "deletions": 131}, "files": [{"sha": "20b322ec189511bde830fb8ecb8ae0f45cd278e4", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -74,11 +74,11 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n-        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+        if blk.targeted_by_break {\n             let expr_exit = self.add_ast_node(blk.id, &[]);\n \n             self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: break_to_expr_id,\n+                block_expr_id: blk.id,\n                 break_index: expr_exit,\n             });\n "}, {"sha": "17185a6ab69f493399e327afc94c8504c5f84a11", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -1156,7 +1156,7 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, break_to: Option<NodeId>) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n         let mut expr = None;\n \n         let mut stmts = vec![];\n@@ -1179,7 +1179,7 @@ impl<'a> LoweringContext<'a> {\n             expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n-            break_to_expr_id: break_to,\n+            targeted_by_break: targeted_by_break,\n         })\n     }\n \n@@ -1274,7 +1274,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.with_new_scopes(|this| {\n-                    let body = this.lower_block(body, None);\n+                    let body = this.lower_block(body, false);\n                     let body = this.expr_block(body, ThinVec::new());\n                     let body_id = this.record_body(body, Some(decl));\n                     hir::ItemFn(this.lower_fn_decl(decl),\n@@ -1368,7 +1368,7 @@ impl<'a> LoweringContext<'a> {\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                        let body = this.lower_block(body, None);\n+                        let body = this.lower_block(body, false);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n@@ -1424,7 +1424,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n-                        let body = this.lower_block(body, None);\n+                        let body = this.lower_block(body, false);\n                         let expr = this.expr_block(body, ThinVec::new());\n                         let body_id = this.record_body(expr, Some(&sig.decl));\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n@@ -1848,15 +1848,15 @@ impl<'a> LoweringContext<'a> {\n                                 id: id,\n                                 rules: hir::DefaultBlock,\n                                 span: span,\n-                                break_to_expr_id: None,\n+                                targeted_by_break: false,\n                             });\n                             P(self.expr_block(blk, ThinVec::new()))\n                         }\n                         _ => P(self.lower_expr(els)),\n                     }\n                 });\n \n-                let then_blk = self.lower_block(blk, None);\n+                let then_blk = self.lower_block(blk, false);\n                 let then_expr = self.expr_block(then_blk, ThinVec::new());\n \n                 hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n@@ -1865,18 +1865,18 @@ impl<'a> LoweringContext<'a> {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprWhile(\n                         this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n-                        this.lower_block(body, None),\n+                        this.lower_block(body, false),\n                         this.lower_opt_sp_ident(opt_ident)))\n             }\n             ExprKind::Loop(ref body, opt_ident) => {\n                 self.with_loop_scope(e.id, |this|\n-                    hir::ExprLoop(this.lower_block(body, None),\n+                    hir::ExprLoop(this.lower_block(body, false),\n                                   this.lower_opt_sp_ident(opt_ident),\n                                   hir::LoopSource::Loop))\n             }\n             ExprKind::Catch(ref body) => {\n-                self.with_catch_scope(e.id, |this|\n-                    hir::ExprBlock(this.lower_block(body, Some(e.id))))\n+                self.with_catch_scope(body.id, |this|\n+                    hir::ExprBlock(this.lower_block(body, true)))\n             }\n             ExprKind::Match(ref expr, ref arms) => {\n                 hir::ExprMatch(P(self.lower_expr(expr)),\n@@ -1894,7 +1894,7 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 })\n             }\n-            ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, None)),\n+            ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, false)),\n             ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n@@ -2040,7 +2040,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // `<pat> => <body>`\n                 {\n-                    let body = self.lower_block(body, None);\n+                    let body = self.lower_block(body, false);\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n                     let pat = self.lower_pat(pat);\n                     arms.push(self.arm(hir_vec![pat], body_expr));\n@@ -2112,7 +2112,7 @@ impl<'a> LoweringContext<'a> {\n                             let (guard, body) = if let ExprKind::If(ref cond,\n                                                                     ref then,\n                                                                     _) = else_expr.node {\n-                                let then = self.lower_block(then, None);\n+                                let then = self.lower_block(then, false);\n                                 (Some(cond),\n                                  self.expr_block(then, ThinVec::new()))\n                             } else {\n@@ -2162,7 +2162,7 @@ impl<'a> LoweringContext<'a> {\n                 // Note that the block AND the condition are evaluated in the loop scope.\n                 // This is done to allow `break` from inside the condition of the loop.\n                 let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n-                    this.lower_block(body, None),\n+                    this.lower_block(body, false),\n                     this.expr_break(e.span, ThinVec::new()),\n                     this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n                 ));\n@@ -2223,7 +2223,7 @@ impl<'a> LoweringContext<'a> {\n                 // `::std::option::Option::Some(<pat>) => <body>`\n                 let pat_arm = {\n                     let body_block = self.with_loop_scope(e.id,\n-                                                          |this| this.lower_block(body, None));\n+                                                          |this| this.lower_block(body, false));\n                     let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                     let pat = self.lower_pat(pat);\n                     let some_pat = self.pat_some(e.span, pat);\n@@ -2655,7 +2655,7 @@ impl<'a> LoweringContext<'a> {\n             id: self.next_id(),\n             rules: hir::DefaultBlock,\n             span: span,\n-            break_to_expr_id: None,\n+            targeted_by_break: false,\n         }\n     }\n \n@@ -2763,7 +2763,7 @@ impl<'a> LoweringContext<'a> {\n             id: id,\n             stmts: stmts,\n             expr: Some(expr),\n-            break_to_expr_id: None,\n+            targeted_by_break: false,\n         });\n         self.expr_block(block, attrs)\n     }"}, {"sha": "d5000ac9c18669a3940bbea0a4629eaa6645d614", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -549,9 +549,11 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n-    /// The id of the expression that `break` breaks to if the block can be broken out of.\n-    /// Currently only `Some(_)` for `catch {}` blocks\n-    pub break_to_expr_id: Option<NodeId>,\n+    /// If true, then there may exist `break 'a` values that aim to\n+    /// break out of this block early. As of this writing, this is not\n+    /// currently permitted in Rust itself, but it is generated as\n+    /// part of `catch` statements.\n+    pub targeted_by_break: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]"}, {"sha": "7cae08efc0de057a14815832c82db859f5c907c7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -821,8 +821,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n-        if let Some(break_to_expr_id) = blk.break_to_expr_id {\n-            self.breakable_block_ln.insert(break_to_expr_id, succ);\n+        if blk.targeted_by_break {\n+            self.breakable_block_ln.insert(blk.id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {"}, {"sha": "7739766182cfa3ef7f2f045e90f443365a54052f", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -12,90 +12,116 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n use rustc::mir::*;\n use rustc::hir;\n+use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Lvalue<'tcx>,\n-                     mut block: BasicBlock,\n-                     ast_block: &'tcx hir::Block)\n+                     block: BasicBlock,\n+                     ast_block: &'tcx hir::Block,\n+                     source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n+        let Block { extent, span, stmts, expr, targeted_by_break } = self.hir.mirror(ast_block);\n         self.in_scope(extent, block, move |this| {\n-            // This convoluted structure is to avoid using recursion as we walk down a list\n-            // of statements. Basically, the structure we get back is something like:\n-            //\n-            //    let x = <init> in {\n-            //       expr1;\n-            //       let y = <init> in {\n-            //           expr2;\n-            //           expr3;\n-            //           ...\n-            //       }\n-            //    }\n-            //\n-            // The let bindings are valid till the end of block so all we have to do is to pop all\n-            // the let-scopes at the end.\n-            //\n-            // First we build all the statements in the block.\n-            let mut let_extent_stack = Vec::with_capacity(8);\n-            let outer_visibility_scope = this.visibility_scope;\n-            for stmt in stmts {\n-                let Stmt { span: _, kind } = this.hir.mirror(stmt);\n-                match kind {\n-                    StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this| {\n-                            let expr = this.hir.mirror(expr);\n-                            this.stmt_expr(block, expr)\n-                        }));\n-                    }\n-                    StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        let tcx = this.hir.tcx();\n+            if targeted_by_break {\n+                // This is a `break`-able block (currently only `catch { ... }`)\n+                let exit_block = this.cfg.start_new_block();\n+                let block_exit = this.in_breakable_scope(None, exit_block,\n+                                                         destination.clone(), |this| {\n+                    this.ast_block_stmts(destination, block, span, stmts, expr)\n+                });\n+                this.cfg.terminate(unpack!(block_exit), source_info,\n+                                   TerminatorKind::Goto { target: exit_block });\n+                exit_block.unit()\n+            } else {\n+                this.ast_block_stmts(destination, block, span, stmts, expr)\n+            }\n+        })\n+    }\n \n-                        // Enter the remainder scope, i.e. the bindings' destruction scope.\n-                        this.push_scope(remainder_scope);\n-                        let_extent_stack.push(remainder_scope);\n+    fn ast_block_stmts(&mut self,\n+                       destination: &Lvalue<'tcx>,\n+                       mut block: BasicBlock,\n+                       span: Span,\n+                       stmts: Vec<StmtRef<'tcx>>,\n+                       expr: Option<ExprRef<'tcx>>)\n+                       -> BlockAnd<()> {\n+        let this = self;\n+\n+        // This convoluted structure is to avoid using recursion as we walk down a list\n+        // of statements. Basically, the structure we get back is something like:\n+        //\n+        //    let x = <init> in {\n+        //       expr1;\n+        //       let y = <init> in {\n+        //           expr2;\n+        //           expr3;\n+        //           ...\n+        //       }\n+        //    }\n+        //\n+        // The let bindings are valid till the end of block so all we have to do is to pop all\n+        // the let-scopes at the end.\n+        //\n+        // First we build all the statements in the block.\n+        let mut let_extent_stack = Vec::with_capacity(8);\n+        let outer_visibility_scope = this.visibility_scope;\n+        for stmt in stmts {\n+            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n+            match kind {\n+                StmtKind::Expr { scope, expr } => {\n+                    unpack!(block = this.in_scope(scope, block, |this| {\n+                        let expr = this.hir.mirror(expr);\n+                        this.stmt_expr(block, expr)\n+                    }));\n+                }\n+                StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                    let tcx = this.hir.tcx();\n \n-                        // Declare the bindings, which may create a visibility scope.\n-                        let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n-                        let remainder_span = remainder_span.unwrap_or(span);\n-                        let scope = this.declare_bindings(None, remainder_span, &pattern);\n+                    // Enter the remainder scope, i.e. the bindings' destruction scope.\n+                    this.push_scope(remainder_scope);\n+                    let_extent_stack.push(remainder_scope);\n \n-                        // Evaluate the initializer, if present.\n-                        if let Some(init) = initializer {\n-                            unpack!(block = this.in_scope(init_scope, block, move |this| {\n-                                // FIXME #30046                              ^~~~\n-                                this.expr_into_pattern(block, pattern, init)\n-                            }));\n-                        } else {\n-                            this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n-                                this.storage_live_binding(block, node, span);\n-                                this.schedule_drop_for_binding(node, span);\n-                            })\n-                        }\n+                    // Declare the bindings, which may create a visibility scope.\n+                    let remainder_span = remainder_scope.span(&tcx.region_maps, &tcx.hir);\n+                    let remainder_span = remainder_span.unwrap_or(span);\n+                    let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n-                        // Enter the visibility scope, after evaluating the initializer.\n-                        if let Some(visibility_scope) = scope {\n-                            this.visibility_scope = visibility_scope;\n-                        }\n+                    // Evaluate the initializer, if present.\n+                    if let Some(init) = initializer {\n+                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                            // FIXME #30046                              ^~~~\n+                            this.expr_into_pattern(block, pattern, init)\n+                        }));\n+                    } else {\n+                        this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n+                            this.storage_live_binding(block, node, span);\n+                            this.schedule_drop_for_binding(node, span);\n+                        })\n+                    }\n+\n+                    // Enter the visibility scope, after evaluating the initializer.\n+                    if let Some(visibility_scope) = scope {\n+                        this.visibility_scope = visibility_scope;\n                     }\n                 }\n             }\n-            // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n-            // of the block.\n-            if let Some(expr) = expr {\n-                unpack!(block = this.into(destination, block, expr));\n-            } else {\n-                let source_info = this.source_info(span);\n-                this.cfg.push_assign_unit(block, source_info, destination);\n-            }\n-            // Finally, we pop all the let scopes before exiting out from the scope of block\n-            // itself.\n-            for extent in let_extent_stack.into_iter().rev() {\n-                unpack!(block = this.pop_scope(extent, block));\n-            }\n-            // Restore the original visibility scope.\n-            this.visibility_scope = outer_visibility_scope;\n-            block.unit()\n-        })\n+        }\n+        // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n+        // of the block.\n+        if let Some(expr) = expr {\n+            unpack!(block = this.into(destination, block, expr));\n+        } else {\n+            let source_info = this.source_info(span);\n+            this.cfg.push_assign_unit(block, source_info, destination);\n+        }\n+        // Finally, we pop all the let scopes before exiting out from the scope of block\n+        // itself.\n+        for extent in let_extent_stack.into_iter().rev() {\n+            unpack!(block = this.pop_scope(extent, block));\n+        }\n+        // Restore the original visibility scope.\n+        this.visibility_scope = outer_visibility_scope;\n+        block.unit()\n     }\n }"}, {"sha": "a5a114c61bcf6afd46fbb882f7aaef6ce18301bb", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -40,19 +40,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n-                if let Some(_) = ast_block.break_to_expr_id {\n-                    // This is a `break`-able block (currently only `catch { ... }`)\n-                    let exit_block = this.cfg.start_new_block();\n-                    let block_exit = this.in_breakable_scope(None, exit_block,\n-                                                             destination.clone(), |this| {\n-                        this.ast_block(destination, block, ast_block)\n-                    });\n-                    this.cfg.terminate(unpack!(block_exit), source_info,\n-                                       TerminatorKind::Goto { target: exit_block });\n-                    exit_block.unit()\n-                } else {\n-                    this.ast_block(destination, block, ast_block)\n-                }\n+                this.ast_block(destination, block, ast_block, source_info)\n             }\n             ExprKind::Match { discriminant, arms } => {\n                 this.match_expr(destination, expr_span, block, discriminant, arms)"}, {"sha": "d2465331df353c9db0c0ebbd28892fee34339b71", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -23,6 +23,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n+            targeted_by_break: self.targeted_by_break,\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,"}, {"sha": "a3982efd2d695b6e50fdae1af2bd582f21f0f506", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -31,6 +31,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n \n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n+    pub targeted_by_break: bool,\n     pub extent: CodeExtent,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,"}, {"sha": "000398a4bce9f32c90d0bc68f0a0175a52902230", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066d44bc0d1680e2094867631920104049fd4948/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=066d44bc0d1680e2094867631920104049fd4948", "patch": "@@ -416,15 +416,11 @@ pub struct EnclosingBreakables<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n-    fn find_breakable(&mut self, target: hir::ScopeTarget)\n-        -> Option<&mut BreakableCtxt<'gcx, 'tcx>>\n-    {\n-        let opt_index = target.opt_id().and_then(|id| self.by_id.get(&id).cloned());\n-        if let Some(ix) = opt_index {\n-            Some(&mut self.stack[ix])\n-        } else {\n-            None\n-        }\n+    fn find_breakable(&mut self, target_id: ast::NodeId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n+        let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n+            bug!(\"could not find enclosing breakable with id {}\", target_id);\n+        });\n+        &mut self.stack[ix]\n     }\n }\n \n@@ -3472,12 +3468,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n-            let coerce_to = {\n-                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                enclosing_breakables\n-                    .find_breakable(destination.target_id).map(|ctxt| ctxt.coerce_to)\n-            };\n-            if let Some(coerce_to) = coerce_to {\n+            if let Some(target_id) = destination.target_id.opt_id() {\n+                let coerce_to = {\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    enclosing_breakables.find_breakable(target_id).coerce_to\n+                };\n+\n                 let e_ty;\n                 let cause;\n                 if let Some(ref e) = *expr_opt {\n@@ -3492,7 +3488,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                let ctxt = enclosing_breakables.find_breakable(destination.target_id).unwrap();\n+                let ctxt = enclosing_breakables.find_breakable(target_id);\n \n                 let result = if let Some(ref e) = *expr_opt {\n                     // Special-case the first element, as it has no \"previous expressions\".\n@@ -4024,7 +4020,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut ty = if let Some(break_to_expr_id) = blk.break_to_expr_id {\n+        let mut ty = if blk.targeted_by_break {\n             let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(blk.span));\n             let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n             let ctxt = BreakableCtxt {\n@@ -4034,15 +4030,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 may_break: false,\n             };\n \n-            let (mut ctxt, (e_ty, cause)) = self.with_breakable_ctxt(break_to_expr_id, ctxt, || {\n+            let (mut ctxt, (e_ty, cause)) = self.with_breakable_ctxt(blk.id, ctxt, || {\n                 for s in &blk.stmts {\n                     self.check_stmt(s);\n                 }\n                 let coerce_to = {\n                     let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    enclosing_breakables.find_breakable(\n-                        hir::ScopeTarget::Block(break_to_expr_id)\n-                    ).unwrap().coerce_to\n+                    enclosing_breakables.find_breakable(blk.id).coerce_to\n                 };\n                 let e_ty;\n                 let cause;"}]}