{"sha": "f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZjA1MGQwOTAwM2E0Yzc4OTVmNDRmZWQzYTdjNmNkY2U4ZjI5NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-24T22:58:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-24T22:58:28Z"}, "message": "Auto merge of #31873 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #31677, #31784, #31839, #31842, #31843, #31850, #31863, #31868, #31870\n- Failed merges:", "tree": {"sha": "b86509358be85838e2c677348bb476a981327f6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b86509358be85838e2c677348bb476a981327f6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "html_url": "https://github.com/rust-lang/rust/commit/f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ef8d426050318934d16d962325ec002eaf0c29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef8d426050318934d16d962325ec002eaf0c29d", "html_url": "https://github.com/rust-lang/rust/commit/0ef8d426050318934d16d962325ec002eaf0c29d"}, {"sha": "b660ca59ff16bc4bfb675fa6afe61b32aa284d96", "url": "https://api.github.com/repos/rust-lang/rust/commits/b660ca59ff16bc4bfb675fa6afe61b32aa284d96", "html_url": "https://github.com/rust-lang/rust/commit/b660ca59ff16bc4bfb675fa6afe61b32aa284d96"}], "stats": {"total": 200, "additions": 138, "deletions": 62}, "files": [{"sha": "0c4f804126631fea066fdc402ad7e4a47a566dd8", "filename": "src/doc/book/iterators.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fbook%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fbook%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fiterators.md?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -311,10 +311,12 @@ for i in (1..100).filter(|&x| x % 2 == 0) {\n ```\n \n This will print all of the even numbers between one and a hundred.\n-(Note that because `filter` doesn't consume the elements that are\n-being iterated over, it is passed a reference to each element, and\n-thus the filter predicate uses the `&x` pattern to extract the integer\n-itself.)\n+(Note that, unlike `map`, the closure passed to `filter` is passed a reference\n+to the element instead of the element itself. The filter predicate here uses\n+the `&x` pattern to extract the integer. The filter closure is passed a\n+reference because it returns `true` or `false` instead of the element,\n+so the `filter` implementation must retain ownership to put the elements\n+into the newly constructed iterator.)\n \n You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:"}, {"sha": "70d71c14ddf1686da0714ea4612285ac716181db", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -157,7 +157,7 @@ this point of time). These two parts of the vector (the one on the stack and\n one on the heap) must agree with each other at all times with regards to\n things like the length, capacity etc.\n \n-When we move `v` to `v2`, rust actually does a bitwise copy of the vector\n+When we move `v` to `v2`, Rust actually does a bitwise copy of the vector\n object `v` into the stack allocation represented by `v2`. This shallow copy\n does not create a copy of the heap allocation containing the actual data.\n Which means that there would be two pointers to the contents of the vector"}, {"sha": "b124f3ffc4652d48488bba4a03b22a19ba46b48c", "filename": "src/doc/nomicon/other-reprs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fother-reprs.md?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -57,7 +57,7 @@ These reprs have no effect on a struct.\n \n # repr(packed)\n \n-`repr(packed)` forces rust to strip any padding, and only align the type to a\n+`repr(packed)` forces Rust to strip any padding, and only align the type to a\n byte. This may improve the memory footprint, but will likely have other negative\n side-effects.\n "}, {"sha": "228af39483832a7d9c7afce2167158a0be71be0a", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -841,8 +841,8 @@ extern crate std as ruststd; // linking to 'std' under another name\n \n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n-path required to refer to a module item. These declarations may appear at the\n-top of [modules](#modules) and [blocks](grammar.html#block-expressions).\n+path required to refer to a module item. These declarations may appear in\n+[modules](#modules) and [blocks](grammar.html#block-expressions), usually at the top.\n \n > **Note**: Unlike in many languages,\n > `use` declarations in Rust do *not* declare linkage dependency with external crates.\n@@ -1764,7 +1764,7 @@ pub mod submodule {\n # fn main() {}\n ```\n \n-For a rust program to pass the privacy checking pass, all paths must be valid\n+For a Rust program to pass the privacy checking pass, all paths must be valid\n accesses given the two rules above. This includes all use statements,\n expressions, types, etc.\n \n@@ -3564,8 +3564,9 @@ Each instance of a trait object includes:\n    each method of `SomeTrait` that `T` implements, a pointer to `T`'s\n    implementation (i.e. a function pointer).\n \n-The purpose of trait objects is to permit \"late binding\" of methods. A call to\n-a method on a trait object is only resolved to a vtable entry at compile time.\n+The purpose of trait objects is to permit \"late binding\" of methods. Calling a\n+method on a trait object results in virtual dispatch at runtime: that is, a\n+function pointer is loaded from the trait object vtable and invoked indirectly.\n The actual implementation for each vtable entry can vary on an object-by-object\n basis.\n "}, {"sha": "eab69088aa2b93fd2f63ffe4f83c9758e7863f82", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -407,7 +407,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// time. The chunks are slices and do not overlap. If `size` does not divide the\n     /// length of the slice, then the last chunk will not have length\n     /// `size`.\n     ///\n@@ -433,7 +433,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///"}, {"sha": "ae442e155c0d07b923eca9bbc5d008374ac3b1f4", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -135,6 +135,49 @@ use super::range::RangeArgument;\n /// }\n /// ```\n ///\n+/// # Indexing\n+///\n+/// The Vec type allows to access values by index, because it implements the\n+/// `Index` trait. An example will be more explicit:\n+///\n+/// ```\n+/// let v = vec!(0, 2, 4, 6);\n+/// println!(\"{}\", v[1]); // it will display '2'\n+/// ```\n+///\n+/// However be careful: if you try to access an index which isn't in the Vec,\n+/// your software will panic! You cannot do this:\n+///\n+/// ```ignore\n+/// let v = vec!(0, 2, 4, 6);\n+/// println!(\"{}\", v[6]); // it will panic!\n+/// ```\n+///\n+/// In conclusion: always check if the index you want to get really exists\n+/// before doing it.\n+///\n+/// # Slicing\n+///\n+/// A Vec can be mutable. Slices, on the other hand, are read-only objects.\n+/// To get a slice, use \"&\". Example:\n+///\n+/// ```\n+/// fn read_slice(slice: &[usize]) {\n+///     // ...\n+/// }\n+///\n+/// let v = vec!(0, 1);\n+/// read_slice(&v);\n+///\n+/// // ... and that's all!\n+/// // you can also do it like this:\n+/// let x : &[usize] = &v;\n+/// ```\n+///\n+/// In Rust, it's more common to pass slices as arguments rather than vectors\n+/// when you just want to provide a read access. The same goes for String and\n+/// &str.\n+///\n /// # Capacity and reallocation\n ///\n /// The capacity of a vector is the amount of space allocated for any future"}, {"sha": "fe059076926ee8161ebb736e5d8fa5ad9e260d3f", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -331,9 +331,8 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names {\n-            match self.opt_val(&nm[..]) {\n-                Some(Val(ref s)) => return Some(s.clone()),\n-                _ => (),\n+            if let Some(Val(ref s)) = self.opt_val(&nm[..]) {\n+                  return Some(s.clone())\n             }\n         }\n         None"}, {"sha": "76360dcc1b9725b79c15cb79b2f3877740d9600b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -226,9 +226,8 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> String {\n-    match ccx.type_hashcodes().borrow().get(&t) {\n-        Some(h) => return h.to_string(),\n-        None => {}\n+    if let Some(h) = ccx.type_hashcodes().borrow().get(&t) {\n+        return h.to_string()\n     }\n \n     let mut symbol_hasher = ccx.symbol_hasher().borrow_mut();\n@@ -315,9 +314,8 @@ pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -\n         push(&mut n, &data);\n     }\n \n-    match hash {\n-        Some(s) => push(&mut n, s),\n-        None => {}\n+    if let Some(s) = hash {\n+        push(&mut n, s)\n     }\n \n     n.push('E'); // End name-sequence."}, {"sha": "161ab90c03a73ef992ea40cb3b3f9ad4f1db7e3d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -150,9 +150,8 @@ impl Drop for _InsnCtxt {\n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: {}\", s);\n     TASK_LOCAL_INSN_KEY.with(|slot| {\n-        match slot.borrow_mut().as_mut() {\n-            Some(ctx) => ctx.push(s),\n-            None => {}\n+        if let Some(ctx) = slot.borrow_mut().as_mut() {\n+            ctx.push(s)\n         }\n     });\n     _InsnCtxt {\n@@ -198,9 +197,8 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 name: &str,\n                                 did: DefId)\n                                 -> ValueRef {\n-    match ccx.externs().borrow().get(name) {\n-        Some(n) => return *n,\n-        None => (),\n+    if let Some(n) = ccx.externs().borrow().get(name) {\n+        return *n;\n     }\n \n     let f = declare::declare_rust_fn(ccx, name, fn_ty);\n@@ -238,9 +236,8 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   -> ValueRef {\n     let name = ccx.sess().cstore.item_symbol(did);\n     let ty = type_of(ccx, t);\n-    match ccx.externs().borrow_mut().get(&name) {\n-        Some(n) => return *n,\n-        None => (),\n+    if let Some(n) = ccx.externs().borrow_mut().get(&name) {\n+        return *n;\n     }\n     // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n     // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -2755,9 +2752,8 @@ fn contains_null(s: &str) -> bool {\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{}`)\", id);\n \n-    match ccx.item_vals().borrow().get(&id).cloned() {\n-        Some(v) => return v,\n-        None => {}\n+    if let Some(v) = ccx.item_vals().borrow().get(&id).cloned() {\n+        return v;\n     }\n \n     let item = ccx.tcx().map.get(id);"}, {"sha": "7f7de0e872b6cd3eb617ef764002efbafdbb2ad3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -947,9 +947,8 @@ pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache().borrow().get(&s) {\n-            Some(&llval) => return llval,\n-            None => ()\n+        if let Some(&llval) = cx.const_cstr_cache().borrow().get(&s) {\n+            return llval;\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx(),"}, {"sha": "24a7fd372f63691841672237caf2aa9b29dd9bf8", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -182,9 +182,8 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    match cx.llsizingtypes().borrow().get(&t).cloned() {\n-        Some(t) => return t,\n-        None => ()\n+    if let Some(t) = cx.llsizingtypes().borrow().get(&t).cloned() {\n+        return t;\n     }\n \n     debug!(\"sizing_type_of {:?}\", t);\n@@ -317,9 +316,8 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n /// NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n-    match cx.lltypes().borrow().get(&t) {\n-        Some(&llty) => return llty,\n-        None => ()\n+    if let Some(&llty) = cx.lltypes().borrow().get(&t) {\n+        return llty;\n     }\n \n     debug!(\"type_of {:?}\", t);"}, {"sha": "1b97b3865d4212b1a94cb6de39469ae4a69964b9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -2734,18 +2734,19 @@ fn make_item_keywords(it: &clean::Item) -> String {\n \n fn get_index_search_type(item: &clean::Item,\n                          parent: Option<String>) -> Option<IndexItemFunctionType> {\n-    let decl = match item.inner {\n-        clean::FunctionItem(ref f) => &f.decl,\n-        clean::MethodItem(ref m) => &m.decl,\n-        clean::TyMethodItem(ref m) => &m.decl,\n+    let (decl, selfty) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.decl, None),\n+        clean::MethodItem(ref m) => (&m.decl, Some(&m.self_)),\n+        clean::TyMethodItem(ref m) => (&m.decl, Some(&m.self_)),\n         _ => return None\n     };\n \n     let mut inputs = Vec::new();\n \n     // Consider `self` an argument as well.\n-    if let Some(name) = parent {\n-        inputs.push(Type { name: Some(name.to_ascii_lowercase()) });\n+    match parent.and_then(|p| selfty.map(|s| (p, s)) ) {\n+        Some((_, &clean::SelfStatic)) | None => (),\n+        Some((name, _)) => inputs.push(Type { name: Some(name.to_ascii_lowercase()) }),\n     }\n \n     inputs.extend(&mut decl.inputs.values.iter().map(|arg| {"}, {"sha": "ffb15d157b0666e10bb3948f41344c789af8b95d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -385,9 +385,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         *s.borrow_mut() = analysis.take();\n     });\n \n-    match matches.opt_str(\"crate-name\") {\n-        Some(name) => krate.name = name,\n-        None => {}\n+    if let Some(name) = matches.opt_str(\"crate-name\") {\n+        krate.name = name\n     }\n \n     // Process all of the crate attributes, extracting plugin metadata along"}, {"sha": "78da9412212a9caf3cfc72909268004464178241", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -467,9 +467,8 @@ impl ToSocketAddrs for str {\n     type Iter = vec::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n         // try to parse as a regular SocketAddr first\n-        match self.parse().ok() {\n-            Some(addr) => return Ok(vec![addr].into_iter()),\n-            None => {}\n+        if let Some(addr) = self.parse().ok() {\n+            return Ok(vec![addr].into_iter());\n         }\n \n         macro_rules! try_opt {"}, {"sha": "63eee6bcfded5fa5afef655d197f649f6b4d80e4", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -66,9 +66,8 @@ impl<'a> Parser<'a> {\n     fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])\n                -> Option<T> {\n         for pf in parsers {\n-            match self.read_atomically(|p: &mut Parser| pf(p)) {\n-                Some(r) => return Some(r),\n-                None => {}\n+            if let Some(r) = self.read_atomically(|p: &mut Parser| pf(p)) {\n+                return Some(r);\n             }\n         }\n         None"}, {"sha": "e5819522123c409b7de1b227911afede51bf0c74", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -12,6 +12,50 @@\n //\n /// The boolean type.\n ///\n+/// The `bool` represents a value, which could only be either `true` or `false`.\n+///\n+/// # Basic usage\n+///\n+/// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n+/// which allow us to perform boolean operations using `&`, `|` and `!`.\n+///\n+/// [`if`] always demands a `bool` value. [`assert!`], being an important macro in testing,\n+/// checks whether an expression returns `true`.\n+///\n+/// ```\n+/// let bool_val = true & false | false;\n+/// assert!(!bool_val);\n+/// ```\n+///\n+/// [`assert!`]: std/macro.assert!.html\n+/// [`if` conditionals]: ../../book/if.html\n+/// [`BitAnd`]: ../ops/trait.BitAnd.html\n+/// [`BitOr`]: ../ops/trait.BitOr.html\n+/// [`Not`]: ../ops/trait.Not.html\n+///\n+/// # Examples\n+///\n+/// A trivial example of the usage of `bool`,\n+///\n+/// ```\n+/// let praise_the_borrow_checker = true;\n+///\n+/// // using the `if` conditional\n+/// if praise_the_borrow_checker {\n+///     println!(\"oh, yeah!\");\n+/// } else {\n+///     println!(\"what?!!\");\n+/// }\n+///\n+/// // ... or, a match pattern\n+/// match praise_the_borrow_checker {\n+///     true => println!(\"keep praising!\"),\n+///     false => println!(\"you should praise!\"),\n+/// }\n+/// ```\n+///\n+/// Also, since `bool` implements the [`Copy`](../marker/trait.Copy.html) trait, we don't\n+/// have to worry about the move semantics (just like the integer and float primitives).\n mod prim_bool { }\n \n #[doc(primitive = \"char\")]\n@@ -533,4 +577,3 @@ mod prim_isize { }\n /// *[See also the `std::usize` module](usize/index.html).*\n ///\n mod prim_usize { }\n-"}, {"sha": "59da74b728797cdc20457187c77ed379222575e9", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f050d09003a4c7895f44fed3a7c6cdce8f2949/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=f6f050d09003a4c7895f44fed3a7c6cdce8f2949", "patch": "@@ -69,9 +69,8 @@ static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n     let key = c::TlsAlloc();\n     assert!(key != c::TLS_OUT_OF_INDEXES);\n-    match dtor {\n-        Some(f) => register_dtor(key, f),\n-        None => {}\n+    if let Some(f) = dtor {\n+        register_dtor(key, f);\n     }\n     return key;\n }"}]}