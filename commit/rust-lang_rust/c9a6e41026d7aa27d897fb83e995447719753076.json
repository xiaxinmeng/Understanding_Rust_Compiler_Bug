{"sha": "c9a6e41026d7aa27d897fb83e995447719753076", "node_id": "C_kwDOAAsO6NoAKGM5YTZlNDEwMjZkN2FhMjdkODk3ZmI4M2U5OTU0NDc3MTk3NTMwNzY", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-03-22T21:56:09Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-04-16T15:35:44Z"}, "message": "Report allocation errors as panics", "tree": {"sha": "8660763bab337b55353ba589fe1b202dc8fe4bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8660763bab337b55353ba589fe1b202dc8fe4bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9a6e41026d7aa27d897fb83e995447719753076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a6e41026d7aa27d897fb83e995447719753076", "html_url": "https://github.com/rust-lang/rust/commit/c9a6e41026d7aa27d897fb83e995447719753076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9a6e41026d7aa27d897fb83e995447719753076/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "281648698693def16f1985ca85948f5efc7e9e3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/281648698693def16f1985ca85948f5efc7e9e3f", "html_url": "https://github.com/rust-lang/rust/commit/281648698693def16f1985ca85948f5efc7e9e3f"}], "stats": {"total": 134, "additions": 107, "deletions": 27}, "files": [{"sha": "8975ba3f06bbf8dd2763b7c67deea16797c6e851", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -35,3 +35,6 @@ compiler-builtins-mem = ['compiler_builtins/mem']\n compiler-builtins-c = [\"compiler_builtins/c\"]\n compiler-builtins-no-asm = [\"compiler_builtins/no-asm\"]\n compiler-builtins-mangled-names = [\"compiler_builtins/mangled-names\"]\n+\n+# Make panics and failed asserts immediately abort without formatting any message\n+panic_immediate_abort = [\"core/panic_immediate_abort\"]"}, {"sha": "08c65a96bc74434bed3708d67ad945e32a160761", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -14,6 +14,11 @@ use core::ptr::{self, NonNull};\n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(not(no_global_oom_handling))]\n+use core::any::Any;\n+#[cfg(not(no_global_oom_handling))]\n+use core::panic::BoxMeUp;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -343,14 +348,77 @@ pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A)\n     }\n }\n \n-// # Allocation error handler\n+/// Payload passed to the panic handler when `handle_alloc_error` is called.\n+#[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n+#[derive(Debug)]\n+pub struct AllocErrorPanicPayload {\n+    layout: Layout,\n+}\n+\n+impl AllocErrorPanicPayload {\n+    /// Internal function for the standard library to clone a payload.\n+    #[unstable(feature = \"std_internals\", issue = \"none\")]\n+    #[doc(hidden)]\n+    pub fn internal_clone(&self) -> Self {\n+        AllocErrorPanicPayload { layout: self.layout }\n+    }\n \n+    /// Returns the [`Layout`] of the allocation attempt that caused the error.\n+    #[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n+    pub fn layout(&self) -> Layout {\n+        self.layout\n+    }\n+}\n+\n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n #[cfg(not(no_global_oom_handling))]\n-extern \"Rust\" {\n-    // This is the magic symbol to call the global alloc error handler. rustc generates\n-    // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n-    // default implementations below (`__rdl_oom`) otherwise.\n-    fn __rust_alloc_error_handler(size: usize, align: usize) -> !;\n+unsafe impl BoxMeUp for AllocErrorPanicPayload {\n+    fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+        use crate::boxed::Box;\n+        Box::into_raw(Box::new(self.internal_clone()))\n+    }\n+\n+    fn get(&mut self) -> &(dyn Any + Send) {\n+        self\n+    }\n+}\n+\n+// # Allocation error handler\n+\n+#[cfg(all(not(no_global_oom_handling), not(test)))]\n+fn rust_oom(layout: Layout) -> ! {\n+    if cfg!(feature = \"panic_immediate_abort\") {\n+        core::intrinsics::abort()\n+    }\n+\n+    extern \"Rust\" {\n+        // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+        // that gets resolved to the `#[panic_handler]` function.\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !;\n+\n+        // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n+        // Its value depends on the -Zoom={panic,abort} compiler option.\n+        static __rust_alloc_error_handler_should_panic: u8;\n+    }\n+\n+    // Hack to work around issues with the lifetime of Arguments.\n+    match format_args!(\"memory allocation of {} bytes failed\", layout.size()) {\n+        fmt => {\n+            // Create a PanicInfo with a custom payload for the panic handler.\n+            let can_unwind = unsafe { __rust_alloc_error_handler_should_panic != 0 };\n+            let mut pi = core::panic::PanicInfo::internal_constructor(\n+                Some(&fmt),\n+                core::panic::Location::caller(),\n+                can_unwind,\n+            );\n+            let payload = AllocErrorPanicPayload { layout };\n+            pi.set_payload(&payload);\n+\n+            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n+            unsafe { panic_impl(&pi) }\n+        }\n+    }\n }\n \n /// Abort on memory allocation error or failure.\n@@ -375,9 +443,7 @@ pub const fn handle_alloc_error(layout: Layout) -> ! {\n     }\n \n     fn rt_error(layout: Layout) -> ! {\n-        unsafe {\n-            __rust_alloc_error_handler(layout.size(), layout.align());\n-        }\n+        rust_oom(layout);\n     }\n \n     unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }"}, {"sha": "146e366013f3007b9c7f2dad6cfc4d4f49bc17da", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -136,6 +136,7 @@\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n+#![feature(panic_internals)]\n #![feature(pattern)]\n #![feature(pointer_byte_offsets)]\n #![feature(provide_any)]"}, {"sha": "cbd259e67730909fedd01270236f4f2fa8c281c5", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -67,7 +67,7 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n system-llvm-libunwind = [\"unwind/system-llvm-libunwind\"]\n \n # Make panics and failed asserts immediately abort without formatting any message\n-panic_immediate_abort = [\"core/panic_immediate_abort\"]\n+panic_immediate_abort = [\"alloc/panic_immediate_abort\"]\n \n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml"}, {"sha": "109d6331ade93adb7c2a46d5f191564ab244a50b", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -319,6 +319,7 @@\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]\n #![feature(new_uninit)]\n+#![feature(panic_oom_payload)]\n #![feature(slice_concat_trait)]\n #![feature(thin_box)]\n #![feature(try_reserve_kind)]"}, {"sha": "ca4cf68ad54e2e89bdad843f2320b8e7d1883b0c", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a6e41026d7aa27d897fb83e995447719753076/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=c9a6e41026d7aa27d897fb83e995447719753076", "patch": "@@ -245,19 +245,24 @@ fn default_hook(info: &PanicInfo<'_>) {\n \n     // The current implementation always returns `Some`.\n     let location = info.location().unwrap();\n-\n-    let msg = match info.payload().downcast_ref::<&'static str>() {\n-        Some(s) => *s,\n-        None => match info.payload().downcast_ref::<String>() {\n-            Some(s) => &s[..],\n-            None => \"Box<dyn Any>\",\n-        },\n-    };\n     let thread = thread_info::current_thread();\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut dyn crate::io::Write| {\n-        let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n+        // Use the panic message directly if available, otherwise take it from\n+        // the payload.\n+        if let Some(msg) = info.message() {\n+            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n+        } else {\n+            let msg = if let Some(s) = info.payload().downcast_ref::<&'static str>() {\n+                *s\n+            } else if let Some(s) = info.payload().downcast_ref::<String>() {\n+                &s[..]\n+            } else {\n+                \"Box<dyn Any>\"\n+            };\n+            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n+        }\n \n         static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n@@ -524,6 +529,8 @@ pub fn panicking() -> bool {\n #[cfg(not(test))]\n #[panic_handler]\n pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n+    use alloc::alloc::AllocErrorPanicPayload;\n+\n     struct PanicPayload<'a> {\n         inner: &'a fmt::Arguments<'a>,\n         string: Option<String>,\n@@ -550,8 +557,7 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             // We do two allocations here, unfortunately. But (a) they're required with the current\n-            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n-            // begin_panic below).\n+            // scheme, and (b) OOM uses its own separate payload type which doesn't allocate.\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -576,7 +582,14 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        if let Some(msg) = msg.as_str() {\n+        if let Some(payload) = info.payload().downcast_ref::<AllocErrorPanicPayload>() {\n+            rust_panic_with_hook(\n+                &mut payload.internal_clone(),\n+                info.message(),\n+                loc,\n+                info.can_unwind(),\n+            );\n+        } else if let Some(msg) = msg.as_str() {\n             rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc, info.can_unwind());\n         } else {\n             rust_panic_with_hook(\n@@ -623,11 +636,7 @@ pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n-            // Note that this should be the only allocation performed in this code path. Currently\n-            // this means that panic!() on OOM will invoke this code path, but then again we're not\n-            // really ready for panic on OOM anyway. If we do start doing this, then we should\n-            // propagate this allocation to be performed in the parent of this thread instead of the\n-            // thread that's panicking.\n+            // Note that this should be the only allocation performed in this code path.\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                 None => process::abort(),"}]}