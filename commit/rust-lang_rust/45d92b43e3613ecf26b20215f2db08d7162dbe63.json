{"sha": "45d92b43e3613ecf26b20215f2db08d7162dbe63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDkyYjQzZTM2MTNlY2YyNmIyMDIxNWYyZGIwOGQ3MTYyZGJlNjM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-23T07:24:58Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-23T07:24:58Z"}, "message": "merge `need_type_info_err(_const)`", "tree": {"sha": "aed5219b0283dc45e0af28cfb844ac513cdcbb47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed5219b0283dc45e0af28cfb844ac513cdcbb47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d92b43e3613ecf26b20215f2db08d7162dbe63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d92b43e3613ecf26b20215f2db08d7162dbe63", "html_url": "https://github.com/rust-lang/rust/commit/45d92b43e3613ecf26b20215f2db08d7162dbe63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d92b43e3613ecf26b20215f2db08d7162dbe63/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0bc267512fc0cb49c86978192857e8187017f0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0bc267512fc0cb49c86978192857e8187017f0b", "html_url": "https://github.com/rust-lang/rust/commit/e0bc267512fc0cb49c86978192857e8187017f0b"}], "stats": {"total": 279, "additions": 148, "deletions": 131}, "files": [{"sha": "f17492674ab4c9440dde77c68f1ebec16cd7615b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 117, "deletions": 87, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -176,7 +176,10 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+    err.span_label(\n+        span,\n+        InferCtxt::missing_type_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+    );\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -220,60 +223,119 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_type_name(\n         &self,\n-        ty: Ty<'tcx>,\n+        arg: GenericArg<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n-        if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = &inner.type_variables();\n-            let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n-                let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id {\n-                    let parent_name = self\n-                        .tcx\n-                        .def_key(parent_def_id)\n-                        .disambiguated_data\n-                        .data\n-                        .get_opt_name()\n-                        .map(|parent_symbol| parent_symbol.to_string());\n-\n-                    (parent_name, Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)))\n-                } else {\n-                    (None, None)\n-                };\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => {\n+                if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n+                    let mut inner = self.inner.borrow_mut();\n+                    let ty_vars = &inner.type_variables();\n+                    let var_origin = ty_vars.var_origin(ty_vid);\n+                    if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) =\n+                        var_origin.kind\n+                    {\n+                        let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n+                        let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id\n+                        {\n+                            let parent_name = self\n+                                .tcx\n+                                .def_key(parent_def_id)\n+                                .disambiguated_data\n+                                .data\n+                                .get_opt_name()\n+                                .map(|parent_symbol| parent_symbol.to_string());\n+\n+                            (\n+                                parent_name,\n+                                Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                            )\n+                        } else {\n+                            (None, None)\n+                        };\n+\n+                        if name != kw::SelfUpper {\n+                            return (\n+                                name.to_string(),\n+                                Some(var_origin.span),\n+                                \"type parameter\".into(),\n+                                parent_name,\n+                                parent_desc,\n+                            );\n+                        }\n+                    }\n+                }\n \n-                if name != kw::SelfUpper {\n-                    return (\n-                        name.to_string(),\n-                        Some(var_origin.span),\n-                        \"type parameter\".into(),\n-                        parent_name,\n-                        parent_desc,\n-                    );\n+                let mut s = String::new();\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+                if let Some(highlight) = highlight {\n+                    printer.region_highlight_mode = highlight;\n                 }\n+                let _ = ty.print(printer);\n+                (s, None, ty.prefix_string(), None, None)\n             }\n-        }\n+            GenericArgKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n+                    let origin =\n+                        self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+                    if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n+                        origin.kind\n+                    {\n+                        let parent_def_id = self.tcx.parent(def_id);\n+                        let (parent_name, parent_descr) = if let Some(parent_def_id) = parent_def_id\n+                        {\n+                            let parent_name = self\n+                                .tcx\n+                                .def_key(parent_def_id)\n+                                .disambiguated_data\n+                                .data\n+                                .get_opt_name()\n+                                .map(|parent_symbol| parent_symbol.to_string());\n+\n+                            (\n+                                parent_name,\n+                                Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                            )\n+                        } else {\n+                            (None, None)\n+                        };\n+\n+                        return (\n+                            name.to_string(),\n+                            Some(origin.span),\n+                            \"const parameter\".into(),\n+                            parent_name,\n+                            parent_descr,\n+                        );\n+                    }\n+                }\n \n-        let mut s = String::new();\n-        let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-        if let Some(highlight) = highlight {\n-            printer.region_highlight_mode = highlight;\n+                let mut s = String::new();\n+                let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n+                if let Some(highlight) = highlight {\n+                    printer.region_highlight_mode = highlight;\n+                }\n+                let _ = ct.print(printer);\n+                (s, None, \"<TODO>\".into(), None, None)\n+            }\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         }\n-        let _ = ty.print(printer);\n-        (s, None, ty.prefix_string(), None, None)\n     }\n \n-    // FIXME(eddyb) generalize all of this to handle `ty::Const` inference variables as well.\n     pub fn need_type_info_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        ty: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(ty, None);\n+        let kind_str = match ty.unpack() {\n+            GenericArgKind::Type(_) => \"type\",\n+            GenericArgKind::Const(_) => \"the value\",\n+            GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n+        };\n \n         let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -545,55 +607,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr),\n+                InferCtxt::missing_type_msg(kind_str, &name, &descr, parent_name, parent_descr),\n             );\n         }\n \n         err\n     }\n \n-    // FIXME(const_generics): We should either try and merge this with `need_type_info_err`\n-    // or improve the errors created here.\n-    //\n-    // Unlike for type inference variables, we don't yet store the origin of const inference variables.\n-    // This is needed for to get a more relevant error span.\n-    pub fn need_type_info_err_const(\n-        &self,\n-        body_id: Option<hir::BodyId>,\n-        span: Span,\n-        ct: &'tcx ty::Const<'tcx>,\n-        error_code: TypeAnnotationNeeded,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ct.into(), span);\n-        if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n-            local_visitor.visit_expr(expr);\n-        }\n-\n-        let mut param_name = None;\n-        let span = if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n-            let origin = self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n-            if let ConstVariableOriginKind::ConstParameterDefinition(param) = origin.kind {\n-                param_name = Some(param);\n-            }\n-            origin.span\n-        } else {\n-            local_visitor.target_span\n-        };\n-\n-        let error_code = error_code.into();\n-        let mut err =\n-            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n-\n-        if let Some(param_name) = param_name {\n-            err.note(&format!(\"cannot infer the value of the const parameter `{}`\", param_name));\n-        } else {\n-            err.note(\"unable to infer the value of a const parameter\");\n-        }\n-\n-        err\n-    }\n-\n     /// If the `FnSig` for the method call can be found and type arguments are identified as\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n@@ -647,7 +667,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(ty.into(), None);\n \n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -656,18 +676,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(span, InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr));\n+        err.span_label(\n+            span,\n+            InferCtxt::missing_type_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+        );\n         err\n     }\n \n     fn missing_type_msg(\n+        kind_str: &str,\n         type_name: &str,\n         descr: &str,\n         parent_name: Option<String>,\n         parent_descr: Option<&str>,\n-    ) -> Cow<'static, str> {\n+    ) -> String {\n         if type_name == \"_\" {\n-            \"cannot infer type\".into()\n+            format!(\"cannot infer {}\", kind_str)\n         } else {\n             let parent_desc = if let Some(parent_name) = parent_name {\n                 let parent_type_descr = if let Some(parent_descr) = parent_descr {\n@@ -681,7 +705,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 \"\".to_string()\n             };\n \n-            format!(\"cannot infer type for {} `{}`{}\", descr, type_name, parent_desc).into()\n+            let preposition = if \"value\" == kind_str { \"of\" } else { \"for\" };\n+            // For example: \"cannot infer type for type parameter `T`\"\n+            format!(\n+                \"cannot infer {} {} {} `{}`{}\",\n+                kind_str, preposition, descr, type_name, parent_desc\n+            )\n+            .into()\n         }\n     }\n }"}, {"sha": "d7bfab8a7f85de483b3040fa2ce148163069a1c2", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -1163,7 +1163,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             GenericParamDefKind::Const { .. } => {\n                 let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(\n+                        param.name,\n+                        param.def_id,\n+                    ),\n                     span,\n                 };\n                 let const_var_id ="}, {"sha": "499f92b4041161b8bba9fd1d5ecf827e98403365", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify::{\n     self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n };\n+use rustc_span::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -124,8 +125,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n-    // FIXME(const_generics): Consider storing the `DefId` of the param here.\n-    ConstParameterDefinition(Symbol),\n+    ConstParameterDefinition(Symbol, DefId),\n     SubstitutionPlaceholder,\n }\n "}, {"sha": "d96020fe36106181ada2046aac45203b70b03b70", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -396,7 +396,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(&ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(ty.into(), Some(highlight)).0;\n \n         debug!(\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -646,7 +646,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(return_ty.into(), Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n \n@@ -698,7 +698,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(yield_ty.into(), Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n "}, {"sha": "4cc9a1ecdc81ba0cb9344fc6218b5d1e20669d90", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -20,7 +20,6 @@ use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n     TypeFoldable, WithConstness,\n@@ -1513,10 +1512,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    self.need_type_info_err(body_id, span, self_ty.into(), ErrorCode::E0282).emit();\n                     return;\n                 }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                let mut err =\n+                    self.need_type_info_err(body_id, span, self_ty.into(), ErrorCode::E0283);\n                 err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                 if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n@@ -1580,17 +1580,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match arg.unpack() {\n-                    GenericArgKind::Lifetime(lt) => {\n-                        span_bug!(span, \"unexpected well formed predicate: {:?}\", lt)\n-                    }\n-                    GenericArgKind::Type(ty) => {\n-                        self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n-                    }\n-                    GenericArgKind::Const(ct) => {\n-                        self.need_type_info_err_const(body_id, span, ct, ErrorCode::E0282)\n-                    }\n-                }\n+                self.need_type_info_err(body_id, span, arg, ErrorCode::E0282)\n             }\n \n             ty::PredicateAtom::Subtype(data) => {\n@@ -1601,7 +1591,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n-                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+                self.need_type_info_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n                 let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n@@ -1612,7 +1602,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n                 if self_ty.needs_infer() && ty.needs_infer() {\n                     // We do this for the `foo.collect()?` case to produce a suggestion.\n-                    let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                    let mut err =\n+                        self.need_type_info_err(body_id, span, self_ty.into(), ErrorCode::E0284);\n                     err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                     err\n                 } else {"}, {"sha": "31010753474bed791c01ec6725813fab80f8a065", "filename": "compiler/rustc_typeck/src/check/fn_ctxt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2991,7 +2991,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.need_type_info_err((**self).body_id, sp, ty, E0282)\n+                self.need_type_info_err((**self).body_id, sp, ty.into(), E0282)\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }"}, {"sha": "ccff9b5cdb4b4562a51b87f7e69695c7175c059c", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -653,18 +653,23 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn report_type_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(self.tcx), t, E0282)\n+                .need_type_info_err(\n+                    Some(self.body.id()),\n+                    self.span.to_span(self.tcx),\n+                    t.into(),\n+                    E0282,\n+                )\n                 .emit();\n         }\n     }\n \n     fn report_const_error(&self, c: &'tcx ty::Const<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err_const(\n+                .need_type_info_err(\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n-                    c,\n+                    c.into(),\n                     E0282,\n                 )\n                 .emit();"}, {"sha": "a5f7705804e026b4f22763010d513b46c8b02d21", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:12:5\n    |\n LL |     foo();\n-   |     ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `X`\n+   |     ^^^ cannot infer the value for const parameter `X` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "a5f7705804e026b4f22763010d513b46c8b02d21", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:12:5\n    |\n LL |     foo();\n-   |     ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `X`\n+   |     ^^^ cannot infer the value for const parameter `X` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "0344b364166d7ba2cc26b1597777e47a5e0d6944", "filename": "src/test/ui/const-generics/infer/method-chain.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/method-chain.rs:21:33\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n-   |                                 ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |                                 ^^^ cannot infer the value for const parameter `N` declared on the associated function `baz`\n \n error: aborting due to previous error\n "}, {"sha": "0344b364166d7ba2cc26b1597777e47a5e0d6944", "filename": "src/test/ui/const-generics/infer/method-chain.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/method-chain.rs:21:33\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n-   |                                 ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |                                 ^^^ cannot infer the value for const parameter `N` declared on the associated function `baz`\n \n error: aborting due to previous error\n "}, {"sha": "47ffc7e7157cc0708b49376b079a7804b5c36ae3", "filename": "src/test/ui/const-generics/infer/uninferred-consts.full.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |         ^^^ cannot infer the value for const parameter `N` declared on the associated function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "47ffc7e7157cc0708b49376b079a7804b5c36ae3", "filename": "src/test/ui/const-generics/infer/uninferred-consts.min.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45d92b43e3613ecf26b20215f2db08d7162dbe63/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr?ref=45d92b43e3613ecf26b20215f2db08d7162dbe63", "patch": "@@ -2,9 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |         ^^^\n-   |\n-   = note: cannot infer the value of the const parameter `N`\n+   |         ^^^ cannot infer the value for const parameter `N` declared on the associated function `foo`\n \n error: aborting due to previous error\n "}]}