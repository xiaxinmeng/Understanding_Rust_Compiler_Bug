{"sha": "35598b4595ec6b7ae4ea6c0244f775651366fe9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NTk4YjQ1OTVlYzZiN2FlNGVhNmMwMjQ0Zjc3NTY1MTM2NmZlOWU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-03T23:43:56Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-04T00:01:32Z"}, "message": "De-export net::*. Part of #3583.", "tree": {"sha": "29ca15318fba2226ad8735404eeab8bf4f53a053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29ca15318fba2226ad8735404eeab8bf4f53a053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35598b4595ec6b7ae4ea6c0244f775651366fe9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35598b4595ec6b7ae4ea6c0244f775651366fe9e", "html_url": "https://github.com/rust-lang/rust/commit/35598b4595ec6b7ae4ea6c0244f775651366fe9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35598b4595ec6b7ae4ea6c0244f775651366fe9e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53906bb4fb9b2a99878fc6a5cc5cc174ffdea25c", "url": "https://api.github.com/repos/rust-lang/rust/commits/53906bb4fb9b2a99878fc6a5cc5cc174ffdea25c", "html_url": "https://github.com/rust-lang/rust/commit/53906bb4fb9b2a99878fc6a5cc5cc174ffdea25c"}], "stats": {"total": 137, "additions": 46, "deletions": 91}, "files": [{"sha": "76a5955c3e196273ffae53ebbfd54a01596fed15", "filename": "src/libstd/net.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=35598b4595ec6b7ae4ea6c0244f775651366fe9e", "patch": "@@ -1,10 +1,5 @@\n //! Top-level module for network-related functionality\n \n-use tcp = net_tcp;\n-export tcp;\n-\n-use ip = net_ip;\n-export ip;\n-\n-use url = net_url;\n-export url;\n\\ No newline at end of file\n+pub use tcp = net_tcp;\n+pub use ip = net_ip;\n+pub use url = net_url;"}, {"sha": "2d9dd5bdf4e83a5f8d069dc7b60dd223d098fad3", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=35598b4595ec6b7ae4ea6c0244f775651366fe9e", "patch": "@@ -20,14 +20,8 @@ use get_data_for_req = uv::ll::get_data_for_req;\n use ll = uv::ll;\n use comm = core::comm;\n \n-export IpAddr, parse_addr_err;\n-export format_addr;\n-export v4, v6;\n-export get_addr;\n-export Ipv4, Ipv6;\n-\n /// An IP address\n-enum IpAddr {\n+pub enum IpAddr {\n     /// An IPv4 address\n     Ipv4(sockaddr_in),\n     Ipv6(sockaddr_in6)\n@@ -45,7 +39,7 @@ type ParseAddrErr = {\n  *\n  * * ip - a `std::net::ip::ip_addr`\n  */\n-fn format_addr(ip: &IpAddr) -> ~str {\n+pub fn format_addr(ip: &IpAddr) -> ~str {\n     match *ip {\n       Ipv4(ref addr) =>  unsafe {\n         let result = uv_ip4_name(addr);\n@@ -83,7 +77,7 @@ enum IpGetAddrErr {\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n  */\n-fn get_addr(node: &str, iotask: iotask)\n+pub fn get_addr(node: &str, iotask: iotask)\n         -> result::Result<~[IpAddr], IpGetAddrErr> {\n     do core::comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| unsafe {\n@@ -116,8 +110,7 @@ fn get_addr(node: &str, iotask: iotask)\n     }\n }\n \n-mod v4 {\n-    #[legacy_exports];\n+pub mod v4 {\n     /**\n      * Convert a str to `ip_addr`\n      *\n@@ -133,17 +126,17 @@ mod v4 {\n      *\n      * * an `ip_addr` of the `ipv4` variant\n      */\n-    fn parse_addr(ip: &str) -> IpAddr {\n+    pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(copy addr) => addr,\n           result::Err(ref err_data) => fail err_data.err_msg\n         }\n     }\n     // the simple, old style numberic representation of\n     // ipv4\n-    type Ipv4Rep = { a: u8, b: u8, c: u8, d:u8 };\n+    pub type Ipv4Rep = { a: u8, b: u8, c: u8, d:u8 };\n \n-    trait AsUnsafeU32 {\n+    pub trait AsUnsafeU32 {\n         unsafe fn as_u32() -> u32;\n     }\n \n@@ -153,7 +146,7 @@ mod v4 {\n             *((ptr::addr_of(&self)) as *u32)\n         }\n     }\n-    fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n+    pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             match uint::from_str(*s) {\n               Some(n) if n <= 255 => n,\n@@ -171,7 +164,7 @@ mod v4 {\n                         c: parts[2] as u8, d: parts[3] as u8})\n         }\n     }\n-    fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n+    pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n         unsafe {\n             let INADDR_NONE = ll::get_INADDR_NONE();\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n@@ -203,8 +196,7 @@ mod v4 {\n         }\n     }\n }\n-mod v6 {\n-    #[legacy_exports];\n+pub mod v6 {\n     /**\n      * Convert a str to `ip_addr`\n      *\n@@ -220,13 +212,13 @@ mod v6 {\n      *\n      * * an `ip_addr` of the `ipv6` variant\n      */\n-    fn parse_addr(ip: &str) -> IpAddr {\n+    pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(copy addr) => addr,\n           result::Err(copy err_data) => fail err_data.err_msg\n         }\n     }\n-    fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n+    pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n         unsafe {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(str::from_slice(ip), 22);\n@@ -251,7 +243,7 @@ type GetAddrData = {\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n-                     res: *addrinfo) unsafe {\n+                      res: *addrinfo) unsafe {\n     log(debug, ~\"in get_addr_cb\");\n     let handle_data = get_data_for_req(handle) as\n         *GetAddrData;\n@@ -311,7 +303,6 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n         let localhost_str = ~\"127.0.0.1\";"}, {"sha": "546231da6333e1ff3f366c653fb347a034c7a1d0", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=35598b4595ec6b7ae4ea6c0244f775651366fe9e", "patch": "@@ -11,22 +11,8 @@ use libc::size_t;\n use io::{Reader, ReaderUtil, Writer};\n use comm = core::comm;\n \n-// tcp interfaces\n-export TcpSocket;\n-// buffered socket\n-export TcpSocketBuf, socket_buf;\n-// errors\n-export TcpErrData, TcpConnectErrData;\n-// operations on a tcp_socket\n-export write, write_future, read_start, read_stop;\n-// tcp server stuff\n-export listen, accept;\n-// tcp client stuff\n-export connect;\n-\n #[nolink]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_uv_current_kernel_malloc(size: libc::c_uint) -> *libc::c_void;\n     fn rust_uv_current_kernel_free(mem: *libc::c_void);\n     fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n@@ -48,7 +34,7 @@ struct TcpSocket {\n   }\n }\n \n-fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n+pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n     TcpSocket {\n         socket_data: socket_data\n     }\n@@ -64,14 +50,14 @@ struct TcpSocketBuf {\n     data: @TcpBufferedSocketData,\n }\n \n-fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n+pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n     TcpSocketBuf {\n         data: data\n     }\n }\n \n /// Contains raw, string-based, error information returned from libuv\n-type TcpErrData = {\n+pub type TcpErrData = {\n     err_name: ~str,\n     err_msg: ~str\n };\n@@ -103,7 +89,7 @@ enum TcpListenErrData {\n     AccessDenied\n }\n /// Details returned as part of a `result::err` result from `tcp::connect`\n-enum TcpConnectErrData {\n+pub enum TcpConnectErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n      * to libuv's `err_name` and `err_msg` fields, respectively.\n@@ -129,7 +115,7 @@ enum TcpConnectErrData {\n  * the remote host. In the event of failure, a\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n-fn connect(input_ip: ip::IpAddr, port: uint,\n+pub fn connect(input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n     let result_po = core::comm::Port::<ConnAttempt>();\n@@ -262,7 +248,7 @@ fn connect(input_ip: ip::IpAddr, port: uint,\n  * A `result` object with a `nil` value as the `ok` variant, or a\n  * `tcp_err_data` value as the `err` variant\n  */\n-fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n+pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> unsafe {\n     let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n     write_common_impl(socket_data_ptr, raw_write_data)\n@@ -299,7 +285,7 @@ fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n  * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n  * value as the `err` variant\n  */\n-fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n+pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>> unsafe {\n     let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n     do future_spawn {\n@@ -323,7 +309,7 @@ fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * optionally, loop on) from until `read_stop` is called, or a\n  * `tcp_err_data` record\n  */\n-fn read_start(sock: &TcpSocket)\n+pub fn read_start(sock: &TcpSocket)\n     -> result::Result<comm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n@@ -337,7 +323,7 @@ fn read_start(sock: &TcpSocket)\n  *\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n-fn read_stop(sock: &TcpSocket,\n+pub fn read_stop(sock: &TcpSocket,\n              +read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n@@ -472,7 +458,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  * this function will return a `net::tcp::tcp_err_data` record\n  * as the `err` variant of a `result`.\n  */\n-fn accept(new_conn: TcpNewConnection)\n+pub fn accept(new_conn: TcpNewConnection)\n     -> result::Result<TcpSocket, TcpErrData> unsafe {\n \n     match new_conn{\n@@ -570,7 +556,7 @@ fn accept(new_conn: TcpNewConnection)\n  * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n  * of listen exiting because of an error\n  */\n-fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n+pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n           +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n           +new_connect_cb: fn~(TcpNewConnection,\n@@ -728,17 +714,17 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  *\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n-fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n+pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@{ sock: move sock, mut buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl TcpSocket {\n-    fn read_start() -> result::Result<comm::Port<\n+    pub fn read_start() -> result::Result<comm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(&self)\n     }\n-    fn read_stop(read_port:\n+    pub fn read_stop(read_port:\n                  comm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n         read_stop(&self, move read_port)\n@@ -751,11 +737,11 @@ impl TcpSocket {\n         future::Future<result::Result<~[u8], TcpErrData>> {\n         read_future(&self, timeout_msecs)\n     }\n-    fn write(raw_write_data: ~[u8])\n+    pub fn write(raw_write_data: ~[u8])\n         -> result::Result<(), TcpErrData> {\n         write(&self, raw_write_data)\n     }\n-    fn write_future(raw_write_data: ~[u8])\n+    pub fn write_future(raw_write_data: ~[u8])\n         -> future::Future<result::Result<(), TcpErrData>> {\n         write_future(&self, raw_write_data)\n     }\n@@ -816,7 +802,7 @@ impl TcpSocketBuf: io::Reader {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Writer {\n-    fn write(data: &[const u8]) unsafe {\n+    pub fn write(data: &[const u8]) unsafe {\n         let socket_data_ptr =\n             ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n         let w_result = write_common_impl(socket_data_ptr,\n@@ -1224,16 +1210,13 @@ type TcpBufferedSocketData = {\n \n //#[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n     mod tcp_ipv4_server_and_client_test {\n-        #[legacy_exports];\n         #[cfg(target_arch=\"x86_64\")]\n         mod impl64 {\n-            #[legacy_exports];\n             #[test]\n             fn test_gl_tcp_server_and_client_ipv4() unsafe {\n                 impl_gl_tcp_ipv4_server_and_client();\n@@ -1258,7 +1241,6 @@ mod test {\n         }\n         #[cfg(target_arch=\"x86\")]\n         mod impl32 {\n-            #[legacy_exports];\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n             fn test_gl_tcp_server_and_client_ipv4() unsafe {"}, {"sha": "40c9f96f5e84c0c83ab3f2c23477ddd2ebf68d03", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=35598b4595ec6b7ae4ea6c0244f775651366fe9e", "patch": "@@ -10,15 +10,6 @@ use result::{Err, Ok};\n use to_str::ToStr;\n use to_bytes::IterBytes;\n \n-export Url, Query;\n-export from_str, to_str;\n-export get_scheme;\n-export query_to_str;\n-\n-export encode, decode;\n-export encode_component, decode_component;\n-export encode_form_urlencoded, decode_form_urlencoded;\n-\n struct Url {\n     scheme: ~str,\n     user: Option<UserInfo>,\n@@ -34,9 +25,9 @@ type UserInfo = {\n     pass: Option<~str>\n };\n \n-type Query = ~[(~str, ~str)];\n+pub type Query = ~[(~str, ~str)];\n \n-fn Url(scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n+pub fn Url(scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n        +port: Option<~str>, +path: ~str, +query: Query,\n        +fragment: Option<~str>) -> Url {\n     Url { scheme: move scheme, user: move user, host: move host,\n@@ -93,7 +84,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n-fn encode(s: &str) -> ~str {\n+pub fn encode(s: &str) -> ~str {\n     encode_inner(s, true)\n }\n \n@@ -103,7 +94,7 @@ fn encode(s: &str) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n-fn encode_component(s: &str) -> ~str {\n+pub fn encode_component(s: &str) -> ~str {\n     encode_inner(s, false)\n }\n \n@@ -150,14 +141,14 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This will only decode escape sequences generated by encode_uri.\n  */\n-fn decode(s: &str) -> ~str {\n+pub fn decode(s: &str) -> ~str {\n     decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-fn decode_component(s: &str) -> ~str {\n+pub fn decode_component(s: &str) -> ~str {\n     decode_inner(s, false)\n }\n \n@@ -183,7 +174,7 @@ fn encode_plus(s: &str) -> ~str {\n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n-fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n+pub fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n@@ -209,7 +200,7 @@ fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n-fn decode_form_urlencoded(s: ~[u8]) ->\n+pub fn decode_form_urlencoded(s: ~[u8]) ->\n     map::HashMap<~str, @dvec::DVec<@~str>> {\n     do io::with_bytes_reader(s) |rdr| {\n         let m = HashMap();\n@@ -334,7 +325,7 @@ fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-fn query_to_str(query: Query) -> ~str {\n+pub fn query_to_str(query: Query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = copy *kv;\n@@ -344,7 +335,7 @@ fn query_to_str(query: Query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n+pub fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n@@ -623,7 +614,7 @@ fn get_query_fragment(rawurl: &str) ->\n  *\n  */\n \n-fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n+pub fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n     // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(&schm) {\n@@ -681,7 +672,7 @@ impl Url : FromStr {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-fn to_str(url: Url) -> ~str {\n+pub fn to_str(url: Url) -> ~str {\n     let user = if url.user.is_some() {\n       userinfo_to_str(option::unwrap(copy url.user))\n     } else {\n@@ -713,7 +704,7 @@ fn to_str(url: Url) -> ~str {\n }\n \n impl Url: to_str::ToStr {\n-    fn to_str() -> ~str {\n+    pub fn to_str() -> ~str {\n         to_str(self)\n     }\n }"}, {"sha": "6a5658d24eb0dc34a3cd72a1ff4b1452839e56d7", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/35598b4595ec6b7ae4ea6c0244f775651366fe9e/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=35598b4595ec6b7ae4ea6c0244f775651366fe9e", "patch": "@@ -44,13 +44,9 @@ export cell;\n \n // General io and system-services modules\n \n-#[legacy_exports]\n mod net;\n-#[legacy_exports]\n mod net_ip;\n-#[legacy_exports]\n mod net_tcp;\n-#[legacy_exports]\n mod net_url;\n \n // libuv modules"}]}