{"sha": "ab068f120ba853fe04f1a5513779ce5529faee93", "node_id": "C_kwDOAAsO6NoAKGFiMDY4ZjEyMGJhODUzZmUwNGYxYTU1MTM3NzljZTU1MjlmYWVlOTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T16:09:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T16:09:17Z"}, "message": "Auto merge of #13156 - Veykril:macro-stmts, r=Veykril\n\nRemove hir::Expr::MacroStmts\n\nThis hir expression isn't needed and only existed as it was simpler to\ndeal with at first as it gave us a direct mapping for the ast version of\nthe same construct. This PR removes it, properly handling the statements\nthat are introduced by macro call expressions.", "tree": {"sha": "5eafe213206252c5808c1fd34456f4308203d9a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5eafe213206252c5808c1fd34456f4308203d9a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab068f120ba853fe04f1a5513779ce5529faee93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab068f120ba853fe04f1a5513779ce5529faee93", "html_url": "https://github.com/rust-lang/rust/commit/ab068f120ba853fe04f1a5513779ce5529faee93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab068f120ba853fe04f1a5513779ce5529faee93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f38581372ea23348c2b8b4a9c50733ae8e0dd74", "html_url": "https://github.com/rust-lang/rust/commit/7f38581372ea23348c2b8b4a9c50733ae8e0dd74"}, {"sha": "ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "html_url": "https://github.com/rust-lang/rust/commit/ee02a4721b5bb20a67a105291cc3f59d8e57da7b"}], "stats": {"total": 186, "additions": 68, "deletions": 118}, "files": [{"sha": "8ebac5cb1c6c449dd9f7200355f84b43c60f9bab", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 53, "deletions": 64, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -550,20 +550,6 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::MacroStmts(e) => {\n-                let statements: Box<[_]> =\n-                    e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-                let tail = e.expr().map(|e| self.collect_expr(e));\n-\n-                if e.syntax().children().next().is_none() {\n-                    // HACK: make sure that macros that expand to nothing aren't treated as a `()`\n-                    // expression when used in block tail position.\n-                    cov_mark::hit!(empty_macro_in_trailing_position_is_removed);\n-                    return None;\n-                }\n-\n-                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n-            }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n     }\n@@ -640,11 +626,46 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n+    fn collect_macro_as_stmt(\n+        &mut self,\n+        statements: &mut Vec<Statement>,\n+        mac: ast::MacroExpr,\n+    ) -> Option<ExprId> {\n+        let mac_call = mac.macro_call()?;\n+        let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));\n+        let macro_ptr = AstPtr::new(&mac_call);\n+        let expansion = self.collect_macro_call(\n+            mac_call,\n+            macro_ptr,\n+            false,\n+            |this, expansion: Option<ast::MacroStmts>| match expansion {\n+                Some(expansion) => {\n+                    expansion.statements().for_each(|stmt| this.collect_stmt(statements, stmt));\n+                    expansion.expr().and_then(|expr| match expr {\n+                        ast::Expr::MacroExpr(mac) => this.collect_macro_as_stmt(statements, mac),\n+                        expr => Some(this.collect_expr(expr)),\n+                    })\n+                }\n+                None => None,\n+            },\n+        );\n+        match expansion {\n+            Some(tail) => {\n+                // Make the macro-call point to its expanded expression so we can query\n+                // semantics on syntax pointers to the macro\n+                let src = self.expander.to_source(syntax_ptr);\n+                self.source_map.expr_map.insert(src, tail);\n+                Some(tail)\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn collect_stmt(&mut self, statements: &mut Vec<Statement>, s: ast::Stmt) {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n-                    return None;\n+                    return;\n                 }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref =\n@@ -654,61 +675,26 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n+                statements.push(Statement::Let { pat, type_ref, initializer, else_branch });\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n                 let expr = stmt.expr();\n-                if let Some(expr) = &expr {\n-                    if self.check_cfg(expr).is_none() {\n-                        return None;\n-                    }\n+                match &expr {\n+                    Some(expr) if self.check_cfg(expr).is_none() => return,\n+                    _ => (),\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n                 // Note that macro could be expanded to multiple statements\n-                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n-                    let mac_call = mac.macro_call()?;\n-                    let syntax_ptr = AstPtr::new(expr);\n-                    let macro_ptr = AstPtr::new(&mac_call);\n-                    let stmt = self.collect_macro_call(\n-                        mac_call,\n-                        macro_ptr,\n-                        false,\n-                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n-                            Some(expansion) => {\n-                                let statements = expansion\n-                                    .statements()\n-                                    .filter_map(|stmt| this.collect_stmt(stmt))\n-                                    .collect();\n-                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n-\n-                                let mac_stmts = this.alloc_expr(\n-                                    Expr::MacroStmts { tail, statements },\n-                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n-                                );\n-\n-                                Some(mac_stmts)\n-                            }\n-                            None => None,\n-                        },\n-                    );\n-\n-                    let expr = match stmt {\n-                        Some(expr) => {\n-                            // Make the macro-call point to its expanded expression so we can query\n-                            // semantics on syntax pointers to the macro\n-                            let src = self.expander.to_source(syntax_ptr);\n-                            self.source_map.expr_map.insert(src, expr);\n-                            expr\n-                        }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n-                    };\n-                    Some(Statement::Expr { expr, has_semi })\n+                if let Some(ast::Expr::MacroExpr(mac)) = expr {\n+                    if let Some(expr) = self.collect_macro_as_stmt(statements, mac) {\n+                        statements.push(Statement::Expr { expr, has_semi })\n+                    }\n                 } else {\n                     let expr = self.collect_expr_opt(expr);\n-                    Some(Statement::Expr { expr, has_semi })\n+                    statements.push(Statement::Expr { expr, has_semi });\n                 }\n             }\n-            ast::Stmt::Item(_item) => None,\n+            ast::Stmt::Item(_item) => (),\n         }\n     }\n \n@@ -729,9 +715,12 @@ impl ExprCollector<'_> {\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n-        let mut statements: Vec<_> =\n-            block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+        let mut statements = Vec::new();\n+        block.statements().for_each(|s| self.collect_stmt(&mut statements, s));\n+        let tail = block.tail_expr().and_then(|e| match e {\n+            ast::Expr::MacroExpr(mac) => self.collect_macro_as_stmt(&mut statements, mac),\n+            expr => self.maybe_collect_expr(expr),\n+        });\n         let tail = tail.or_else(|| {\n             let stmt = statements.pop()?;\n             if let Statement::Expr { expr, has_semi: false } = stmt {"}, {"sha": "f2fed954444e2ca80b04a41a7bafa488f87905e4", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -422,19 +422,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"}}\");\n             }\n-            Expr::MacroStmts { statements, tail } => {\n-                w!(self, \"{{ // macro statements\");\n-                self.indented(|p| {\n-                    for stmt in statements.iter() {\n-                        p.print_stmt(stmt);\n-                    }\n-                    if let Some(tail) = tail {\n-                        p.print_expr(*tail);\n-                    }\n-                });\n-                self.newline();\n-                w!(self, \"}}\");\n-            }\n         }\n     }\n "}, {"sha": "9b28e38029e02d07feab6faa32ef5af675145530", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -176,9 +176,6 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n     scopes.set_scope(expr, *scope);\n     match &body[expr] {\n-        Expr::MacroStmts { statements, tail } => {\n-            compute_block_scopes(statements, *tail, body, scopes, scope);\n-        }\n         Expr::Block { statements, tail, id, label } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));\n             // Overwrite the old scope for the block expr, so that every block scope can be found"}, {"sha": "419d3feec3b6c2240c8be326edb0ad24a402c9eb", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -206,10 +206,6 @@ pub enum Expr {\n     Unsafe {\n         body: ExprId,\n     },\n-    MacroStmts {\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -263,7 +259,7 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {"}, {"sha": "fc128102f225a18cc066193e649e843dd2147906", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -969,7 +969,7 @@ impl ExpandTo {\n         if parent.kind() == MACRO_EXPR\n             && parent\n                 .parent()\n-                .map_or(true, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n+                .map_or(false, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n         {\n             return ExpandTo::Statements;\n         }"}, {"sha": "a42a00ea598eb86913280da1f9b6f72503ec6590", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -794,9 +794,6 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n-            Expr::MacroStmts { tail, statements } => {\n-                self.infer_block(tgt_expr, statements, *tail, expected)\n-            }\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n                 // which are handled by `infer_assignee_expr()`, so any underscore"}, {"sha": "b3adafaafd38de8ea411754aa963079da3f3a309", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -193,8 +193,6 @@ fn expr_macro_def_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             39..442 '{     ...!(); }': ()\n             73..94 'spam!(...am!())': {unknown}\n             100..119 'for _ ...!() {}': ()\n@@ -276,8 +274,6 @@ fn expr_macro_rules_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             53..456 '{     ...!(); }': ()\n             87..108 'spam!(...am!())': {unknown}\n             114..133 'for _ ...!() {}': ()\n@@ -312,7 +308,6 @@ fn expr_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..8 'leta=();': ()\n             !3..4 'a': ()\n             !5..7 '()': ()\n             57..84 '{     ...); } }': ()\n@@ -321,7 +316,7 @@ fn expr_macro_expanded_in_stmts() {\n }\n \n #[test]\n-fn recurisve_macro_expanded_in_stmts() {\n+fn recursive_macro_expanded_in_stmts() {\n     check_infer(\n         r#\"\n         macro_rules! ng {\n@@ -340,11 +335,6 @@ fn recurisve_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..7 'leta=3;': ()\n-            !0..13 'ng!{[leta=3]}': ()\n-            !0..13 'ng!{[leta=]3}': ()\n-            !0..13 'ng!{[leta]=3}': ()\n-            !0..13 'ng!{[let]a=3}': ()\n             !3..4 'a': i32\n             !5..6 '3': i32\n             196..237 '{     ...= a; }': ()\n@@ -369,8 +359,6 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..7 'mac!($)': ()\n-            !0..26 'macro_...>{1};}': ()\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],"}, {"sha": "23e51a9c16a5600138e3e519e2ae952c4a68c95e", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -573,7 +573,6 @@ fn issue_6811() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..16 'let_a=...t_b=1;': ()\n             !3..5 '_a': i32\n             !6..7 '1': i32\n             !11..13 '_b': i32\n@@ -1679,7 +1678,6 @@ fn main() {\n \n #[test]\n fn trailing_empty_macro() {\n-    cov_mark::check!(empty_macro_in_trailing_position_is_removed);\n     check_no_mismatches(\n         r#\"\n macro_rules! m2 {"}, {"sha": "707e9e84506a402728145c7e37a1f6b24dac55db", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -2549,7 +2549,6 @@ impl B for Astruct {}\n         expect![[r#\"\n             569..573 'self': Box<[T], A>\n             602..634 '{     ...     }': Vec<T, A>\n-            612..628 'unimpl...ted!()': Vec<T, A>\n             648..761 '{     ...t]); }': ()\n             658..661 'vec': Vec<i32, Global>\n             664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>"}, {"sha": "342912b678a1db836de2a77eb92f674fbc7246cd", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -140,11 +140,19 @@ impl SourceAnalyzer {\n     ) -> Option<InFile<ast::Expr>> {\n         let macro_file = self.body_source_map()?.node_macro_file(expr.as_ref())?;\n         let expanded = db.parse_or_expand(macro_file)?;\n-\n-        let res = match ast::MacroCall::cast(expanded.clone()) {\n-            Some(call) => self.expand_expr(db, InFile::new(macro_file, call))?,\n-            _ => InFile::new(macro_file, ast::Expr::cast(expanded)?),\n+        let res = if let Some(stmts) = ast::MacroStmts::cast(expanded.clone()) {\n+            match stmts.expr()? {\n+                ast::Expr::MacroExpr(mac) => {\n+                    self.expand_expr(db, InFile::new(macro_file, mac.macro_call()?))?\n+                }\n+                expr => InFile::new(macro_file, expr),\n+            }\n+        } else if let Some(call) = ast::MacroCall::cast(expanded.clone()) {\n+            self.expand_expr(db, InFile::new(macro_file, call))?\n+        } else {\n+            InFile::new(macro_file, ast::Expr::cast(expanded)?)\n         };\n+\n         Some(res)\n     }\n "}, {"sha": "b890e2b58df8f2688923c1262665e7361a747881", "filename": "crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -315,7 +315,6 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         | ast::Expr::IndexExpr(_)\n         | ast::Expr::Literal(_)\n         | ast::Expr::MacroExpr(_)\n-        | ast::Expr::MacroStmts(_)\n         | ast::Expr::MethodCallExpr(_)\n         | ast::Expr::ParenExpr(_)\n         | ast::Expr::PathExpr(_)"}, {"sha": "894795435451c8e2691fe805253987719cd80313", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -343,7 +343,6 @@ Expr =\n | Literal\n | LoopExpr\n | MacroExpr\n-| MacroStmts\n | MatchExpr\n | MethodCallExpr\n | ParenExpr"}, {"sha": "449402e5f5b30af4f6e69e3b26c27aa234a2b93c", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab068f120ba853fe04f1a5513779ce5529faee93/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=ab068f120ba853fe04f1a5513779ce5529faee93", "patch": "@@ -1526,7 +1526,6 @@ pub enum Expr {\n     Literal(Literal),\n     LoopExpr(LoopExpr),\n     MacroExpr(MacroExpr),\n-    MacroStmts(MacroStmts),\n     MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n     ParenExpr(ParenExpr),\n@@ -3342,9 +3341,6 @@ impl From<LoopExpr> for Expr {\n impl From<MacroExpr> for Expr {\n     fn from(node: MacroExpr) -> Expr { Expr::MacroExpr(node) }\n }\n-impl From<MacroStmts> for Expr {\n-    fn from(node: MacroStmts) -> Expr { Expr::MacroStmts(node) }\n-}\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n@@ -3411,7 +3407,6 @@ impl AstNode for Expr {\n                 | LITERAL\n                 | LOOP_EXPR\n                 | MACRO_EXPR\n-                | MACRO_STMTS\n                 | MATCH_EXPR\n                 | METHOD_CALL_EXPR\n                 | PAREN_EXPR\n@@ -3448,7 +3443,6 @@ impl AstNode for Expr {\n             LITERAL => Expr::Literal(Literal { syntax }),\n             LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n             MACRO_EXPR => Expr::MacroExpr(MacroExpr { syntax }),\n-            MACRO_STMTS => Expr::MacroStmts(MacroStmts { syntax }),\n             MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n             PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n@@ -3487,7 +3481,6 @@ impl AstNode for Expr {\n             Expr::Literal(it) => &it.syntax,\n             Expr::LoopExpr(it) => &it.syntax,\n             Expr::MacroExpr(it) => &it.syntax,\n-            Expr::MacroStmts(it) => &it.syntax,\n             Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n             Expr::ParenExpr(it) => &it.syntax,"}]}