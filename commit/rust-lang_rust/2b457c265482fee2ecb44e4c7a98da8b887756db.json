{"sha": "2b457c265482fee2ecb44e4c7a98da8b887756db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNDU3YzI2NTQ4MmZlZTJlY2I0NGU0YzdhOThkYThiODg3NzU2ZGI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-17T23:14:57Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-18T00:14:32Z"}, "message": "Pretty print explicit self types. Work on #2585.", "tree": {"sha": "834095b194c1b22f8a7324c3a81fce4e977b3592", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834095b194c1b22f8a7324c3a81fce4e977b3592"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b457c265482fee2ecb44e4c7a98da8b887756db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b457c265482fee2ecb44e4c7a98da8b887756db", "html_url": "https://github.com/rust-lang/rust/commit/2b457c265482fee2ecb44e4c7a98da8b887756db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b457c265482fee2ecb44e4c7a98da8b887756db/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a65366d5486eb580f6dabda7243f4ad78273ffe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a65366d5486eb580f6dabda7243f4ad78273ffe1", "html_url": "https://github.com/rust-lang/rust/commit/a65366d5486eb580f6dabda7243f4ad78273ffe1"}], "stats": {"total": 80, "additions": 63, "deletions": 17}, "files": [{"sha": "b99cb3db4b805c7888aa84a32fad56963fb6704f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2b457c265482fee2ecb44e4c7a98da8b887756db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b457c265482fee2ecb44e4c7a98da8b887756db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2b457c265482fee2ecb44e4c7a98da8b887756db", "patch": "@@ -617,7 +617,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n       cbox(s, indent_unit);\n       ibox(s, 4);\n       word(s.s, ~\"new(\");\n-      print_fn_args(s, ctor.node.dec, ~[]);\n+      print_fn_args(s, ctor.node.dec, ~[], none);\n       word(s.s, ~\")\");\n       space(s.s);\n       print_block(s, ctor.node.body);\n@@ -1193,7 +1193,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         word(s.s, fn_header_info_to_str(none, decl.purity, some(proto)));\n-        print_fn_args_and_ret(s, decl, *cap_clause);\n+        print_fn_args_and_ret(s, decl, *cap_clause, none);\n         space(s.s);\n         print_block(s, body);\n       }\n@@ -1522,33 +1522,64 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     s.ann.post(ann_node);\n }\n \n+fn print_self_ty(s: ps, self_ty: ast::self_ty_) {\n+    match self_ty {\n+      ast::sty_static | ast::sty_by_ref => {}\n+      ast::sty_value => { word(s.s, ~\"self\"); }\n+      ast::sty_region(m) => {\n+        word(s.s, ~\"&\"); print_mutability(s, m); word(s.s, ~\"self\");\n+      }\n+      ast::sty_box(m) => {\n+        word(s.s, ~\"@\"); print_mutability(s, m); word(s.s, ~\"self\");\n+      }\n+      ast::sty_uniq(m) => {\n+        word(s.s, ~\"~\"); print_mutability(s, m); word(s.s, ~\"self\");\n+      }\n+    }\n+}\n+\n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: ~[ast::ty_param],\n             opt_self_ty: option<ast::self_ty_>) {\n     head(s, fn_header_info_to_str(opt_self_ty, decl.purity, none));\n     word(s.s, *name);\n     print_type_params(s, typarams);\n-    print_fn_args_and_ret(s, decl, ~[]);\n+    print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n }\n \n fn print_fn_args(s: ps, decl: ast::fn_decl,\n-                 cap_items: ~[ast::capture_item]) {\n-    commasep(s, inconsistent, decl.inputs, print_arg);\n-    if cap_items.is_not_empty() {\n-        let mut first = decl.inputs.is_empty();\n-        for cap_items.each |cap_item| {\n-            if first { first = false; } else { word_space(s, ~\",\"); }\n-            if cap_item.is_move { word_nbsp(s, ~\"move\") }\n-            else { word_nbsp(s, ~\"copy\") }\n-            word(s.s, *cap_item.name);\n-        }\n+                 cap_items: ~[ast::capture_item],\n+                 opt_self_ty: option<ast::self_ty_>) {\n+    // It is unfortunate to duplicate the commasep logic, but we\n+    // we want the self type, the args, and the capture clauses all\n+    // in the same box.\n+    box(s, 0u, inconsistent);\n+    let mut first = true;\n+    for opt_self_ty.each |self_ty| {\n+        first = false;\n+        print_self_ty(s, self_ty);\n+    }\n+\n+    for decl.inputs.each |arg| {\n+        if first { first = false; } else { word_space(s, ~\",\"); }\n+        print_arg(s, arg);\n     }\n+\n+    for cap_items.each |cap_item| {\n+        if first { first = false; } else { word_space(s, ~\",\"); }\n+        if cap_item.is_move { word_nbsp(s, ~\"move\") }\n+        else { word_nbsp(s, ~\"copy\") }\n+        word(s.s, *cap_item.name);\n+    }\n+\n+    end(s);\n }\n \n fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n-                         cap_items: ~[ast::capture_item]) {\n+                         cap_items: ~[ast::capture_item],\n+                         opt_self_ty: option<ast::self_ty_>) {\n     popen(s);\n-    print_fn_args(s, decl, cap_items);\n+    print_fn_args(s, decl, cap_items, opt_self_ty);\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n@@ -1562,7 +1593,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n                        cap_items: ~[ast::capture_item]) {\n     word(s.s, ~\"|\");\n-    print_fn_args(s, decl, cap_items);\n+    print_fn_args(s, decl, cap_items, none);\n     word(s.s, ~\"|\");\n     if decl.output.node != ast::ty_infer {\n         space_if_not_bol(s);\n@@ -1741,9 +1772,24 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     match id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n     match tps { some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n+\n     popen(s);\n-    commasep(s, inconsistent, decl.inputs, print_arg);\n+    // It is unfortunate to duplicate the commasep logic, but we\n+    // we want the self type, the args, and the capture clauses all\n+    // in the same box.\n+    box(s, 0u, inconsistent);\n+    let mut first = true;\n+    for opt_self_ty.each |self_ty| {\n+        first = false;\n+        print_self_ty(s, self_ty);\n+    }\n+    for decl.inputs.each |arg| {\n+        if first { first = false; } else { word_space(s, ~\",\"); }\n+        print_arg(s, arg);\n+    }\n+    end(s);\n     pclose(s);\n+\n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);"}]}