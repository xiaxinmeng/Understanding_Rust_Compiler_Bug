{"sha": "dcf41821b88bc9c54aaa621f7e744405a33e2238", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZjQxODIxYjg4YmM5YzU0YWFhNjIxZjdlNzQ0NDA1YTMzZTIyMzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T22:51:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-11T04:05:04Z"}, "message": "Rollup merge of #40389 - F001:placementVecDeque, r=nagisa\n\nImplement placement-in protocol for `VecDeque`\n\nCC #30172\n\nr? @nagisa", "tree": {"sha": "22a88fba065d1d5782e2945788001939eefa407d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22a88fba065d1d5782e2945788001939eefa407d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf41821b88bc9c54aaa621f7e744405a33e2238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf41821b88bc9c54aaa621f7e744405a33e2238", "html_url": "https://github.com/rust-lang/rust/commit/dcf41821b88bc9c54aaa621f7e744405a33e2238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf41821b88bc9c54aaa621f7e744405a33e2238/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0da85d7257413abcb2b6ab59609f2d8d821ba97", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0da85d7257413abcb2b6ab59609f2d8d821ba97", "html_url": "https://github.com/rust-lang/rust/commit/d0da85d7257413abcb2b6ab59609f2d8d821ba97"}, {"sha": "8062cfb37294082ad5825a105e47e0b7b50a7269", "url": "https://api.github.com/repos/rust-lang/rust/commits/8062cfb37294082ad5825a105e47e0b7b50a7269", "html_url": "https://github.com/rust-lang/rust/commit/8062cfb37294082ad5825a105e47e0b7b50a7269"}], "stats": {"total": 210, "additions": 184, "deletions": 26}, "files": [{"sha": "24f57c506304c46cad39b3642eac403ebf2e9969", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 160, "deletions": 25, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=dcf41821b88bc9c54aaa621f7e744405a33e2238", "patch": "@@ -22,7 +22,7 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut};\n+use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n use core::ptr;\n use core::ptr::Shared;\n use core::slice;\n@@ -1087,14 +1087,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        if self.is_full() {\n-            let old_cap = self.cap();\n-            self.buf.double();\n-            unsafe {\n-                self.handle_cap_increase(old_cap);\n-            }\n-            debug_assert!(!self.is_full());\n-        }\n+        self.grow_if_necessary();\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1117,14 +1110,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        if self.is_full() {\n-            let old_cap = self.cap();\n-            self.buf.double();\n-            unsafe {\n-                self.handle_cap_increase(old_cap);\n-            }\n-            debug_assert!(!self.is_full());\n-        }\n+        self.grow_if_necessary();\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1257,14 +1243,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        if self.is_full() {\n-            let old_cap = self.cap();\n-            self.buf.double();\n-            unsafe {\n-                self.handle_cap_increase(old_cap);\n-            }\n-            debug_assert!(!self.is_full());\n-        }\n+        self.grow_if_necessary();\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -1762,6 +1741,69 @@ impl<T> VecDeque<T> {\n             self.truncate(len - del);\n         }\n     }\n+\n+    // This may panic or abort\n+    #[inline]\n+    fn grow_if_necessary(&mut self) {\n+        if self.is_full() {\n+            let old_cap = self.cap();\n+            self.buf.double();\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n+            debug_assert!(!self.is_full());\n+        }\n+    }\n+\n+    /// Returns a place for insertion at the back of the `VecDeque`.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.place_back() <- 3;\n+    /// buf.place_back() <- 4;\n+    /// assert_eq!(&buf, &[3, 4]);\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place_back(&mut self) -> PlaceBack<T> {\n+        PlaceBack { vec_deque: self }\n+    }\n+\n+    /// Returns a place for insertion at the front of the `VecDeque`.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push_front`](#method.push_front),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.place_front() <- 3;\n+    /// buf.place_front() <- 4;\n+    /// assert_eq!(&buf, &[4, 3]);\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place_front(&mut self) -> PlaceFront<T> {\n+        PlaceFront { vec_deque: self }\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {\n@@ -2442,6 +2484,98 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     }\n }\n \n+/// A place for insertion at the back of a `VecDeque`.\n+///\n+/// See [`VecDeque::place_back`](struct.VecDeque.html#method.place_back) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol are subject to change\",\n+           issue = \"30172\")]\n+#[derive(Debug)]\n+pub struct PlaceBack<'a, T: 'a> {\n+    vec_deque: &'a mut VecDeque<T>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n+    type Place = PlaceBack<'a, T>;\n+\n+    fn make_place(self) -> Self {\n+        self.vec_deque.grow_if_necessary();\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for PlaceBack<'a, T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { self.vec_deque.ptr().offset(self.vec_deque.head as isize) }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n+    type Owner = &'a mut T;\n+\n+    unsafe fn finalize(mut self) -> &'a mut T {\n+        let head = self.vec_deque.head;\n+        self.vec_deque.head = self.vec_deque.wrap_add(head, 1);\n+        &mut *(self.vec_deque.ptr().offset(head as isize))\n+    }\n+}\n+\n+/// A place for insertion at the front of a `VecDeque`.\n+///\n+/// See [`VecDeque::place_front`](struct.VecDeque.html#method.place_front) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol are subject to change\",\n+           issue = \"30172\")]\n+#[derive(Debug)]\n+pub struct PlaceFront<'a, T: 'a> {\n+    vec_deque: &'a mut VecDeque<T>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for PlaceFront<'a, T> {\n+    type Place = PlaceFront<'a, T>;\n+\n+    fn make_place(self) -> Self {\n+        self.vec_deque.grow_if_necessary();\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for PlaceFront<'a, T> {\n+    fn pointer(&mut self) -> *mut T {\n+        let tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n+        unsafe { self.vec_deque.ptr().offset(tail as isize) }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for PlaceFront<'a, T> {\n+    type Owner = &'a mut T;\n+\n+    unsafe fn finalize(mut self) -> &'a mut T {\n+        self.vec_deque.tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n+        &mut *(self.vec_deque.ptr().offset(self.vec_deque.tail as isize))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use test;\n@@ -2797,4 +2931,5 @@ mod tests {\n             }\n         }\n     }\n+\n }"}, {"sha": "d97d9b8ab83f67935fcec4a60e48c83f0e924a4c", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=dcf41821b88bc9c54aaa621f7e744405a33e2238", "patch": "@@ -32,6 +32,7 @@\n extern crate collections;\n extern crate test;\n extern crate std_unicode;\n+extern crate core;\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "f2935c05d4f7a90ac3112b0481fdac7057562652", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf41821b88bc9c54aaa621f7e744405a33e2238/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=dcf41821b88bc9c54aaa621f7e744405a33e2238", "patch": "@@ -10,7 +10,7 @@\n \n use std::collections::VecDeque;\n use std::fmt::Debug;\n-use std::collections::vec_deque::Drain;\n+use std::collections::vec_deque::{Drain};\n \n use self::Taggy::*;\n use self::Taggypar::*;\n@@ -1000,3 +1000,25 @@ fn test_is_empty() {\n     assert!(v.iter_mut().is_empty());\n     assert!(v.into_iter().is_empty());\n }\n+\n+#[test]\n+fn test_placement_in() {\n+    let mut buf: VecDeque<isize> = VecDeque::new();\n+    buf.place_back() <- 1;\n+    buf.place_back() <- 2;\n+    assert_eq!(buf, [1,2]);\n+\n+    buf.place_front() <- 3;\n+    buf.place_front() <- 4;\n+    assert_eq!(buf, [4,3,1,2]);\n+\n+    {\n+        let ptr_head = buf.place_front() <- 5;\n+        assert_eq!(*ptr_head, 5);\n+    }\n+    {\n+        let ptr_tail = buf.place_back() <- 6;\n+        assert_eq!(*ptr_tail, 6);\n+    }\n+    assert_eq!(buf, [5,4,3,1,2,6]);\n+}"}]}