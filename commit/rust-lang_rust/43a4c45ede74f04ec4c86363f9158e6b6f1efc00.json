{"sha": "43a4c45ede74f04ec4c86363f9158e6b6f1efc00", "node_id": "C_kwDOAAsO6NoAKDQzYTRjNDVlZGU3NGYwNGVjNGM4NjM2M2Y5MTU4ZTZiNmYxZWZjMDA", "commit": {"author": {"name": "Ole Strohm", "email": "strohm99@gmail.com", "date": "2022-02-22T13:59:30Z"}, "committer": {"name": "Ole Strohm", "email": "strohm99@gmail.com", "date": "2022-02-22T13:59:30Z"}, "message": "fix: Make match_arms assist handle doc(hidden) and non_exhaustive", "tree": {"sha": "098f88f5c89d4a93b83288eb9ffb5b3b14ec117f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098f88f5c89d4a93b83288eb9ffb5b3b14ec117f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43a4c45ede74f04ec4c86363f9158e6b6f1efc00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43a4c45ede74f04ec4c86363f9158e6b6f1efc00", "html_url": "https://github.com/rust-lang/rust/commit/43a4c45ede74f04ec4c86363f9158e6b6f1efc00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43a4c45ede74f04ec4c86363f9158e6b6f1efc00/comments", "author": {"login": "OleStrohm", "id": 6892524, "node_id": "MDQ6VXNlcjY4OTI1MjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6892524?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OleStrohm", "html_url": "https://github.com/OleStrohm", "followers_url": "https://api.github.com/users/OleStrohm/followers", "following_url": "https://api.github.com/users/OleStrohm/following{/other_user}", "gists_url": "https://api.github.com/users/OleStrohm/gists{/gist_id}", "starred_url": "https://api.github.com/users/OleStrohm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OleStrohm/subscriptions", "organizations_url": "https://api.github.com/users/OleStrohm/orgs", "repos_url": "https://api.github.com/users/OleStrohm/repos", "events_url": "https://api.github.com/users/OleStrohm/events{/privacy}", "received_events_url": "https://api.github.com/users/OleStrohm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "OleStrohm", "id": 6892524, "node_id": "MDQ6VXNlcjY4OTI1MjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6892524?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OleStrohm", "html_url": "https://github.com/OleStrohm", "followers_url": "https://api.github.com/users/OleStrohm/followers", "following_url": "https://api.github.com/users/OleStrohm/following{/other_user}", "gists_url": "https://api.github.com/users/OleStrohm/gists{/gist_id}", "starred_url": "https://api.github.com/users/OleStrohm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OleStrohm/subscriptions", "organizations_url": "https://api.github.com/users/OleStrohm/orgs", "repos_url": "https://api.github.com/users/OleStrohm/repos", "events_url": "https://api.github.com/users/OleStrohm/events{/privacy}", "received_events_url": "https://api.github.com/users/OleStrohm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ce06d4b173d396947263c207946383fdaad6db6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce06d4b173d396947263c207946383fdaad6db6", "html_url": "https://github.com/rust-lang/rust/commit/7ce06d4b173d396947263c207946383fdaad6db6"}], "stats": {"total": 390, "additions": 362, "deletions": 28}, "files": [{"sha": "7d151f9efecc4f2dfae9155f8f3caa606b5f08cb", "filename": "crates/ide_assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 362, "deletions": 28, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/43a4c45ede74f04ec4c86363f9158e6b6f1efc00/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43a4c45ede74f04ec4c86363f9158e6b6f1efc00/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=43a4c45ede74f04ec4c86363f9158e6b6f1efc00", "patch": "@@ -1,11 +1,11 @@\n use std::iter::{self, Peekable};\n \n use either::Either;\n-use hir::{Adt, HasSource, ModuleDef, Semantics};\n+use hir::{Adt, HasAttrs, HasSource, ModuleDef, Semantics};\n use ide_db::helpers::{mod_path_to_ast, FamousDefs};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n-use syntax::ast::{self, make, AstNode, HasName, MatchArm, MatchArmList, MatchExpr, Pat};\n+use syntax::ast::{self, make, AstNode, HasName, MatchArmList, MatchExpr, Pat};\n \n use crate::{\n     utils::{self, render_snippet, Cursor},\n@@ -52,36 +52,50 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n \n     let expr = match_expr.expr()?;\n \n-    let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n-    if let [arm] = arms.as_slice() {\n-        if let Some(Pat::WildcardPat(..)) = arm.pat() {\n-            arms.clear();\n-        }\n-    }\n+    let mut has_catch_all_arm = false;\n \n-    let top_lvl_pats: Vec<_> = arms\n-        .iter()\n-        .filter_map(ast::MatchArm::pat)\n-        .flat_map(|pat| match pat {\n-            // Special case OrPat as separate top-level pats\n-            Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n-            _ => Either::Right(iter::once(pat)),\n+    let top_lvl_pats: Vec<_> = match_arm_list\n+        .arms()\n+        .filter_map(|arm| Some((arm.pat()?, arm.guard().is_some())))\n+        .flat_map(|(pat, has_guard)| {\n+            match pat {\n+                // Special case OrPat as separate top-level pats\n+                Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n+                _ => Either::Right(iter::once(pat)),\n+            }\n+            .map(move |pat| (pat, has_guard))\n+        })\n+        .map(|(pat, has_guard)| {\n+            has_catch_all_arm |= !has_guard && matches!(pat, Pat::WildcardPat(_));\n+            pat\n         })\n         // Exclude top level wildcards so that they are expanded by this assist, retains status quo in #8129.\n         .filter(|pat| !matches!(pat, Pat::WildcardPat(_)))\n         .collect();\n \n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n-    let mut missing_pats: Peekable<Box<dyn Iterator<Item = ast::Pat>>> = if let Some(enum_def) =\n-        resolve_enum_def(&ctx.sema, &expr)\n-    {\n+    let (mut missing_pats, is_non_exhaustive): (\n+        Peekable<Box<dyn Iterator<Item = (ast::Pat, bool)>>>,\n+        bool,\n+    ) = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n         let variants = enum_def.variants(ctx.db());\n \n+        let is_non_exhaustive = match enum_def {\n+            ExtendedEnum::Enum(e) => e.attrs(ctx.db()).by_key(\"non_exhaustive\").exists(),\n+            _ => false,\n+        };\n+\n         let missing_pats = variants\n             .into_iter()\n-            .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+            .filter_map(|variant| {\n+                let is_hidden = match variant {\n+                    ExtendedVariant::Variant(var) => var.attrs(ctx.db()).has_doc_hidden(),\n+                    _ => false,\n+                };\n+                Some((build_pat(ctx.db(), module, variant)?, is_hidden))\n+            })\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n \n         let option_enum =\n             FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum);\n@@ -92,8 +106,13 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n         } else {\n             Box::new(missing_pats)\n         };\n-        missing_pats.peekable()\n+        (missing_pats.peekable(), is_non_exhaustive)\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n+        let is_non_exhaustive = enum_defs.iter().any(|enum_def| match enum_def {\n+            ExtendedEnum::Enum(e) => e.attrs(ctx.db()).by_key(\"non_exhaustive\").exists(),\n+            _ => false,\n+        });\n+\n         let mut n_arms = 1;\n         let variants_of_enums: Vec<Vec<ExtendedVariant>> = enum_defs\n             .into_iter()\n@@ -117,17 +136,24 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n             .multi_cartesian_product()\n             .inspect(|_| cov_mark::hit!(add_missing_match_arms_lazy_computation))\n             .map(|variants| {\n+                let is_hidden = variants.iter().any(|variant| match variant {\n+                    ExtendedVariant::Variant(var) => var.attrs(ctx.db()).has_doc_hidden(),\n+                    _ => false,\n+                });\n                 let patterns =\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n-                ast::Pat::from(make::tuple_pat(patterns))\n+\n+                (ast::Pat::from(make::tuple_pat(patterns)), is_hidden)\n             })\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n-        (Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable()\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n+        ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n     } else {\n         return None;\n     };\n \n-    if missing_pats.peek().is_none() {\n+    let mut needs_catch_all_arm = is_non_exhaustive && !has_catch_all_arm;\n+\n+    if !needs_catch_all_arm && missing_pats.peek().is_none() {\n         return None;\n     }\n \n@@ -138,8 +164,10 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n         |builder| {\n             let new_match_arm_list = match_arm_list.clone_for_update();\n             let missing_arms = missing_pats\n-                .map(|pat| make::match_arm(iter::once(pat), None, make::ext::expr_todo()))\n-                .map(|it| it.clone_for_update());\n+                .map(|(pat, hidden)| {\n+                    (make::match_arm(iter::once(pat), None, make::ext::expr_todo()), hidden)\n+                })\n+                .map(|(it, hidden)| (it.clone_for_update(), hidden));\n \n             let catch_all_arm = new_match_arm_list\n                 .arms()\n@@ -159,7 +187,22 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext) ->\n                 }\n             }\n             let mut first_new_arm = None;\n-            for arm in missing_arms {\n+            for (arm, hidden) in missing_arms {\n+                if hidden {\n+                    needs_catch_all_arm = !has_catch_all_arm;\n+                } else {\n+                    first_new_arm.get_or_insert_with(|| arm.clone());\n+                    new_match_arm_list.add_arm(arm);\n+                }\n+            }\n+            if needs_catch_all_arm && !has_catch_all_arm {\n+                cov_mark::hit!(added_wildcard_pattern);\n+                let arm = make::match_arm(\n+                    iter::once(make::wildcard_pat().into()),\n+                    None,\n+                    make::ext::expr_todo(),\n+                )\n+                .clone_for_update();\n                 first_new_arm.get_or_insert_with(|| arm.clone());\n                 new_match_arm_list.add_arm(arm);\n             }\n@@ -1280,6 +1323,297 @@ fn foo(t: bool) {\n         $0true => todo!(),\n         false => todo!(),\n     }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_hidden_variants() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E {\n+    A,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+enum E {\n+    A,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+fn foo(t: E) {\n+    match t {\n+        $0E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_hidden_variants_tuple() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E {\n+    A,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+fn foo(t: (bool, E)) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+enum E {\n+    A,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+fn foo(t: (bool, E)) {\n+    match t {\n+        $0(true, E::A) => todo!(),\n+        (false, E::A) => todo!(),\n+        _ => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_with_only_hidden_variants() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E {\n+    #[doc(hidden)]\n+    A,\n+}\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+enum E {\n+    #[doc(hidden)]\n+    A,\n+}\n+\n+fn foo(t: E) {\n+    match t {\n+        ${0:_} => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_fill_wildcard_when_hidden_variants_are_explicit() {\n+        check_assist_not_applicable(\n+            add_missing_match_arms,\n+            r#\"\n+enum E {\n+    #[doc(hidden)]\n+    A,\n+}\n+\n+fn foo(t: E) {\n+    match $0t {\n+        E::A => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    // FIXME: I don't think the assist should be applicable in this case\n+    #[test]\n+    fn does_not_fill_wildcard_with_wildcard() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E) {\n+    match $0t {\n+        _ => todo!(),\n+    }\n+}\"#,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E) {\n+    match t {\n+        _ => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_explicit_matches() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, }\n+\n+fn foo(t: E) {\n+    match $0t {\n+        E::A => todo!(),\n+    }\n+}\"#,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, }\n+\n+fn foo(t: E) {\n+    match t {\n+        E::A => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_without_matches() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, }\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, }\n+\n+fn foo(t: E) {\n+    match t {\n+        $0E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_doc_hidden() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, #[doc(hidden)] B }\n+\n+fn foo(t: E) {\n+    match $0t {\n+    }\n+}\"#,\n+            r#\"\n+#[non_exhaustive]\n+enum E { A, #[doc(hidden)] B }\n+\n+fn foo(t: E) {\n+    match t {\n+        $0E::A => todo!(),\n+        _ => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fills_wildcard_on_non_exhaustive_with_doc_hidden_with_explicit_arms() {\n+        cov_mark::check!(added_wildcard_pattern);\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+#[non_exhaustive]\n+enum E { #[doc(hidden)] A }\n+\n+fn foo(t: E) {\n+    match $0t {\n+        E::A => todo!(),\n+    }\n+}\"#,\n+            r#\"\n+#[non_exhaustive]\n+enum E { #[doc(hidden)] A }\n+\n+fn foo(t: E) {\n+    match t {\n+        E::A => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_wildcard_with_partial_wildcard() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E, b: bool) {\n+    match $0t {\n+        _ if b => todo!(),\n+    }\n+}\"#,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E, b: bool) {\n+    match t {\n+        _ if b => todo!(),\n+        ${0:_} => todo!(),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_notfill_wildcard_with_partial_wildcard_and_wildcard() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E, b: bool) {\n+    match $0t {\n+        _ if b => todo!(),\n+        _ => todo!(),\n+    }\n+}\"#,\n+            r#\"\n+enum E { #[doc(hidden)] A, }\n+\n+fn foo(t: E, b: bool) {\n+    match t {\n+        _ if b => todo!(),\n+        _ => todo!(),\n+    }\n }\"#,\n         );\n     }"}]}