{"sha": "ede366be637657280ca506c5bad0f41f96c47340", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZTM2NmJlNjM3NjU3MjgwY2E1MDZjNWJhZDBmNDFmOTZjNDczNDA=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-03-04T12:59:10Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:30Z"}, "message": "collected all the imports and names\n\nhow to compare macro to import path\n\nadd more imports to test", "tree": {"sha": "3da93b99531d080df5e838022c346691376ea2a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3da93b99531d080df5e838022c346691376ea2a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ede366be637657280ca506c5bad0f41f96c47340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ede366be637657280ca506c5bad0f41f96c47340", "html_url": "https://github.com/rust-lang/rust/commit/ede366be637657280ca506c5bad0f41f96c47340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ede366be637657280ca506c5bad0f41f96c47340/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4b8bb88f210de7fa2d82fe64b48331126eb7462", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b8bb88f210de7fa2d82fe64b48331126eb7462", "html_url": "https://github.com/rust-lang/rust/commit/a4b8bb88f210de7fa2d82fe64b48331126eb7462"}], "stats": {"total": 354, "additions": 281, "deletions": 73}, "files": [{"sha": "89f55986f634f3e5d589ed5a80bdfb75e9a34a14", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ede366be637657280ca506c5bad0f41f96c47340/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede366be637657280ca506c5bad0f41f96c47340/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ede366be637657280ca506c5bad0f41f96c47340", "patch": "@@ -60,6 +60,7 @@ extern crate rustc_trait_selection;\n #[allow(unused_extern_crates)]\n extern crate rustc_typeck;\n \n+use rustc::session::Session;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_lint::LintId;\n use rustc_session::Session;\n@@ -1060,9 +1061,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let max_struct_bools = conf.max_struct_bools;\n     store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n     store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n-    let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n-    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n-    store.register_early_pass(|| box macro_use::MacroUseImports);\n+    store.register_late_pass(|| box wildcard_imports::WildcardImports);\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n@@ -1080,6 +1079,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         single_char_binding_names_threshold,\n     });\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n+    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),"}, {"sha": "4c89647a5741359349bd1e56230c1b9902a03a59", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 190, "deletions": 44, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/ede366be637657280ca506c5bad0f41f96c47340/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede366be637657280ca506c5bad0f41f96c47340/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=ede366be637657280ca506c5bad0f41f96c47340", "patch": "@@ -1,10 +1,12 @@\n-use crate::utils::{snippet, span_lint_and_sugg, in_macro};\n+use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n+use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n use rustc_ast::ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{impl_lint_pass, declare_tool_lint};\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{edition::Edition, Span};\n \n declare_clippy_lint! {\n@@ -20,82 +22,226 @@ declare_clippy_lint! {\n     /// #[macro_use]\n     /// use lazy_static;\n     /// ```\n-    pub MACRO_USE_IMPORT,\n+    pub MACRO_USE_IMPORTS,\n     pedantic,\n     \"#[macro_use] is no longer needed\"\n }\n \n-#[derive(Default)]\n-pub struct MacroUseImport {\n-    collected: FxHashSet<Span>,\n+const BRACKETS: &[char] = &['<', '>'];\n+\n+/// MacroRefData includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n+#[derive(Debug, Clone)]\n+pub struct MacroRefData {\n+    name: String,\n+    path: String,\n }\n \n-impl_lint_pass!(MacroUseImport => [MACRO_USE_IMPORT]);\n+impl MacroRefData {\n+    pub fn new(name: String, span: Span, ecx: &LateContext<'_, '_>) -> Self {\n+        let mut path = ecx.sess().source_map().span_to_filename(span).to_string();\n \n-impl EarlyLintPass for MacroUseImport {\n+        // std lib paths are <::std::module::file type>\n+        // so remove brackets and space\n+        if path.contains('<') {\n+            path = path.replace(BRACKETS, \"\");\n+        }\n+        if path.contains(' ') {\n+            path = path.split(' ').next().unwrap().to_string();\n+        }\n+        Self {\n+            name: name.to_string(),\n+            path,\n+        }\n+    }\n+}\n \n-    fn check_item(&mut self, ecx: &EarlyContext<'_>, item: &ast::Item) {\n+#[derive(Default)]\n+pub struct MacroUseImports {\n+    /// the actual import path used and the span of the attribute above it.\n+    imports: Vec<(String, Span)>,\n+    /// the span of the macro reference and the `MacroRefData`\n+    /// for the use of the macro.\n+    /// TODO make this FxHashSet<Span> to guard against inserting already found macros\n+    collected: FxHashMap<Span, MacroRefData>,\n+    mac_refs: Vec<(Span, MacroRefData)>,\n+}\n+\n+impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n+\n+impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n+    fn check_item(&mut self, lcx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-            if ecx.sess.opts.edition == Edition::Edition2018;\n-            if let ast::ItemKind::Use(use_tree) = &item.kind;\n+            if lcx.sess().opts.edition == Edition::Edition2018;\n+            if let hir::ItemKind::Use(path, _kind) = &item.kind;\n             if let Some(mac_attr) = item\n                 .attrs\n                 .iter()\n                 .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+            if let Res::Def(DefKind::Mod, id) = path.res;\n             then {\n-                let import_path = snippet(ecx, use_tree.span, \"_\");\n-                let mac_names = find_used_macros(ecx, &import_path);\n-                let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n-                let help = format!(\"use {}::<macro name>\", import_path);\n-                span_lint_and_sugg(\n-                    ecx,\n-                    MACRO_USE_IMPORT,\n-                    mac_attr.span,\n-                    msg,\n-                    // \"remove the attribute and import the macro directly, try\",\n-                    \"\",\n-                    help,\n-                    Applicability::HasPlaceholders,\n-                );\n+                // println!(\"{:#?}\", lcx.tcx.def_path_str(id));\n+                for kid in lcx.tcx.item_children(id).iter() {\n+                    // println!(\"{:#?}\", kid);\n+                    if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n+                        let span = mac_attr.span.clone();\n+\n+                        // println!(\"{:#?}\", lcx.tcx.def_path_str(mac_id));\n+\n+                        self.imports.push((lcx.tcx.def_path_str(mac_id), span));\n+                    }\n+                }\n+            } else {\n+                if in_macro(item.span) {\n+                    let call_site = item.span.source_callsite();\n+                    let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+                    if let Some(callee) = item.span.source_callee() {\n+                        if !self.collected.contains_key(&call_site) {\n+                            let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n+                            self.mac_refs.push((call_site, mac.clone()));\n+                            self.collected.insert(call_site, mac);\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n+    fn check_attribute(&mut self, lcx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+        if in_macro(attr.span) {\n+            let call_site = attr.span.source_callsite();\n+            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            if let Some(callee) = attr.span.source_callee() {\n+                if !self.collected.contains_key(&call_site) {\n+                    println!(\"{:?}\\n{:#?}\", call_site, attr);\n+\n+                    let name = if name.contains(\"::\") {\n+                        name.split(\"::\").last().unwrap().to_string()\n+                    } else {\n+                        name.to_string()\n+                    };\n \n-    fn check_expr(&mut self, ecx: &EarlyContext<'_>, expr: &ast::Expr) {\n+                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n+                    self.mac_refs.push((call_site, mac.clone()));\n+                    self.collected.insert(call_site, mac);\n+                }\n+            }\n+        }\n+    }\n+    fn check_expr(&mut self, lcx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         if in_macro(expr.span) {\n-            let name = snippet(ecx, ecx.sess.source_map().span_until_char(expr.span.source_callsite(), '!'), \"_\");\n+            let call_site = expr.span.source_callsite();\n+            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = expr.span.source_callee() {\n-                if self.collected.insert(callee.def_site) {\n-                    println!(\"EXPR {:#?}\", name);\n+                if !self.collected.contains_key(&call_site) {\n+                    let name = if name.contains(\"::\") {\n+                        name.split(\"::\").last().unwrap().to_string()\n+                    } else {\n+                        name.to_string()\n+                    };\n+\n+                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n+                    self.mac_refs.push((call_site, mac.clone()));\n+                    self.collected.insert(call_site, mac);\n                 }\n             }\n         }\n     }\n-    fn check_stmt(&mut self, ecx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n+    fn check_stmt(&mut self, lcx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n         if in_macro(stmt.span) {\n-            let name = snippet(ecx, ecx.sess.source_map().span_until_char(stmt.span.source_callsite(), '!'), \"_\");\n+            let call_site = stmt.span.source_callsite();\n+            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = stmt.span.source_callee() {\n-                println!(\"EXPR {:#?}\", name);\n+                if !self.collected.contains_key(&call_site) {\n+                    let name = if name.contains(\"::\") {\n+                        name.split(\"::\").last().unwrap().to_string()\n+                    } else {\n+                        name.to_string()\n+                    };\n+\n+                    let mac = MacroRefData::new(name, callee.def_site, lcx);\n+                    self.mac_refs.push((call_site, mac.clone()));\n+                    self.collected.insert(call_site, mac);\n+                }\n             }\n         }\n     }\n-    fn check_pat(&mut self, ecx: &EarlyContext<'_>, pat: &ast::Pat) {\n+    fn check_pat(&mut self, lcx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n         if in_macro(pat.span) {\n-            let name = snippet(ecx, ecx.sess.source_map().span_until_char(pat.span.source_callsite(), '!'), \"_\");\n+            let call_site = pat.span.source_callsite();\n+            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n             if let Some(callee) = pat.span.source_callee() {\n-                println!(\"EXPR {:#?}\", name);\n+                if !self.collected.contains_key(&call_site) {\n+                    let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n+                    self.mac_refs.push((call_site, mac.clone()));\n+                    self.collected.insert(call_site, mac);\n+                }\n             }\n         }\n     }\n-}\n+    fn check_ty(&mut self, lcx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+        if in_macro(ty.span) {\n+            let call_site = ty.span.source_callsite();\n+            let name = snippet(lcx, lcx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+            if let Some(callee) = ty.span.source_callee() {\n+                if !self.collected.contains_key(&call_site) {\n+                    let mac = MacroRefData::new(name.to_string(), callee.def_site, lcx);\n+                    self.mac_refs.push((call_site, mac.clone()));\n+                    self.collected.insert(call_site, mac);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, lcx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+        for (import, span) in self.imports.iter() {\n+            let matched = self\n+                .mac_refs\n+                .iter()\n+                .find(|(_span, mac)| import.ends_with(&mac.name))\n+                .is_some();\n \n-fn find_used_macros(ecx: &EarlyContext<'_>, path: &str) {\n-    for it in ecx.krate.module.items.iter() {\n-        if in_macro(it.span) {\n-            // println!(\"{:#?}\", it)\n+            if matched {\n+                self.mac_refs.retain(|(_span, mac)| !import.ends_with(&mac.name));\n+                let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n+                let help = format!(\"use {}\", import);\n+                span_lint_and_sugg(\n+                    lcx,\n+                    MACRO_USE_IMPORTS,\n+                    *span,\n+                    msg,\n+                    \"remove the attribute and import the macro directly, try\",\n+                    help,\n+                    Applicability::HasPlaceholders,\n+                )\n+            }\n+        }\n+        if !self.mac_refs.is_empty() {\n+            // TODO if not empty we found one we could not make a suggestion for\n+            // such as std::prelude::v1 or something else I haven't thought of.\n+            // println!(\"{:#?}\", self.mac_refs);\n         }\n     }\n-    for x in ecx.sess.imported_macro_spans.borrow().iter() {\n-        // println!(\"{:?}\", x);\n+}\n+\n+const PRELUDE: &[&str] = &[\n+    \"marker\", \"ops\", \"convert\", \"iter\", \"option\", \"result\", \"borrow\", \"boxed\", \"string\", \"vec\", \"macros\",\n+];\n+\n+/// This is somewhat of a fallback for imports from `std::prelude` because they\n+/// are not recognized by `LateLintPass::check_item` `lcx.tcx.item_children(id)`\n+fn make_path(mac: &MacroRefData, use_path: &str) -> String {\n+    let segs = mac.path.split(\"::\").filter(|s| *s != \"\").collect::<Vec<_>>();\n+\n+    if segs.starts_with(&[\"std\"]) && PRELUDE.iter().any(|m| segs.contains(m)) {\n+        return format!(\n+            \"std::prelude::{} is imported by default, remove `use` statement\",\n+            mac.name\n+        );\n+    }\n+\n+    if use_path.split(\"::\").count() == 1 {\n+        return format!(\"{}::{}\", use_path, mac.name);\n     }\n+\n+    mac.path.clone()\n }"}, {"sha": "61d3a827f1f77ecf6d8dd69590a42eb2cfb26354", "filename": "macro_use_import", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a4b8bb88f210de7fa2d82fe64b48331126eb7462/macro_use_import", "raw_url": "https://github.com/rust-lang/rust/raw/a4b8bb88f210de7fa2d82fe64b48331126eb7462/macro_use_import", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/macro_use_import?ref=a4b8bb88f210de7fa2d82fe64b48331126eb7462"}, {"sha": "c63149a6819c89d19b6d1c97e89c651e53c20b57", "filename": "tests/ui/auxiliary/macro_use_helper.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs?ref=ede366be637657280ca506c5bad0f41f96c47340", "patch": "@@ -0,0 +1,55 @@\n+extern crate macro_rules;\n+\n+// STMT\n+#[macro_export]\n+macro_rules! pub_macro {\n+    () => {\n+        let _ = \"hello Mr. Vonnegut\";\n+    };\n+}\n+\n+pub mod inner {\n+    pub use super::*;\n+\n+    // RE-EXPORT\n+    // this will stick in `inner` module\n+    pub use macro_rules::try_err;\n+\n+    // ITEM\n+    #[macro_export]\n+    macro_rules! inner_mod {\n+        () => {\n+            #[allow(dead_code)]\n+            pub struct Tardis;\n+        };\n+    }\n+}\n+\n+// EXPR\n+#[macro_export]\n+macro_rules! function {\n+    () => {\n+        if true {\n+        } else {\n+        }\n+    };\n+}\n+\n+// TYPE\n+#[macro_export]\n+macro_rules! ty_mac {\n+    () => {\n+        Vec<u8>\n+    };\n+}\n+\n+mod extern_exports {\n+    pub(super) mod private_inner {\n+        #[macro_export]\n+        macro_rules! pub_in_private {\n+            ($name:ident) => {\n+                let $name = String::from(\"secrets and lies\");\n+            };\n+        }\n+    }\n+}"}, {"sha": "6490a2107d5ac2690fa8cf43aeb75fabf805447a", "filename": "tests/ui/macro_use_import.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4b8bb88f210de7fa2d82fe64b48331126eb7462/tests%2Fui%2Fmacro_use_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b8bb88f210de7fa2d82fe64b48331126eb7462/tests%2Fui%2Fmacro_use_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_import.rs?ref=a4b8bb88f210de7fa2d82fe64b48331126eb7462", "patch": "@@ -1,12 +0,0 @@\n-// compile-flags: --edition 2018\n-#![warn(clippy::macro_use_import)]\n-\n-use std::collections::HashMap;\n-#[macro_use]\n-use std::prelude;\n-\n-fn main() {\n-    let _ = HashMap::<u8, u8>::new();\n-    serde_if_integer128!(\"\");\n-    println!();\n-}"}, {"sha": "1d86ba584411f85d189a980298aa93cbd472a852", "filename": "tests/ui/macro_use_import.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4b8bb88f210de7fa2d82fe64b48331126eb7462/tests%2Fui%2Fmacro_use_import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4b8bb88f210de7fa2d82fe64b48331126eb7462/tests%2Fui%2Fmacro_use_import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_import.stderr?ref=a4b8bb88f210de7fa2d82fe64b48331126eb7462", "patch": "@@ -1,10 +0,0 @@\n-error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_import.rs:5:1\n-   |\n-LL | #[macro_use]\n-   | ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use std::prelude::<macro name>`\n-   |\n-   = note: `-D clippy::macro-use-import` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "76911b0c565f091cdc0668bf987a89513d410a4a", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede366be637657280ca506c5bad0f41f96c47340/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=ede366be637657280ca506c5bad0f41f96c47340", "patch": "@@ -1,11 +1,40 @@\n-// edition:2018\n+// compile-flags: --edition 2018\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+\n+#![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]\n \n-use std::collections::HashMap;\n #[macro_use]\n-use std::prelude;\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate clippy_mini_macro_test as mini_mac;\n+\n+mod a {\n+    #[macro_use]\n+    use std::prelude;\n+    #[macro_use]\n+    use mac;\n+    #[macro_use]\n+    use mini_mac;\n+    #[macro_use]\n+    use mac::inner;\n+\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn main() {\n+        pub_macro!();\n+        inner_mod!();\n+        pub_in_private!(_var);\n+        function!();\n+        let v: ty_mac!() = Vec::default();\n+\n+        inner::try_err!();\n+    }\n+}\n \n fn main() {\n-    let _ = HashMap::<u8, u8>::new();\n     println!();\n }"}]}