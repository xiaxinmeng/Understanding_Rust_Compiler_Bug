{"sha": "1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NzNmODRlYmJiM2IyYmI0YjlhMTQ4OGI2NTUzYWM0NmIyZGI4ZDQ=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-25T18:13:16Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-06T02:24:17Z"}, "message": "Addressed all feedback to date", "tree": {"sha": "afdc71d2c96bc6fcb4ce8782a2bbfe8fbbaef1fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afdc71d2c96bc6fcb4ce8782a2bbfe8fbbaef1fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "html_url": "https://github.com/rust-lang/rust/commit/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5545c56e9d55909e7b4549c158a39449068d2ef0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5545c56e9d55909e7b4549c158a39449068d2ef0", "html_url": "https://github.com/rust-lang/rust/commit/5545c56e9d55909e7b4549c158a39449068d2ef0"}], "stats": {"total": 98, "additions": 41, "deletions": 57}, "files": [{"sha": "e21e03822ebb3cda5a3147839a2d2345ed8307bd", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -82,21 +82,19 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn add_coverage_counter(\n         &mut self,\n         instance: Instance<'tcx>,\n-        function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n     ) -> bool {\n         if let Some(coverage_context) = self.coverage_context() {\n             debug!(\n-                \"adding counter to coverage_map: instance={:?}, function_source_hash={}, id={:?}, \\\n-                at {:?}\",\n-                instance, function_source_hash, id, region,\n+                \"adding counter to coverage_map: instance={:?}, id={:?}, region={:?}\",\n+                instance, id, region,\n             );\n             let mut coverage_map = coverage_context.function_coverage_map.borrow_mut();\n             coverage_map\n                 .entry(instance)\n                 .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-                .add_counter(function_source_hash, id, region);\n+                .add_counter(id, region);\n             true\n         } else {\n             false"}, {"sha": "b0d7953f511c7969d7aff463d1ee4639d297f8df", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -52,11 +52,8 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         }\n     }\n \n-    /// Although every function should have at least one `Counter`, the `Counter` isn't required to\n-    /// have a `CodeRegion`. (The `CodeRegion` may be associated only with `Expressions`.) This\n-    /// method supports the ability to ensure the `function_source_hash` is set from `Counters` that\n-    /// do not trigger the call to `add_counter()` because they don't have an associated\n-    /// `CodeRegion` to add.\n+    /// Sets the function source hash value. If called multiple times for the same function, all\n+    /// calls should have the same hash value.\n     pub fn set_function_source_hash(&mut self, source_hash: u64) {\n         if self.source_hash == 0 {\n             self.source_hash = source_hash;\n@@ -66,14 +63,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     }\n \n     /// Adds a code region to be counted by an injected counter intrinsic.\n-    /// The source_hash (computed during coverage instrumentation) should also be provided, and\n-    /// should be the same for all counters in a given function.\n-    pub fn add_counter(&mut self, source_hash: u64, id: CounterValueReference, region: CodeRegion) {\n-        if self.source_hash == 0 {\n-            self.source_hash = source_hash;\n-        } else {\n-            debug_assert_eq!(source_hash, self.source_hash);\n-        }\n+    pub fn add_counter(&mut self, id: CounterValueReference, region: CodeRegion) {\n         self.counters[id].replace(region).expect_none(\"add_counter called with duplicate `id`\");\n     }\n "}, {"sha": "a115d35866638703ae589ec205f0ffeda3aa0605", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -10,15 +10,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                let covmap_updated = if let Some(code_region) = code_region {\n-                    // Note: Some counters do not have code regions, but may still be referenced from\n-                    // expressions.\n-                    bx.add_coverage_counter(self.instance, function_source_hash, id, code_region)\n-                } else {\n-                    bx.set_function_source_hash(self.instance, function_source_hash)\n-                };\n+                if bx.set_function_source_hash(self.instance, function_source_hash) {\n+                    // If `set_function_source_hash()` returned true, the coverage map is enabled,\n+                    // so continue adding the counter.\n+                    if let Some(code_region) = code_region {\n+                        // Note: Some counters do not have code regions, but may still be referenced\n+                        // from expressions. In that case, don't add the counter to the coverage map,\n+                        // but do inject the counter intrinsic.\n+                        bx.add_coverage_counter(self.instance, id, code_region);\n+                    }\n \n-                if covmap_updated {\n                     let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n \n                     let fn_name = bx.create_pgo_func_name_var(self.instance);"}, {"sha": "95bddfb4b41d16d605a256615e305269d3eeb191", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -9,8 +9,9 @@ pub trait CoverageInfoMethods: BackendTypes {\n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n \n-    /// Returns true if the function source hash was added to the coverage map; false if\n-    /// `-Z instrument-coverage` is not enabled (a coverage map is not being generated).\n+    /// Returns true if the function source hash was added to the coverage map (even if it had\n+    /// already been added, for this instance). Returns false *only* if `-Z instrument-coverage` is\n+    /// not enabled (a coverage map is not being generated).\n     fn set_function_source_hash(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -22,7 +23,6 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn add_coverage_counter(\n         &mut self,\n         instance: Instance<'tcx>,\n-        function_source_hash: u64,\n         index: CounterValueReference,\n         region: CodeRegion,\n     ) -> bool;"}, {"sha": "3a97e05a39fe8675d77e036385e15b2659b8b916", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -85,27 +85,13 @@ impl From<CounterValueReference> for ExpressionOperandId {\n     }\n }\n \n-impl From<&mut CounterValueReference> for ExpressionOperandId {\n-    #[inline]\n-    fn from(v: &mut CounterValueReference) -> ExpressionOperandId {\n-        ExpressionOperandId::from(v.as_u32())\n-    }\n-}\n-\n impl From<InjectedExpressionId> for ExpressionOperandId {\n     #[inline]\n     fn from(v: InjectedExpressionId) -> ExpressionOperandId {\n         ExpressionOperandId::from(v.as_u32())\n     }\n }\n \n-impl From<&mut InjectedExpressionId> for ExpressionOperandId {\n-    #[inline]\n-    fn from(v: &mut InjectedExpressionId) -> ExpressionOperandId {\n-        ExpressionOperandId::from(v.as_u32())\n-    }\n-}\n-\n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum CoverageKind {\n     Counter {"}, {"sha": "7454ec2f438772f1c3c10002f64e78cce3e68ab8", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -12,6 +12,16 @@ use rustc_data_structures::graph::WithNumNodes;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::coverage::*;\n \n+// When evaluating an expression operand to determine if it references a `Counter` or an\n+// `Expression`, the range of counter or expression IDs must be known in order to answer the\n+// question: \"Does this ID fall inside the range of counters,\" for example. If \"yes,\" the ID refers\n+// to a counter, otherwise the ID refers to an expression.\n+//\n+// But in situations where the range is not currently known, the only fallback is to assume a\n+// specific range limit. `MAX_COUNTER_GUARD` enforces a limit on the number of counters, and\n+// therefore a limit on the range of counter IDs.\n+pub(crate) const MAX_COUNTER_GUARD: u32 = (u32::MAX / 2) + 1;\n+\n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n /// `Coverage` statements.\n pub(crate) struct CoverageCounters {\n@@ -95,6 +105,7 @@ impl CoverageCounters {\n     /// Counter IDs start from one and go up.\n     fn next_counter(&mut self) -> CounterValueReference {\n         assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n+        assert!(self.next_counter_id <= MAX_COUNTER_GUARD);\n         let next = self.next_counter_id;\n         self.next_counter_id += 1;\n         CounterValueReference::from(next)"}, {"sha": "2fbbc9b675a1eab878d1bfbecab8f709e05b7cf1", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -1,3 +1,5 @@\n+use super::counters;\n+\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{Coverage, CoverageInfo, Location};\n@@ -32,21 +34,16 @@ pub(crate) fn provide(providers: &mut Providers) {\n /// safeguard, with `add_missing_operands` set to `true`, to find any other counter or expression\n /// IDs referenced by expression operands, if not already seen.\n ///\n-/// Ideally, every expression operand in the MIR will have a corresponding Counter or Expression,\n-/// but since current or future MIR optimizations can theoretically optimize out segments of a\n-/// MIR, it may not be possible to guarantee this, so the second pass ensures the `CoverageInfo`\n-/// counts include all referenced IDs.\n+/// Ideally, each operand ID in a MIR `CoverageKind::Expression` will have a separate MIR `Coverage`\n+/// statement for the `Counter` or `Expression` with the referenced ID. but since current or future\n+/// MIR optimizations can theoretically optimize out segments of a MIR, it may not be possible to\n+/// guarantee this, so the second pass ensures the `CoverageInfo` counts include all referenced IDs.\n struct CoverageVisitor {\n     info: CoverageInfo,\n     add_missing_operands: bool,\n }\n \n impl CoverageVisitor {\n-    // If an expression operand is encountered with an ID outside the range of known counters and\n-    // expressions, the only way to determine if the ID is a counter ID or an expression ID is to\n-    // assume a maximum possible counter ID value.\n-    const MAX_COUNTER_GUARD: u32 = (u32::MAX / 2) + 1;\n-\n     #[inline(always)]\n     fn update_num_counters(&mut self, counter_id: u32) {\n         self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n@@ -62,7 +59,10 @@ impl CoverageVisitor {\n         if operand_id >= self.info.num_counters {\n             let operand_as_expression_index = u32::MAX - operand_id;\n             if operand_as_expression_index >= self.info.num_expressions {\n-                if operand_id <= Self::MAX_COUNTER_GUARD {\n+                if operand_id <= counters::MAX_COUNTER_GUARD {\n+                    // Since the complete range of counter and expression IDs is not known here, the\n+                    // only way to determine if the ID is a counter ID or an expression ID is to\n+                    // assume a maximum possible counter ID value.\n                     self.update_num_counters(operand_id)\n                 } else {\n                     self.update_num_expressions(operand_id)"}, {"sha": "8549ac0e4afd110e76e04be9a9d007e9ea9d7f45", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=1973f84ebbb3b2bb4b9a1488b6553ac46b2db8d4", "patch": "@@ -388,8 +388,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n         bcb_data\n             .basic_blocks\n             .iter()\n-            .map(|bbref| {\n-                let bb = *bbref;\n+            .flat_map(|&bb| {\n                 let data = &self.mir_body[bb];\n                 data.statements\n                     .iter()\n@@ -404,7 +403,6 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                             .map(|span| CoverageSpan::for_terminator(span, bcb, bb)),\n                     )\n             })\n-            .flatten()\n             .collect()\n     }\n \n@@ -733,7 +731,7 @@ fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -\n         // However, in other cases, a visible `CoverageSpan` is not wanted, but the `Goto`\n         // block must still be counted (for example, to contribute its count to an `Expression`\n         // that reports the execution count for some other block). In these cases, the code region\n-        // is set to `None`.\n+        // is set to `None`. (See `Instrumentor::is_code_region_redundant()`.)\n         TerminatorKind::Goto { .. } => {\n             Some(function_source_span(terminator.source_info.span.shrink_to_hi(), body_span))\n         }"}]}