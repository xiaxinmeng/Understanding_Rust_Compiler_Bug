{"sha": "7333c4ac25648e831fb2033ee77fbbdc62ae492a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMzNjNGFjMjU2NDhlODMxZmIyMDMzZWU3N2ZiYmRjNjJhZTQ5MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-31T21:41:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-31T21:41:58Z"}, "message": "Auto merge of #35143 - arielb1:rfc447-regions, r=eddyb\n\ntypeck: use a TypeVisitor in ctp\n\nUse a TypeVisitor in ctp instead of `ty::walk`\n\nThis fixes a few cases where a region could be projected out of a trait while not being constrained by the type parameters, violating rust-lang/rfcs#447 and breaking soundness. As such, this is a [breaking-change].\n\nFixes #35139\n\nr? @eddyb", "tree": {"sha": "a1a0e76e2608dfe3d6c0452675d7ca200b4ab591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1a0e76e2608dfe3d6c0452675d7ca200b4ab591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7333c4ac25648e831fb2033ee77fbbdc62ae492a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7333c4ac25648e831fb2033ee77fbbdc62ae492a", "html_url": "https://github.com/rust-lang/rust/commit/7333c4ac25648e831fb2033ee77fbbdc62ae492a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7333c4ac25648e831fb2033ee77fbbdc62ae492a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b87f031e79d870f6b148339e21e5c2a3112d4af", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b87f031e79d870f6b148339e21e5c2a3112d4af", "html_url": "https://github.com/rust-lang/rust/commit/2b87f031e79d870f6b148339e21e5c2a3112d4af"}, {"sha": "0a128f325e47ae5c554ff1bcb76db142355a5919", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a128f325e47ae5c554ff1bcb76db142355a5919", "html_url": "https://github.com/rust-lang/rust/commit/0a128f325e47ae5c554ff1bcb76db142355a5919"}], "stats": {"total": 154, "additions": 83, "deletions": 71}, "files": [{"sha": "ec95afe15bd518778b2556eec503c60fc8102973", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7333c4ac25648e831fb2033ee77fbbdc62ae492a", "patch": "@@ -2237,9 +2237,9 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: HashSet<_> =\n-        ctp::parameters_for_type(impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n+        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n \n     ctp::setup_constraining_predicates(impl_predicates.predicates.get_mut_slice(TypeSpace),\n@@ -2267,9 +2267,9 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters: HashSet<_> =\n-        ctp::parameters_for_type(impl_scheme.ty, false).into_iter().collect();\n+        ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n+        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n@@ -2280,7 +2280,7 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n             ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n         })\n-        .flat_map(|ty| ctp::parameters_for_type(ty, true))\n+        .flat_map(|ty| ctp::parameters_for(&ty, true))\n         .filter_map(|p| match p {\n             ctp::Parameter::Type(_) => None,\n             ctp::Parameter::Region(r) => Some(r),"}, {"sha": "7909584bfabdf560b4c11ffe97b08f3133a2667d", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=7333c4ac25648e831fb2033ee77fbbdc62ae492a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::{self, subst, Ty};\n-\n+use rustc::ty::{self, Ty};\n+use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use std::collections::HashSet;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -19,77 +19,53 @@ pub enum Parameter {\n }\n \n /// If `include_projections` is false, returns the list of parameters that are\n-/// constrained by the type `ty` - i.e. the value of each parameter in the list is\n-/// uniquely determined by `ty` (see RFC 447). If it is true, return the list\n+/// constrained by `t` - i.e. the value of each parameter in the list is\n+/// uniquely determined by `t` (see RFC 447). If it is true, return the list\n /// of parameters whose values are needed in order to constrain `ty` - these\n /// differ, with the latter being a superset, in the presence of projections.\n-pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>,\n-                                 include_projections: bool) -> Vec<Parameter> {\n-    let mut result = vec![];\n-    ty.maybe_walk(|t| match t.sty {\n-        ty::TyProjection(..) if !include_projections => {\n+pub fn parameters_for<'tcx, T>(t: &T,\n+                               include_nonconstraining: bool)\n+                               -> Vec<Parameter>\n+    where T: TypeFoldable<'tcx>\n+{\n \n-            false // projections are not injective.\n-        }\n-        _ => {\n-            result.append(&mut parameters_for_type_shallow(t));\n-            // non-projection type constructors are injective.\n-            true\n-        }\n-    });\n-    result\n+    let mut collector = ParameterCollector {\n+        parameters: vec![],\n+        include_nonconstraining: include_nonconstraining\n+    };\n+    t.visit_with(&mut collector);\n+    collector.parameters\n }\n \n-pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>,\n-                                      include_projections: bool) -> Vec<Parameter> {\n-    let mut region_parameters =\n-        parameters_for_regions_in_substs(&trait_ref.substs);\n-\n-    let type_parameters =\n-        trait_ref.substs\n-                 .types\n-                 .iter()\n-                 .flat_map(|ty| parameters_for_type(ty, include_projections));\n-\n-    region_parameters.extend(type_parameters);\n-\n-    region_parameters\n+struct ParameterCollector {\n+    parameters: Vec<Parameter>,\n+    include_nonconstraining: bool\n }\n \n-fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n-    match ty.sty {\n-        ty::TyParam(ref d) =>\n-            vec![Parameter::Type(d.clone())],\n-        ty::TyRef(region, _) =>\n-            parameters_for_region(region).into_iter().collect(),\n-        ty::TyStruct(_, substs) |\n-        ty::TyEnum(_, substs) =>\n-            parameters_for_regions_in_substs(substs),\n-        ty::TyTrait(ref data) =>\n-            parameters_for_regions_in_substs(&data.principal.skip_binder().substs),\n-        ty::TyProjection(ref pi) =>\n-            parameters_for_regions_in_substs(&pi.trait_ref.substs),\n-        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-        ty::TyFloat(..) | ty::TyBox(..) | ty::TyStr |\n-        ty::TyArray(..) | ty::TySlice(..) |\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) |\n-        ty::TyTuple(..) | ty::TyRawPtr(..) |\n-        ty::TyInfer(..) | ty::TyClosure(..) | ty::TyError =>\n-            vec![]\n-    }\n-}\n+impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.sty {\n+            ty::TyProjection(..) if !self.include_nonconstraining => {\n+                // projections are not injective\n+                return false;\n+            }\n+            ty::TyParam(ref d) => {\n+                self.parameters.push(Parameter::Type(d.clone()));\n+            }\n+            _ => {}\n+        }\n \n-fn parameters_for_regions_in_substs(substs: &subst::Substs) -> Vec<Parameter> {\n-    substs.regions\n-          .iter()\n-          .filter_map(|r| parameters_for_region(r))\n-          .collect()\n-}\n+        t.super_visit_with(self)\n+    }\n \n-fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n-    match *region {\n-        ty::ReEarlyBound(data) => Some(Parameter::Region(data)),\n-        _ => None,\n+    fn visit_region(&mut self, r: ty::Region) -> bool {\n+        match r {\n+            ty::ReEarlyBound(data) => {\n+                self.parameters.push(Parameter::Region(data));\n+            }\n+            _ => {}\n+        }\n+        false\n     }\n }\n \n@@ -191,12 +167,12 @@ pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n \n-                let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref, true);\n+                let inputs = parameters_for(&projection.projection_ty.trait_ref, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;\n                 }\n-                input_parameters.extend(parameters_for_type(projection.ty, false));\n+                input_parameters.extend(parameters_for(&projection.ty, false));\n             } else {\n                 continue;\n             }"}, {"sha": "67f0e7aaf9717ee68161684dccc9d3ee6caf026c", "filename": "src/test/compile-fail/issue-35139.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7333c4ac25648e831fb2033ee77fbbdc62ae492a/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs?ref=7333c4ac25648e831fb2033ee77fbbdc62ae492a", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+pub trait MethodType {\n+    type GetProp: ?Sized;\n+}\n+\n+pub struct MTFn;\n+\n+impl<'a> MethodType for MTFn { //~ ERROR E0207\n+    type GetProp = fmt::Debug + 'a;\n+}\n+\n+fn bad(a: Box<<MTFn as MethodType>::GetProp>) -> Box<fmt::Debug+'static> {\n+    a\n+}\n+\n+fn dangling(a: &str) -> Box<fmt::Debug> {\n+    bad(Box::new(a))\n+}\n+\n+fn main() {\n+    let mut s = \"hello\".to_string();\n+    let x = dangling(&s);\n+    s = String::new();\n+    println!(\"{:?}\", x);\n+}"}]}