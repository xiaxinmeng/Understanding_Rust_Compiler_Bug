{"sha": "ebe67d98103717518904950a7a2008dd909d5f92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZTY3ZDk4MTAzNzE3NTE4OTA0OTUwYTdhMjAwOGRkOTA5ZDVmOTI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-25T13:34:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-25T13:34:05Z"}, "message": "Rollup merge of #82514 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\nBi-weekly Clippy update.\n\nThis updates `Cargo.lock`, so probably needs rollup=never. (https://github.com/rust-lang/rust/commit/0046d7c33e944e87a5cabc940f21bacdce5af307)\n\nhttps://github.com/rust-lang/rust/commit/a6dd9b96068800fd548a72b3aa7ac4712d1d0c49 fixes things in Clippy, so that it can be build and tested. This needs proper fixing in Clippy, but I didn't want this to block the sync.\n\nr? `@Manishearth`", "tree": {"sha": "8b3b283bb58cdeea4bd6c2adbddc08780f2d3980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b3b283bb58cdeea4bd6c2adbddc08780f2d3980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe67d98103717518904950a7a2008dd909d5f92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgN6dNCRBK7hj4Ov3rIwAAdHIIAHoQODUDPd2xdmEJUQ7obAh3\nMzy7vwZeQR4pJNmqbGiOWtpryK7FuYyghJJdYAZhZNWYqIwfhoMuErOb8P7rRG5g\noolkGfY5suCUI2eC16+5WtH6YVLnbqjo3glPDAjil7BLu+RzqRZMX5Cx9cDusn5t\nUwKwgNteqY3dv5Hjq+Z+D+ipLtBMOgcQE6SrgQ2U05bbuW9zfybBvvY7n1lQbqLQ\neTyDPDoU/rWS3mbEIj6oYt6lzCFYmoMjehL48lA7CL5AiyA2dyEVSvx0hapyM1eu\n8cUXwTx1eKf5bLJZo3RBBSVut9edUegllLAKch0jgGKVKQtStpvww4loiqtYTak=\n=/kga\n-----END PGP SIGNATURE-----\n", "payload": "tree 8b3b283bb58cdeea4bd6c2adbddc08780f2d3980\nparent 12ea0f6112d99310ba992f5656c29929da0bc6eb\nparent 0046d7c33e944e87a5cabc940f21bacdce5af307\nauthor Dylan DPC <dylan.dpc@gmail.com> 1614260045 +0100\ncommitter GitHub <noreply@github.com> 1614260045 +0100\n\nRollup merge of #82514 - flip1995:clippyup, r=Manishearth\n\nUpdate Clippy\n\nBi-weekly Clippy update.\n\nThis updates `Cargo.lock`, so probably needs rollup=never. (https://github.com/rust-lang/rust/commit/0046d7c33e944e87a5cabc940f21bacdce5af307)\n\nhttps://github.com/rust-lang/rust/commit/a6dd9b96068800fd548a72b3aa7ac4712d1d0c49 fixes things in Clippy, so that it can be build and tested. This needs proper fixing in Clippy, but I didn't want this to block the sync.\n\nr? `@Manishearth`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe67d98103717518904950a7a2008dd909d5f92", "html_url": "https://github.com/rust-lang/rust/commit/ebe67d98103717518904950a7a2008dd909d5f92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe67d98103717518904950a7a2008dd909d5f92/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12ea0f6112d99310ba992f5656c29929da0bc6eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/12ea0f6112d99310ba992f5656c29929da0bc6eb", "html_url": "https://github.com/rust-lang/rust/commit/12ea0f6112d99310ba992f5656c29929da0bc6eb"}, {"sha": "0046d7c33e944e87a5cabc940f21bacdce5af307", "url": "https://api.github.com/repos/rust-lang/rust/commits/0046d7c33e944e87a5cabc940f21bacdce5af307", "html_url": "https://github.com/rust-lang/rust/commit/0046d7c33e944e87a5cabc940f21bacdce5af307"}], "stats": {"total": 9860, "additions": 6576, "deletions": 3284}, "files": [{"sha": "7491c1712669ca8c6ec5dde82e81977c7119cda3", "filename": "Cargo.lock", "status": "modified", "additions": 119, "deletions": 11, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -565,14 +565,14 @@ dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs\",\n+ \"compiletest_rs 0.6.0\",\n  \"derive-new\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver 0.11.0\",\n  \"serde\",\n  \"tempfile\",\n- \"tester\",\n+ \"tester 0.9.0\",\n ]\n \n [[package]]\n@@ -584,6 +584,7 @@ name = \"clippy_lints\"\n version = \"0.1.52\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n+ \"clippy_utils\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"pulldown-cmark 0.8.0\",\n@@ -600,6 +601,20 @@ dependencies = [\n  \"url 2.1.1\",\n ]\n \n+[[package]]\n+name = \"clippy_utils\"\n+version = \"0.1.52\"\n+dependencies = [\n+ \"if_chain\",\n+ \"itertools 0.9.0\",\n+ \"regex-syntax\",\n+ \"rustc-semver\",\n+ \"serde\",\n+ \"smallvec 1.6.1\",\n+ \"toml\",\n+ \"unicode-normalization\",\n+]\n+\n [[package]]\n name = \"cloudabi\"\n version = \"0.1.0\"\n@@ -695,7 +710,30 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester\",\n+ \"tester 0.7.0\",\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"compiletest_rs\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0086d6ad78cf409c3061618cd98e2789d5c9ce598fc9651611cf62eae0a599cb\"\n+dependencies = [\n+ \"diff\",\n+ \"filetime\",\n+ \"getopts\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"log\",\n+ \"miow 0.3.6\",\n+ \"regex\",\n+ \"rustfix\",\n+ \"serde\",\n+ \"serde_derive\",\n+ \"serde_json\",\n+ \"tempfile\",\n+ \"tester 0.9.0\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -984,14 +1022,35 @@ dependencies = [\n  \"dirs-sys\",\n ]\n \n+[[package]]\n+name = \"dirs-next\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"dirs-sys-next\",\n+]\n+\n [[package]]\n name = \"dirs-sys\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8e93d7f5705de3e49895a2b5e0b8855a1c27f080192ae9c32a6432d50741a57a\"\n dependencies = [\n  \"libc\",\n- \"redox_users\",\n+ \"redox_users 0.3.4\",\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"dirs-sys-next\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d\"\n+dependencies = [\n+ \"libc\",\n+ \"redox_users 0.4.0\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1115,7 +1174,7 @@ checksum = \"3ed85775dcc68644b5c950ac06a2b23768d3bc9390464151aaf27136998dcf9e\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -2226,7 +2285,7 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n- \"compiletest_rs\",\n+ \"compiletest_rs 0.5.0\",\n  \"env_logger 0.7.1\",\n  \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n@@ -2458,7 +2517,7 @@ dependencies = [\n  \"cloudabi\",\n  \"instant\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"smallvec 1.6.1\",\n  \"winapi 0.3.9\",\n ]\n@@ -2899,17 +2958,36 @@ version = \"0.1.57\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce\"\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"94341e4e44e24f6b591b59e47a8a027df12e008d73fd5672dbea9cc22f4507d9\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n [[package]]\n name = \"redox_users\"\n version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09b23093265f8d200fa7b4c2c76297f47e681c655f6f1285a8780d6a022f7431\"\n dependencies = [\n  \"getrandom 0.1.14\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"rust-argon2\",\n ]\n \n+[[package]]\n+name = \"redox_users\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+ \"redox_syscall 0.2.5\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"1.4.3\"\n@@ -4535,6 +4613,12 @@ dependencies = [\n  \"unicode_categories\",\n ]\n \n+[[package]]\n+name = \"rustversion\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cb5d2a036dc6d2d8fd16fde3498b04306e29bd193bf306a57427019b823d5acd\"\n+\n [[package]]\n name = \"ryu\"\n version = \"1.0.5\"\n@@ -4812,7 +4896,7 @@ checksum = \"7fd8b795c389288baa5f355489c65e71fd48a02104600d15c4cfbc561e9e429d\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -4973,7 +5057,7 @@ checksum = \"c8a4c1d0bee3230179544336c15eefb563cf0302955d962e456542323e8c2e8a\"\n dependencies = [\n  \"filetime\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"xattr\",\n ]\n \n@@ -4986,7 +5070,7 @@ dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n  \"rand\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"remove_dir_all\",\n  \"winapi 0.3.9\",\n ]\n@@ -5020,6 +5104,17 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"term\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c59df8ac95d96ff9bede18eb7300b0fda5e5d8d90960e76f8e14ae765eedbf1f\"\n+dependencies = [\n+ \"dirs-next\",\n+ \"rustversion\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.1.0\"\n@@ -5065,6 +5160,19 @@ dependencies = [\n  \"term 0.6.1\",\n ]\n \n+[[package]]\n+name = \"tester\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0639d10d8f4615f223a57275cf40f9bdb7cfbb806bcb7f7cc56e3beb55a576eb\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"getopts\",\n+ \"libc\",\n+ \"num_cpus\",\n+ \"term 0.7.0\",\n+]\n+\n [[package]]\n name = \"textwrap\"\n version = \"0.11.0\""}, {"sha": "2bc87db123d4d38d126ba80a597f43b0d3e8524b", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n ---\n name: Bug Report\n about: Create a bug report for Clippy\n-labels: L-bug\n+labels: C-bug\n ---\n <!--\n Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,"}, {"sha": "53341c7a928afd77a9ccac06bb3f4b9b992e31c2", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_negative.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n ---\n name: Bug Report (False Negative)\n about: Create a bug report about missing warnings from a lint\n-labels: L-bug, L-false-negative\n+labels: C-bug, I-false-negative\n ---\n <!--\n Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,"}, {"sha": "34fd6f4bdb7105f86b548c51fc864a54b12c79fa", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_positive.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n ---\n name: Bug Report (False Positive)\n about: Create a bug report about a wrongly emitted lint warning\n-labels: L-bug, L-false-positive\n+labels: C-bug, I-false-positive\n ---\n <!--\n Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,"}, {"sha": "0b7cd1ed0fb60fb7921be8e6393a04de1e4f80cb", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n ---\n name: Internal Compiler Error\n about: Create a report for an internal compiler error in Clippy.\n-labels: L-bug, L-crash\n+labels: C-bug, I-ICE\n ---\n <!--\n Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide"}, {"sha": "e182c99ce06a24318c16a81ea6de1c612f0769f1", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/new_lint.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n ---\n name: New lint suggestion\n about: Suggest a new Clippy lint.\n-labels: L-lint\n+labels: A-lint\n ---\n \n ### What it does"}, {"sha": "f6ac936df4d6b848207e47bfba419bfb1f3778fb", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -53,16 +53,8 @@ jobs:\n     - name: Test \"--fix -Zunstable-options\"\n       run: cargo run --features deny-warnings,internal-lints --bin cargo-clippy -- clippy --fix -Zunstable-options\n \n-    - name: Test\n-      run: cargo test --features deny-warnings,internal-lints\n-\n-    - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints\n-      working-directory: clippy_lints\n-\n-    - name: Test rustc_tools_util\n-      run: cargo test --features deny-warnings\n-      working-directory: rustc_tools_util\n+    - name: Test Workspace\n+      run: cargo test --all --features deny-warnings,internal-lints\n \n     - name: Test clippy_dev\n       run: cargo test --features deny-warnings"}, {"sha": "9d24b0293c4a73d156dcc0e7cb2465b20417d460", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -112,16 +112,8 @@ jobs:\n     - name: Build\n       run: cargo build --features deny-warnings,internal-lints\n \n-    - name: Test\n-      run: cargo test --features deny-warnings,internal-lints\n-\n-    - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints\n-      working-directory: clippy_lints\n-\n-    - name: Test rustc_tools_util\n-      run: cargo test --features deny-warnings\n-      working-directory: rustc_tools_util\n+    - name: Test Workspace\n+      run: cargo test --all --features deny-warnings,internal-lints\n \n     - name: Test clippy_dev\n       run: cargo test --features deny-warnings"}, {"sha": "139129d55e330af9d2f323986a1c621878152625", "filename": "src/tools/clippy/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.gitignore?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -18,6 +18,7 @@ out\n *Cargo.lock\n /target\n /clippy_lints/target\n+/clippy_utils/target\n /clippy_workspace_tests/target\n /clippy_dev/target\n /rustc_tools_util/target"}, {"sha": "d96c74b6e412650ad73369573a01abd6549fcce5", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 125, "deletions": 4, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -6,13 +6,128 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[4911ab1...master](https://github.com/rust-lang/rust-clippy/compare/4911ab1...master)\n+[3e41797...master](https://github.com/rust-lang/rust-clippy/compare/3e41797...master)\n+\n+## Rust 1.51\n+\n+Current beta, release 2021-03-25\n+\n+[4911ab1...3e41797](https://github.com/rust-lang/rust-clippy/compare/4911ab1...3e41797)\n+\n+### New Lints\n+\n+* [`upper_case_acronyms`]\n+  [#6475](https://github.com/rust-lang/rust-clippy/pull/6475)\n+* [`from_over_into`] [#6476](https://github.com/rust-lang/rust-clippy/pull/6476)\n+* [`case_sensitive_file_extension_comparisons`]\n+  [#6500](https://github.com/rust-lang/rust-clippy/pull/6500)\n+* [`needless_question_mark`]\n+  [#6507](https://github.com/rust-lang/rust-clippy/pull/6507)\n+* [`missing_panics_doc`]\n+  [#6523](https://github.com/rust-lang/rust-clippy/pull/6523)\n+* [`redundant_slicing`]\n+  [#6528](https://github.com/rust-lang/rust-clippy/pull/6528)\n+* [`vec_init_then_push`]\n+  [#6538](https://github.com/rust-lang/rust-clippy/pull/6538)\n+* [`ptr_as_ptr`] [#6542](https://github.com/rust-lang/rust-clippy/pull/6542)\n+* [`collapsible_else_if`] (split out from `collapsible_if`)\n+  [#6544](https://github.com/rust-lang/rust-clippy/pull/6544)\n+* [`inspect_for_each`] [#6577](https://github.com/rust-lang/rust-clippy/pull/6577)\n+* [`manual_filter_map`]\n+  [#6591](https://github.com/rust-lang/rust-clippy/pull/6591)\n+* [`exhaustive_enums`]\n+  [#6617](https://github.com/rust-lang/rust-clippy/pull/6617)\n+* [`exhaustive_structs`]\n+  [#6617](https://github.com/rust-lang/rust-clippy/pull/6617)\n+\n+### Moves and Deprecations\n+\n+* Replace [`find_map`] with [`manual_find_map`]\n+  [#6591](https://github.com/rust-lang/rust-clippy/pull/6591)\n+* [`unknown_clippy_lints`] Now integrated in the `unknown_lints` rustc lint\n+  [#6653](https://github.com/rust-lang/rust-clippy/pull/6653)\n+\n+### Enhancements\n+\n+* [`ptr_arg`] Now also suggests to use `&Path` instead of `&PathBuf`\n+  [#6506](https://github.com/rust-lang/rust-clippy/pull/6506)\n+* [`cast_ptr_alignment`] Also lint when the `pointer::cast` method is used\n+  [#6557](https://github.com/rust-lang/rust-clippy/pull/6557)\n+* [`collapsible_match`] Now also deals with `&` and `*` operators in the `match`\n+  scrutinee [#6619](https://github.com/rust-lang/rust-clippy/pull/6619)\n+\n+### False Positive Fixes\n+\n+* [`similar_names`] Ignore underscore prefixed names\n+  [#6403](https://github.com/rust-lang/rust-clippy/pull/6403)\n+* [`print_literal`] and [`write_literal`] No longer lint numeric literals\n+  [#6408](https://github.com/rust-lang/rust-clippy/pull/6408)\n+* [`large_enum_variant`] No longer lints in external macros\n+  [#6485](https://github.com/rust-lang/rust-clippy/pull/6485)\n+* [`empty_enum`] Only lint if `never_type` feature is enabled\n+  [#6513](https://github.com/rust-lang/rust-clippy/pull/6513)\n+* [`field_reassign_with_default`] No longer lints in macros\n+  [#6553](https://github.com/rust-lang/rust-clippy/pull/6553)\n+* [`size_of_in_element_count`] No longer lints when dividing by element size\n+  [#6578](https://github.com/rust-lang/rust-clippy/pull/6578)\n+* [`needless_return`] No longer lints in macros\n+  [#6586](https://github.com/rust-lang/rust-clippy/pull/6586)\n+* [`match_overlapping_arm`] No longer lint when first arm is completely included\n+  in second arm [#6603](https://github.com/rust-lang/rust-clippy/pull/6603)\n+* [`doc_markdown`] Add `WebGL` to the default configuration as an allowed\n+  identifier [#6605](https://github.com/rust-lang/rust-clippy/pull/6605)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`field_reassign_with_default`] Don't expand macro in lint suggestion\n+  [#6531](https://github.com/rust-lang/rust-clippy/pull/6531)\n+* [`match_like_matches_macro`] Strip references in suggestion\n+  [#6532](https://github.com/rust-lang/rust-clippy/pull/6532)\n+* [`single_match`] Suggest `if` over `if let` when possible\n+  [#6574](https://github.com/rust-lang/rust-clippy/pull/6574)\n+* [`ref_in_deref`] Use parentheses correctly in suggestion\n+  [#6609](https://github.com/rust-lang/rust-clippy/pull/6609)\n+* [`stable_sort_primitive`] Clarify error message\n+  [#6611](https://github.com/rust-lang/rust-clippy/pull/6611)\n+\n+### ICE Fixes\n+\n+* [`zero_sized_map_values`]\n+  [#6582](https://github.com/rust-lang/rust-clippy/pull/6582)\n+\n+### Documentation Improvements\n+\n+* Improve search performance on the Clippy website and make it possible to\n+  directly search for lints on the GitHub issue tracker\n+  [#6483](https://github.com/rust-lang/rust-clippy/pull/6483)\n+* Clean up `README.md` by removing outdated paragraph\n+  [#6488](https://github.com/rust-lang/rust-clippy/pull/6488)\n+* [`await_holding_refcell_ref`] and [`await_holding_lock`]\n+  [#6585](https://github.com/rust-lang/rust-clippy/pull/6585)\n+* [`as_conversions`] [#6608](https://github.com/rust-lang/rust-clippy/pull/6608)\n+\n+### Others\n+\n+* Clippy now has a [Roadmap] for 2021. If you like to get involved in a bigger\n+  project, take a look at the [Roadmap project page]. All issues listed there\n+  are actively mentored\n+  [#6462](https://github.com/rust-lang/rust-clippy/pull/6462)\n+* The Clippy version number now corresponds to the Rust version number\n+  [#6526](https://github.com/rust-lang/rust-clippy/pull/6526)\n+* Fix oversight which caused Clippy to lint deps in some environments, where\n+  `CLIPPY_TESTS=true` was set somewhere\n+  [#6575](https://github.com/rust-lang/rust-clippy/pull/6575)\n+* Add `cargo dev-lintcheck` tool to the Clippy Dev Tool\n+  [#6469](https://github.com/rust-lang/rust-clippy/pull/6469)\n+\n+[Roadmap]: https://github.com/rust-lang/rust-clippy/blob/master/doc/roadmap-2021.md\n+[Roadmap project page]: https://github.com/rust-lang/rust-clippy/projects/3\n \n ## Rust 1.50\n \n-Current beta, release 2021-02-11\n+Current stable, released 2021-02-11\n \n-[b20d4c1...4911ab1](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...4911ab1)\n+[b20d4c1...4bd77a1](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...4bd77a1)\n \n ### New Lints\n \n@@ -90,6 +205,8 @@ Current beta, release 2021-02-11\n * [`declare_interior_mutable_const`] and [`borrow_interior_mutable_const`]:\n   Both now ignore enums with frozen variants\n   [#6110](https://github.com/rust-lang/rust-clippy/pull/6110)\n+* [`field_reassign_with_default`] No longer lint for private fields\n+  [#6537](https://github.com/rust-lang/rust-clippy/pull/6537)\n \n \n ### Suggestion Fixes/Improvements\n@@ -137,7 +254,7 @@ Current beta, release 2021-02-11\n \n ## Rust 1.49\n \n-Current stable, released 2020-12-31\n+Released 2020-12-31\n \n [e636b88...b20d4c1](https://github.com/rust-lang/rust-clippy/compare/e636b88...b20d4c1)\n \n@@ -1910,6 +2027,7 @@ Released 2018-09-13\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n@@ -1975,6 +2093,7 @@ Released 2018-09-13\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n+[`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n@@ -1990,6 +2109,7 @@ Released 2018-09-13\n [`implicit_saturating_sub`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_sub\n [`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n+[`inconsistent_struct_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_struct_constructor\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n [`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n [`inefficient_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#inefficient_to_string\n@@ -2042,6 +2162,7 @@ Released 2018-09-13\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n+[`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or"}, {"sha": "ea32a8edd1ffb311848900f19766b08a24ecb8ea", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -37,8 +37,8 @@ tempfile = { version = \"3.1.0\", optional = true }\n \n [dev-dependencies]\n cargo_metadata = \"0.12\"\n-compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n-tester = \"0.7\"\n+compiletest_rs = { version = \"0.6.0\", features = [\"tmp\"] }\n+tester = \"0.9\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n derive-new = \"0.5\""}, {"sha": "3cc03cf360336bc2588b1ba34af53040b19c42de", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -98,6 +98,23 @@ If you want to run Clippy **only** on the given crate, use the `--no-deps` optio\n cargo clippy -p example -- --no-deps \n ```\n \n+### As a rustc replacement (`clippy-driver`)\n+\n+Clippy can also be used in projects that do not use cargo. To do so, you will need to replace\n+your `rustc` compilation commands with `clippy-driver`. For example, if your project runs:\n+\n+```terminal\n+rustc --edition 2018 -Cpanic=abort foo.rs\n+```\n+\n+Then, to enable Clippy, you will need to call:\n+\n+```terminal\n+clippy-driver --edition 2018 -Cpanic=abort foo.rs\n+```\n+\n+Note that `rustc` will still run, i.e. it will still emit the output files it normally does.\n+\n ### Travis CI\n \n You can add Clippy to Travis CI in the same way you use it locally:"}, {"sha": "ebf157b80acf1c3aaf8236d145cb16c1977a22a5", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -19,8 +19,9 @@ shell-escape = \"0.1\"\n tar = { version = \"0.4.30\", optional = true }\n toml = { version = \"0.5\", optional = true }\n ureq = { version = \"2.0.0-rc3\", optional = true }\n+rayon = { version = \"1.5.0\", optional = true }\n walkdir = \"2\"\n \n [features]\n-lintcheck = [\"flate2\", \"serde_json\", \"tar\", \"toml\", \"ureq\", \"serde\", \"fs_extra\"]\n+lintcheck = [\"flate2\", \"serde_json\", \"tar\", \"toml\", \"ureq\", \"serde\", \"fs_extra\", \"rayon\"]\n deny-warnings = []"}, {"sha": "a5ed9e27bd2bcba33b723d2c04f404f32f0fce3c", "filename": "src/tools/clippy/clippy_dev/README.md", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FREADME.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,28 +1,77 @@\n-# Clippy Dev Tool \n+# Clippy Dev Tool\n \n-The Clippy Dev Tool is a tool to ease Clippy development, similar to `rustc`s `x.py`.\n+The Clippy Dev Tool is a tool to ease Clippy development, similar to `rustc`s\n+`x.py`.\n \n Functionalities (incomplete):\n \n ## `lintcheck`\n-Runs clippy on a fixed set of crates read from `clippy_dev/lintcheck_crates.toml`\n-and saves logs of the lint warnings into the repo.\n-We can then check the diff and spot new or disappearing warnings.\n+\n+Runs clippy on a fixed set of crates read from\n+`clippy_dev/lintcheck_crates.toml` and saves logs of the lint warnings into the\n+repo.  We can then check the diff and spot new or disappearing warnings.\n \n From the repo root, run:\n-````\n+\n+```\n cargo run --target-dir clippy_dev/target --package clippy_dev \\\n --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --features lintcheck -- lintcheck\n-````\n+```\n+\n or\n-````\n+\n+```\n cargo dev-lintcheck\n-````\n+```\n \n-By default the logs will be saved into `lintcheck-logs/lintcheck_crates_logs.txt`.\n+By default the logs will be saved into\n+`lintcheck-logs/lintcheck_crates_logs.txt`.\n \n-You can set a custom sources.toml by adding `--crates-toml custom.toml`\n-where `custom.toml` must be a relative path from the repo root.\n+You can set a custom sources.toml by adding `--crates-toml custom.toml` or using\n+`LINTCHECK_TOML=\"custom.toml\"` where `custom.toml` must be a relative path from\n+the repo root.\n \n The results will then be saved to `lintcheck-logs/custom_logs.toml`.\n \n+### Configuring the Crate Sources\n+\n+The sources to check are saved in a `toml` file. There are three types of\n+sources.\n+\n+1. Crates-io Source\n+\n+   ```toml\n+   bitflags = {name = \"bitflags\", versions = ['1.2.1']}\n+   ```\n+   Requires a \"name\" and one or multiple \"versions\" to be checked.\n+\n+2. `git` Source\n+   ````toml\n+   puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n+   ````\n+   Requires a name, the url to the repo and unique identifier of a commit,\n+   branch or tag which is checked out before linting.  There is no way to always\n+   check `HEAD` because that would lead to changing lint-results as the repo\n+   would get updated.  If `git_url` or `git_hash` is missing, an error will be\n+   thrown.\n+\n+3. Local Dependency\n+   ```toml\n+   clippy = {name = \"clippy\", path = \"/home/user/clippy\"}\n+   ```\n+   For when you want to add a repository that is not published yet.\n+\n+#### Command Line Options (optional)\n+\n+```toml\n+bitflags = {name = \"bitflags\", versions = ['1.2.1'], options = ['-Wclippy::pedantic', '-Wclippy::cargo']}\n+```\n+\n+It is possible to specify command line options for each crate. This makes it\n+possible to only check a crate for certain lint groups. If no options are\n+specified, the lint groups `clippy::all`, `clippy::pedantic`, and\n+`clippy::cargo` are checked. If an empty array is specified only `clippy::all`\n+is checked.\n+\n+**Note:** `-Wclippy::all` is always enabled by default, unless `-Aclippy::all`\n+is explicitly specified in the options."}, {"sha": "c4fa0a9aca70b75333b37f5fe5f6e70decdbe3cf", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -42,9 +42,10 @@ pub fn bless(ignore_timestamp: bool) {\n             .for_each(|f| {\n                 let test_name = f.path().strip_prefix(test_suite_dir).unwrap();\n                 for &ext in &[\"stdout\", \"stderr\", \"fixed\"] {\n+                    let test_name_ext = format!(\"stage-id.{}\", ext);\n                     update_reference_file(\n                         f.path().with_extension(ext),\n-                        test_name.with_extension(ext),\n+                        test_name.with_extension(test_name_ext),\n                         ignore_timestamp,\n                     );\n                 }"}, {"sha": "b806f5452846505b94b9a00e8666e7752a7a795a", "filename": "src/tools/clippy/clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 267, "deletions": 69, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flintcheck.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -11,48 +11,65 @@ use crate::clippy_project_root;\n \n use std::collections::HashMap;\n use std::process::Command;\n-use std::{fmt, fs::write, path::PathBuf};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::{env, fmt, fs::write, path::PathBuf};\n \n use clap::ArgMatches;\n+use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n \n-// use this to store the crates when interacting with the crates.toml file\n+/// List of sources to check, loaded from a .toml file\n #[derive(Debug, Serialize, Deserialize)]\n-struct CrateList {\n+struct SourceList {\n     crates: HashMap<String, TomlCrate>,\n }\n \n-// crate data we stored in the toml, can have multiple versions per crate\n-// A single TomlCrate is laster mapped to several CrateSources in that case\n+/// A crate source stored inside the .toml\n+/// will be translated into on one of the `CrateSource` variants\n #[derive(Debug, Serialize, Deserialize)]\n struct TomlCrate {\n     name: String,\n     versions: Option<Vec<String>>,\n     git_url: Option<String>,\n     git_hash: Option<String>,\n     path: Option<String>,\n+    options: Option<Vec<String>>,\n }\n \n-// represents an archive we download from crates.io, or a git repo, or a local repo\n-#[derive(Debug, Serialize, Deserialize, Eq, Hash, PartialEq)]\n+/// Represents an archive we download from crates.io, or a git repo, or a local repo/folder\n+/// Once processed (downloaded/extracted/cloned/copied...), this will be translated into a `Crate`\n+#[derive(Debug, Serialize, Deserialize, Eq, Hash, PartialEq, Ord, PartialOrd)]\n enum CrateSource {\n-    CratesIo { name: String, version: String },\n-    Git { name: String, url: String, commit: String },\n-    Path { name: String, path: PathBuf },\n+    CratesIo {\n+        name: String,\n+        version: String,\n+        options: Option<Vec<String>>,\n+    },\n+    Git {\n+        name: String,\n+        url: String,\n+        commit: String,\n+        options: Option<Vec<String>>,\n+    },\n+    Path {\n+        name: String,\n+        path: PathBuf,\n+        options: Option<Vec<String>>,\n+    },\n }\n \n-// represents the extracted sourcecode of a crate\n-// we actually don't need to special-case git repos here because it does not matter for clippy, yay!\n-// (clippy only needs a simple path)\n+/// Represents the actual source code of a crate that we ran \"cargo clippy\" on\n #[derive(Debug)]\n struct Crate {\n     version: String,\n     name: String,\n     // path to the extracted sources that clippy can check\n     path: PathBuf,\n+    options: Option<Vec<String>>,\n }\n \n+/// A single warning that clippy issued while checking a `Crate`\n #[derive(Debug)]\n struct ClippyWarning {\n     crate_name: String,\n@@ -62,7 +79,7 @@ struct ClippyWarning {\n     column: String,\n     linttype: String,\n     message: String,\n-    ice: bool,\n+    is_ice: bool,\n }\n \n impl std::fmt::Display for ClippyWarning {\n@@ -76,9 +93,12 @@ impl std::fmt::Display for ClippyWarning {\n }\n \n impl CrateSource {\n+    /// Makes the sources available on the disk for clippy to check.\n+    /// Clones a git repo and checks out the specified commit or downloads a crate from crates.io or\n+    /// copies a local folder\n     fn download_and_extract(&self) -> Crate {\n         match self {\n-            CrateSource::CratesIo { name, version } => {\n+            CrateSource::CratesIo { name, version, options } => {\n                 let extract_dir = PathBuf::from(\"target/lintcheck/crates\");\n                 let krate_download_dir = PathBuf::from(\"target/lintcheck/downloads\");\n \n@@ -110,9 +130,15 @@ impl CrateSource {\n                     version: version.clone(),\n                     name: name.clone(),\n                     path: extract_dir.join(format!(\"{}-{}/\", name, version)),\n+                    options: options.clone(),\n                 }\n             },\n-            CrateSource::Git { name, url, commit } => {\n+            CrateSource::Git {\n+                name,\n+                url,\n+                commit,\n+                options,\n+            } => {\n                 let repo_path = {\n                     let mut repo_path = PathBuf::from(\"target/lintcheck/crates\");\n                     // add a -git suffix in case we have the same crate from crates.io and a git repo\n@@ -122,27 +148,37 @@ impl CrateSource {\n                 // clone the repo if we have not done so\n                 if !repo_path.is_dir() {\n                     println!(\"Cloning {} and checking out {}\", url, commit);\n-                    Command::new(\"git\")\n+                    if !Command::new(\"git\")\n                         .arg(\"clone\")\n                         .arg(url)\n                         .arg(&repo_path)\n-                        .output()\n-                        .expect(\"Failed to clone git repo!\");\n+                        .status()\n+                        .expect(\"Failed to clone git repo!\")\n+                        .success()\n+                    {\n+                        eprintln!(\"Failed to clone {} into {}\", url, repo_path.display())\n+                    }\n                 }\n                 // check out the commit/branch/whatever\n-                Command::new(\"git\")\n+                if !Command::new(\"git\")\n                     .arg(\"checkout\")\n                     .arg(commit)\n-                    .output()\n-                    .expect(\"Failed to check out commit\");\n+                    .current_dir(&repo_path)\n+                    .status()\n+                    .expect(\"Failed to check out commit\")\n+                    .success()\n+                {\n+                    eprintln!(\"Failed to checkout {} of repo at {}\", commit, repo_path.display())\n+                }\n \n                 Crate {\n                     version: commit.clone(),\n                     name: name.clone(),\n                     path: repo_path,\n+                    options: options.clone(),\n                 }\n             },\n-            CrateSource::Path { name, path } => {\n+            CrateSource::Path { name, path, options } => {\n                 use fs_extra::dir;\n \n                 // simply copy the entire directory into our target dir\n@@ -171,31 +207,64 @@ impl CrateSource {\n                     version: String::from(\"local\"),\n                     name: name.clone(),\n                     path: crate_root,\n+                    options: options.clone(),\n                 }\n             },\n         }\n     }\n }\n \n impl Crate {\n-    fn run_clippy_lints(&self, cargo_clippy_path: &PathBuf) -> Vec<ClippyWarning> {\n-        println!(\"Linting {} {}...\", &self.name, &self.version);\n+    /// Run `cargo clippy` on the `Crate` and collect and return all the lint warnings that clippy\n+    /// issued\n+    fn run_clippy_lints(\n+        &self,\n+        cargo_clippy_path: &PathBuf,\n+        target_dir_index: &AtomicUsize,\n+        thread_limit: usize,\n+        total_crates_to_lint: usize,\n+    ) -> Vec<ClippyWarning> {\n+        // advance the atomic index by one\n+        let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n+        // \"loop\" the index within 0..thread_limit\n+        let target_dir_index = index % thread_limit;\n+        let perc = ((index * 100) as f32 / total_crates_to_lint as f32) as u8;\n+\n+        if thread_limit == 1 {\n+            println!(\n+                \"{}/{} {}% Linting {} {}\",\n+                index, total_crates_to_lint, perc, &self.name, &self.version\n+            );\n+        } else {\n+            println!(\n+                \"{}/{} {}% Linting {} {} in target dir {:?}\",\n+                index, total_crates_to_lint, perc, &self.name, &self.version, target_dir_index\n+            );\n+        }\n+\n         let cargo_clippy_path = std::fs::canonicalize(cargo_clippy_path).unwrap();\n \n-        let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir/\");\n+        let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n+\n+        let mut args = vec![\"--\", \"--message-format=json\", \"--\", \"--cap-lints=warn\"];\n+\n+        if let Some(options) = &self.options {\n+            for opt in options {\n+                args.push(opt);\n+            }\n+        } else {\n+            args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+        }\n \n         let all_output = std::process::Command::new(&cargo_clippy_path)\n-            .env(\"CARGO_TARGET_DIR\", shared_target_dir)\n+            // use the looping index to create individual target dirs\n+            .env(\n+                \"CARGO_TARGET_DIR\",\n+                shared_target_dir.join(format!(\"_{:?}\", target_dir_index)),\n+            )\n             // lint warnings will look like this:\n             // src/cargo/ops/cargo_compile.rs:127:35: warning: usage of `FromIterator::from_iter`\n-            .args(&[\n-                \"--\",\n-                \"--message-format=json\",\n-                \"--\",\n-                \"--cap-lints=warn\",\n-                \"-Wclippy::pedantic\",\n-                \"-Wclippy::cargo\",\n-            ])\n+            .args(&args)\n             .current_dir(&self.path)\n             .output()\n             .unwrap_or_else(|error| {\n@@ -211,28 +280,69 @@ impl Crate {\n         let warnings: Vec<ClippyWarning> = output_lines\n             .into_iter()\n             // get all clippy warnings and ICEs\n-            .filter(|line| line.contains(\"clippy::\") || line.contains(\"internal compiler error: \"))\n+            .filter(|line| filter_clippy_warnings(&line))\n             .map(|json_msg| parse_json_message(json_msg, &self))\n             .collect();\n         warnings\n     }\n }\n \n+/// takes a single json-formatted clippy warnings and returns true (we are interested in that line)\n+/// or false (we aren't)\n+fn filter_clippy_warnings(line: &str) -> bool {\n+    // we want to collect ICEs because clippy might have crashed.\n+    // these are summarized later\n+    if line.contains(\"internal compiler error: \") {\n+        return true;\n+    }\n+    // in general, we want all clippy warnings\n+    // however due to some kind of bug, sometimes there are absolute paths\n+    // to libcore files inside the message\n+    // or we end up with cargo-metadata output (https://github.com/rust-lang/rust-clippy/issues/6508)\n+\n+    // filter out these message to avoid unnecessary noise in the logs\n+    if line.contains(\"clippy::\")\n+        && !(line.contains(\"could not read cargo metadata\")\n+            || (line.contains(\".rustup\") && line.contains(\"toolchains\")))\n+    {\n+        return true;\n+    }\n+    false\n+}\n+\n+/// get the path to lintchecks crate sources .toml file, check LINTCHECK_TOML first but if it's\n+/// empty use the default path\n+fn lintcheck_config_toml(toml_path: Option<&str>) -> PathBuf {\n+    PathBuf::from(\n+        env::var(\"LINTCHECK_TOML\").unwrap_or(\n+            toml_path\n+                .clone()\n+                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n+                .to_string(),\n+        ),\n+    )\n+}\n+\n+/// Builds clippy inside the repo to make sure we have a clippy executable we can use.\n fn build_clippy() {\n-    Command::new(\"cargo\")\n+    let status = Command::new(\"cargo\")\n         .arg(\"build\")\n-        .output()\n+        .status()\n         .expect(\"Failed to build clippy!\");\n+    if !status.success() {\n+        eprintln!(\"Error: Failed to compile Clippy!\");\n+        std::process::exit(1);\n+    }\n }\n \n-// get a list of CrateSources we want to check from a \"lintcheck_crates.toml\" file.\n+/// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n-    let toml_path = PathBuf::from(toml_path.unwrap_or(\"clippy_dev/lintcheck_crates.toml\"));\n+    let toml_path = lintcheck_config_toml(toml_path);\n     // save it so that we can use the name of the sources.toml as name for the logfile later.\n     let toml_filename = toml_path.file_stem().unwrap().to_str().unwrap().to_string();\n     let toml_content: String =\n         std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n-    let crate_list: CrateList =\n+    let crate_list: SourceList =\n         toml::from_str(&toml_content).unwrap_or_else(|e| panic!(\"Failed to parse {}: \\n{}\", toml_path.display(), e));\n     // parse the hashmap of the toml file into a list of crates\n     let tomlcrates: Vec<TomlCrate> = crate_list\n@@ -249,6 +359,7 @@ fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n             crate_sources.push(CrateSource::Path {\n                 name: tk.name.clone(),\n                 path: PathBuf::from(path),\n+                options: tk.options.clone(),\n             });\n         }\n \n@@ -258,6 +369,7 @@ fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n                 crate_sources.push(CrateSource::CratesIo {\n                     name: tk.name.clone(),\n                     version: ver.to_string(),\n+                    options: tk.options.clone(),\n                 });\n             })\n         }\n@@ -267,6 +379,7 @@ fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n                 name: tk.name.clone(),\n                 url: tk.git_url.clone().unwrap(),\n                 commit: tk.git_hash.clone().unwrap(),\n+                options: tk.options.clone(),\n             });\n         }\n         // if we have a version as well as a git data OR only one git data, something is funky\n@@ -283,10 +396,13 @@ fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n             unreachable!(\"Failed to translate TomlCrate into CrateSource!\");\n         }\n     });\n+    // sort the crates\n+    crate_sources.sort();\n+\n     (toml_filename, crate_sources)\n }\n \n-// extract interesting data from a json lint message\n+/// Parse the json output of clippy and return a `ClippyWarning`\n fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n     let jmsg: Value = serde_json::from_str(&json_message).unwrap_or_else(|e| panic!(\"Failed to parse json:\\n{:?}\", e));\n \n@@ -307,18 +423,84 @@ fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n             .into(),\n         linttype: jmsg[\"message\"][\"code\"][\"code\"].to_string().trim_matches('\"').into(),\n         message: jmsg[\"message\"][\"message\"].to_string().trim_matches('\"').into(),\n-        ice: json_message.contains(\"internal compiler error: \"),\n+        is_ice: json_message.contains(\"internal compiler error: \"),\n     }\n }\n \n-// the main fn\n-pub fn run(clap_config: &ArgMatches) {\n-    let cargo_clippy_path: PathBuf = PathBuf::from(\"target/debug/cargo-clippy\");\n+/// Generate a short list of occuring lints-types and their count\n+fn gather_stats(clippy_warnings: &[ClippyWarning]) -> String {\n+    // count lint type occurrences\n+    let mut counter: HashMap<&String, usize> = HashMap::new();\n+    clippy_warnings\n+        .iter()\n+        .for_each(|wrn| *counter.entry(&wrn.linttype).or_insert(0) += 1);\n \n+    // collect into a tupled list for sorting\n+    let mut stats: Vec<(&&String, &usize)> = counter.iter().map(|(lint, count)| (lint, count)).collect();\n+    // sort by \"000{count} {clippy::lintname}\"\n+    // to not have a lint with 200 and 2 warnings take the same spot\n+    stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n+\n+    stats\n+        .iter()\n+        .map(|(lint, count)| format!(\"{} {}\\n\", lint, count))\n+        .collect::<String>()\n+}\n+\n+/// check if the latest modification of the logfile is older than the modification date of the\n+/// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n+fn lintcheck_needs_rerun(toml_path: Option<&str>) -> bool {\n+    let clippy_modified: std::time::SystemTime = {\n+        let mut times = [\"target/debug/clippy-driver\", \"target/debug/cargo-clippy\"]\n+            .iter()\n+            .map(|p| {\n+                std::fs::metadata(p)\n+                    .expect(\"failed to get metadata of file\")\n+                    .modified()\n+                    .expect(\"failed to get modification date\")\n+            });\n+        // the lates modification of either of the binaries\n+        std::cmp::max(times.next().unwrap(), times.next().unwrap())\n+    };\n+\n+    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_config_toml(toml_path))\n+        .expect(\"failed to get metadata of file\")\n+        .modified()\n+        .expect(\"failed to get modification date\");\n+\n+    // if clippys modification time is bigger (older) than the logs mod time, we need to rerun lintcheck\n+    clippy_modified > logs_modified\n+}\n+\n+/// lintchecks `main()` function\n+pub fn run(clap_config: &ArgMatches) {\n     println!(\"Compiling clippy...\");\n     build_clippy();\n     println!(\"Done compiling\");\n \n+    let clap_toml_path = clap_config.value_of(\"crates-toml\");\n+\n+    // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n+    // refresh the logs\n+    if lintcheck_needs_rerun(clap_toml_path) {\n+        let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n+        match std::fs::metadata(&shared_target_dir) {\n+            Ok(metadata) => {\n+                if metadata.is_dir() {\n+                    println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n+                    std::fs::remove_dir_all(&shared_target_dir)\n+                        .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n+                }\n+            },\n+            Err(_) => { // dir probably does not exist, don't remove anything\n+            },\n+        }\n+    }\n+\n+    let cargo_clippy_path: PathBuf = PathBuf::from(\"target/debug/cargo-clippy\")\n+        .canonicalize()\n+        .expect(\"failed to canonicalize path to clippy binary\");\n+\n     // assert that clippy is found\n     assert!(\n         cargo_clippy_path.is_file(),\n@@ -335,7 +517,7 @@ pub fn run(clap_config: &ArgMatches) {\n     // download and extract the crates, then run clippy on them and collect clippys warnings\n     // flatten into one big list of warnings\n \n-    let (filename, crates) = read_crates(clap_config.value_of(\"crates-toml\"));\n+    let (filename, crates) = read_crates(clap_toml_path);\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n@@ -359,45 +541,60 @@ pub fn run(clap_config: &ArgMatches) {\n             .into_iter()\n             .map(|krate| krate.download_and_extract())\n             .filter(|krate| krate.name == only_one_crate)\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path))\n+            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1))\n             .flatten()\n             .collect()\n     } else {\n+        let counter = std::sync::atomic::AtomicUsize::new(0);\n+\n+        // Ask rayon for thread count. Assume that half of that is the number of physical cores\n+        // Use one target dir for each core so that we can run N clippys in parallel.\n+        // We need to use different target dirs because cargo would lock them for a single build otherwise,\n+        // killing the parallelism. However this also means that deps will only be reused half/a\n+        // quarter of the time which might result in a longer wall clock runtime\n+\n+        // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n+        // order to achive some kind of parallelism\n+\n+        // by default, use a single thread\n+        let num_cpus = match clap_config.value_of(\"threads\") {\n+            Some(threads) => {\n+                let threads: usize = threads\n+                    .parse()\n+                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n+                if threads == 0 {\n+                    // automatic choice\n+                    // Rayon seems to return thread count so half that for core count\n+                    (rayon::current_num_threads() / 2) as usize\n+                } else {\n+                    threads\n+                }\n+            },\n+            // no -j passed, use a single thread\n+            None => 1,\n+        };\n+\n+        let num_crates = crates.len();\n+\n         // check all crates (default)\n         crates\n-            .into_iter()\n+            .into_par_iter()\n             .map(|krate| krate.download_and_extract())\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path))\n+            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n             .flatten()\n             .collect()\n     };\n \n-    // generate some stats:\n+    // generate some stats\n+    let stats_formatted = gather_stats(&clippy_warnings);\n \n     // grab crashes/ICEs, save the crate name and the ice message\n     let ices: Vec<(&String, &String)> = clippy_warnings\n         .iter()\n-        .filter(|warning| warning.ice)\n+        .filter(|warning| warning.is_ice)\n         .map(|w| (&w.crate_name, &w.message))\n         .collect();\n \n-    // count lint type occurrences\n-    let mut counter: HashMap<&String, usize> = HashMap::new();\n-    clippy_warnings\n-        .iter()\n-        .for_each(|wrn| *counter.entry(&wrn.linttype).or_insert(0) += 1);\n-\n-    // collect into a tupled list for sorting\n-    let mut stats: Vec<(&&String, &usize)> = counter.iter().map(|(lint, count)| (lint, count)).collect();\n-    // sort by \"000{count} {clippy::lintname}\"\n-    // to not have a lint with 200 and 2 warnings take the same spot\n-    stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n-\n-    let stats_formatted: String = stats\n-        .iter()\n-        .map(|(lint, count)| format!(\"{} {}\\n\", lint, count))\n-        .collect::<String>();\n-\n     let mut all_msgs: Vec<String> = clippy_warnings.iter().map(|warning| warning.to_string()).collect();\n     all_msgs.sort();\n     all_msgs.push(\"\\n\\n\\n\\nStats\\n\\n\".into());\n@@ -411,5 +608,6 @@ pub fn run(clap_config: &ArgMatches) {\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n     let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n+    println!(\"Writing logs to {}\", file);\n     write(file, text).unwrap();\n }"}, {"sha": "505d465760c57873b1c840ba769276e86b78f00e", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -69,6 +69,14 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 .value_name(\"CRATES-SOURCES-TOML-PATH\")\n                 .long(\"crates-toml\")\n                 .help(\"set the path for a crates.toml where lintcheck should read the sources from\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"threads\")\n+                .takes_value(true)\n+                .value_name(\"N\")\n+                .short(\"j\")\n+                .long(\"jobs\")\n+                .help(\"number of threads to use, 0 automatic choice\"),\n         );\n \n     let app = App::new(\"Clippy developer tooling\")"}, {"sha": "d5ec8597044c8d83ba2c5ebafeadd930792e761c", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -18,6 +18,7 @@ edition = \"2018\"\n \n [dependencies]\n cargo_metadata = \"0.12\"\n+clippy_utils = { path = \"../clippy_utils\" }\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n pulldown-cmark = { version = \"0.8\", default-features = false }\n@@ -38,4 +39,4 @@ syn = { version = \"1\", features = [\"full\"] }\n [features]\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n-internal-lints = []\n+internal-lints = [\"clippy_utils/internal-lints\"]"}, {"sha": "b53f80fd8bc15801ea0238153a71444e4a657eab", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,8 @@\n-use crate::utils::{differing_macro_contexts, snippet_block_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    differing_macro_contexts, get_parent_expr, get_trait_def_id, implements_trait, paths,\n+    snippet_block_with_applicability, span_lint, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n@@ -52,6 +56,18 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if let ExprKind::Closure(_, _, eid, _, _) = expr.kind {\n+            // do not lint if the closure is called using an iterator (see #1141)\n+            if_chain! {\n+                if let Some(parent) = get_parent_expr(self.cx, expr);\n+                if let ExprKind::MethodCall(_, _, args, _) = parent.kind;\n+                let caller = self.cx.typeck_results().expr_ty(&args[0]);\n+                if let Some(iter_id) = get_trait_def_id(self.cx, &paths::ITERATOR);\n+                if implements_trait(self.cx, caller, iter_id, &[]);\n+                then {\n+                    return;\n+                }\n+            }\n+\n             let body = self.cx.tcx.hir().body(eid);\n             let ex = &body.value;\n             if matches!(ex.kind, ExprKind::Block(_, _)) && !body.value.span.from_expansion() {"}, {"sha": "34f0e6ab027053840dbc0181063e492bc58e58d3", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -122,6 +122,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n         if let ast::ExprKind::Block(ref block, _) = else_.kind;\n         if !block_starts_with_comment(cx, block);\n         if let Some(else_) = expr_block(block);\n+        if else_.attrs.is_empty();\n         if !else_.span.from_expansion();\n         if let ast::ExprKind::If(..) = else_.kind;\n         then {\n@@ -143,16 +144,12 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n     if_chain! {\n         if !block_starts_with_comment(cx, then);\n         if let Some(inner) = expr_block(then);\n+        if inner.attrs.is_empty();\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.kind;\n+        // Prevent triggering on `if c { if let a = b { .. } }`.\n+        if !matches!(check_inner.kind, ast::ExprKind::Let(..));\n+        if expr.span.ctxt() == inner.span.ctxt();\n         then {\n-            if let ast::ExprKind::Let(..) = check_inner.kind {\n-                // Prevent triggering on `if c { if let a = b { .. } }`.\n-                return;\n-            }\n-\n-            if expr.span.ctxt() != inner.span.ctxt() {\n-                return;\n-            }\n             span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this `if` statement can be collapsed\", |diag| {\n                 let lhs = Sugg::ast(cx, check, \"..\");\n                 let rhs = Sugg::ast(cx, check_inner, \"..\");"}, {"sha": "3c45525684be455365a85c323d076ffbe44d92e3", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -96,12 +96,12 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n                 cx,\n                 COLLAPSIBLE_MATCH,\n                 expr.span,\n-                \"Unnecessary nested match\",\n+                \"unnecessary nested match\",\n                 |diag| {\n                     let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n-                    help_span.push_span_label(binding_span, \"Replace this binding\".into());\n+                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n                     help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n-                    diag.span_help(help_span, \"The outer pattern can be modified to include the inner pattern.\");\n+                    diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );\n         }"}, {"sha": "7e87f53e3fba7d2a7c8b739689d9dc416b77810e", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 574, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,574 +1 @@\n-#![allow(clippy::float_cmp)]\n-\n-use crate::utils::{clip, sext, unsext};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitFloatType, LitKind};\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n-use rustc_lint::LateContext;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n-use rustc_span::symbol::Symbol;\n-use std::cmp::Ordering::{self, Equal};\n-use std::convert::TryInto;\n-use std::hash::{Hash, Hasher};\n-\n-/// A `LitKind`-like enum to fold constant `Expr`s into.\n-#[derive(Debug, Clone)]\n-pub enum Constant {\n-    /// A `String` (e.g., \"abc\").\n-    Str(String),\n-    /// A binary string (e.g., `b\"abc\"`).\n-    Binary(Lrc<[u8]>),\n-    /// A single `char` (e.g., `'a'`).\n-    Char(char),\n-    /// An integer's bit representation.\n-    Int(u128),\n-    /// An `f32`.\n-    F32(f32),\n-    /// An `f64`.\n-    F64(f64),\n-    /// `true` or `false`.\n-    Bool(bool),\n-    /// An array of constants.\n-    Vec(Vec<Constant>),\n-    /// Also an array, but with only one constant, repeated N times.\n-    Repeat(Box<Constant>, u64),\n-    /// A tuple of constants.\n-    Tuple(Vec<Constant>),\n-    /// A raw pointer.\n-    RawPtr(u128),\n-    /// A reference\n-    Ref(Box<Constant>),\n-    /// A literal with syntax error.\n-    Err(Symbol),\n-}\n-\n-impl PartialEq for Constant {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n-            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n-            (&Self::Char(l), &Self::Char(r)) => l == r,\n-            (&Self::Int(l), &Self::Int(r)) => l == r,\n-            (&Self::F64(l), &Self::F64(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                l.to_bits() == r.to_bits()\n-            },\n-            (&Self::F32(l), &Self::F32(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                f64::from(l).to_bits() == f64::from(r).to_bits()\n-            },\n-            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n-            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n-            // TODO: are there inter-type equalities?\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Hash for Constant {\n-    fn hash<H>(&self, state: &mut H)\n-    where\n-        H: Hasher,\n-    {\n-        std::mem::discriminant(self).hash(state);\n-        match *self {\n-            Self::Str(ref s) => {\n-                s.hash(state);\n-            },\n-            Self::Binary(ref b) => {\n-                b.hash(state);\n-            },\n-            Self::Char(c) => {\n-                c.hash(state);\n-            },\n-            Self::Int(i) => {\n-                i.hash(state);\n-            },\n-            Self::F32(f) => {\n-                f64::from(f).to_bits().hash(state);\n-            },\n-            Self::F64(f) => {\n-                f.to_bits().hash(state);\n-            },\n-            Self::Bool(b) => {\n-                b.hash(state);\n-            },\n-            Self::Vec(ref v) | Self::Tuple(ref v) => {\n-                v.hash(state);\n-            },\n-            Self::Repeat(ref c, l) => {\n-                c.hash(state);\n-                l.hash(state);\n-            },\n-            Self::RawPtr(u) => {\n-                u.hash(state);\n-            },\n-            Self::Ref(ref r) => {\n-                r.hash(state);\n-            },\n-            Self::Err(ref s) => {\n-                s.hash(state);\n-            },\n-        }\n-    }\n-}\n-\n-impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n-        match (left, right) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n-            (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = *cmp_type.kind() {\n-                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n-                } else {\n-                    Some(l.cmp(&r))\n-                }\n-            },\n-            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n-            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n-            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n-                .iter()\n-                .zip(r.iter())\n-                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n-                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n-                    Some(Equal) => Some(ls.cmp(rs)),\n-                    x => x,\n-                }\n-            },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n-            // TODO: are there any useful inter-type orderings?\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// Parses a `LitKind` to a `Constant`.\n-pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n-    match *lit {\n-        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n-        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n-        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n-        LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(n, _) => Constant::Int(n),\n-        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n-            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n-            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n-        },\n-        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n-            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n-            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n-            _ => bug!(),\n-        },\n-        LitKind::Bool(b) => Constant::Bool(b),\n-        LitKind::Err(s) => Constant::Err(s),\n-    }\n-}\n-\n-pub fn constant<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    };\n-    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n-}\n-\n-pub fn constant_simple<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<Constant> {\n-    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n-}\n-\n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n-pub fn constant_context<'a, 'tcx>(\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> ConstEvalLateContext<'a, 'tcx> {\n-    ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    }\n-}\n-\n-pub struct ConstEvalLateContext<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    needed_resolution: bool,\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n-    /// Simple constant folding: Insert an expression, get a constant or none.\n-    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n-        match e.kind {\n-            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n-            ExprKind::Block(ref block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n-            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprKind::Repeat(ref value, _) => {\n-                let n = match self.typeck_results.expr_ty(e).kind() {\n-                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n-                    _ => span_bug!(e.span, \"typeck error\"),\n-                };\n-                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n-            },\n-            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n-            }),\n-            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n-            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n-            ExprKind::Call(ref callee, ref args) => {\n-                // We only handle a few const functions for now.\n-                if_chain! {\n-                    if args.is_empty();\n-                    if let ExprKind::Path(qpath) = &callee.kind;\n-                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n-                    if let Some(def_id) = res.opt_def_id();\n-                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n-                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n-                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n-                    then {\n-                       let value = match int_impl {\n-                           \"<impl i8>\" => i8::MAX as u128,\n-                           \"<impl i16>\" => i16::MAX as u128,\n-                           \"<impl i32>\" => i32::MAX as u128,\n-                           \"<impl i64>\" => i64::MAX as u128,\n-                           \"<impl i128>\" => i128::MAX as u128,\n-                           _ => return None,\n-                       };\n-                       Some(Constant::Int(value))\n-                    }\n-                    else {\n-                        None\n-                    }\n-                }\n-            },\n-            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n-            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n-            // TODO: add other expressions.\n-            _ => None,\n-        }\n-    }\n-\n-    #[allow(clippy::cast_possible_wrap)]\n-    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Bool, Int};\n-        match *o {\n-            Bool(b) => Some(Bool(!b)),\n-            Int(value) => {\n-                let value = !value;\n-                match *ty.kind() {\n-                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n-                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n-                    _ => None,\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Int, F32, F64};\n-        match *o {\n-            Int(value) => {\n-                let ity = match *ty.kind() {\n-                    ty::Int(ity) => ity,\n-                    _ => return None,\n-                };\n-                // sign extend\n-                let value = sext(self.lcx.tcx, value, ity);\n-                let value = value.checked_neg()?;\n-                // clear unused bits\n-                Some(Int(unsext(self.lcx.tcx, value, ity)))\n-            },\n-            F32(f) => Some(F32(-f)),\n-            F64(f) => Some(F64(-f)),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Create `Some(Vec![..])` of all constants, unless there is any\n-    /// non-constant part.\n-    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n-        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n-    }\n-\n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n-    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n-        let res = self.typeck_results.qpath_res(qpath, id);\n-        match res {\n-            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.typeck_results.node_substs(id);\n-                let substs = if self.substs.is_empty() {\n-                    substs\n-                } else {\n-                    substs.subst(self.lcx.tcx, self.substs)\n-                };\n-\n-                let result = self\n-                    .lcx\n-                    .tcx\n-                    .const_eval_resolve(\n-                        self.param_env,\n-                        ty::WithOptConstParam::unknown(def_id),\n-                        substs,\n-                        None,\n-                        None,\n-                    )\n-                    .ok()\n-                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(&result);\n-                if result.is_some() {\n-                    self.needed_resolution = true;\n-                }\n-                result\n-            },\n-            // FIXME: cover all usable cases.\n-            _ => None,\n-        }\n-    }\n-\n-    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n-        let lhs = self.expr(lhs);\n-        let index = self.expr(index);\n-\n-        match (lhs, index) {\n-            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n-                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                _ => None,\n-            },\n-            (Some(Constant::Vec(vec)), _) => {\n-                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n-                    match vec.get(0) {\n-                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// A block can only yield a constant if it only has one constant expression.\n-    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n-        if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(b))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n-        if let Some(Constant::Bool(b)) = self.expr(cond) {\n-            if b {\n-                self.expr(&*then)\n-            } else {\n-                otherwise.as_ref().and_then(|expr| self.expr(expr))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n-        let l = self.expr(left)?;\n-        let r = self.expr(right);\n-        match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n-                ty::Int(ity) => {\n-                    let l = sext(self.lcx.tcx, l, ity);\n-                    let r = sext(self.lcx.tcx, r, ity);\n-                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n-                    match op.node {\n-                        BinOpKind::Add => l.checked_add(r).map(zext),\n-                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n-                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n-                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n-                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n-                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::BitXor => Some(zext(l ^ r)),\n-                        BinOpKind::BitOr => Some(zext(l | r)),\n-                        BinOpKind::BitAnd => Some(zext(l & r)),\n-                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                        _ => None,\n-                    }\n-                },\n-                ty::Uint(_) => match op.node {\n-                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n-                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n-                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n-                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n-                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n-                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n-                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n-                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n-                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F32(l + r)),\n-                BinOpKind::Sub => Some(Constant::F32(l - r)),\n-                BinOpKind::Mul => Some(Constant::F32(l * r)),\n-                BinOpKind::Div => Some(Constant::F32(l / r)),\n-                BinOpKind::Rem => Some(Constant::F32(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F64(l + r)),\n-                BinOpKind::Sub => Some(Constant::F64(l - r)),\n-                BinOpKind::Mul => Some(Constant::F64(l * r)),\n-                BinOpKind::Div => Some(Constant::F64(l / r)),\n-                BinOpKind::Rem => Some(Constant::F64(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (l, r) => match (op.node, l, r) {\n-                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n-                    Some(r)\n-                },\n-                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n-                _ => None,\n-            },\n-        }\n-    }\n-}\n-\n-pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::ConstValue;\n-    match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty.kind() {\n-                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n-                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                    int.try_into().expect(\"invalid f32 bit representation\"),\n-                ))),\n-                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                    int.try_into().expect(\"invalid f64 bit representation\"),\n-                ))),\n-                ty::RawPtr(type_and_mut) => {\n-                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n-                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n-                    }\n-                    None\n-                },\n-                // FIXME: implement other conversions.\n-                _ => None,\n-            }\n-        },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n-            ty::Ref(_, tam, _) => match tam.kind() {\n-                ty::Str => String::from_utf8(\n-                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n-                        .to_owned(),\n-                )\n-                .ok()\n-                .map(Constant::Str),\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n-            ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n-                        .to_owned()\n-                        .chunks(4)\n-                        .map(|chunk| {\n-                            Some(Constant::F32(f32::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n-                        .to_owned()\n-                        .chunks(8)\n-                        .map(|chunk| {\n-                            Some(Constant::F64(f64::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                // FIXME: implement other array type conversions.\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        // FIXME: implement other conversions.\n-        _ => None,\n-    }\n-}\n+pub use clippy_utils::consts::*;"}, {"sha": "6ace9aa6bdfc0d1e06c4bfc1c7906e6b4488a7fc", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,237 @@\n+use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, walk_stmt, NestedVisitorMap, Visitor},\n+    Body, Expr, ExprKind, HirId, Lit, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{\n+    hir::map::Map,\n+    ty::{self, FloatTy, IntTy, PolyFnSig, Ty},\n+};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{snippet, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n+    /// inference.\n+    ///\n+    /// Default numeric fallback means that if numeric types have not yet been bound to concrete\n+    /// types at the end of type inference, then integer type is bound to `i32`, and similarly\n+    /// floating type is bound to `f64`.\n+    ///\n+    /// See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n+    ///\n+    /// **Why is this bad?** For those who are very careful about types, default numeric fallback\n+    /// can be a pitfall that cause unexpected runtime behavior.\n+    ///\n+    /// **Known problems:** This lint can only be allowed at the function level or above.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 10;\n+    /// let f = 1.23;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let i = 10i32;\n+    /// let f = 1.23f64;\n+    /// ```\n+    pub DEFAULT_NUMERIC_FALLBACK,\n+    restriction,\n+    \"usage of unconstrained numeric literals which may cause default numeric fallback.\"\n+}\n+\n+declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n+\n+impl LateLintPass<'_> for DefaultNumericFallback {\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        let mut visitor = NumericFallbackVisitor::new(cx);\n+        visitor.visit_body(body);\n+    }\n+}\n+\n+struct NumericFallbackVisitor<'a, 'tcx> {\n+    /// Stack manages type bound of exprs. The top element holds current expr type.\n+    ty_bounds: Vec<TyBound<'tcx>>,\n+\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            ty_bounds: vec![TyBound::Nothing],\n+            cx,\n+        }\n+    }\n+\n+    /// Check whether a passed literal has potential to cause fallback or not.\n+    fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n+        if_chain! {\n+                if let Some(ty_bound) = self.ty_bounds.last();\n+                if matches!(lit.node,\n+                            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n+                if !ty_bound.is_integral();\n+                then {\n+                    let suffix = match lit_ty.kind() {\n+                        ty::Int(IntTy::I32) => \"i32\",\n+                        ty::Float(FloatTy::F64) => \"f64\",\n+                        // Default numeric fallback never results in other types.\n+                        _ => return,\n+                    };\n+\n+                    let sugg = format!(\"{}_{}\", snippet(self.cx, lit.span, \"\"), suffix);\n+                    span_lint_and_sugg(\n+                        self.cx,\n+                        DEFAULT_NUMERIC_FALLBACK,\n+                        lit.span,\n+                        \"default numeric fallback might occur\",\n+                        \"consider adding suffix\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    #[allow(clippy::too_many_lines)]\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            ExprKind::Call(func, args) => {\n+                if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n+                    for (expr, bound) in args.iter().zip(fn_sig.skip_binder().inputs().iter()) {\n+                        // Push found arg type, then visit arg.\n+                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+            },\n+\n+            ExprKind::MethodCall(_, _, args, _) => {\n+                if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+                    let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n+                    for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n+                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+            },\n+\n+            ExprKind::Struct(qpath, fields, base) => {\n+                if_chain! {\n+                    if let Some(def_id) = self.cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n+                    let ty = self.cx.tcx.type_of(def_id);\n+                    if let Some(adt_def) = ty.ty_adt_def();\n+                    if adt_def.is_struct();\n+                    if let Some(variant) = adt_def.variants.iter().next();\n+                    then {\n+                        let fields_def = &variant.fields;\n+\n+                        // Push field type then visit each field expr.\n+                        for field in fields.iter() {\n+                            let bound =\n+                                fields_def\n+                                    .iter()\n+                                    .find_map(|f_def| {\n+                                        if f_def.ident == field.ident\n+                                            { Some(self.cx.tcx.type_of(f_def.did)) }\n+                                        else { None }\n+                                    });\n+                            self.ty_bounds.push(bound.into());\n+                            self.visit_expr(field.expr);\n+                            self.ty_bounds.pop();\n+                        }\n+\n+                        // Visit base with no bound.\n+                        if let Some(base) = base {\n+                            self.ty_bounds.push(TyBound::Nothing);\n+                            self.visit_expr(base);\n+                            self.ty_bounds.pop();\n+                        }\n+                        return;\n+                    }\n+                }\n+            },\n+\n+            ExprKind::Lit(lit) => {\n+                let ty = self.cx.typeck_results().expr_ty(expr);\n+                self.check_lit(lit, ty);\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Local(local) => {\n+                if local.ty.is_some() {\n+                    self.ty_bounds.push(TyBound::Any)\n+                } else {\n+                    self.ty_bounds.push(TyBound::Nothing)\n+                }\n+            },\n+\n+            _ => self.ty_bounds.push(TyBound::Nothing),\n+        }\n+\n+        walk_stmt(self, stmt);\n+        self.ty_bounds.pop();\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n+    let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n+    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    match node_ty.kind() {\n+        ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n+        ty::FnPtr(fn_sig) => Some(*fn_sig),\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum TyBound<'tcx> {\n+    Any,\n+    Ty(Ty<'tcx>),\n+    Nothing,\n+}\n+\n+impl<'tcx> TyBound<'tcx> {\n+    fn is_integral(self) -> bool {\n+        match self {\n+            TyBound::Any => true,\n+            TyBound::Ty(t) => t.is_integral(),\n+            TyBound::Nothing => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<Option<Ty<'tcx>>> for TyBound<'tcx> {\n+    fn from(v: Option<Ty<'tcx>>) -> Self {\n+        match v {\n+            Some(t) => TyBound::Ty(t),\n+            None => TyBound::Nothing,\n+        }\n+    }\n+}"}, {"sha": "39a202f281cb7d2f8908cff1d8ac402e0d4c2c99", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    implements_trait, is_entrypoint_fn, is_type_diagnostic_item, match_panic_def_id, method_chain_args, return_ty,\n-    span_lint, span_lint_and_note,\n+    implements_trait, is_entrypoint_fn, is_expn_of, is_type_diagnostic_item, match_panic_def_id, method_chain_args,\n+    return_ty, span_lint, span_lint_and_note,\n };\n use if_chain::if_chain;\n use itertools::Itertools;\n@@ -216,17 +216,23 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n-                if !(is_entrypoint_fn(cx, item.def_id.to_def_id())\n-                    || in_external_macro(cx.tcx.sess, item.span))\n-                {\n+                if !(is_entrypoint_fn(cx, item.def_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n                     let body = cx.tcx.hir().body(body_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n                         typeck_results: cx.tcx.typeck(item.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(&body.value);\n-                    lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(\n+                        cx,\n+                        item.hir_id(),\n+                        item.span,\n+                        sig,\n+                        headers,\n+                        Some(body_id),\n+                        fpu.panic_span,\n+                    );\n                 }\n             },\n             hir::ItemKind::Impl(ref impl_) => {\n@@ -264,7 +270,15 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 panic_span: None,\n             };\n             fpu.visit_expr(&body.value);\n-            lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, Some(body_id), fpu.panic_span);\n+            lint_for_missing_headers(\n+                cx,\n+                item.hir_id(),\n+                item.span,\n+                sig,\n+                headers,\n+                Some(body_id),\n+                fpu.panic_span,\n+            );\n         }\n     }\n }\n@@ -561,9 +575,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                             | ItemKind::ExternCrate(..)\n                             | ItemKind::ForeignMod(..) => return false,\n                             // We found a main function ...\n-                            ItemKind::Fn(box FnKind(_, sig, _, Some(block)))\n-                                if item.ident.name == sym::main =>\n-                            {\n+                            ItemKind::Fn(box FnKind(_, sig, _, Some(block))) if item.ident.name == sym::main => {\n                                 let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n                                 let returns_nothing = match &sig.decl.output {\n                                     FnRetTy::Default(..) => true,\n@@ -699,6 +711,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n             if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n             if let Some(path_def_id) = path.res.opt_def_id();\n             if match_panic_def_id(self.cx, path_def_id);\n+            if is_expn_of(expr.span, \"unreachable\").is_none();\n             then {\n                 self.panic_span = Some(expr.span);\n             }"}, {"sha": "0933f9830147c4f3d13f8757469d5df7cac80b17", "filename": "src/tools/clippy/clippy_lints/src/from_str_radix_10.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,101 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def, Expr, ExprKind, PrimTy, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::is_type_diagnostic_item;\n+use crate::utils::span_lint_and_sugg;\n+use crate::utils::sugg::Sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for function invocations of the form `primitive::from_str_radix(s, 10)`\n+    ///\n+    /// **Why is this bad?**\n+    /// This specific common use case can be rewritten as `s.parse::<primitive>()`\n+    /// (and in most cases, the turbofish can be removed), which reduces code length\n+    /// and complexity.\n+    ///\n+    /// **Known problems:**\n+    /// This lint may suggest using (&<expression>).parse() instead of <expression>.parse() directly\n+    /// in some cases, which is correct but adds unnecessary complexity to the code.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// let input: &str = get_input();\n+    /// let num = u16::from_str_radix(input, 10)?;\n+    /// ```\n+    /// Use instead:\n+    /// ```ignore\n+    /// let input: &str = get_input();\n+    /// let num: u16 = input.parse()?;\n+    /// ```\n+    pub FROM_STR_RADIX_10,\n+    style,\n+    \"from_str_radix with radix 10\"\n+}\n+\n+declare_lint_pass!(FromStrRadix10 => [FROM_STR_RADIX_10]);\n+\n+impl LateLintPass<'tcx> for FromStrRadix10 {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, exp: &Expr<'tcx>) {\n+        if_chain! {\n+            if let ExprKind::Call(maybe_path, arguments) = &exp.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, pathseg)) = &maybe_path.kind;\n+\n+            // check if the first part of the path is some integer primitive\n+            if let TyKind::Path(ty_qpath) = &ty.kind;\n+            let ty_res = cx.qpath_res(ty_qpath, ty.hir_id);\n+            if let def::Res::PrimTy(prim_ty) = ty_res;\n+            if matches!(prim_ty, PrimTy::Int(_) | PrimTy::Uint(_));\n+\n+            // check if the second part of the path indeed calls the associated\n+            // function `from_str_radix`\n+            if pathseg.ident.name.as_str() == \"from_str_radix\";\n+\n+            // check if the second argument is a primitive `10`\n+            if arguments.len() == 2;\n+            if let ExprKind::Lit(lit) = &arguments[1].kind;\n+            if let rustc_ast::ast::LitKind::Int(10, _) = lit.node;\n+\n+            then {\n+                let expr = if let ExprKind::AddrOf(_, _, expr) = &arguments[0].kind {\n+                    let ty = cx.typeck_results().expr_ty(expr);\n+                    if is_ty_stringish(cx, ty) {\n+                        expr\n+                    } else {\n+                        &arguments[0]\n+                    }\n+                } else {\n+                    &arguments[0]\n+                };\n+\n+                let sugg = Sugg::hir_with_applicability(\n+                    cx,\n+                    expr,\n+                    \"<string>\",\n+                    &mut Applicability::MachineApplicable\n+                ).maybe_par();\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    FROM_STR_RADIX_10,\n+                    exp.span,\n+                    \"this call to `from_str_radix` can be replaced with a call to `str::parse`\",\n+                    \"try\",\n+                    format!(\"{}.parse::<{}>()\", sugg, prim_ty.name_str()),\n+                    Applicability::MaybeIncorrect\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks if a Ty is `String` or `&str`\n+fn is_ty_stringish(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    is_type_diagnostic_item(cx, ty, sym::string_type) || is_type_diagnostic_item(cx, ty, sym::str)\n+}"}, {"sha": "e4b3a9009f612664916c01b864699c9edcbe8961", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{\n     attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, is_type_diagnostic_item, iter_input_pats,\n-    last_path_segment, match_def_path, must_use_attr, path_to_local, return_ty, snippet, snippet_opt, span_lint,\n-    span_lint_and_help, span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n+    match_def_path, must_use_attr, path_to_local, return_ty, snippet, snippet_opt, span_lint, span_lint_and_help,\n+    span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n@@ -470,12 +470,11 @@ fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span\n     if_chain! {\n         if !in_external_macro(cx.sess(), item_span);\n         if let hir::FnRetTy::Return(ref ty) = decl.output;\n-        if let hir::TyKind::Path(ref qpath) = ty.kind;\n-        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym::result_type);\n-        if let Some(ref args) = last_path_segment(qpath).args;\n-        if let [_, hir::GenericArg::Type(ref err_ty)] = args.args;\n-        if let hir::TyKind::Tup(t) = err_ty.kind;\n-        if t.is_empty();\n+        let ty = hir_ty_to_ty(cx.tcx, ty);\n+        if is_type_diagnostic_item(cx, ty, sym::result_type);\n+        if let ty::Adt(_, substs) = ty.kind();\n+        let err_ty = substs.type_at(1);\n+        if err_ty.is_unit();\n         then {\n             span_lint_and_help(\n                 cx,"}, {"sha": "c5afdf530eb70da76cbfa7d9dcfee0091243b84f", "filename": "src/tools/clippy/clippy_lints/src/inconsistent_struct_constructor.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,134 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{snippet, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for struct constructors where the order of the field init\n+    /// shorthand in the constructor is inconsistent with the order in the struct definition.\n+    ///\n+    /// **Why is this bad?** Since the order of fields in a constructor doesn't affect the\n+    /// resulted instance as the below example indicates,\n+    ///\n+    /// ```rust\n+    /// #[derive(Debug, PartialEq, Eq)]\n+    /// struct Foo {\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    /// let x = 1;\n+    /// let y = 2;\n+    ///\n+    /// // This assertion never fails.\n+    /// assert_eq!(Foo { x, y }, Foo { y, x });\n+    /// ```\n+    ///\n+    /// inconsistent order means nothing and just decreases readability and consistency.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Foo {\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    /// let x = 1;\n+    /// let y = 2;\n+    /// Foo { y, x };\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct Foo {\n+    /// #     x: i32,\n+    /// #     y: i32,\n+    /// # }\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// Foo { x, y };\n+    /// ```\n+    pub INCONSISTENT_STRUCT_CONSTRUCTOR,\n+    style,\n+    \"the order of the field init shorthand is inconsistent with the order in the struct definition\"\n+}\n+\n+declare_lint_pass!(InconsistentStructConstructor => [INCONSISTENT_STRUCT_CONSTRUCTOR]);\n+\n+impl LateLintPass<'_> for InconsistentStructConstructor {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Struct(qpath, fields, base) = expr.kind;\n+            if let Some(def_id)  = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n+            let ty = cx.tcx.type_of(def_id);\n+            if let Some(adt_def) = ty.ty_adt_def();\n+            if adt_def.is_struct();\n+            if let Some(variant) = adt_def.variants.iter().next();\n+            if fields.iter().all(|f| f.is_shorthand);\n+            then {\n+                let mut def_order_map = FxHashMap::default();\n+                for (idx, field) in variant.fields.iter().enumerate() {\n+                    def_order_map.insert(field.ident.name, idx);\n+                }\n+\n+                if is_consistent_order(fields, &def_order_map) {\n+                    return;\n+                }\n+\n+                let mut ordered_fields: Vec<_> = fields.iter().map(|f| f.ident.name).collect();\n+                ordered_fields.sort_unstable_by_key(|id| def_order_map[id]);\n+\n+                let mut fields_snippet = String::new();\n+                let (last_ident, idents) = ordered_fields.split_last().unwrap();\n+                for ident in idents {\n+                    fields_snippet.push_str(&format!(\"{}, \", ident));\n+                }\n+                fields_snippet.push_str(&last_ident.to_string());\n+\n+                let base_snippet = if let Some(base) = base {\n+                        format!(\", ..{}\", snippet(cx, base.span, \"..\"))\n+                    } else {\n+                        String::new()\n+                    };\n+\n+                let sugg = format!(\"{} {{ {}{} }}\",\n+                    snippet(cx, qpath.span(), \"..\"),\n+                    fields_snippet,\n+                    base_snippet,\n+                    );\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    INCONSISTENT_STRUCT_CONSTRUCTOR,\n+                    expr.span,\n+                    \"inconsistent struct constructor\",\n+                    \"try\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+// Check whether the order of the fields in the constructor is consistent with the order in the\n+// definition.\n+fn is_consistent_order<'tcx>(fields: &'tcx [hir::Field<'tcx>], def_order_map: &FxHashMap<Symbol, usize>) -> bool {\n+    let mut cur_idx = usize::MIN;\n+    for f in fields {\n+        let next_idx = def_order_map[&f.ident.name];\n+        if cur_idx > next_idx {\n+            return false;\n+        }\n+        cur_idx = next_idx;\n+    }\n+\n+    true\n+}"}, {"sha": "a95321ea7e2af39fed82690aa512e82fe7f314c0", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -106,6 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             let decl = &signature.decl;\n             if decl.implicit_self.has_implicit_self();\n             if decl.inputs.len() == 1;\n+            if impl_item.generics.params.is_empty();\n \n             // Check if return type is String\n             if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::string_type);"}, {"sha": "176eeadcc630a99cf2974c61bf34d1cb0d634e03", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,10 +1,7 @@\n // error-pattern:cargo-clippy\n \n-#![feature(bindings_after_at)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(concat_idents)]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n@@ -149,6 +146,20 @@ macro_rules! declare_clippy_lint {\n     };\n }\n \n+#[macro_export]\n+macro_rules! sym {\n+    ( $($x:tt)* ) => { clippy_utils::sym!($($x)*) }\n+}\n+\n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ( $($x:tt)* ) => { clippy_utils::unwrap_cargo_metadata!($($x)*) }\n+}\n+\n+macro_rules! extract_msrv_attr {\n+    ( $($x:tt)* ) => { clippy_utils::extract_msrv_attr!($($x)*); }\n+}\n+\n mod consts;\n #[macro_use]\n mod utils;\n@@ -181,6 +192,7 @@ mod copy_iterator;\n mod create_dir;\n mod dbg_macro;\n mod default;\n+mod default_numeric_fallback;\n mod dereference;\n mod derive;\n mod disallowed_method;\n@@ -210,6 +222,7 @@ mod floating_point_arithmetic;\n mod format;\n mod formatting;\n mod from_over_into;\n+mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n mod get_last_with_len;\n@@ -219,6 +232,7 @@ mod if_let_some_result;\n mod if_not_else;\n mod implicit_return;\n mod implicit_saturating_sub;\n+mod inconsistent_struct_constructor;\n mod indexing_slicing;\n mod infinite_iter;\n mod inherent_impl;\n@@ -239,6 +253,7 @@ mod loops;\n mod macro_use;\n mod main_recursion;\n mod manual_async_fn;\n+mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_strip;\n@@ -585,6 +600,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &dbg_macro::DBG_MACRO,\n         &default::DEFAULT_TRAIT_ACCESS,\n         &default::FIELD_REASSIGN_WITH_DEFAULT,\n+        &default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n         &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -637,6 +653,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &formatting::SUSPICIOUS_ELSE_FORMATTING,\n         &formatting::SUSPICIOUS_UNARY_OP_FORMATTING,\n         &from_over_into::FROM_OVER_INTO,\n+        &from_str_radix_10::FROM_STR_RADIX_10,\n         &functions::DOUBLE_MUST_USE,\n         &functions::MUST_USE_CANDIDATE,\n         &functions::MUST_USE_UNIT,\n@@ -652,6 +669,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &if_not_else::IF_NOT_ELSE,\n         &implicit_return::IMPLICIT_RETURN,\n         &implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n+        &inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n         &indexing_slicing::INDEXING_SLICING,\n         &indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n         &infinite_iter::INFINITE_ITER,\n@@ -702,6 +720,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n+        &manual_map::MANUAL_MAP,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &manual_ok_or::MANUAL_OK_OR,\n         &manual_strip::MANUAL_STRIP,\n@@ -1031,6 +1050,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n+    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n+    store.register_late_pass(|| box inconsistent_struct_constructor::InconsistentStructConstructor);\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n@@ -1195,7 +1216,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n     store.register_early_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold));\n     store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n-    store.register_early_pass(|| box upper_case_acronyms::UpperCaseAcronyms);\n+    let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n+    store.register_early_pass(move || box upper_case_acronyms::UpperCaseAcronyms::new(upper_case_acronyms_aggressive));\n     store.register_late_pass(|| box default::Default::default());\n     store.register_late_pass(|| box unused_self::UnusedSelf);\n     store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n@@ -1256,6 +1278,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box types::PtrAsPtr::new(msrv));\n     store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n     store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n+    store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n+    store.register_late_pass(|| box manual_map::ManualMap);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1265,6 +1289,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n         LintId::of(&create_dir::CREATE_DIR),\n         LintId::of(&dbg_macro::DBG_MACRO),\n+        LintId::of(&default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n         LintId::of(&else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_ENUMS),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_STRUCTS),\n@@ -1389,6 +1414,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::PTR_AS_PTR),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n+        LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n         LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unused_self::UNUSED_SELF),\n         LintId::of(&wildcard_imports::ENUM_GLOB_USE),\n@@ -1468,6 +1494,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&formatting::SUSPICIOUS_ELSE_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n         LintId::of(&from_over_into::FROM_OVER_INTO),\n+        LintId::of(&from_str_radix_10::FROM_STR_RADIX_10),\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n@@ -1477,6 +1504,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&identity_op::IDENTITY_OP),\n         LintId::of(&if_let_mutex::IF_LET_MUTEX),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n+        LintId::of(&inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n         LintId::of(&indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n         LintId::of(&infinite_iter::INFINITE_ITER),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n@@ -1512,6 +1540,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n@@ -1682,7 +1711,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n-        LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unused_unit::UNUSED_UNIT),\n@@ -1724,10 +1752,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&formatting::SUSPICIOUS_ELSE_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n         LintId::of(&from_over_into::FROM_OVER_INTO),\n+        LintId::of(&from_str_radix_10::FROM_STR_RADIX_10),\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&functions::RESULT_UNIT_ERR),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n+        LintId::of(&inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n@@ -1741,6 +1771,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -1899,7 +1930,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n-        LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&zero_div_zero::ZERO_DIVIDED_BY_ZERO),"}, {"sha": "a50a3943bab7bd360b1b0c8bbf3122a7fb80174c", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,274 @@\n+use crate::{\n+    map_unit_fn::OPTION_MAP_UNIT_FN,\n+    matches::MATCH_AS_REF,\n+    utils::{\n+        is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths, peel_hir_expr_refs,\n+        peel_mid_ty_refs_is_mutable, snippet_with_applicability, span_lint_and_sugg,\n+    },\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{sym, Ident};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n+    ///\n+    /// **Why is this bad?** Using the `map` method is clearer and more concise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => Some(x + 1),\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).map(|x| x + 1);\n+    /// ```\n+    pub MANUAL_MAP,\n+    style,\n+    \"reimplementation of `map`\"\n+}\n+\n+declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n+\n+impl LateLintPass<'_> for ManualMap {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Match(scrutinee, [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }], _) =\n+            expr.kind\n+        {\n+            let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+                peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+            if !is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+                || !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type)\n+            {\n+                return;\n+            }\n+\n+            let (some_expr, some_pat, pat_ref_count, is_wild_none) =\n+                match (try_parse_pattern(cx, arm1.pat), try_parse_pattern(cx, arm2.pat)) {\n+                    (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n+                        if is_none_expr(cx, arm1.body) =>\n+                    {\n+                        (arm2.body, pattern, ref_count, true)\n+                    },\n+                    (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n+                        if is_none_expr(cx, arm1.body) =>\n+                    {\n+                        (arm2.body, pattern, ref_count, false)\n+                    },\n+                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n+                        if is_none_expr(cx, arm2.body) =>\n+                    {\n+                        (arm1.body, pattern, ref_count, true)\n+                    },\n+                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n+                        if is_none_expr(cx, arm2.body) =>\n+                    {\n+                        (arm1.body, pattern, ref_count, false)\n+                    },\n+                    _ => return,\n+                };\n+\n+            // Top level or patterns aren't allowed in closures.\n+            if matches!(some_pat.kind, PatKind::Or(_)) {\n+                return;\n+            }\n+\n+            let some_expr = match get_some_expr(cx, some_expr) {\n+                Some(expr) => expr,\n+                None => return,\n+            };\n+\n+            if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+                && !is_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+            {\n+                return;\n+            }\n+\n+            // Determine which binding mode to use.\n+            let explicit_ref = some_pat.contains_explicit_ref_binding();\n+            let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+            let as_ref_str = match binding_ref {\n+                Some(Mutability::Mut) => \".as_mut()\",\n+                Some(Mutability::Not) => \".as_ref()\",\n+                None => \"\",\n+            };\n+\n+            let mut app = Applicability::MachineApplicable;\n+\n+            // Remove address-of expressions from the scrutinee. `as_ref` will be called,\n+            // the type is copyable, or the option is being passed by value.\n+            let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+            let scrutinee_str = snippet_with_applicability(cx, scrutinee.span, \"_\", &mut app);\n+            let scrutinee_str = if expr.precedence().order() < PREC_POSTFIX {\n+                // Parens are needed to chain method calls.\n+                format!(\"({})\", scrutinee_str)\n+            } else {\n+                scrutinee_str.into()\n+            };\n+\n+            let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n+                if let Some(func) = can_pass_as_func(cx, some_binding, some_expr) {\n+                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                } else {\n+                    if match_var(some_expr, some_binding.name)\n+                        && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                        && binding_ref.is_some()\n+                    {\n+                        return;\n+                    }\n+\n+                    // `ref` and `ref mut` annotations were handled earlier.\n+                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    format!(\n+                        \"|{}{}| {}\",\n+                        annotation,\n+                        some_binding,\n+                        snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                    )\n+                }\n+            } else if !is_wild_none && explicit_ref.is_none() {\n+                // TODO: handle explicit reference annotations.\n+                format!(\n+                    \"|{}| {}\",\n+                    snippet_with_applicability(cx, some_pat.span, \"..\", &mut app),\n+                    snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                )\n+            } else {\n+                // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+                return;\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_MAP,\n+                expr.span,\n+                \"manual implementation of `Option::map`\",\n+                \"try this\",\n+                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str),\n+                app,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if match_var(arg, binding.name) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1),\n+            PatKind::Path(QPath::Resolved(None, path))\n+                if path\n+                    .res\n+                    .opt_def_id()\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)) =>\n+            {\n+                Some(OptionPat::None)\n+            },\n+            PatKind::TupleStruct(QPath::Resolved(None, path), [pattern], _)\n+                if path\n+                    .res\n+                    .opt_def_id()\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME)) =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0)\n+}\n+\n+// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n+fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    // TODO: Allow more complex expressions.\n+    match expr.kind {\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(QPath::Resolved(None, path)),\n+                ..\n+            },\n+            [arg],\n+        ) => {\n+            if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n+                Some(arg)\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => get_some_expr(cx, expr),\n+        _ => None,\n+    }\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Path(QPath::Resolved(None, path)) => path\n+            .res\n+            .opt_def_id()\n+            .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)),\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => is_none_expr(cx, expr),\n+        _ => false,\n+    }\n+}"}, {"sha": "efc8b13942507dc408df040a4d281aae391d7268", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -3,19 +3,19 @@ use crate::utils::sugg::Sugg;\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     expr_block, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local_id,\n-    peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-    strip_pat_refs,\n+    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local,\n+    path_to_local_id, peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block,\n+    snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, strip_pat_refs,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource, Mutability, Node, Pat,\n     PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, Symbol};\n+use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -1873,13 +1873,6 @@ fn test_overlapping() {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n-        lhs.len() == rhs.len()\n-            && lhs\n-                .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n-    }\n-\n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx);\n@@ -1891,12 +1884,38 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n             let min_index = usize::min(lindex, rindex);\n             let max_index = usize::max(lindex, rindex);\n \n+            let mut local_map: FxHashMap<HirId, HirId> = FxHashMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n             // Arms with a guard are ignored, those can\u2019t always be merged together\n             // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n-                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n-                // all patterns should have the same bindings\n-                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(&lhs.body, &rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n         };\n \n         let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n@@ -1939,50 +1958,18 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n     }\n }\n \n-/// Returns the list of bindings in a pattern.\n-fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.kind {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Binding(.., ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.typeck_results().pat_ty(pat));\n-                }\n-                if let Some(ref as_pat) = *as_pat {\n-                    bindings_impl(cx, as_pat, map);\n-                }\n-            },\n-            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Struct(_, fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.pat, map);\n-                }\n-            },\n-            PatKind::Slice(lhs, ref mid, rhs) => {\n-                for pat in lhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-                if let Some(ref mid) = *mid {\n-                    bindings_impl(cx, mid, map);\n-                }\n-                for pat in rhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n-        }\n-    }\n-\n-    let mut result = FxHashMap::default();\n-    bindings_impl(cx, pat, &mut result);\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n     result\n }\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: FxHashSet<HirId>) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "00a707107bce91f8404057d367c1fe74d757879d", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -212,10 +212,10 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             if !expr_borrows(cx, left_expr) {\n                 return Some(LintTrigger::SortByKey(SortByKeyDetection {\n                     vec_name,\n-                    unstable,\n                     closure_arg,\n                     closure_body,\n-                    reverse\n+                    reverse,\n+                    unstable,\n                 }));\n             }\n         }"}, {"sha": "1e58576d0599cdeced4ddd82326ebad6f93cf0a8", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,13 +1,13 @@\n use crate::utils::{\n-    contains_return, in_macro, is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n+    contains_return, in_macro, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n     visitors::find_all_ret_expressions,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -17,8 +17,8 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** It is not meaningful to wrap values when no `None` or `Err` is returned.\n     ///\n-    /// **Known problems:** Since this lint changes function type signature, you may need to\n-    /// adjust some code at callee side.\n+    /// **Known problems:** There can be false positives if the function signature is designed to\n+    /// fit some external requirement.\n     ///\n     /// **Example:**\n     ///\n@@ -48,7 +48,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub UNNECESSARY_WRAPS,\n-    complexity,\n+    pedantic,\n     \"functions that only return `Ok` or `Some`\"\n }\n \n@@ -64,6 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         span: Span,\n         hir_id: HirId,\n     ) {\n+        // Abort if public function/method or closure.\n         match fn_kind {\n             FnKind::ItemFn(.., visibility, _) | FnKind::Method(.., Some(visibility), _) => {\n                 if visibility.node.is_pub() {\n@@ -74,6 +75,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             _ => (),\n         }\n \n+        // Abort if the method is implementing a trait or of it a trait method.\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n             if matches!(\n                 item.kind,\n@@ -83,25 +85,44 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             }\n         }\n \n-        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::option_type) {\n-            (\"Option\", &paths::OPTION_SOME)\n-        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n-            (\"Result\", &paths::RESULT_OK)\n+        // Get the wrapper and inner types, if can't, abort.\n+        let (return_type_label, path, inner_type) = if let ty::Adt(adt_def, subst) = return_ty(cx, hir_id).kind() {\n+            if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did) {\n+                (\"Option\", &paths::OPTION_SOME, subst.type_at(0))\n+            } else if cx.tcx.is_diagnostic_item(sym::result_type, adt_def.did) {\n+                (\"Result\", &paths::RESULT_OK, subst.type_at(0))\n+            } else {\n+                return;\n+            }\n         } else {\n             return;\n         };\n \n+        // Check if all return expression respect the following condition and collect them.\n         let mut suggs = Vec::new();\n         let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n+                // Check if a function call.\n                 if let ExprKind::Call(ref func, ref args) = ret_expr.kind;\n+                // Get the Path of the function call.\n                 if let ExprKind::Path(ref qpath) = func.kind;\n+                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n                 if match_qpath(qpath, path);\n                 if args.len() == 1;\n+                // Make sure the function argument does not contain a return expression.\n                 if !contains_return(&args[0]);\n                 then {\n-                    suggs.push((ret_expr.span, snippet(cx, args[0].span.source_callsite(), \"..\").to_string()));\n+                    suggs.push(\n+                        (\n+                            ret_expr.span,\n+                            if inner_type.is_unit() {\n+                                \"\".to_string()\n+                            } else {\n+                                snippet(cx, args[0].span.source_callsite(), \"..\").to_string()\n+                            }\n+                        )\n+                    );\n                     true\n                 } else {\n                     false\n@@ -110,39 +131,34 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         });\n \n         if can_sugg && !suggs.is_empty() {\n-            span_lint_and_then(\n-                cx,\n-                UNNECESSARY_WRAPS,\n-                span,\n-                format!(\n-                    \"this function's return value is unnecessarily wrapped by `{}`\",\n-                    return_type\n+            let (lint_msg, return_type_sugg_msg, return_type_sugg, body_sugg_msg) = if inner_type.is_unit() {\n+                (\n+                    \"this function's return value is unnecessary\".to_string(),\n+                    \"remove the return type...\".to_string(),\n+                    snippet(cx, fn_decl.output.span(), \"..\").to_string(),\n+                    \"...and then remove returned values\",\n                 )\n-                .as_str(),\n-                |diag| {\n-                    let inner_ty = return_ty(cx, hir_id)\n-                        .walk()\n-                        .skip(1) // skip `std::option::Option` or `std::result::Result`\n-                        .take(1) // take the first outermost inner type\n-                        .filter_map(|inner| match inner.unpack() {\n-                            GenericArgKind::Type(inner_ty) => Some(inner_ty.to_string()),\n-                            _ => None,\n-                        });\n-                    inner_ty.for_each(|inner_ty| {\n-                        diag.span_suggestion(\n-                            fn_decl.output.span(),\n-                            format!(\"remove `{}` from the return type...\", return_type).as_str(),\n-                            inner_ty,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    });\n-                    diag.multipart_suggestion(\n-                        \"...and change the returning expressions\",\n-                        suggs,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                },\n-            );\n+            } else {\n+                (\n+                    format!(\n+                        \"this function's return value is unnecessarily wrapped by `{}`\",\n+                        return_type_label\n+                    ),\n+                    format!(\"remove `{}` from the return type...\", return_type_label),\n+                    inner_type.to_string(),\n+                    \"...and then change returning expressions\",\n+                )\n+            };\n+\n+            span_lint_and_then(cx, UNNECESSARY_WRAPS, span, lint_msg.as_str(), |diag| {\n+                diag.span_suggestion(\n+                    fn_decl.output.span(),\n+                    return_type_sugg_msg.as_str(),\n+                    return_type_sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.multipart_suggestion(body_sugg_msg, suggs, Applicability::MaybeIncorrect);\n+            });\n         }\n     }\n }"}, {"sha": "0470e1dbbb8122ae9804b2634f05986e9458a372", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -5,16 +5,20 @@ use rustc_ast::ast::{Item, ItemKind, Variant};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for camel case name containing a capitalized acronym.\n+    /// **What it does:** Checks for fully capitalized names and optionally names containing a capitalized acronym.\n     ///\n     /// **Why is this bad?** In CamelCase, acronyms count as one word.\n     /// See [naming conventions](https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case)\n     /// for more.\n     ///\n+    /// By default, the lint only triggers on fully-capitalized names.\n+    /// You can use the `upper-case-acronyms-aggressive: true` config option to enable linting\n+    /// on all camel case names\n+    ///\n     /// **Known problems:** When two acronyms are contiguous, the lint can't tell where\n     /// the first acronym ends and the second starts, so it suggests to lowercase all of\n     /// the letters in the second acronym.\n@@ -33,7 +37,20 @@ declare_clippy_lint! {\n     \"capitalized acronyms are against the naming convention\"\n }\n \n-declare_lint_pass!(UpperCaseAcronyms => [UPPER_CASE_ACRONYMS]);\n+#[derive(Default)]\n+pub struct UpperCaseAcronyms {\n+    upper_case_acronyms_aggressive: bool,\n+}\n+\n+impl UpperCaseAcronyms {\n+    pub fn new(aggressive: bool) -> Self {\n+        Self {\n+            upper_case_acronyms_aggressive: aggressive,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(UpperCaseAcronyms => [UPPER_CASE_ACRONYMS]);\n \n fn correct_ident(ident: &str) -> String {\n     let ident = ident.chars().rev().collect::<String>();\n@@ -56,11 +73,18 @@ fn correct_ident(ident: &str) -> String {\n     ident\n }\n \n-fn check_ident(cx: &EarlyContext<'_>, ident: &Ident) {\n+fn check_ident(cx: &EarlyContext<'_>, ident: &Ident, be_aggressive: bool) {\n     let span = ident.span;\n     let ident = &ident.as_str();\n     let corrected = correct_ident(ident);\n-    if ident != &corrected {\n+    // warn if we have pure-uppercase idents\n+    // assume that two-letter words are some kind of valid abbreviation like FP for false positive\n+    // (and don't warn)\n+    if (ident.chars().all(|c| c.is_ascii_uppercase()) && ident.len() > 2)\n+    // otherwise, warn if we have SOmeTHING lIKE THIs but only warn with the aggressive \n+    // upper-case-acronyms-aggressive config option enabled\n+    || (be_aggressive && ident != &corrected)\n+    {\n         span_lint_and_sugg(\n             cx,\n             UPPER_CASE_ACRONYMS,\n@@ -82,12 +106,12 @@ impl EarlyLintPass for UpperCaseAcronyms {\n                 ItemKind::TyAlias(..) | ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..)\n             );\n             then {\n-                check_ident(cx, &it.ident);\n+                check_ident(cx, &it.ident, self.upper_case_acronyms_aggressive);\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &Variant) {\n-        check_ident(cx, &v.ident);\n+        check_ident(cx, &v.ident, self.upper_case_acronyms_aggressive);\n     }\n }"}, {"sha": "be7b9e9ff2dcc20186e58ec6409a3ce160987073", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 369, "deletions": 193, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,24 +1,24 @@\n+use crate::utils::{in_macro, meets_msrv, snippet_opt, span_lint_and_sugg};\n use if_chain::if_chain;\n+\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::def::DefKind;\n use rustc_hir::{\n-    def, FnDecl, FnRetTy, FnSig, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Path, PathSegment, QPath,\n-    TyKind,\n+    def,\n+    def_id::LocalDefId,\n+    intravisit::{walk_ty, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n+    QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_middle::ty::{DefIdTree, Ty};\n+use rustc_middle::ty::{AssocKind, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::kw;\n+use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{differing_macro_contexts, meets_msrv, span_lint_and_sugg};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n     /// replacement with `Self` is applicable.\n@@ -28,10 +28,11 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// - False positive when using associated types ([#2843](https://github.com/rust-lang/rust-clippy/issues/2843))\n-    /// - False positives in some situations when using generics ([#3410](https://github.com/rust-lang/rust-clippy/issues/3410))\n+    /// - Unaddressed false negative in fn bodies of trait implementations\n+    /// - False positive with assotiated types in traits (#4140)\n     ///\n     /// **Example:**\n+    ///\n     /// ```rust\n     /// struct Foo {}\n     /// impl Foo {\n@@ -54,234 +55,409 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-impl_lint_pass!(UseSelf => [USE_SELF]);\n-\n-const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n-\n-fn span_use_self_lint(cx: &LateContext<'_>, path: &Path<'_>, last_segment: Option<&PathSegment<'_>>) {\n-    let last_segment = last_segment.unwrap_or_else(|| path.segments.last().expect(SEGMENTS_MSG));\n+#[derive(Default)]\n+pub struct UseSelf {\n+    msrv: Option<RustcVersion>,\n+    stack: Vec<StackItem>,\n+}\n \n-    // Path segments only include actual path, no methods or fields.\n-    let last_path_span = last_segment.ident.span;\n+const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n \n-    if differing_macro_contexts(path.span, last_path_span) {\n-        return;\n+impl UseSelf {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Self::default()\n+        }\n     }\n-\n-    // Only take path up to the end of last_path_span.\n-    let span = path.span.with_hi(last_path_span.hi());\n-\n-    span_lint_and_sugg(\n-        cx,\n-        USE_SELF,\n-        span,\n-        \"unnecessary structure name repetition\",\n-        \"use the applicable keyword\",\n-        \"Self\".to_owned(),\n-        Applicability::MachineApplicable,\n-    );\n }\n \n-// FIXME: always use this (more correct) visitor, not just in method signatures.\n-struct SemanticUseSelfVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n+#[derive(Debug)]\n+enum StackItem {\n+    Check {\n+        hir_id: HirId,\n+        impl_trait_ref_def_id: Option<LocalDefId>,\n+        types_to_skip: Vec<HirId>,\n+        types_to_lint: Vec<HirId>,\n+    },\n+    NoCheck,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for SemanticUseSelfVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n+impl_lint_pass!(UseSelf => [USE_SELF]);\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = &hir_ty.kind {\n-            match path.res {\n-                def::Res::SelfTy(..) => {},\n-                _ => {\n-                    if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n-                        span_use_self_lint(self.cx, path, None);\n-                    }\n-                },\n-            }\n-        }\n+const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n-        walk_ty(self, hir_ty)\n+impl<'tcx> LateLintPass<'tcx> for UseSelf {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // We push the self types of `impl`s on a stack here. Only the top type on the stack is\n+        // relevant for linting, since this is the self type of the `impl` we're currently in. To\n+        // avoid linting on nested items, we push `StackItem::NoCheck` on the stack to signal, that\n+        // we're in an `impl` or nested item, that we don't want to lint\n+        //\n+        // NB: If you push something on the stack in this method, remember to also pop it in the\n+        // `check_item_post` method.\n+        match &item.kind {\n+            ItemKind::Impl(Impl {\n+                self_ty: hir_self_ty,\n+                of_trait,\n+                ..\n+            }) => {\n+                let should_check = if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind {\n+                    let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n+                    parameters.as_ref().map_or(true, |params| {\n+                        !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+                    })\n+                } else {\n+                    false\n+                };\n+                let impl_trait_ref_def_id = of_trait.as_ref().map(|_| cx.tcx.hir().local_def_id(item.hir_id()));\n+                if should_check {\n+                    self.stack.push(StackItem::Check {\n+                        hir_id: hir_self_ty.hir_id,\n+                        impl_trait_ref_def_id,\n+                        types_to_lint: Vec::new(),\n+                        types_to_skip: Vec::new(),\n+                    });\n+                } else {\n+                    self.stack.push(StackItem::NoCheck);\n+                }\n+            },\n+            ItemKind::Static(..)\n+            | ItemKind::Const(..)\n+            | ItemKind::Fn(..)\n+            | ItemKind::Enum(..)\n+            | ItemKind::Struct(..)\n+            | ItemKind::Union(..)\n+            | ItemKind::Trait(..) => {\n+                self.stack.push(StackItem::NoCheck);\n+            },\n+            _ => (),\n+        }\n     }\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+    fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n+        use ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n+        match item.kind {\n+            Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..) => {\n+                self.stack.pop();\n+            },\n+            _ => (),\n+        }\n     }\n-}\n \n-fn check_trait_method_impl_decl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    impl_item: &ImplItem<'_>,\n-    impl_decl: &'tcx FnDecl<'_>,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-) {\n-    let trait_method = cx\n-        .tcx\n-        .associated_items(impl_trait_ref.def_id)\n-        .find_by_name_and_kind(cx.tcx, impl_item.ident, ty::AssocKind::Fn, impl_trait_ref.def_id)\n-        .expect(\"impl method matches a trait method\");\n-\n-    let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n-    let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n-\n-    let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n-        Some(&**ty)\n-    } else {\n-        None\n-    };\n-\n-    // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n-    // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n-    // We use `impl_hir_ty` to see if the type was written as `Self`,\n-    // `hir_ty_to_ty(...)` to check semantic types of paths, and\n-    // `trait_ty` to determine which parts of the signature in the trait, mention\n-    // the type being implemented verbatim (as opposed to `Self`).\n-    for (impl_hir_ty, trait_ty) in impl_decl\n-        .inputs\n-        .iter()\n-        .chain(output_hir_ty)\n-        .zip(trait_method_sig.inputs_and_output)\n-    {\n-        // Check if the input/output type in the trait method specifies the implemented\n-        // type verbatim, and only suggest `Self` if that isn't the case.\n-        // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n-        // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n-        // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n-        let self_ty = impl_trait_ref.self_ty();\n-        if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n-            let mut visitor = SemanticUseSelfVisitor { cx, self_ty };\n-\n-            visitor.visit_ty(&impl_hir_ty);\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n+        // We want to skip types in trait `impl`s that aren't declared as `Self` in the trait\n+        // declaration. The collection of those types is all this method implementation does.\n+        if_chain! {\n+            if let ImplItemKind::Fn(FnSig { decl, .. }, ..) = impl_item.kind;\n+            if let Some(&mut StackItem::Check {\n+                impl_trait_ref_def_id: Some(def_id),\n+                ref mut types_to_skip,\n+                ..\n+            }) = self.stack.last_mut();\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(def_id);\n+            then {\n+                // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n+                // `Self`.\n+                let self_ty = impl_trait_ref.self_ty();\n+\n+                // `trait_method_sig` is the signature of the function, how it is declared in the\n+                // trait, not in the impl of the trait.\n+                let trait_method = cx\n+                    .tcx\n+                    .associated_items(impl_trait_ref.def_id)\n+                    .find_by_name_and_kind(cx.tcx, impl_item.ident, AssocKind::Fn, impl_trait_ref.def_id)\n+                    .expect(\"impl method matches a trait method\");\n+                let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+                let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n+\n+                // `impl_inputs_outputs` is an iterator over the types (`hir::Ty`) declared in the\n+                // implementation of the trait.\n+                let output_hir_ty = if let FnRetTy::Return(ty) = &decl.output {\n+                    Some(&**ty)\n+                } else {\n+                    None\n+                };\n+                let impl_inputs_outputs = decl.inputs.iter().chain(output_hir_ty);\n+\n+                // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n+                //\n+                // `trait_sem_ty` (of type `ty::Ty`) is the semantic type for the signature in the\n+                // trait declaration. This is used to check if `Self` was used in the trait\n+                // declaration.\n+                //\n+                // If `any`where in the `trait_sem_ty` the `self_ty` was used verbatim (as opposed\n+                // to `Self`), we want to skip linting that type and all subtypes of it. This\n+                // avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`, in an `impl Trait\n+                // for u8`, when the trait always uses `Vec<u8>`.\n+                //\n+                // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n+                for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n+                    if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n+                        let mut visitor = SkipTyCollector::default();\n+                        visitor.visit_ty(&impl_hir_ty);\n+                        types_to_skip.extend(visitor.types_to_skip);\n+                    }\n+                }\n+            }\n         }\n     }\n-}\n \n-const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) {\n+        // `hir_ty_to_ty` cannot be called in `Body`s or it will panic (sometimes). But in bodies\n+        // we can use `cx.typeck_results.node_type(..)` to get the `ty::Ty` from a `hir::Ty`.\n+        // However the `node_type()` method can *only* be called in bodies.\n+        //\n+        // This method implementation determines which types should get linted in a `Body` and\n+        // which shouldn't, with a visitor. We could directly lint in the visitor, but then we\n+        // could only allow this lint on item scope. And we would have to check if those types are\n+        // already dealt with in `check_ty` anyway.\n+        if let Some(StackItem::Check {\n+            hir_id,\n+            types_to_lint,\n+            types_to_skip,\n+            ..\n+        }) = self.stack.last_mut()\n+        {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            let mut visitor = LintTyCollector {\n+                cx,\n+                self_ty,\n+                types_to_lint: vec![],\n+                types_to_skip: vec![],\n+            };\n+            visitor.visit_expr(&body.value);\n+            types_to_lint.extend(visitor.types_to_lint);\n+            types_to_skip.extend(visitor.types_to_skip);\n+        }\n+    }\n \n-pub struct UseSelf {\n-    msrv: Option<RustcVersion>,\n-}\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if in_macro(hir_ty.span) | in_impl(cx, hir_ty) | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+            return;\n+        }\n \n-impl UseSelf {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n+        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n+            hir_id,\n+            types_to_lint,\n+            types_to_skip,\n+            ..\n+        }) = self.stack.last()\n+        {\n+            if types_to_skip.contains(&hir_ty.hir_id) {\n+                false\n+            } else if types_to_lint.contains(&hir_ty.hir_id) {\n+                true\n+            } else {\n+                let self_ty = ty_from_hir_id(cx, *hir_id);\n+                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n+            }\n+        } else {\n+            false\n+        };\n+\n+        if lint_dependend_on_expr_kind {\n+            // FIXME: this span manipulation should not be necessary\n+            // @flip1995 found an ast lowering issue in\n+            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+            match cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n+                Some(Node::Expr(Expr {\n+                    kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n+                    ..\n+                })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n+                _ => span_lint(cx, hir_ty.span),\n+            }\n+        }\n     }\n-}\n \n-impl<'tcx> LateLintPass<'tcx> for UseSelf {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n-            return;\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n+            let def_id = expr.hir_id.owner;\n+            if cx.tcx.has_typeck_results(def_id) {\n+                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n+            } else {\n+                false\n+            }\n         }\n \n-        if in_external_macro(cx.sess(), item.span) {\n+        if in_macro(expr.span) | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n             return;\n         }\n-        if_chain! {\n-            if let ItemKind::Impl(impl_) = &item.kind;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = impl_.self_ty.kind;\n-            then {\n-                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = parameters.as_ref().map_or(\n-                    true,\n-                    |params| !params.parenthesized\n-                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n-                );\n \n-                if should_check {\n-                    let visitor = &mut UseSelfVisitor {\n-                        item_path,\n-                        cx,\n-                    };\n-                    let impl_trait_ref = cx.tcx.impl_trait_ref(item.def_id);\n-\n-                    if let Some(impl_trait_ref) = impl_trait_ref {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            if let ImplItemKind::Fn(FnSig{ decl: impl_decl, .. }, impl_body_id)\n-                                    = &impl_item.kind {\n-                                check_trait_method_impl_decl(cx, impl_item, impl_decl, impl_trait_ref);\n-\n-                                let body = cx.tcx.hir().body(*impl_body_id);\n-                                visitor.visit_body(body);\n-                            } else {\n-                                visitor.visit_impl_item(impl_item);\n-                            }\n+        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            match &expr.kind {\n+                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        match path.res {\n+                            def::Res::SelfTy(..) => (),\n+                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n+                            _ => {\n+                                span_lint(cx, path.span);\n+                            },\n                         }\n-                    } else {\n-                        for impl_item_ref in impl_.items {\n-                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n-                            visitor.visit_impl_item(impl_item);\n+                    }\n+                },\n+                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+                ExprKind::Call(fun, _) => {\n+                    if let Expr {\n+                        kind: ExprKind::Path(ref qpath),\n+                        ..\n+                    } = fun\n+                    {\n+                        if expr_ty_matches(cx, expr, self_ty) {\n+                            let res = cx.qpath_res(qpath, fun.hir_id);\n+\n+                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n+                                match ctor_of {\n+                                    def::CtorOf::Variant => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, true);\n+                                    },\n+                                    def::CtorOf::Struct => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, false);\n+                                    },\n+                                }\n+                            }\n                         }\n                     }\n-                }\n+                },\n+                // unit enum variants (`Enum::A`)\n+                ExprKind::Path(qpath) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        span_lint_on_qpath_resolved(cx, &qpath, true);\n+                    }\n+                },\n+                _ => (),\n             }\n         }\n     }\n+\n     extract_msrv_attr!(LateContext);\n }\n \n-struct UseSelfVisitor<'a, 'tcx> {\n-    item_path: &'a Path<'a>,\n+#[derive(Default)]\n+struct SkipTyCollector {\n+    types_to_skip: Vec<HirId>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, hir_ty: &hir::Ty<'_>) {\n+        self.types_to_skip.push(hir_ty.hir_id);\n+\n+        walk_ty(self, hir_ty)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct LintTyCollector<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    types_to_lint: Vec<HirId>,\n+    types_to_skip: Vec<HirId>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _id: HirId) {\n-        if !path.segments.iter().any(|p| p.ident.span.is_dummy()) {\n-            if path.segments.len() >= 2 {\n-                let last_but_one = &path.segments[path.segments.len() - 2];\n-                if last_but_one.ident.name != kw::SelfUpper {\n-                    let enum_def_id = match path.res {\n-                        Res::Def(DefKind::Variant, variant_def_id) => self.cx.tcx.parent(variant_def_id),\n-                        Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), ctor_def_id) => {\n-                            let variant_def_id = self.cx.tcx.parent(ctor_def_id);\n-                            variant_def_id.and_then(|def_id| self.cx.tcx.parent(def_id))\n-                        },\n-                        _ => None,\n-                    };\n-\n-                    if self.item_path.res.opt_def_id() == enum_def_id {\n-                        span_use_self_lint(self.cx, path, Some(last_but_one));\n-                    }\n-                }\n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n+        if_chain! {\n+            if let Some(ty) = self.cx.typeck_results().node_type_opt(hir_ty.hir_id);\n+            if should_lint_ty(hir_ty, ty, self.self_ty);\n+            then {\n+                self.types_to_lint.push(hir_ty.hir_id);\n+            } else {\n+                self.types_to_skip.push(hir_ty.hir_id);\n             }\n+        }\n \n-            if path.segments.last().expect(SEGMENTS_MSG).ident.name != kw::SelfUpper {\n-                if self.item_path.res == path.res {\n-                    span_use_self_lint(self.cx, path, None);\n-                } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, _), ctor_def_id) = path.res {\n-                    if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_def_id) {\n-                        span_use_self_lint(self.cx, path, None);\n-                    }\n-                }\n-            }\n+        walk_ty(self, hir_ty)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn span_lint(cx: &LateContext<'_>, span: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        USE_SELF,\n+        span,\n+        \"unnecessary structure name repetition\",\n+        \"use the applicable keyword\",\n+        \"Self\".to_owned(),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+#[allow(clippy::cast_possible_truncation)]\n+fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n+    let sp = span.with_hi(segment.ident.span.lo());\n+    // remove the trailing ::\n+    let span_without_last_segment = match snippet_opt(cx, sp) {\n+        Some(snippet) => match snippet.rfind(\"::\") {\n+            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n+            None => sp,\n+        },\n+        None => sp,\n+    };\n+    span_lint(cx, span_without_last_segment);\n+}\n+\n+fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if path.segments.len() > 1 {\n+        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n+    }\n+}\n+\n+fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if until_last_segment {\n+            span_lint_on_path_until_last_segment(cx, path);\n+        } else {\n+            span_lint(cx, path.span);\n         }\n+    }\n+}\n \n-        walk_path(self, path);\n+fn ty_from_hir_id<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Ty<'tcx> {\n+    if let Some(Node::Ty(hir_ty)) = cx.tcx.hir().find(hir_id) {\n+        hir_ty_to_ty(cx.tcx, hir_ty)\n+    } else {\n+        unreachable!(\"This function should only be called with `HirId`s that are for sure `Node::Ty`\")\n     }\n+}\n \n-    fn visit_item(&mut self, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Use(..)\n-            | ItemKind::Static(..)\n-            | ItemKind::Enum(..)\n-            | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::Impl { .. }\n-            | ItemKind::Fn(..) => {\n-                // Don't check statements that shadow `Self` or where `Self` can't be used\n-            },\n-            _ => walk_item(self, item),\n+fn in_impl(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    let parent = map.get_parent_node(hir_ty.hir_id);\n+    if_chain! {\n+        if let Some(Node::Item(item)) = map.find(parent);\n+        if let ItemKind::Impl { .. } = item.kind;\n+        then {\n+            true\n+        } else {\n+            false\n         }\n     }\n+}\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::All(self.cx.tcx.hir())\n+fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n+    if_chain! {\n+        if TyS::same_type(ty, self_ty);\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        then {\n+            !matches!(path.res, def::Res::SelfTy(..))\n+        } else {\n+            false\n+        }\n     }\n }"}, {"sha": "9139a0966c55785f335c602cb427cd75fdaf5194", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -126,7 +126,7 @@ define_Conf! {\n         \"NaN\", \"NaNs\",\n         \"OAuth\", \"GraphQL\",\n         \"OCaml\",\n-        \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\",\n+        \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\", \"OpenDNS\",\n         \"WebGL\",\n         \"TensorFlow\",\n         \"TrueType\",\n@@ -173,6 +173,8 @@ define_Conf! {\n     (disallowed_methods, \"disallowed_methods\": Vec<String>, Vec::<String>::new()),\n     /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n     (unreadable_literal_lint_fractions, \"unreadable_literal_lint_fractions\": bool, true),\n+    /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n+    (upper_case_acronyms_aggressive, \"upper_case_acronyms_aggressive\": bool, false),\n     /// Lint: _CARGO_COMMON_METADATA. For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n     (cargo_ignore_publish, \"cargo_ignore_publish\": bool, false),\n }"}, {"sha": "0a347516c3ad2dd7e6e47ca04bd460d5c83e72c7", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -4,7 +4,7 @@ use crate::utils::{\n     span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n-use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n+use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n@@ -301,17 +301,12 @@ declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &AstCrate) {\n-        if let Some(utils) = krate\n-            .module\n-            .items\n-            .iter()\n-            .find(|item| item.ident.name.as_str() == \"utils\")\n-        {\n-            if let ItemKind::Mod(ref utils_mod) = utils.kind {\n-                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n-                    if let ItemKind::Mod(ref paths_mod) = paths.kind {\n+        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n+            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n+                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n+                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n                         let mut last_name: Option<SymbolStr> = None;\n-                        for item in &*paths_mod.items {\n+                        for item in items {\n                             let name = item.ident.as_str();\n                             if let Some(ref last_name) = last_name {\n                                 if **last_name > *name {\n@@ -343,7 +338,7 @@ impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if !run_lints(cx, &[DEFAULT_LINT], item.hir_id) {\n+        if !run_lints(cx, &[DEFAULT_LINT], item.hir_id()) {\n             return;\n         }\n \n@@ -393,7 +388,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                         .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n                         .expect(\"LintPass needs to implement get_lints\")\n                         .id\n-                        .hir_id,\n+                        .hir_id(),\n                 );\n                 collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n             }\n@@ -861,7 +856,7 @@ declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n \n impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let local_def_id = &cx.tcx.parent_module(item.hir_id);\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n         let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n         if_chain! {\n             if mod_name.as_str() == \"paths\";"}, {"sha": "be9a07f8d7c9e10a900ef43d6d124720c6946d89", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1831, "changes": 1832, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,1837 +1,7 @@\n-#[macro_use]\n-pub mod sym_helper;\n-\n-#[allow(clippy::module_name_repetitions)]\n-pub mod ast_utils;\n-pub mod attrs;\n pub mod author;\n-pub mod camel_case;\n-pub mod comparisons;\n pub mod conf;\n-mod diagnostics;\n-pub mod eager_or_lazy;\n-pub mod higher;\n-mod hir_utils;\n pub mod inspector;\n #[cfg(feature = \"internal-lints\")]\n pub mod internal_lints;\n-pub mod numeric_literal;\n-pub mod paths;\n-pub mod ptr;\n-pub mod qualify_min_const_fn;\n-pub mod sugg;\n-pub mod usage;\n-pub mod visitors;\n-\n-pub use self::attrs::*;\n-pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n-\n-use std::borrow::Cow;\n-use std::collections::hash_map::Entry;\n-use std::hash::BuildHasherDefault;\n-\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, LitKind};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::Node;\n-use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n-    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n-};\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_lint::{LateContext, Level, Lint, LintContext};\n-use rustc_middle::hir::exports::Export;\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n-use rustc_semver::RustcVersion;\n-use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n-use rustc_span::source_map::original_sp;\n-use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n-use rustc_target::abi::Integer;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n-use smallvec::SmallVec;\n-\n-use crate::consts::{constant, Constant};\n-\n-pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n-    if let Ok(version) = RustcVersion::parse(msrv) {\n-        return Some(version);\n-    } else if let Some(sess) = sess {\n-        if let Some(span) = span {\n-            sess.span_err(span, &format!(\"`{}` is not a valid Rust version\", msrv));\n-        }\n-    }\n-    None\n-}\n-\n-pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool {\n-    msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n-}\n-\n-macro_rules! extract_msrv_attr {\n-    (LateContext) => {\n-        extract_msrv_attr!(@LateContext, ());\n-    };\n-    (EarlyContext) => {\n-        extract_msrv_attr!(@EarlyContext);\n-    };\n-    (@$context:ident$(, $call:tt)?) => {\n-        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n-            use $crate::utils::get_unique_inner_attr;\n-            match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n-                Some(msrv_attr) => {\n-                    if let Some(msrv) = msrv_attr.value_str() {\n-                        self.msrv = $crate::utils::parse_msrv(\n-                            &msrv.to_string(),\n-                            Some(cx.sess$($call)?),\n-                            Some(msrv_attr.span),\n-                        );\n-                    } else {\n-                        cx.sess$($call)?.span_err(msrv_attr.span, \"bad clippy attribute\");\n-                    }\n-                },\n-                _ => (),\n-            }\n-        }\n-    };\n-}\n-\n-/// Returns `true` if the two spans come from differing expansions (i.e., one is\n-/// from a macro and one isn't).\n-#[must_use]\n-pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n-    rhs.ctxt() != lhs.ctxt()\n-}\n-\n-/// Returns `true` if the given `NodeId` is inside a constant context\n-///\n-/// # Example\n-///\n-/// ```rust,ignore\n-/// if in_constant(cx, expr.hir_id) {\n-///     // Do something\n-/// }\n-/// ```\n-pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_item(id);\n-    match cx.tcx.hir().get(parent_id) {\n-        Node::Item(&Item {\n-            kind: ItemKind::Const(..) | ItemKind::Static(..),\n-            ..\n-        })\n-        | Node::TraitItem(&TraitItem {\n-            kind: TraitItemKind::Const(..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Const(..),\n-            ..\n-        })\n-        | Node::AnonConst(_) => true,\n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(ref sig, ..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(ref sig, _),\n-            ..\n-        }) => sig.header.constness == Constness::Const,\n-        _ => false,\n-    }\n-}\n-\n-/// Returns `true` if this `span` was expanded by any macro.\n-#[must_use]\n-pub fn in_macro(span: Span) -> bool {\n-    if span.from_expansion() {\n-        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-    } else {\n-        false\n-    }\n-}\n-\n-// If the snippet is empty, it's an attribute that was inserted during macro\n-// expansion and we want to ignore those, because they could come from external\n-// sources that the user has no control over.\n-// For some reason these attributes don't have any expansion info on them, so\n-// we have to check it this way until there is a better way.\n-pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n-    if let Some(snippet) = snippet_opt(cx, span) {\n-        if snippet.is_empty() {\n-            return false;\n-        }\n-    }\n-    true\n-}\n-\n-/// Checks if given pattern is a wildcard (`_`)\n-pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    matches!(pat.kind, PatKind::Wild)\n-}\n-\n-/// Checks if type is struct, enum or union type with the given def path.\n-///\n-/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n-/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n-pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the type is equal to a diagnostic item\n-///\n-/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n-pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the type is equal to a lang item\n-pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the method call given in `expr` belongs to the given trait.\n-pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n-    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-    let trt_id = cx.tcx.trait_of_item(def_id);\n-    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n-}\n-\n-/// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n-        if let [p] = path.segments {\n-            return p.ident.name == var;\n-        }\n-    }\n-    false\n-}\n-\n-pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n-    match *path {\n-        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n-        QPath::TypeRelative(_, ref seg) => seg,\n-        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n-    }\n-}\n-\n-pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n-    match *path {\n-        QPath::Resolved(_, ref path) => path.segments.get(0),\n-        QPath::TypeRelative(_, ref seg) => Some(seg),\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n-/// Matches a `QPath` against a slice of segment string literals.\n-///\n-/// There is also `match_path` if you are dealing with a `rustc_hir::Path` instead of a\n-/// `rustc_hir::QPath`.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n-    match *path {\n-        QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n-            TyKind::Path(ref inner_path) => {\n-                if let [prefix @ .., end] = segments {\n-                    if match_qpath(inner_path, prefix) {\n-                        return segment.ident.name.as_str() == *end;\n-                    }\n-                }\n-                false\n-            },\n-            _ => false,\n-        },\n-        QPath::LangItem(..) => false,\n-    }\n-}\n-\n-/// Matches a `Path` against a slice of segment string literals.\n-///\n-/// There is also `match_qpath` if you are dealing with a `rustc_hir::QPath` instead of a\n-/// `rustc_hir::Path`.\n-///\n-/// # Examples\n-///\n-/// ```rust,ignore\n-/// if match_path(&trait_ref.path, &paths::HASH) {\n-///     // This is the `std::hash::Hash` trait.\n-/// }\n-///\n-/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n-///     // This is a `rustc_middle::lint::Lint`.\n-/// }\n-/// ```\n-pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n-/// Matches a `Path` against a slice of segment string literals, e.g.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n-/// If the expression is a path to a local, returns the canonical `HirId` of the local.\n-pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n-        if let Res::Local(id) = path.res {\n-            return Some(id);\n-        }\n-    }\n-    None\n-}\n-\n-/// Returns true if the expression is a path to a local with the specified `HirId`.\n-/// Use this function to see if an expression matches a function argument or a match binding.\n-pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n-    path_to_local(expr) == Some(id)\n-}\n-\n-/// Gets the definition associated to a path.\n-#[allow(clippy::shadow_unrelated)] // false positive #6563\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n-    macro_rules! try_res {\n-        ($e:expr) => {\n-            match $e {\n-                Some(e) => e,\n-                None => return Res::Err,\n-            }\n-        };\n-    }\n-    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n-        tcx.item_children(def_id)\n-            .iter()\n-            .find(|item| item.ident.name.as_str() == name)\n-    }\n-\n-    let (krate, first, path) = match *path {\n-        [krate, first, ref path @ ..] => (krate, first, path),\n-        _ => return Res::Err,\n-    };\n-    let tcx = cx.tcx;\n-    let crates = tcx.crates();\n-    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n-    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n-    let last = path\n-        .iter()\n-        .copied()\n-        // `get_def_path` seems to generate these empty segments for extern blocks.\n-        // We can just ignore them.\n-        .filter(|segment| !segment.is_empty())\n-        // for each segment, find the child item\n-        .try_fold(first, |item, segment| {\n-            let def_id = item.res.def_id();\n-            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n-                Some(item)\n-            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n-                // it is not a child item so check inherent impl items\n-                tcx.inherent_impls(def_id)\n-                    .iter()\n-                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n-            } else {\n-                None\n-            }\n-        });\n-    try_res!(last).res\n-}\n-\n-/// Convenience function to get the `DefId` of a trait by path.\n-/// It could be a trait or trait alias.\n-pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match path_to_res(cx, path) {\n-        Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n-        _ => None,\n-    }\n-}\n-\n-/// Checks whether a type implements a trait.\n-/// See also `get_trait_def_id`.\n-pub fn implements_trait<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    trait_id: DefId,\n-    ty_params: &[GenericArg<'tcx>],\n-) -> bool {\n-    // Do not check on infer_types to avoid panic in evaluate_obligation.\n-    if ty.has_infer_types() {\n-        return false;\n-    }\n-    let ty = cx.tcx.erase_regions(ty);\n-    if ty.has_escaping_bound_vars() {\n-        return false;\n-    }\n-    let ty_params = cx.tcx.mk_substs(ty_params.iter());\n-    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n-}\n-\n-/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n-///\n-/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n-///\n-/// ```rust\n-/// struct Point(isize, isize);\n-///\n-/// impl std::ops::Add for Point {\n-///     type Output = Self;\n-///\n-///     fn add(self, other: Self) -> Self {\n-///         Point(0, 0)\n-///     }\n-/// }\n-/// ```\n-pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n-    // Get the implemented trait for the current function\n-    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n-    if_chain! {\n-        if parent_impl != hir::CRATE_HIR_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-        if let hir::ItemKind::Impl(impl_) = &item.kind;\n-        then { return impl_.of_trait.as_ref(); }\n-    }\n-    None\n-}\n-\n-/// Checks whether this type implements `Drop`.\n-pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.ty_adt_def() {\n-        Some(def) => def.has_dtor(cx.tcx),\n-        None => false,\n-    }\n-}\n-\n-/// Returns the method names and argument list of nested method call expressions that make up\n-/// `expr`. method/span lists are sorted with the most recent call first.\n-pub fn method_calls<'tcx>(\n-    expr: &'tcx Expr<'tcx>,\n-    max_depth: usize,\n-) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n-    let mut method_names = Vec::with_capacity(max_depth);\n-    let mut arg_lists = Vec::with_capacity(max_depth);\n-    let mut spans = Vec::with_capacity(max_depth);\n-\n-    let mut current = expr;\n-    for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n-                break;\n-            }\n-            method_names.push(path.ident.name);\n-            arg_lists.push(&**args);\n-            spans.push(*span);\n-            current = &args[0];\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    (method_names, arg_lists, spans)\n-}\n-\n-/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n-///\n-/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n-/// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n-/// containing the `Expr`s for\n-/// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n-    let mut current = expr;\n-    let mut matched = Vec::with_capacity(methods.len());\n-    for method_name in methods.iter().rev() {\n-        // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n-            if path.ident.name.as_str() == *method_name {\n-                if args.iter().any(|e| e.span.from_expansion()) {\n-                    return None;\n-                }\n-                matched.push(&**args); // build up `matched` backwards\n-                current = &args[0] // go to parent expression\n-            } else {\n-                return None;\n-            }\n-        } else {\n-            return None;\n-        }\n-    }\n-    // Reverse `matched` so that it is in the same order as `methods`.\n-    matched.reverse();\n-    Some(matched)\n-}\n-\n-/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n-pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    cx.tcx\n-        .entry_fn(LOCAL_CRATE)\n-        .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n-}\n-\n-/// Returns `true` if the expression is in the program's `#[panic_handler]`.\n-pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n-    Some(def_id) == cx.tcx.lang_items().panic_impl()\n-}\n-\n-/// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n-    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-    match cx.tcx.hir().find(parent_id) {\n-        Some(\n-            Node::Item(Item { ident, .. })\n-            | Node::TraitItem(TraitItem { ident, .. })\n-            | Node::ImplItem(ImplItem { ident, .. }),\n-        ) => Some(ident.name),\n-        _ => None,\n-    }\n-}\n-\n-/// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n-struct ContainsName {\n-    name: Symbol,\n-    result: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ContainsName {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_name(&mut self, _: Span, name: Symbol) {\n-        if self.name == name {\n-            self.result = true;\n-        }\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Checks if an `Expr` contains a certain name.\n-pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n-    let mut cn = ContainsName { name, result: false };\n-    cn.visit_expr(expr);\n-    cn.result\n-}\n-\n-/// Returns `true` if `expr` contains a return expression\n-pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    struct RetCallFinder {\n-        found: bool,\n-    }\n-\n-    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n-            if let hir::ExprKind::Ret(..) = &expr.kind {\n-                self.found = true;\n-            } else {\n-                hir::intravisit::walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n-            hir::intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    let mut visitor = RetCallFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n-struct FindMacroCalls<'a, 'b> {\n-    names: &'a [&'b str],\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Finds calls of the specified macros in a function body.\n-pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut fmc = FindMacroCalls {\n-        names,\n-        result: Vec::new(),\n-    };\n-    fmc.visit_expr(&body.value);\n-    fmc.result\n-}\n-\n-/// Converts a span to a code snippet if available, otherwise use default.\n-///\n-/// This is useful if you want to provide suggestions for your lint or more generally, if you want\n-/// to convert a given `Span` to a `str`.\n-///\n-/// # Example\n-/// ```rust,ignore\n-/// snippet(cx, expr.span, \"..\")\n-/// ```\n-pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n-}\n-\n-/// Same as `snippet`, but it adapts the applicability level by following rules:\n-///\n-/// - Applicability level `Unspecified` will never be changed.\n-/// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n-/// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n-/// `HasPlaceholders`\n-pub fn snippet_with_applicability<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n-    if *applicability != Applicability::Unspecified && span.from_expansion() {\n-        *applicability = Applicability::MaybeIncorrect;\n-    }\n-    snippet_opt(cx, span).map_or_else(\n-        || {\n-            if *applicability == Applicability::MachineApplicable {\n-                *applicability = Applicability::HasPlaceholders;\n-            }\n-            Cow::Borrowed(default)\n-        },\n-        From::from,\n-    )\n-}\n-\n-/// Same as `snippet`, but should only be used when it's clear that the input span is\n-/// not a macro argument.\n-pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    snippet(cx, span.source_callsite(), default)\n-}\n-\n-/// Converts a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n-    cx.sess().source_map().span_to_snippet(span).ok()\n-}\n-\n-/// Converts a span (from a block) to a code snippet if available, otherwise use default.\n-///\n-/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n-/// things which need to be printed as such.\n-///\n-/// The `indent_relative_to` arg can be used, to provide a span, where the indentation of the\n-/// resulting snippet of the given span.\n-///\n-/// # Example\n-///\n-/// ```rust,ignore\n-/// snippet_block(cx, block.span, \"..\", None)\n-/// // where, `block` is the block of the if expr\n-///     if x {\n-///         y;\n-///     }\n-/// // will return the snippet\n-/// {\n-///     y;\n-/// }\n-/// ```\n-///\n-/// ```rust,ignore\n-/// snippet_block(cx, block.span, \"..\", Some(if_expr.span))\n-/// // where, `block` is the block of the if expr\n-///     if x {\n-///         y;\n-///     }\n-/// // will return the snippet\n-/// {\n-///         y;\n-///     } // aligned with `if`\n-/// ```\n-/// Note that the first line of the snippet always has 0 indentation.\n-pub fn snippet_block<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-) -> Cow<'a, str> {\n-    let snip = snippet(cx, span, default);\n-    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    reindent_multiline(snip, true, indent)\n-}\n-\n-/// Same as `snippet_block`, but adapts the applicability level by the rules of\n-/// `snippet_with_applicability`.\n-pub fn snippet_block_with_applicability<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-    applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n-    let snip = snippet_with_applicability(cx, span, default, applicability);\n-    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    reindent_multiline(snip, true, indent)\n-}\n-\n-/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n-/// line.\n-///\n-/// ```rust,ignore\n-///     let x = ();\n-/// //          ^^\n-/// // will be converted to\n-///     let x = ();\n-/// //  ^^^^^^^^^^\n-/// ```\n-pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n-}\n-\n-fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n-    let line_span = line_span(cx, span);\n-    snippet_opt(cx, line_span).and_then(|snip| {\n-        snip.find(|c: char| !c.is_whitespace())\n-            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n-    })\n-}\n-\n-/// Returns the indentation of the line of a span\n-///\n-/// ```rust,ignore\n-/// let x = ();\n-/// //      ^^ -- will return 0\n-///     let x = ();\n-/// //          ^^ -- will return 4\n-/// ```\n-pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n-    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n-}\n-\n-/// Returns the positon just before rarrow\n-///\n-/// ```rust,ignore\n-/// fn into(self) -> () {}\n-///              ^\n-/// // in case of unformatted code\n-/// fn into2(self)-> () {}\n-///               ^\n-/// fn into3(self)   -> () {}\n-///               ^\n-/// ```\n-pub fn position_before_rarrow(s: &str) -> Option<usize> {\n-    s.rfind(\"->\").map(|rpos| {\n-        let mut rpos = rpos;\n-        let chars: Vec<char> = s.chars().collect();\n-        while rpos > 1 {\n-            if let Some(c) = chars.get(rpos - 1) {\n-                if c.is_whitespace() {\n-                    rpos -= 1;\n-                    continue;\n-                }\n-            }\n-            break;\n-        }\n-        rpos\n-    })\n-}\n-\n-/// Extends the span to the beginning of the spans line, incl. whitespaces.\n-///\n-/// ```rust,ignore\n-///        let x = ();\n-/// //             ^^\n-/// // will be converted to\n-///        let x = ();\n-/// // ^^^^^^^^^^^^^^\n-/// ```\n-fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    let span = original_sp(span, DUMMY_SP);\n-    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n-    let line_no = source_map_and_line.line;\n-    let line_start = source_map_and_line.sf.lines[line_no];\n-    Span::new(line_start, span.hi(), span.ctxt())\n-}\n-\n-/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n-/// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(\n-    cx: &T,\n-    expr: &Expr<'_>,\n-    option: Option<String>,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-) -> Cow<'a, str> {\n-    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n-    let string = option.unwrap_or_default();\n-    if expr.span.from_expansion() {\n-        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n-    } else if let ExprKind::Block(_, _) = expr.kind {\n-        Cow::Owned(format!(\"{}{}\", code, string))\n-    } else if string.is_empty() {\n-        Cow::Owned(format!(\"{{ {} }}\", code))\n-    } else {\n-        Cow::Owned(format!(\"{{\\n{};\\n{}\\n}}\", code, string))\n-    }\n-}\n-\n-/// Reindent a multiline string with possibility of ignoring the first line.\n-#[allow(clippy::needless_pass_by_value)]\n-pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n-    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n-    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n-    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n-}\n-\n-fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n-    let x = s\n-        .lines()\n-        .skip(ignore_first as usize)\n-        .filter_map(|l| {\n-            if l.is_empty() {\n-                None\n-            } else {\n-                // ignore empty lines\n-                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n-            }\n-        })\n-        .min()\n-        .unwrap_or(0);\n-    let indent = indent.unwrap_or(0);\n-    s.lines()\n-        .enumerate()\n-        .map(|(i, l)| {\n-            if (ignore_first && i == 0) || l.is_empty() {\n-                l.to_owned()\n-            } else if x > indent {\n-                l.split_at(x - indent).1.to_owned()\n-            } else {\n-                \" \".repeat(indent - x) + l\n-            }\n-        })\n-        .collect::<Vec<String>>()\n-        .join(\"\\n\")\n-}\n-\n-/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let hir_id = e.hir_id;\n-    let parent_id = map.get_parent_node(hir_id);\n-    if hir_id == parent_id {\n-        return None;\n-    }\n-    map.find(parent_id).and_then(|node| {\n-        if let Node::Expr(parent) = node {\n-            Some(parent)\n-        } else {\n-            None\n-        }\n-    })\n-}\n-\n-pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let enclosing_node = map\n-        .get_enclosing_scope(hir_id)\n-        .and_then(|enclosing_id| map.find(enclosing_id));\n-    enclosing_node.and_then(|node| match node {\n-        Node::Block(block) => Some(block),\n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(_, _, eid),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(_, eid),\n-            ..\n-        }) => match cx.tcx.hir().body(eid).value.kind {\n-            ExprKind::Block(ref block, _) => Some(block),\n-            _ => None,\n-        },\n-        _ => None,\n-    })\n-}\n-\n-/// Returns the base type for HIR references and pointers.\n-pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n-    match ty.kind {\n-        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n-        _ => ty,\n-    }\n-}\n-\n-/// Returns the base type for references and raw pointers, and count reference\n-/// depth.\n-pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n-    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n-        match ty.kind() {\n-            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n-            _ => (ty, depth),\n-        }\n-    }\n-    inner(ty, 0)\n-}\n-\n-/// Checks whether the given expression is a constant integer of the given value.\n-/// unlike `is_integer_literal`, this version does const folding\n-pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n-    if is_integer_literal(e, value) {\n-        return true;\n-    }\n-    let map = cx.tcx.hir();\n-    let parent_item = map.get_parent_item(e.hir_id);\n-    if let Some((Constant::Int(v), _)) = map\n-        .maybe_body_owned_by(parent_item)\n-        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n-    {\n-        value == v\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Checks whether the given expression is a constant literal of the given value.\n-pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n-    // FIXME: use constant folding\n-    if let ExprKind::Lit(ref spanned) = expr.kind {\n-        if let LitKind::Int(v, _) = spanned.node {\n-            return v == value;\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns `true` if the given `Expr` has been coerced before.\n-///\n-/// Examples of coercions can be found in the Nomicon at\n-/// <https://doc.rust-lang.org/nomicon/coercions.html>.\n-///\n-/// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n-/// information on adjustments and coercions.\n-pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n-}\n-\n-/// Returns the pre-expansion span if is this comes from an expansion of the\n-/// macro `name`.\n-/// See also `is_direct_expn_of`.\n-#[must_use]\n-pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n-    loop {\n-        if span.from_expansion() {\n-            let data = span.ctxt().outer_expn_data();\n-            let new_span = data.call_site;\n-\n-            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n-                if mac_name.as_str() == name {\n-                    return Some(new_span);\n-                }\n-            }\n-\n-            span = new_span;\n-        } else {\n-            return None;\n-        }\n-    }\n-}\n-\n-/// Returns the pre-expansion span if the span directly comes from an expansion\n-/// of the macro `name`.\n-/// The difference with `is_expn_of` is that in\n-/// ```rust,ignore\n-/// foo!(bar!(42));\n-/// ```\n-/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n-/// `bar!` by\n-/// `is_direct_expn_of`.\n-#[must_use]\n-pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    if span.from_expansion() {\n-        let data = span.ctxt().outer_expn_data();\n-        let new_span = data.call_site;\n-\n-        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n-            if mac_name.as_str() == name {\n-                return Some(new_span);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Convenience function to get the return type of a function.\n-pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n-    let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n-    cx.tcx.erase_late_bound_regions(ret_ty)\n-}\n-\n-/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n-pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n-        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n-        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-    })\n-}\n-\n-/// Returns `true` if the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n-        _ => false,\n-    }\n-}\n-\n-pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n-}\n-\n-/// Checks if an expression is constructing a tuple-like enum variant or struct\n-pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref fun, _) = expr.kind {\n-        if let ExprKind::Path(ref qp) = fun.kind {\n-            let res = cx.qpath_res(qp, fun.hir_id);\n-            return match res {\n-                def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n-                def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n-                _ => false,\n-            };\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns `true` if a pattern is refutable.\n-// TODO: should be implemented using rustc/mir_build/thir machinery\n-pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n-    fn is_enum_variant(cx: &LateContext<'_>, qpath: &QPath<'_>, id: HirId) -> bool {\n-        matches!(\n-            cx.qpath_res(qpath, id),\n-            def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n-        )\n-    }\n-\n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_>, mut i: I) -> bool {\n-        i.any(|pat| is_refutable(cx, pat))\n-    }\n-\n-    match pat.kind {\n-        PatKind::Wild => false,\n-        PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n-        PatKind::Lit(..) | PatKind::Range(..) => true,\n-        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n-        PatKind::Or(ref pats) => {\n-            // TODO: should be the honest check, that pats is exhaustive set\n-            are_refutable(cx, pats.iter().map(|pat| &**pat))\n-        },\n-        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n-            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n-        },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n-            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n-        },\n-        PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n-                ty::Slice(..) => {\n-                    // [..] is the only irrefutable slice pattern.\n-                    !head.is_empty() || middle.is_none() || !tail.is_empty()\n-                },\n-                ty::Array(..) => are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat)),\n-                _ => {\n-                    // unreachable!()\n-                    true\n-                },\n-            }\n-        },\n-    }\n-}\n-\n-/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n-/// implementations have.\n-pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n-}\n-\n-/// Remove blocks around an expression.\n-///\n-/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n-/// themselves.\n-pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(ref block, ..) = expr.kind {\n-        match (block.stmts.is_empty(), block.expr.as_ref()) {\n-            (true, Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n-pub fn is_self(slf: &Param<'_>) -> bool {\n-    if let PatKind::Binding(.., name, _) = slf.pat.kind {\n-        name.name == kw::SelfLower\n-    } else {\n-        false\n-    }\n-}\n-\n-pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n-        if let Res::SelfTy(..) = path.res;\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}\n-\n-pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n-    (0..decl.inputs.len()).map(move |i| &body.params[i])\n-}\n-\n-/// Checks if a given expression is a match expression expanded from the `?`\n-/// operator or the `try` macro.\n-pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    fn is_ok(arm: &Arm<'_>) -> bool {\n-        if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n-            if match_qpath(path, &paths::RESULT_OK[1..]);\n-            if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n-            if path_to_local_id(arm.body, hir_id);\n-            then {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    fn is_err(arm: &Arm<'_>) -> bool {\n-        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            match_qpath(path, &paths::RESULT_ERR[1..])\n-        } else {\n-            false\n-        }\n-    }\n-\n-    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n-        // desugared from a `?` operator\n-        if let MatchSource::TryDesugar = *source {\n-            return Some(expr);\n-        }\n-\n-        if_chain! {\n-            if arms.len() == 2;\n-            if arms[0].guard.is_none();\n-            if arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n-            then {\n-                return Some(expr);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Returns `true` if the lint is allowed in the current context\n-///\n-/// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n-    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n-}\n-\n-pub fn strip_pat_refs<'hir>(mut pat: &'hir Pat<'hir>) -> &'hir Pat<'hir> {\n-    while let PatKind::Ref(subpat, _) = pat.kind {\n-        pat = subpat;\n-    }\n-    pat\n-}\n-\n-pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {\n-    Integer::from_int_ty(&tcx, ity).size().bits()\n-}\n-\n-#[allow(clippy::cast_possible_wrap)]\n-/// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ty::IntTy) -> i128 {\n-    let amt = 128 - int_bits(tcx, ity);\n-    ((u as i128) << amt) >> amt\n-}\n-\n-#[allow(clippy::cast_sign_loss)]\n-/// clip unused bytes\n-pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ty::IntTy) -> u128 {\n-    let amt = 128 - int_bits(tcx, ity);\n-    ((u as u128) << amt) >> amt\n-}\n-\n-/// clip unused bytes\n-pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ty::UintTy) -> u128 {\n-    let bits = Integer::from_uint_ty(&tcx, ity).size().bits();\n-    let amt = 128 - bits;\n-    (u << amt) >> amt\n-}\n-\n-/// Removes block comments from the given `Vec` of lines.\n-///\n-/// # Examples\n-///\n-/// ```rust,ignore\n-/// without_block_comments(vec![\"/*\", \"foo\", \"*/\"]);\n-/// // => vec![]\n-///\n-/// without_block_comments(vec![\"bar\", \"/*\", \"foo\", \"*/\"]);\n-/// // => vec![\"bar\"]\n-/// ```\n-pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n-    let mut without = vec![];\n-\n-    let mut nest_level = 0;\n-\n-    for line in lines {\n-        if line.contains(\"/*\") {\n-            nest_level += 1;\n-            continue;\n-        } else if line.contains(\"*/\") {\n-            nest_level -= 1;\n-            continue;\n-        }\n-\n-        if nest_level == 0 {\n-            without.push(line);\n-        }\n-    }\n-\n-    without\n-}\n-\n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n-    let map = &tcx.hir();\n-    let mut prev_enclosing_node = None;\n-    let mut enclosing_node = node;\n-    while Some(enclosing_node) != prev_enclosing_node {\n-        if is_automatically_derived(map.attrs(enclosing_node)) {\n-            return true;\n-        }\n-        prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.get_parent_item(enclosing_node);\n-    }\n-    false\n-}\n-\n-/// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n-    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n-    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n-    // so we can't use its `lookup_method` method.\n-    let into_iter_collections: [&[&str]; 13] = [\n-        &paths::VEC,\n-        &paths::OPTION,\n-        &paths::RESULT,\n-        &paths::BTREESET,\n-        &paths::BTREEMAP,\n-        &paths::VEC_DEQUE,\n-        &paths::LINKED_LIST,\n-        &paths::BINARY_HEAP,\n-        &paths::HASHSET,\n-        &paths::HASHMAP,\n-        &paths::PATH_BUF,\n-        &paths::PATH,\n-        &paths::RECEIVER,\n-    ];\n-\n-    let ty_to_check = match probably_ref_ty.kind() {\n-        ty::Ref(_, ty_to_check, _) => ty_to_check,\n-        _ => probably_ref_ty,\n-    };\n-\n-    let def_id = match ty_to_check.kind() {\n-        ty::Array(..) => return Some(\"array\"),\n-        ty::Slice(..) => return Some(\"slice\"),\n-        ty::Adt(adt, _) => adt.did,\n-        _ => return None,\n-    };\n-\n-    for path in &into_iter_collections {\n-        if match_def_path(cx, def_id, path) {\n-            return Some(*path.last().unwrap());\n-        }\n-    }\n-    None\n-}\n-\n-/// Matches a function call with the given path and returns the arguments.\n-///\n-/// Usage:\n-///\n-/// ```rust,ignore\n-/// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n-/// ```\n-pub fn match_function_call<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    path: &[&str],\n-) -> Option<&'tcx [Expr<'tcx>]> {\n-    if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, path);\n-        then {\n-            return Some(&args)\n-        }\n-    };\n-    None\n-}\n-\n-/// Checks if `Ty` is normalizable. This function is useful\n-/// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let cause = rustc_middle::traits::ObligationCause::dummy();\n-        infcx.at(&cause, param_env).normalize(ty).is_ok()\n-    })\n-}\n-\n-pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n-    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n-    // accepts only that. We should probably move to Symbols in Clippy as well.\n-    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n-    cx.match_def_path(did, &syms)\n-}\n-\n-pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n-    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n-        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n-}\n-\n-pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_def_path(cx, did, &paths::BEGIN_PANIC)\n-        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANIC_ANY)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n-}\n-\n-/// Returns the list of condition expressions and the list of blocks in a\n-/// sequence of `if/else`.\n-/// E.g., this returns `([a, b], [c, d, e])` for the expression\n-/// `if a { c } else if b { d } else { e }`.\n-pub fn if_sequence<'tcx>(\n-    mut expr: &'tcx Expr<'tcx>,\n-) -> (SmallVec<[&'tcx Expr<'tcx>; 1]>, SmallVec<[&'tcx Block<'tcx>; 1]>) {\n-    let mut conds = SmallVec::new();\n-    let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n-\n-    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n-        conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.kind {\n-            blocks.push(block);\n-        } else {\n-            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n-        }\n-\n-        if let Some(ref else_expr) = *else_expr {\n-            expr = else_expr;\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    // final `else {..}`\n-    if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.kind {\n-            blocks.push(&**block);\n-        }\n-    }\n-\n-    (conds, blocks)\n-}\n-\n-pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    let parent_id = map.get_parent_node(expr.hir_id);\n-    let parent_node = map.get(parent_id);\n-    matches!(\n-        parent_node,\n-        Node::Expr(Expr {\n-            kind: ExprKind::If(_, _, _),\n-            ..\n-        })\n-    )\n-}\n-\n-// Finds the attribute with the given name, if any\n-pub fn attr_by_name<'a>(attrs: &'a [Attribute], name: &'_ str) -> Option<&'a Attribute> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.ident().map_or(false, |ident| ident.as_str() == name))\n-}\n-\n-// Finds the `#[must_use]` attribute, if any\n-pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n-    attr_by_name(attrs, \"must_use\")\n-}\n-\n-// Returns whether the type has #[must_use] attribute\n-pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ref ty)\n-        | ty::Array(ref ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n-        | ty::Ref(_, ref ty, _) => {\n-            // for the Array case we don't need to care for the len == 0 case\n-            // because we don't want to lint functions returning empty arrays\n-            is_must_use_ty(cx, *ty)\n-        },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(ref def_id, _) => {\n-            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n-                        return true;\n-                    }\n-                }\n-            }\n-            false\n-        },\n-        ty::Dynamic(binder, _) => {\n-            for predicate in binder.iter() {\n-                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n-                        return true;\n-                    }\n-                }\n-            }\n-            false\n-        },\n-        _ => false,\n-    }\n-}\n-\n-// check if expr is calling method or function with #[must_use] attribute\n-pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let did = match expr.kind {\n-        ExprKind::Call(ref path, _) => if_chain! {\n-            if let ExprKind::Path(ref qpath) = path.kind;\n-            if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n-            then {\n-                Some(did)\n-            } else {\n-                None\n-            }\n-        },\n-        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-        _ => None,\n-    };\n-\n-    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n-}\n-\n-pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n-    krate.item.attrs.iter().any(|attr| {\n-        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n-            attr.path == sym::no_std\n-        } else {\n-            false\n-        }\n-    })\n-}\n-\n-/// Check if parent of a hir node is a trait implementation block.\n-/// For example, `f` in\n-/// ```rust,ignore\n-/// impl Trait for S {\n-///     fn f() {}\n-/// }\n-/// ```\n-pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n-    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-        matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Check if it's even possible to satisfy the `where` clause for the item.\n-///\n-/// `trivial_bounds` feature allows functions with unsatisfiable bounds, for example:\n-///\n-/// ```ignore\n-/// fn foo() where i32: Iterator {\n-///     for _ in 2i32 {}\n-/// }\n-/// ```\n-pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n-    use rustc_trait_selection::traits;\n-    let predicates =\n-        cx.tcx\n-            .predicates_of(did)\n-            .predicates\n-            .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-    traits::impossible_predicates(\n-        cx.tcx,\n-        traits::elaborate_predicates(cx.tcx, predicates)\n-            .map(|o| o.predicate)\n-            .collect::<Vec<_>>(),\n-    )\n-}\n-\n-/// Returns the `DefId` of the callee if the given expression is a function or method call.\n-pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n-    match &expr.kind {\n-        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(qpath),\n-                hir_id: path_hir_id,\n-                ..\n-            },\n-            ..,\n-        ) => cx.typeck_results().qpath_res(qpath, *path_hir_id).opt_def_id(),\n-        _ => None,\n-    }\n-}\n-\n-pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n-    lints.iter().any(|lint| {\n-        matches!(\n-            cx.tcx.lint_level_at_node(lint, id),\n-            (Level::Forbid | Level::Deny | Level::Warn, _)\n-        )\n-    })\n-}\n-\n-/// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n-/// number type, a str, or an array, slice, or tuple of those types).\n-pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n-        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n-        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n-        _ => false,\n-    }\n-}\n-\n-/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n-/// slice iff the given expression is a slice of primitives (as defined in the\n-/// `is_recursively_primitive_type` function) and None otherwise.\n-pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n-    let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    let expr_kind = expr_type.kind();\n-    let is_primitive = match expr_kind {\n-        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n-        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n-            if let ty::Slice(element_type) = inner_ty.kind() {\n-                is_recursively_primitive_type(element_type)\n-            } else {\n-                unreachable!()\n-            }\n-        },\n-        _ => false,\n-    };\n-\n-    if is_primitive {\n-        // if we have wrappers like Array, Slice or Tuple, print these\n-        // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n-            ty::Slice(..) => return Some(\"slice\".into()),\n-            ty::Array(..) => return Some(\"array\".into()),\n-            ty::Tuple(..) => return Some(\"tuple\".into()),\n-            _ => {\n-                // is_recursively_primitive_type() should have taken care\n-                // of the rest and we can rely on the type that is found\n-                let refs_peeled = expr_type.peel_refs();\n-                return Some(refs_peeled.walk().last().unwrap().to_string());\n-            },\n-        }\n-    }\n-    None\n-}\n-\n-/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n-/// `hash` must be comformed with `eq`\n-pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n-where\n-    Hash: Fn(&T) -> u64,\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        return vec![(&exprs[0], &exprs[1])];\n-    }\n-\n-    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n-\n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n-\n-    for expr in exprs {\n-        match map.entry(hash(expr)) {\n-            Entry::Occupied(mut o) => {\n-                for o in o.get() {\n-                    if eq(o, expr) {\n-                        match_expr_list.push((o, expr));\n-                    }\n-                }\n-                o.get_mut().push(expr);\n-            },\n-            Entry::Vacant(v) => {\n-                v.insert(vec![expr]);\n-            },\n-        }\n-    }\n-\n-    match_expr_list\n-}\n-\n-/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n-/// references removed.\n-pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n-    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n-        if let PatKind::Ref(pat, _) = pat.kind {\n-            peel(pat, count + 1)\n-        } else {\n-            (pat, count)\n-        }\n-    }\n-    peel(pat, 0)\n-}\n-\n-/// Peels off up to the given number of references on the expression. Returns the underlying\n-/// expression and the number of references removed.\n-pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0, count)\n-}\n-\n-/// Peels off all references on the type. Returns the underlying type and the number of references\n-/// removed.\n-pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n-    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n-        } else {\n-            (ty, count)\n-        }\n-    }\n-    peel(ty, 0)\n-}\n-\n-#[macro_export]\n-macro_rules! unwrap_cargo_metadata {\n-    ($cx: ident, $lint: ident, $deps: expr) => {{\n-        let mut command = cargo_metadata::MetadataCommand::new();\n-        if !$deps {\n-            command.no_deps();\n-        }\n-\n-        match command.exec() {\n-            Ok(metadata) => metadata,\n-            Err(err) => {\n-                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n-                return;\n-            },\n-        }\n-    }};\n-}\n-\n-pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-        if let Res::Def(_, def_id) = path.res;\n-        then {\n-            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n-pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-/// Check if the resolution of a given path is a `Some` variant of `Option`.\n-pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{reindent_multiline, without_block_comments};\n-\n-    #[test]\n-    fn test_reindent_multiline_single_line() {\n-        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_block() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-    } else {\n-        z\n-    }\", reindent_multiline(\"    if x {\n-            y\n-        } else {\n-            z\n-        }\".into(), false, None));\n-        assert_eq!(\"\\\n-    if x {\n-    \\ty\n-    } else {\n-    \\tz\n-    }\", reindent_multiline(\"    if x {\n-        \\ty\n-        } else {\n-        \\tz\n-        }\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_empty_line() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-\n-    } else {\n-        z\n-    }\", reindent_multiline(\"    if x {\n-            y\n-\n-        } else {\n-            z\n-        }\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_lines_deeper() {\n-        assert_eq!(\"\\\n-        if x {\n-            y\n-        } else {\n-            z\n-        }\", reindent_multiline(\"\\\n-    if x {\n-        y\n-    } else {\n-        z\n-    }\".into(), true, Some(8)));\n-    }\n-\n-    #[test]\n-    fn test_without_block_comments_lines_without_block_comments() {\n-        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n-        println!(\"result: {:?}\", result);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n-        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n-\n-        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n-        assert!(result.is_empty());\n \n-        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n-        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n-    }\n-}\n+pub use clippy_utils::*;"}, {"sha": "8d111f98add9aac2c7ba145d443bbbf67cb5a594", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,12 +1,14 @@\n-use crate::utils::{is_type_diagnostic_item, match_def_path, paths, snippet, span_lint_and_sugg};\n+use crate::utils::{\n+    is_type_diagnostic_item, match_def_path, path_to_local, path_to_local_id, paths, snippet, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span};\n use std::convert::TryInto;\n \n declare_clippy_lint! {\n@@ -45,8 +47,8 @@ enum VecInitKind {\n     WithCapacity(u64),\n }\n struct VecPushSearcher {\n+    local_id: HirId,\n     init: VecInitKind,\n-    name: Symbol,\n     lhs_is_local: bool,\n     lhs_span: Span,\n     err_span: Span,\n@@ -81,17 +83,20 @@ impl VecPushSearcher {\n }\n \n impl LateLintPass<'_> for VecInitThenPush {\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n+    fn check_block(&mut self, _: &LateContext<'tcx>, _: &'tcx Block<'tcx>) {\n         self.searcher = None;\n+    }\n+\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), local.span);\n             if let Some(init) = local.init;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, _, ident, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, id, _, None) = local.pat.kind;\n             if let Some(init_kind) = get_vec_init_kind(cx, init);\n             then {\n                 self.searcher = Some(VecPushSearcher {\n+                        local_id: id,\n                         init: init_kind,\n-                        name: ident.name,\n                         lhs_is_local: true,\n                         lhs_span: local.ty.map_or(local.pat.span, |t| local.pat.span.to(t.span)),\n                         err_span: local.span,\n@@ -106,13 +111,12 @@ impl LateLintPass<'_> for VecInitThenPush {\n             if_chain! {\n                 if !in_external_macro(cx.sess(), expr.span);\n                 if let ExprKind::Assign(left, right, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n-                if let Some(name) = path.segments.get(0);\n+                if let Some(id) = path_to_local(left);\n                 if let Some(init_kind) = get_vec_init_kind(cx, right);\n                 then {\n                     self.searcher = Some(VecPushSearcher {\n+                        local_id: id,\n                         init: init_kind,\n-                        name: name.ident.name,\n                         lhs_is_local: false,\n                         lhs_span: left.span,\n                         err_span: expr.span,\n@@ -128,10 +132,8 @@ impl LateLintPass<'_> for VecInitThenPush {\n             if_chain! {\n                 if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind;\n                 if let ExprKind::MethodCall(path, _, [self_arg, _], _) = expr.kind;\n+                if path_to_local_id(self_arg, searcher.local_id);\n                 if path.ident.name.as_str() == \"push\";\n-                if let ExprKind::Path(QPath::Resolved(_, self_path)) = self_arg.kind;\n-                if let [self_name] = self_path.segments;\n-                if self_name.ident.name == searcher.name;\n                 then {\n                     self.searcher = Some(VecPushSearcher {\n                         found: searcher.found + 1,"}, {"sha": "553e6b000ebbc055161347f939a3060f206893b4", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -149,7 +149,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n-    ///\n     /// // Bad\n     /// writeln!(buf, \"\");\n     ///\n@@ -176,7 +175,6 @@ declare_clippy_lint! {\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n     /// # let name = \"World\";\n-    ///\n     /// // Bad\n     /// write!(buf, \"Hello {}!\\n\", name);\n     ///\n@@ -202,7 +200,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n-    ///\n     /// // Bad\n     /// writeln!(buf, \"{}\", \"foo\");\n     ///"}, {"sha": "9c01badb04cc9e6856341bbf5b596d3335cb02b6", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+name = \"clippy_utils\"\n+version = \"0.1.52\"\n+authors = [\"The Rust Clippy Developers\"]\n+edition = \"2018\"\n+publish = false\n+\n+[dependencies]\n+if_chain = \"1.0.0\"\n+itertools = \"0.9\"\n+regex-syntax = \"0.6\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+smallvec = { version = \"1\", features = [\"union\"] }\n+toml = \"0.5.3\"\n+unicode-normalization = \"0.1\"\n+rustc-semver=\"1.1.0\"\n+\n+[features]\n+internal-lints = []"}, {"sha": "9ef1557ec061d54f8a6b5b17190e72c80fa951ed", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "renamed", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -4,7 +4,7 @@\n \n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use crate::utils::{both, over};\n+use crate::{both, over};\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n@@ -229,23 +229,20 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n     match (l, r) {\n         (ExternCrate(l), ExternCrate(r)) => l == r,\n         (Use(l), Use(r)) => eq_use_tree(l, r),\n-        (Static(lt, lm, le), Static(rt, rm, re)) => {\n-            lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re)\n-        }\n-        (Const(ld, lt, le), Const(rd, rt, re)) => {\n-            eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re)\n-        }\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (Fn(box FnKind(ld, lf, lg, lb)), Fn(box FnKind(rd, rf, rg, rb))) => {\n-            eq_defaultness(*ld, *rd)\n-                && eq_fn_sig(lf, rf)\n-                && eq_generics(lg, rg)\n-                && both(lb, rb, |l, r| eq_block(l, r))\n-        }\n-        (Mod(lu, lmk), Mod(ru, rmk)) => lu == ru && match (lmk, rmk) {\n-            (ModKind::Loaded(litems, linline, _), ModKind::Loaded(ritems, rinline, _)) =>\n-                linline == rinline && over(litems, ritems, |l, r| eq_item(l, r, eq_item_kind)),\n-            (ModKind::Unloaded, ModKind::Unloaded) => true,\n-            _ => false,\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (Mod(lu, lmk), Mod(ru, rmk)) => {\n+            lu == ru\n+                && match (lmk, rmk) {\n+                    (ModKind::Loaded(litems, linline, _), ModKind::Loaded(ritems, rinline, _)) => {\n+                        linline == rinline && over(litems, ritems, |l, r| eq_item(l, r, eq_item_kind))\n+                    },\n+                    (ModKind::Unloaded, ModKind::Unloaded) => true,\n+                    _ => false,\n+                }\n         },\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n@@ -311,15 +308,10 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n     use ForeignItemKind::*;\n     match (l, r) {\n-        (Static(lt, lm, le), Static(rt, rm, re)) => {\n-            lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re)\n-        }\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (Fn(box FnKind(ld, lf, lg, lb)), Fn(box FnKind(rd, rf, rg, rb))) => {\n-            eq_defaultness(*ld, *rd)\n-                && eq_fn_sig(lf, rf)\n-                && eq_generics(lg, rg)\n-                && both(lb, rb, |l, r| eq_block(l, r))\n-        }\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n         (TyAlias(box TyAliasKind(ld, lg, lb, lt)), TyAlias(box TyAliasKind(rd, rg, rb, rt))) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs"}, {"sha": "eefcbabd835d2b669cf65be463c4130b366b66e7", "filename": "src/tools/clippy/clippy_utils/src/ast_utils/ident_iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils/ident_iter.rs"}, {"sha": "8d28421d70d707fdec87dcbf03a059f5d63ada2c", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs"}, {"sha": "ba1c01ebc9f76d2523340b2bd7c56cd482142293", "filename": "src/tools/clippy/clippy_utils/src/camel_case.rs", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcamel_case.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -55,6 +55,8 @@ pub fn from(s: &str) -> usize {\n             }\n         } else if c.is_lowercase() {\n             down = true;\n+        } else if c.is_uppercase() {\n+            last_i = i;\n         } else {\n             return last_i;\n         }\n@@ -70,12 +72,16 @@ mod test {\n     fn from_full() {\n         assert_eq!(from(\"AbcDef\"), 0);\n         assert_eq!(from(\"Abc\"), 0);\n+        assert_eq!(from(\"ABcd\"), 0);\n+        assert_eq!(from(\"ABcdEf\"), 0);\n+        assert_eq!(from(\"AabABcd\"), 0);\n     }\n \n     #[test]\n     fn from_partial() {\n         assert_eq!(from(\"abcDef\"), 3);\n         assert_eq!(from(\"aDbc\"), 1);\n+        assert_eq!(from(\"aabABcd\"), 3);\n     }\n \n     #[test]", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/camel_case.rs"}, {"sha": "7a18d5e818fb1c607298209b6b344ef6a484021d", "filename": "src/tools/clippy/clippy_utils/src/comparisons.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fcomparisons.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/comparisons.rs"}, {"sha": "802c01055a68c84d68dd4307c841c6b67bcfa334", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,574 @@\n+#![allow(clippy::float_cmp)]\n+\n+use crate::{clip, sext, unsext};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, LitFloatType, LitKind};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n+use rustc_span::symbol::Symbol;\n+use std::cmp::Ordering::{self, Equal};\n+use std::convert::TryInto;\n+use std::hash::{Hash, Hasher};\n+\n+/// A `LitKind`-like enum to fold constant `Expr`s into.\n+#[derive(Debug, Clone)]\n+pub enum Constant {\n+    /// A `String` (e.g., \"abc\").\n+    Str(String),\n+    /// A binary string (e.g., `b\"abc\"`).\n+    Binary(Lrc<[u8]>),\n+    /// A single `char` (e.g., `'a'`).\n+    Char(char),\n+    /// An integer's bit representation.\n+    Int(u128),\n+    /// An `f32`.\n+    F32(f32),\n+    /// An `f64`.\n+    F64(f64),\n+    /// `true` or `false`.\n+    Bool(bool),\n+    /// An array of constants.\n+    Vec(Vec<Constant>),\n+    /// Also an array, but with only one constant, repeated N times.\n+    Repeat(Box<Constant>, u64),\n+    /// A tuple of constants.\n+    Tuple(Vec<Constant>),\n+    /// A raw pointer.\n+    RawPtr(u128),\n+    /// A reference\n+    Ref(Box<Constant>),\n+    /// A literal with syntax error.\n+    Err(Symbol),\n+}\n+\n+impl PartialEq for Constant {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                l.to_bits() == r.to_bits()\n+            },\n+            (&Self::F32(l), &Self::F32(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                f64::from(l).to_bits() == f64::from(r).to_bits()\n+            },\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        std::mem::discriminant(self).hash(state);\n+        match *self {\n+            Self::Str(ref s) => {\n+                s.hash(state);\n+            },\n+            Self::Binary(ref b) => {\n+                b.hash(state);\n+            },\n+            Self::Char(c) => {\n+                c.hash(state);\n+            },\n+            Self::Int(i) => {\n+                i.hash(state);\n+            },\n+            Self::F32(f) => {\n+                f64::from(f).to_bits().hash(state);\n+            },\n+            Self::F64(f) => {\n+                f.to_bits().hash(state);\n+            },\n+            Self::Bool(b) => {\n+                b.hash(state);\n+            },\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n+                v.hash(state);\n+            },\n+            Self::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            },\n+            Self::RawPtr(u) => {\n+                u.hash(state);\n+            },\n+            Self::Ref(ref r) => {\n+                r.hash(state);\n+            },\n+            Self::Err(ref s) => {\n+                s.hash(state);\n+            },\n+        }\n+    }\n+}\n+\n+impl Constant {\n+    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+        match (left, right) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n+                if let ty::Int(int_ty) = *cmp_type.kind() {\n+                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n+                } else {\n+                    Some(l.cmp(&r))\n+                }\n+            },\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n+                .iter()\n+                .zip(r.iter())\n+                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                }\n+            },\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Parses a `LitKind` to a `Constant`.\n+pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+    match *lit {\n+        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n+        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n+        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::Char(c) => Constant::Char(c),\n+        LitKind::Int(n, _) => Constant::Int(n),\n+        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n+            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n+            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n+        },\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n+            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n+            _ => bug!(),\n+        },\n+        LitKind::Bool(b) => Constant::Bool(b),\n+        LitKind::Err(s) => Constant::Err(s),\n+    }\n+}\n+\n+pub fn constant<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    };\n+    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+}\n+\n+pub fn constant_simple<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<Constant> {\n+    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+}\n+\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n+pub fn constant_context<'a, 'tcx>(\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> ConstEvalLateContext<'a, 'tcx> {\n+    ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    }\n+}\n+\n+pub struct ConstEvalLateContext<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    needed_resolution: bool,\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n+    /// Simple constant folding: Insert an expression, get a constant or none.\n+    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n+        match e.kind {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n+                let n = match self.typeck_results.expr_ty(e).kind() {\n+                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n+            },\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n+            }),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Call(ref callee, ref args) => {\n+                // We only handle a few const functions for now.\n+                if_chain! {\n+                    if args.is_empty();\n+                    if let ExprKind::Path(qpath) = &callee.kind;\n+                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n+                    if let Some(def_id) = res.opt_def_id();\n+                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n+                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n+                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n+                    then {\n+                       let value = match int_impl {\n+                           \"<impl i8>\" => i8::MAX as u128,\n+                           \"<impl i16>\" => i16::MAX as u128,\n+                           \"<impl i32>\" => i32::MAX as u128,\n+                           \"<impl i64>\" => i64::MAX as u128,\n+                           \"<impl i128>\" => i128::MAX as u128,\n+                           _ => return None,\n+                       };\n+                       Some(Constant::Int(value))\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }\n+            },\n+            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n+            // TODO: add other expressions.\n+            _ => None,\n+        }\n+    }\n+\n+    #[allow(clippy::cast_possible_wrap)]\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Bool, Int};\n+        match *o {\n+            Bool(b) => Some(Bool(!b)),\n+            Int(value) => {\n+                let value = !value;\n+                match *ty.kind() {\n+                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Int, F32, F64};\n+        match *o {\n+            Int(value) => {\n+                let ity = match *ty.kind() {\n+                    ty::Int(ity) => ity,\n+                    _ => return None,\n+                };\n+                // sign extend\n+                let value = sext(self.lcx.tcx, value, ity);\n+                let value = value.checked_neg()?;\n+                // clear unused bits\n+                Some(Int(unsext(self.lcx.tcx, value, ity)))\n+            },\n+            F32(f) => Some(F32(-f)),\n+            F64(f) => Some(F64(-f)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Create `Some(Vec![..])` of all constants, unless there is any\n+    /// non-constant part.\n+    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n+        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n+    }\n+\n+    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n+        let res = self.typeck_results.qpath_res(qpath, id);\n+        match res {\n+            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n+                let substs = self.typeck_results.node_substs(id);\n+                let substs = if self.substs.is_empty() {\n+                    substs\n+                } else {\n+                    substs.subst(self.lcx.tcx, self.substs)\n+                };\n+\n+                let result = self\n+                    .lcx\n+                    .tcx\n+                    .const_eval_resolve(\n+                        self.param_env,\n+                        ty::WithOptConstParam::unknown(def_id),\n+                        substs,\n+                        None,\n+                        None,\n+                    )\n+                    .ok()\n+                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n+                let result = miri_to_const(&result);\n+                if result.is_some() {\n+                    self.needed_resolution = true;\n+                }\n+                result\n+            },\n+            // FIXME: cover all usable cases.\n+            _ => None,\n+        }\n+    }\n+\n+    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n+        let lhs = self.expr(lhs);\n+        let index = self.expr(index);\n+\n+        match (lhs, index) {\n+            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n+                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                _ => None,\n+            },\n+            (Some(Constant::Vec(vec)), _) => {\n+                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n+                    match vec.get(0) {\n+                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// A block can only yield a constant if it only has one constant expression.\n+    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n+        if block.stmts.is_empty() {\n+            block.expr.as_ref().and_then(|b| self.expr(b))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n+        if let Some(Constant::Bool(b)) = self.expr(cond) {\n+            if b {\n+                self.expr(&*then)\n+            } else {\n+                otherwise.as_ref().and_then(|expr| self.expr(expr))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n+        let l = self.expr(left)?;\n+        let r = self.expr(right);\n+        match (l, r) {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n+                ty::Int(ity) => {\n+                    let l = sext(self.lcx.tcx, l, ity);\n+                    let r = sext(self.lcx.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n+                    match op.node {\n+                        BinOpKind::Add => l.checked_add(r).map(zext),\n+                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::BitXor => Some(zext(l ^ r)),\n+                        BinOpKind::BitOr => Some(zext(l | r)),\n+                        BinOpKind::BitAnd => Some(zext(l & r)),\n+                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                        _ => None,\n+                    }\n+                },\n+                ty::Uint(_) => match op.node {\n+                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (l, r) => match (op.node, l, r) {\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n+                    Some(r)\n+                },\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                _ => None,\n+            },\n+        }\n+    }\n+}\n+\n+pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+    use rustc_middle::mir::interpret::ConstValue;\n+    match result.val {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n+            match result.ty.kind() {\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                    int.try_into().expect(\"invalid f32 bit representation\"),\n+                ))),\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                    int.try_into().expect(\"invalid f64 bit representation\"),\n+                ))),\n+                ty::RawPtr(type_and_mut) => {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n+                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n+                    }\n+                    None\n+                },\n+                // FIXME: implement other conversions.\n+                _ => None,\n+            }\n+        },\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n+                ty::Str => String::from_utf8(\n+                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                        .to_owned(),\n+                )\n+                .ok()\n+                .map(Constant::Str),\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n+                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .to_owned()\n+                        .chunks(4)\n+                        .map(|chunk| {\n+                            Some(Constant::F32(f32::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .to_owned()\n+                        .chunks(8)\n+                        .map(|chunk| {\n+                            Some(Constant::F64(f64::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                // FIXME: implement other array type conversions.\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        // FIXME: implement other conversions.\n+        _ => None,\n+    }\n+}"}, {"sha": "269be217c2d875bf3db450a39940705666154459", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/diagnostics.rs"}, {"sha": "52a33e9b1704c300d8e1ffcf0bcdffcfd9071930", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::utils::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n+use crate::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/eager_or_lazy.rs"}, {"sha": "be22df7109af792da83e68d6263cc14668572579", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, paths};\n+use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs"}, {"sha": "81be9254cbe1a3db8aa180acc936c2e7c2055af9", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "renamed", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,10 +1,12 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::utils::differing_macro_contexts;\n+use crate::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def::Res;\n use rustc_hir::{\n     BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat, FnRetTy,\n-    GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n+    GenericArg, GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n     PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n@@ -24,7 +26,7 @@ pub struct SpanlessEq<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     allow_side_effects: bool,\n-    expr_fallback: Option<Box<dyn Fn(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n+    expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n@@ -45,15 +47,54 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_fallback(self, expr_fallback: impl Fn(&Expr<'_>, &Expr<'_>) -> bool + 'a) -> Self {\n+    pub fn expr_fallback(self, expr_fallback: impl FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a) -> Self {\n         Self {\n             expr_fallback: Some(Box::new(expr_fallback)),\n             ..self\n         }\n     }\n \n-    /// Checks whether two statements are the same.\n-    pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n+    /// Use this method to wrap comparisons that may involve inter-expression context.\n+    /// See `self.locals`.\n+    fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n+        HirEqInterExpr {\n+            inner: self,\n+            locals: FxHashMap::default(),\n+        }\n+    }\n+\n+    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+        self.inter_expr().eq_block(left, right)\n+    }\n+\n+    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        self.inter_expr().eq_expr(left, right)\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n+        self.inter_expr().eq_path_segment(left, right)\n+    }\n+\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment<'_>], right: &[PathSegment<'_>]) -> bool {\n+        self.inter_expr().eq_path_segments(left, right)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+        self.inter_expr().eq_ty_kind(left, right)\n+    }\n+}\n+\n+struct HirEqInterExpr<'a, 'b, 'tcx> {\n+    inner: &'a mut SpanlessEq<'b, 'tcx>,\n+\n+    // When binding are declared, the binding ID in the left expression is mapped to the one on the\n+    // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n+    // these blocks are considered equal since `x` is mapped to `y`.\n+    locals: FxHashMap<HirId, HirId>,\n+}\n+\n+impl HirEqInterExpr<'_, '_, '_> {\n+    fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n                 self.eq_pat(&l.pat, &r.pat)\n@@ -68,21 +109,21 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two blocks are the same.\n-    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+    fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n+    fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n-        if let Some(typeck_results) = self.maybe_typeck_results {\n+        if let Some(typeck_results) = self.inner.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.cx, typeck_results, left),\n-                constant_simple(self.cx, typeck_results, right),\n+                constant_simple(self.inner.cx, typeck_results, left),\n+                constant_simple(self.inner.cx, typeck_results, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -98,10 +139,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -116,7 +157,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -139,19 +180,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 ls == rs\n                     && self.eq_expr(le, re)\n                     && over(la, ra, |l, r| {\n-                        self.eq_expr(&l.body, &r.body)\n+                        self.eq_pat(&l.pat, &r.pat)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && self.eq_pat(&l.pat, &r.pat)\n+                            && self.eq_expr(&l.body, &r.body)\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n+                let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n+                let rl = celcx.expr(&self.inner.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n@@ -168,7 +209,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n             _ => false,\n         };\n-        is_eq || self.expr_fallback.as_ref().map_or(false, |f| f(left, right))\n+        is_eq || self.inner.expr_fallback.as_mut().map_or(false, |f| f(left, right))\n     }\n \n     fn eq_exprs(&mut self, left: &[Expr<'_>], right: &[Expr<'_>]) -> bool {\n@@ -199,13 +240,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n-    pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n+    fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n         let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n         li.name == ri.name && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n-    pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n@@ -214,8 +255,12 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n-            (&PatKind::Binding(ref lb, .., ref li, ref lp), &PatKind::Binding(ref rb, .., ref ri, ref rp)) => {\n-                lb == rb && li.name == ri.name && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(lb, li, _, ref lp), &PatKind::Binding(rb, ri, _, ref rp)) => {\n+                let eq = lb == rb && both(lp, rp, |l, r| self.eq_pat(l, r));\n+                if eq {\n+                    self.locals.insert(li, ri);\n+                }\n+                eq\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -251,8 +296,11 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n-        left.is_global() == right.is_global()\n-            && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        match (left.res, right.res) {\n+            (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n+            (Res::Local(_), _) | (_, Res::Local(_)) => false,\n+            _ => over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r)),\n+        }\n     }\n \n     fn eq_path_parameters(&mut self, left: &GenericArgs<'_>, right: &GenericArgs<'_>) -> bool {\n@@ -279,28 +327,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.ident.name == right.ident.name && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n-    pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n+    fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         self.eq_ty_kind(&left.kind, &right.kind)\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+    fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let old_maybe_typeck_results = self.maybe_typeck_results;\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n-\n-                let eq_ty = self.eq_ty(lt, rt);\n-                self.maybe_typeck_results = old_maybe_typeck_results;\n-                eq_ty && ll == rl\n+                let cx = self.inner.cx;\n+                let eval_const =\n+                    |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n+                self.eq_ty(lt, rt) && eval_const(ll_id.body) == eval_const(rl_id.body)\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n@@ -667,10 +706,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n-    pub fn hash_path(&mut self, p: &Path<'_>) {\n-        p.is_global().hash(&mut self.s);\n-        for p in p.segments {\n-            self.hash_name(p.ident.name);\n+    pub fn hash_path(&mut self, path: &Path<'_>) {\n+        match path.res {\n+            // constant hash since equality is dependant on inter-expression context\n+            Res::Local(_) => 1_usize.hash(&mut self.s),\n+            _ => {\n+                for seg in path.segments {\n+                    self.hash_name(seg.ident.name);\n+                }\n+            },\n         }\n     }\n ", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs"}, {"sha": "94b7339c7eb6f28fdbe27d891643651e71b85258", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "added", "additions": 1883, "deletions": 0, "changes": 1883, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,1883 @@\n+#![feature(box_patterns)]\n+#![feature(in_band_lifetimes)]\n+#![feature(or_patterns)]\n+#![feature(rustc_private)]\n+#![recursion_limit = \"512\"]\n+#![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n+\n+// FIXME: switch to something more ergonomic here, once available.\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_ast;\n+extern crate rustc_ast_pretty;\n+extern crate rustc_data_structures;\n+extern crate rustc_errors;\n+extern crate rustc_hir;\n+extern crate rustc_infer;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_mir;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_target;\n+extern crate rustc_trait_selection;\n+extern crate rustc_typeck;\n+\n+#[macro_use]\n+pub mod sym_helper;\n+\n+#[allow(clippy::module_name_repetitions)]\n+pub mod ast_utils;\n+pub mod attrs;\n+pub mod camel_case;\n+pub mod comparisons;\n+pub mod consts;\n+mod diagnostics;\n+pub mod eager_or_lazy;\n+pub mod higher;\n+mod hir_utils;\n+pub mod numeric_literal;\n+pub mod paths;\n+pub mod ptr;\n+pub mod qualify_min_const_fn;\n+pub mod sugg;\n+pub mod usage;\n+pub mod visitors;\n+\n+pub use self::attrs::*;\n+pub use self::diagnostics::*;\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n+\n+use std::borrow::Cow;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind, Mutability};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::Node;\n+use rustc_hir::{\n+    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n+    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::{LateContext, Level, Lint, LintContext};\n+use rustc_middle::hir::exports::Export;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_semver::RustcVersion;\n+use rustc_session::Session;\n+use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::source_map::original_sp;\n+use rustc_span::sym;\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n+use rustc_target::abi::Integer;\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use smallvec::SmallVec;\n+\n+use crate::consts::{constant, Constant};\n+\n+pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n+    if let Ok(version) = RustcVersion::parse(msrv) {\n+        return Some(version);\n+    } else if let Some(sess) = sess {\n+        if let Some(span) = span {\n+            sess.span_err(span, &format!(\"`{}` is not a valid Rust version\", msrv));\n+        }\n+    }\n+    None\n+}\n+\n+pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool {\n+    msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n+}\n+\n+#[macro_export]\n+macro_rules! extract_msrv_attr {\n+    (LateContext) => {\n+        extract_msrv_attr!(@LateContext, ());\n+    };\n+    (EarlyContext) => {\n+        extract_msrv_attr!(@EarlyContext);\n+    };\n+    (@$context:ident$(, $call:tt)?) => {\n+        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n+            use $crate::get_unique_inner_attr;\n+            match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n+                Some(msrv_attr) => {\n+                    if let Some(msrv) = msrv_attr.value_str() {\n+                        self.msrv = $crate::parse_msrv(\n+                            &msrv.to_string(),\n+                            Some(cx.sess$($call)?),\n+                            Some(msrv_attr.span),\n+                        );\n+                    } else {\n+                        cx.sess$($call)?.span_err(msrv_attr.span, \"bad clippy attribute\");\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    };\n+}\n+\n+/// Returns `true` if the two spans come from differing expansions (i.e., one is\n+/// from a macro and one isn't).\n+#[must_use]\n+pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n+    rhs.ctxt() != lhs.ctxt()\n+}\n+\n+/// Returns `true` if the given `NodeId` is inside a constant context\n+///\n+/// # Example\n+///\n+/// ```rust,ignore\n+/// if in_constant(cx, expr.hir_id) {\n+///     // Do something\n+/// }\n+/// ```\n+pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(id);\n+    match cx.tcx.hir().get(parent_id) {\n+        Node::Item(&Item {\n+            kind: ItemKind::Const(..) | ItemKind::Static(..),\n+            ..\n+        })\n+        | Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Const(..),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Const(..),\n+            ..\n+        })\n+        | Node::AnonConst(_) => true,\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(ref sig, ..),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(ref sig, _),\n+            ..\n+        }) => sig.header.constness == Constness::Const,\n+        _ => false,\n+    }\n+}\n+\n+/// Returns `true` if this `span` was expanded by any macro.\n+#[must_use]\n+pub fn in_macro(span: Span) -> bool {\n+    if span.from_expansion() {\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n+    } else {\n+        false\n+    }\n+}\n+\n+// If the snippet is empty, it's an attribute that was inserted during macro\n+// expansion and we want to ignore those, because they could come from external\n+// sources that the user has no control over.\n+// For some reason these attributes don't have any expansion info on them, so\n+// we have to check it this way until there is a better way.\n+pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n+    if let Some(snippet) = snippet_opt(cx, span) {\n+        if snippet.is_empty() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+/// Checks if given pattern is a wildcard (`_`)\n+pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n+    matches!(pat.kind, PatKind::Wild)\n+}\n+\n+/// Checks if type is struct, enum or union type with the given def path.\n+///\n+/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n+pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the type is equal to a diagnostic item\n+///\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n+pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the type is equal to a lang item\n+pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the method call given in `expr` belongs to the given trait.\n+pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n+    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n+    let trt_id = cx.tcx.trait_of_item(def_id);\n+    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n+}\n+\n+/// Checks if an expression references a variable of the given name.\n+pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+        if let [p] = path.segments {\n+            return p.ident.name == var;\n+        }\n+    }\n+    false\n+}\n+\n+pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n+    }\n+}\n+\n+pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments.get(0),\n+        QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::LangItem(..) => None,\n+    }\n+}\n+\n+/// Matches a `QPath` against a slice of segment string literals.\n+///\n+/// There is also `match_path` if you are dealing with a `rustc_hir::Path` instead of a\n+/// `rustc_hir::QPath`.\n+///\n+/// # Examples\n+/// ```rust,ignore\n+/// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n+pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n+    match *path {\n+        QPath::Resolved(_, ref path) => match_path(path, segments),\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+            TyKind::Path(ref inner_path) => {\n+                if let [prefix @ .., end] = segments {\n+                    if match_qpath(inner_path, prefix) {\n+                        return segment.ident.name.as_str() == *end;\n+                    }\n+                }\n+                false\n+            },\n+            _ => false,\n+        },\n+        QPath::LangItem(..) => false,\n+    }\n+}\n+\n+/// Matches a `Path` against a slice of segment string literals.\n+///\n+/// There is also `match_qpath` if you are dealing with a `rustc_hir::QPath` instead of a\n+/// `rustc_hir::Path`.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// if match_path(&trait_ref.path, &paths::HASH) {\n+///     // This is the `std::hash::Hash` trait.\n+/// }\n+///\n+/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n+///     // This is a `rustc_middle::lint::Lint`.\n+/// }\n+/// ```\n+pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n+}\n+\n+/// Matches a `Path` against a slice of segment string literals, e.g.\n+///\n+/// # Examples\n+/// ```rust,ignore\n+/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n+pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n+}\n+\n+/// If the expression is a path to a local, returns the canonical `HirId` of the local.\n+pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+        if let Res::Local(id) = path.res {\n+            return Some(id);\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns true if the expression is a path to a local with the specified `HirId`.\n+/// Use this function to see if an expression matches a function argument or a match binding.\n+pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n+    path_to_local(expr) == Some(id)\n+}\n+\n+/// Gets the definition associated to a path.\n+#[allow(clippy::shadow_unrelated)] // false positive #6563\n+pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n+    macro_rules! try_res {\n+        ($e:expr) => {\n+            match $e {\n+                Some(e) => e,\n+                None => return Res::Err,\n+            }\n+        };\n+    }\n+    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n+        tcx.item_children(def_id)\n+            .iter()\n+            .find(|item| item.ident.name.as_str() == name)\n+    }\n+\n+    let (krate, first, path) = match *path {\n+        [krate, first, ref path @ ..] => (krate, first, path),\n+        _ => return Res::Err,\n+    };\n+    let tcx = cx.tcx;\n+    let crates = tcx.crates();\n+    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n+    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n+    let last = path\n+        .iter()\n+        .copied()\n+        // `get_def_path` seems to generate these empty segments for extern blocks.\n+        // We can just ignore them.\n+        .filter(|segment| !segment.is_empty())\n+        // for each segment, find the child item\n+        .try_fold(first, |item, segment| {\n+            let def_id = item.res.def_id();\n+            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n+                Some(item)\n+            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n+                // it is not a child item so check inherent impl items\n+                tcx.inherent_impls(def_id)\n+                    .iter()\n+                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n+            } else {\n+                None\n+            }\n+        });\n+    try_res!(last).res\n+}\n+\n+/// Convenience function to get the `DefId` of a trait by path.\n+/// It could be a trait or trait alias.\n+pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n+    match path_to_res(cx, path) {\n+        Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n+        _ => None,\n+    }\n+}\n+\n+/// Checks whether a type implements a trait.\n+/// See also `get_trait_def_id`.\n+pub fn implements_trait<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_id: DefId,\n+    ty_params: &[GenericArg<'tcx>],\n+) -> bool {\n+    // Do not check on infer_types to avoid panic in evaluate_obligation.\n+    if ty.has_infer_types() {\n+        return false;\n+    }\n+    let ty = cx.tcx.erase_regions(ty);\n+    if ty.has_escaping_bound_vars() {\n+        return false;\n+    }\n+    let ty_params = cx.tcx.mk_substs(ty_params.iter());\n+    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+}\n+\n+/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n+///\n+/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n+///\n+/// ```rust\n+/// struct Point(isize, isize);\n+///\n+/// impl std::ops::Add for Point {\n+///     type Output = Self;\n+///\n+///     fn add(self, other: Self) -> Self {\n+///         Point(0, 0)\n+///     }\n+/// }\n+/// ```\n+pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n+    // Get the implemented trait for the current function\n+    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n+    if_chain! {\n+        if parent_impl != hir::CRATE_HIR_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n+        if let hir::ItemKind::Impl(impl_) = &item.kind;\n+        then { return impl_.of_trait.as_ref(); }\n+    }\n+    None\n+}\n+\n+/// Checks whether this type implements `Drop`.\n+pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.ty_adt_def() {\n+        Some(def) => def.has_dtor(cx.tcx),\n+        None => false,\n+    }\n+}\n+\n+/// Returns the method names and argument list of nested method call expressions that make up\n+/// `expr`. method/span lists are sorted with the most recent call first.\n+pub fn method_calls<'tcx>(\n+    expr: &'tcx Expr<'tcx>,\n+    max_depth: usize,\n+) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+    let mut method_names = Vec::with_capacity(max_depth);\n+    let mut arg_lists = Vec::with_capacity(max_depth);\n+    let mut spans = Vec::with_capacity(max_depth);\n+\n+    let mut current = expr;\n+    for _ in 0..max_depth {\n+        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n+            if args.iter().any(|e| e.span.from_expansion()) {\n+                break;\n+            }\n+            method_names.push(path.ident.name);\n+            arg_lists.push(&**args);\n+            spans.push(*span);\n+            current = &args[0];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    (method_names, arg_lists, spans)\n+}\n+\n+/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n+///\n+/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n+/// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n+/// containing the `Expr`s for\n+/// `.bar()` and `.baz()`\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n+    let mut current = expr;\n+    let mut matched = Vec::with_capacity(methods.len());\n+    for method_name in methods.iter().rev() {\n+        // method chains are stored last -> first\n+        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n+            if path.ident.name.as_str() == *method_name {\n+                if args.iter().any(|e| e.span.from_expansion()) {\n+                    return None;\n+                }\n+                matched.push(&**args); // build up `matched` backwards\n+                current = &args[0] // go to parent expression\n+            } else {\n+                return None;\n+            }\n+        } else {\n+            return None;\n+        }\n+    }\n+    // Reverse `matched` so that it is in the same order as `methods`.\n+    matched.reverse();\n+    Some(matched)\n+}\n+\n+/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n+pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    cx.tcx\n+        .entry_fn(LOCAL_CRATE)\n+        .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n+}\n+\n+/// Returns `true` if the expression is in the program's `#[panic_handler]`.\n+pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n+    Some(def_id) == cx.tcx.lang_items().panic_impl()\n+}\n+\n+/// Gets the name of the item the expression is in, if available.\n+pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n+    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    match cx.tcx.hir().find(parent_id) {\n+        Some(\n+            Node::Item(Item { ident, .. })\n+            | Node::TraitItem(TraitItem { ident, .. })\n+            | Node::ImplItem(ImplItem { ident, .. }),\n+        ) => Some(ident.name),\n+        _ => None,\n+    }\n+}\n+\n+/// Gets the name of a `Pat`, if any.\n+pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n+    match pat.kind {\n+        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None,\n+    }\n+}\n+\n+struct ContainsName {\n+    name: Symbol,\n+    result: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ContainsName {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_name(&mut self, _: Span, name: Symbol) {\n+        if self.name == name {\n+            self.result = true;\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Checks if an `Expr` contains a certain name.\n+pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n+    let mut cn = ContainsName { name, result: false };\n+    cn.visit_expr(expr);\n+    cn.result\n+}\n+\n+/// Returns `true` if `expr` contains a return expression\n+pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n+    struct RetCallFinder {\n+        found: bool,\n+    }\n+\n+    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+            if self.found {\n+                return;\n+            }\n+            if let hir::ExprKind::Ret(..) = &expr.kind {\n+                self.found = true;\n+            } else {\n+                hir::intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+            hir::intravisit::NestedVisitorMap::None\n+        }\n+    }\n+\n+    let mut visitor = RetCallFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+struct FindMacroCalls<'a, 'b> {\n+    names: &'a [&'b str],\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            self.result.push(expr.span);\n+        }\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Finds calls of the specified macros in a function body.\n+pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n+    let mut fmc = FindMacroCalls {\n+        names,\n+        result: Vec::new(),\n+    };\n+    fmc.visit_expr(&body.value);\n+    fmc.result\n+}\n+\n+/// Converts a span to a code snippet if available, otherwise use default.\n+///\n+/// This is useful if you want to provide suggestions for your lint or more generally, if you want\n+/// to convert a given `Span` to a `str`.\n+///\n+/// # Example\n+/// ```rust,ignore\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n+pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n+}\n+\n+/// Same as `snippet`, but it adapts the applicability level by following rules:\n+///\n+/// - Applicability level `Unspecified` will never be changed.\n+/// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n+/// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n+/// `HasPlaceholders`\n+pub fn snippet_with_applicability<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    if *applicability != Applicability::Unspecified && span.from_expansion() {\n+        *applicability = Applicability::MaybeIncorrect;\n+    }\n+    snippet_opt(cx, span).map_or_else(\n+        || {\n+            if *applicability == Applicability::MachineApplicable {\n+                *applicability = Applicability::HasPlaceholders;\n+            }\n+            Cow::Borrowed(default)\n+        },\n+        From::from,\n+    )\n+}\n+\n+/// Same as `snippet`, but should only be used when it's clear that the input span is\n+/// not a macro argument.\n+pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+    snippet(cx, span.source_callsite(), default)\n+}\n+\n+/// Converts a span to a code snippet. Returns `None` if not available.\n+pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+    cx.sess().source_map().span_to_snippet(span).ok()\n+}\n+\n+/// Converts a span (from a block) to a code snippet if available, otherwise use default.\n+///\n+/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n+/// things which need to be printed as such.\n+///\n+/// The `indent_relative_to` arg can be used, to provide a span, where the indentation of the\n+/// resulting snippet of the given span.\n+///\n+/// # Example\n+///\n+/// ```rust,ignore\n+/// snippet_block(cx, block.span, \"..\", None)\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///     y;\n+/// }\n+/// ```\n+///\n+/// ```rust,ignore\n+/// snippet_block(cx, block.span, \"..\", Some(if_expr.span))\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///         y;\n+///     } // aligned with `if`\n+/// ```\n+/// Note that the first line of the snippet always has 0 indentation.\n+pub fn snippet_block<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n+    let snip = snippet(cx, span, default);\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    reindent_multiline(snip, true, indent)\n+}\n+\n+/// Same as `snippet_block`, but adapts the applicability level by the rules of\n+/// `snippet_with_applicability`.\n+pub fn snippet_block_with_applicability<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let snip = snippet_with_applicability(cx, span, default, applicability);\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    reindent_multiline(snip, true, indent)\n+}\n+\n+/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n+/// line.\n+///\n+/// ```rust,ignore\n+///     let x = ();\n+/// //          ^^\n+/// // will be converted to\n+///     let x = ();\n+/// //  ^^^^^^^^^^\n+/// ```\n+pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n+}\n+\n+fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n+    let line_span = line_span(cx, span);\n+    snippet_opt(cx, line_span).and_then(|snip| {\n+        snip.find(|c: char| !c.is_whitespace())\n+            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n+    })\n+}\n+\n+/// Returns the indentation of the line of a span\n+///\n+/// ```rust,ignore\n+/// let x = ();\n+/// //      ^^ -- will return 0\n+///     let x = ();\n+/// //          ^^ -- will return 4\n+/// ```\n+pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n+    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n+}\n+\n+/// Returns the positon just before rarrow\n+///\n+/// ```rust,ignore\n+/// fn into(self) -> () {}\n+///              ^\n+/// // in case of unformatted code\n+/// fn into2(self)-> () {}\n+///               ^\n+/// fn into3(self)   -> () {}\n+///               ^\n+/// ```\n+pub fn position_before_rarrow(s: &str) -> Option<usize> {\n+    s.rfind(\"->\").map(|rpos| {\n+        let mut rpos = rpos;\n+        let chars: Vec<char> = s.chars().collect();\n+        while rpos > 1 {\n+            if let Some(c) = chars.get(rpos - 1) {\n+                if c.is_whitespace() {\n+                    rpos -= 1;\n+                    continue;\n+                }\n+            }\n+            break;\n+        }\n+        rpos\n+    })\n+}\n+\n+/// Extends the span to the beginning of the spans line, incl. whitespaces.\n+///\n+/// ```rust,ignore\n+///        let x = ();\n+/// //             ^^\n+/// // will be converted to\n+///        let x = ();\n+/// // ^^^^^^^^^^^^^^\n+/// ```\n+fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    let span = original_sp(span, DUMMY_SP);\n+    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n+    let line_no = source_map_and_line.line;\n+    let line_start = source_map_and_line.sf.lines[line_no];\n+    Span::new(line_start, span.hi(), span.ctxt())\n+}\n+\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n+/// Also takes an `Option<String>` which can be put inside the braces.\n+pub fn expr_block<'a, T: LintContext>(\n+    cx: &T,\n+    expr: &Expr<'_>,\n+    option: Option<String>,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n+    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n+    let string = option.unwrap_or_default();\n+    if expr.span.from_expansion() {\n+        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n+    } else if let ExprKind::Block(_, _) = expr.kind {\n+        Cow::Owned(format!(\"{}{}\", code, string))\n+    } else if string.is_empty() {\n+        Cow::Owned(format!(\"{{ {} }}\", code))\n+    } else {\n+        Cow::Owned(format!(\"{{\\n{};\\n{}\\n}}\", code, string))\n+    }\n+}\n+\n+/// Reindent a multiline string with possibility of ignoring the first line.\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n+    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n+    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n+}\n+\n+fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n+    let x = s\n+        .lines()\n+        .skip(ignore_first as usize)\n+        .filter_map(|l| {\n+            if l.is_empty() {\n+                None\n+            } else {\n+                // ignore empty lines\n+                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n+            }\n+        })\n+        .min()\n+        .unwrap_or(0);\n+    let indent = indent.unwrap_or(0);\n+    s.lines()\n+        .enumerate()\n+        .map(|(i, l)| {\n+            if (ignore_first && i == 0) || l.is_empty() {\n+                l.to_owned()\n+            } else if x > indent {\n+                l.split_at(x - indent).1.to_owned()\n+            } else {\n+                \" \".repeat(indent - x) + l\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\")\n+}\n+\n+/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n+pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    let map = &cx.tcx.hir();\n+    let hir_id = e.hir_id;\n+    let parent_id = map.get_parent_node(hir_id);\n+    if hir_id == parent_id {\n+        return None;\n+    }\n+    map.find(parent_id).and_then(|node| {\n+        if let Node::Expr(parent) = node {\n+            Some(parent)\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n+    let map = &cx.tcx.hir();\n+    let enclosing_node = map\n+        .get_enclosing_scope(hir_id)\n+        .and_then(|enclosing_id| map.find(enclosing_id));\n+    enclosing_node.and_then(|node| match node {\n+        Node::Block(block) => Some(block),\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(_, _, eid),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(_, eid),\n+            ..\n+        }) => match cx.tcx.hir().body(eid).value.kind {\n+            ExprKind::Block(ref block, _) => Some(block),\n+            _ => None,\n+        },\n+        _ => None,\n+    })\n+}\n+\n+/// Returns the base type for HIR references and pointers.\n+pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n+    match ty.kind {\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        _ => ty,\n+    }\n+}\n+\n+/// Returns the base type for references and raw pointers, and count reference\n+/// depth.\n+pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n+        match ty.kind() {\n+            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n+            _ => (ty, depth),\n+        }\n+    }\n+    inner(ty, 0)\n+}\n+\n+/// Checks whether the given expression is a constant integer of the given value.\n+/// unlike `is_integer_literal`, this version does const folding\n+pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n+    if is_integer_literal(e, value) {\n+        return true;\n+    }\n+    let map = cx.tcx.hir();\n+    let parent_item = map.get_parent_item(e.hir_id);\n+    if let Some((Constant::Int(v), _)) = map\n+        .maybe_body_owned_by(parent_item)\n+        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n+    {\n+        value == v\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks whether the given expression is a constant literal of the given value.\n+pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n+    // FIXME: use constant folding\n+    if let ExprKind::Lit(ref spanned) = expr.kind {\n+        if let LitKind::Int(v, _) = spanned.node {\n+            return v == value;\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns `true` if the given `Expr` has been coerced before.\n+///\n+/// Examples of coercions can be found in the Nomicon at\n+/// <https://doc.rust-lang.org/nomicon/coercions.html>.\n+///\n+/// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n+/// information on adjustments and coercions.\n+pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n+}\n+\n+/// Returns the pre-expansion span if is this comes from an expansion of the\n+/// macro `name`.\n+/// See also `is_direct_expn_of`.\n+#[must_use]\n+pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n+    loop {\n+        if span.from_expansion() {\n+            let data = span.ctxt().outer_expn_data();\n+            let new_span = data.call_site;\n+\n+            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+                if mac_name.as_str() == name {\n+                    return Some(new_span);\n+                }\n+            }\n+\n+            span = new_span;\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+/// Returns the pre-expansion span if the span directly comes from an expansion\n+/// of the macro `name`.\n+/// The difference with `is_expn_of` is that in\n+/// ```rust,ignore\n+/// foo!(bar!(42));\n+/// ```\n+/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n+/// `bar!` by\n+/// `is_direct_expn_of`.\n+#[must_use]\n+pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n+    if span.from_expansion() {\n+        let data = span.ctxt().outer_expn_data();\n+        let new_span = data.call_site;\n+\n+        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+            if mac_name.as_str() == name {\n+                return Some(new_span);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Convenience function to get the return type of a function.\n+pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n+    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+    let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n+    cx.tcx.erase_late_bound_regions(ret_ty)\n+}\n+\n+/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n+pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n+/// Returns `true` if the given type is an `unsafe` function.\n+pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+}\n+\n+/// Checks if an expression is constructing a tuple-like enum variant or struct\n+pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Call(ref fun, _) = expr.kind {\n+        if let ExprKind::Path(ref qp) = fun.kind {\n+            let res = cx.qpath_res(qp, fun.hir_id);\n+            return match res {\n+                def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n+                def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n+                _ => false,\n+            };\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns `true` if a pattern is refutable.\n+// TODO: should be implemented using rustc/mir_build/thir machinery\n+pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_>, qpath: &QPath<'_>, id: HirId) -> bool {\n+        matches!(\n+            cx.qpath_res(qpath, id),\n+            def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n+        )\n+    }\n+\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_>, mut i: I) -> bool {\n+        i.any(|pat| is_refutable(cx, pat))\n+    }\n+\n+    match pat.kind {\n+        PatKind::Wild => false,\n+        PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n+        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) | PatKind::Range(..) => true,\n+        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n+        PatKind::Or(ref pats) => {\n+            // TODO: should be the honest check, that pats is exhaustive set\n+            are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        },\n+        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n+        },\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        },\n+        PatKind::Slice(ref head, ref middle, ref tail) => {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n+                ty::Slice(..) => {\n+                    // [..] is the only irrefutable slice pattern.\n+                    !head.is_empty() || middle.is_none() || !tail.is_empty()\n+                },\n+                ty::Array(..) => are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat)),\n+                _ => {\n+                    // unreachable!()\n+                    true\n+                },\n+            }\n+        },\n+    }\n+}\n+\n+/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n+/// implementations have.\n+pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n+}\n+\n+/// Remove blocks around an expression.\n+///\n+/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n+/// themselves.\n+pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    while let ExprKind::Block(ref block, ..) = expr.kind {\n+        match (block.stmts.is_empty(), block.expr.as_ref()) {\n+            (true, Some(e)) => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n+pub fn is_self(slf: &Param<'_>) -> bool {\n+    if let PatKind::Binding(.., name, _) = slf.pat.kind {\n+        name.name == kw::SelfLower\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n+        if let Res::SelfTy(..) = path.res;\n+        then {\n+            return true\n+        }\n+    }\n+    false\n+}\n+\n+pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n+    (0..decl.inputs.len()).map(move |i| &body.params[i])\n+}\n+\n+/// Checks if a given expression is a match expression expanded from the `?`\n+/// operator or the `try` macro.\n+pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_ok(arm: &Arm<'_>) -> bool {\n+        if_chain! {\n+            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n+            if match_qpath(path, &paths::RESULT_OK[1..]);\n+            if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n+            if path_to_local_id(arm.body, hir_id);\n+            then {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    fn is_err(arm: &Arm<'_>) -> bool {\n+        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n+            match_qpath(path, &paths::RESULT_ERR[1..])\n+        } else {\n+            false\n+        }\n+    }\n+\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n+        // desugared from a `?` operator\n+        if let MatchSource::TryDesugar = *source {\n+            return Some(expr);\n+        }\n+\n+        if_chain! {\n+            if arms.len() == 2;\n+            if arms[0].guard.is_none();\n+            if arms[1].guard.is_none();\n+            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            then {\n+                return Some(expr);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Returns `true` if the lint is allowed in the current context\n+///\n+/// Useful for skipping long running code when it's unnecessary\n+pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n+    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n+}\n+\n+pub fn strip_pat_refs<'hir>(mut pat: &'hir Pat<'hir>) -> &'hir Pat<'hir> {\n+    while let PatKind::Ref(subpat, _) = pat.kind {\n+        pat = subpat;\n+    }\n+    pat\n+}\n+\n+pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {\n+    Integer::from_int_ty(&tcx, ity).size().bits()\n+}\n+\n+#[allow(clippy::cast_possible_wrap)]\n+/// Turn a constant int byte representation into an i128\n+pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ty::IntTy) -> i128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as i128) << amt) >> amt\n+}\n+\n+#[allow(clippy::cast_sign_loss)]\n+/// clip unused bytes\n+pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ty::IntTy) -> u128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as u128) << amt) >> amt\n+}\n+\n+/// clip unused bytes\n+pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ty::UintTy) -> u128 {\n+    let bits = Integer::from_uint_ty(&tcx, ity).size().bits();\n+    let amt = 128 - bits;\n+    (u << amt) >> amt\n+}\n+\n+/// Removes block comments from the given `Vec` of lines.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// without_block_comments(vec![\"/*\", \"foo\", \"*/\"]);\n+/// // => vec![]\n+///\n+/// without_block_comments(vec![\"bar\", \"/*\", \"foo\", \"*/\"]);\n+/// // => vec![\"bar\"]\n+/// ```\n+pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n+    let mut without = vec![];\n+\n+    let mut nest_level = 0;\n+\n+    for line in lines {\n+        if line.contains(\"/*\") {\n+            nest_level += 1;\n+            continue;\n+        } else if line.contains(\"*/\") {\n+            nest_level -= 1;\n+            continue;\n+        }\n+\n+        if nest_level == 0 {\n+            without.push(line);\n+        }\n+    }\n+\n+    without\n+}\n+\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n+    let map = &tcx.hir();\n+    let mut prev_enclosing_node = None;\n+    let mut enclosing_node = node;\n+    while Some(enclosing_node) != prev_enclosing_node {\n+        if is_automatically_derived(map.attrs(enclosing_node)) {\n+            return true;\n+        }\n+        prev_enclosing_node = Some(enclosing_node);\n+        enclosing_node = map.get_parent_item(enclosing_node);\n+    }\n+    false\n+}\n+\n+/// Returns true if ty has `iter` or `iter_mut` methods\n+pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n+    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n+    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n+    // so we can't use its `lookup_method` method.\n+    let into_iter_collections: [&[&str]; 13] = [\n+        &paths::VEC,\n+        &paths::OPTION,\n+        &paths::RESULT,\n+        &paths::BTREESET,\n+        &paths::BTREEMAP,\n+        &paths::VEC_DEQUE,\n+        &paths::LINKED_LIST,\n+        &paths::BINARY_HEAP,\n+        &paths::HASHSET,\n+        &paths::HASHMAP,\n+        &paths::PATH_BUF,\n+        &paths::PATH,\n+        &paths::RECEIVER,\n+    ];\n+\n+    let ty_to_check = match probably_ref_ty.kind() {\n+        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        _ => probably_ref_ty,\n+    };\n+\n+    let def_id = match ty_to_check.kind() {\n+        ty::Array(..) => return Some(\"array\"),\n+        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Adt(adt, _) => adt.did,\n+        _ => return None,\n+    };\n+\n+    for path in &into_iter_collections {\n+        if match_def_path(cx, def_id, path) {\n+            return Some(*path.last().unwrap());\n+        }\n+    }\n+    None\n+}\n+\n+/// Matches a function call with the given path and returns the arguments.\n+///\n+/// Usage:\n+///\n+/// ```rust,ignore\n+/// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n+/// ```\n+pub fn match_function_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    path: &[&str],\n+) -> Option<&'tcx [Expr<'tcx>]> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, fun_def_id, path);\n+        then {\n+            return Some(&args)\n+        }\n+    };\n+    None\n+}\n+\n+/// Checks if `Ty` is normalizable. This function is useful\n+/// to avoid crashes on `layout_of`.\n+pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        let cause = rustc_middle::traits::ObligationCause::dummy();\n+        infcx.at(&cause, param_env).normalize(ty).is_ok()\n+    })\n+}\n+\n+pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n+    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n+    // accepts only that. We should probably move to Symbols in Clippy as well.\n+    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n+    cx.match_def_path(did, &syms)\n+}\n+\n+pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n+    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n+        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n+}\n+\n+pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n+    match_def_path(cx, did, &paths::BEGIN_PANIC)\n+        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANIC_ANY)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n+}\n+\n+/// Returns the list of condition expressions and the list of blocks in a\n+/// sequence of `if/else`.\n+/// E.g., this returns `([a, b], [c, d, e])` for the expression\n+/// `if a { c } else if b { d } else { e }`.\n+pub fn if_sequence<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> (SmallVec<[&'tcx Expr<'tcx>; 1]>, SmallVec<[&'tcx Block<'tcx>; 1]>) {\n+    let mut conds = SmallVec::new();\n+    let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n+\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n+        conds.push(&**cond);\n+        if let ExprKind::Block(ref block, _) = then_expr.kind {\n+            blocks.push(block);\n+        } else {\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n+        }\n+\n+        if let Some(ref else_expr) = *else_expr {\n+            expr = else_expr;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // final `else {..}`\n+    if !blocks.is_empty() {\n+        if let ExprKind::Block(ref block, _) = expr.kind {\n+            blocks.push(&**block);\n+        }\n+    }\n+\n+    (conds, blocks)\n+}\n+\n+pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    let parent_id = map.get_parent_node(expr.hir_id);\n+    let parent_node = map.get(parent_id);\n+    matches!(\n+        parent_node,\n+        Node::Expr(Expr {\n+            kind: ExprKind::If(_, _, _),\n+            ..\n+        })\n+    )\n+}\n+\n+// Finds the attribute with the given name, if any\n+pub fn attr_by_name<'a>(attrs: &'a [Attribute], name: &'_ str) -> Option<&'a Attribute> {\n+    attrs\n+        .iter()\n+        .find(|attr| attr.ident().map_or(false, |ident| ident.as_str() == name))\n+}\n+\n+// Finds the `#[must_use]` attribute, if any\n+pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n+    attr_by_name(attrs, \"must_use\")\n+}\n+\n+// Returns whether the type has #[must_use] attribute\n+pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n+        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Slice(ref ty)\n+        | ty::Array(ref ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n+        | ty::Ref(_, ref ty, _) => {\n+            // for the Array case we don't need to care for the len == 0 case\n+            // because we don't want to lint functions returning empty arrays\n+            is_must_use_ty(cx, *ty)\n+        },\n+        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Opaque(ref def_id, _) => {\n+            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        ty::Dynamic(binder, _) => {\n+            for predicate in binder.iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+// check if expr is calling method or function with #[must_use] attribute\n+pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let did = match expr.kind {\n+        ExprKind::Call(ref path, _) => if_chain! {\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n+            then {\n+                Some(did)\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n+        _ => None,\n+    };\n+\n+    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n+}\n+\n+pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n+    krate.item.attrs.iter().any(|attr| {\n+        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n+            attr.path == sym::no_std\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+/// Check if parent of a hir node is a trait implementation block.\n+/// For example, `f` in\n+/// ```rust,ignore\n+/// impl Trait for S {\n+///     fn f() {}\n+/// }\n+/// ```\n+pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+        matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Check if it's even possible to satisfy the `where` clause for the item.\n+///\n+/// `trivial_bounds` feature allows functions with unsatisfiable bounds, for example:\n+///\n+/// ```ignore\n+/// fn foo() where i32: Iterator {\n+///     for _ in 2i32 {}\n+/// }\n+/// ```\n+pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n+    use rustc_trait_selection::traits;\n+    let predicates =\n+        cx.tcx\n+            .predicates_of(did)\n+            .predicates\n+            .iter()\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+    traits::impossible_predicates(\n+        cx.tcx,\n+        traits::elaborate_predicates(cx.tcx, predicates)\n+            .map(|o| o.predicate)\n+            .collect::<Vec<_>>(),\n+    )\n+}\n+\n+/// Returns the `DefId` of the callee if the given expression is a function or method call.\n+pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n+    match &expr.kind {\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(qpath),\n+                hir_id: path_hir_id,\n+                ..\n+            },\n+            ..,\n+        ) => cx.typeck_results().qpath_res(qpath, *path_hir_id).opt_def_id(),\n+        _ => None,\n+    }\n+}\n+\n+pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n+    lints.iter().any(|lint| {\n+        matches!(\n+            cx.tcx.lint_level_at_node(lint, id),\n+            (Level::Forbid | Level::Deny | Level::Warn, _)\n+        )\n+    })\n+}\n+\n+/// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n+/// number type, a str, or an array, slice, or tuple of those types).\n+pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n+/// slice iff the given expression is a slice of primitives (as defined in the\n+/// `is_recursively_primitive_type` function) and None otherwise.\n+pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n+    let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n+    let expr_kind = expr_type.kind();\n+    let is_primitive = match expr_kind {\n+        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n+            if let ty::Slice(element_type) = inner_ty.kind() {\n+                is_recursively_primitive_type(element_type)\n+            } else {\n+                unreachable!()\n+            }\n+        },\n+        _ => false,\n+    };\n+\n+    if is_primitive {\n+        // if we have wrappers like Array, Slice or Tuple, print these\n+        // and get the type enclosed in the slice ref\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n+            ty::Slice(..) => return Some(\"slice\".into()),\n+            ty::Array(..) => return Some(\"array\".into()),\n+            ty::Tuple(..) => return Some(\"tuple\".into()),\n+            _ => {\n+                // is_recursively_primitive_type() should have taken care\n+                // of the rest and we can rely on the type that is found\n+                let refs_peeled = expr_type.peel_refs();\n+                return Some(refs_peeled.walk().last().unwrap().to_string());\n+            },\n+        }\n+    }\n+    None\n+}\n+\n+/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n+/// `hash` must be comformed with `eq`\n+pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        return vec![(&exprs[0], &exprs[1])];\n+    }\n+\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    match_expr_list\n+}\n+\n+/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n+/// references removed.\n+pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+        if let PatKind::Ref(pat, _) = pat.kind {\n+            peel(pat, count + 1)\n+        } else {\n+            (pat, count)\n+        }\n+    }\n+    peel(pat, 0)\n+}\n+\n+/// Peels off up to the given number of references on the expression. Returns the underlying\n+/// expression and the number of references removed.\n+pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0, count)\n+}\n+\n+/// Peels off all references on the expression. Returns the underlying expression and the number of\n+/// references removed.\n+pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0)\n+}\n+\n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n+    }\n+    peel(ty, 0)\n+}\n+\n+/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// removed, and whether the pointer is ultimately mutable or not.\n+pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n+    fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n+        match ty.kind() {\n+            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            _ => (ty, count, mutability),\n+        }\n+    }\n+    f(ty, 0, Mutability::Mut)\n+}\n+\n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ($cx: ident, $lint: ident, $deps: expr) => {{\n+        let mut command = cargo_metadata::MetadataCommand::new();\n+        if !$deps {\n+            command.no_deps();\n+        }\n+\n+        match command.exec() {\n+            Ok(metadata) => metadata,\n+            Err(err) => {\n+                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n+                return;\n+            },\n+        }\n+    }};\n+}\n+\n+pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+        if let Res::Def(_, def_id) = path.res;\n+        then {\n+            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n+pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Check if the resolution of a given path is a `Some` variant of `Option`.\n+pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{reindent_multiline, without_block_comments};\n+\n+    #[test]\n+    fn test_reindent_multiline_single_line() {\n+        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_block() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\", reindent_multiline(\"    if x {\n+            y\n+        } else {\n+            z\n+        }\".into(), false, None));\n+        assert_eq!(\"\\\n+    if x {\n+    \\ty\n+    } else {\n+    \\tz\n+    }\", reindent_multiline(\"    if x {\n+        \\ty\n+        } else {\n+        \\tz\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_empty_line() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+\n+    } else {\n+        z\n+    }\", reindent_multiline(\"    if x {\n+            y\n+\n+        } else {\n+            z\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_lines_deeper() {\n+        assert_eq!(\"\\\n+        if x {\n+            y\n+        } else {\n+            z\n+        }\", reindent_multiline(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\".into(), true, Some(8)));\n+    }\n+\n+    #[test]\n+    fn test_without_block_comments_lines_without_block_comments() {\n+        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n+        println!(\"result: {:?}\", result);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n+        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n+\n+        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n+        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n+    }\n+}"}, {"sha": "d02603d7702c7f3c6a8f7f48d30b29a027ff7e00", "filename": "src/tools/clippy/clippy_utils/src/numeric_literal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/numeric_literal.rs"}, {"sha": "e61786796475347d6442341b403a42a83cfdac77", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs"}, {"sha": "baeff08e02cd8f6738678b71e2cdf1d039f772ef", "filename": "src/tools/clippy/clippy_utils/src/ptr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_pat_name, match_var, snippet};\n+use crate::{get_pat_name, match_var, snippet};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n use rustc_lint::LateContext;", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/ptr.rs"}, {"sha": "a482017afeb136339277386cd0f78be46d91c3cf", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/qualify_min_const_fn.rs"}, {"sha": "d4f6f4281d368ef32bef21978057a9b5a21cdb87", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,7 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs"}, {"sha": "f47dc80ebade8222716a721293eb00b50e80aa52", "filename": "src/tools/clippy/clippy_utils/src/sym_helper.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsym_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsym_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsym_helper.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/sym_helper.rs"}, {"sha": "d577827dcf3ccc0aea320ef53630127b01e44010", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils;\n+use crate as utils;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs"}, {"sha": "5a8c629e3338c41683de26a237968a33bb1cda8b", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::path_to_local_id;\n+use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Arm, Body, Expr, HirId, Stmt};", "previous_filename": "src/tools/clippy/clippy_lints/src/utils/visitors.rs"}, {"sha": "f62c2d29c707e3e45eb143bdc0fc4895021eebf0", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -108,6 +108,9 @@ should only commit files changed by `cargo dev bless` for the\n specific lint you are creating/editing. Note that if the generated files are\n empty, they should be removed.\n \n+Note that you can run multiple test files by specifying a comma separated list:\n+`TESTNAME=foo_functions,test2,test3`.\n+\n ### Cargo lints\n \n For cargo lints, the process of testing differs in that we are interested in\n@@ -289,7 +292,7 @@ the next section. Let's worry about the details later and emit our lint for\n \n Depending on how complex we want our lint message to be, we can choose from a\n variety of lint emission functions. They can all be found in\n-[`clippy_lints/src/utils/diagnostics.rs`][diagnostics].\n+[`clippy_utils/src/diagnostics.rs`][diagnostics].\n \n `span_lint_and_help` seems most appropriate in this case. It allows us to\n provide an extra help message and we can't really suggest a better name\n@@ -318,7 +321,7 @@ When code or an identifier must appear in a message or label, it should be\n surrounded with single grave accents \\`.\n \n [check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n-[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs\n [the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n \n ## Adding the lint logic\n@@ -534,7 +537,7 @@ directory. Adding a configuration to a lint can be useful for thresholds or to c\n behavior that can be seen as a false positive for some users. Adding a configuration is done \n in the following steps:\n \n-1. Adding a new configuration entry to [clippy_lints::utils::conf](/clippy_lints/src/utils/conf.rs)\n+1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n     like this:\n     ```rust\n     /// Lint: LINT_NAME. <The configuration field doc comment>\n@@ -633,7 +636,7 @@ documentation currently. This is unfortunate, but in most cases you can probably\n get away with copying things from existing similar lints. If you are stuck,\n don't hesitate to ask on [Zulip] or in the issue/PR.\n \n-[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs\n [if_chain]: https://docs.rs/if_chain/*/if_chain/\n [from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n [in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html"}, {"sha": "abac1227b4ff389cee02b348ddf01ad9a5346b78", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -78,7 +78,7 @@ impl LateLintPass<'_> for MyStructLint {\n There are two ways to do this, depending if the target trait is part of lang items.\n \n ```rust\n-use crate::utils::{implements_trait, match_trait_method, paths};\n+use clippy_utils::{implements_trait, match_trait_method, paths};\n \n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -112,7 +112,7 @@ We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`]\n To check if our type defines a method called `some_method`:\n \n ```rust\n-use crate::utils::{is_type_diagnostic_item, return_ty};\n+use clippy_utils::{is_type_diagnostic_item, return_ty};\n \n impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n \n # Dealing with macros\n \n-There are several helpers in Clippy's utils to deal with macros:\n+There are several helpers in [`clippy_utils`][utils] to deal with macros:\n \n - `in_macro()`: detect if the given span is expanded by a macro\n \n@@ -199,4 +199,5 @@ assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n [pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n-[paths]: ../clippy_lints/src/utils/paths.rs\n+[paths]: ../clippy_utils/src/paths.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs"}, {"sha": "c23dd926f621d1edd78409dde998be0ffbf7df4b", "filename": "src/tools/clippy/lintcheck-logs/lintcheck_crates_logs.txt", "status": "modified", "additions": 36, "deletions": 78, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Flintcheck-logs%2Flintcheck_crates_logs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Flintcheck-logs%2Flintcheck_crates_logs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck-logs%2Flintcheck_crates_logs.txt?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,6 +1,5 @@\n-clippy 0.1.51 (7f5bb7fd0 2021-02-06)\n+clippy 0.1.52 (697f3b6d4 2021-02-22)\n \n-cargo-0.49.0//home/matthias/.rustup/toolchains/nightly-2021-02-03-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:409:34 clippy::match_same_arms \"this `match` has identical arm bodies\"\n cargo-0.49.0/build.rs:1:null clippy::cargo_common_metadata \"package `cargo` is missing `package.categories` metadata\"\n cargo-0.49.0/build.rs:1:null clippy::cargo_common_metadata \"package `cargo` is missing `package.keywords` metadata\"\n cargo-0.49.0/src/bin/cargo/cli.rs:104:34 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -22,6 +21,7 @@ cargo-0.49.0/src/bin/cargo/commands/check.rs:1:5 clippy::wildcard_imports \"usage\n cargo-0.49.0/src/bin/cargo/commands/clean.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n cargo-0.49.0/src/bin/cargo/commands/doc.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n cargo-0.49.0/src/bin/cargo/commands/fetch.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n+cargo-0.49.0/src/bin/cargo/commands/fetch.rs:22:5 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/bin/cargo/commands/fix.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n cargo-0.49.0/src/bin/cargo/commands/generate_lockfile.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n cargo-0.49.0/src/bin/cargo/commands/git_checkout.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n@@ -99,10 +99,10 @@ cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:411:9 clippy::\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:420:69 clippy::doc_markdown \"you should put `mode/target_kind` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:423:19 clippy::doc_markdown \"you should put `CrateTypes` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:424:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:424:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:469:58 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:603:19 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:665:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n+cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:697:12 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:82:31 clippy::doc_markdown \"you should put `FileType` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:83:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:84:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -151,7 +151,6 @@ cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:361:5 clippy::must_use_candi\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:374:43 clippy::doc_markdown \"you should put `RunCustomBuild` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:378:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:383:41 clippy::doc_markdown \"you should put `RunCustomBuild` between ticks in the documentation\"\n-cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:384:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:384:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:391:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/compiler/context/mod.rs:397:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -173,14 +172,13 @@ cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:481:5 clippy::missing_error\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:481:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:48:56 clippy::doc_markdown \"you should put `RunCustomBuild` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:561:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:561:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:567:20 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:576:28 clippy::shadow_unrelated \"`mut value` is being shadowed\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:606:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:688:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:756:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:762:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n-cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:762:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:762:5 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/core/compiler/custom_build.rs:823:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/compiler/fingerprint.rs:1021:51 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/compiler/fingerprint.rs:1656:16 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -236,7 +234,7 @@ cargo-0.49.0/src/cargo/core/compiler/job_queue.rs:93:24 clippy::doc_markdown \"yo\n cargo-0.49.0/src/cargo/core/compiler/links.rs:8:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:1016:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:1094:19 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n-cargo-0.49.0/src/cargo/core/compiler/mod.rs:1131:1 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/core/compiler/mod.rs:1131:1 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:1268:34 clippy::case_sensitive_file_extension_comparisons \"case-sensitive file extension comparison\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:1277:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:179:1 clippy::too_many_lines \"this function has too many lines (162/100)\"\n@@ -245,13 +243,13 @@ cargo-0.49.0/src/cargo/core/compiler/mod.rs:201:25 clippy::single_match_else \"yo\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:267:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:324:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:364:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n-cargo-0.49.0/src/cargo/core/compiler/mod.rs:364:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/core/compiler/mod.rs:364:5 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:392:45 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:415:23 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:464:18 clippy::ptr_arg \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:488:61 clippy::ptr_arg \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:667:15 clippy::similar_names \"binding's name is too similar to existing binding\"\n-cargo-0.49.0/src/cargo/core/compiler/mod.rs:693:1 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/core/compiler/mod.rs:693:1 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:725:42 clippy::match_same_arms \"this `match` has identical arm bodies\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:736:1 clippy::too_many_lines \"this function has too many lines (141/100)\"\n cargo-0.49.0/src/cargo/core/compiler/mod.rs:73:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -290,7 +288,6 @@ cargo-0.49.0/src/cargo/core/compiler/unit_graph.rs:65:1 clippy::missing_errors_d\n cargo-0.49.0/src/cargo/core/compiler/unit_graph.rs:65:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n cargo-0.49.0/src/cargo/core/dependency.rs:157:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/dependency.rs:182:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/dependency.rs:203:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/dependency.rs:203:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:224:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:23:1 clippy::struct_excessive_bools \"more than 3 bools in a struct\"\n@@ -300,13 +297,10 @@ cargo-0.49.0/src/cargo/core/dependency.rs:274:5 clippy::must_use_candidate \"this\n cargo-0.49.0/src/cargo/core/dependency.rs:278:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:287:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:291:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/core/dependency.rs:296:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/dependency.rs:305:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:311:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:319:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/core/dependency.rs:323:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/dependency.rs:337:75 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n-cargo-0.49.0/src/cargo/core/dependency.rs:379:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/dependency.rs:397:56 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/dependency.rs:403:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/dependency.rs:408:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -452,12 +446,10 @@ cargo-0.49.0/src/cargo/core/package.rs:287:1 clippy::module_name_repetitions \"it\n cargo-0.49.0/src/cargo/core/package.rs:385:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/package.rs:421:5 clippy::needless_lifetimes \"explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\"\n cargo-0.49.0/src/cargo/core/package.rs:425:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/package.rs:425:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/package.rs:452:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/package.rs:453:60 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/core/package.rs:459:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/package.rs:473:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/package.rs:552:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/package.rs:587:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/package.rs:588:9 clippy::needless_question_mark \"Question mark operator is useless here\"\n cargo-0.49.0/src/cargo/core/package.rs:682:46 clippy::cast_possible_truncation \"casting `f64` to `u64` may truncate the value\"\n@@ -490,13 +482,12 @@ cargo-0.49.0/src/cargo/core/package_id_spec.rs:51:5 clippy::missing_errors_doc \"\n cargo-0.49.0/src/cargo/core/package_id_spec.rs:51:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/package_id_spec.rs:77:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/package_id_spec.rs:88:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/core/profiles.rs:1004:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/profiles.rs:1004:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/profiles.rs:1014:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/profiles.rs:1018:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/profiles.rs:1028:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/profiles.rs:106:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n-cargo-0.49.0/src/cargo/core/profiles.rs:143:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/core/profiles.rs:143:5 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/core/profiles.rs:286:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/profiles.rs:286:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/profiles.rs:294:40 clippy::if_not_else \"unnecessary boolean `not` operation\"\n@@ -522,9 +513,7 @@ cargo-0.49.0/src/cargo/core/registry.rs:19:5 clippy::missing_errors_doc \"docs fo\n cargo-0.49.0/src/cargo/core/registry.rs:240:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/registry.rs:26:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/registry.rs:344:49 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n-cargo-0.49.0/src/cargo/core/registry.rs:358:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/registry.rs:369:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/core/registry.rs:424:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/registry.rs:424:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/registry.rs:49:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n cargo-0.49.0/src/cargo/core/registry.rs:520:17 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -538,7 +527,6 @@ cargo-0.49.0/src/cargo/core/resolver/context.rs:274:53 clippy::redundant_closure\n cargo-0.49.0/src/cargo/core/resolver/context.rs:42:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n cargo-0.49.0/src/cargo/core/resolver/context.rs:74:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/resolver/encode.rs:156:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/resolver/encode.rs:156:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/resolver/encode.rs:156:5 clippy::too_many_lines \"this function has too many lines (164/100)\"\n cargo-0.49.0/src/cargo/core/resolver/encode.rs:339:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n cargo-0.49.0/src/cargo/core/resolver/encode.rs:438:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n@@ -596,7 +584,6 @@ cargo-0.49.0/src/cargo/core/resolver/resolve.rs:255:5 clippy::must_use_candidate\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:259:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:263:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:269:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/core/resolver/resolve.rs:273:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:273:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:274:9 clippy::map_unwrap_or \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\"\n cargo-0.49.0/src/cargo/core/resolver/resolve.rs:280:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -639,6 +626,7 @@ cargo-0.49.0/src/cargo/core/shell.rs:314:5 clippy::must_use_candidate \"this meth\n cargo-0.49.0/src/cargo/core/shell.rs:322:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/shell.rs:330:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/shell.rs:345:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+cargo-0.49.0/src/cargo/core/shell.rs:459:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/core/shell.rs:98:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/source/mod.rs:103:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/source/mod.rs:247:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n@@ -682,7 +670,6 @@ cargo-0.49.0/src/cargo/core/source/source_id.rs:241:5 clippy::must_use_candidate\n cargo-0.49.0/src/cargo/core/source/source_id.rs:252:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/source/source_id.rs:257:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/source/source_id.rs:262:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/source/source_id.rs:262:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/core/source/source_id.rs:305:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/source/source_id.rs:310:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/core/source/source_id.rs:318:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -780,7 +767,6 @@ cargo-0.49.0/src/cargo/core/workspace.rs:849:5 clippy::missing_panics_doc \"docs\n cargo-0.49.0/src/cargo/core/workspace.rs:893:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/core/workspace.rs:906:24 clippy::redundant_else \"redundant else block\"\n cargo-0.49.0/src/cargo/core/workspace.rs:932:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/core/workspace.rs:932:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/lib.rs:177:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/lib.rs:177:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/lib.rs:180:36 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n@@ -808,7 +794,6 @@ cargo-0.49.0/src/cargo/ops/cargo_compile.rs:249:1 clippy::missing_errors_doc \"do\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:258:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:267:16 clippy::needless_question_mark \"Question mark operator is useless here\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:275:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/ops/cargo_compile.rs:275:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:275:1 clippy::too_many_lines \"this function has too many lines (219/100)\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:468:9 clippy::default_trait_access \"calling `std::collections::HashMap::default()` is more clear than this expression\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:548:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -824,7 +809,6 @@ cargo-0.49.0/src/cargo/ops/cargo_compile.rs:612:21 clippy::doc_markdown \"you sho\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:613:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:618:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:641:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/ops/cargo_compile.rs:652:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:652:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:655:50 clippy::match_same_arms \"this `match` has identical arm bodies\"\n cargo-0.49.0/src/cargo/ops/cargo_compile.rs:673:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -879,6 +863,7 @@ cargo-0.49.0/src/cargo/ops/cargo_package.rs:394:5 clippy::items_after_statements\n cargo-0.49.0/src/cargo/ops/cargo_package.rs:425:61 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/ops/cargo_package.rs:459:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/ops/cargo_package.rs:66:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n+cargo-0.49.0/src/cargo/ops/cargo_package.rs:69:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/ops/cargo_package.rs:93:20 clippy::if_not_else \"unnecessary boolean `not` operation\"\n cargo-0.49.0/src/cargo/ops/cargo_pkgid.rs:5:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/cargo_read_manifest.rs:14:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -893,7 +878,6 @@ cargo-0.49.0/src/cargo/ops/cargo_run.rs:37:16 clippy::redundant_else \"redundant\n cargo-0.49.0/src/cargo/ops/cargo_run.rs:53:9 clippy::if_not_else \"unnecessary boolean `not` operation\"\n cargo-0.49.0/src/cargo/ops/cargo_run.rs:65:16 clippy::redundant_else \"redundant else block\"\n cargo-0.49.0/src/cargo/ops/cargo_run.rs:9:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/ops/cargo_run.rs:9:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/ops/cargo_test.rs:16:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/cargo_test.rs:43:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/cargo_test.rs:84:17 clippy::similar_names \"binding's name is too similar to existing binding\"\n@@ -904,7 +888,7 @@ cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:233:21 clippy::si\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:244:22 clippy::doc_markdown \"you should put `PackageId` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:244:63 clippy::doc_markdown \"you should put `PackageId` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:253:17 clippy::if_not_else \"unnecessary boolean `not` operation\"\n-cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:370:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:370:5 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:505:8 clippy::map_unwrap_or \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling `map_or_else(<g>, <f>)` instead\"\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:525:10 clippy::needless_pass_by_value \"this argument is passed by value, but not consumed in the function body\"\n cargo-0.49.0/src/cargo/ops/common_for_install_and_uninstall.rs:542:27 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n@@ -967,7 +951,6 @@ cargo-0.49.0/src/cargo/ops/registry.rs:794:16 clippy::single_match_else \"you see\n cargo-0.49.0/src/cargo/ops/registry.rs:828:14 clippy::doc_markdown \"you should put `SourceId` between ticks in the documentation\"\n cargo-0.49.0/src/cargo/ops/registry.rs:848:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/resolve.rs:199:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/ops/resolve.rs:199:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/ops/resolve.rs:199:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n cargo-0.49.0/src/cargo/ops/resolve.rs:199:1 clippy::too_many_lines \"this function has too many lines (137/100)\"\n cargo-0.49.0/src/cargo/ops/resolve.rs:241:28 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -997,6 +980,7 @@ cargo-0.49.0/src/cargo/ops/tree/mod.rs:21:1 clippy::struct_excessive_bools \"more\n cargo-0.49.0/src/cargo/ops/tree/mod.rs:360:30 clippy::match_same_arms \"this `match` has identical arm bodies\"\n cargo-0.49.0/src/cargo/ops/tree/mod.rs:58:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/ops/vendor.rs:14:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n+cargo-0.49.0/src/cargo/ops/vendor.rs:215:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/ops/vendor.rs:21:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/ops/vendor.rs:21:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/ops/vendor.rs:314:34 clippy::match_same_arms \"this `match` has identical arm bodies\"\n@@ -1017,7 +1001,6 @@ cargo-0.49.0/src/cargo/sources/directory.rs:14:1 clippy::module_name_repetitions\n cargo-0.49.0/src/cargo/sources/directory.rs:90:56 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/sources/git/source.rs:14:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n cargo-0.49.0/src/cargo/sources/git/source.rs:25:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/sources/git/source.rs:25:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/sources/git/source.rs:49:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/sources/git/source.rs:53:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/git/source.rs:53:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n@@ -1032,7 +1015,6 @@ cargo-0.49.0/src/cargo/sources/git/utils.rs:184:5 clippy::missing_errors_doc \"do\n cargo-0.49.0/src/cargo/sources/git/utils.rs:188:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/git/utils.rs:242:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/git/utils.rs:253:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/sources/git/utils.rs:253:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/sources/git/utils.rs:262:13 clippy::if_not_else \"unnecessary boolean `not` operation\"\n cargo-0.49.0/src/cargo/sources/git/utils.rs:289:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/git/utils.rs:294:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -1062,7 +1044,6 @@ cargo-0.49.0/src/cargo/sources/path.rs:429:5 clippy::missing_errors_doc \"docs fo\n cargo-0.49.0/src/cargo/sources/path.rs:460:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/sources/path.rs:473:43 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/sources/path.rs:482:43 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n-cargo-0.49.0/src/cargo/sources/path.rs:55:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/sources/path.rs:63:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/path.rs:77:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/sources/path.rs:98:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1142,7 +1123,6 @@ cargo-0.49.0/src/cargo/util/config/mod.rs:100:71 clippy::doc_markdown \"you shoul\n cargo-0.49.0/src/cargo/util/config/mod.rs:1049:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1064:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1090:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/util/config/mod.rs:1090:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1166:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1179:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1181:33 clippy::needless_question_mark \"Question mark operator is useless here\"\n@@ -1157,7 +1137,6 @@ cargo-0.49.0/src/cargo/util/config/mod.rs:1225:5 clippy::missing_errors_doc \"doc\n cargo-0.49.0/src/cargo/util/config/mod.rs:1229:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:124:1 clippy::struct_excessive_bools \"more than 3 bools in a struct\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1254:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-cargo-0.49.0/src/cargo/util/config/mod.rs:1263:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1279:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1281:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n cargo-0.49.0/src/cargo/util/config/mod.rs:1323:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n@@ -1224,7 +1203,6 @@ cargo-0.49.0/src/cargo/util/dependency_queue.rs:151:5 clippy::must_use_candidate\n cargo-0.49.0/src/cargo/util/dependency_queue.rs:156:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/dependency_queue.rs:168:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/dependency_queue.rs:46:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/util/dependency_queue.rs:66:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/dependency_queue.rs:91:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/util/diagnostic_server.rs:218:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n cargo-0.49.0/src/cargo/util/diagnostic_server.rs:230:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1238,7 +1216,6 @@ cargo-0.49.0/src/cargo/util/errors.rs:143:5 clippy::must_use_candidate \"this met\n cargo-0.49.0/src/cargo/util/errors.rs:150:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/errors.rs:15:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/errors.rs:237:5 clippy::pub_enum_variant_names \"variant name ends with the enum's name\"\n-cargo-0.49.0/src/cargo/util/errors.rs:245:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/errors.rs:245:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/errors.rs:321:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/errors.rs:328:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -1263,12 +1240,11 @@ cargo-0.49.0/src/cargo/util/flock.rs:335:23 clippy::cast_possible_truncation \"ca\n cargo-0.49.0/src/cargo/util/flock.rs:335:23 clippy::cast_sign_loss \"casting `i64` to `u32` may lose the sign of the value\"\n cargo-0.49.0/src/cargo/util/flock.rs:335:44 clippy::cast_possible_truncation \"casting `i64` to `u32` may truncate the value\"\n cargo-0.49.0/src/cargo/util/flock.rs:379:35 clippy::match_same_arms \"this `match` has identical arm bodies\"\n-cargo-0.49.0/src/cargo/util/flock.rs:37:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/flock.rs:37:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/util/flock.rs:43:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/flock.rs:43:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/flock.rs:52:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/flock.rs:52:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+cargo-0.49.0/src/cargo/util/flock.rs:96:17 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/util/graph.rs:10:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/graph.rs:41:51 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/util/graph.rs:45:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -1331,8 +1307,8 @@ cargo-0.49.0/src/cargo/util/paths.rs:445:1 clippy::missing_errors_doc \"docs for\n cargo-0.49.0/src/cargo/util/paths.rs:459:45 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n cargo-0.49.0/src/cargo/util/paths.rs:469:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/paths.rs:469:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+cargo-0.49.0/src/cargo/util/paths.rs:514:5 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/util/paths.rs:54:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n-cargo-0.49.0/src/cargo/util/paths.rs:61:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n cargo-0.49.0/src/cargo/util/paths.rs:61:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/paths.rs:63:19 clippy::option_if_let_else \"use Option::map_or_else instead of an if let/else\"\n cargo-0.49.0/src/cargo/util/paths.rs:88:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1346,6 +1322,7 @@ cargo-0.49.0/src/cargo/util/process_builder.rs:185:5 clippy::missing_errors_doc\n cargo-0.49.0/src/cargo/util/process_builder.rs:190:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/process_builder.rs:218:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/process_builder.rs:218:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+cargo-0.49.0/src/cargo/util/process_builder.rs:278:22 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n cargo-0.49.0/src/cargo/util/process_builder.rs:307:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n cargo-0.49.0/src/cargo/util/process_builder.rs:343:39 clippy::needless_pass_by_value \"this argument is passed by value, but not consumed in the function body\"\n cargo-0.49.0/src/cargo/util/progress.rs:122:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1386,6 +1363,7 @@ cargo-0.49.0/src/cargo/util/rustc.rs:115:5 clippy::doc_markdown \"you should put\n cargo-0.49.0/src/cargo/util/rustc.rs:162:17 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n cargo-0.49.0/src/cargo/util/rustc.rs:39:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/sha256.rs:10:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n+cargo-0.49.0/src/cargo/util/sha256.rs:16:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n cargo-0.49.0/src/cargo/util/sha256.rs:20:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/sha256.rs:31:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n cargo-0.49.0/src/cargo/util/sha256.rs:40:24 clippy::unseparated_literal_suffix \"integer type suffix should be separated by an underscore\"\n@@ -1451,6 +1429,7 @@ iron-0.6.1/src/iron.rs:133:5 clippy::missing_errors_doc \"docs for function retur\n iron-0.6.1/src/iron.rs:143:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n iron-0.6.1/src/iron.rs:149:13 clippy::redundant_field_names \"redundant field names in struct initialization\"\n iron-0.6.1/src/iron.rs:167:49 clippy::similar_names \"binding's name is too similar to existing binding\"\n+iron-0.6.1/src/iron.rs:196:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n iron-0.6.1/src/iron.rs:80:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n iron-0.6.1/src/iron.rs:85:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n iron-0.6.1/src/iron.rs:90:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -1991,18 +1970,15 @@ log-0.4.11/src/lib.rs:1118:5 clippy::must_use_candidate \"this method could have\n log-0.4.11/src/lib.rs:1177:1 clippy::inline_always \"you have declared `#[inline(always)]` on `max_level`. This is usually a bad idea\"\n log-0.4.11/src/lib.rs:1178:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n log-0.4.11/src/lib.rs:1306:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-log-0.4.11/src/lib.rs:1306:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n log-0.4.11/src/lib.rs:1358:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n log-0.4.11/src/lib.rs:1359:5 clippy::if_not_else \"unnecessary `!=` operation\"\n log-0.4.11/src/lib.rs:1407:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n-log-0.4.11/src/lib.rs:329:27 clippy::derive_hash_xor_eq \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n log-0.4.11/src/lib.rs:356:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n log-0.4.11/src/lib.rs:448:12 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n log-0.4.11/src/lib.rs:500:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n log-0.4.11/src/lib.rs:506:28 clippy::trivially_copy_pass_by_ref \"this argument (8 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n log-0.4.11/src/lib.rs:506:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n log-0.4.11/src/lib.rs:506:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-log-0.4.11/src/lib.rs:520:27 clippy::derive_hash_xor_eq \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n log-0.4.11/src/lib.rs:538:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n log-0.4.11/src/lib.rs:653:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n log-0.4.11/src/lib.rs:661:21 clippy::trivially_copy_pass_by_ref \"this argument (8 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n@@ -2112,7 +2088,6 @@ puffin-02dd4a3/puffin/src/data.rs:137:24 clippy::match_same_arms \"this `match` h\n puffin-02dd4a3/puffin/src/data.rs:177:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n puffin-02dd4a3/puffin/src/data.rs:211:21 clippy::cast_possible_truncation \"casting `u64` to `usize` may truncate the value on targets with 32-bit wide pointers\"\n puffin-02dd4a3/puffin/src/data.rs:24:5 clippy::wildcard_imports \"usage of wildcard import\"\n-puffin-02dd4a3/puffin/src/data.rs:75:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n puffin-02dd4a3/puffin/src/lib.rs:113:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n puffin-02dd4a3/puffin/src/lib.rs:147:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n puffin-02dd4a3/puffin/src/lib.rs:147:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n@@ -2146,7 +2121,6 @@ quote-1.0.7/src/ext.rs:10:1 clippy::module_name_repetitions \"item name ends with\n quote-1.0.7/src/ext.rs:7:5 clippy::doc_markdown \"you should put `TokenStream` between ticks in the documentation\"\n quote-1.0.7/src/ident_fragment.rs:13:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n quote-1.0.7/src/ident_fragment.rs:51:31 clippy::manual_strip \"stripping a prefix manually\"\n-quote-1.0.7/src/runtime.rs:332:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n quote-1.0.7/src/runtime.rs:52:5 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n quote-1.0.7/src/runtime.rs:63:5 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n quote-1.0.7/src/runtime.rs:66:33 clippy::doc_markdown \"you should put `DoesNotHaveIter` between ticks in the documentation\"\n@@ -2183,7 +2157,6 @@ rand-0.7.3/src/distributions/binomial.rs:233:32 clippy::cast_precision_loss \"cas\n rand-0.7.3/src/distributions/binomial.rs:234:27 clippy::cast_precision_loss \"casting `i64` to `f64` causes a loss of precision (`i64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\"\n rand-0.7.3/src/distributions/binomial.rs:251:22 clippy::cast_sign_loss \"casting `i64` to `u64` may lose the sign of the value\"\n rand-0.7.3/src/distributions/binomial.rs:255:9 clippy::if_not_else \"unnecessary `!=` operation\"\n-rand-0.7.3/src/distributions/binomial.rs:35:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/binomial.rs:35:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/binomial.rs:45:17 clippy::cast_precision_loss \"casting `i64` to `f64` causes a loss of precision (`i64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\"\n rand-0.7.3/src/distributions/binomial.rs:46:5 clippy::cast_possible_truncation \"casting `f64` to `i64` may truncate the value\"\n@@ -2194,25 +2167,18 @@ rand-0.7.3/src/distributions/binomial.rs:81:21 clippy::cast_precision_loss \"cast\n rand-0.7.3/src/distributions/binomial.rs:82:32 clippy::cast_possible_truncation \"casting `u64` to `i32` may truncate the value\"\n rand-0.7.3/src/distributions/binomial.rs:88:26 clippy::cast_precision_loss \"casting `u64` to `f64` causes a loss of precision (`u64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\"\n rand-0.7.3/src/distributions/binomial.rs:99:21 clippy::cast_precision_loss \"casting `u64` to `f64` causes a loss of precision (`u64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\"\n-rand-0.7.3/src/distributions/cauchy.rs:33:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/cauchy.rs:33:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/dirichlet.rs:52:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/dirichlet.rs:64:32 clippy::unseparated_literal_suffix \"float type suffix should be separated by an underscore\"\n rand-0.7.3/src/distributions/dirichlet.rs:65:23 clippy::unseparated_literal_suffix \"float type suffix should be separated by an underscore\"\n-rand-0.7.3/src/distributions/exponential.rs:76:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/exponential.rs:76:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/float.rs:73:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n rand-0.7.3/src/distributions/gamma.rs:13:5 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n rand-0.7.3/src/distributions/gamma.rs:14:5 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n-rand-0.7.3/src/distributions/gamma.rs:189:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/gamma.rs:189:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-rand-0.7.3/src/distributions/gamma.rs:230:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/gamma.rs:230:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-rand-0.7.3/src/distributions/gamma.rs:259:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/gamma.rs:259:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-rand-0.7.3/src/distributions/gamma.rs:287:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/gamma.rs:287:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-rand-0.7.3/src/distributions/gamma.rs:90:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/gamma.rs:90:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/integer.rs:23:9 clippy::cast_possible_truncation \"casting `u32` to `u8` may truncate the value\"\n rand-0.7.3/src/distributions/integer.rs:30:9 clippy::cast_possible_truncation \"casting `u32` to `u16` may truncate the value\"\n@@ -2226,7 +2192,6 @@ rand-0.7.3/src/distributions/normal.rs:47:25 clippy::unseparated_literal_suffix\n rand-0.7.3/src/distributions/normal.rs:48:25 clippy::unseparated_literal_suffix \"float type suffix should be separated by an underscore\"\n rand-0.7.3/src/distributions/other.rs:89:9 clippy::cast_possible_wrap \"casting `u32` to `i32` may wrap around the value\"\n rand-0.7.3/src/distributions/pareto.rs:32:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-rand-0.7.3/src/distributions/poisson.rs:35:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/distributions/poisson.rs:35:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand-0.7.3/src/distributions/poisson.rs:87:30 clippy::cast_possible_truncation \"casting `f64` to `u64` may truncate the value\"\n rand-0.7.3/src/distributions/poisson.rs:87:30 clippy::cast_sign_loss \"casting `f64` to `u64` may lose the sign of the value\"\n@@ -2316,6 +2281,7 @@ rand-0.7.3/src/rngs/adapter/reseeding.rs:112:5 clippy::inline_always \"you have d\n rand-0.7.3/src/rngs/adapter/reseeding.rs:117:5 clippy::inline_always \"you have declared `#[inline(always)]` on `next_u64`. This is usually a bad idea\"\n rand-0.7.3/src/rngs/adapter/reseeding.rs:198:13 clippy::cast_possible_wrap \"casting `u64` to `i64` may wrap around the value\"\n rand-0.7.3/src/rngs/adapter/reseeding.rs:231:9 clippy::cast_possible_wrap \"casting `usize` to `isize` may wrap around the value\"\n+rand-0.7.3/src/rngs/adapter/reseeding.rs:249:13 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n rand-0.7.3/src/rngs/adapter/reseeding.rs:27:28 clippy::doc_markdown \"you should put `ChaCha` between ticks in the documentation\"\n rand-0.7.3/src/rngs/adapter/reseeding.rs:79:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n rand-0.7.3/src/rngs/entropy.rs:24:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n@@ -2344,7 +2310,6 @@ rand-0.7.3/src/seq/index.rs:139:13 clippy::enum_glob_use \"usage of wildcard impo\n rand-0.7.3/src/seq/index.rs:159:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n rand-0.7.3/src/seq/index.rs:171:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n rand-0.7.3/src/seq/index.rs:180:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n-rand-0.7.3/src/seq/index.rs:213:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand-0.7.3/src/seq/index.rs:223:18 clippy::cast_possible_truncation \"casting `usize` to `u32` may truncate the value on targets with 64-bit wide pointers\"\n rand-0.7.3/src/seq/index.rs:224:18 clippy::cast_possible_truncation \"casting `usize` to `u32` may truncate the value on targets with 64-bit wide pointers\"\n rand-0.7.3/src/seq/index.rs:233:25 clippy::cast_precision_loss \"casting `u32` to `f32` causes a loss of precision (`u32` is 32 bits wide, but `f32`'s mantissa is only 23 bits wide)\"\n@@ -2369,14 +2334,12 @@ rand-0.7.3/src/seq/mod.rs:45:4 clippy::needless_doctest_main \"needless `fn main`\n rand-0.7.3/src/seq/mod.rs:527:26 clippy::cast_possible_truncation \"casting `usize` to `u32` may truncate the value on targets with 64-bit wide pointers\"\n rand_core-0.6.0/src/block.rs:117:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n rand_core-0.6.0/src/block.rs:153:5 clippy::inline_always \"you have declared `#[inline(always)]` on `index`. This is usually a bad idea\"\n-rand_core-0.6.0/src/block.rs:168:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand_core-0.6.0/src/block.rs:230:5 clippy::inline_always \"you have declared `#[inline(always)]` on `try_fill_bytes`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:240:5 clippy::inline_always \"you have declared `#[inline(always)]` on `from_seed`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:245:5 clippy::inline_always \"you have declared `#[inline(always)]` on `seed_from_u64`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:250:5 clippy::inline_always \"you have declared `#[inline(always)]` on `from_rng`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:280:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n rand_core-0.6.0/src/block.rs:319:5 clippy::inline_always \"you have declared `#[inline(always)]` on `index`. This is usually a bad idea\"\n-rand_core-0.6.0/src/block.rs:335:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand_core-0.6.0/src/block.rs:405:5 clippy::inline_always \"you have declared `#[inline(always)]` on `try_fill_bytes`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:415:5 clippy::inline_always \"you have declared `#[inline(always)]` on `from_seed`. This is usually a bad idea\"\n rand_core-0.6.0/src/block.rs:420:5 clippy::inline_always \"you have declared `#[inline(always)]` on `seed_from_u64`. This is usually a bad idea\"\n@@ -2386,8 +2349,6 @@ rand_core-0.6.0/src/block.rs:68:1 clippy::module_name_repetitions \"item name sta\n rand_core-0.6.0/src/error.rs:106:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand_core-0.6.0/src/error.rs:87:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand_core-0.6.0/src/error.rs:95:74 clippy::cast_possible_wrap \"casting `u32` to `i32` may wrap around the value\"\n-rand_core-0.6.0/src/le.rs:18:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-rand_core-0.6.0/src/le.rs:27:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n rand_core-0.6.0/src/lib.rs:179:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n rand_core-0.6.0/src/lib.rs:301:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n rand_core-0.6.0/src/lib.rs:303:26 clippy::unreadable_literal \"long literal lacking separators\"\n@@ -2433,6 +2394,7 @@ rayon-1.5.0/src/iter/chain.rs:58:17 clippy::shadow_unrelated \"`b` is being shado\n rayon-1.5.0/src/iter/chain.rs:78:14 clippy::shadow_unrelated \"`a` is being shadowed\"\n rayon-1.5.0/src/iter/chain.rs:78:17 clippy::shadow_unrelated \"`b` is being shadowed\"\n rayon-1.5.0/src/iter/chain.rs:97:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n+rayon-1.5.0/src/iter/chunks.rs:29:9 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n rayon-1.5.0/src/iter/chunks.rs:3:5 clippy::wildcard_imports \"usage of wildcard import\"\n rayon-1.5.0/src/iter/chunks.rs:4:5 clippy::wildcard_imports \"usage of wildcard import\"\n rayon-1.5.0/src/iter/chunks.rs:77:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n@@ -2699,7 +2661,6 @@ regex-1.3.2/src/compile.rs:1040:38 clippy::cast_possible_truncation \"casting `u1\n regex-1.3.2/src/compile.rs:1051:25 clippy::unseparated_literal_suffix \"integer type suffix should be separated by an underscore\"\n regex-1.3.2/src/compile.rs:1071:8 clippy::cast_lossless \"casting `u32` to `u64` may become silently lossy if you later change the type\"\n regex-1.3.2/src/compile.rs:112:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-regex-1.3.2/src/compile.rs:112:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n regex-1.3.2/src/compile.rs:154:30 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n regex-1.3.2/src/compile.rs:156:30 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n regex-1.3.2/src/compile.rs:185:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n@@ -3114,10 +3075,6 @@ regex-1.3.2/src/utf8.rs:85:19 clippy::cast_lossless \"casting `u8` to `u32` may b\n regex-1.3.2/src/utf8.rs:92:23 clippy::unusual_byte_groupings \"digits of hex or binary literal not grouped by four\"\n regex-1.3.2/src/utf8.rs:92:9 clippy::unusual_byte_groupings \"digits of hex or binary literal not grouped by four\"\n regex-1.3.2/src/utf8.rs:97:16 clippy::unusual_byte_groupings \"digits of hex or binary literal not grouped by four\"\n-ripgrep-12.1.1//home/matthias/.rustup/toolchains/nightly-2021-02-03-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:30:27 clippy::match_same_arms \"this `match` has identical arm bodies\"\n-ripgrep-12.1.1//home/matthias/.rustup/toolchains/nightly-2021-02-03-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:30:27 clippy::match_same_arms \"this `match` has identical arm bodies\"\n-ripgrep-12.1.1//home/matthias/.rustup/toolchains/nightly-2021-02-03-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:30:27 clippy::match_same_arms \"this `match` has identical arm bodies\"\n-ripgrep-12.1.1//home/matthias/.rustup/toolchains/nightly-2021-02-03-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:30:27 clippy::match_same_arms \"this `match` has identical arm bodies\"\n ripgrep-12.1.1/build.rs:133:19 clippy::option_as_ref_deref \"called `.as_ref().map(|x| &**x)` on an Option value. This can be done more directly by calling `githash.as_deref()` instead\"\n ripgrep-12.1.1/build.rs:18:18 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n ripgrep-12.1.1/build.rs:225:14 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n@@ -3171,6 +3128,7 @@ ripgrep-12.1.1/crates/core/args.rs:1524:5 clippy::unnecessary_wraps \"this functi\n ripgrep-12.1.1/crates/core/args.rs:1635:14 clippy::doc_markdown \"you should put `values_of_lossy` between ticks in the documentation\"\n ripgrep-12.1.1/crates/core/args.rs:1693:41 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n ripgrep-12.1.1/crates/core/args.rs:1770:17 clippy::cast_possible_truncation \"casting `u64` to `usize` may truncate the value on targets with 32-bit wide pointers\"\n+ripgrep-12.1.1/crates/core/args.rs:1829:5 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n ripgrep-12.1.1/crates/core/args.rs:287:13 clippy::similar_names \"binding's name is too similar to existing binding\"\n ripgrep-12.1.1/crates/core/args.rs:33:1 clippy::single_component_path_imports \"this import is redundant\"\n ripgrep-12.1.1/crates/core/args.rs:34:1 clippy::single_component_path_imports \"this import is redundant\"\n@@ -3189,6 +3147,8 @@ ripgrep-12.1.1/crates/core/config.rs:58:6 clippy::type_complexity \"very complex\n ripgrep-12.1.1/crates/core/config.rs:79:6 clippy::type_complexity \"very complex type used. Consider factoring parts into `type` definitions\"\n ripgrep-12.1.1/crates/core/logger.rs:11:30 clippy::doc_markdown \"you should put `max_level` between ticks in the documentation\"\n ripgrep-12.1.1/crates/core/logger.rs:15:16 clippy::redundant_static_lifetimes \"constants have by default a `'static` lifetime\"\n+ripgrep-12.1.1/crates/core/main.rs:114:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+ripgrep-12.1.1/crates/core/main.rs:189:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n ripgrep-12.1.1/crates/core/main.rs:55:19 clippy::needless_pass_by_value \"this argument is passed by value, but not consumed in the function body\"\n ripgrep-12.1.1/crates/core/main.rs:56:9 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n ripgrep-12.1.1/crates/core/messages.rs:46:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n@@ -3216,19 +3176,18 @@ ripgrep-12.1.1/crates/core/search.rs:533:36 clippy::cast_lossless \"casting `u32`\n ripgrep-12.1.1/crates/core/search.rs:533:5 clippy::cast_precision_loss \"casting `u64` to `f64` causes a loss of precision (`u64` is 64 bits wide, but `f64`'s mantissa is only 52 bits wide)\"\n ripgrep-12.1.1/crates/core/subject.rs:20:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n ripgrep-12.1.1/crates/core/subject.rs:4:1 clippy::single_component_path_imports \"this import is redundant\"\n+serde-1.0.118/src/de/mod.rs:1592:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:1616:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:1627:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:1638:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:1649:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:952:13 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n+serde-1.0.118/src/de/mod.rs:986:13 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n syn-1.0.54/build.rs:1:null clippy::cargo_common_metadata \"package `syn` is missing `package.keywords` metadata\"\n-syn-1.0.54/build.rs:1:null clippy::multiple_crate_versions \"could not read cargo metadata: `cargo metadata` exited with an error:  Downloading crates ...\\n  Downloaded syn-test-suite v0.0.0\\nerror: failed to verify the checksum of `syn-test-suite v0.0.0`\"\n-syn-1.0.54/src/generics.rs:174:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n syn-1.0.54/src/lib.rs:1:null clippy::cargo_common_metadata \"package `syn` is missing `package.keywords` metadata\"\n-syn-1.0.54/src/lib.rs:1:null clippy::multiple_crate_versions \"could not read cargo metadata: `cargo metadata` exited with an error:  Downloading crates ...\\n  Downloaded syn-test-suite v0.0.0\\nerror: failed to verify the checksum of `syn-test-suite v0.0.0`\"\n syn-1.0.54/src/lit.rs:1397:40 clippy::redundant_else \"redundant else block\"\n syn-1.0.54/src/lit.rs:1405:28 clippy::redundant_else \"redundant else block\"\n syn-1.0.54/src/lit.rs:1485:32 clippy::redundant_else \"redundant else block\"\n-syn-1.0.54/src/lit.rs:343:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-syn-1.0.54/src/lit.rs:437:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-syn-1.0.54/src/lit.rs:916:9 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-syn-1.0.54/src/token.rs:974:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-syn-1.0.54/src/token.rs:996:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n unicode-xid-0.2.1/src/lib.rs:1:null clippy::cargo_common_metadata \"package `unicode-xid` is missing `package.categories` metadata\"\n unicode-xid-0.2.1/src/lib.rs:56:11 clippy::upper_case_acronyms \"name `UnicodeXID` contains a capitalized acronym\"\n unicode-xid-0.2.1/src/lib.rs:57:64 clippy::doc_markdown \"you should put `XID_Start` between ticks in the documentation\"\n@@ -3248,7 +3207,6 @@ xsv-0.13.0/src/cmd/cat.rs:7:16 clippy::redundant_static_lifetimes \"statics have\n xsv-0.13.0/src/cmd/count.rs:32:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n xsv-0.13.0/src/cmd/count.rs:38:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n xsv-0.13.0/src/cmd/count.rs:42:33 clippy::unseparated_literal_suffix \"integer type suffix should be separated by an underscore\"\n-xsv-0.13.0/src/cmd/count.rs:50:5 clippy::unit_arg \"passing a unit value to a function\"\n xsv-0.13.0/src/cmd/count.rs:7:16 clippy::redundant_static_lifetimes \"statics have by default a `'static` lifetime\"\n xsv-0.13.0/src/cmd/fixlengths.rs:45:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n xsv-0.13.0/src/cmd/fixlengths.rs:50:18 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -3324,7 +3282,7 @@ xsv-0.13.0/src/cmd/sort.rs:48:9 clippy::similar_names \"binding's name is too sim\n xsv-0.13.0/src/cmd/sort.rs:91:14 clippy::explicit_into_iter_loop \"it is more concise to loop over containers instead of using explicit iteration methods\"\n xsv-0.13.0/src/cmd/split.rs:14:16 clippy::redundant_static_lifetimes \"statics have by default a `'static` lifetime\"\n xsv-0.13.0/src/cmd/split.rs:61:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n-xsv-0.13.0/src/cmd/split.rs:94:5 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n+xsv-0.13.0/src/cmd/split.rs:94:5 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n xsv-0.13.0/src/cmd/split.rs:96:14 clippy::needless_pass_by_value \"this argument is passed by value, but not consumed in the function body\"\n xsv-0.13.0/src/cmd/split.rs:99:13 clippy::cast_possible_truncation \"casting `u64` to `usize` may truncate the value on targets with 32-bit wide pointers\"\n xsv-0.13.0/src/cmd/stats.rs:110:36 clippy::redundant_closure_for_method_calls \"redundant closure found\"\n@@ -3438,14 +3396,12 @@ clippy::redundant_slicing 1\n clippy::same_item_push 1\n clippy::should_implement_trait 1\n clippy::stable_sort_primitive 1\n-clippy::unit_arg 1\n clippy::unnecessary_lazy_evaluations 1\n clippy::unsafe_derive_deserialize 1\n clippy::used_underscore_binding 1\n clippy::verbose_bit_mask 1\n clippy::while_let_on_iterator 1\n clippy::comparison_to_empty 2\n-clippy::derive_hash_xor_eq 2\n clippy::expl_impl_clone_on_copy 2\n clippy::filter_map 2\n clippy::len_zero 2\n@@ -3463,10 +3419,10 @@ clippy::write_with_newline 2\n clippy::filter_map_next 3\n clippy::fn_params_excessive_bools 3\n clippy::if_same_then_else 3\n+clippy::inconsistent_struct_constructor 3\n clippy::mut_mut 3\n clippy::ptr_arg 3\n clippy::zero_ptr 3\n-clippy::let_underscore_drop 4\n clippy::too_many_arguments 4\n clippy::explicit_iter_loop 5\n clippy::field_reassign_with_default 5\n@@ -3488,11 +3444,11 @@ clippy::range_plus_one 7\n clippy::invalid_upcast_comparisons 8\n clippy::needless_question_mark 8\n clippy::wrong_self_convention 8\n+clippy::multiple_crate_versions 9\n clippy::manual_range_contains 10\n clippy::match_wildcard_for_single_variants 10\n clippy::missing_safety_doc 10\n clippy::needless_doctest_main 10\n-clippy::multiple_crate_versions 11\n clippy::needless_lifetimes 12\n clippy::cargo_common_metadata 13\n clippy::shadow_unrelated 13\n@@ -3511,6 +3467,7 @@ clippy::struct_excessive_bools 20\n clippy::redundant_static_lifetimes 21\n clippy::default_trait_access 22\n clippy::cast_lossless 23\n+clippy::let_underscore_drop 23\n clippy::trivially_copy_pass_by_ref 26\n clippy::redundant_else 29\n clippy::too_many_lines 32\n@@ -3519,11 +3476,11 @@ clippy::enum_glob_use 40\n clippy::unseparated_literal_suffix 41\n clippy::cast_precision_loss 44\n clippy::single_match_else 45\n+clippy::missing_panics_doc 54\n clippy::inline_always 59\n-clippy::match_same_arms 65\n+clippy::match_same_arms 60\n clippy::similar_names 78\n clippy::cast_possible_truncation 95\n-clippy::missing_panics_doc 108\n clippy::redundant_field_names 111\n clippy::redundant_closure_for_method_calls 135\n clippy::items_after_statements 139\n@@ -3533,3 +3490,4 @@ clippy::doc_markdown 178\n clippy::missing_errors_doc 343\n clippy::unreadable_literal 365\n clippy::must_use_candidate 565\n+ICEs:"}, {"sha": "865043b46d179516040b478cfdff377561dc8816", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-02-11\"\n+channel = \"nightly-2021-02-25\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "0594663786ce212a3d7547d79e4efe56f7825234", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -66,8 +66,8 @@ fn third_party_crates() -> String {\n fn default_config() -> compiletest::Config {\n     let mut config = compiletest::Config::default();\n \n-    if let Ok(name) = env::var(\"TESTNAME\") {\n-        config.filter = Some(name);\n+    if let Ok(filters) = env::var(\"TESTNAME\") {\n+        config.filters = filters.split(',').map(std::string::ToString::to_string).collect();\n     }\n \n     if let Some(path) = option_env!(\"RUSTC_LIB_PATH\") {\n@@ -167,7 +167,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n fn run_ui_cargo(config: &mut compiletest::Config) {\n     fn run_tests(\n         config: &compiletest::Config,\n-        filter: &Option<String>,\n+        filters: &[String],\n         mut tests: Vec<tester::TestDescAndFn>,\n     ) -> Result<bool, io::Error> {\n         let mut result = true;\n@@ -181,9 +181,10 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n \n             // Use the filter if provided\n             let dir_path = dir.path();\n-            match &filter {\n-                Some(name) if !dir_path.ends_with(name) => continue,\n-                _ => {},\n+            for filter in filters {\n+                if !dir_path.ends_with(filter) {\n+                    continue;\n+                }\n             }\n \n             for case in fs::read_dir(&dir_path)? {\n@@ -243,8 +244,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n \n     let current_dir = env::current_dir().unwrap();\n     let conf_dir = var(\"CLIPPY_CONF_DIR\").unwrap_or_default();\n-    let filter = env::var(\"TESTNAME\").ok();\n-    let res = run_tests(&config, &filter, tests);\n+    let res = run_tests(&config, &config.filters, tests);\n     env::set_current_dir(current_dir).unwrap();\n     set_var(\"CLIPPY_CONF_DIR\", conf_dir);\n "}, {"sha": "d83080b69f5e5311b68bc8ccd21d3c42bf107f51", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "cc94ec53e1358fb6006ba16e506a96484122e669", "filename": "src/tools/clippy/tests/ui-toml/upper_case_acronyms_aggressive/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fclippy.toml?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1 @@\n+upper-case-acronyms-aggressive = true"}, {"sha": "fdf8905f812f6fbc1fa587f9aad0fc5116fa893d", "filename": "src/tools/clippy/tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,22 @@\n+#![warn(clippy::upper_case_acronyms)]\n+\n+struct HTTPResponse; // not linted by default, but with cfg option\n+\n+struct CString; // not linted\n+\n+enum Flags {\n+    NS, // not linted\n+    CWR,\n+    ECE,\n+    URG,\n+    ACK,\n+    PSH,\n+    RST,\n+    SYN,\n+    FIN,\n+}\n+\n+struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+                         // `GccLlvmSomething`\n+\n+fn main() {}"}, {"sha": "1cc59dc45f2aa6c05d35da735c9ae2e83b53923f", "filename": "src/tools/clippy/tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,70 @@\n+error: name `HTTPResponse` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:3:8\n+   |\n+LL | struct HTTPResponse; // not linted by default, but with cfg option\n+   |        ^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `HttpResponse`\n+   |\n+   = note: `-D clippy::upper-case-acronyms` implied by `-D warnings`\n+\n+error: name `NS` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:8:5\n+   |\n+LL |     NS, // not linted\n+   |     ^^ help: consider making the acronym lowercase, except the initial letter (notice the capitalization): `Ns`\n+\n+error: name `CWR` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:9:5\n+   |\n+LL |     CWR,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Cwr`\n+\n+error: name `ECE` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:10:5\n+   |\n+LL |     ECE,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Ece`\n+\n+error: name `URG` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:11:5\n+   |\n+LL |     URG,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Urg`\n+\n+error: name `ACK` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:12:5\n+   |\n+LL |     ACK,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter (notice the capitalization): `Ack`\n+\n+error: name `PSH` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:13:5\n+   |\n+LL |     PSH,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Psh`\n+\n+error: name `RST` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:14:5\n+   |\n+LL |     RST,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Rst`\n+\n+error: name `SYN` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:15:5\n+   |\n+LL |     SYN,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Syn`\n+\n+error: name `FIN` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:16:5\n+   |\n+LL |     FIN,\n+   |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Fin`\n+\n+error: name `GCCLLVMSomething` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:19:8\n+   |\n+LL | struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+   |        ^^^^^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `GccllvmSomething`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "aebeaf346799d3767a483533b9ff1e2f67c17783", "filename": "src/tools/clippy/tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -41,3 +41,15 @@ pub fn derive_foo(_input: TokenStream) -> TokenStream {\n         }\n     }\n }\n+\n+#[proc_macro_derive(StructAUseSelf)]\n+pub fn derive_use_self(_input: TokenStream) -> proc_macro::TokenStream {\n+    quote! {\n+        struct A;\n+        impl A {\n+            fn new() -> A {\n+                A\n+            }\n+        }\n+    }\n+}"}, {"sha": "2856943b9be8001a31c172480e16d35e6580abd9", "filename": "src/tools/clippy/tests/ui/blocks_in_if_conditions_closure.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fblocks_in_if_conditions_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fblocks_in_if_conditions_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fblocks_in_if_conditions_closure.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -44,4 +44,13 @@ fn macro_in_closure() {\n     }\n }\n \n-fn main() {}\n+#[rustfmt::skip]\n+fn main() {\n+    let mut range = 0..10;\n+    range.all(|i| {i < 10} );\n+\n+    let v = vec![1, 2, 3];\n+    if v.into_iter().any(|x| {x == 4}) {\n+        println!(\"contains 4!\");\n+    }\n+}"}, {"sha": "c69a46f0a77ee908e908d67c821782776c6f8cc1", "filename": "src/tools/clippy/tests/ui/collapsible_else_if.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -65,4 +65,13 @@ fn main() {\n     else {\n         println!(\"!\")\n     }\n+\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        #[cfg(not(roflol))]\n+        if y == \"world\" {\n+            println!(\"world!\")\n+        }\n+    }\n }"}, {"sha": "1359c7eb6278e6dbda3ee8f937fe8acc835a4258", "filename": "src/tools/clippy/tests/ui/collapsible_else_if.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -79,4 +79,13 @@ fn main() {\n             println!(\"!\")\n         }\n     }\n+\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        #[cfg(not(roflol))]\n+        if y == \"world\" {\n+            println!(\"world!\")\n+        }\n+    }\n }"}, {"sha": "e4c088bf6f03f3bf5402af00d503bff56965340f", "filename": "src/tools/clippy/tests/ui/collapsible_if.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -138,4 +138,11 @@ fn main() {\n \n     // Fix #5962\n     if matches!(true, true) && matches!(true, true) {}\n+\n+    if true {\n+        #[cfg(not(teehee))]\n+        if true {\n+            println!(\"Hello world!\");\n+        }\n+    }\n }"}, {"sha": "d6cf01c8319400c844ecedf0f2eea401c3c67fdf", "filename": "src/tools/clippy/tests/ui/collapsible_if.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -154,4 +154,11 @@ fn main() {\n     if matches!(true, true) {\n         if matches!(true, true) {}\n     }\n+\n+    if true {\n+        #[cfg(not(teehee))]\n+        if true {\n+            println!(\"Hello world!\");\n+        }\n+    }\n }"}, {"sha": "55467cf4229de4b9e5607d003a93f010bfd9eefd", "filename": "src/tools/clippy/tests/ui/collapsible_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -232,6 +232,14 @@ fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u\n             };\n         }\n     }\n+    let _: &dyn std::any::Any = match &Some(Some(1)) {\n+        Some(e) => match e {\n+            Some(e) => e,\n+            e => e,\n+        },\n+        // else branch looks the same but the binding is different\n+        e => e,\n+    };\n }\n \n fn make<T>() -> T {"}, {"sha": "77978884900893f816cc016ea570e93a33c32688", "filename": "src/tools/clippy/tests/ui/collapsible_match.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:7:20\n    |\n LL |           Ok(val) => match val {\n@@ -9,15 +9,15 @@ LL | |         },\n    | |_________^\n    |\n    = note: `-D clippy::collapsible-match` implied by `-D warnings`\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:7:12\n    |\n LL |         Ok(val) => match val {\n-   |            ^^^ Replace this binding\n+   |            ^^^ replace this binding\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:16:20\n    |\n LL |           Ok(val) => match val {\n@@ -27,31 +27,31 @@ LL | |             _ => return,\n LL | |         },\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:16:12\n    |\n LL |         Ok(val) => match val {\n-   |            ^^^ Replace this binding\n+   |            ^^^ replace this binding\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:25:9\n    |\n LL | /         if let Some(n) = val {\n LL | |             take(n);\n LL | |         }\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:24:15\n    |\n LL |     if let Ok(val) = res_opt {\n-   |               ^^^ Replace this binding\n+   |               ^^^ replace this binding\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:32:9\n    |\n LL | /         if let Some(n) = val {\n@@ -61,15 +61,15 @@ LL | |             return;\n LL | |         }\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:31:15\n    |\n LL |     if let Ok(val) = res_opt {\n-   |               ^^^ Replace this binding\n+   |               ^^^ replace this binding\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:43:9\n    |\n LL | /         match val {\n@@ -78,32 +78,32 @@ LL | |             _ => (),\n LL | |         }\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:42:15\n    |\n LL |     if let Ok(val) = res_opt {\n-   |               ^^^ Replace this binding\n+   |               ^^^ replace this binding\n LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:52:13\n    |\n LL | /             if let Some(n) = val {\n LL | |                 take(n);\n LL | |             }\n    | |_____________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:51:12\n    |\n LL |         Ok(val) => {\n-   |            ^^^ Replace this binding\n+   |            ^^^ replace this binding\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:61:9\n    |\n LL | /         match val {\n@@ -112,16 +112,16 @@ LL | |             _ => return,\n LL | |         }\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:60:15\n    |\n LL |     if let Ok(val) = res_opt {\n-   |               ^^^ Replace this binding\n+   |               ^^^ replace this binding\n LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:72:13\n    |\n LL | /             if let Some(n) = val {\n@@ -131,15 +131,15 @@ LL | |                 return;\n LL | |             }\n    | |_____________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:71:12\n    |\n LL |         Ok(val) => {\n-   |            ^^^ Replace this binding\n+   |            ^^^ replace this binding\n LL |             if let Some(n) = val {\n    |                    ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:83:20\n    |\n LL |           Ok(val) => match val {\n@@ -149,15 +149,15 @@ LL | |             None => return,\n LL | |         },\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:83:12\n    |\n LL |         Ok(val) => match val {\n-   |            ^^^ Replace this binding\n+   |            ^^^ replace this binding\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match.rs:92:22\n    |\n LL |           Some(val) => match val {\n@@ -167,11 +167,11 @@ LL | |             _ => return,\n LL | |         },\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match.rs:92:14\n    |\n LL |         Some(val) => match val {\n-   |              ^^^ Replace this binding\n+   |              ^^^ replace this binding\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n "}, {"sha": "c8a445ef369d9be9c796ad3c43552119394e8781", "filename": "src/tools/clippy/tests/ui/collapsible_match2.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_match2.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,4 +1,4 @@\n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match2.rs:8:34\n    |\n LL |               Ok(val) if make() => match val {\n@@ -9,15 +9,15 @@ LL | |             },\n    | |_____________^\n    |\n    = note: `-D clippy::collapsible-match` implied by `-D warnings`\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match2.rs:8:16\n    |\n LL |             Ok(val) if make() => match val {\n-   |                ^^^ Replace this binding\n+   |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match2.rs:15:24\n    |\n LL |               Ok(val) => match val {\n@@ -27,15 +27,15 @@ LL | |                 _ => return,\n LL | |             },\n    | |_____________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match2.rs:15:16\n    |\n LL |             Ok(val) => match val {\n-   |                ^^^ Replace this binding\n+   |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match2.rs:29:29\n    |\n LL |                       $pat => match $e {\n@@ -48,16 +48,16 @@ LL | |                     },\n LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |           ------------------------------------------------- in this macro invocation\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match2.rs:41:28\n    |\n LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |                            ^^^          ^^^^^^^ with this pattern\n    |                            |\n-   |                            Replace this binding\n+   |                            replace this binding\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match2.rs:46:20\n    |\n LL |           Some(s) => match *s {\n@@ -67,15 +67,15 @@ LL | |             _ => (),\n LL | |         },\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match2.rs:46:14\n    |\n LL |         Some(s) => match *s {\n-   |              ^ Replace this binding\n+   |              ^ replace this binding\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n \n-error: Unnecessary nested match\n+error: unnecessary nested match\n   --> $DIR/collapsible_match2.rs:55:24\n    |\n LL |           Some(ref s) => match &*s {\n@@ -85,11 +85,11 @@ LL | |             _ => (),\n LL | |         },\n    | |_________^\n    |\n-help: The outer pattern can be modified to include the inner pattern.\n+help: the outer pattern can be modified to include the inner pattern\n   --> $DIR/collapsible_match2.rs:55:14\n    |\n LL |         Some(ref s) => match &*s {\n-   |              ^^^^^ Replace this binding\n+   |              ^^^^^ replace this binding\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n "}, {"sha": "f8c866a49aa20015be08faee7ade41ec0e49af06", "filename": "src/tools/clippy/tests/ui/crashes/ice-6179.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6179.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,21 @@\n+//! This is a minimal reproducer for the ICE in https://github.com/rust-lang/rust-clippy/pull/6179.\n+//! The ICE is mainly caused by using `hir_ty_to_ty`. See the discussion in the PR for details.\n+\n+#![warn(clippy::use_self)]\n+#![allow(dead_code)]\n+\n+struct Foo {}\n+\n+impl Foo {\n+    fn foo() -> Self {\n+        impl Foo {\n+            fn bar() {}\n+        }\n+\n+        let _: _ = 1;\n+\n+        Self {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0b3758952ac6d7d80a36c5a24d11efab76292135", "filename": "src/tools/clippy/tests/ui/default_numeric_fallback.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,135 @@\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `i32`.\n+        let x = 22;\n+        let x = [1, 2, 3];\n+        let x = if true { (1, 2) } else { (3, 4) };\n+        let x = match 1 {\n+            1 => 1,\n+            _ => 2,\n+        };\n+\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12;\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 22_i32;\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [i32; 3] = [1, 2, 3];\n+        let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n+        let x: _ = 1;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_i32() -> i32 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `i32` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> i32 { 1 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(x: i32) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        generic_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: i32,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1 };\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, x: i32) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b31aa4ebcf8e4a3efd54ff94ca83a39355fc53ea", "filename": "src/tools/clippy/tests/ui/default_numeric_fallback.stderr", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_numeric_fallback.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,148 @@\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:10:17\n+   |\n+LL |         let x = 22;\n+   |                 ^^ help: consider adding suffix: `22_i32`\n+   |\n+   = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:18\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                  ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:21\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                     ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:11:24\n+   |\n+LL |         let x = [1, 2, 3];\n+   |                        ^ help: consider adding suffix: `3_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:28\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                            ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:31\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                               ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:44\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                                            ^ help: consider adding suffix: `3_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:12:47\n+   |\n+LL |         let x = if true { (1, 2) } else { (3, 4) };\n+   |                                               ^ help: consider adding suffix: `4_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:13:23\n+   |\n+LL |         let x = match 1 {\n+   |                       ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:14:13\n+   |\n+LL |             1 => 1,\n+   |             ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:14:18\n+   |\n+LL |             1 => 1,\n+   |                  ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:15:18\n+   |\n+LL |             _ => 2,\n+   |                  ^ help: consider adding suffix: `2_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:19:17\n+   |\n+LL |         let x = 0.12;\n+   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:37:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:45:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:51:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:63:9\n+   |\n+LL |         1\n+   |         ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:69:27\n+   |\n+LL |         let f = || -> _ { 1 };\n+   |                           ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:73:29\n+   |\n+LL |         let f = || -> i32 { 1 };\n+   |                             ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:87:21\n+   |\n+LL |         generic_arg(1);\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:90:32\n+   |\n+LL |         let x: _ = generic_arg(1);\n+   |                                ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:108:28\n+   |\n+LL |         GenericStruct { x: 1 };\n+   |                            ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:111:36\n+   |\n+LL |         let _ = GenericStruct { x: 1 };\n+   |                                    ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:131:23\n+   |\n+LL |         s.generic_arg(1);\n+   |                       ^ help: consider adding suffix: `1_i32`\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "d2c666bd2901c7fbe34e9f7daeeeab83deb8344a", "filename": "src/tools/clippy/tests/ui/doc.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -50,11 +50,23 @@ fn test_units() {\n }\n \n /// This tests allowed identifiers.\n+/// KiB MiB GiB TiB PiB EiB\n /// DirectX\n /// ECMAScript\n+/// GPLv2 GPLv3\n+/// GitHub GitLab\n+/// IPv4 IPv6\n+/// ClojureScript CoffeeScript JavaScript PureScript TypeScript\n+/// NaN NaNs\n /// OAuth GraphQL\n+/// OCaml\n+/// OpenGL OpenMP OpenSSH OpenSSL OpenStreetMap OpenDNS\n /// WebGL\n+/// TensorFlow\n+/// TrueType\n+/// iOS macOS\n /// TeX LaTeX BibTeX BibLaTeX\n+/// MinGW\n /// CamelCase (see also #2395)\n /// be_sure_we_got_to_the_end_of_it\n fn test_allowed() {"}, {"sha": "7eab8a85f093d6f1de5a51e517605338f98fee33", "filename": "src/tools/clippy/tests/ui/doc.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -55,133 +55,133 @@ LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:59:5\n+  --> $DIR/doc.rs:71:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `link_with_underscores` between ticks in the documentation\n-  --> $DIR/doc.rs:63:22\n+  --> $DIR/doc.rs:75:22\n    |\n LL | /// This test has [a link_with_underscores][chunked-example] inside it. See #823.\n    |                      ^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `inline_link2` between ticks in the documentation\n-  --> $DIR/doc.rs:66:21\n+  --> $DIR/doc.rs:78:21\n    |\n LL | /// It can also be [inline_link2].\n    |                     ^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:76:5\n+  --> $DIR/doc.rs:88:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `CamelCaseThing` between ticks in the documentation\n-  --> $DIR/doc.rs:84:8\n+  --> $DIR/doc.rs:96:8\n    |\n LL | /// ## CamelCaseThing\n    |        ^^^^^^^^^^^^^^\n \n error: you should put `CamelCaseThing` between ticks in the documentation\n-  --> $DIR/doc.rs:87:7\n+  --> $DIR/doc.rs:99:7\n    |\n LL | /// # CamelCaseThing\n    |       ^^^^^^^^^^^^^^\n \n error: you should put `CamelCaseThing` between ticks in the documentation\n-  --> $DIR/doc.rs:89:22\n+  --> $DIR/doc.rs:101:22\n    |\n LL | /// Not a title #897 CamelCaseThing\n    |                      ^^^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:90:5\n+  --> $DIR/doc.rs:102:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:97:5\n+  --> $DIR/doc.rs:109:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:110:5\n+  --> $DIR/doc.rs:122:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `FooBar` between ticks in the documentation\n-  --> $DIR/doc.rs:121:43\n+  --> $DIR/doc.rs:133:43\n    |\n LL | /** E.g., serialization of an empty list: FooBar\n    |                                           ^^^^^^\n \n error: you should put `BarQuz` between ticks in the documentation\n-  --> $DIR/doc.rs:126:5\n+  --> $DIR/doc.rs:138:5\n    |\n LL | And BarQuz too.\n    |     ^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:127:1\n+  --> $DIR/doc.rs:139:1\n    |\n LL | be_sure_we_got_to_the_end_of_it\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `FooBar` between ticks in the documentation\n-  --> $DIR/doc.rs:132:43\n+  --> $DIR/doc.rs:144:43\n    |\n LL | /** E.g., serialization of an empty list: FooBar\n    |                                           ^^^^^^\n \n error: you should put `BarQuz` between ticks in the documentation\n-  --> $DIR/doc.rs:137:5\n+  --> $DIR/doc.rs:149:5\n    |\n LL | And BarQuz too.\n    |     ^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:138:1\n+  --> $DIR/doc.rs:150:1\n    |\n LL | be_sure_we_got_to_the_end_of_it\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `be_sure_we_got_to_the_end_of_it` between ticks in the documentation\n-  --> $DIR/doc.rs:149:5\n+  --> $DIR/doc.rs:161:5\n    |\n LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put bare URLs between `<`/`>` or make a proper Markdown link\n-  --> $DIR/doc.rs:176:13\n+  --> $DIR/doc.rs:188:13\n    |\n LL | /// Not ok: http://www.unicode.org\n    |             ^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put bare URLs between `<`/`>` or make a proper Markdown link\n-  --> $DIR/doc.rs:177:13\n+  --> $DIR/doc.rs:189:13\n    |\n LL | /// Not ok: https://www.unicode.org\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put bare URLs between `<`/`>` or make a proper Markdown link\n-  --> $DIR/doc.rs:178:13\n+  --> $DIR/doc.rs:190:13\n    |\n LL | /// Not ok: http://www.unicode.org/\n    |             ^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put bare URLs between `<`/`>` or make a proper Markdown link\n-  --> $DIR/doc.rs:179:13\n+  --> $DIR/doc.rs:191:13\n    |\n LL | /// Not ok: http://www.unicode.org/reports/tr9/#Reordering_Resolved_Levels\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `mycrate::Collection` between ticks in the documentation\n-  --> $DIR/doc.rs:182:22\n+  --> $DIR/doc.rs:194:22\n    |\n LL | /// An iterator over mycrate::Collection's values.\n    |                      ^^^^^^^^^^^^^^^^^^^"}, {"sha": "3008c2d5b85381710f3235acd7fc9c8ac2e6cf86", "filename": "src/tools/clippy/tests/ui/doc_panics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -28,6 +28,15 @@ pub fn inner_body(opt: Option<u32>) {\n     });\n }\n \n+/// This needs to be documented\n+pub fn unreachable_and_panic() {\n+    if true {\n+        unreachable!()\n+    } else {\n+        panic!()\n+    }\n+}\n+\n /// This is documented\n ///\n /// # Panics\n@@ -69,6 +78,19 @@ pub fn todo_documented() {\n     todo!()\n }\n \n+/// This is documented\n+///\n+/// # Panics\n+///\n+/// We still need to do this part\n+pub fn unreachable_amd_panic_documented() {\n+    if true {\n+        unreachable!()\n+    } else {\n+        panic!()\n+    }\n+}\n+\n /// This is okay because it is private\n fn unwrap_private() {\n     let result = Err(\"Hi\");\n@@ -93,3 +115,8 @@ fn inner_body_private(opt: Option<u32>) {\n         }\n     });\n }\n+\n+/// This is okay because unreachable\n+pub fn unreachable() {\n+    unreachable!(\"This function panics\")\n+}"}, {"sha": "287148690d27af84c408679e7ba500b92ddad4b1", "filename": "src/tools/clippy/tests/ui/doc_panics.stderr", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_panics.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -63,5 +63,24 @@ LL |             panic!()\n    |             ^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: docs for function which may panic missing `# Panics` section\n+  --> $DIR/doc_panics.rs:32:1\n+   |\n+LL | / pub fn unreachable_and_panic() {\n+LL | |     if true {\n+LL | |         unreachable!()\n+LL | |     } else {\n+LL | |         panic!()\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: first possible panic found here\n+  --> $DIR/doc_panics.rs:36:9\n+   |\n+LL |         panic!()\n+   |         ^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "4fefc0b43f1d93dbf55a153e4db1bd559baeab63", "filename": "src/tools/clippy/tests/ui/enum_variants.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -133,4 +133,17 @@ pub enum NetworkLayer {\n     Layer3,\n }\n \n+// should lint suggesting `IData`, not only `Data` (see #4639)\n+enum IDataRequest {\n+    PutIData(String),\n+    GetIData(String),\n+    DeleteUnpubIData(String),\n+}\n+\n+enum HIDataRequest {\n+    PutHIData(String),\n+    GetHIData(String),\n+    DeleteUnpubHIData(String),\n+}\n+\n fn main() {}"}, {"sha": "ab7fff4507aaa6719db234e5b5bbe436f8e8b9b9", "filename": "src/tools/clippy/tests/ui/enum_variants.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -97,5 +97,29 @@ LL | | }\n    = note: `-D clippy::pub-enum-variant-names` implied by `-D warnings`\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: aborting due to 10 previous errors\n+error: all variants have the same postfix: `IData`\n+  --> $DIR/enum_variants.rs:137:1\n+   |\n+LL | / enum IDataRequest {\n+LL | |     PutIData(String),\n+LL | |     GetIData(String),\n+LL | |     DeleteUnpubIData(String),\n+LL | | }\n+   | |_^\n+   |\n+   = help: remove the postfixes and use full paths to the variants instead of glob imports\n+\n+error: all variants have the same postfix: `HIData`\n+  --> $DIR/enum_variants.rs:143:1\n+   |\n+LL | / enum HIDataRequest {\n+LL | |     PutHIData(String),\n+LL | |     GetHIData(String),\n+LL | |     DeleteUnpubHIData(String),\n+LL | | }\n+   | |_^\n+   |\n+   = help: remove the postfixes and use full paths to the variants instead of glob imports\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "2f2ea04847a98da6a11b1e49544e505f19968138", "filename": "src/tools/clippy/tests/ui/from_str_radix_10.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,52 @@\n+#![warn(clippy::from_str_radix_10)]\n+\n+mod some_mod {\n+    // fake function that shouldn't trigger the lint\n+    pub fn from_str_radix(_: &str, _: u32) -> Result<(), std::num::ParseIntError> {\n+        unimplemented!()\n+    }\n+}\n+\n+// fake function that shouldn't trigger the lint\n+fn from_str_radix(_: &str, _: u32) -> Result<(), std::num::ParseIntError> {\n+    unimplemented!()\n+}\n+\n+// to test parenthesis addition\n+struct Test;\n+\n+impl std::ops::Add<Test> for Test {\n+    type Output = &'static str;\n+\n+    fn add(self, _: Self) -> Self::Output {\n+        \"304\"\n+    }\n+}\n+\n+fn main() -> Result<(), Box<dyn std::error::Error>> {\n+    // all of these should trigger the lint\n+    u32::from_str_radix(\"30\", 10)?;\n+    i64::from_str_radix(\"24\", 10)?;\n+    isize::from_str_radix(\"100\", 10)?;\n+    u8::from_str_radix(\"7\", 10)?;\n+    u16::from_str_radix(&(\"10\".to_owned() + \"5\"), 10)?;\n+    i128::from_str_radix(Test + Test, 10)?;\n+\n+    let string = \"300\";\n+    i32::from_str_radix(string, 10)?;\n+\n+    let stringier = \"400\".to_string();\n+    i32::from_str_radix(&stringier, 10)?;\n+\n+    // none of these should trigger the lint\n+    u16::from_str_radix(\"20\", 3)?;\n+    i32::from_str_radix(\"45\", 12)?;\n+    usize::from_str_radix(\"10\", 16)?;\n+    i128::from_str_radix(\"10\", 13)?;\n+    some_mod::from_str_radix(\"50\", 10)?;\n+    some_mod::from_str_radix(\"50\", 6)?;\n+    from_str_radix(\"50\", 10)?;\n+    from_str_radix(\"50\", 6)?;\n+\n+    Ok(())\n+}"}, {"sha": "471bf52a9a7ed92156e0dbcabf8d644ac9bf1ad9", "filename": "src/tools/clippy/tests/ui/from_str_radix_10.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffrom_str_radix_10.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,52 @@\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:28:5\n+   |\n+LL |     u32::from_str_radix(\"30\", 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `\"30\".parse::<u32>()`\n+   |\n+   = note: `-D clippy::from-str-radix-10` implied by `-D warnings`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:29:5\n+   |\n+LL |     i64::from_str_radix(\"24\", 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `\"24\".parse::<i64>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:30:5\n+   |\n+LL |     isize::from_str_radix(\"100\", 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `\"100\".parse::<isize>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:31:5\n+   |\n+LL |     u8::from_str_radix(\"7\", 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `\"7\".parse::<u8>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:32:5\n+   |\n+LL |     u16::from_str_radix(&(\"10\".to_owned() + \"5\"), 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `((\"10\".to_owned() + \"5\")).parse::<u16>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:33:5\n+   |\n+LL |     i128::from_str_radix(Test + Test, 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(Test + Test).parse::<i128>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:36:5\n+   |\n+LL |     i32::from_str_radix(string, 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.parse::<i32>()`\n+\n+error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n+  --> $DIR/from_str_radix_10.rs:39:5\n+   |\n+LL |     i32::from_str_radix(&stringier, 10)?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `stringier.parse::<i32>()`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "a2ff1b741ca25e5699ff8d9f2453325ed7e4b9f0", "filename": "src/tools/clippy/tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -12,7 +12,7 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     if true {\n         for _ in &[42] {\n             let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            if foo.is_some() {\n                 break;\n             } else {\n                 continue;\n@@ -21,8 +21,8 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     } else {\n         //~ ERROR same body as `if` block\n         for _ in &[42] {\n-            let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            let bar: &Option<_> = &Some::<u8>(42);\n+            if bar.is_some() {\n                 break;\n             } else {\n                 continue;"}, {"sha": "454322d8aacda727b2a8efead93c70cc554ed772", "filename": "src/tools/clippy/tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else2.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -5,7 +5,7 @@ LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n LL | |         for _ in &[42] {\n-LL | |             let foo: &Option<_> = &Some::<u8>(42);\n+LL | |             let bar: &Option<_> = &Some::<u8>(42);\n ...  |\n LL | |         }\n LL | |     }\n@@ -19,7 +19,7 @@ LL |       if true {\n    |  _____________^\n LL | |         for _ in &[42] {\n LL | |             let foo: &Option<_> = &Some::<u8>(42);\n-LL | |             if true {\n+LL | |             if foo.is_some() {\n ...  |\n LL | |         }\n LL | |     } else {"}, {"sha": "8d9c311003508173c227ebaef88e3d090a9e6ed7", "filename": "src/tools/clippy/tests/ui/inconsistent_struct_constructor.fixed", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,61 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::inconsistent_struct_constructor)]\n+#![allow(clippy::redundant_field_names)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::no_effect)]\n+#![allow(dead_code)]\n+\n+#[derive(Default)]\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+\n+mod without_base {\n+    use super::Foo;\n+\n+    fn test() {\n+        let x = 1;\n+        let y = 1;\n+        let z = 1;\n+\n+        // Should lint.\n+        Foo { x, y, z };\n+\n+        // Shoule NOT lint because the order is the same as in the definition.\n+        Foo { x, y, z };\n+\n+        // Should NOT lint because z is not a shorthand init.\n+        Foo { y, x, z: z };\n+    }\n+}\n+\n+mod with_base {\n+    use super::Foo;\n+\n+    fn test() {\n+        let x = 1;\n+        let z = 1;\n+\n+        // Should lint.\n+        Foo { x, z, ..Default::default() };\n+\n+        // Should NOT lint because the order is consistent with the definition.\n+        Foo {\n+            x,\n+            z,\n+            ..Default::default()\n+        };\n+\n+        // Should NOT lint because z is not a shorthand init.\n+        Foo {\n+            z: z,\n+            x,\n+            ..Default::default()\n+        };\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "63fac9105015d3756b5be6edc83c52777c5d5179", "filename": "src/tools/clippy/tests/ui/inconsistent_struct_constructor.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,65 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::inconsistent_struct_constructor)]\n+#![allow(clippy::redundant_field_names)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::no_effect)]\n+#![allow(dead_code)]\n+\n+#[derive(Default)]\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+\n+mod without_base {\n+    use super::Foo;\n+\n+    fn test() {\n+        let x = 1;\n+        let y = 1;\n+        let z = 1;\n+\n+        // Should lint.\n+        Foo { y, x, z };\n+\n+        // Shoule NOT lint because the order is the same as in the definition.\n+        Foo { x, y, z };\n+\n+        // Should NOT lint because z is not a shorthand init.\n+        Foo { y, x, z: z };\n+    }\n+}\n+\n+mod with_base {\n+    use super::Foo;\n+\n+    fn test() {\n+        let x = 1;\n+        let z = 1;\n+\n+        // Should lint.\n+        Foo {\n+            z,\n+            x,\n+            ..Default::default()\n+        };\n+\n+        // Should NOT lint because the order is consistent with the definition.\n+        Foo {\n+            x,\n+            z,\n+            ..Default::default()\n+        };\n+\n+        // Should NOT lint because z is not a shorthand init.\n+        Foo {\n+            z: z,\n+            x,\n+            ..Default::default()\n+        };\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d7abe44f2540834bb8dc842af33f3eefb341dc26", "filename": "src/tools/clippy/tests/ui/inconsistent_struct_constructor.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finconsistent_struct_constructor.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,20 @@\n+error: inconsistent struct constructor\n+  --> $DIR/inconsistent_struct_constructor.rs:25:9\n+   |\n+LL |         Foo { y, x, z };\n+   |         ^^^^^^^^^^^^^^^ help: try: `Foo { x, y, z }`\n+   |\n+   = note: `-D clippy::inconsistent-struct-constructor` implied by `-D warnings`\n+\n+error: inconsistent struct constructor\n+  --> $DIR/inconsistent_struct_constructor.rs:43:9\n+   |\n+LL | /         Foo {\n+LL | |             z,\n+LL | |             x,\n+LL | |             ..Default::default()\n+LL | |         };\n+   | |_________^ help: try: `Foo { x, z, ..Default::default() }`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6e65fdbd04e7dafc7acfae04f81d757218b2bb9c", "filename": "src/tools/clippy/tests/ui/inherent_to_string.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -14,6 +14,7 @@ struct C;\n struct D;\n struct E;\n struct F;\n+struct G;\n \n impl A {\n     // Should be detected; emit warning\n@@ -73,6 +74,13 @@ impl F {\n     }\n }\n \n+impl G {\n+    // Should not be detected, as it does not match the function signature\n+    fn to_string<const _N: usize>(&self) -> String {\n+        \"G.to_string()\".to_string()\n+    }\n+}\n+\n fn main() {\n     let a = A;\n     a.to_string();\n@@ -93,4 +101,7 @@ fn main() {\n \n     let f = F;\n     f.to_string(1);\n+\n+    let g = G;\n+    g.to_string::<1>();\n }"}, {"sha": "f5fcc193b4d8a2332af013451b679751b0629d68", "filename": "src/tools/clippy/tests/ui/inherent_to_string.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finherent_to_string.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,5 +1,5 @@\n error: implementation of inherent method `to_string(&self) -> String` for type `A`\n-  --> $DIR/inherent_to_string.rs:20:5\n+  --> $DIR/inherent_to_string.rs:21:5\n    |\n LL | /     fn to_string(&self) -> String {\n LL | |         \"A.to_string()\".to_string()\n@@ -10,7 +10,7 @@ LL | |     }\n    = help: implement trait `Display` for type `A` instead\n \n error: type `C` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\n-  --> $DIR/inherent_to_string.rs:44:5\n+  --> $DIR/inherent_to_string.rs:45:5\n    |\n LL | /     fn to_string(&self) -> String {\n LL | |         \"C.to_string()\".to_string()"}, {"sha": "193509067582546244233ce967985a82d9169d0d", "filename": "src/tools/clippy/tests/ui/manual_map_option.fixed", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,70 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+\n+fn main() {\n+    Some(0).map(|_| 2);\n+\n+    Some(0).map(|x| x + 1);\n+\n+    Some(\"\").map(|x| x.is_empty());\n+\n+    Some(0).map(|x| !x);\n+\n+    #[rustfmt::skip]\n+    Some(0).map(std::convert::identity);\n+\n+    Some(&String::new()).map(|x| str::len(x));\n+\n+    match Some(0) {\n+        Some(x) if false => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    Some([0, 1]).as_ref().map(|x| x[0]);\n+\n+    Some(0).map(|x| x * 2);\n+\n+    Some(String::new()).as_ref().map(|x| x.is_empty());\n+\n+    Some(String::new()).as_ref().map(|x| x.len());\n+\n+    Some(0).map(|x| x + x);\n+\n+    #[warn(clippy::option_map_unit_fn)]\n+    match &mut Some(String::new()) {\n+        Some(x) => Some(x.push_str(\"\")),\n+        None => None,\n+    };\n+\n+    #[allow(clippy::option_map_unit_fn)]\n+    {\n+        Some(String::new()).as_mut().map(|x| x.push_str(\"\"));\n+    }\n+\n+    Some(String::new()).as_ref().map(|x| x.len());\n+\n+    Some(String::new()).as_ref().map(|x| x.is_empty());\n+\n+    Some((0, 1, 2)).map(|(x, y, z)| x + y + z);\n+\n+    Some([1, 2, 3]).map(|[first, ..]| first);\n+\n+    Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x));\n+\n+    match Some((String::new(), 0)) {\n+        Some((ref x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some(Some(0)) {\n+        Some(Some(_)) | Some(None) => Some(0),\n+        None => None,\n+    };\n+\n+    match Some(Some((0, 1))) {\n+        Some(Some((x, 1))) => Some(x),\n+        _ => None,\n+    };\n+}"}, {"sha": "8b8187db0a9798217c024cddf2e40f6b93a05112", "filename": "src/tools/clippy/tests/ui/manual_map_option.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,122 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+\n+fn main() {\n+    match Some(0) {\n+        Some(_) => Some(2),\n+        None::<u32> => None,\n+    };\n+\n+    match Some(0) {\n+        Some(x) => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    match Some(\"\") {\n+        Some(x) => Some(x.is_empty()),\n+        None => None,\n+    };\n+\n+    if let Some(x) = Some(0) {\n+        Some(!x)\n+    } else {\n+        None\n+    };\n+\n+    #[rustfmt::skip]\n+    match Some(0) {\n+        Some(x) => { Some(std::convert::identity(x)) }\n+        None => { None }\n+    };\n+\n+    match Some(&String::new()) {\n+        Some(x) => Some(str::len(x)),\n+        None => None,\n+    };\n+\n+    match Some(0) {\n+        Some(x) if false => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    match &Some([0, 1]) {\n+        Some(x) => Some(x[0]),\n+        &None => None,\n+    };\n+\n+    match &Some(0) {\n+        &Some(x) => Some(x * 2),\n+        None => None,\n+    };\n+\n+    match Some(String::new()) {\n+        Some(ref x) => Some(x.is_empty()),\n+        _ => None,\n+    };\n+\n+    match &&Some(String::new()) {\n+        Some(x) => Some(x.len()),\n+        _ => None,\n+    };\n+\n+    match &&Some(0) {\n+        &&Some(x) => Some(x + x),\n+        &&_ => None,\n+    };\n+\n+    #[warn(clippy::option_map_unit_fn)]\n+    match &mut Some(String::new()) {\n+        Some(x) => Some(x.push_str(\"\")),\n+        None => None,\n+    };\n+\n+    #[allow(clippy::option_map_unit_fn)]\n+    {\n+        match &mut Some(String::new()) {\n+            Some(x) => Some(x.push_str(\"\")),\n+            None => None,\n+        };\n+    }\n+\n+    match &mut Some(String::new()) {\n+        Some(ref x) => Some(x.len()),\n+        None => None,\n+    };\n+\n+    match &mut &Some(String::new()) {\n+        Some(x) => Some(x.is_empty()),\n+        &mut _ => None,\n+    };\n+\n+    match Some((0, 1, 2)) {\n+        Some((x, y, z)) => Some(x + y + z),\n+        None => None,\n+    };\n+\n+    match Some([1, 2, 3]) {\n+        Some([first, ..]) => Some(first),\n+        None => None,\n+    };\n+\n+    match &Some((String::new(), \"test\")) {\n+        Some((x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some((String::new(), 0)) {\n+        Some((ref x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some(Some(0)) {\n+        Some(Some(_)) | Some(None) => Some(0),\n+        None => None,\n+    };\n+\n+    match Some(Some((0, 1))) {\n+        Some(Some((x, 1))) => Some(x),\n+        _ => None,\n+    };\n+}"}, {"sha": "210a30d05d40f30ce4c6480a1a17ccccc81524fc", "filename": "src/tools/clippy/tests/ui/manual_map_option.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_map_option.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -0,0 +1,158 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:7:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(_) => Some(2),\n+LL | |         None::<u32> => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|_| 2)`\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:12:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => Some(x + 1),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x + 1)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:17:5\n+   |\n+LL | /     match Some(\"\") {\n+LL | |         Some(x) => Some(x.is_empty()),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(\"\").map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:22:5\n+   |\n+LL | /     if let Some(x) = Some(0) {\n+LL | |         Some(!x)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| !x)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:29:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => { Some(std::convert::identity(x)) }\n+LL | |         None => { None }\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(std::convert::identity)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:34:5\n+   |\n+LL | /     match Some(&String::new()) {\n+LL | |         Some(x) => Some(str::len(x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(&String::new()).map(|x| str::len(x))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:44:5\n+   |\n+LL | /     match &Some([0, 1]) {\n+LL | |         Some(x) => Some(x[0]),\n+LL | |         &None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some([0, 1]).as_ref().map(|x| x[0])`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:49:5\n+   |\n+LL | /     match &Some(0) {\n+LL | |         &Some(x) => Some(x * 2),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x * 2)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:54:5\n+   |\n+LL | /     match Some(String::new()) {\n+LL | |         Some(ref x) => Some(x.is_empty()),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:59:5\n+   |\n+LL | /     match &&Some(String::new()) {\n+LL | |         Some(x) => Some(x.len()),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:64:5\n+   |\n+LL | /     match &&Some(0) {\n+LL | |         &&Some(x) => Some(x + x),\n+LL | |         &&_ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x + x)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:77:9\n+   |\n+LL | /         match &mut Some(String::new()) {\n+LL | |             Some(x) => Some(x.push_str(\"\")),\n+LL | |             None => None,\n+LL | |         };\n+   | |_________^ help: try this: `Some(String::new()).as_mut().map(|x| x.push_str(\"\"))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:83:5\n+   |\n+LL | /     match &mut Some(String::new()) {\n+LL | |         Some(ref x) => Some(x.len()),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:88:5\n+   |\n+LL | /     match &mut &Some(String::new()) {\n+LL | |         Some(x) => Some(x.is_empty()),\n+LL | |         &mut _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:93:5\n+   |\n+LL | /     match Some((0, 1, 2)) {\n+LL | |         Some((x, y, z)) => Some(x + y + z),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some((0, 1, 2)).map(|(x, y, z)| x + y + z)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:98:5\n+   |\n+LL | /     match Some([1, 2, 3]) {\n+LL | |         Some([first, ..]) => Some(first),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some([1, 2, 3]).map(|[first, ..]| first)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:103:5\n+   |\n+LL | /     match &Some((String::new(), \"test\")) {\n+LL | |         Some((x, y)) => Some((y, x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "a4ec803024edf68689d732abaf090ac9ec21fa87", "filename": "src/tools/clippy/tests/ui/result_unit_error.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,6 +1,4 @@\n-#![allow(clippy::unnecessary_wraps)]\n-#[warn(clippy::result_unit_err)]\n-#[allow(unused)]\n+#![warn(clippy::result_unit_err)]\n \n pub fn returns_unit_error() -> Result<u32, ()> {\n     Err(())\n@@ -36,4 +34,23 @@ impl UnitErrorHolder {\n     }\n }\n \n+// https://github.com/rust-lang/rust-clippy/issues/6546\n+pub mod issue_6546 {\n+    type ResInv<A, B> = Result<B, A>;\n+\n+    pub fn should_lint() -> ResInv<(), usize> {\n+        Ok(0)\n+    }\n+\n+    pub fn should_not_lint() -> ResInv<usize, ()> {\n+        Ok(())\n+    }\n+\n+    type MyRes<A, B> = Result<(A, B), Box<dyn std::error::Error>>;\n+\n+    pub fn should_not_lint2(x: i32) -> MyRes<i32, ()> {\n+        Ok((x, ()))\n+    }\n+}\n+\n fn main() {}"}, {"sha": "41d8b0a7cb7f82e92989fb56c909a32b8e27315c", "filename": "src/tools/clippy/tests/ui/result_unit_error.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fresult_unit_error.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,5 +1,5 @@\n error: this returns a `Result<_, ()>\n-  --> $DIR/result_unit_error.rs:5:1\n+  --> $DIR/result_unit_error.rs:3:1\n    |\n LL | pub fn returns_unit_error() -> Result<u32, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,28 +8,36 @@ LL | pub fn returns_unit_error() -> Result<u32, ()> {\n    = help: use a custom Error type instead\n \n error: this returns a `Result<_, ()>\n-  --> $DIR/result_unit_error.rs:14:5\n+  --> $DIR/result_unit_error.rs:12:5\n    |\n LL |     fn get_that_error(&self) -> Result<bool, ()>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom Error type instead\n \n error: this returns a `Result<_, ()>\n-  --> $DIR/result_unit_error.rs:16:5\n+  --> $DIR/result_unit_error.rs:14:5\n    |\n LL |     fn get_this_one_too(&self) -> Result<bool, ()> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom Error type instead\n \n error: this returns a `Result<_, ()>\n-  --> $DIR/result_unit_error.rs:34:5\n+  --> $DIR/result_unit_error.rs:32:5\n    |\n LL |     pub fn unit_error(&self) -> Result<usize, ()> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom Error type instead\n \n-error: aborting due to 4 previous errors\n+error: this returns a `Result<_, ()>\n+  --> $DIR/result_unit_error.rs:41:5\n+   |\n+LL |     pub fn should_lint() -> ResInv<(), usize> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "a510263e67da19a2256975ffe18767606dffae0c", "filename": "src/tools/clippy/tests/ui/unnecessary_wraps.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -116,8 +116,53 @@ fn issue_6384(s: &str) -> Option<&str> {\n     })\n }\n \n+// should be linted\n+fn issue_6640_1(a: bool, b: bool) -> Option<()> {\n+    if a && b {\n+        return Some(());\n+    }\n+    if a {\n+        Some(());\n+        Some(())\n+    } else {\n+        return Some(());\n+    }\n+}\n+\n+// should be linted\n+fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n+    if a && b {\n+        return Ok(());\n+    }\n+    if a {\n+        Ok(())\n+    } else {\n+        return Ok(());\n+    }\n+}\n+\n+// should not be linted\n+fn issue_6640_3() -> Option<()> {\n+    if true {\n+        Some(())\n+    } else {\n+        None\n+    }\n+}\n+\n+// should not be linted\n+fn issue_6640_4() -> Result<(), ()> {\n+    if true {\n+        Ok(())\n+    } else {\n+        Err(())\n+    }\n+}\n+\n fn main() {\n     // method calls are not linted\n     func1(true, true);\n     func2(true, true);\n+    issue_6640_1(true, true);\n+    issue_6640_2(true, true);\n }"}, {"sha": "9a861c61a4679bd4fc7f46f83dca2a84a895af55", "filename": "src/tools/clippy/tests/ui/unnecessary_wraps.stderr", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_wraps.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -15,7 +15,7 @@ help: remove `Option` from the return type...\n    |\n LL | fn func1(a: bool, b: bool) -> i32 {\n    |                               ^^^\n-help: ...and change the returning expressions\n+help: ...and then change returning expressions\n    |\n LL |         return 42;\n LL |     }\n@@ -41,7 +41,7 @@ help: remove `Option` from the return type...\n    |\n LL | fn func2(a: bool, b: bool) -> i32 {\n    |                               ^^^\n-help: ...and change the returning expressions\n+help: ...and then change returning expressions\n    |\n LL |         return 10;\n LL |     }\n@@ -63,7 +63,7 @@ help: remove `Option` from the return type...\n    |\n LL | fn func5() -> i32 {\n    |               ^^^\n-help: ...and change the returning expressions\n+help: ...and then change returning expressions\n    |\n LL |     1\n    |\n@@ -80,7 +80,7 @@ help: remove `Result` from the return type...\n    |\n LL | fn func7() -> i32 {\n    |               ^^^\n-help: ...and change the returning expressions\n+help: ...and then change returning expressions\n    |\n LL |     1\n    |\n@@ -97,10 +97,62 @@ help: remove `Option` from the return type...\n    |\n LL |     fn func12() -> i32 {\n    |                    ^^^\n-help: ...and change the returning expressions\n+help: ...and then change returning expressions\n    |\n LL |         1\n    |\n \n-error: aborting due to 5 previous errors\n+error: this function's return value is unnecessary\n+  --> $DIR/unnecessary_wraps.rs:120:1\n+   |\n+LL | / fn issue_6640_1(a: bool, b: bool) -> Option<()> {\n+LL | |     if a && b {\n+LL | |         return Some(());\n+LL | |     }\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+help: remove the return type...\n+   |\n+LL | fn issue_6640_1(a: bool, b: bool) -> Option<()> {\n+   |                                      ^^^^^^^^^^\n+help: ...and then remove returned values\n+   |\n+LL |         return ;\n+LL |     }\n+LL |     if a {\n+LL |         Some(());\n+LL |         \n+LL |     } else {\n+ ...\n+\n+error: this function's return value is unnecessary\n+  --> $DIR/unnecessary_wraps.rs:133:1\n+   |\n+LL | / fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n+LL | |     if a && b {\n+LL | |         return Ok(());\n+LL | |     }\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+help: remove the return type...\n+   |\n+LL | fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n+   |                                      ^^^^^^^^^^^^^^^\n+help: ...and then remove returned values\n+   |\n+LL |         return ;\n+LL |     }\n+LL |     if a {\n+LL |         \n+LL |     } else {\n+LL |         return ;\n+   |\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "fdf8905f812f6fbc1fa587f9aad0fc5116fa893d", "filename": "src/tools/clippy/tests/ui/upper_case_acronyms.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,11 +1,11 @@\n #![warn(clippy::upper_case_acronyms)]\n \n-struct HTTPResponse; // linted\n+struct HTTPResponse; // not linted by default, but with cfg option\n \n struct CString; // not linted\n \n enum Flags {\n-    NS, // linted\n+    NS, // not linted\n     CWR,\n     ECE,\n     URG,\n@@ -16,6 +16,7 @@ enum Flags {\n     FIN,\n }\n \n-struct GCCLLVMSomething; // linted, beware that lint suggests `GccllvmSomething` instead of `GccLlvmSomething`\n+struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+                         // `GccLlvmSomething`\n \n fn main() {}"}, {"sha": "bbe38991e52714a89faff46fd844bbc4a8adb346", "filename": "src/tools/clippy/tests/ui/upper_case_acronyms.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupper_case_acronyms.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,22 +1,10 @@\n-error: name `HTTPResponse` contains a capitalized acronym\n-  --> $DIR/upper_case_acronyms.rs:3:8\n-   |\n-LL | struct HTTPResponse; // linted\n-   |        ^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `HttpResponse`\n-   |\n-   = note: `-D clippy::upper-case-acronyms` implied by `-D warnings`\n-\n-error: name `NS` contains a capitalized acronym\n-  --> $DIR/upper_case_acronyms.rs:8:5\n-   |\n-LL |     NS, // linted\n-   |     ^^ help: consider making the acronym lowercase, except the initial letter (notice the capitalization): `Ns`\n-\n error: name `CWR` contains a capitalized acronym\n   --> $DIR/upper_case_acronyms.rs:9:5\n    |\n LL |     CWR,\n    |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Cwr`\n+   |\n+   = note: `-D clippy::upper-case-acronyms` implied by `-D warnings`\n \n error: name `ECE` contains a capitalized acronym\n   --> $DIR/upper_case_acronyms.rs:10:5\n@@ -60,11 +48,5 @@ error: name `FIN` contains a capitalized acronym\n LL |     FIN,\n    |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Fin`\n \n-error: name `GCCLLVMSomething` contains a capitalized acronym\n-  --> $DIR/upper_case_acronyms.rs:19:8\n-   |\n-LL | struct GCCLLVMSomething; // linted, beware that lint suggests `GccllvmSomething` instead of `GccLlvmSomething`\n-   |        ^^^^^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `GccllvmSomething`\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "95e7bc754310f8393cf59cf6939ddc2f8e7bf170", "filename": "src/tools/clippy/tests/ui/use_self.fixed", "status": "modified", "additions": 215, "deletions": 9, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,9 +1,13 @@\n // run-rustfix\n // edition:2018\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n #![allow(dead_code)]\n-#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms)]\n+#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms, clippy::from_over_into)]\n+\n+#[macro_use]\n+extern crate proc_macro_derive;\n \n fn main() {}\n \n@@ -71,13 +75,12 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        #[allow(clippy::wrong_self_convention)]\n-        fn into_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(&self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn into_bytes(&self) -> Vec<u8> {\n+        fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]\n         }\n     }\n@@ -110,17 +113,20 @@ mod tuple_structs {\n mod macros {\n     macro_rules! use_self_expand {\n         () => {\n-            fn new() -> Self {\n-                Self {}\n+            fn new() -> Foo {\n+                Foo {}\n             }\n         };\n     }\n \n     struct Foo {}\n \n     impl Foo {\n-        use_self_expand!(); // Should lint in local macros\n+        use_self_expand!(); // Should not lint in local macros\n     }\n+\n+    #[derive(StructAUseSelf)] // Should not lint in derives\n+    struct A;\n }\n \n mod nesting {\n@@ -177,11 +183,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -252,3 +269,192 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Self {\n+            Self { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = Self;\n+        type To = Self;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            Self::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "75424f341597d1e50aa08ef0362dfeb9b8d1256c", "filename": "src/tools/clippy/tests/ui/use_self.rs", "status": "modified", "additions": 214, "deletions": 8, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,9 +1,13 @@\n // run-rustfix\n // edition:2018\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::use_self)]\n #![allow(dead_code)]\n-#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms)]\n+#![allow(clippy::should_implement_trait, clippy::upper_case_acronyms, clippy::from_over_into)]\n+\n+#[macro_use]\n+extern crate proc_macro_derive;\n \n fn main() {}\n \n@@ -71,13 +75,12 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        #[allow(clippy::wrong_self_convention)]\n-        fn into_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(&self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn into_bytes(&self) -> Vec<u8> {\n+        fn to_bytes(&self) -> Vec<u8> {\n             vec![*self]\n         }\n     }\n@@ -87,7 +90,7 @@ mod existential {\n     struct Foo;\n \n     impl Foo {\n-        fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n+        fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n             foos.iter()\n         }\n \n@@ -119,8 +122,11 @@ mod macros {\n     struct Foo {}\n \n     impl Foo {\n-        use_self_expand!(); // Should lint in local macros\n+        use_self_expand!(); // Should not lint in local macros\n     }\n+\n+    #[derive(StructAUseSelf)] // Should not lint in derives\n+    struct A;\n }\n \n mod nesting {\n@@ -177,11 +183,22 @@ mod issue3410 {\n     struct B;\n \n     trait Trait<T> {\n-        fn a(v: T);\n+        fn a(v: T) -> Self;\n     }\n \n     impl Trait<Vec<A>> for Vec<B> {\n-        fn a(_: Vec<A>) {}\n+        fn a(_: Vec<A>) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    impl<T> Trait<Vec<A>> for Vec<T>\n+    where\n+        T: Trait<B>,\n+    {\n+        fn a(v: Vec<A>) -> Self {\n+            <Vec<B>>::a(v).into_iter().map(Trait::a).collect()\n+        }\n     }\n }\n \n@@ -252,3 +269,192 @@ mod paths_created_by_lowering {\n         }\n     }\n }\n+\n+// reused from #1997\n+mod generics {\n+    struct Foo<T> {\n+        value: T,\n+    }\n+\n+    impl<T> Foo<T> {\n+        // `Self` is applicable here\n+        fn foo(value: T) -> Foo<T> {\n+            Foo { value }\n+        }\n+\n+        // `Cannot` use `Self` as a return type as the generic types are different\n+        fn bar(value: i32) -> Foo<i32> {\n+            Foo { value }\n+        }\n+    }\n+}\n+\n+mod issue4140 {\n+    pub struct Error<From, To> {\n+        _from: From,\n+        _too: To,\n+    }\n+\n+    pub trait From<T> {\n+        type From;\n+        type To;\n+\n+        fn from(value: T) -> Self;\n+    }\n+\n+    pub trait TryFrom<T>\n+    where\n+        Self: Sized,\n+    {\n+        type From;\n+        type To;\n+\n+        fn try_from(value: T) -> Result<Self, Error<Self::From, Self::To>>;\n+    }\n+\n+    impl<F, T> TryFrom<F> for T\n+    where\n+        T: From<F>,\n+    {\n+        type From = T::From;\n+        type To = T::To;\n+\n+        fn try_from(value: F) -> Result<Self, Error<Self::From, Self::To>> {\n+            Ok(From::from(value))\n+        }\n+    }\n+\n+    impl From<bool> for i64 {\n+        type From = bool;\n+        type To = Self;\n+\n+        fn from(value: bool) -> Self {\n+            if value {\n+                100\n+            } else {\n+                0\n+            }\n+        }\n+    }\n+}\n+\n+mod issue2843 {\n+    trait Foo {\n+        type Bar;\n+    }\n+\n+    impl Foo for usize {\n+        type Bar = u8;\n+    }\n+\n+    impl<T: Foo> Foo for Option<T> {\n+        type Bar = Option<T::Bar>;\n+    }\n+}\n+\n+mod issue3859 {\n+    pub struct Foo;\n+    pub struct Bar([usize; 3]);\n+\n+    impl Foo {\n+        pub const BAR: usize = 3;\n+\n+        pub fn foo() {\n+            const _X: usize = Foo::BAR;\n+            // const _Y: usize = Self::BAR;\n+        }\n+    }\n+}\n+\n+mod issue4305 {\n+    trait Foo: 'static {}\n+\n+    struct Bar;\n+\n+    impl Foo for Bar {}\n+\n+    impl<T: Foo> From<T> for Box<dyn Foo> {\n+        fn from(t: T) -> Self {\n+            Box::new(t)\n+        }\n+    }\n+}\n+\n+mod lint_at_item_level {\n+    struct Foo {}\n+\n+    #[allow(clippy::use_self)]\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    #[allow(clippy::use_self)]\n+    impl Default for Foo {\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod lint_at_impl_item_level {\n+    struct Foo {}\n+\n+    impl Foo {\n+        #[allow(clippy::use_self)]\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+    }\n+\n+    impl Default for Foo {\n+        #[allow(clippy::use_self)]\n+        fn default() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+mod issue4734 {\n+    #[repr(C, packed)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    impl From<X> for u32 {\n+        fn from(c: X) -> Self {\n+            unsafe { core::mem::transmute(c) }\n+        }\n+    }\n+}\n+\n+mod nested_paths {\n+    use std::convert::Into;\n+    mod submod {\n+        pub struct B {}\n+        pub struct C {}\n+\n+        impl Into<C> for B {\n+            fn into(self) -> C {\n+                C {}\n+            }\n+        }\n+    }\n+\n+    struct A<T> {\n+        t: T,\n+    }\n+\n+    impl<T> A<T> {\n+        fn new<V: Into<T>>(v: V) -> Self {\n+            Self { t: Into::into(v) }\n+        }\n+    }\n+\n+    impl A<submod::C> {\n+        fn test() -> Self {\n+            A::new::<submod::B>(submod::B {})\n+        }\n+    }\n+}"}, {"sha": "37dfef7cfe0e516996b23ddc5d43c5393a4004d6", "filename": "src/tools/clippy/tests/ui/use_self.stderr", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -1,164 +1,178 @@\n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:14:21\n+  --> $DIR/use_self.rs:18:21\n    |\n LL |         fn new() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n    |\n    = note: `-D clippy::use-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:15:13\n+  --> $DIR/use_self.rs:19:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:17:22\n+  --> $DIR/use_self.rs:21:22\n    |\n LL |         fn test() -> Foo {\n    |                      ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:18:13\n+  --> $DIR/use_self.rs:22:13\n    |\n LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:23:25\n+  --> $DIR/use_self.rs:27:25\n    |\n LL |         fn default() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:24:13\n+  --> $DIR/use_self.rs:28:13\n    |\n LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:90:56\n+  --> $DIR/use_self.rs:93:24\n    |\n-LL |         fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n-   |                                                        ^^^ help: use the applicable keyword: `Self`\n+LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n+   |                        ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:105:13\n+  --> $DIR/use_self.rs:93:55\n+   |\n+LL |         fn bad(foos: &[Foo]) -> impl Iterator<Item = &Foo> {\n+   |                                                       ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:108:13\n    |\n LL |             TS(0)\n    |             ^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:113:25\n-   |\n-LL |             fn new() -> Foo {\n-   |                         ^^^ help: use the applicable keyword: `Self`\n-...\n-LL |         use_self_expand!(); // Should lint in local macros\n-   |         ------------------- in this macro invocation\n+  --> $DIR/use_self.rs:143:29\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |                 fn bar() -> Bar {\n+   |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:114:17\n-   |\n-LL |                 Foo {}\n-   |                 ^^^ help: use the applicable keyword: `Self`\n-...\n-LL |         use_self_expand!(); // Should lint in local macros\n-   |         ------------------- in this macro invocation\n+  --> $DIR/use_self.rs:144:21\n    |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |                     Bar { foo: Foo {} }\n+   |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:149:21\n+  --> $DIR/use_self.rs:155:21\n    |\n LL |         fn baz() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:150:13\n+  --> $DIR/use_self.rs:156:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:137:29\n-   |\n-LL |                 fn bar() -> Bar {\n-   |                             ^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:138:21\n-   |\n-LL |                     Bar { foo: Foo {} }\n-   |                     ^^^ help: use the applicable keyword: `Self`\n-\n-error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:167:21\n+  --> $DIR/use_self.rs:173:21\n    |\n LL |             let _ = Enum::B(42);\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:168:21\n+  --> $DIR/use_self.rs:174:21\n    |\n LL |             let _ = Enum::C { field: true };\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:169:21\n+  --> $DIR/use_self.rs:175:21\n    |\n LL |             let _ = Enum::A;\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:200:13\n+  --> $DIR/use_self.rs:217:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:201:13\n+  --> $DIR/use_self.rs:218:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:203:13\n+  --> $DIR/use_self.rs:220:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:222:13\n+  --> $DIR/use_self.rs:239:13\n    |\n LL |             TestStruct::from_something()\n    |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:236:25\n+  --> $DIR/use_self.rs:253:25\n    |\n LL |         async fn g() -> S {\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:237:13\n+  --> $DIR/use_self.rs:254:13\n    |\n LL |             S {}\n    |             ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:16\n+  --> $DIR/use_self.rs:258:16\n    |\n LL |             &p[S::A..S::B]\n    |                ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:241:22\n+  --> $DIR/use_self.rs:258:22\n    |\n LL |             &p[S::A..S::B]\n    |                      ^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 25 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:281:29\n+   |\n+LL |         fn foo(value: T) -> Foo<T> {\n+   |                             ^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:282:13\n+   |\n+LL |             Foo { value }\n+   |             ^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:319:21\n+   |\n+LL |         type From = T::From;\n+   |                     ^^^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:320:19\n+   |\n+LL |         type To = T::To;\n+   |                   ^^^^^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:457:13\n+   |\n+LL |             A::new::<submod::B>(submod::B {})\n+   |             ^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 29 previous errors\n "}, {"sha": "9bcd692fb3511d805c24f6b49902eb31300936de", "filename": "src/tools/clippy/tests/ui/use_self_trait.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.fixed?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -47,7 +47,8 @@ impl Mul for Bad {\n \n impl Clone for Bad {\n     fn clone(&self) -> Self {\n-        Self\n+        // FIXME: applicable here\n+        Bad\n     }\n }\n "}, {"sha": "de305d40f330b1a4707995a0f286a844b6da0449", "filename": "src/tools/clippy/tests/ui/use_self_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -47,6 +47,7 @@ impl Mul for Bad {\n \n impl Clone for Bad {\n     fn clone(&self) -> Self {\n+        // FIXME: applicable here\n         Bad\n     }\n }"}, {"sha": "55af3ff2a93d9af515ccfea3db0cf2afd2a0be11", "filename": "src/tools/clippy/tests/ui/use_self_trait.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self_trait.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -84,11 +84,5 @@ error: unnecessary structure name repetition\n LL |     fn mul(self, rhs: Bad) -> Bad {\n    |                               ^^^ help: use the applicable keyword: `Self`\n \n-error: unnecessary structure name repetition\n-  --> $DIR/use_self_trait.rs:50:9\n-   |\n-LL |         Bad\n-   |         ^^^ help: use the applicable keyword: `Self`\n-\n-error: aborting due to 15 previous errors\n+error: aborting due to 14 previous errors\n "}, {"sha": "5099aad83bcbc78c1e32a8be3efddf760b203c9e", "filename": "src/tools/clippy/tests/ui/vec_init_then_push.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -12,10 +12,35 @@ fn main() {\n     cap_err.push(0);\n     cap_err.push(1);\n     cap_err.push(2);\n+    if true {\n+        // don't include this one\n+        cap_err.push(3);\n+    }\n \n     let mut cap_ok = Vec::with_capacity(10);\n     cap_ok.push(0);\n \n     new_err = Vec::new();\n     new_err.push(0);\n+\n+    let mut vec = Vec::new();\n+    // control flow at block final expression\n+    if true {\n+        // no lint\n+        vec.push(1);\n+    }\n+}\n+\n+pub fn no_lint() -> Vec<i32> {\n+    let mut p = Some(1);\n+    let mut vec = Vec::new();\n+    loop {\n+        match p {\n+            None => return vec,\n+            Some(i) => {\n+                vec.push(i);\n+                p = None;\n+            },\n+        }\n+    }\n }"}, {"sha": "9ec3e10e62470559cb304b27c6ea89f7f6700bf9", "filename": "src/tools/clippy/tests/ui/vec_init_then_push.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_init_then_push.stderr?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -24,7 +24,7 @@ LL | |     cap_err.push(2);\n    | |____________________^ help: consider using the `vec![]` macro: `let mut cap_err = vec![..];`\n \n error: calls to `push` immediately after creation\n-  --> $DIR/vec_init_then_push.rs:19:5\n+  --> $DIR/vec_init_then_push.rs:23:5\n    |\n LL | /     new_err = Vec::new();\n LL | |     new_err.push(0);"}, {"sha": "922a8207cea866c80cb482e0f631f8a52b096357", "filename": "src/tools/clippy/tests/versioncheck.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe67d98103717518904950a7a2008dd909d5f92/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fversioncheck.rs?ref=ebe67d98103717518904950a7a2008dd909d5f92", "patch": "@@ -2,21 +2,30 @@\n use rustc_tools_util::VersionInfo;\n \n #[test]\n-fn check_that_clippy_lints_has_the_same_version_as_clippy() {\n+fn check_that_clippy_lints_and_clippy_utils_have_the_same_version_as_clippy() {\n+    // do not run this test inside the upstream rustc repo:\n+    // https://github.com/rust-lang/rust-clippy/issues/6683\n+    if option_env!(\"RUSTC_TEST_SUITE\").is_some() {\n+        return;\n+    }\n+\n     let clippy_meta = cargo_metadata::MetadataCommand::new()\n         .no_deps()\n         .exec()\n         .expect(\"could not obtain cargo metadata\");\n-    std::env::set_current_dir(std::env::current_dir().unwrap().join(\"clippy_lints\")).unwrap();\n-    let clippy_lints_meta = cargo_metadata::MetadataCommand::new()\n-        .no_deps()\n-        .exec()\n-        .expect(\"could not obtain cargo metadata\");\n-    assert_eq!(clippy_lints_meta.packages[0].version, clippy_meta.packages[0].version);\n-    for package in &clippy_meta.packages[0].dependencies {\n-        if package.name == \"clippy_lints\" {\n-            assert!(package.req.matches(&clippy_lints_meta.packages[0].version));\n-            return;\n+\n+    for krate in &[\"clippy_lints\", \"clippy_utils\"] {\n+        let krate_meta = clippy_meta\n+            .packages\n+            .iter()\n+            .find(|package| package.name == *krate)\n+            .expect(\"could not obtain cargo metadata\");\n+        assert_eq!(krate_meta.version, clippy_meta.packages[0].version);\n+        for package in &clippy_meta.packages[0].dependencies {\n+            if package.name == *krate {\n+                assert!(package.req.matches(&krate_meta.version));\n+                break;\n+            }\n         }\n     }\n }"}]}