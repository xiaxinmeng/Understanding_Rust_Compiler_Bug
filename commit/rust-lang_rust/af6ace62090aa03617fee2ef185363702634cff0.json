{"sha": "af6ace62090aa03617fee2ef185363702634cff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNmFjZTYyMDkwYWEwMzYxN2ZlZTJlZjE4NTM2MzcwMjYzNGNmZjA=", "commit": {"author": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-05-06T12:54:27Z"}, "committer": {"name": "Marcel Hellwig", "email": "git@cookiesoft.de", "date": "2019-05-06T12:54:27Z"}, "message": "convert custom try macro to `?`\n\nresolves #60580", "tree": {"sha": "5aee19496957088eab57aef5c5832ae090866768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aee19496957088eab57aef5c5832ae090866768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af6ace62090aa03617fee2ef185363702634cff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af6ace62090aa03617fee2ef185363702634cff0", "html_url": "https://github.com/rust-lang/rust/commit/af6ace62090aa03617fee2ef185363702634cff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af6ace62090aa03617fee2ef185363702634cff0/comments", "author": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hellow554", "id": 921462, "node_id": "MDQ6VXNlcjkyMTQ2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/921462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hellow554", "html_url": "https://github.com/hellow554", "followers_url": "https://api.github.com/users/hellow554/followers", "following_url": "https://api.github.com/users/hellow554/following{/other_user}", "gists_url": "https://api.github.com/users/hellow554/gists{/gist_id}", "starred_url": "https://api.github.com/users/hellow554/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hellow554/subscriptions", "organizations_url": "https://api.github.com/users/hellow554/orgs", "repos_url": "https://api.github.com/users/hellow554/repos", "events_url": "https://api.github.com/users/hellow554/events{/privacy}", "received_events_url": "https://api.github.com/users/hellow554/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7fcbfbf1fff2794de5ec6dcb0a052c345ded3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7fcbfbf1fff2794de5ec6dcb0a052c345ded3a7", "html_url": "https://github.com/rust-lang/rust/commit/c7fcbfbf1fff2794de5ec6dcb0a052c345ded3a7"}], "stats": {"total": 76, "additions": 31, "deletions": 45}, "files": [{"sha": "5039c2e3ddfb3e43c3b3764b28501bfc260c8c6f", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af6ace62090aa03617fee2ef185363702634cff0/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6ace62090aa03617fee2ef185363702634cff0/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=af6ace62090aa03617fee2ef185363702634cff0", "patch": "@@ -254,44 +254,37 @@ impl Command {\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke syscall::exit)\n     unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt(syscall::dup2(fd, 2, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(2, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 2, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(2, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(2, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(2, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt(syscall::dup2(fd, 1, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(1, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 1, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(1, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(1, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(1, syscall::F_SETFD, flags))?;\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt(syscall::dup2(fd, 0, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(0, syscall::F_GETFD, 0)));\n+            cvt(syscall::dup2(fd, 0, &[]))?;\n+            let mut flags = cvt(syscall::fcntl(0, syscall::F_GETFD, 0))?;\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(0, syscall::F_SETFD, flags)));\n+            cvt(syscall::fcntl(0, syscall::F_SETFD, flags))?;\n         }\n \n         if let Some(g) = self.gid {\n-            t!(cvt(syscall::setregid(g as usize, g as usize)));\n+            cvt(syscall::setregid(g as usize, g as usize))?;\n         }\n         if let Some(u) = self.uid {\n-            t!(cvt(syscall::setreuid(u as usize, u as usize)));\n+            cvt(syscall::setreuid(u as usize, u as usize))?;\n         }\n         if let Some(ref cwd) = self.cwd {\n-            t!(cvt(syscall::chdir(cwd)));\n+            cvt(syscall::chdir(cwd))?;\n         }\n \n         for callback in self.closures.iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         self.env.apply();\n@@ -313,7 +306,7 @@ impl Command {\n         };\n \n         let mut file = if let Some(program) = program {\n-            t!(File::open(program.as_os_str()))\n+            File::open(program.as_os_str())?\n         } else {\n             return io::Error::from_raw_os_error(syscall::ENOENT);\n         };\n@@ -327,7 +320,7 @@ impl Command {\n             let mut shebang = [0; 2];\n             let mut read = 0;\n             loop {\n-                match t!(reader.read(&mut shebang[read..])) {\n+                match reader.read(&mut shebang[read..])? {\n                     0 => break,\n                     n => read += n,\n                 }\n@@ -338,9 +331,9 @@ impl Command {\n                 // First of all, since we'll be passing another file to\n                 // fexec(), we need to manually check that we have permission\n                 // to execute this file:\n-                let uid = t!(cvt(syscall::getuid()));\n-                let gid = t!(cvt(syscall::getgid()));\n-                let meta = t!(file.metadata());\n+                let uid = cvt(syscall::getuid())?;\n+                let gid = cvt(syscall::getgid())?;\n+                let meta = file.metadata()?;\n \n                 let mode = if uid == meta.uid() as usize {\n                     meta.mode() >> 3*2 & 0o7\n@@ -355,7 +348,7 @@ impl Command {\n \n                 // Second of all, we need to actually read which interpreter it wants\n                 let mut interpreter = Vec::new();\n-                t!(reader.read_until(b'\\n', &mut interpreter));\n+                reader.read_until(b'\\n', &mut interpreter)?;\n                 // Pop one trailing newline, if any\n                 if interpreter.ends_with(&[b'\\n']) {\n                     interpreter.pop().unwrap();\n@@ -373,11 +366,11 @@ impl Command {\n         };\n         if let Some(ref interpreter) = interpreter {\n             let path: &OsStr = OsStr::from_bytes(&interpreter);\n-            file = t!(File::open(path));\n+            file = File::open(path)?;\n \n             args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n         } else {\n-            t!(file.seek(SeekFrom::Start(0)));\n+            file.seek(SeekFrom::Start(0))?;\n         }\n \n         args.push([self.program.as_ptr() as usize, self.program.len()]);"}, {"sha": "07f813315e8c12757209b32e78602f3cab59c977", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af6ace62090aa03617fee2ef185363702634cff0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6ace62090aa03617fee2ef185363702634cff0/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=af6ace62090aa03617fee2ef185363702634cff0", "patch": "@@ -167,26 +167,19 @@ impl Command {\n     ) -> io::Error {\n         use crate::sys::{self, cvt_r};\n \n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n         if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n         if cfg!(not(any(target_os = \"l4re\"))) {\n             if let Some(u) = self.get_gid() {\n-                t!(cvt(libc::setgid(u as gid_t)));\n+                cvt(libc::setgid(u as gid_t))?;\n             }\n             if let Some(u) = self.get_uid() {\n                 // When dropping privileges from root, the `setgroups` call\n@@ -198,11 +191,11 @@ impl Command {\n                 // privilege dropping function.\n                 let _ = libc::setgroups(0, ptr::null());\n \n-                t!(cvt(libc::setuid(u as uid_t)));\n+                cvt(libc::setuid(u as uid_t))?;\n             }\n         }\n         if let Some(ref cwd) = *self.get_cwd() {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n+            cvt(libc::chdir(cwd.as_ptr()))?;\n         }\n \n         // emscripten has no signal support.\n@@ -225,18 +218,18 @@ impl Command {\n                              0,\n                              mem::size_of::<libc::sigset_t>());\n             } else {\n-                t!(cvt(libc::sigemptyset(&mut set)));\n+                cvt(libc::sigemptyset(&mut set))?;\n             }\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                         ptr::null_mut())));\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                         ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n                 return io::Error::last_os_error()\n             }\n         }\n \n         for callback in self.get_closures().iter_mut() {\n-            t!(callback());\n+            callback()?;\n         }\n \n         // Although we're performing an exec here we may also return with an"}]}