{"sha": "9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDIwNmNkYzRlNzMxZDBiMTcyZDc2YjJkNjUyYmYwZWNhYTljYTE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-17T10:18:14Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-17T21:47:03Z"}, "message": "Clean up block_ctxt representation", "tree": {"sha": "605d9bf5fdf885032954f328d94cefaf110ce06c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/605d9bf5fdf885032954f328d94cefaf110ce06c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "html_url": "https://github.com/rust-lang/rust/commit/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3", "html_url": "https://github.com/rust-lang/rust/commit/54d7bffbb8f79d4680b6200ee50e0ca8eb2dc3c3"}], "stats": {"total": 271, "additions": 131, "deletions": 140}, "files": [{"sha": "0e09899a5a45230f9dfd5e220981ade85e858270", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 65, "deletions": 80, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "patch": "@@ -2108,7 +2108,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n              body: ast::blk, outer_next_cx: @block_ctxt) -> @block_ctxt {\n         let next_cx = new_sub_block_ctxt(bcx, \"next\");\n         let scope_cx =\n-            new_loop_scope_block_ctxt(bcx, option::some(next_cx),\n+            new_loop_scope_block_ctxt(bcx, cont_other(next_cx),\n                                       outer_next_cx, \"for loop scope\",\n                                       body.span);\n         Br(bcx, scope_cx.llbb);\n@@ -2138,7 +2138,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     -> @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n-    let cond_cx = new_loop_scope_block_ctxt(cx, none, next_cx,\n+    let cond_cx = new_loop_scope_block_ctxt(cx, cont_self, next_cx,\n                                             \"while cond\", body.span);\n     let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n     Br(cx, cond_cx.llbb);\n@@ -2154,7 +2154,7 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let body_cx =\n-        new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n+        new_loop_scope_block_ctxt(cx, cont_self, next_cx,\n                                   \"do-while loop body\", body.span);\n     let body_end = trans_block(body_cx, body, ignore);\n     let cond_cx = new_scope_block_ctxt(body_cx, \"do-while cond\");\n@@ -2995,27 +2995,32 @@ fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n }\n \n fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n-    fn find_scope_for_lpad(bcx: @block_ctxt) -> @block_ctxt {\n-        let scope_bcx = bcx;\n+    fn in_lpad_scope_cx(bcx: @block_ctxt, f: fn(scope_info)) {\n+        let bcx = bcx;\n         while true {\n-            if vec::is_not_empty(scope_bcx.cleanups) { break; }\n-            scope_bcx = alt scope_bcx.parent {\n-              parent_some(b) { b }\n-              parent_none { break; }\n-            };\n+            alt bcx.kind {\n+              scope_block(info) {\n+                if info.cleanups.len() > 0u || bcx.parent == parent_none {\n+                    f(info); ret;\n+                }\n+              }\n+              _ {}\n+            }\n+            bcx = alt check bcx.parent { parent_some(b) { b } };\n         }\n-        scope_bcx\n     }\n \n-    let scope_bcx = find_scope_for_lpad(bcx);\n-    // If there is a valid landing pad still around, use it\n-    alt scope_bcx.landing_pad {\n-      some(target) { ret target; }\n-      none {}\n+    let cached = none, pad_bcx = bcx; // Guaranteed to be set below\n+    in_lpad_scope_cx(bcx) {|info|\n+        // If there is a valid landing pad still around, use it\n+        alt info.landing_pad {\n+          some(target) { cached = some(target); ret; }\n+          none {}\n+        }\n+        pad_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n+        info.landing_pad = some(pad_bcx.llbb);\n     }\n-\n-    let pad_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n-    scope_bcx.landing_pad = some(pad_bcx.llbb);\n+    alt cached { some(b) { ret b; } none {} } // Can't return from block above\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3573,13 +3578,13 @@ fn trans_break_cont(bcx: @block_ctxt, to_end: bool)\n     let unwind = bcx, target = bcx;\n     while true {\n         alt unwind.kind {\n-          LOOP_SCOPE_BLOCK(_cont, _break) {\n+          scope_block({is_loop: some({cnt, brk}), _}) {\n             target = if to_end {\n-                _break\n+                brk\n             } else {\n-                alt _cont {\n-                  option::some(_cont) { _cont }\n-                  _ { unwind }\n+                alt cnt {\n+                  cont_other(o) { o }\n+                  cont_self { unwind }\n                 }\n             };\n             break;\n@@ -3738,16 +3743,14 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         s = cx.ccx.names(name);\n     }\n-    let llbb: BasicBlockRef =\n-        str::as_buf(s, {|buf| llvm::LLVMAppendBasicBlock(cx.llfn, buf) });\n+    let llbb: BasicBlockRef = str::as_buf(s, {|buf|\n+        llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n+    });\n     let bcx = @{llbb: llbb,\n                 mutable terminated: false,\n                 mutable unreachable: false,\n                 parent: parent,\n                 kind: kind,\n-                mutable cleanups: [],\n-                mutable cleanup_paths: [],\n-                mutable landing_pad: none,\n                 block_span: block_span,\n                 fcx: cx};\n     alt parent {\n@@ -3759,45 +3762,51 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     ret bcx;\n }\n \n+fn simple_scope_block() -> block_kind {\n+    scope_block({is_loop: none, mutable cleanups: [],\n+                 mutable cleanup_paths: [], mutable landing_pad: none})\n+}\n \n // Use this when you're at the top block of a function or the like.\n fn new_top_block_ctxt(fcx: @fn_ctxt, sp: option<span>) -> @block_ctxt {\n-    ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, \"function top level\",\n-                       sp);\n+    ret new_block_ctxt(fcx, parent_none, simple_scope_block(),\n+                       \"function top level\", sp);\n }\n \n-\n // Use this when you're at a curly-brace or similar lexical scope.\n fn new_scope_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n, none);\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), simple_scope_block(),\n+                       n, none);\n }\n \n fn new_real_block_ctxt(bcx: @block_ctxt, n: str, sp: span) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n, some(sp));\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), simple_scope_block(),\n+                       n, some(sp));\n }\n \n-fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: option<@block_ctxt>,\n+fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: loop_cont,\n                              _break: @block_ctxt, n: str, sp: span)\n     -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n-                       LOOP_SCOPE_BLOCK(_cont, _break), n, some(sp));\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), scope_block({\n+        is_loop: some({cnt: _cont, brk: _break}),\n+        mutable cleanups: [],\n+        mutable cleanup_paths: [],\n+        mutable landing_pad: none\n+    }), n, some(sp));\n }\n \n \n // Use this when you're making a general CFG BB within a scope.\n fn new_sub_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n, none);\n+    ret new_block_ctxt(bcx.fcx, parent_some(bcx), non_scope_block, n, none);\n }\n \n fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n     ret @{llbb: llbb,\n           mutable terminated: false,\n           mutable unreachable: false,\n           parent: parent_none,\n-          kind: NON_SCOPE_BLOCK,\n-          mutable cleanups: [],\n-          mutable cleanup_paths: [],\n-          mutable landing_pad: none,\n+          kind: non_scope_block,\n           block_span: none,\n           fcx: fcx};\n }\n@@ -3813,13 +3822,13 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n    @block_ctxt {\n     if bcx.unreachable { ret bcx; }\n-    let i = cleanup_cx.cleanups.len(), bcx = bcx;\n-    if cleanup_cx.kind == NON_SCOPE_BLOCK { assert i == 0u; }\n-    while i > 0u {\n-        i -= 1u;\n-        alt cleanup_cx.cleanups[i] {\n-          clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); }\n+    let bcx = bcx;\n+    alt check cleanup_cx.kind {\n+      scope_block({cleanups, _}) {\n+        vec::riter(cleanups) {|cu|\n+            alt cu { clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); } }\n         }\n+      }\n     }\n     ret bcx;\n }\n@@ -3831,18 +3840,20 @@ fn cleanup_and_leave(bcx: @block_ctxt, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n     let cur = bcx, bcx = bcx;\n     while true {\n-        if cur.cleanups.len() > 0u {\n-            assert cur.kind != NON_SCOPE_BLOCK;\n-            for exists in cur.cleanup_paths {\n+        alt cur.kind {\n+          scope_block(info) if info.cleanups.len() > 0u {\n+            for exists in info.cleanup_paths {\n                 if exists.target == leave {\n                     Br(bcx, exists.dest);\n                     ret;\n                 }\n             }\n             let sub_cx = new_sub_block_ctxt(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            cur.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n+            info.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n             bcx = trans_block_cleanups(sub_cx, cur);\n+          }\n+          _ {}\n         }\n         alt upto {\n           some(bb) { if cur.llbb == bb { break; } }\n@@ -3890,33 +3901,6 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     }\n }\n \n-fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n-    ret @{llbb: fcx.llstaticallocas,\n-          mutable terminated: false,\n-          mutable unreachable: false,\n-          parent: parent_none,\n-          kind: SCOPE_BLOCK,\n-          mutable cleanups: [],\n-          mutable cleanup_paths: [],\n-          mutable landing_pad: none,\n-          block_span: none,\n-          fcx: fcx};\n-}\n-\n-fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n-    ret @{llbb: fcx.llderivedtydescs,\n-          mutable terminated: false,\n-          mutable unreachable: false,\n-          parent: parent_none,\n-          kind: SCOPE_BLOCK,\n-          mutable cleanups: [],\n-          mutable cleanup_paths: [],\n-          mutable landing_pad: none,\n-          block_span: none,\n-          fcx: fcx};\n-}\n-\n-\n fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n     let bcx = cx, ccx = bcx_ccx(cx);\n     let llty = type_of(ccx, t);\n@@ -3927,7 +3911,8 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n         // block_ctxt built on the llderivedtydescs block for the fn,\n         // so that the size dominates the array_alloca that\n         // comes next.\n-        let n = size_of(llderivedtydescs_block_ctxt(bcx.fcx), t);\n+        let n = size_of(new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs),\n+                        t);\n         bcx.fcx.llderivedtydescs = n.bcx.llbb;\n         PointerCast(bcx, dynastack_alloca(bcx, T_i8(), n.val, t), T_ptr(llty))\n     };"}, {"sha": "783e8d15070ca832ffe711991c7b15e0c378a5d0", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 66, "deletions": 60, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9f4206cdc4e731d0b172d76b2d652bf0ecaa9ca1", "patch": "@@ -233,16 +233,17 @@ enum cleanup {\n type cleanup_path = {target: option<BasicBlockRef>,\n                      dest: BasicBlockRef};\n \n-fn scope_clean_changed(cx: @block_ctxt) {\n-    cx.cleanup_paths = [];\n-    cx.landing_pad = none;\n+fn scope_clean_changed(info: scope_info) {\n+    if info.cleanup_paths.len() > 0u { info.cleanup_paths = []; }\n+    info.landing_pad = none;\n }\n \n fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n-    let scope_cx = find_scope_cx(cx);\n-    scope_cx.cleanups += [clean(bind drop_ty(_, val, ty))];\n-    scope_clean_changed(scope_cx);\n+    in_scope_cx(cx) {|info|\n+        info.cleanups += [clean(bind drop_ty(_, val, ty))];\n+        scope_clean_changed(info);\n+    }\n }\n fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n@@ -254,51 +255,48 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n             ret drop_ty(bcx, val, ty);\n         }\n     }\n-    let scope_cx = find_scope_cx(cx);\n-    scope_cx.cleanups +=\n-        [clean_temp(val, bind do_drop(_, val, ty))];\n-    scope_clean_changed(scope_cx);\n+    in_scope_cx(cx) {|info|\n+        info.cleanups += [clean_temp(val, bind do_drop(_, val, ty))];\n+        scope_clean_changed(info);\n+    }\n }\n fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n-    let scope_cx = find_scope_cx(cx);\n-    scope_cx.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n-    scope_clean_changed(scope_cx);\n+    in_scope_cx(cx) {|info|\n+        info.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n+        scope_clean_changed(info);\n+    }\n }\n fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n-    let scope_cx = find_scope_cx(cx);\n     let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n                   else { bind base::trans_free(_, ptr) };\n-    scope_cx.cleanups += [clean_temp(ptr, free_fn)];\n-    scope_clean_changed(scope_cx);\n+    in_scope_cx(cx) {|info|\n+        info.cleanups += [clean_temp(ptr, free_fn)];\n+        scope_clean_changed(info);\n+    }\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n-    let sc_cx = find_scope_cx(cx);\n-    let found = -1;\n-    let i = 0;\n-    for c: cleanup in sc_cx.cleanups {\n-        alt c {\n-          clean_temp(v, _) {\n-            if v as uint == val as uint { found = i; break; }\n-          }\n-          _ { }\n+    in_scope_cx(cx) {|info|\n+        let i = 0u;\n+        for cu in info.cleanups {\n+            alt cu {\n+              clean_temp(v, _) if v == val {\n+                info.cleanups =\n+                    vec::slice(info.cleanups, 0u, i) +\n+                    vec::slice(info.cleanups, i + 1u, info.cleanups.len());\n+                scope_clean_changed(info);\n+                ret;\n+              }\n+              _ {}\n+            }\n+            i += 1u;\n         }\n-        i += 1;\n     }\n-    // The value does not have a cleanup associated with it.\n-    if found == -1 { ret; }\n-    // We found the cleanup and remove it\n-    sc_cx.cleanups =\n-        vec::slice(sc_cx.cleanups, 0u, found as uint) +\n-            vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n-                            sc_cx.cleanups.len());\n-    scope_clean_changed(sc_cx);\n-    ret;\n }\n \n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n@@ -325,47 +323,53 @@ enum block_kind {\n     // cleaned up. May correspond to an actual block in the language, but also\n     // to an implicit scope, for example, calls introduce an implicit scope in\n     // which the arguments are evaluated and cleaned up.\n-    SCOPE_BLOCK,\n-    // A basic block created from the body of a loop.  Contains pointers to\n-    // which block to jump to in the case of \"continue\" or \"break\".\n-    LOOP_SCOPE_BLOCK(option<@block_ctxt>, @block_ctxt),\n+    scope_block(scope_info),\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n     // non-scope block because it doesn't introduce a new variable scope.\n-    NON_SCOPE_BLOCK\n+    non_scope_block,\n }\n \n+enum loop_cont { cont_self, cont_other(@block_ctxt), }\n+\n+type scope_info = {\n+    is_loop: option<{cnt: loop_cont, brk: @block_ctxt}>,\n+    // A list of functions that must be run at when leaving this\n+    // block, cleaning up any variables that were introduced in the\n+    // block.\n+    mutable cleanups: [cleanup],\n+    // Existing cleanup paths that may be reused, indexed by destination and\n+    // cleared when the set of cleanups changes.\n+    mutable cleanup_paths: [cleanup_path],\n+    // Unwinding landing pad. Also cleared when cleanups change.\n+    mutable landing_pad: option<BasicBlockRef>,\n+};\n+\n // Basic block context.  We create a block context for each basic block\n // (single-entry, single-exit sequence of instructions) we generate from Rust\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block_ctxt =\n+type block_ctxt = {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n+    llbb: BasicBlockRef,\n+    mutable terminated: bool,\n+    mutable unreachable: bool,\n+    parent: block_parent,\n     // The 'kind' of basic block this is.\n-    // A list of functions that run at the end of translating this\n-    // block, cleaning up any variables that were introduced in the\n-    // block and need to go out of scope at the end of it.\n-    // The source span where this block comes from, for error\n-    // reporting. FIXME this is not currently reliable\n+    kind: block_kind,\n+    // The source span where the block came from, if it is a block that\n+    // actually appears in the source code.\n+    block_span: option<span>,\n     // The function context for the function to which this block is\n     // attached.\n-    {llbb: BasicBlockRef,\n-     mutable terminated: bool,\n-     mutable unreachable: bool,\n-     parent: block_parent,\n-     kind: block_kind,\n-     // FIXME the next five fields should probably only appear in scope blocks\n-     mutable cleanups: [cleanup],\n-     mutable cleanup_paths: [cleanup_path],\n-     mutable landing_pad: option<BasicBlockRef>,\n-     block_span: option<span>,\n-     fcx: @fn_ctxt};\n+    fcx: @fn_ctxt\n+};\n \n // FIXME: we should be able to use option<@block_parent> here but\n // the infinite-enum check in rustboot gets upset.\n@@ -395,13 +399,15 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n     ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n-fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n+fn in_scope_cx(cx: @block_ctxt, f: fn(scope_info)) {\n     let cur = cx;\n     while true {\n-        if cur.kind != NON_SCOPE_BLOCK { break; }\n+        alt cur.kind {\n+          scope_block(info) { f(info); ret; }\n+          _ {}\n+        }\n         cur = alt check cur.parent { parent_some(b) { b } };\n     }\n-    cur\n }\n \n // Accessors"}]}