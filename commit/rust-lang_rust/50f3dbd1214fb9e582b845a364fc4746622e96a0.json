{"sha": "50f3dbd1214fb9e582b845a364fc4746622e96a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjNkYmQxMjE0ZmI5ZTU4MmI4NDVhMzY0ZmM0NzQ2NjIyZTk2YTA=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-07-06T02:06:37Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-07-16T22:57:03Z"}, "message": "Move hir::Place to librustc_middle/hir\n\nNeeded to support https://github.com/rust-lang/project-rfc-2229/issues/7\n\nCurrently rustc_typeck depends on rustc_middle for definition TypeckTables, etc.\nFor supporting project-rfc-2229#7, rustc_middle would've to depend on\nrustc_typeck for Place -- introducing a circular dependcy.\n\nThis resembles the MIR equivalent of `Place` located in `lbrustc_middle/mir`.\n\nCo-authored-by: Aman Arora <me@aman-arora.com>\nCo-authored-by: Jennifer Wills <wills.jenniferg@gmail.com>\nCo-authored-by: Logan Mosier <logmosier@gmail.com>", "tree": {"sha": "07dfae3f3a3c0588c3ec75d5842e62f3d2f3270c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07dfae3f3a3c0588c3ec75d5842e62f3d2f3270c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f3dbd1214fb9e582b845a364fc4746622e96a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f3dbd1214fb9e582b845a364fc4746622e96a0", "html_url": "https://github.com/rust-lang/rust/commit/50f3dbd1214fb9e582b845a364fc4746622e96a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f3dbd1214fb9e582b845a364fc4746622e96a0/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c9e5df3a097e094641f16dab501ab1c4da10e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9e5df3a097e094641f16dab501ab1c4da10e9f", "html_url": "https://github.com/rust-lang/rust/commit/5c9e5df3a097e094641f16dab501ab1c4da10e9f"}], "stats": {"total": 274, "additions": 141, "deletions": 133}, "files": [{"sha": "b014f3c8eb7949635854fa1618581e7e5b4a660a", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -4,6 +4,7 @@\n \n pub mod exports;\n pub mod map;\n+pub mod place;\n \n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;"}, {"sha": "d85165bcccfdc99cf38fc11348f60787bdc0a9b3", "filename": "src/librustc_middle/hir/place.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fplace.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -0,0 +1,115 @@\n+use crate::ty;\n+use crate::ty::Ty;\n+\n+use rustc_hir::HirId;\n+use rustc_target::abi::VariantIdx;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum PlaceBase {\n+    /// A temporary variable\n+    Rvalue,\n+    /// A named `static` item\n+    StaticItem,\n+    /// A named local variable\n+    Local(HirId),\n+    /// An upvar referenced by closure env\n+    Upvar(ty::UpvarId),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ProjectionKind {\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    Deref,\n+\n+    /// `B.F` where `B` is the base expression and `F` is\n+    /// the field. The field is identified by which variant\n+    /// it appears in along with a field index. The variant\n+    /// is used for enums.\n+    Field(u32, VariantIdx),\n+\n+    /// Some index like `B[x]`, where `B` is the base\n+    /// expression. We don't preserve the index `x` because\n+    /// we won't need it.\n+    Index,\n+\n+    /// A subslice covering a range of values like `B[x..y]`.\n+    Subslice,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Projection<'tcx> {\n+    /// Type after the projection is being applied.\n+    pub ty: Ty<'tcx>,\n+\n+    /// Defines the type of access\n+    pub kind: ProjectionKind,\n+}\n+\n+/// A `Place` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Place<'tcx> {\n+    /// The type of the `PlaceBase`\n+    pub base_ty: Ty<'tcx>,\n+    /// The \"outermost\" place that holds this value.\n+    pub base: PlaceBase,\n+    /// How this place is derived from the base place.\n+    pub projections: Vec<Projection<'tcx>>,\n+}\n+\n+/// A `PlaceWithHirId` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct PlaceWithHirId<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: HirId,\n+\n+    /// Information about the `Place`\n+    pub place: Place<'tcx>,\n+}\n+\n+impl<'tcx> PlaceWithHirId<'tcx> {\n+    pub fn new(\n+        hir_id: HirId,\n+        base_ty: Ty<'tcx>,\n+        base: PlaceBase,\n+        projections: Vec<Projection<'tcx>>,\n+    ) -> PlaceWithHirId<'tcx> {\n+        PlaceWithHirId {\n+            hir_id: hir_id,\n+            place: Place { base_ty: base_ty, base: base, projections: projections },\n+        }\n+    }\n+}\n+\n+impl<'tcx> Place<'tcx> {\n+    /// Returns an iterator of the types that have to be dereferenced to access\n+    /// the `Place`.\n+    ///\n+    /// The types are in the reverse order that they are applied. So if\n+    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n+    ///`*const u32` then `&*const u32`.\n+    pub fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n+        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n+            if ProjectionKind::Deref == proj.kind {\n+                Some(self.ty_before_projection(index))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the type of this `Place` after all projections have been applied.\n+    pub fn ty(&self) -> Ty<'tcx> {\n+        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n+    }\n+\n+    /// Returns the type of this `Place` immediately before `projection_index`th projection\n+    /// is applied.\n+    pub fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n+        assert!(projection_index < self.projections.len());\n+        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n+    }\n+}"}, {"sha": "06557fcb0e7a2f5f3b0060e3c087260bb2745cd6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -82,6 +82,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n@@ -442,7 +443,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_adjustments(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -483,10 +484,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         span: Span,\n     ) {\n-        if let mc::PlaceBase::Rvalue = place_with_id.place.base {\n+        if let PlaceBase::Rvalue = place_with_id.place.base {\n             if place_with_id.place.projections.is_empty() {\n                 let typ = self.resolve_type(place_with_id.place.ty());\n                 let body_id = self.body_id;\n@@ -573,7 +574,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n+    fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -594,7 +595,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr<'_>,\n-        expr_cmt: &mc::PlaceWithHirId<'tcx>,\n+        expr_cmt: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n@@ -615,7 +616,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::PlaceWithHirId<'tcx>,\n+        cmt_borrowed: &PlaceWithHirId<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -638,7 +639,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_place: &mc::PlaceWithHirId<'tcx>,\n+        borrow_place: &PlaceWithHirId<'tcx>,\n     ) {\n         let origin = infer::DataBorrowed(borrow_place.place.ty(), span);\n         self.type_must_outlive(origin, borrow_place.place.ty(), borrow_region);\n@@ -659,7 +660,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n             }\n         }\n-        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n+        if let PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n             self.link_upvar_region(span, borrow_region, upvar_id);\n         }\n     }"}, {"sha": "3bc5696bf70e8997cfc931c731fcbcd176000a73", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -33,14 +33,13 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use crate::mem_categorization as mc;\n-use crate::mem_categorization::PlaceBase;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::{Span, Symbol};\n \n@@ -270,7 +269,7 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\n@@ -309,7 +308,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -334,7 +333,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -464,12 +463,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         debug!(\"consume(place_with_id={:?},mode={:?})\", place_with_id, mode);\n         self.adjust_upvar_borrow_kind_for_consume(place_with_id, mode);\n     }\n \n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         debug!(\"borrow(place_with_id={:?}, bk={:?})\", place_with_id, bk);\n \n         match bk {\n@@ -483,7 +482,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>) {\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>) {\n         debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_place);"}, {"sha": "ff24cbe7b699b69959ad1e368b82f29dd4072c2a", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -5,14 +5,15 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use mc::{PlaceBase, PlaceWithHirId, Projection};\n+pub use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -27,13 +28,13 @@ use rustc_span::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: ConsumeMode);\n \n     // The value found at `place` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n \n     // The path at `place_with_id` is being assigned to.\n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>);\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             &*with_expr,\n                             with_place.clone(),\n                             with_field.ty(self.tcx(), substs),\n-                            mc::ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n+                            ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n                         );\n                         self.delegate_consume(&field_place);\n                     }\n@@ -462,7 +463,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_autoref(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-        base_place: &mc::PlaceWithHirId<'tcx>,\n+        base_place: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -573,7 +574,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         closure_hir_id: hir::HirId,\n         closure_span: Span,\n         var_id: hir::HirId,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;"}, {"sha": "28169167223626601d56376634a91d58061ba377", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3dbd1214fb9e582b845a364fc4746622e96a0/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=50f3dbd1214fb9e582b845a364fc4746622e96a0", "patch": "@@ -48,6 +48,7 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n+use rustc_middle::hir::place::*;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -64,116 +65,6 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-#[derive(Clone, Debug)]\n-pub enum PlaceBase {\n-    /// A temporary variable\n-    Rvalue,\n-    /// A named `static` item\n-    StaticItem,\n-    /// A named local variable\n-    Local(hir::HirId),\n-    /// An upvar referenced by closure env\n-    Upvar(ty::UpvarId),\n-}\n-\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub enum ProjectionKind {\n-    /// A dereference of a pointer, reference or `Box<T>` of the given type\n-    Deref,\n-\n-    /// `B.F` where `B` is the base expression and `F` is\n-    /// the field. The field is identified by which variant\n-    /// it appears in along with a field index. The variant\n-    /// is used for enums.\n-    Field(u32, VariantIdx),\n-\n-    /// Some index like `B[x]`, where `B` is the base\n-    /// expression. We don't preserve the index `x` because\n-    /// we won't need it.\n-    Index,\n-\n-    /// A subslice covering a range of values like `B[x..y]`.\n-    Subslice,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Projection<'tcx> {\n-    // Type after the projection is being applied.\n-    ty: Ty<'tcx>,\n-\n-    /// Defines the type of access\n-    kind: ProjectionKind,\n-}\n-\n-/// A `Place` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct Place<'tcx> {\n-    /// The type of the `PlaceBase`\n-    pub base_ty: Ty<'tcx>,\n-    /// The \"outermost\" place that holds this value.\n-    pub base: PlaceBase,\n-    /// How this place is derived from the base place.\n-    pub projections: Vec<Projection<'tcx>>,\n-}\n-\n-/// A `PlaceWithHirId` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct PlaceWithHirId<'tcx> {\n-    /// `HirId` of the expression or pattern producing this value.\n-    pub hir_id: hir::HirId,\n-\n-    /// Information about the `Place`\n-    pub place: Place<'tcx>,\n-}\n-\n-impl<'tcx> PlaceWithHirId<'tcx> {\n-    crate fn new(\n-        hir_id: hir::HirId,\n-        base_ty: Ty<'tcx>,\n-        base: PlaceBase,\n-        projections: Vec<Projection<'tcx>>,\n-    ) -> PlaceWithHirId<'tcx> {\n-        PlaceWithHirId {\n-            hir_id: hir_id,\n-            place: Place { base_ty: base_ty, base: base, projections: projections },\n-        }\n-    }\n-}\n-\n-impl<'tcx> Place<'tcx> {\n-    /// Returns an iterator of the types that have to be dereferenced to access\n-    /// the `Place`.\n-    ///\n-    /// The types are in the reverse order that they are applied. So if\n-    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n-    ///`*const u32` then `&*const u32`.\n-    crate fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n-        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n-            if ProjectionKind::Deref == proj.kind {\n-                Some(self.ty_before_projection(index))\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // Returns the type of this `Place` after all projections have been applied.\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n-    }\n-\n-    // Returns the type of this `Place` immediately before `projection_index`th projection\n-    // is applied.\n-    crate fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n-        assert!(projection_index < self.projections.len());\n-        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n-    }\n-}\n-\n crate trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;"}]}