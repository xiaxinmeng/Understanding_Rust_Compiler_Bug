{"sha": "84340db87aed477f61bf46ba5e4a75f3eb672237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MzQwZGI4N2FlZDQ3N2Y2MWJmNDZiYTVlNGE3NWYzZWI2NzIyMzc=", "commit": {"author": {"name": "arsdragonfly", "email": "arsdragonfly@gmail.com", "date": "2019-09-27T20:17:23Z"}, "committer": {"name": "arsdragonfly", "email": "arsdragonfly@gmail.com", "date": "2019-09-27T20:17:23Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer", "tree": {"sha": "af7fe4eb8045ccb1b73bcdcd80b3a729062bd308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af7fe4eb8045ccb1b73bcdcd80b3a729062bd308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84340db87aed477f61bf46ba5e4a75f3eb672237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84340db87aed477f61bf46ba5e4a75f3eb672237", "html_url": "https://github.com/rust-lang/rust/commit/84340db87aed477f61bf46ba5e4a75f3eb672237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84340db87aed477f61bf46ba5e4a75f3eb672237/comments", "author": {"login": "arsdragonfly", "id": 4067473, "node_id": "MDQ6VXNlcjQwNjc0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4067473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arsdragonfly", "html_url": "https://github.com/arsdragonfly", "followers_url": "https://api.github.com/users/arsdragonfly/followers", "following_url": "https://api.github.com/users/arsdragonfly/following{/other_user}", "gists_url": "https://api.github.com/users/arsdragonfly/gists{/gist_id}", "starred_url": "https://api.github.com/users/arsdragonfly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arsdragonfly/subscriptions", "organizations_url": "https://api.github.com/users/arsdragonfly/orgs", "repos_url": "https://api.github.com/users/arsdragonfly/repos", "events_url": "https://api.github.com/users/arsdragonfly/events{/privacy}", "received_events_url": "https://api.github.com/users/arsdragonfly/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arsdragonfly", "id": 4067473, "node_id": "MDQ6VXNlcjQwNjc0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4067473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arsdragonfly", "html_url": "https://github.com/arsdragonfly", "followers_url": "https://api.github.com/users/arsdragonfly/followers", "following_url": "https://api.github.com/users/arsdragonfly/following{/other_user}", "gists_url": "https://api.github.com/users/arsdragonfly/gists{/gist_id}", "starred_url": "https://api.github.com/users/arsdragonfly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arsdragonfly/subscriptions", "organizations_url": "https://api.github.com/users/arsdragonfly/orgs", "repos_url": "https://api.github.com/users/arsdragonfly/repos", "events_url": "https://api.github.com/users/arsdragonfly/events{/privacy}", "received_events_url": "https://api.github.com/users/arsdragonfly/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1988a17f4ceb90bcdaed79072c4b7f647c86854", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1988a17f4ceb90bcdaed79072c4b7f647c86854", "html_url": "https://github.com/rust-lang/rust/commit/d1988a17f4ceb90bcdaed79072c4b7f647c86854"}, {"sha": "21fa889cf3f70c507e3b9f2f6362e65cbb8ed955", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fa889cf3f70c507e3b9f2f6362e65cbb8ed955", "html_url": "https://github.com/rust-lang/rust/commit/21fa889cf3f70c507e3b9f2f6362e65cbb8ed955"}], "stats": {"total": 507, "additions": 378, "deletions": 129}, "files": [{"sha": "419e93330b89f1a2dc9acee3abd56b4b0d3f098c", "filename": "crates/ra_assists/src/assists/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -511,7 +511,7 @@ pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n         hir::PathKind::Plain => {}\n         hir::PathKind::Self_ => ps.push(\"self\".into()),\n         hir::PathKind::Super => ps.push(\"super\".into()),\n-        hir::PathKind::Type(_) => return None,\n+        hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n     }\n     for s in path.segments.iter() {\n         ps.push(s.name.to_string().into());"}, {"sha": "603daed3746e15cf119247779a8c2ccbdb153661", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -32,11 +32,10 @@ pub trait CheckCanceled {\n \n     fn catch_canceled<F, T>(&self, f: F) -> Result<T, Canceled>\n     where\n-        Self: Sized,\n+        Self: Sized + panic::RefUnwindSafe,\n         F: FnOnce(&Self) -> T + panic::UnwindSafe,\n     {\n-        let this = panic::AssertUnwindSafe(self);\n-        panic::catch_unwind(|| f(*this)).map_err(|err| match err.downcast::<Canceled>() {\n+        panic::catch_unwind(|| f(self)).map_err(|err| match err.downcast::<Canceled>() {\n             Ok(canceled) => *canceled,\n             Err(payload) => panic::resume_unwind(payload),\n         })"}, {"sha": "99d28621509a673b2e23c0891a21526d4cbf19d3", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -133,7 +133,7 @@ impl VariantData {\n                     .fields()\n                     .enumerate()\n                     .map(|(i, fd)| StructFieldData {\n-                        name: Name::tuple_field_name(i),\n+                        name: Name::new_tuple_field(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();"}, {"sha": "dc964e1566965d02f1ae8d641fea61151c7c14c2", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -119,7 +119,7 @@ impl HasSource for TypeAlias {\n impl HasSource for MacroDef {\n     type Ast = ast::MacroCall;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::MacroCall> {\n-        Source { file_id: self.id.0.file_id(), ast: self.id.0.to_node(db) }\n+        Source { file_id: self.id.ast_id.file_id(), ast: self.id.ast_id.to_node(db) }\n     }\n }\n "}, {"sha": "6d6f6050656dce763c2d92cded035374ebd24c6c", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -272,8 +272,11 @@ where\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n             ast::Expr::PathExpr(e) => {\n-                let path =\n-                    e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n+                let path = e\n+                    .path()\n+                    .and_then(|path| self.parse_path(path))\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n             ast::Expr::ContinueExpr(_e) => {\n@@ -295,7 +298,7 @@ where\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n-                let path = e.path().and_then(Path::from_ast);\n+                let path = e.path().and_then(|path| self.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n@@ -459,7 +462,7 @@ where\n                     .ast_id(&e)\n                     .with_file_id(self.current_file_id);\n \n-                if let Some(path) = e.path().and_then(Path::from_ast) {\n+                if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n                         let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n@@ -529,7 +532,7 @@ where\n                 Pat::Bind { name, mode: annotation, subpat }\n             }\n             ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::TupleStruct { path, args }\n             }\n@@ -539,7 +542,7 @@ where\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::TuplePat(p) => {\n@@ -548,7 +551,7 @@ where\n             }\n             ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 let record_field_pat_list =\n                     p.record_field_pat_list().expect(\"every struct should have a field list\");\n                 let mut fields: Vec<_> = record_field_pat_list\n@@ -589,6 +592,10 @@ where\n             self.missing_pat()\n         }\n     }\n+\n+    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n+        Path::from_src(Source { ast: path, file_id: self.current_file_id }, self.db)\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "4ce7551c3354735afdd3fbca17ab74cfb7f45c5b", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -132,6 +132,7 @@ impl GenericParams {\n     fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+            // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().and_then(|t| t.path()).and_then(Path::from_ast);\n \n             let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };"}, {"sha": "bcbcd3dd7747d42b1034730ba059b26aa3f27fa6", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{ast, AstNode, Parse, SyntaxNode};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, InternDatabase},\n-    AstId, FileAstId, Module, Source,\n+    AstId, Crate, FileAstId, Module, Source,\n };\n \n /// hir makes heavy use of ids: integer (u32) handlers to various things. You\n@@ -58,6 +58,17 @@ impl HirFileId {\n         }\n     }\n \n+    /// Get the crate which the macro lives in, if it is a macro file.\n+    pub(crate) fn macro_crate(self, db: &impl AstDatabase) -> Option<Crate> {\n+        match self.0 {\n+            HirFileIdRepr::File(_) => None,\n+            HirFileIdRepr::Macro(macro_file) => {\n+                let loc = macro_file.macro_call_id.loc(db);\n+                Some(loc.def.krate)\n+            }\n+        }\n+    }\n+\n     pub(crate) fn parse_or_expand_query(\n         db: &impl AstDatabase,\n         file_id: HirFileId,\n@@ -121,10 +132,13 @@ impl From<FileId> for HirFileId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n+pub struct MacroDefId {\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n+    pub(crate) krate: Crate,\n+}\n \n pub(crate) fn macro_def_query(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n-    let macro_call = id.0.to_node(db);\n+    let macro_call = id.ast_id.to_node(db);\n     let arg = macro_call.token_tree()?;\n     let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n         log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);"}, {"sha": "c66a1c6a6dbb664fdc03a0af2cb09300c54053a8", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -218,7 +218,10 @@ impl ModuleImplBlocks {\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n                     let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n-                    if let Some(path) = macro_call.path().and_then(Path::from_ast) {\n+                    if let Some(path) = macro_call\n+                        .path()\n+                        .and_then(|path| Path::from_src(Source { ast: path, file_id }, db))\n+                    {\n                         if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n                         {\n                             let call_id = MacroCallLoc { def: def.id, ast_id }.id(db);"}, {"sha": "0fed468026ccada81f62461daa52eb0dcd7a0515", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -13,4 +13,6 @@ test_utils::marks!(\n     macro_rules_from_other_crates_are_visible_with_macro_use\n     prelude_is_macro_use\n     coerce_merge_fail_fallback\n+    macro_dollar_crate_self\n+    macro_dollar_crate_other\n );"}, {"sha": "d50867f5dcf9ef68a0e71c5a1302694aa1420c51", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -5,50 +5,60 @@ use ra_syntax::{ast, SmolStr};\n /// `Name` is a wrapper around string, which is used in hir for both references\n /// and declarations. In theory, names should also carry hygiene info, but we are\n /// not there yet!\n-#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct Name {\n-    text: SmolStr,\n-}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Name(Repr);\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.text, f)\n-    }\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+enum Repr {\n+    Text(SmolStr),\n+    TupleField(usize),\n }\n \n-impl fmt::Debug for Name {\n+impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.text, f)\n+        match &self.0 {\n+            Repr::Text(text) => fmt::Display::fmt(&text, f),\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n     }\n }\n \n impl Name {\n     /// Note: this is private to make creating name from random string hard.\n     /// Hopefully, this should allow us to integrate hygiene cleaner in the\n     /// future, and to switch to interned representation of names.\n-    const fn new(text: SmolStr) -> Name {\n-        Name { text }\n+    const fn new_text(text: SmolStr) -> Name {\n+        Name(Repr::Text(text))\n     }\n \n-    pub(crate) fn missing() -> Name {\n-        Name::new(\"[missing name]\".into())\n+    pub(crate) fn new_tuple_field(idx: usize) -> Name {\n+        Name(Repr::TupleField(idx))\n     }\n \n-    pub(crate) fn tuple_field_name(idx: usize) -> Name {\n-        Name::new(idx.to_string().into())\n+    /// Shortcut to create inline plain text name\n+    const fn new_inline_ascii(len: usize, text: &[u8]) -> Name {\n+        Name::new_text(SmolStr::new_inline_from_ascii(len, text))\n     }\n \n-    // There's should be no way to extract a string out of `Name`: `Name` in the\n-    // future, `Name` will include hygiene information, and you can't encode\n-    // hygiene into a String.\n-    //\n-    // If you need to compare something with `Name`, compare `Name`s directly.\n-    //\n-    // If you need to render `Name` for the user, use the `Display` impl, but be\n-    // aware that it strips hygiene info.\n-    #[deprecated(note = \"use to_string instead\")]\n-    pub fn as_smolstr(&self) -> &SmolStr {\n-        &self.text\n+    /// Resolve a name from the text of token.\n+    fn resolve(raw_text: &SmolStr) -> Name {\n+        let raw_start = \"r#\";\n+        if raw_text.as_str().starts_with(raw_start) {\n+            Name::new_text(SmolStr::new(&raw_text[raw_start.len()..]))\n+        } else {\n+            Name::new_text(raw_text.clone())\n+        }\n+    }\n+\n+    pub(crate) fn missing() -> Name {\n+        Name::new_text(\"[missing name]\".into())\n+    }\n+\n+    pub(crate) fn as_tuple_index(&self) -> Option<usize> {\n+        match self.0 {\n+            Repr::TupleField(idx) => Some(idx),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -58,82 +68,73 @@ pub(crate) trait AsName {\n \n impl AsName for ast::NameRef {\n     fn as_name(&self) -> Name {\n-        let name = resolve_name(self.text());\n-        Name::new(name)\n+        match self.as_tuple_field() {\n+            Some(idx) => Name::new_tuple_field(idx),\n+            None => Name::resolve(self.text()),\n+        }\n     }\n }\n \n impl AsName for ast::Name {\n     fn as_name(&self) -> Name {\n-        let name = resolve_name(self.text());\n-        Name::new(name)\n+        Name::resolve(self.text())\n     }\n }\n \n impl AsName for ast::FieldKind {\n     fn as_name(&self) -> Name {\n         match self {\n             ast::FieldKind::Name(nr) => nr.as_name(),\n-            ast::FieldKind::Index(idx) => Name::new(idx.text().clone()),\n+            ast::FieldKind::Index(idx) => Name::new_tuple_field(idx.text().parse().unwrap()),\n         }\n     }\n }\n \n impl AsName for ra_db::Dependency {\n     fn as_name(&self) -> Name {\n-        Name::new(self.name.clone())\n+        Name::new_text(self.name.clone())\n     }\n }\n \n // Primitives\n-pub(crate) const ISIZE: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"isize\"));\n-pub(crate) const I8: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"i8\"));\n-pub(crate) const I16: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i16\"));\n-pub(crate) const I32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i32\"));\n-pub(crate) const I64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"i64\"));\n-pub(crate) const I128: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"i128\"));\n-pub(crate) const USIZE: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"usize\"));\n-pub(crate) const U8: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"u8\"));\n-pub(crate) const U16: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u16\"));\n-pub(crate) const U32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u32\"));\n-pub(crate) const U64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"u64\"));\n-pub(crate) const U128: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"u128\"));\n-pub(crate) const F32: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"f32\"));\n-pub(crate) const F64: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"f64\"));\n-pub(crate) const BOOL: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"bool\"));\n-pub(crate) const CHAR: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"char\"));\n-pub(crate) const STR: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"str\"));\n+pub(crate) const ISIZE: Name = Name::new_inline_ascii(5, b\"isize\");\n+pub(crate) const I8: Name = Name::new_inline_ascii(2, b\"i8\");\n+pub(crate) const I16: Name = Name::new_inline_ascii(3, b\"i16\");\n+pub(crate) const I32: Name = Name::new_inline_ascii(3, b\"i32\");\n+pub(crate) const I64: Name = Name::new_inline_ascii(3, b\"i64\");\n+pub(crate) const I128: Name = Name::new_inline_ascii(4, b\"i128\");\n+pub(crate) const USIZE: Name = Name::new_inline_ascii(5, b\"usize\");\n+pub(crate) const U8: Name = Name::new_inline_ascii(2, b\"u8\");\n+pub(crate) const U16: Name = Name::new_inline_ascii(3, b\"u16\");\n+pub(crate) const U32: Name = Name::new_inline_ascii(3, b\"u32\");\n+pub(crate) const U64: Name = Name::new_inline_ascii(3, b\"u64\");\n+pub(crate) const U128: Name = Name::new_inline_ascii(4, b\"u128\");\n+pub(crate) const F32: Name = Name::new_inline_ascii(3, b\"f32\");\n+pub(crate) const F64: Name = Name::new_inline_ascii(3, b\"f64\");\n+pub(crate) const BOOL: Name = Name::new_inline_ascii(4, b\"bool\");\n+pub(crate) const CHAR: Name = Name::new_inline_ascii(4, b\"char\");\n+pub(crate) const STR: Name = Name::new_inline_ascii(3, b\"str\");\n \n // Special names\n-pub(crate) const SELF_PARAM: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"self\"));\n-pub(crate) const SELF_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Self\"));\n-pub(crate) const MACRO_RULES: Name = Name::new(SmolStr::new_inline_from_ascii(11, b\"macro_rules\"));\n+pub(crate) const SELF_PARAM: Name = Name::new_inline_ascii(4, b\"self\");\n+pub(crate) const SELF_TYPE: Name = Name::new_inline_ascii(4, b\"Self\");\n+pub(crate) const MACRO_RULES: Name = Name::new_inline_ascii(11, b\"macro_rules\");\n \n // Components of known path (value or mod name)\n-pub(crate) const STD: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"std\"));\n-pub(crate) const ITER: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"iter\"));\n-pub(crate) const OPS: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"ops\"));\n-pub(crate) const FUTURE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"future\"));\n-pub(crate) const RESULT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n-pub(crate) const BOXED: Name = Name::new(SmolStr::new_inline_from_ascii(5, b\"boxed\"));\n+pub(crate) const STD: Name = Name::new_inline_ascii(3, b\"std\");\n+pub(crate) const ITER: Name = Name::new_inline_ascii(4, b\"iter\");\n+pub(crate) const OPS: Name = Name::new_inline_ascii(3, b\"ops\");\n+pub(crate) const FUTURE: Name = Name::new_inline_ascii(6, b\"future\");\n+pub(crate) const RESULT: Name = Name::new_inline_ascii(6, b\"result\");\n+pub(crate) const BOXED: Name = Name::new_inline_ascii(5, b\"boxed\");\n \n // Components of known path (type name)\n-pub(crate) const INTO_ITERATOR_TYPE: Name =\n-    Name::new(SmolStr::new_inline_from_ascii(12, b\"IntoIterator\"));\n-pub(crate) const ITEM_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(4, b\"Item\"));\n-pub(crate) const TRY_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\"));\n-pub(crate) const OK_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n-pub(crate) const FUTURE_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Future\"));\n-pub(crate) const RESULT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Result\"));\n-pub(crate) const OUTPUT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n-pub(crate) const TARGET_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Target\"));\n-pub(crate) const BOX_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Box\"));\n-\n-fn resolve_name(text: &SmolStr) -> SmolStr {\n-    let raw_start = \"r#\";\n-    if text.as_str().starts_with(raw_start) {\n-        SmolStr::new(&text[raw_start.len()..])\n-    } else {\n-        text.clone()\n-    }\n-}\n+pub(crate) const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(12, b\"IntoIterator\");\n+pub(crate) const ITEM_TYPE: Name = Name::new_inline_ascii(4, b\"Item\");\n+pub(crate) const TRY_TYPE: Name = Name::new_inline_ascii(3, b\"Try\");\n+pub(crate) const OK_TYPE: Name = Name::new_inline_ascii(2, b\"Ok\");\n+pub(crate) const FUTURE_TYPE: Name = Name::new_inline_ascii(6, b\"Future\");\n+pub(crate) const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n+pub(crate) const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n+pub(crate) const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n+pub(crate) const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");"}, {"sha": "67adcfa2882fa468fd6c03fc333327c95f11ecf4", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -332,6 +332,20 @@ impl CrateDefMap {\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    match krate.root_module(db) {\n+                        Some(module) => {\n+                            tested_by!(macro_dollar_crate_other);\n+                            PerNs::types(module.into())\n+                        }\n+                        None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                    }\n+                }\n+            }\n             PathKind::Crate => {\n                 PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n             }"}, {"sha": "65929c522bb4698b9ed7db1944f027a319436984", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -662,7 +662,10 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n+                let macro_id = MacroDefId {\n+                    ast_id: mac.ast_id.with_file_id(self.file_id),\n+                    krate: self.def_collector.def_map.krate,\n+                };\n                 let macro_ = MacroDef { id: macro_id };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_, mac.export);\n             }"}, {"sha": "c494b95b0e9c36d5a31395b4d9bf662eb222bcae", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -9,7 +9,7 @@ use test_utils::tested_by;\n \n use crate::{\n     db::{AstDatabase, DefDatabase},\n-    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path,\n+    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -71,6 +71,8 @@ impl RawItems {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n             source_map: ImportSourceMap::default(),\n+            file_id,\n+            db,\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n             if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n@@ -192,13 +194,15 @@ pub(super) struct MacroData {\n     pub(super) export: bool,\n }\n \n-struct RawItemsCollector {\n+struct RawItemsCollector<DB> {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n+    file_id: HirFileId,\n+    db: DB,\n }\n \n-impl RawItemsCollector {\n+impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n@@ -300,17 +304,21 @@ impl RawItemsCollector {\n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n \n-        Path::expand_use_item(&use_item, |path, use_tree, is_glob, alias| {\n-            let import_data = ImportData {\n-                path,\n-                alias,\n-                is_glob,\n-                is_prelude,\n-                is_extern_crate: false,\n-                is_macro_use: false,\n-            };\n-            self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n-        })\n+        Path::expand_use_item(\n+            Source { ast: use_item, file_id: self.file_id },\n+            self.db,\n+            |path, use_tree, is_glob, alias| {\n+                let import_data = ImportData {\n+                    path,\n+                    alias,\n+                    is_glob,\n+                    is_prelude,\n+                    is_extern_crate: false,\n+                    is_macro_use: false,\n+                };\n+                self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n+            },\n+        )\n     }\n \n     fn add_extern_crate_item(\n@@ -335,7 +343,10 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n-        let path = match m.path().and_then(Path::from_ast) {\n+        let path = match m\n+            .path()\n+            .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n+        {\n             Some(it) => it,\n             _ => return,\n         };"}, {"sha": "e4b4083948a6dfdb92860d89ccf288098ff47121", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -515,3 +515,108 @@ fn path_qualified_macros() {\n         \u22eenot_found: _\n     \"###);\n }\n+\n+#[test]\n+fn macro_dollar_crate_is_correct_in_item() {\n+    covers!(macro_dollar_crate_self);\n+    covers!(macro_dollar_crate_other);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        #[macro_use]\n+        extern crate foo;\n+\n+        #[macro_use]\n+        mod m {\n+            macro_rules! current {\n+                () => {\n+                    use $crate::Foo as FooSelf;\n+                }\n+            }\n+        }\n+\n+        struct Foo;\n+\n+        current!();\n+        not_current1!();\n+        foo::not_current2!();\n+\n+        //- /lib.rs\n+        mod m {\n+            #[macro_export]\n+            macro_rules! not_current1 {\n+                () => {\n+                    use $crate::Bar;\n+                }\n+            }\n+        }\n+\n+        #[macro_export]\n+        macro_rules! not_current2 {\n+            () => {\n+                use $crate::Baz;\n+            }\n+        }\n+\n+        struct Bar;\n+        struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eeBaz: t v\n+        \u22eeFoo: t v\n+        \u22eeFooSelf: t v\n+        \u22eefoo: t\n+        \u22eem: t\n+        \u22ee\n+        \u22eecrate::m\n+    \"###);\n+}\n+\n+#[test]\n+fn macro_dollar_crate_is_correct_in_indirect_deps() {\n+    covers!(macro_dollar_crate_other);\n+    // From std\n+    let map = def_map_with_crate_graph(\n+        r#\"\n+        //- /main.rs\n+        foo!();\n+\n+        //- /std.rs\n+        #[prelude_import]\n+        use self::prelude::*;\n+\n+        pub use core::foo;\n+\n+        mod prelude {}\n+\n+        #[macro_use]\n+        mod std_macros;\n+\n+        //- /core.rs\n+        #[macro_export]\n+        macro_rules! foo {\n+            () => {\n+                use $crate::bar;\n+            }\n+        }\n+\n+        pub struct bar;\n+        \"#,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"std\"]),\n+            \"std\": (\"/std.rs\", [\"core\"]),\n+            \"core\": (\"/core.rs\", []),\n+        },\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eebar: t v\n+    \"###);\n+}"}, {"sha": "158c853d42d100daf7961bfdf0de773f99e4dc0e", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{name, type_ref::TypeRef, AsName, Name};\n+use crate::{db::AstDatabase, name, type_ref::TypeRef, AsName, Crate, Name, Source};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -52,16 +52,19 @@ pub enum PathKind {\n     Abs,\n     // Type based path like `<T>::foo`\n     Type(Box<TypeRef>),\n+    // `$crate` from macro expansion\n+    DollarCrate(Crate),\n }\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n     pub fn expand_use_item(\n-        item: &ast::UseItem,\n+        item_src: Source<ast::UseItem>,\n+        db: &impl AstDatabase,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n-        if let Some(tree) = item.use_tree() {\n-            expand_use_tree(None, tree, &mut cb);\n+        if let Some(tree) = item_src.ast.use_tree() {\n+            expand_use_tree(None, tree, &|| item_src.file_id.macro_crate(db), &mut cb);\n         }\n     }\n \n@@ -76,7 +79,19 @@ impl Path {\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    /// DEPRECATED: It does not handle `$crate` from macro call.\n+    pub fn from_ast(path: ast::Path) -> Option<Path> {\n+        Path::parse(path, &|| None)\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    /// It correctly handles `$crate` based path from macro call.\n+    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n+        let file_id = source.file_id;\n+        Path::parse(source.ast, &|| file_id.macro_crate(db))\n+    }\n+\n+    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<Crate>) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -88,6 +103,13 @@ impl Path {\n \n             match segment.kind()? {\n                 ast::PathSegmentKind::Name(name) => {\n+                    if name.text() == \"$crate\" {\n+                        if let Some(macro_crate) = macro_crate() {\n+                            kind = PathKind::DollarCrate(macro_crate);\n+                            break;\n+                        }\n+                    }\n+\n                     let args = segment\n                         .type_arg_list()\n                         .and_then(GenericArgs::from_ast)\n@@ -113,7 +135,7 @@ impl Path {\n                         }\n                         // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                         Some(trait_ref) => {\n-                            let path = Path::from_ast(trait_ref.path()?)?;\n+                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n                             kind = path.kind;\n                             let mut prefix_segments = path.segments;\n                             prefix_segments.reverse();\n@@ -264,6 +286,7 @@ impl From<Name> for Path {\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,\n+    macro_crate: &impl Fn() -> Option<Crate>,\n     cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n@@ -272,13 +295,13 @@ fn expand_use_tree(\n             None => prefix,\n             // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path) {\n+            Some(path) => match convert_path(prefix, path, macro_crate) {\n                 Some(it) => Some(it),\n                 None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, cb);\n+            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n         }\n     } else {\n         let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n@@ -295,7 +318,7 @@ fn expand_use_tree(\n                     }\n                 }\n             }\n-            if let Some(path) = convert_path(prefix, ast_path) {\n+            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n                 let is_glob = tree.has_star();\n                 cb(path, &tree, is_glob, alias)\n             }\n@@ -305,12 +328,29 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n-    let prefix =\n-        if let Some(qual) = path.qualifier() { Some(convert_path(prefix, qual)?) } else { prefix };\n+fn convert_path(\n+    prefix: Option<Path>,\n+    path: ast::Path,\n+    macro_crate: &impl Fn() -> Option<Crate>,\n+) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual, macro_crate)?)\n+    } else {\n+        prefix\n+    };\n+\n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name) => {\n+            if name.text() == \"$crate\" {\n+                if let Some(krate) = macro_crate() {\n+                    return Some(Path::from_simple_segments(\n+                        PathKind::DollarCrate(krate),\n+                        iter::empty(),\n+                    ));\n+                }\n+            }\n+\n             // no type args in use\n             let mut res = prefix\n                 .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });"}, {"sha": "6e89bfc76581cdfaa21021c83235b6e36b463a48", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -203,6 +203,7 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         macro_call: &ast::MacroCall,\n     ) -> Option<MacroDef> {\n+        // This must be a normal source file rather than macro file.\n         let path = macro_call.path().and_then(Path::from_ast)?;\n         self.resolver.resolve_path_as_macro(db, &path)\n     }\n@@ -261,6 +262,7 @@ impl SourceAnalyzer {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n+        // This must be a normal source file rather than macro file.\n         let hir_path = crate::Path::from_ast(path.clone())?;\n         self.resolve_hir_path(db, &hir_path)\n     }"}, {"sha": "2e4a489a0df23faa0a747e4f50aac2c9cc7e0178", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -609,7 +609,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         for (i, &subpat) in subpats.iter().enumerate() {\n             let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n+                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n@@ -1374,10 +1374,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 )\n                 .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n                     Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Tuple { .. } => {\n-                            let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n-                        }\n+                        TypeCtor::Tuple { .. } => name\n+                            .as_tuple_index()\n+                            .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n                         TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n                             self.write_field_resolution(tgt_expr, field);\n                             field.ty(self.db).subst(&a_ty.parameters)"}, {"sha": "4df39c1915f09c86a10cffef0eafd7bf70f58e1b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -3130,6 +3130,39 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n+    covers!(macro_dollar_crate_other);\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let x = (foo::foo!(1), foo::foo!(2));\n+    x<|>;\n+}\n+\n+//- /lib.rs\n+#[macro_export]\n+macro_rules! foo {\n+    (1) => { $crate::bar!() };\n+    (2) => { 1 + $crate::baz() };\n+}\n+\n+#[macro_export]\n+macro_rules! bar {\n+    () => { 42 }\n+}\n+\n+pub fn baz() -> usize { 31usize }\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"foo\"]),\n+        \"foo\": (\"/lib.rs\", []),\n+    });\n+    assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {"}, {"sha": "90a11ac7d58d418f43bc491a3efa7e41088902b0", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -30,6 +30,9 @@ impl PartialEq for TraitSolver {\n \n impl Eq for TraitSolver {}\n \n+// FIXME: this impl is WRONG, chalk is not RefUnwindSafe, and this causes #1927\n+impl std::panic::RefUnwindSafe for TraitSolver {}\n+\n impl TraitSolver {\n     fn solve(\n         &self,"}, {"sha": "2cf06b25044483f5e17979818cb5b38c742e3998", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -72,6 +72,7 @@ impl TypeRef {\n             }\n             ast::TypeRef::NeverType(..) => TypeRef::Never,\n             ast::TypeRef::PathType(inner) => {\n+                // FIXME: Use `Path::from_src`\n                 inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n             }\n             ast::TypeRef::PointerType(inner) => {\n@@ -141,6 +142,7 @@ impl TypeBound {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };\n+                // FIXME: Use `Path::from_src`\n                 let path = match Path::from_ast(path) {\n                     Some(p) => p,\n                     None => return TypeBound::Error,"}, {"sha": "ed094d5bb49c4b65024741325f4b9ff17e95b66f", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -86,7 +86,7 @@ fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> Result<tt::Sub\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError> {\n     let res = if v == \"crate\" {\n-        // FIXME: Properly handle $crate token\n+        // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n         let tt =\n             tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n                 .into();"}, {"sha": "0433edb84e66ec7e3d4cc268e4c431104cc43d34", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84340db87aed477f61bf46ba5e4a75f3eb672237/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=84340db87aed477f61bf46ba5e4a75f3eb672237", "patch": "@@ -21,6 +21,16 @@ impl ast::NameRef {\n     pub fn text(&self) -> &SmolStr {\n         text_of_first_token(self.syntax())\n     }\n+\n+    pub fn as_tuple_field(&self) -> Option<usize> {\n+        self.syntax().children_with_tokens().find_map(|c| {\n+            if c.kind() == SyntaxKind::INT_NUMBER {\n+                c.as_token().and_then(|tok| tok.text().as_str().parse().ok())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n }\n \n fn text_of_first_token(node: &SyntaxNode) -> &SmolStr {"}]}