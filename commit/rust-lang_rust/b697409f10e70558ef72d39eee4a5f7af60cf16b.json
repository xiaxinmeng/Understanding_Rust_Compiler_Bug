{"sha": "b697409f10e70558ef72d39eee4a5f7af60cf16b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OTc0MDlmMTBlNzA1NThlZjcyZDM5ZWVlNGE1ZjdhZjYwY2YxNmI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-13T04:19:01Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-13T09:36:03Z"}, "message": "Remove bitslice.rs.\n\nThis requires the following changes.\n\n- It moves parts of bitslice.rs into bitvec.rs: `bitwise()`,\n  `BitwiseOperator`, `bits_to_string()`.\n\n- It changes `IdxSet` to just be a wrapper around `BitArray`.\n\n- It changes `BitArray` and `BitVec` to use `usize` words instead of\n  `u128` words. (`BitSlice` and `IdxSet` already use `usize`.) Local\n  profiling showed `usize` was better.\n\n- It moves some operations from `IdxSet` into `BitArray`:\n  `new_filled()`, `clear()`, `set_up_to()`, `trim_to()` (renamed\n  `clear_above()`), `words()` and `words_mut()`, `encode()` and\n  `decode(). The `IdxSet` operations now just call the `BitArray`\n  operations.\n\n- It replaces `BitArray`'s iterator implementation with `IdxSet`'s,\n  because the latter is more concise. It also removes the buggy\n  `size_hint` function from `BitArray`'s iterator, which counted the\n  number of *words* rather than the number of *bits*. `IdxSet`'s\n  iterator is now just a thin wrapper around `BitArray`'s iterator.\n\n- It moves some unit tests from `indexed_set.rs` to `bitvec.rs`.", "tree": {"sha": "320172bde65674b3cbe4f25cff748c923d5b4b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/320172bde65674b3cbe4f25cff748c923d5b4b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b697409f10e70558ef72d39eee4a5f7af60cf16b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b697409f10e70558ef72d39eee4a5f7af60cf16b", "html_url": "https://github.com/rust-lang/rust/commit/b697409f10e70558ef72d39eee4a5f7af60cf16b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b697409f10e70558ef72d39eee4a5f7af60cf16b/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755fcae75e9634e6a11651f46d17d7b1310f821b", "url": "https://api.github.com/repos/rust-lang/rust/commits/755fcae75e9634e6a11651f46d17d7b1310f821b", "html_url": "https://github.com/rust-lang/rust/commit/755fcae75e9634e6a11651f46d17d7b1310f821b"}], "stats": {"total": 546, "additions": 225, "deletions": 321}, "files": [{"sha": "a63033c436528bc866e32f5877f17f86be911a32", "filename": "src/librustc_data_structures/bitslice.rs", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/755fcae75e9634e6a11651f46d17d7b1310f821b/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755fcae75e9634e6a11651f46d17d7b1310f821b/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=755fcae75e9634e6a11651f46d17d7b1310f821b", "patch": "@@ -1,146 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: merge with `bitvec`\n-\n-use std::mem;\n-\n-pub type Word = usize;\n-\n-/// `BitSlice` provides helper methods for treating a `[Word]`\n-/// as a bitvector.\n-pub trait BitSlice {\n-    fn clear_bit(&mut self, idx: usize) -> bool;\n-    fn set_bit(&mut self, idx: usize) -> bool;\n-    fn get_bit(&self, idx: usize) -> bool;\n-}\n-\n-impl BitSlice for [Word] {\n-    /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n-    #[inline]\n-    fn clear_bit(&mut self, idx: usize) -> bool {\n-        let words = self;\n-        debug!(\"clear_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<Word>() * 8), idx);\n-        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n-        debug!(\"word={} bit_in_word={} bit_mask=0x{:x}\", word, bit_in_word, bit_mask);\n-        let oldv = words[word];\n-        let newv = oldv & !bit_mask;\n-        words[word] = newv;\n-        oldv != newv\n-    }\n-\n-    /// Sets bit at `idx` to 1; returns true iff this changed `self.`\n-    #[inline]\n-    fn set_bit(&mut self, idx: usize) -> bool {\n-        let words = self;\n-        debug!(\"set_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<Word>() * 8), idx);\n-        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n-        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n-        let oldv = words[word];\n-        let newv = oldv | bit_mask;\n-        words[word] = newv;\n-        oldv != newv\n-    }\n-\n-    /// Extracts value of bit at `idx` in `self`.\n-    #[inline]\n-    fn get_bit(&self, idx: usize) -> bool {\n-        let words = self;\n-        let BitLookup { word, bit_mask, .. } = bit_lookup(idx);\n-        (words[word] & bit_mask) != 0\n-    }\n-}\n-\n-struct BitLookup {\n-    /// An index of the word holding the bit in original `[Word]` of query.\n-    word: usize,\n-    /// Index of the particular bit within the word holding the bit.\n-    bit_in_word: usize,\n-    /// Word with single 1-bit set corresponding to where the bit is located.\n-    bit_mask: Word,\n-}\n-\n-#[inline]\n-fn bit_lookup(bit: usize) -> BitLookup {\n-    let word_bits = mem::size_of::<Word>() * 8;\n-    let word = bit / word_bits;\n-    let bit_in_word = bit % word_bits;\n-    let bit_mask = 1 << bit_in_word;\n-    BitLookup { word, bit_in_word, bit_mask }\n-}\n-\n-pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n-    let mut result = String::new();\n-    let mut sep = '[';\n-\n-    // Note: this is a little endian printout of bytes.\n-\n-    // i tracks how many bits we have printed so far.\n-    let mut i = 0;\n-    for &word in words.iter() {\n-        let mut v = word;\n-        for _ in 0..mem::size_of::<Word>() { // for each byte in `v`:\n-            let remain = bits - i;\n-            // If less than a byte remains, then mask just that many bits.\n-            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n-            assert!(mask <= 0xFF);\n-            let byte = v & mask;\n-\n-            result.push_str(&format!(\"{}{:02x}\", sep, byte));\n-\n-            if remain <= 8 { break; }\n-            v >>= 8;\n-            i += 8;\n-            sep = '-';\n-        }\n-        sep = '|';\n-    }\n-    result.push(']');\n-\n-    result\n-}\n-\n-#[inline]\n-pub fn bitwise<Op:BitwiseOperator>(out_vec: &mut [Word],\n-                                   in_vec: &[Word],\n-                                   op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n-    fn join(&self, pred1: Word, pred2: Word) -> Word;\n-}\n-\n-pub struct Intersect;\n-impl BitwiseOperator for Intersect {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & b }\n-}\n-pub struct Union;\n-impl BitwiseOperator for Union {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a | b }\n-}\n-pub struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & !b }\n-}"}, {"sha": "52cc347f8e771c1dbfe4ecaf4d0554b5552615af", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 200, "deletions": 37, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n+use rustc_serialize;\n+use std::iter;\n use std::marker::PhantomData;\n+use std::slice;\n \n-type Word = u128;\n-const WORD_BITS: usize = 128;\n+pub type Word = u64;\n+pub const WORD_BYTES: usize = ::std::mem::size_of::<Word>();\n+pub const WORD_BITS: usize = WORD_BYTES * 8;\n \n /// A very simple BitArray type.\n ///\n /// It does not support resizing after creation; use `BitVector` for that.\n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, Eq, PartialEq)]\n pub struct BitArray<C: Idx> {\n     data: Vec<Word>,\n     marker: PhantomData<C>,\n@@ -27,28 +31,69 @@ impl<C: Idx> BitArray<C> {\n     // Do not make this method public, instead switch your use case to BitVector.\n     #[inline]\n     fn grow(&mut self, num_bits: C) {\n-        let num_words = words(num_bits);\n+        let num_words = num_words(num_bits);\n         if self.data.len() <= num_words {\n             self.data.resize(num_words + 1, 0)\n         }\n     }\n \n     #[inline]\n     pub fn new(num_bits: usize) -> BitArray<C> {\n-        let num_words = words(num_bits);\n+        BitArray::new_empty(num_bits)\n+    }\n+\n+    #[inline]\n+    pub fn new_empty(num_bits: usize) -> BitArray<C> {\n+        let num_words = num_words(num_bits);\n         BitArray {\n             data: vec![0; num_words],\n             marker: PhantomData,\n         }\n     }\n \n+    #[inline]\n+    pub fn new_filled(num_bits: usize) -> BitArray<C> {\n+        let num_words = num_words(num_bits);\n+        let mut result = BitArray {\n+            data: vec![!0; num_words],\n+            marker: PhantomData,\n+        };\n+        result.clear_above(num_bits);\n+        result\n+    }\n+\n     #[inline]\n     pub fn clear(&mut self) {\n         for p in &mut self.data {\n             *p = 0;\n         }\n     }\n \n+    /// Sets all elements up to `num_bits`.\n+    pub fn set_up_to(&mut self, num_bits: usize) {\n+        for p in &mut self.data {\n+            *p = !0;\n+        }\n+        self.clear_above(num_bits);\n+    }\n+\n+    /// Clear all elements above `num_bits`.\n+    fn clear_above(&mut self, num_bits: usize) {\n+        let first_clear_block = num_bits / WORD_BITS;\n+\n+        if first_clear_block < self.data.len() {\n+            // Within `first_clear_block`, the `num_bits % WORD_BITS` LSBs\n+            // should remain.\n+            let mask = (1 << (num_bits % WORD_BITS)) - 1;\n+            self.data[first_clear_block] &= mask;\n+\n+            // All the blocks above `first_clear_block` are fully cleared.\n+            for b in &mut self.data[first_clear_block + 1..] {\n+                *b = 0;\n+            }\n+        }\n+    }\n+\n     pub fn count(&self) -> usize {\n         self.data.iter().map(|e| e.count_ones() as usize).sum()\n     }\n@@ -88,7 +133,7 @@ impl<C: Idx> BitArray<C> {\n     /// Sets all bits to true.\n     pub fn insert_all(&mut self) {\n         for data in &mut self.data {\n-            *data = u128::max_value();\n+            *data = !0;\n         }\n     }\n \n@@ -117,53 +162,132 @@ impl<C: Idx> BitArray<C> {\n         changed\n     }\n \n+    pub fn words(&self) -> &[Word] {\n+        &self.data\n+    }\n+\n+    pub fn words_mut(&mut self) -> &mut [Word] {\n+        &mut self.data\n+    }\n+\n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitIter<'a, C> {\n         BitIter {\n-            iter: self.data.iter(),\n-            current: 0,\n-            idx: 0,\n+            cur: None,\n+            iter: self.data.iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n }\n \n+impl<T: Idx> rustc_serialize::Encodable for BitArray<T> {\n+    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.data.encode(encoder)\n+    }\n+}\n+\n+impl<T: Idx> rustc_serialize::Decodable for BitArray<T> {\n+    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitArray<T>, D::Error> {\n+        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n+        Ok(BitArray {\n+            data: words,\n+            marker: PhantomData,\n+        })\n+    }\n+}\n+\n pub struct BitIter<'a, C: Idx> {\n-    iter: ::std::slice::Iter<'a, Word>,\n-    current: Word,\n-    idx: usize,\n+    cur: Option<(Word, usize)>,\n+    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n     marker: PhantomData<C>\n }\n \n impl<'a, C: Idx> Iterator for BitIter<'a, C> {\n     type Item = C;\n     fn next(&mut self) -> Option<C> {\n-        while self.current == 0 {\n-            self.current = if let Some(&i) = self.iter.next() {\n-                if i == 0 {\n-                    self.idx += WORD_BITS;\n-                    continue;\n-                } else {\n-                    self.idx = words(self.idx) * WORD_BITS;\n-                    i\n+        loop {\n+            if let Some((ref mut word, offset)) = self.cur {\n+                let bit_pos = word.trailing_zeros() as usize;\n+                if bit_pos != WORD_BITS {\n+                    let bit = 1 << bit_pos;\n+                    *word ^= bit;\n+                    return Some(C::new(bit_pos + offset))\n                 }\n-            } else {\n-                return None;\n             }\n-        }\n-        let offset = self.current.trailing_zeros() as usize;\n-        self.current >>= offset;\n-        self.current >>= 1; // shift otherwise overflows for 0b1000_0000_\u2026_0000\n-        self.idx += offset + 1;\n \n-        Some(C::new(self.idx - 1))\n+            let (i, word) = self.iter.next()?;\n+            self.cur = Some((*word, WORD_BITS * i));\n+        }\n     }\n+}\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n+pub trait BitwiseOperator {\n+    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n+    fn join(&self, pred1: Word, pred2: Word) -> Word;\n+}\n+\n+#[inline]\n+pub fn bitwise<Op: BitwiseOperator>(out_vec: &mut [Word], in_vec: &[Word], op: &Op) -> bool\n+{\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n+        let old_val = *out_elem;\n+        let new_val = op.join(old_val, *in_elem);\n+        *out_elem = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+pub struct Intersect;\n+impl BitwiseOperator for Intersect {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a & b }\n+}\n+\n+pub struct Union;\n+impl BitwiseOperator for Union {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a | b }\n+}\n+\n+pub struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a & !b }\n+}\n+\n+pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n+    let mut result = String::new();\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    // i tracks how many bits we have printed so far.\n+    let mut i = 0;\n+    for &word in words.iter() {\n+        let mut v = word;\n+        for _ in 0..WORD_BYTES { // for each byte in `v`:\n+            let remain = bits - i;\n+            // If less than a byte remains, then mask just that many bits.\n+            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+            assert!(mask <= 0xFF);\n+            let byte = v & mask;\n+\n+            result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+\n+            if remain <= 8 { break; }\n+            v >>= 8;\n+            i += 8;\n+            sep = '-';\n+        }\n+        sep = '|';\n     }\n+    result.push(']');\n+\n+    result\n }\n \n /// A resizable BitVector type.\n@@ -218,7 +342,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n-        let words_per_row = words(columns);\n+        let words_per_row = num_words(columns);\n         BitMatrix {\n             columns,\n             vector: vec![0; rows * words_per_row],\n@@ -229,7 +353,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n         let row = row.index();\n-        let words_per_row = words(self.columns);\n+        let words_per_row = num_words(self.columns);\n         let start = row * words_per_row;\n         (start, start + words_per_row)\n     }\n@@ -307,9 +431,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n         let (start, end) = self.range(row);\n         BitIter {\n-            iter: self.vector[start..end].iter(),\n-            current: 0,\n-            idx: 0,\n+            cur: None,\n+            iter: self.vector[start..end].iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n@@ -418,7 +541,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n }\n \n #[inline]\n-fn words<C: Idx>(elements: C) -> usize {\n+fn num_words<C: Idx>(elements: C) -> usize {\n     (elements.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n@@ -430,6 +553,46 @@ fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n     (word, mask)\n }\n \n+#[test]\n+fn test_clear_above() {\n+    use std::cmp;\n+\n+    for i in 0..256 {\n+        let mut idx_buf: BitArray<usize> = BitArray::new_filled(128);\n+        idx_buf.clear_above(i);\n+\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn test_set_up_to() {\n+    for i in 0..128 {\n+        for mut idx_buf in\n+            vec![BitArray::new_empty(128), BitArray::new_filled(128)]\n+            .into_iter()\n+        {\n+            idx_buf.set_up_to(i);\n+\n+            let elems: Vec<usize> = idx_buf.iter().collect();\n+            let expected: Vec<usize> = (0..i).collect();\n+            assert_eq!(elems, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_new_filled() {\n+    for i in 0..128 {\n+        let idx_buf = BitArray::new_filled(i);\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..i).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n #[test]\n fn bitvec_iter_works() {\n     let mut bitvec: BitArray<usize> = BitArray::new(100);"}, {"sha": "be519e7bbdeb7485d53958596af007da5cbb3302", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 21, "deletions": 133, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -10,12 +10,9 @@\n \n use array_vec::ArrayVec;\n use std::fmt;\n-use std::iter;\n-use std::marker::PhantomData;\n use std::mem;\n use std::slice;\n-use bitslice::{BitSlice, Word};\n-use bitslice::{bitwise, Union, Subtract, Intersect};\n+use bitvec::{bitwise, BitArray, BitIter, Intersect, Subtract, Union, Word, WORD_BITS};\n use indexed_vec::Idx;\n use rustc_serialize;\n \n@@ -40,39 +37,21 @@ pub trait SubtractFromIdxSet<T: Idx> {\n /// this type uses to represent the set of object it holds.\n ///\n /// The representation is dense, using one bit per possible element.\n-#[derive(Eq, PartialEq)]\n-pub struct IdxSet<T: Idx> {\n-    _pd: PhantomData<fn(&T)>,\n-    bits: Vec<Word>,\n-}\n-\n-impl<T: Idx> Clone for IdxSet<T> {\n-    fn clone(&self) -> Self {\n-        IdxSet { _pd: PhantomData, bits: self.bits.clone() }\n-    }\n-}\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct IdxSet<T: Idx>(BitArray<T>);\n \n impl<T: Idx> rustc_serialize::Encodable for IdxSet<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self,\n-                                     encoder: &mut E)\n-                                     -> Result<(), E::Error> {\n-        self.bits.encode(encoder)\n+    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.0.encode(encoder)\n     }\n }\n \n impl<T: Idx> rustc_serialize::Decodable for IdxSet<T> {\n     fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSet<T>, D::Error> {\n-        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n-\n-        Ok(IdxSet {\n-            _pd: PhantomData,\n-            bits: words,\n-        })\n+        Ok(IdxSet(rustc_serialize::Decodable::decode(d)?))\n     }\n }\n \n-const BITS_PER_WORD: usize = mem::size_of::<Word>() * 8;\n-\n impl<T: Idx> fmt::Debug for IdxSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()\n@@ -82,92 +61,57 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n }\n \n impl<T: Idx> IdxSet<T> {\n-    fn new(init: Word, domain_size: usize) -> Self {\n-        let num_words = (domain_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n-        IdxSet {\n-            _pd: Default::default(),\n-            bits: vec![init; num_words],\n-        }\n+    /// Creates set holding no elements.\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        IdxSet(BitArray::new_empty(domain_size))\n     }\n \n     /// Creates set holding every element whose index falls in range 0..domain_size.\n     pub fn new_filled(domain_size: usize) -> Self {\n-        let mut result = Self::new(!0, domain_size);\n-        result.trim_to(domain_size);\n-        result\n-    }\n-\n-    /// Creates set holding no elements.\n-    pub fn new_empty(domain_size: usize) -> Self {\n-        Self::new(0, domain_size)\n+        IdxSet(BitArray::new_filled(domain_size))\n     }\n \n     /// Duplicates as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n         // This domain_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.bits.len() * BITS_PER_WORD;\n+        let domain_size = self.words().len() * WORD_BITS;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n         HybridIdxSet::Dense(self.to_owned(), domain_size)\n     }\n \n     /// Removes all elements\n     pub fn clear(&mut self) {\n-        for b in &mut self.bits {\n-            *b = 0;\n-        }\n+        self.0.clear();\n     }\n \n     /// Sets all elements up to `domain_size`\n     pub fn set_up_to(&mut self, domain_size: usize) {\n-        for b in &mut self.bits {\n-            *b = !0;\n-        }\n-        self.trim_to(domain_size);\n-    }\n-\n-    /// Clear all elements above `domain_size`.\n-    fn trim_to(&mut self, domain_size: usize) {\n-        // `trim_block` is the first block where some bits have\n-        // to be cleared.\n-        let trim_block = domain_size / BITS_PER_WORD;\n-\n-        // all the blocks above it have to be completely cleared.\n-        if trim_block < self.bits.len() {\n-            for b in &mut self.bits[trim_block+1..] {\n-                *b = 0;\n-            }\n-\n-            // at that block, the `domain_size % BITS_PER_WORD` LSBs\n-            // should remain.\n-            let remaining_bits = domain_size % BITS_PER_WORD;\n-            let mask = (1<<remaining_bits)-1;\n-            self.bits[trim_block] &= mask;\n-        }\n+        self.0.set_up_to(domain_size);\n     }\n \n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n-        self.bits.clear_bit(elem.index())\n+        self.0.remove(*elem)\n     }\n \n     /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n-        self.bits.set_bit(elem.index())\n+        self.0.insert(*elem)\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n-        self.bits.get_bit(elem.index())\n+        self.0.contains(*elem)\n     }\n \n     pub fn words(&self) -> &[Word] {\n-        &self.bits\n+        self.0.words()\n     }\n \n     pub fn words_mut(&mut self) -> &mut [Word] {\n-        &mut self.bits\n+        self.0.words_mut()\n     }\n \n     /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n@@ -196,9 +140,7 @@ impl<T: Idx> IdxSet<T> {\n \n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n-            cur: None,\n-            iter: self.words().iter().enumerate(),\n-            _pd: PhantomData,\n+            iter: self.0.iter()\n         }\n     }\n }\n@@ -216,28 +158,14 @@ impl<T: Idx> SubtractFromIdxSet<T> for IdxSet<T> {\n }\n \n pub struct Iter<'a, T: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n-    _pd: PhantomData<fn(&T)>,\n+    iter: BitIter<'a, T>\n }\n \n impl<'a, T: Idx> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n-        loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != BITS_PER_WORD {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(T::new(bit_pos + offset))\n-                }\n-            }\n-\n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, BITS_PER_WORD * i));\n-        }\n+        self.iter.next()\n     }\n }\n \n@@ -456,43 +384,3 @@ impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n         }\n     }\n }\n-\n-#[test]\n-fn test_trim_to() {\n-    use std::cmp;\n-\n-    for i in 0..256 {\n-        let mut idx_buf: IdxSet<usize> = IdxSet::new_filled(128);\n-        idx_buf.trim_to(i);\n-\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn test_set_up_to() {\n-    for i in 0..128 {\n-        for mut idx_buf in\n-            vec![IdxSet::new_empty(128), IdxSet::new_filled(128)]\n-            .into_iter()\n-        {\n-            idx_buf.set_up_to(i);\n-\n-            let elems: Vec<usize> = idx_buf.iter().collect();\n-            let expected: Vec<usize> = (0..i).collect();\n-            assert_eq!(elems, expected);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_new_filled() {\n-    for i in 0..128 {\n-        let idx_buf = IdxSet::new_filled(i);\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..i).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}"}, {"sha": "1fdcab5f7a21505c37d654fdec414ef1342fd1da", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -63,7 +63,6 @@ pub use rustc_serialize::hex::ToHex;\n pub mod svh;\n pub mod array_vec;\n pub mod base_n;\n-pub mod bitslice;\n pub mod bitvec;\n pub mod const_cstr;\n pub mod flock;"}, {"sha": "9487147ea9df95e4ee193a763196aaa565e22068", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::{BasicBlock, Mir};\n-use rustc_data_structures::bitslice::bits_to_string;\n+use rustc_data_structures::bitvec::bits_to_string;\n \n use dot;\n use dot::IntoCow;"}, {"sha": "6f004227f568278aa59e23b75bbe97f3fb036d2e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n-use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n+use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;"}, {"sha": "c8f704798529bd5151f13652bf088ec0c2012103", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n+use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n "}, {"sha": "49d75d31fc7fb95f1896b668ed93d765e4cde690", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b697409f10e70558ef72d39eee4a5f7af60cf16b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b697409f10e70558ef72d39eee4a5f7af60cf16b", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n+use rustc_data_structures::bitvec::{bitwise, BitwiseOperator};\n use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;"}]}