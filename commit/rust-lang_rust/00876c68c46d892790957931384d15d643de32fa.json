{"sha": "00876c68c46d892790957931384d15d643de32fa", "node_id": "C_kwDOAAsO6NoAKDAwODc2YzY4YzQ2ZDg5Mjc5MDk1NzkzMTM4NGQxNWQ2NDNkZTMyZmE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-19T06:24:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-19T06:24:44Z"}, "message": "Rollup merge of #104411 - lcnr:bivariance-nll, r=compiler-errors\n\nnll: correctly deal with bivariance\n\nfixes #104409\n\nwhen in a bivariant context, relating stuff should always trivially succeed. Also changes the mir validator to correctly deal with higher ranked regions.\n\nr? types cc ``@RalfJung``", "tree": {"sha": "6d0ddaca897d40646adb9a681ae78f3e236e6226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d0ddaca897d40646adb9a681ae78f3e236e6226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00876c68c46d892790957931384d15d643de32fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjeHasCRBK7hj4Ov3rIwAAM0EIAEQOWon2mcJLNnC0hDj4zo9x\nCVCD8iVR7pWbG8S37Aki5DmTnYPkwNrkntDiTSXmxm2STBSGf9u9UO9Aa3ixS8pB\nnmMklBfoNMi9YcmIcQHzhri273e6NWBHSVpupLVikKN4tE3+Y8NRDx7LCrJCIiAM\nJnXRrQ8TGbWL5K9MkjOhknuZUE66f7okEtopjRg75SUEQE5pBUzL+OKIdFdALXlR\nAMITZKPd/k1nweasoThWyOIrX8pbeWUa7eTo8XwdNyR8ajfw2xjPjeRpmQ2Pp2FN\nnbwu82Jr859lU97rkrcGIrMmN7OjVvXMK3Hf7+ga/5VH+qu9SLnEq8wGw6wbfVQ=\n=ESjz\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d0ddaca897d40646adb9a681ae78f3e236e6226\nparent aeeac5dd0c079cbe36ea5ba6eed702e88906eb16\nparent b2e6d08e3f88aee01d84412e0ea8369c48e0f419\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1668839084 +0530\ncommitter GitHub <noreply@github.com> 1668839084 +0530\n\nRollup merge of #104411 - lcnr:bivariance-nll, r=compiler-errors\n\nnll: correctly deal with bivariance\n\nfixes #104409\n\nwhen in a bivariant context, relating stuff should always trivially succeed. Also changes the mir validator to correctly deal with higher ranked regions.\n\nr? types cc ``@RalfJung``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00876c68c46d892790957931384d15d643de32fa", "html_url": "https://github.com/rust-lang/rust/commit/00876c68c46d892790957931384d15d643de32fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00876c68c46d892790957931384d15d643de32fa/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeeac5dd0c079cbe36ea5ba6eed702e88906eb16", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeeac5dd0c079cbe36ea5ba6eed702e88906eb16", "html_url": "https://github.com/rust-lang/rust/commit/aeeac5dd0c079cbe36ea5ba6eed702e88906eb16"}, {"sha": "b2e6d08e3f88aee01d84412e0ea8369c48e0f419", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e6d08e3f88aee01d84412e0ea8369c48e0f419", "html_url": "https://github.com/rust-lang/rust/commit/b2e6d08e3f88aee01d84412e0ea8369c48e0f419"}], "stats": {"total": 215, "additions": 130, "deletions": 85}, "files": [{"sha": "f59f34b874c19441de4178bf9bb4443e69242c8d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -23,7 +23,7 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n-use crate::transform::validate::equal_up_to_regions;\n+use crate::util;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -354,8 +354,8 @@ pub(super) fn mir_assign_valid_types<'tcx>(\n     // Type-changing assignments can happen when subtyping is used. While\n     // all normal lifetimes are erased, higher-ranked types with their\n     // late-bound lifetimes are still around and can lead to type\n-    // differences. So we compare ignoring lifetimes.\n-    if equal_up_to_regions(tcx, param_env, src.ty, dest.ty) {\n+    // differences.\n+    if util::is_subtype(tcx, param_env, src.ty, dest.ty) {\n         // Make sure the layout is equal, too -- just to be safe. Miri really\n         // needs layout equality. For performance reason we skip this check when\n         // the types are equal. Equal types *can* have different layouts when"}, {"sha": "860dee589805780addc061110736fa9db4c888af", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -2,7 +2,6 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -12,8 +11,7 @@ use rustc_middle::mir::{\n     ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n     TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -70,44 +68,6 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n-/// Returns whether the two types are equal up to lifetimes.\n-/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n-/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n-///\n-/// The point of this function is to approximate \"equal up to subtyping\".  However,\n-/// the approximation is incorrect as variance is ignored.\n-pub fn equal_up_to_regions<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    src: Ty<'tcx>,\n-    dest: Ty<'tcx>,\n-) -> bool {\n-    // Fast path.\n-    if src == dest {\n-        return true;\n-    }\n-\n-    // Normalize lifetimes away on both sides, then compare.\n-    let normalize = |ty: Ty<'tcx>| {\n-        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty).fold_with(\n-            &mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            },\n-        )\n-    };\n-    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n-}\n-\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     body: &'a Body<'tcx>,\n@@ -183,22 +143,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n \n-        // Normalize projections and things like that.\n-        // Type-changing assignments can happen when subtyping is used. While\n-        // all normal lifetimes are erased, higher-ranked types with their\n-        // late-bound lifetimes are still around and can lead to type\n-        // differences. So we compare ignoring lifetimes.\n-\n-        // First, try with reveal_all. This might not work in some cases, as the predicates\n-        // can be cleared in reveal_all mode. We try the reveal first anyways as it is used\n-        // by some other passes like inlining as well.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        if equal_up_to_regions(self.tcx, param_env, src, dest) {\n-            return true;\n-        }\n-\n-        // If this fails, we can try it without the reveal.\n-        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n+        crate::util::is_subtype(self.tcx, self.param_env, src, dest)\n     }\n }\n "}, {"sha": "a9cb191cc593fc0f7d5c116580712a35b930e59f", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -0,0 +1,63 @@\n+//! Routines to check for relations between fully inferred types.\n+//!\n+//! FIXME: Move this to a more general place. The utility of this extends to\n+//! other areas of the compiler as well.\n+\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_trait_selection::traits::ObligationCtxt;\n+\n+/// Returns whether the two types are equal up to subtyping.\n+///\n+/// This is used in case we don't know the expected subtyping direction\n+/// and still want to check whether anything is broken.\n+pub fn is_equal_up_to_subtyping<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    // Fast path.\n+    if src == dest {\n+        return true;\n+    }\n+\n+    // Check for subtyping in either direction.\n+    is_subtype(tcx, param_env, src, dest) || is_subtype(tcx, param_env, dest, src)\n+}\n+\n+/// Returns whether `src` is a subtype of `dest`, i.e. `src <: dest`.\n+///\n+/// This mostly ignores opaque types as it can be used in constraining contexts\n+/// while still computing the final underlying type.\n+pub fn is_subtype<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    if src == dest {\n+        return true;\n+    }\n+\n+    let mut builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    let infcx = builder.build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let cause = ObligationCause::dummy();\n+    let src = ocx.normalize(cause.clone(), param_env, src);\n+    let dest = ocx.normalize(cause.clone(), param_env, dest);\n+    match ocx.sub(&cause, param_env, src, dest) {\n+        Ok(()) => {}\n+        Err(_) => return false,\n+    };\n+    let errors = ocx.select_all_or_error();\n+    // With `Reveal::All`, opaque types get normalized away, with `Reveal::UserFacing`\n+    // we would get unification errors because we're unable to look into opaque types,\n+    // even if they're constrained in our current function.\n+    //\n+    // It seems very unlikely that this hides any bugs.\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    errors.is_empty()\n+}"}, {"sha": "76ea5a24e69edd8c1bd09cab7ece7e05eb345302", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -2,13 +2,15 @@ pub mod aggregate;\n mod alignment;\n mod call_kind;\n pub mod collect_writes;\n+mod compare_types;\n mod find_self_call;\n mod might_permit_raw_init;\n mod type_name;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n+pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};\n pub use self::find_self_call::find_self_call;\n pub use self::might_permit_raw_init::might_permit_raw_init;\n pub use self::type_name::type_name;"}, {"sha": "b4805de961889a2fcb8c1da77ee829a219b8e32f", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -449,8 +449,8 @@ fn check_opaque_meets_bounds<'tcx>(\n \n     let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-    match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_ty) {\n-        Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+    match ocx.eq(&misc_cause, param_env, opaque_ty, hidden_ty) {\n+        Ok(()) => {}\n         Err(ty_err) => {\n             tcx.sess.delay_span_bug(\n                 span,"}, {"sha": "0b9209771cd3232cddb01cc44ba5b36e08efa120", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -402,10 +402,8 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         unnormalized_trait_sig.inputs_and_output.iter().chain(trait_sig.inputs_and_output.iter()),\n     );\n \n-    match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n-        Ok(infer::InferOk { value: (), obligations }) => {\n-            ocx.register_obligations(obligations);\n-        }\n+    match ocx.eq(&cause, param_env, trait_return_ty, impl_return_ty) {\n+        Ok(()) => {}\n         Err(terr) => {\n             let mut diag = struct_span_err!(\n                 tcx.sess,\n@@ -442,10 +440,8 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n-        Ok(infer::InferOk { value: (), obligations }) => {\n-            ocx.register_obligations(obligations);\n-        }\n+    match ocx.eq(&cause, param_env, trait_fty, impl_fty) {\n+        Ok(()) => {}\n         Err(terr) => {\n             // This function gets called during `compare_predicate_entailment` when normalizing a\n             // signature that contains RPITIT. When the method signatures don't match, we have to"}, {"sha": "167a82d4499a188603895a21b2bfe9349d628341", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -556,8 +556,9 @@ where\n         self.ambient_variance_info = self.ambient_variance_info.xform(info);\n \n         debug!(?self.ambient_variance);\n-\n-        let r = self.relate(a, b)?;\n+        // In a bivariant context this always succeeds.\n+        let r =\n+            if self.ambient_variance == ty::Variance::Bivariant { a } else { self.relate(a, b)? };\n \n         self.ambient_variance = old_ambient_variance;\n "}, {"sha": "d7dd5fc8528454ca76c0a78ce2f1decdbedb437f", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -1,7 +1,6 @@\n //! Inlining pass for MIR functions\n use crate::deref_separator::deref_finder;\n use rustc_attr::InlineAttr;\n-use rustc_const_eval::transform::validate::equal_up_to_regions;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -14,7 +13,8 @@ use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n-use super::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::util;\n use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n@@ -180,7 +180,7 @@ impl<'tcx> Inliner<'tcx> {\n         let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n         let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n         let output_type = callee_body.return_ty();\n-        if !equal_up_to_regions(self.tcx, self.param_env, output_type, destination_ty) {\n+        if !util::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n             trace!(?output_type, ?destination_ty);\n             return Err(\"failed to normalize return type\");\n         }\n@@ -200,7 +200,7 @@ impl<'tcx> Inliner<'tcx> {\n                 arg_tuple_tys.iter().zip(callee_body.args_iter().skip(skipped_args))\n             {\n                 let input_type = callee_body.local_decls[input].ty;\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize tuple argument type\");\n                 }\n@@ -209,7 +209,7 @@ impl<'tcx> Inliner<'tcx> {\n             for (arg, input) in args.iter().zip(callee_body.args_iter()) {\n                 let input_type = callee_body.local_decls[input].ty;\n                 let arg_ty = arg.ty(&caller_body.local_decls, self.tcx);\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize argument type\");\n                 }\n@@ -847,7 +847,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n             let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n             let check_equal = |this: &mut Self, f_ty| {\n-                if !equal_up_to_regions(this.tcx, this.param_env, ty, f_ty) {\n+                if !util::is_equal_up_to_subtyping(this.tcx, this.param_env, ty, f_ty) {\n                     trace!(?ty, ?f_ty);\n                     this.validation = Err(\"failed to normalize projection type\");\n                     return;"}, {"sha": "f8346e515d70c57ab0a3e693a65871e4ad4a4c1a", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -125,20 +125,32 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n+    /// Checks whether `expected` is a subtype of `actual`: `expected <: actual`.\n+    pub fn sub<T: ToTrace<'tcx>>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: T,\n+        actual: T,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        self.infcx\n+            .at(cause, param_env)\n+            .sup(expected, actual)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n+    }\n+\n+    /// Checks whether `expected` is a supertype of `actual`: `expected :> actual`.\n     pub fn sup<T: ToTrace<'tcx>>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         expected: T,\n         actual: T,\n     ) -> Result<(), TypeError<'tcx>> {\n-        match self.infcx.at(cause, param_env).sup(expected, actual) {\n-            Ok(InferOk { obligations, value: () }) => {\n-                self.register_obligations(obligations);\n-                Ok(())\n-            }\n-            Err(e) => Err(e),\n-        }\n+        self.infcx\n+            .at(cause, param_env)\n+            .sup(expected, actual)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n     pub fn select_where_possible(&self) -> Vec<FulfillmentError<'tcx>> {"}, {"sha": "cadfb3b66f29747cc0e37ffc30561e69b605eb29", "filename": "src/test/ui/mir/important-higher-ranked-regions.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00876c68c46d892790957931384d15d643de32fa/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00876c68c46d892790957931384d15d643de32fa/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs?ref=00876c68c46d892790957931384d15d643de32fa", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: -Zvalidate-mir\n+\n+// This test checks that bivariant parameters are handled correctly\n+// in the mir.\n+#![allow(coherence_leak_check)]\n+trait Trait {\n+    type Assoc;\n+}\n+\n+struct Foo<T, U>(T)\n+where\n+    T: Trait<Assoc = U>;\n+\n+impl Trait for for<'a> fn(&'a ()) {\n+    type Assoc = u32;\n+}\n+impl Trait for fn(&'static ()) {\n+    type Assoc = String;\n+}\n+\n+fn foo(x: Foo<for<'a> fn(&'a ()), u32>) -> Foo<fn(&'static ()), String> {\n+    x\n+}\n+\n+fn main() {}"}]}