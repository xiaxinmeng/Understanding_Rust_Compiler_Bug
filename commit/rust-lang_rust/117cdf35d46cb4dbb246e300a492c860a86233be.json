{"sha": "117cdf35d46cb4dbb246e300a492c860a86233be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExN2NkZjM1ZDQ2Y2I0ZGJiMjQ2ZTMwMGE0OTJjODYwYTg2MjMzYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-15T08:17:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-15T08:17:57Z"}, "message": "Auto merge of #64469 - matthewjasper:increase-hygiene-use, r=petrochenkov\n\nCleanup handling of hygiene for built-in macros\n\nThis makes most identifiers generated by built-in macros use def-site hygiene, not only the ones that previously used gensyms.\n\n* `ExtCtxt::ident_of` now takes a `Span` and is preferred to `Ident::{from_str, from_str_and_span}`\n* Remove `Span::with_legacy_ctxt`\n    * `assert` now uses call-site hygiene because it needs to resolve `panic` unhygienically.\n    * `concat_idents` now uses call-site hygiene because it wouldn't be very useful with def-site hygiene.\n    * everything else is moved to def-site hygiene\n\nr? @petrochenkov", "tree": {"sha": "109e3227f1b4076c99874c94dc9aa1d554781f2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/109e3227f1b4076c99874c94dc9aa1d554781f2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/117cdf35d46cb4dbb246e300a492c860a86233be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/117cdf35d46cb4dbb246e300a492c860a86233be", "html_url": "https://github.com/rust-lang/rust/commit/117cdf35d46cb4dbb246e300a492c860a86233be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/117cdf35d46cb4dbb246e300a492c860a86233be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf776d5c2fc88624d2562e493aab0d324a3b7d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf776d5c2fc88624d2562e493aab0d324a3b7d8", "html_url": "https://github.com/rust-lang/rust/commit/8bf776d5c2fc88624d2562e493aab0d324a3b7d8"}, {"sha": "8ab67c8f560a730b8978f4a42deb70d01ca1cdfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab67c8f560a730b8978f4a42deb70d01ca1cdfc", "html_url": "https://github.com/rust-lang/rust/commit/8ab67c8f560a730b8978f4a42deb70d01ca1cdfc"}], "stats": {"total": 314, "additions": 161, "deletions": 153}, "files": [{"sha": "58789a10609b7e84f1ef98407d3ee85a521def6c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -1316,7 +1316,7 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n-                        let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n+                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),"}, {"sha": "21ea4766d8e527ad134f75441e145a9885773164", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -618,24 +618,19 @@ impl UnusedImportBraces {\n             }\n \n             // Trigger the lint if the nested item is a non-self single item\n-            let node_ident;\n-            match items[0].0.kind {\n+            let node_name = match items[0].0.kind {\n                 ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == kw::SelfLower {\n                         return;\n                     }\n-                    node_ident = rename.unwrap_or(orig_ident);\n+                    rename.unwrap_or(orig_ident).name\n                 }\n-                ast::UseTreeKind::Glob => {\n-                    node_ident = ast::Ident::from_str(\"*\");\n-                }\n-                ast::UseTreeKind::Nested(_) => {\n-                    return;\n-                }\n-            }\n+                ast::UseTreeKind::Glob => Symbol::intern(\"*\"),\n+                ast::UseTreeKind::Nested(_) => return,\n+            };\n \n-            let msg = format!(\"braces around {} is unnecessary\", node_ident.name);\n+            let msg = format!(\"braces around {} is unnecessary\", node_name);\n             cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n         }\n     }"}, {"sha": "a1e3bbcbf8ea94d8205ca043e9fe7a0f780a9525", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -444,7 +444,8 @@ impl cstore::CStore {\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroDef(ast::Item {\n-            ident: ast::Ident::from_str(&name.as_str()),\n+            // FIXME: cross-crate hygiene\n+            ident: ast::Ident::with_dummy_span(name.as_symbol()),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),"}, {"sha": "74f68e514712623af4f8eda8d66831f1b706c873", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -40,7 +40,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::{SyntaxExtension, MacroKind, SpecialDerives};\n-use syntax::symbol::{Symbol, kw, sym};\n+use syntax::symbol::{kw, sym};\n \n use syntax::visit::{self, Visitor};\n use syntax::attr;\n@@ -241,7 +241,7 @@ impl Segment {\n \n     fn names_to_string(segments: &[Segment]) -> String {\n         names_to_string(&segments.iter()\n-                            .map(|seg| seg.ident)\n+                            .map(|seg| seg.ident.name)\n                             .collect::<Vec<_>>())\n     }\n }\n@@ -951,7 +951,7 @@ pub struct Resolver<'a> {\n     struct_constructors: DefIdMap<(Res, ty::Visibility)>,\n \n     /// Features enabled for this crate.\n-    active_features: FxHashSet<Symbol>,\n+    active_features: FxHashSet<Name>,\n \n     /// Stores enum visibilities to properly build a reduced graph\n     /// when visiting the correspondent variants.\n@@ -1018,8 +1018,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n-        crate_root: Option<Symbol>,\n-        components: &[Symbol],\n+        crate_root: Option<Name>,\n+        components: &[Name],\n         ns: Namespace,\n     ) -> (ast::Path, Res) {\n         let root = if crate_root.is_some() {\n@@ -2555,7 +2555,7 @@ impl<'a> Resolver<'a> {\n     fn add_suggestion_for_rename_of_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        name: Symbol,\n+        name: Name,\n         directive: &ImportDirective<'_>,\n         binding_span: Span,\n     ) {\n@@ -2770,38 +2770,37 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn names_to_string(idents: &[Ident]) -> String {\n+fn names_to_string(names: &[Name]) -> String {\n     let mut result = String::new();\n-    for (i, ident) in idents.iter()\n-                            .filter(|ident| ident.name != kw::PathRoot)\n+    for (i, name) in names.iter()\n+                            .filter(|name| **name != kw::PathRoot)\n                             .enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        result.push_str(&ident.as_str());\n+        result.push_str(&name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n-                        .map(|seg| seg.ident)\n+                        .map(|seg| seg.ident.name)\n                         .collect::<Vec<_>>())\n }\n \n /// A somewhat inefficient routine to obtain the name of a module.\n fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n+    fn collect_mod(names: &mut Vec<Name>, module: Module<'_>) {\n         if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(Ident::with_dummy_span(name));\n+                names.push(name);\n                 collect_mod(names, parent);\n             }\n         } else {\n-            // danger, shouldn't be ident?\n-            names.push(Ident::from_str(\"<opaque>\"));\n+            names.push(Name::intern(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }\n@@ -2810,9 +2809,8 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     if names.is_empty() {\n         return None;\n     }\n-    Some(names_to_string(&names.into_iter()\n-                        .rev()\n-                        .collect::<Vec<_>>()))\n+    names.reverse();\n+    Some(names_to_string(&names))\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "e77e8290f1faa9f911cdaf0ecb96f43da07818a3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -1433,15 +1433,17 @@ fn import_path_to_string(names: &[Ident],\n     let global = !names.is_empty() && names[0].name == kw::PathRoot;\n     if let Some(pos) = pos {\n         let names = if global { &names[1..pos + 1] } else { &names[..pos + 1] };\n-        names_to_string(names)\n+        names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>())\n     } else {\n         let names = if global { &names[1..] } else { names };\n         if names.is_empty() {\n             import_directive_subclass_to_string(subclass)\n         } else {\n-            format!(\"{}::{}\",\n-                    names_to_string(names),\n-                    import_directive_subclass_to_string(subclass))\n+            format!(\n+                \"{}::{}\",\n+                names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>()),\n+                import_directive_subclass_to_string(subclass),\n+            )\n         }\n     }\n }"}, {"sha": "384c0555c85bd683ed43353f2dfdcacc1003f857", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -977,13 +977,6 @@ impl<'a> ExtCtxt<'a> {\n         span.with_call_site_ctxt(self.current_expansion.id)\n     }\n \n-    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n-    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n-    /// or with `with_call_site_ctxt` (where necessary).\n-    pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n-        span.with_legacy_ctxt(self.current_expansion.id)\n-    }\n-\n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n@@ -1081,8 +1074,8 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        ast::Ident::from_str(st)\n+    pub fn ident_of(&self, st: &str, sp: Span) -> ast::Ident {\n+        ast::Ident::from_str_and_span(st, sp)\n     }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);"}, {"sha": "f1d0e0b68f7359bd9b1a240180bf5af4746611cd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -363,7 +363,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     pub fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let ident = Ident::from_str(&idx.to_string()).with_span_pos(sp);\n+        let ident = Ident::new(sym::integer(idx), sp);\n         self.expr(sp, ast::ExprKind::Field(expr, ident))\n     }\n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n@@ -525,7 +525,7 @@ impl<'a> ExtCtxt<'a> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n-        let binding_variable = self.ident_of(\"__try_var\");\n+        let binding_variable = self.ident_of(\"__try_var\", sp);\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n "}, {"sha": "cf196645e4f7bac410c170a11d18be8a245f921c", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -1256,7 +1256,7 @@ impl<'a> Parser<'a> {\n             for part in idents {\n                 fixed_name.push_str(&format!(\"_{}\", part.name));\n             }\n-            ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n+            ident = Ident::from_str_and_span(&fixed_name, fixed_name_sp);\n \n             self.struct_span_err(fixed_name_sp, error_msg)\n                 .span_label(fixed_name_sp, \"dash-separated idents are not valid\")"}, {"sha": "75d727b9fb60b5f640fbc3456b0f9a900d45befb", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -62,7 +62,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: cx.with_legacy_ctxt(sp),\n+        span: cx.with_def_site_ctxt(sp),\n         attrs: ThinVec::new(),\n     }))\n }"}, {"sha": "cbfe14fa439be85152b65d5885ed3131e004dc2c", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -23,7 +23,9 @@ pub fn expand_assert<'cx>(\n         }\n     };\n \n-    let sp = cx.with_legacy_ctxt(sp);\n+    // `core::panic` and `std::panic` are different macros, so we use call-site\n+    // context to pick up whichever is currently in scope.\n+    let sp = cx.with_call_site_ctxt(sp);\n     let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {"}, {"sha": "3c33baf95a597705c44abc8f1baf21d82e746b31", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -16,7 +16,7 @@ pub fn expand_cfg(\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let sp = cx.with_legacy_ctxt(sp);\n+    let sp = cx.with_def_site_ctxt(sp);\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {"}, {"sha": "16f016036ea5e5b03361277e8c7b29a8a4230265", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -59,6 +59,6 @@ pub fn expand_concat(\n     } else if has_errors {\n         return DummyResult::any(sp);\n     }\n-    let sp = cx.with_legacy_ctxt(sp);\n+    let sp = cx.with_def_site_ctxt(sp);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "f344706d4ebf5a876420167c861b4fa8d26a4722", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -39,7 +39,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n     }\n \n-    let ident = ast::Ident::new(Symbol::intern(&res_str), cx.with_legacy_ctxt(sp));\n+    let ident = ast::Ident::new(Symbol::intern(&res_str), cx.with_call_site_ctxt(sp));\n \n     struct ConcatIdentsResult { ident: ast::Ident }\n "}, {"sha": "13d63aaf2a80c987d50cd7397af34e18dfb2bb18", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -109,7 +109,7 @@ pub fn some_ordering_collapsed(\n         GtOp => \"gt\",\n         GeOp => \"ge\",\n     };\n-    cx.expr_method_call(span, lft, ast::Ident::from_str_and_span(op_str, span), vec![rgt])\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str, span), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {"}, {"sha": "088b61be8b81b3b24a81ad58daea6dd53bfbc4fe", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = Ident::from_str_and_span(\"debug_trait_builder\", span);\n+    let builder = cx.ident_of(\"debug_trait_builder\", span);\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -72,7 +72,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n             let expr =\n-                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n+                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_tuple\", span), vec![name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n@@ -93,7 +93,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n             let expr =\n-                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n+                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_struct\", span), vec![name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -113,7 +113,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, cx.ident_of(\"finish\", span), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "cde72abbdef6a7060c11e9f008452b2a81fb7710", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -66,10 +66,14 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                           krate: &str)\n                           -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n-    let recurse = vec![cx.ident_of(krate), cx.ident_of(\"Decodable\"), cx.ident_of(\"decode\")];\n+    let recurse = vec![\n+        cx.ident_of(krate, trait_span),\n+        cx.ident_of(\"Decodable\", trait_span),\n+        cx.ident_of(\"decode\", trait_span),\n+    ];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_d\");\n+    let blkarg = cx.ident_of(\"_d\", trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n     return match *substr.fields {\n@@ -78,7 +82,7 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = cx.ident_of(\"read_struct_field\");\n+            let read_struct_field = cx.ident_of(\"read_struct_field\", trait_span);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n@@ -94,17 +98,17 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n-                                cx.ident_of(\"read_struct\"),\n+                                cx.ident_of(\"read_struct\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, nfields),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n-            let variant = cx.ident_of(\"i\");\n+            let variant = cx.ident_of(\"i\", trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n+            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\", trait_span);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -132,11 +136,11 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n             let result = cx.expr_method_call(trait_span,\n                                              blkdecoder,\n-                                             cx.ident_of(\"read_enum_variant\"),\n+                                             cx.ident_of(\"read_enum_variant\", trait_span),\n                                              vec![variant_vec, lambda]);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n-                                cx.ident_of(\"read_enum\"),\n+                                cx.ident_of(\"read_enum\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }"}, {"sha": "655d3bb7c4ab8e3866b694aa7f9153d4e43cc941", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -153,16 +153,16 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n                           -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_e\");\n+    let blkarg = cx.ident_of(\"_e\", trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let fn_path = cx.expr_path(cx.path_global(trait_span,\n-                                              vec![cx.ident_of(krate),\n-                                                   cx.ident_of(\"Encodable\"),\n-                                                   cx.ident_of(\"encode\")]));\n+                                              vec![cx.ident_of(krate, trait_span),\n+                                                   cx.ident_of(\"Encodable\", trait_span),\n+                                                   cx.ident_of(\"encode\", trait_span)]));\n \n     return match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n+            let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -201,7 +201,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n \n             cx.expr_method_call(trait_span,\n                                 encoder,\n-                                cx.ident_of(\"emit_struct\"),\n+                                cx.ident_of(\"emit_struct\", trait_span),\n                                 vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, fields.len()),\n                                      blk])\n@@ -214,7 +214,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n+            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\", trait_span);\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -244,15 +244,15 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             let name = cx.expr_str(trait_span, variant.ident.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n-                                           cx.ident_of(\"emit_enum_variant\"),\n+                                           cx.ident_of(\"emit_enum_variant\", trait_span),\n                                            vec![name,\n                                                 cx.expr_usize(trait_span, idx),\n                                                 cx.expr_usize(trait_span, fields.len()),\n                                                 blk]);\n             let blk = cx.lambda1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n-                                          cx.ident_of(\"emit_enum\"),\n+                                          cx.ident_of(\"emit_enum\", trait_span),\n                                           vec![cx.expr_str(trait_span ,substr.type_ident.name),\n                                                blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))"}, {"sha": "aceee62e89b0c02e9e8913bd24d4f9638e2af5f0", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -237,7 +237,7 @@ pub struct MethodDef<'a> {\n     /// Whether there is a self argument (outer Option) i.e., whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n-    pub explicit_self: Option<Option<PtrTy<'a>>>,\n+    pub explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n     pub args: Vec<(Ty<'a>, &'a str)>,\n@@ -843,7 +843,7 @@ impl<'a> MethodDef<'a> {\n                                 -> P<Expr> {\n         let substructure = Substructure {\n             type_ident,\n-            method_ident: cx.ident_of(self.name),\n+            method_ident: cx.ident_of(self.name, trait_.span),\n             self_args,\n             nonself_args,\n             fields,\n@@ -890,7 +890,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = ast::Ident::from_str_and_span(name, trait_.span);\n+            let ident = cx.ident_of(name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -938,7 +938,7 @@ impl<'a> MethodDef<'a> {\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = cx.ident_of(self.name);\n+        let method_ident = cx.ident_of(self.name, trait_.span);\n         let fn_decl = cx.fn_decl(args, ast::FunctionRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n@@ -1201,7 +1201,7 @@ impl<'a> MethodDef<'a> {\n             ).collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name| cx.ident_of(&name[..]))\n+            .map(|name| cx.ident_of(name, sp))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n@@ -1210,7 +1210,7 @@ impl<'a> MethodDef<'a> {\n         let vi_idents = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                ast::Ident::from_str_and_span(&vi_suffix[..], trait_.span)\n+                cx.ident_of(&vi_suffix[..], trait_.span)\n             })\n             .collect::<Vec<ast::Ident>>();\n \n@@ -1389,7 +1389,7 @@ impl<'a> MethodDef<'a> {\n \n                 let target_ty = cx.ty_ident(\n                     sp,\n-                    ast::Ident::from_str_and_span(target_type_name, sp),\n+                    cx.ident_of(target_type_name, sp),\n                 );\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n@@ -1591,7 +1591,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = ast::Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries {"}, {"sha": "b341a076752069476ad3116834881eab4d1b5a54", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -13,9 +13,9 @@ use syntax_pos::symbol::kw;\n \n /// The types of pointers\n #[derive(Clone)]\n-pub enum PtrTy<'a> {\n+pub enum PtrTy {\n     /// &'lifetime mut\n-    Borrowed(Option<&'a str>, ast::Mutability),\n+    Borrowed(Option<Ident>, ast::Mutability),\n     /// *mut\n     #[allow(dead_code)]\n     Raw(ast::Mutability),\n@@ -26,7 +26,7 @@ pub enum PtrTy<'a> {\n #[derive(Clone)]\n pub struct Path<'a> {\n     path: Vec<&'a str>,\n-    lifetime: Option<&'a str>,\n+    lifetime: Option<Ident>,\n     params: Vec<Box<Ty<'a>>>,\n     kind: PathKind,\n }\n@@ -46,7 +46,7 @@ impl<'a> Path<'a> {\n         Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n     }\n     pub fn new_<'r>(path: Vec<&'r str>,\n-                    lifetime: Option<&'r str>,\n+                    lifetime: Option<Ident>,\n                     params: Vec<Box<Ty<'r>>>,\n                     kind: PathKind)\n                     -> Path<'r> {\n@@ -72,7 +72,7 @@ impl<'a> Path<'a> {\n                    self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| Ident::from_str_and_span(*s, span)).collect();\n+        let mut idents = self.path.iter().map(|s| cx.ident_of(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -99,22 +99,22 @@ impl<'a> Path<'a> {\n pub enum Ty<'a> {\n     Self_,\n     /// &/Box/ Ty\n-    Ptr(Box<Ty<'a>>, PtrTy<'a>),\n+    Ptr(Box<Ty<'a>>, PtrTy),\n     /// mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit\n     Tuple(Vec<Ty<'a>>),\n }\n \n-pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n+pub fn borrowed_ptrty() -> PtrTy {\n     Borrowed(None, ast::Mutability::Immutable)\n }\n pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n     Ptr(ty, borrowed_ptrty())\n }\n \n-pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n+pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n     Some(Some(borrowed_ptrty()))\n }\n \n@@ -126,13 +126,11 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n     Tuple(Vec::new())\n }\n \n-fn mk_lifetime(cx: &ExtCtxt<'_>, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n-    lt.map(|s|\n-        cx.lifetime(span, Ident::from_str(s))\n-    )\n+fn mk_lifetime(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Option<ast::Lifetime> {\n+    lt.map(|ident| cx.lifetime(span, ident))\n }\n \n-fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n+fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Lifetime> {\n     mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n@@ -209,7 +207,7 @@ fn mk_ty_param(cx: &ExtCtxt<'_>,\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, ast::Ident::from_str_and_span(name, span), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, cx.ident_of(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n@@ -265,7 +263,7 @@ impl<'a> LifetimeBounds<'a> {\n \n pub fn get_explicit_self(cx: &ExtCtxt<'_>,\n                          span: Span,\n-                         self_ptr: &Option<PtrTy<'_>>)\n+                         self_ptr: &Option<PtrTy>)\n                          -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n@@ -276,7 +274,7 @@ pub fn get_explicit_self(cx: &ExtCtxt<'_>,\n                 respan(span,\n                        match *ptr {\n                            Borrowed(ref lt, mutbl) => {\n-                               let lt = lt.map(|s| cx.lifetime(span, Ident::from_str(s)));\n+                               let lt = lt.map(|s| cx.lifetime(span, s));\n                                SelfKind::Region(lt, mutbl)\n                            }\n                            Raw(_) => {"}, {"sha": "70e1fbe6af78aa8568f6a6f34548fb83fcf8a682", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -20,16 +20,16 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         Some(v) => v,\n     };\n \n-    let sp = cx.with_legacy_ctxt(sp);\n+    let sp = cx.with_def_site_ctxt(sp);\n     let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n-            let lt = cx.lifetime(sp, Ident::with_dummy_span(kw::StaticLifetime));\n+            let lt = cx.lifetime(sp, Ident::new(kw::StaticLifetime, sp));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n                                      cx.std_path(&[sym::option, sym::Option, sym::None]),\n                                      vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp,\n-                                                                 Ident::with_dummy_span(sym::str)),\n+                                                                 Ident::new(sym::str, sp)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n                                      vec![]))"}, {"sha": "46c7cbb83de9066b0f974ff885a69377c5865894", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n-            path.push(self.ecx.ident_of(c));\n+            path.push(self.ecx.ident_of(c, sp));\n             match arg {\n                 Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n                 None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n@@ -534,7 +534,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = {\n                     let pos = |c, arg| {\n                         let mut path = Context::rtpath(self.ecx, \"Position\");\n-                        path.push(self.ecx.ident_of(c));\n+                        path.push(self.ecx.ident_of(c, sp));\n                         match arg {\n                             Some(i) => {\n                                 let arg = self.ecx.expr_usize(sp, i);\n@@ -603,7 +603,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n                     let mut p = Context::rtpath(self.ecx, \"Alignment\");\n-                    p.push(self.ecx.ident_of(name));\n+                    p.push(self.ecx.ident_of(name, sp));\n                     self.ecx.path_global(sp, p)\n                 };\n                 let align = match arg.format.align {\n@@ -621,11 +621,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\", sp), fill),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\", sp), align),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\", sp), flags),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\", sp), prec),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\", sp), width),\n                     ],\n                 );\n \n@@ -634,8 +634,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                     sp,\n                                           path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\", sp), pos),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\", sp), fmt),\n                     ],\n                 ))\n             }\n@@ -653,7 +653,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| ast::Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n+            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled"}, {"sha": "19a87e6dc6d745e4d471583d2258c107796c1ad5", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -28,7 +28,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = ecx.with_legacy_ctxt(item.span);\n+    let span = ecx.with_def_site_ctxt(item.span);\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,\n@@ -43,7 +43,7 @@ pub fn expand(\n     let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item =\n-        ecx.item_const(span, Ident::with_dummy_span(kw::Underscore), const_ty, const_body);\n+        ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n \n     // Return the original item and the new methods.\n     vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n@@ -61,7 +61,7 @@ impl AllocFnFactory<'_, '_> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let ref mut mk = || {\n-            let name = Ident::from_str(&format!(\"arg{}\", i));\n+            let name = self.cx.ident_of(&format!(\"arg{}\", i), self.span);\n             i += 1;\n             name\n         };\n@@ -83,7 +83,7 @@ impl AllocFnFactory<'_, '_> {\n         );\n         let item = self.cx.item(\n             self.span,\n-            Ident::from_str(&self.kind.fn_name(method.name)),\n+            self.cx.ident_of(&self.kind.fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );\n@@ -119,7 +119,7 @@ impl AllocFnFactory<'_, '_> {\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n+                let usize = self.cx.path_ident(self.span, Ident::new(sym::usize, self.span));\n                 let ty_usize = self.cx.ty_path(usize);\n                 let size = ident();\n                 let align = ident();\n@@ -177,12 +177,12 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::usize));\n+        let usize = self.cx.path_ident(self.span, Ident::new(sym::usize, self.span));\n         self.cx.ty_path(usize)\n     }\n \n     fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_dummy_span(sym::u8));\n+        let u8 = self.cx.path_ident(self.span, Ident::new(sym::u8, self.span));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }"}, {"sha": "c56b3f3fc808fc057c55e5fb1221878b61636495", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -30,7 +30,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                span: cx.with_legacy_ctxt(sp),\n+                span: cx.with_def_site_ctxt(sp),\n                 tokens: None,\n             })])\n         }"}, {"sha": "a5dcfb9840aca5c4d9f4536c151843000117b5ec", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -340,12 +340,12 @@ fn mk_decls(\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let bridge = Ident::from_str_and_span(\"bridge\", span);\n-    let client = Ident::from_str_and_span(\"client\", span);\n-    let proc_macro_ty = Ident::from_str_and_span(\"ProcMacro\", span);\n-    let custom_derive = Ident::from_str_and_span(\"custom_derive\", span);\n-    let attr = Ident::from_str_and_span(\"attr\", span);\n-    let bang = Ident::from_str_and_span(\"bang\", span);\n+    let bridge = cx.ident_of(\"bridge\", span);\n+    let client = cx.ident_of(\"client\", span);\n+    let proc_macro_ty = cx.ident_of(\"ProcMacro\", span);\n+    let custom_derive = cx.ident_of(\"custom_derive\", span);\n+    let attr = cx.ident_of(\"attr\", span);\n+    let bang = cx.ident_of(\"bang\", span);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n@@ -378,7 +378,7 @@ fn mk_decls(\n \n     let decls_static = cx.item_static(\n         span,\n-        Ident::from_str_and_span(\"_DECLS\", span),\n+        cx.ident_of(\"_DECLS\", span),\n         cx.ty_rptr(span,\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,"}, {"sha": "0910c00a8a2a97ba6e55c85fe250cc9f71b50d78", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -98,20 +98,20 @@ pub fn expand_test_or_bench(\n \n     // creates test::$name\n     let test_path = |name| {\n-        cx.path(sp, vec![test_id, cx.ident_of(name)])\n+        cx.path(sp, vec![test_id, cx.ident_of(name, sp)])\n     };\n \n     // creates test::ShouldPanic::$name\n     let should_panic_path = |name| {\n-        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\"), cx.ident_of(name)])\n+        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)])\n     };\n \n     // creates $name: $expr\n-    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name), expr);\n+    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = ast::Ident::from_str_and_span(\"b\", attr_sp);\n+        let b = cx.ident_of(\"b\", attr_sp);\n \n         cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n             // |b| self::test::assert_test_result("}, {"sha": "56de0c97f81c0b70c47ee1347c289beba09d35e8", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -250,7 +250,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![test_id, Ident::from_str_and_span(\"test_main_static\", sp)]));\n+        ecx.path(sp, vec![test_id, ecx.ident_of(\"test_main_static\", sp)]));\n \n     test_runner.span = sp;\n \n@@ -288,7 +288,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     // Honor the reexport_test_harness_main attribute\n     let main_id = match cx.reexport_test_harness_main {\n         Some(sym) => Ident::new(sym, sp.with_ctxt(SyntaxContext::root())),\n-        None => Ident::from_str_and_span(\"main\", sp),\n+        None => Ident::new(sym::main, sp),\n     };\n \n     let main = P(ast::Item {"}, {"sha": "ca177eb4a361654c064e6d137c1d8f939ac3bb3c", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -526,13 +526,6 @@ impl Span {\n         self.with_ctxt_from_mark(expn_id, Transparency::Transparent)\n     }\n \n-    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n-    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n-    /// or with `with_call_site_ctxt` (where necessary).\n-    pub fn with_legacy_ctxt(&self, expn_id: ExpnId) -> Span {\n-        self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)\n-    }\n-\n     /// Produces a span with the same location as `self` and context produced by a macro with the\n     /// given ID and transparency, assuming that macro was defined directly and not produced by\n     /// some other macro (which is the case for built-in and procedural macros)."}, {"sha": "597ae83572cee8d924ee35294f50b421482c13b4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -765,7 +765,7 @@ impl Ident {\n         Ident::with_dummy_span(string.as_symbol())\n     }\n \n-    /// Maps a string to an identifier with an empty span.\n+    /// Maps a string to an identifier with a dummy span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_dummy_span(Symbol::intern(string))\n     }"}, {"sha": "9bd8406a27608dd0aa4899fbc1f9ab4c3df5da7d", "filename": "src/test/ui/allocator/hygiene.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Ftest%2Fui%2Fallocator%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Ftest%2Fui%2Fallocator%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fhygiene.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -0,0 +1,31 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+#![allow(nonstandard_style)]\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[allow(dead_code)]\n+struct u8;\n+#[allow(dead_code)]\n+struct usize;\n+#[allow(dead_code)]\n+static arg0: () = ();\n+\n+#[global_allocator]\n+pub static GLOBAL: A = A(AtomicUsize::new(0));\n+\n+fn main() {\n+    let n = GLOBAL.0.load(Ordering::SeqCst);\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+    drop(s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+}"}, {"sha": "2d6710af392709f5cb3251bbb52193db9f17d294", "filename": "src/test/ui/syntax-extension-minor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Ftest%2Fui%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117cdf35d46cb4dbb246e300a492c860a86233be/src%2Ftest%2Fui%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsyntax-extension-minor.rs?ref=117cdf35d46cb4dbb246e300a492c860a86233be", "patch": "@@ -1,14 +1,14 @@\n+// run-pass\n+\n #![feature(concat_idents)]\n \n pub fn main() {\n     struct Foo;\n     let _: concat_idents!(F, oo) = Foo; // Test that `concat_idents!` can be used in type positions\n \n     let asdf_fdsa = \"<.<\".to_string();\n-    // this now fails (correctly, I claim) because hygiene prevents\n-    // the assembled identifier from being a reference to the binding.\n+    // concat_idents should have call-site hygiene.\n     assert!(concat_idents!(asd, f_f, dsa) == \"<.<\".to_string());\n-    //~^ ERROR cannot find value `asdf_fdsa` in this scope\n \n     assert_eq!(stringify!(use_mention_distinction), \"use_mention_distinction\");\n }"}, {"sha": "2d8056da527c613d562fcd3e3b072d1b8786d865", "filename": "src/test/ui/syntax-extension-minor.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8bf776d5c2fc88624d2562e493aab0d324a3b7d8/src%2Ftest%2Fui%2Fsyntax-extension-minor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bf776d5c2fc88624d2562e493aab0d324a3b7d8/src%2Ftest%2Fui%2Fsyntax-extension-minor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsyntax-extension-minor.stderr?ref=8bf776d5c2fc88624d2562e493aab0d324a3b7d8", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `asdf_fdsa` in this scope\n-  --> $DIR/syntax-extension-minor.rs:10:13\n-   |\n-LL |     assert!(concat_idents!(asd, f_f, dsa) == \"<.<\".to_string());\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}]}