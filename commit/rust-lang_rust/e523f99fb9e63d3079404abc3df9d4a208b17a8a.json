{"sha": "e523f99fb9e63d3079404abc3df9d4a208b17a8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MjNmOTlmYjllNjNkMzA3OTQwNGFiYzNkZjlkNGEyMDhiMTdhOGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-30T19:58:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T03:31:19Z"}, "message": "rustdoc: Add the ability to input json\n\nThis modifies the command-line usage of rustdoc to intake its own JSON output as\nwell as a rust source file. This also alters the command line from\n`rustdoc input file`  to `rustdoc file` with the input/output formats specified\nas -r and -w, respectively.\n\nWhen using a JSON input, no passes or plugins are re-run over the json, instead\nthe output is generated directly from the JSON that was provided. Passes and\nplugins are still run on rust source input, however.", "tree": {"sha": "2d26f5a153d47a616758f9ebc3fd4a4d5423ff3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d26f5a153d47a616758f9ebc3fd4a4d5423ff3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e523f99fb9e63d3079404abc3df9d4a208b17a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e523f99fb9e63d3079404abc3df9d4a208b17a8a", "html_url": "https://github.com/rust-lang/rust/commit/e523f99fb9e63d3079404abc3df9d4a208b17a8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e523f99fb9e63d3079404abc3df9d4a208b17a8a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ccbdc90472345bc96fcb3142631a3d75ffb1ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ccbdc90472345bc96fcb3142631a3d75ffb1ab", "html_url": "https://github.com/rust-lang/rust/commit/a3ccbdc90472345bc96fcb3142631a3d75ffb1ab"}], "stats": {"total": 200, "additions": 142, "deletions": 58}, "files": [{"sha": "4663f9c9532b473ce02e83e07d4e966552fc91fb", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e523f99fb9e63d3079404abc3df9d4a208b17a8a/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e523f99fb9e63d3079404abc3df9d4a208b17a8a/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=e523f99fb9e63d3079404abc3df9d4a208b17a8a", "patch": "@@ -227,7 +227,7 @@ RUSTDOC = $(HBIN2_H_$(CFG_BUILD_TRIPLE))/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n define libdoc\n doc/$(1)/index.html: $$(RUSTDOC) $$(TLIB2_T_$(3)_H_$(3))/$(CFG_STDLIB_$(3))\n \t@$$(call E, rustdoc: $$@)\n-\t$(Q)$(RUSTDOC) html $(2)\n+\t$(Q)$(RUSTDOC) $(2)\n \n DOCS += doc/$(1)/index.html\n endef"}, {"sha": "9649454ff422ea230cbb6eda89d63cc76a4ed3e5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e523f99fb9e63d3079404abc3df9d4a208b17a8a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e523f99fb9e63d3079404abc3df9d4a208b17a8a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e523f99fb9e63d3079404abc3df9d4a208b17a8a", "patch": "@@ -76,7 +76,7 @@ struct Cache {\n struct SourceCollector<'self> {\n     seen: HashSet<~str>,\n     dst: Path,\n-    cx: &'self Context,\n+    cx: &'self mut Context,\n }\n \n struct Item<'self> { cx: &'self Context, item: &'self clean::Item, }\n@@ -179,15 +179,15 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         w.flush();\n     }\n \n-    if cx.include_sources {\n+    {\n         let dst = cx.dst.push(\"src\");\n         mkdir(&dst);\n         let dst = dst.push(crate.name);\n         mkdir(&dst);\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n-            cx: &cx,\n+            cx: &mut cx,\n         };\n         crate = folder.fold_crate(crate);\n     }\n@@ -229,16 +229,28 @@ fn clean_srcpath(src: &str, f: &fn(&str)) {\n \n impl<'self> DocFolder for SourceCollector<'self> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if !self.seen.contains(&item.source.filename) {\n-            self.emit_source(item.source.filename);\n+        if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n+            // If it turns out that we couldn't read this file, then we probably\n+            // can't read any of the files (generating html output from json or\n+            // something like that), so just don't include sources for the\n+            // entire crate. The other option is maintaining this mapping on a\n+            // per-file basis, but that's probably not worth it...\n+            self.cx.include_sources = self.emit_source(item.source.filename);\n             self.seen.insert(item.source.filename.clone());\n+\n+            if !self.cx.include_sources {\n+                println!(\"warning: source code was requested to be rendered, \\\n+                          but `{}` is a missing source file.\",\n+                         item.source.filename);\n+                println!(\"         skipping rendering of source code\");\n+            }\n         }\n         self.fold_item_recur(item)\n     }\n }\n \n impl<'self> SourceCollector<'self> {\n-    fn emit_source(&self, filename: &str) {\n+    fn emit_source(&mut self, filename: &str) -> bool {\n         let p = Path(filename);\n \n         // Read the contents of the file\n@@ -251,7 +263,11 @@ impl<'self> SourceCollector<'self> {\n             // If we couldn't open this file, then just returns because it\n             // probably means that it's some standard library macro thing and we\n             // can't have the source to it anyway.\n-            let mut r = match r { Some(r) => r, None => return };\n+            let mut r = match r {\n+                Some(r) => r,\n+                // eew macro hacks\n+                None => return filename == \"<std-macros>\"\n+            };\n \n             // read everything\n             loop {\n@@ -283,6 +299,7 @@ impl<'self> SourceCollector<'self> {\n         };\n         layout::render(&mut w as &mut io::Writer, &self.cx.layout,\n                        &page, &(\"\"), &Source(contents.as_slice()));\n+        return true;\n     }\n }\n "}, {"sha": "96e0464fdde9d045a7d6bd85f80bbc900bf405f6", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 117, "deletions": 50, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e523f99fb9e63d3079404abc3df9d4a208b17a8a/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e523f99fb9e63d3079404abc3df9d4a208b17a8a/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=e523f99fb9e63d3079404abc3df9d4a208b17a8a", "patch": "@@ -21,13 +21,15 @@ extern mod syntax;\n extern mod rustc;\n extern mod extra;\n \n-use extra::serialize::Encodable;\n-use extra::time;\n-use extra::getopts::groups;\n use std::cell::Cell;\n-use std::rt::io;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n+use std::rt::io;\n+use extra::getopts;\n+use extra::getopts::groups;\n+use extra::json;\n+use extra::serialize::{Decodable, Encodable};\n+use extra::time;\n \n pub mod clean;\n pub mod core;\n@@ -70,9 +72,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n \n local_data_key!(pub ctxtkey: @core::DocContext)\n \n-enum OutputFormat {\n-    HTML, JSON\n-}\n+type Output = (clean::Crate, ~[plugins::PluginJson]);\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args()));\n@@ -81,6 +81,12 @@ pub fn main() {\n pub fn opts() -> ~[groups::OptGroup] {\n     use extra::getopts::groups::*;\n     ~[\n+        optflag(\"h\", \"help\", \"show this help message\"),\n+        optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n+               \"[rust|json]\"),\n+        optopt(\"w\", \"output-format\", \"the output type to write\",\n+               \"[html|json]\"),\n+        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n@@ -89,32 +95,22 @@ pub fn opts() -> ~[groups::OptGroup] {\n                  \"PASSES\"),\n         optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n                  \"PLUGINS\"),\n-        optflag(\"h\", \"help\", \"show this help message\"),\n         optflag(\"\", \"nodefaults\", \"don't run the default passes\"),\n-        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n     ]\n }\n \n pub fn usage(argv0: &str) {\n-    println(groups::usage(format!(\"{} [options] [html|json] <crate>\",\n-                                  argv0), opts()));\n+    println(groups::usage(format!(\"{} [options] <input>\", argv0), opts()));\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    //use extra::getopts::groups::*;\n-\n     let matches = groups::getopts(args.tail(), opts()).unwrap();\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         usage(args[0]);\n         return 0;\n     }\n \n-    let mut default_passes = !matches.opt_present(\"nodefaults\");\n-    let mut passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n-\n-    if passes == ~[~\"list\"] {\n+    if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n         println(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -126,25 +122,68 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n-    let (format, cratefile) = match matches.free.clone() {\n-        [~\"json\", crate] => (JSON, crate),\n-        [~\"html\", crate] => (HTML, crate),\n-        [s, _] => {\n-            println!(\"Unknown output format: `{}`\", s);\n-            usage(args[0]);\n+    let (crate, res) = match acquire_input(&matches) {\n+        Ok(pair) => pair,\n+        Err(s) => {\n+            println!(\"input error: {}\", s);\n             return 1;\n         }\n-        [_, .._] => {\n-            println!(\"Expected exactly one crate to process\");\n-            usage(args[0]);\n-            return 1;\n+    };\n+\n+    info2!(\"going to format\");\n+    let started = time::precise_time_ns();\n+    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n+    match matches.opt_str(\"w\") {\n+        Some(~\"html\") | None => {\n+            html::render::run(crate, output.unwrap_or(Path(\"doc\")))\n         }\n-        _ => {\n-            println!(\"Expected an output format and then one crate\");\n-            usage(args[0]);\n+        Some(~\"json\") => {\n+            json_output(crate, res, output.unwrap_or(Path(\"doc.json\")))\n+        }\n+        Some(s) => {\n+            println!(\"unknown output format: {}\", s);\n             return 1;\n         }\n-    };\n+    }\n+    let ended = time::precise_time_ns();\n+    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1000000000f64);\n+\n+    return 0;\n+}\n+\n+/// Looks inside the command line arguments to extract the relevant input format\n+/// and files and then generates the necessary rustdoc output for formatting.\n+fn acquire_input(matches: &getopts::Matches) -> Result<Output, ~str> {\n+    if matches.free.len() == 0 {\n+        return Err(~\"expected an input file to act on\");\n+    } if matches.free.len() > 1 {\n+        return Err(~\"only one input file may be specified\");\n+    }\n+\n+    let input = matches.free[0].as_slice();\n+    match matches.opt_str(\"r\") {\n+        Some(~\"rust\") => Ok(rust_input(input, matches)),\n+        Some(~\"json\") => json_input(input),\n+        Some(s) => Err(\"unknown input format: \" + s),\n+        None => {\n+            if input.ends_with(\".json\") {\n+                json_input(input)\n+            } else {\n+                Ok(rust_input(input, matches))\n+            }\n+        }\n+    }\n+}\n+\n+/// Interprets the input file as a rust source file, passing it through the\n+/// compiler all the way through the analysis passes. The rustdoc output is then\n+/// generated from the cleaned AST of the crate.\n+///\n+/// This form of input will run all of the plug/cleaning passes\n+fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n+    let mut default_passes = !matches.opt_present(\"nodefaults\");\n+    let mut passes = matches.opt_strs(\"passes\");\n+    let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n     let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n@@ -206,45 +245,73 @@ pub fn main_args(args: &[~str]) -> int {\n \n     // Run everything!\n     info2!(\"Executing passes/plugins\");\n-    let (crate, res) = pm.run_plugins(crate);\n+    return pm.run_plugins(crate);\n+}\n \n-    info2!(\"going to format\");\n-    let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n-    match format {\n-        HTML => { html::render::run(crate, output.unwrap_or(Path(\"doc\"))) }\n-        JSON => { jsonify(crate, res, output.unwrap_or(Path(\"doc.json\"))) }\n+/// This input format purely deserializes the json output file. No passes are\n+/// run over the deserialized output.\n+fn json_input(input: &str) -> Result<Output, ~str> {\n+    let input = match ::std::io::file_reader(&Path(input)) {\n+        Ok(i) => i,\n+        Err(s) => return Err(s),\n+    };\n+    match json::from_reader(input) {\n+        Err(s) => Err(s.to_str()),\n+        Ok(json::Object(obj)) => {\n+            let mut obj = obj;\n+            // Make sure the schema is what we expect\n+            match obj.pop(&~\"schema\") {\n+                Some(json::String(version)) => {\n+                    if version.as_slice() != SCHEMA_VERSION {\n+                        return Err(format!(\"sorry, but I only understand \\\n+                                            version {}\", SCHEMA_VERSION))\n+                    }\n+                }\n+                Some(*) => return Err(~\"malformed json\"),\n+                None => return Err(~\"expected a schema version\"),\n+            }\n+            let crate = match obj.pop(&~\"crate\") {\n+                Some(json) => {\n+                    let mut d = json::Decoder(json);\n+                    Decodable::decode(&mut d)\n+                }\n+                None => return Err(~\"malformed json\"),\n+            };\n+            // XXX: this should read from the \"plugins\" field, but currently\n+            //      Json doesn't implement decodable...\n+            let plugin_output = ~[];\n+            Ok((crate, plugin_output))\n+        }\n+        Ok(*) => Err(~\"malformed json input: expected an object at the top\"),\n     }\n-    let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1000000000f64);\n-\n-    return 0;\n }\n \n-fn jsonify(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n+/// Outputs the crate/plugin json as a giant json blob at the specified\n+/// destination.\n+fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = ~extra::treemap::TreeMap::new();\n-    json.insert(~\"schema\", extra::json::String(SCHEMA_VERSION.to_owned()));\n+    json.insert(~\"schema\", json::String(SCHEMA_VERSION.to_owned()));\n     let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = do std::io::with_str_writer |w| {\n-        crate.encode(&mut extra::json::Encoder(w));\n+        crate.encode(&mut json::Encoder(w));\n     };\n-    let crate_json = match extra::json::from_str(crate_json_str) {\n+    let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,\n         Err(_) => fail!(\"Rust generated JSON is invalid??\")\n     };\n \n     json.insert(~\"crate\", crate_json);\n-    json.insert(~\"plugins\", extra::json::Object(plugins_json));\n+    json.insert(~\"plugins\", json::Object(plugins_json));\n \n     let mut file = dst.open_writer(io::Create).unwrap();\n-    let output = extra::json::Object(json).to_str();\n+    let output = json::Object(json).to_str();\n     file.write(output.as_bytes());\n }"}]}