{"sha": "e7f328ea574bbfc3e927be01eb5f7b66bae5a578", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZjMyOGVhNTc0YmJmYzNlOTI3YmUwMWViNWY3YjY2YmFlNWE1Nzg=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-02-01T12:27:56Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-02-14T18:17:52Z"}, "message": "Handle recursive case of dropping structs with field accesses when struct has no dtor.", "tree": {"sha": "ad0555d540a39cc64a973ef702162a6252ec9c41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0555d540a39cc64a973ef702162a6252ec9c41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7f328ea574bbfc3e927be01eb5f7b66bae5a578", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlqEfVAACgkQAXYLT59T\n8VScHQ//RqXRnBcebtI/Z7XwKi94WdEBrNhcuC5xPXpeTixpIvN576az4LnFoWGB\nR6Vbyo2cVrtT1TX4HtEBMaRJYMgYiit79bx1QzsLd26ICHq98WkgOKaiLCKEmfzc\nkya9ygNlyexBYe3NMOQKZz0m8Qn5flbPsG7b3+DwRSuOQceONy/6YwUBKa0ZX0gn\nVJmmweZl5vC5z+1NzFKelG59AW0LRpRvQbepxU9ffTZNb1RwTq4asYb7h0J30Ekg\nNB9UtjQtLH4qWlDEJTIPX2gWOhBe4RDs/x0Qv1RsQffy46trnRh3Mh8QxWObQioJ\nAOVRuYna/bc3GyTFYGbow16U4SZht05JS9A07VXT4J3Vg//uSFygyl5nKLVybvJ6\nRxgJ1ps+bBt04KYeaEwW3yty3zyuzRSNZPUXmseiNwDWsOom7xL7wRYhyG9/SRUX\nQZaWf9OVfiZSv8VCH4tBE0K/IoZfUO3booKnSBHvrrR6NVW5y5gkGK/7K+wQOthS\nz6ORqdzLW/nfb2SFr58GTbJbJBXoWEIOG9ttM/dWXGeLqoVyhVX+Dyeudq31q16s\nVQcXCG2zoF6cSLfs3iyw2r0weQuw+7VWRao4lq9SYaPsA6YZ4yp3ngXfts2G31K5\nWED3RHykPuOPM7bfrpDht0RwuOgOcCo6/MG4KQ1eDETcqXO5cZw=\n=Gp/g\n-----END PGP SIGNATURE-----", "payload": "tree ad0555d540a39cc64a973ef702162a6252ec9c41\nparent 6493ab6f2aa709c019baf640e31699535679553d\nauthor David Wood <david@davidtw.co> 1517488076 +0000\ncommitter David Wood <david@davidtw.co> 1518632272 +0000\n\nHandle recursive case of dropping structs with field accesses when struct has no dtor.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f328ea574bbfc3e927be01eb5f7b66bae5a578", "html_url": "https://github.com/rust-lang/rust/commit/e7f328ea574bbfc3e927be01eb5f7b66bae5a578", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7f328ea574bbfc3e927be01eb5f7b66bae5a578/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6493ab6f2aa709c019baf640e31699535679553d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6493ab6f2aa709c019baf640e31699535679553d", "html_url": "https://github.com/rust-lang/rust/commit/6493ab6f2aa709c019baf640e31699535679553d"}], "stats": {"total": 119, "additions": 71, "deletions": 48}, "files": [{"sha": "af834ede1ee3368d37d655608f9a80cddc77b2a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 71, "deletions": 48, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e7f328ea574bbfc3e927be01eb5f7b66bae5a578/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f328ea574bbfc3e927be01eb5f7b66bae5a578/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e7f328ea574bbfc3e927be01eb5f7b66bae5a578", "patch": "@@ -463,13 +463,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.access_place(\n-                    ContextKind::Drop.new(loc),\n-                    (drop_place, span),\n-                    (Deep, Write(WriteKind::StorageDeadOrDrop)),\n-                    LocalMutationIsAllowed::Yes,\n-                    flow_state,\n-                );\n+                self.visit_terminator_drop(loc, term, flow_state, drop_place, span);\n             }\n             TerminatorKind::DropAndReplace {\n                 location: ref drop_place,\n@@ -717,6 +711,65 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n              self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n     }\n \n+    fn visit_terminator_drop(\n+        &mut self,\n+        loc: Location,\n+        term: &Terminator<'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        drop_place: &Place<'tcx>,\n+        span: Span,\n+    ) {\n+        let ty = drop_place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        match ty.sty {\n+            // When a struct is being dropped, we need to check whether it has a\n+            // destructor, if it does, then we can call it, if it does not then we\n+            // need to check the individual fields instead.\n+            // See #47703.\n+            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+                for (index, field) in def.all_fields().enumerate() {\n+                    let field_ty = field.ty(self.tcx, substs);\n+                    let proj = Projection {\n+                        base: drop_place.clone(),\n+                        elem: ProjectionElem::Field(Field::new(index), field_ty),\n+                    };\n+                    let place = Place::Projection(Box::new(proj));\n+\n+                    match field_ty.sty {\n+                        // It may be the case that this issue occurs with a struct within a\n+                        // struct, so we recurse to handle that.\n+                        ty::TyAdt(def, _) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+                            self.visit_terminator_drop(\n+                                loc,\n+                                term,\n+                                flow_state,\n+                                &place,\n+                                span,\n+                            );\n+                        },\n+                        _ => {\n+                            self.access_place(\n+                                ContextKind::Drop.new(loc),\n+                                (&place, span),\n+                                (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                                LocalMutationIsAllowed::Yes,\n+                                flow_state,\n+                            );\n+                        },\n+                    }\n+                }\n+            },\n+            _ => {\n+                self.access_place(\n+                    ContextKind::Drop.new(loc),\n+                    (drop_place, span),\n+                    (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                    flow_state,\n+                );\n+            },\n+        }\n+    }\n+\n     /// Checks an access to the given place to see if it is allowed. Examines the set of borrows\n     /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n@@ -2073,7 +2126,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// currently in, when such distinction matters.\n     fn each_borrow_involving_path<F>(\n         &mut self,\n-        context: Context,\n+        _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n@@ -2085,50 +2138,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n-        // When this function is called as a result of an `access_terminator` call attempting\n-        // to drop a struct, if that struct does not have a destructor, then we need to check\n-        // each of the fields in the struct. See #47703.\n-        let (access, places) = if let ContextKind::Drop = context.kind {\n-            let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-            match ty.sty {\n-                ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n-                    let mut places = Vec::new();\n-\n-                    for (index, field) in def.all_fields().enumerate() {\n-                        let proj = Projection {\n-                            base: place.clone(),\n-                            elem: ProjectionElem::Field(Field::new(index),\n-                                                        field.ty(self.tcx, substs)),\n-                        };\n-\n-                        places.push(Place::Projection(Box::new(proj)));\n-                    }\n-\n-                    (ShallowOrDeep::Shallow(None), places)\n-                },\n-                _ => (access, vec![ place.clone() ]),\n-            }\n-        } else {\n-            (access, vec![ place.clone() ])\n-        };\n-\n         let data = flow_state.borrows.operator().borrows();\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        for place in places {\n-            let mut elems_incoming = flow_state.borrows.elems_incoming();\n-            while let Some(i) = elems_incoming.next() {\n-                let borrowed = &data[i.borrow_index()];\n-\n-                if self.places_conflict(&borrowed.borrowed_place, &place, access) {\n-                    debug!(\"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n-                           i, borrowed, place, access);\n-                    let ctrl = op(self, i, borrowed);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n+        let mut elems_incoming = flow_state.borrows.elems_incoming();\n+        while let Some(i) = elems_incoming.next() {\n+            let borrowed = &data[i.borrow_index()];\n+\n+            if self.places_conflict(&borrowed.borrowed_place, &place, access) {\n+                debug!(\"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                       i, borrowed, place, access);\n+                let ctrl = op(self, i, borrowed);\n+                if ctrl == Control::Break {\n+                    return;\n                 }\n             }\n         }"}]}