{"sha": "3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYzY4YmFjN2M4OWE4MWVjODNjYmQ4ZjBhZmY5ZGIwMDE0MjVjNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-17T15:46:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-17T15:46:00Z"}, "message": "Auto merge of #46436 - eddyb:unpacked, r=arielb1,oli-obk\n\nDetect unaligned fields via `aggregate.align < field.align`, instead of a `packed` flag.\n\nCloses #46423. cc @oli-obk", "tree": {"sha": "70fa9eb41f9c8f349e9161fd69d500580aa99c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70fa9eb41f9c8f349e9161fd69d500580aa99c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "html_url": "https://github.com/rust-lang/rust/commit/3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af57acef1cd1651861be0bfe77b4f4dd3066ce02", "url": "https://api.github.com/repos/rust-lang/rust/commits/af57acef1cd1651861be0bfe77b4f4dd3066ce02", "html_url": "https://github.com/rust-lang/rust/commit/af57acef1cd1651861be0bfe77b4f4dd3066ce02"}, {"sha": "799a83ca2faf1af870a4120376b47f2511685982", "url": "https://api.github.com/repos/rust-lang/rust/commits/799a83ca2faf1af870a4120376b47f2511685982", "html_url": "https://github.com/rust-lang/rust/commit/799a83ca2faf1af870a4120376b47f2511685982"}], "stats": {"total": 1299, "additions": 518, "deletions": 781}, "files": [{"sha": "054cb2340ada3eb37da870f9f742c88445b6b4bf", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -10,14 +10,13 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, PtrAndAlign, bytes_to_f32, bytes_to_f64};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer, bytes_to_f32, bytes_to_f64};\n \n use std::collections::BTreeMap;\n-use ty::layout::HasDataLayout;\n use std::fmt;\n-use ty::layout;\n use mir;\n use ty;\n+use ty::layout::{self, Align, HasDataLayout};\n use middle::region;\n use std::iter;\n \n@@ -166,7 +165,7 @@ pub struct Allocation {\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n-    pub align: u64,\n+    pub align: Align,\n }\n \n impl Allocation {\n@@ -177,7 +176,7 @@ impl Allocation {\n             bytes: slice.to_owned(),\n             relocations: BTreeMap::new(),\n             undef_mask,\n-            align: 1,\n+            align: Align::from_bytes(1, 1).unwrap(),\n         }\n     }\n }"}, {"sha": "0bfff2a80e6783bdf2f9a517f317cc5e3b799146", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -1,30 +1,11 @@\n #![allow(unknown_lints)]\n \n-use ty::layout::HasDataLayout;\n+use ty::layout::{Align, HasDataLayout};\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic};\n use syntax::ast::FloatTy;\n use rustc_const_math::ConstFloat;\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct PtrAndAlign {\n-    pub ptr: Pointer,\n-    /// Remember whether this place is *supposed* to be aligned.\n-    pub aligned: bool,\n-}\n-\n-impl PtrAndAlign {\n-    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n-        self.ptr.to_ptr()\n-    }\n-    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(PtrAndAlign {\n-            ptr: self.ptr.offset(i, cx)?,\n-            aligned: self.aligned,\n-        })\n-    }\n-}\n-\n pub fn bytes_to_f32(bits: u128) -> ConstFloat {\n     ConstFloat {\n         bits,\n@@ -50,7 +31,7 @@ pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(PtrAndAlign),\n+    ByRef(Pointer, Align),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -182,13 +163,6 @@ pub enum PrimValKind {\n     Char,\n }\n \n-impl<'a, 'tcx: 'a> Value {\n-    #[inline]\n-    pub fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef(PtrAndAlign { ptr, aligned: true })\n-    }\n-}\n-\n impl<'tcx> PrimVal {\n     pub fn from_u128(n: u128) -> Self {\n         PrimVal::Bytes(n)"}, {"sha": "5464fa601ecad1315aa1335c328a0725f05f3131", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -895,7 +895,7 @@ pub struct InterpretInterner<'tcx> {\n     /// Allows checking whether a constant already has an allocation\n     ///\n     /// The pointers are to the beginning of an `alloc_by_id` allocation\n-    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::PtrAndAlign>,\n+    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::Pointer>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n@@ -931,14 +931,14 @@ impl<'tcx> InterpretInterner<'tcx> {\n     pub fn get_cached(\n         &self,\n         global_id: interpret::GlobalId<'tcx>,\n-    ) -> Option<interpret::PtrAndAlign> {\n+    ) -> Option<interpret::Pointer> {\n         self.alloc_cache.get(&global_id).cloned()\n     }\n \n     pub fn cache(\n         &mut self,\n         global_id: interpret::GlobalId<'tcx>,\n-        ptr: interpret::PtrAndAlign,\n+        ptr: interpret::Pointer,\n     ) {\n         if let Some(old) = self.alloc_cache.insert(global_id, ptr) {\n             bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);"}, {"sha": "42987e3dd782a30f5121d8c0d3ccc490f3e314c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 52, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -778,7 +778,6 @@ pub enum Abi {\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n-        packed: bool\n     }\n }\n \n@@ -790,18 +789,7 @@ impl Abi {\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n             Abi::Vector { .. } => false,\n-            Abi::Aggregate { sized, .. } => !sized\n-        }\n-    }\n-\n-    /// Returns true if the fields of the layout are packed.\n-    pub fn is_packed(&self) -> bool {\n-        match *self {\n-            Abi::Uninhabited |\n-            Abi::Scalar(_) |\n-            Abi::ScalarPair(..) |\n-            Abi::Vector { .. } => false,\n-            Abi::Aggregate { packed, .. } => packed\n+            Abi::Aggregate { sized } => !sized\n         }\n     }\n }\n@@ -1077,10 +1065,7 @@ impl<'a, 'tcx> LayoutDetails {\n             }\n \n             let size = min_size.abi_align(align);\n-            let mut abi = Abi::Aggregate {\n-                sized,\n-                packed\n-            };\n+            let mut abi = Abi::Aggregate { sized };\n \n             // Unpack newtype ABIs and find scalar pairs.\n             if sized && size.bytes() > 0 {\n@@ -1254,10 +1239,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: true,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: true },\n                     align: element.align,\n                     size\n                 })\n@@ -1270,10 +1252,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: element.size,\n                         count: 0\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: false,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: false },\n                     align: element.align,\n                     size: Size::from_bytes(0)\n                 })\n@@ -1285,10 +1264,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: Size::from_bytes(1),\n                         count: 0\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: false,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: false },\n                     align: dl.i8_align,\n                     size: Size::from_bytes(0)\n                 })\n@@ -1302,7 +1278,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n                   StructKind::AlwaysSized)?;\n                 match unit.abi {\n-                    Abi::Aggregate { ref mut sized, .. } => *sized = false,\n+                    Abi::Aggregate { ref mut sized } => *sized = false,\n                     _ => bug!()\n                 }\n                 tcx.intern_layout(unit)\n@@ -1418,10 +1394,7 @@ impl<'a, 'tcx> LayoutDetails {\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index: 0 },\n                         fields: FieldPlacement::Union(variants[0].len()),\n-                        abi: Abi::Aggregate {\n-                            sized: true,\n-                            packed\n-                        },\n+                        abi: Abi::Aggregate { sized: true },\n                         align,\n                         size: size.abi_align(align)\n                     }));\n@@ -1525,15 +1498,10 @@ impl<'a, 'tcx> LayoutDetails {\n                             let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n                                 Abi::Scalar(niche.clone())\n                             } else {\n-                                let mut packed = st[i].abi.is_packed();\n                                 if offset.abi_align(niche_align) != offset {\n-                                    packed = true;\n                                     niche_align = dl.i8_align;\n                                 }\n-                                Abi::Aggregate {\n-                                    sized: true,\n-                                    packed\n-                                }\n+                                Abi::Aggregate { sized: true }\n                             };\n                             align = align.max(niche_align);\n \n@@ -1681,10 +1649,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 let abi = if discr.value.size(dl) == size {\n                     Abi::Scalar(discr.clone())\n                 } else {\n-                    Abi::Aggregate {\n-                        sized: true,\n-                        packed: false\n-                    }\n+                    Abi::Aggregate { sized: true }\n                 };\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n@@ -2277,19 +2242,14 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         self.abi.is_unsized()\n     }\n \n-    /// Returns true if the fields of the layout are packed.\n-    pub fn is_packed(&self) -> bool {\n-        self.abi.is_packed()\n-    }\n-\n     /// Returns true if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n             Abi::Uninhabited => true,\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n             Abi::Vector { .. } => false,\n-            Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n+            Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n         }\n     }\n \n@@ -2452,8 +2412,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n                 element.hash_stable(hcx, hasher);\n                 count.hash_stable(hcx, hasher);\n             }\n-            Aggregate { packed, sized } => {\n-                packed.hash_stable(hcx, hasher);\n+            Aggregate { sized } => {\n                 sized.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "c0cce6a461832884c5639afd7b5588b1c0cc5d7a", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 43, "deletions": 68, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, PrimVal, PtrAndAlign};\n-use super::{Place, PlaceExtra, EvalContext, StackPopCleanup, ValTy, HasMemory};\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, Pointer, PrimVal};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy};\n \n use rustc_const_math::ConstInt;\n \n@@ -45,7 +45,7 @@ pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (PtrAndAlign, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Pointer, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n@@ -66,24 +66,18 @@ pub fn eval_body<'a, 'tcx>(\n         assert!(!layout.is_unsized());\n         let ptr = ecx.memory.allocate(\n             layout.size.bytes(),\n-            layout.align.abi(),\n+            layout.align,\n             None,\n         )?;\n-        tcx.interpret_interner.borrow_mut().cache(\n-            cid,\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: !layout.is_packed(),\n-            },\n-        );\n+        tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n         let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"const_eval: pushing stack frame for global: {}\", name);\n         ecx.push_stack_frame(\n             instance,\n             mir.span,\n             mir,\n-            Place::from_ptr(ptr),\n+            Place::from_ptr(ptr, layout.align),\n             cleanup.clone(),\n         )?;\n \n@@ -101,7 +95,7 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n     let ptr_ty = eval_body(tcx, instance, param_env);\n     let (ptr, ty) = ptr_ty?;\n     let ecx = mk_eval_cx(tcx, instance, param_env)?;\n-    let prim = match ecx.read_maybe_aligned(ptr.aligned, |ectx| ectx.try_read_value(ptr.ptr, ty))? {\n+    let prim = match ecx.try_read_value(ptr, ecx.layout_of(ty)?.align, ty)? {\n         Some(Value::ByVal(prim)) => prim.to_bytes()?,\n         _ => return err!(TypeNotPrimitive(ty)),\n     };\n@@ -363,7 +357,9 @@ pub fn const_eval_provider<'a, 'tcx>(\n             (_, Err(err)) => Err(err),\n             (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n                 let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                check_ctfe_against_miri(&mut ecx, miri_val, miri_ty, ctfe.val);\n+                let layout = ecx.layout_of(miri_ty).unwrap();\n+                let miri_place = Place::from_primval_ptr(miri_val, layout.align);\n+                check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n                 Ok(ctfe)\n             }\n         }\n@@ -374,60 +370,49 @@ pub fn const_eval_provider<'a, 'tcx>(\n \n fn check_ctfe_against_miri<'a, 'tcx>(\n     ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    miri_val: PtrAndAlign,\n+    miri_place: Place,\n     miri_ty: Ty<'tcx>,\n     ctfe: ConstVal<'tcx>,\n ) {\n     use rustc::middle::const_val::ConstAggregate::*;\n     use rustc_const_math::ConstFloat;\n     use rustc::ty::TypeVariants::*;\n+    let miri_val = ValTy {\n+        value: ecx.read_place(miri_place).unwrap(),\n+        ty: miri_ty\n+    };\n     match miri_ty.sty {\n         TyInt(int_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let c = ConstInt::new_signed_truncating(prim as i128,\n                                                     int_ty,\n                                                     ecx.tcx.sess.target.isize_ty);\n             let c = ConstVal::Integral(c);\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyUint(uint_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let c = ConstInt::new_unsigned_truncating(prim,\n                                                      uint_ty,\n                                                      ecx.tcx.sess.target.usize_ty);\n             let c = ConstVal::Integral(c);\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyFloat(ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n             assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n         },\n         TyBool => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n+            let bits = get_prim(ecx, miri_val);\n             if bits > 1 {\n                 bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n             }\n             let b = ConstVal::Bool(bits == 1);\n             assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n         },\n         TyChar => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n+            let bits = get_prim(ecx, miri_val);\n             if let Some(cm) = ::std::char::from_u32(bits as u32) {\n                 assert_eq!(\n                     ConstVal::Char(cm), ctfe,\n@@ -438,10 +423,8 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             }\n         },\n         TyStr => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            if let Ok(Some(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)))) = value {\n+            let value = ecx.follow_by_ref_value(miri_val.value, miri_val.ty);\n+            if let Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) = value {\n                 let bytes = ecx\n                     .memory\n                     .read_bytes(ptr.into(), len as u64)\n@@ -465,7 +448,6 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         },\n         TyArray(elem_ty, n) => {\n             let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-            let size = ecx.layout_of(elem_ty).unwrap().size.bytes();\n             let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n                 ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n                     (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n@@ -478,10 +460,12 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n                 },\n                 _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n             };\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n             for (i, elem) in vec.into_iter().enumerate() {\n                 assert!((i as u64) < n);\n-                let ptr = miri_val.offset(size * i as u64, &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem_ty, elem.0);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem_ty, elem.0);\n             }\n         },\n         TyTuple(..) => {\n@@ -491,22 +475,22 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             };\n             let layout = ecx.layout_of(miri_ty).unwrap();\n             for (i, elem) in vec.into_iter().enumerate() {\n-                let offset = layout.fields.offset(i);\n-                let ptr = miri_val.offset(offset.bytes(), &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n             }\n         },\n         TyAdt(def, _) => {\n-            let (struct_variant, extra) = if def.is_enum() {\n-                let discr = ecx.read_discriminant_value(\n-                    Place::Ptr { ptr: miri_val, extra: PlaceExtra::None },\n-                    miri_ty).unwrap();\n+            let mut miri_place = miri_place;\n+            let struct_variant = if def.is_enum() {\n+                let discr = ecx.read_discriminant_value(miri_place, miri_ty).unwrap();\n                 let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n                     variant_discr.to_u128_unchecked() == discr\n                 }).expect(\"miri produced invalid enum discriminant\");\n-                (&def.variants[variant], PlaceExtra::DowncastVariant(variant))\n+                miri_place = ecx.place_downcast(miri_place, variant).unwrap();\n+                &def.variants[variant]\n             } else {\n-                (def.struct_variant(), PlaceExtra::None)\n+                def.struct_variant()\n             };\n             let vec = match ctfe {\n                 ConstVal::Aggregate(Struct(v)) => v,\n@@ -520,13 +504,9 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             let layout = ecx.layout_of(miri_ty).unwrap();\n             for &(name, elem) in vec.into_iter() {\n                 let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n-                let (place, _) = ecx.place_field(\n-                    Place::Ptr { ptr: miri_val, extra },\n-                    Field::new(field),\n-                    layout,\n-                ).unwrap();\n-                let ptr = place.to_ptr_extra_aligned().0;\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(field), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n             }\n         },\n         TySlice(_) => bug!(\"miri produced a slice?\"),\n@@ -546,11 +526,9 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         // should be fine\n         TyFnDef(..) => {}\n         TyFnPtr(_) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n+            let value = ecx.value_to_primval(miri_val);\n             let ptr = match value {\n-                Ok(Some(Value::ByVal(PrimVal::Ptr(ptr)))) => ptr,\n+                Ok(PrimVal::Ptr(ptr)) => ptr,\n                 value => bug!(\"expected fn ptr, got {:?}\", value),\n             };\n             let inst = ecx.memory.get_fn(ptr).unwrap();\n@@ -572,13 +550,10 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n \n fn get_prim<'a, 'tcx>(\n     ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<Option<Value>, EvalError<'tcx>>,\n+    val: ValTy<'tcx>,\n ) -> u128 {\n-    match res {\n-        Ok(Some(Value::ByVal(prim))) => unwrap_miri(ecx, prim.to_bytes()),\n-        Err(err) => unwrap_miri(ecx, Err(err)),\n-        val => bug!(\"got {:?}\", val),\n-    }\n+    let res = ecx.value_to_primval(val).and_then(|prim| prim.to_bytes());\n+    unwrap_miri(ecx, res)\n }\n \n fn unwrap_miri<'a, 'tcx, T>("}, {"sha": "89d0e91a7ec86ceb93904347db468adb2f0ec9a0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 123, "deletions": 198, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    PtrAndAlign, GlobalId, Value, Pointer, PrimVal, PrimValKind,\n+    GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n \n@@ -211,8 +211,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n         let size = layout.size.bytes();\n-        let align = layout.align.abi();\n-        self.memory.allocate(size, align, Some(MemoryKind::Stack))\n+        self.memory.allocate(size, layout.align, Some(MemoryKind::Stack))\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n@@ -241,7 +240,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ))\n     }\n \n-    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n \n         let primval = match *const_val {\n@@ -261,11 +260,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                let cid = GlobalId {\n+                return Ok(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                };\n-                return Ok(Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"static/const not cached\")));\n+                }, self.layout_of(ty)?));\n             }\n \n             Aggregate(..) |\n@@ -499,7 +497,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr)) = local {\n+        if let Some(Value::ByRef(ptr, _align)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -613,12 +611,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 let value = self.eval_operand(operand)?.value;\n \n-                let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n+                let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n                 // FIXME: speed up repeat filling\n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, &self)?;\n-                    self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n+                    self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n                 }\n             }\n \n@@ -638,12 +636,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 // We ignore the alignment of the place here -- special handling for packed structs ends\n                 // at the `&` operator.\n-                let (ptr, extra) = self.force_allocation(src)?.to_ptr_extra_aligned();\n+                let (ptr, _align, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n \n                 let val = match extra {\n-                    PlaceExtra::None => ptr.ptr.to_value(),\n-                    PlaceExtra::Length(len) => ptr.ptr.to_value_with_len(len),\n-                    PlaceExtra::Vtable(vtable) => ptr.ptr.to_value_with_vtable(vtable),\n+                    PlaceExtra::None => ptr.to_value(),\n+                    PlaceExtra::Length(len) => ptr.to_value_with_len(len),\n+                    PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     PlaceExtra::DowncastVariant(..) => {\n                         bug!(\"attempted to take a reference to an enum downcast place\")\n                     }\n@@ -678,7 +676,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 match kind {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n-                        self.unsize_into(src.value, src.ty, dest, dest_ty)?;\n+                        let src_layout = self.layout_of(src.ty)?;\n+                        let dst_layout = self.layout_of(dest_ty)?;\n+                        self.unsize_into(src.value, src_layout, dest, dst_layout)?;\n                     }\n \n                     Misc => {\n@@ -831,14 +831,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 use rustc::mir::Literal;\n                 let mir::Constant { ref literal, .. } = **constant;\n                 let value = match *literal {\n-                    Literal::Value { ref value } => self.const_to_value(&value.val)?,\n+                    Literal::Value { ref value } => self.const_to_value(&value.val, ty)?,\n \n                     Literal::Promoted { index } => {\n-                        let cid = GlobalId {\n+                        self.read_global_as_value(GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n-                        };\n-                        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"promoted not cached\"))\n+                        }, self.layout_of(ty)?)\n                     }\n                 };\n \n@@ -950,17 +949,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n-        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"))\n-    }\n-\n-    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"cannot copy from an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi();\n-        self.memory.copy(src, dest, size, align, false)?;\n-        Ok(())\n+    pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n+        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n+                     layout.align)\n     }\n \n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n@@ -969,20 +960,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return err!(DeadLocal),\n-                    Some(Value::ByRef(ptr)) => {\n+                    Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n                             ptr,\n+                            align,\n                             extra: PlaceExtra::None,\n                         }\n                     }\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n+                        let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n                         self.stack[frame].locals[local.index() - 1] =\n-                            Some(Value::by_ref(ptr.into())); // it stays live\n-                        self.write_value_to_ptr(val, ptr.into(), ty)?;\n-                        Place::from_ptr(ptr)\n+                            Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n+                        let place = Place::from_ptr(ptr, layout.align);\n+                        self.write_value(ValTy { value: val, ty }, place)?;\n+                        place\n                     }\n                 }\n             }\n@@ -998,8 +992,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n+            Value::ByRef(ptr, align) => {\n+                self.read_value(ptr, align, ty)\n             }\n             other => Ok(other),\n         }\n@@ -1054,15 +1048,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Place::Ptr {\n-                ptr: PtrAndAlign { ptr, aligned },\n-                extra,\n-            } => {\n+            Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                self.write_maybe_aligned_mut(\n-                    aligned,\n-                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty),\n-                )\n+                self.write_value_to_ptr(src_val, ptr, align, dest_ty)\n             }\n \n             Place::Local { frame, local } => {\n@@ -1085,27 +1073,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(PtrAndAlign {\n-                                ptr: dest_ptr,\n-                                aligned,\n-                            }) = old_dest_val\n-        {\n+        if let Value::ByRef(dest_ptr, align) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n             // pointers into the local variable, and must be able to observe the change.\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_maybe_aligned_mut(aligned, |ectx| {\n-                ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty)\n-            })?;\n-\n-        } else if let Value::ByRef(PtrAndAlign {\n-                                       ptr: src_ptr,\n-                                       aligned,\n-                                   }) = src_val\n-        {\n+            self.write_value_to_ptr(src_val, dest_ptr, align, dest_ty)?;\n+        } else if let Value::ByRef(src_ptr, align) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1117,17 +1094,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.read_maybe_aligned_mut(aligned, |ectx| {\n-                if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n-                    write_dest(ectx, src_val)?;\n-                } else {\n-                    let dest_ptr = ectx.alloc_ptr(dest_ty)?.into();\n-                    ectx.copy(src_ptr, dest_ptr, dest_ty)?;\n-                    write_dest(ectx, Value::by_ref(dest_ptr))?;\n-                }\n-                Ok(())\n-            })?;\n-\n+            if let Ok(Some(src_val)) = self.try_read_value(src_ptr, align, dest_ty) {\n+                write_dest(self, src_val)?;\n+            } else {\n+                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n+                let layout = self.layout_of(dest_ty)?;\n+                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size.bytes(), false)?;\n+                write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n+            }\n         } else {\n             // Finally, we have the simple case where neither source nor destination are\n             // `ByRef`. We may simply copy the source value over the the destintion.\n@@ -1140,61 +1114,38 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         value: Value,\n         dest: Pointer,\n+        dest_align: Align,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value_to_ptr: {:#?}\", value);\n+        let layout = self.layout_of(dest_ty)?;\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n+            Value::ByRef(ptr, align) => {\n+                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size.bytes(), false)\n             }\n             Value::ByVal(primval) => {\n-                let layout = self.layout_of(dest_ty)?;\n-                if layout.is_zst() {\n-                    assert!(primval.is_undef());\n-                    Ok(())\n-                } else {\n-                    // TODO: Do we need signedness?\n-                    self.memory.write_maybe_aligned_mut(!layout.is_packed(), |mem| {\n-                        mem.write_primval(dest.to_ptr()?, primval, layout.size.bytes(), false)\n-                    })\n+                match layout.abi {\n+                    layout::Abi::Scalar(_) => {}\n+                    _ if primval.is_undef() => {}\n+                    _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n                 }\n+                // TODO: Do we need signedness?\n+                self.memory.write_primval(dest.to_ptr()?, dest_align, primval, layout.size.bytes(), false)\n             }\n-            Value::ByValPair(a, b) => {\n+            Value::ByValPair(a_val, b_val) => {\n                 let ptr = dest.to_ptr()?;\n-                let mut layout = self.layout_of(dest_ty)?;\n-                trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                let mut packed = layout.is_packed();\n-                'outer: loop {\n-                    for i in 0..layout.fields.count() {\n-                        let field = layout.field(&self, i)?;\n-                        if layout.fields.offset(i).bytes() == 0 && layout.size == field.size {\n-                            layout = field;\n-                            packed |= layout.is_packed();\n-                            continue 'outer;\n-                        }\n-                    }\n-                    break;\n-                }\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                assert_eq!(layout.fields.count(), 2);\n-                let field_0 = layout.field(&self, 0)?;\n-                let field_1 = layout.field(&self, 1)?;\n-                trace!(\"write_value_to_ptr field 0: {:#?}\", field_0);\n-                trace!(\"write_value_to_ptr field 1: {:#?}\", field_1);\n-                assert_eq!(\n-                    field_0.is_packed(),\n-                    field_1.is_packed(),\n-                    \"the two fields must agree on being packed\"\n-                );\n-                packed |= field_0.is_packed();\n-                let field_0_ptr = ptr.offset(layout.fields.offset(0).bytes(), &self)?.into();\n-                let field_1_ptr = ptr.offset(layout.fields.offset(1).bytes(), &self)?.into();\n+                let (a, b) = match layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n+                    _ => bug!(\"write_value_to_ptr: invalid ByValPair layout: {:#?}\", layout)\n+                };\n+                let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let a_ptr = ptr;\n+                let b_offset = a_size.abi_align(b.align(&self));\n+                let b_ptr = ptr.offset(b_offset.bytes(), &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_maybe_aligned_mut(!packed, |mem| {\n-                    mem.write_primval(field_0_ptr, a, field_0.size.bytes(), false)?;\n-                    mem.write_primval(field_1_ptr, b, field_1.size.bytes(), false)\n-                })?;\n-                Ok(())\n+                self.memory.write_primval(a_ptr, dest_align, a_val, a_size.bytes(), false)?;\n+                self.memory.write_primval(b_ptr, dest_align, b_val, b_size.bytes(), false)\n             }\n         }\n     }\n@@ -1277,8 +1228,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let Some(val) = self.try_read_value(ptr, ty)? {\n+    pub fn read_value(&self, ptr: Pointer, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        if let Some(val) = self.try_read_value(ptr, align, ty)? {\n             Ok(val)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", ty);\n@@ -1288,34 +1239,35 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn read_ptr(\n         &self,\n         ptr: MemoryPointer,\n+        ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         let ptr_size = self.memory.pointer_size();\n-        let p : Pointer = self.memory.read_ptr_sized_unsigned(ptr)?.into();\n+        let p: Pointer = self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr_sized_unsigned(extra)?.to_ptr()?,\n+                    self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => Ok(\n-                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra)?.to_bytes()? as u64),\n+                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_bytes()? as u64),\n                 ),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n         }\n     }\n \n-    pub fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, 1, false)?;\n+                let val = self.memory.read_primval(ptr, ptr_align, 1, false)?;\n                 let val = match val {\n                     PrimVal::Bytes(0) => false,\n                     PrimVal::Bytes(1) => true,\n@@ -1325,7 +1277,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 PrimVal::from_bool(val)\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, 4, false)?.to_bytes()? as u32;\n+                let c = self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1342,7 +1294,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, size, true)?\n+                self.memory.read_primval(ptr, ptr_align, size, true)?\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1355,19 +1307,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, size, false)?\n+                self.memory.read_primval(ptr, ptr_align, size, false)?\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::Bytes(self.memory.read_primval(ptr, 4, false)?.to_bytes()?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::Bytes(self.memory.read_primval(ptr, 8, false)?.to_bytes()?),\n+            ty::TyFloat(FloatTy::F32) => {\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()?)\n+            }\n+            ty::TyFloat(FloatTy::F64) => {\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 8, false)?.to_bytes()?)\n+            }\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?,\n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, ptr_align, tam.ty).map(Some),\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n+                    return self.read_ptr(ptr, ptr_align, ty.boxed_ty()).map(Some);\n                 }\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n@@ -1376,7 +1332,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         signed = s;\n                     }\n                     let size = scalar.value.size(self).bytes();\n-                    self.memory.read_primval(ptr, size, signed)?\n+                    self.memory.read_primval(ptr, ptr_align, size, signed)?\n                 } else {\n                     return Ok(None);\n                 }\n@@ -1462,101 +1418,71 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn unsize_into(\n         &mut self,\n         src: Value,\n-        src_ty: Ty<'tcx>,\n+        src_layout: TyLayout<'tcx>,\n         dst: Place,\n-        dst_ty: Ty<'tcx>,\n+        dst_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let src_layout = self.layout_of(src_ty)?;\n-        let dst_layout = self.layout_of(dst_ty)?;\n-        match (&src_ty.sty, &dst_ty.sty) {\n+        match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n             (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n             (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n             (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n-                self.unsize_into_ptr(src, src_ty, dst, dst_ty, s.ty, d.ty)\n+                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s.ty, d.ty)\n             }\n             (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+                assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n-                        panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dst_ty);\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src_layout, dst_layout);\n                     }\n                     return self.unsize_into_ptr(\n                         src,\n-                        src_ty,\n+                        src_layout.ty,\n                         dst,\n-                        dst_ty,\n-                        src_ty.boxed_ty(),\n-                        dst_ty.boxed_ty(),\n+                        dst_layout.ty,\n+                        src_layout.ty.boxed_ty(),\n+                        dst_layout.ty.boxed_ty(),\n                     );\n                 }\n-                if self.ty_to_primval_kind(src_ty).is_ok() {\n-                    // TODO: We ignore the packed flag here\n-                    let sty = src_layout.field(&self, 0)?.ty;\n-                    let dty = dst_layout.field(&self, 0)?.ty;\n-                    return self.unsize_into(src, sty, dst, dty);\n-                }\n+\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n-\n-                assert_eq!(def_a, def_b);\n-\n-                let src_ptr = match src {\n-                    Value::ByRef(PtrAndAlign { ptr, aligned: true }) => ptr,\n-                    // the entire struct is just a pointer\n-                    Value::ByVal(_) => {\n-                        for i in 0..src_layout.fields.count() {\n-                            let src_field = src_layout.field(&self, i)?;\n-                            let dst_field = dst_layout.field(&self, i)?;\n-                            if dst_layout.is_zst() {\n-                                continue;\n-                            }\n-                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(src_field.size, src_layout.size);\n-                            assert_eq!(dst_field.size, dst_layout.size);\n-                            return self.unsize_into(\n-                                src,\n-                                src_field.ty,\n-                                dst,\n-                                dst_field.ty,\n-                            );\n-                        }\n-                        bug!(\"by val unsize into where the value doesn't cover the entire type\")\n-                    }\n-                    // TODO: Is it possible for unaligned pointers to occur here?\n-                    _ => bug!(\"expected aligned pointer, got {:?}\", src),\n-                };\n-\n-                // FIXME(solson)\n-                let dst = self.force_allocation(dst)?.to_ptr()?;\n                 for i in 0..src_layout.fields.count() {\n-                    let src_field = src_layout.field(&self, i)?;\n-                    let dst_field = dst_layout.field(&self, i)?;\n+                    let (dst_f_place, dst_field) =\n+                        self.place_field(dst, mir::Field::new(i), dst_layout)?;\n                     if dst_field.is_zst() {\n                         continue;\n                     }\n-                    let src_field_offset = src_layout.fields.offset(i).bytes();\n-                    let dst_field_offset = dst_layout.fields.offset(i).bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset, &self)?;\n-                    let dst_f_ptr = dst.offset(dst_field_offset, &self)?;\n+                    let (src_f_value, src_field) = match src {\n+                        Value::ByRef(ptr, align) => {\n+                            let src_place = Place::from_primval_ptr(ptr, align);\n+                            let (src_f_place, src_field) =\n+                                self.place_field(src_place, mir::Field::new(i), src_layout)?;\n+                            (self.read_place(src_f_place)?, src_field)\n+                        }\n+                        Value::ByVal(_) | Value::ByValPair(..) => {\n+                            let src_field = src_layout.field(&self, i)?;\n+                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(src_field.size, src_layout.size);\n+                            (src, src_field)\n+                        }\n+                    };\n                     if src_field.ty == dst_field.ty {\n-                        self.copy(src_f_ptr, dst_f_ptr.into(), src_field.ty)?;\n+                        self.write_value(ValTy {\n+                            value: src_f_value,\n+                            ty: src_field.ty,\n+                        }, dst_f_place)?;\n                     } else {\n-                        self.unsize_into(\n-                            Value::by_ref(src_f_ptr),\n-                            src_field.ty,\n-                            Place::from_ptr(dst_f_ptr),\n-                            dst_field.ty,\n-                        )?;\n+                        self.unsize_into(src_f_value, src_field, dst_f_place, dst_field)?;\n                     }\n                 }\n                 Ok(())\n             }\n             _ => {\n                 bug!(\n                     \"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                    src_ty,\n-                    dst_ty\n+                    src_layout,\n+                    dst_layout\n                 )\n             }\n         }\n@@ -1580,11 +1506,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Err(err) => {\n                         panic!(\"Failed to access local: {:?}\", err);\n                     }\n-                    Ok(Value::ByRef(PtrAndAlign { ptr, aligned })) => {\n+                    Ok(Value::ByRef(ptr, align)) => {\n                         match ptr.into_inner_primval() {\n                             PrimVal::Ptr(ptr) => {\n-                                write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" })\n-                                    .unwrap();\n+                                write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n@@ -1610,10 +1535,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 trace!(\"{}\", msg);\n                 self.memory.dump_allocs(allocs);\n             }\n-            Place::Ptr { ptr: PtrAndAlign { ptr, aligned }, .. } => {\n+            Place::Ptr { ptr, align, .. } => {\n                 match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n-                        trace!(\"by {}ref:\", if aligned { \"\" } else { \"unaligned \" });\n+                        trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),"}, {"sha": "671fe29c0e1bc0cfcc11b62c852bf04943ce8a77", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 76, "deletions": 134, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -1,13 +1,12 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{ptr, mem, io};\n-use std::cell::Cell;\n \n use rustc::ty::{Instance, TyCtxt};\n-use rustc::ty::layout::{self, TargetDataLayout};\n+use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, Pointer,\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n \n use super::{EvalContext, Machine};\n@@ -51,11 +50,6 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Maximum number of virtual bytes that may be allocated.\n     memory_size: u64,\n \n-    /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n-    /// alignment checking is currently enforced for read and/or write accesses.\n-    reads_are_aligned: Cell<bool>,\n-    writes_are_aligned: Cell<bool>,\n-\n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n \n@@ -72,8 +66,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             tcx,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            reads_are_aligned: Cell::new(true),\n-            writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -98,12 +90,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn allocate(\n         &mut self,\n         size: u64,\n-        align: u64,\n+        align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        assert_ne!(align, 0);\n-        assert!(align.is_power_of_two());\n-\n         if self.memory_size - self.memory_usage < size {\n             return err!(OutOfMemory {\n                 allocation_size: size,\n@@ -139,13 +128,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         old_size: u64,\n-        old_align: u64,\n+        old_align: Align,\n         new_size: u64,\n-        new_align: u64,\n+        new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        use std::cmp::min;\n-\n         if ptr.offset != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -163,9 +150,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, Some(kind))?;\n         self.copy(\n             ptr.into(),\n+            old_align,\n             new_ptr.into(),\n-            min(old_size, new_size),\n-            min(old_align, new_align),\n+            new_align,\n+            old_size.min(new_size),\n             /*nonoverlapping*/\n             true,\n         )?;\n@@ -190,7 +178,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn deallocate(\n         &mut self,\n         ptr: MemoryPointer,\n-        size_and_align: Option<(u64, u64)>,\n+        size_and_align: Option<(u64, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n@@ -236,7 +224,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                return err!(IncorrectAllocationInformation(size, alloc.bytes.len(), align, alloc.align));\n+                return err!(IncorrectAllocationInformation(size, alloc.bytes.len(), align.abi(), alloc.align.abi()));\n             }\n         }\n \n@@ -255,7 +243,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, align: u64, access: Option<AccessKind>) -> EvalResult<'tcx> {\n+    pub fn check_align(&self, ptr: Pointer, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n@@ -267,32 +255,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                (v, align) // the base address if the \"integer allocation\" is 0 and hence always aligned\n+                // the base address if the \"integer allocation\" is 0 and hence always aligned\n+                (v, required_align)\n             }\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n-        // See if alignment checking is disabled\n-        let enforce_alignment = match access {\n-            Some(AccessKind::Read) => self.reads_are_aligned.get(),\n-            Some(AccessKind::Write) => self.writes_are_aligned.get(),\n-            None => true,\n-        };\n-        if !enforce_alignment {\n-            return Ok(());\n-        }\n         // Check alignment\n-        if alloc_align < align {\n+        if alloc_align.abi() < required_align.abi() {\n             return err!(AlignmentCheckFailed {\n-                has: alloc_align,\n-                required: align,\n+                has: alloc_align.abi(),\n+                required: required_align.abi(),\n             });\n         }\n-        if offset % align == 0 {\n+        if offset % required_align.abi() == 0 {\n             Ok(())\n         } else {\n             err!(AlignmentCheckFailed {\n-                has: offset % align,\n-                required: align,\n+                has: offset % required_align.abi(),\n+                required: required_align.abi(),\n             })\n         }\n     }\n@@ -437,7 +417,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 \"{}({} bytes, alignment {}){}\",\n                 msg,\n                 alloc.bytes.len(),\n-                alloc.align,\n+                alloc.align.abi(),\n                 immutable\n             );\n \n@@ -482,10 +462,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        self.check_align(ptr.into(), align, Some(AccessKind::Read))?;\n+        self.check_align(ptr.into(), align)?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -502,10 +482,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        self.check_align(ptr.into(), align, Some(AccessKind::Write))?;\n+        self.check_align(ptr.into(), align)?;\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -518,7 +498,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(&mut alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return err!(ReadPointerAsBytes);\n@@ -531,7 +511,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n@@ -629,14 +609,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n         src: Pointer,\n+        src_align: Align,\n         dest: Pointer,\n+        dest_align: Align,\n         size: u64,\n-        align: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be aligned\n-        self.check_align(src, align, Some(AccessKind::Read))?;\n-        self.check_align(dest, align, Some(AccessKind::Write))?;\n+        self.check_align(src, src_align)?;\n+        self.check_align(dest, dest_align)?;\n         if size == 0 {\n             return Ok(());\n         }\n@@ -655,8 +636,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             })\n             .collect();\n \n-        let src_bytes = self.get_bytes_unchecked(src, size, align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size, align)?.as_mut_ptr();\n+        let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -705,41 +686,44 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Read))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.get_bytes(ptr.to_ptr()?, size, 1)\n+        self.get_bytes(ptr.to_ptr()?, size, align)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if src.is_empty() {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, align)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if count == 0 {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n         for b in bytes {\n             *b = val;\n         }\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianess = self.endianess();\n-        let bytes = self.get_bytes_unchecked(ptr, size, self.int_align(size))?;\n+        let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n@@ -767,11 +751,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(PrimVal::Bytes(bytes))\n     }\n \n-    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n-        self.read_primval(ptr, self.pointer_size(), false)\n+    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n+        self.read_primval(ptr, ptr_align, self.pointer_size(), false)\n     }\n \n-    pub fn write_primval(&mut self, ptr: MemoryPointer, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n \n         let bytes = match val {\n@@ -802,7 +786,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n         {\n             let align = self.int_align(size);\n-            let dst = self.get_bytes_mut(ptr, size, align)?;\n+            let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n             if signed {\n                 write_target_int(endianess, dst, bytes as i128).unwrap();\n             } else {\n@@ -824,22 +808,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, val: PrimVal) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_primval(ptr, val, ptr_size, false)\n+        self.write_primval(ptr, ptr_align, val, ptr_size, false)\n     }\n \n-    fn int_align(&self, size: u64) -> u64 {\n+    fn int_align(&self, size: u64) -> Align {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume signed and unsigned integers of the same size have the same alignment.\n-        match size {\n-            1 => self.tcx.data_layout.i8_align.abi(),\n-            2 => self.tcx.data_layout.i16_align.abi(),\n-            4 => self.tcx.data_layout.i32_align.abi(),\n-            8 => self.tcx.data_layout.i64_align.abi(),\n-            16 => self.tcx.data_layout.i128_align.abi(),\n+        let ity = match size {\n+            1 => layout::I8,\n+            2 => layout::I16,\n+            4 => layout::I32,\n+            8 => layout::I64,\n+            16 => layout::I128,\n             _ => bug!(\"bad integer size: {}\", size),\n-        }\n+        };\n+        ity.align(self)\n     }\n }\n \n@@ -1004,52 +989,15 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n     fn memory(&self) -> &Memory<'a, 'tcx, M>;\n \n-    // These are not supposed to be overriden.\n-    fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().reads_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().reads_are_aligned.set(old && aligned);\n-        let t = f(self);\n-        self.memory().reads_are_aligned.set(old);\n-        t\n-    }\n-\n-    fn read_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().reads_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().reads_are_aligned.set(old && aligned);\n-        let t = f(self);\n-        self.memory().reads_are_aligned.set(old);\n-        t\n-    }\n-\n-    fn write_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().writes_are_aligned.get();\n-        // Do alignment checking if *all* nested calls say it has to be aligned.\n-        self.memory().writes_are_aligned.set(old && aligned);\n-        let t = f(self);\n-        self.memory().writes_are_aligned.set(old);\n-        t\n-    }\n-\n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n     fn into_ptr(\n         &self,\n         value: Value,\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(match value {\n-            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n+            Value::ByRef(ptr, align) => {\n+                self.memory().read_ptr_sized_unsigned(ptr.to_ptr()?, align)?\n             }\n             Value::ByVal(ptr) |\n             Value::ByValPair(ptr, _) => ptr,\n@@ -1061,17 +1009,14 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         match value {\n-            Value::ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      aligned,\n-                  }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let vtable = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_ptr()?;\n-                    Ok((ptr, vtable))\n-                })\n+            Value::ByRef(ref_ptr, align) => {\n+                let mem = self.memory();\n+                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n+                let vtable = mem.read_ptr_sized_unsigned(\n+                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    align\n+                )?.to_ptr()?;\n+                Ok((ptr, vtable))\n             }\n \n             Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n@@ -1086,17 +1031,14 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, (Pointer, u64)> {\n         match value {\n-            Value::ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      aligned,\n-                  }) => {\n-                self.memory().read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let len = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_bytes()? as u64;\n-                    Ok((ptr, len))\n-                })\n+            Value::ByRef(ref_ptr, align) => {\n+                let mem = self.memory();\n+                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n+                let len = mem.read_ptr_sized_unsigned(\n+                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    align\n+                )?.to_bytes()? as u64;\n+                Ok((ptr, len))\n             }\n             Value::ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;"}, {"sha": "097f769adcf1f3ac92b07068aee9c3badd7eadbe", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -1,10 +1,9 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, PtrAndAlign};\n \n-use rustc::mir::interpret::{Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -15,7 +14,8 @@ pub enum Place {\n         /// An place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: PtrAndAlign,\n+        ptr: Pointer,\n+        align: Align,\n         extra: PlaceExtra,\n     },\n \n@@ -35,34 +35,38 @@ pub enum PlaceExtra {\n impl<'tcx> Place {\n     /// Produces an Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef.into())\n+        Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn from_primval_ptr(ptr: Pointer) -> Self {\n+    pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n         Place::Ptr {\n-            ptr: PtrAndAlign { ptr, aligned: true },\n+            ptr,\n+            align,\n             extra: PlaceExtra::None,\n         }\n     }\n \n-    pub fn from_ptr(ptr: MemoryPointer) -> Self {\n-        Self::from_primval_ptr(ptr.into())\n+    pub fn from_ptr(ptr: MemoryPointer, align: Align) -> Self {\n+        Self::from_primval_ptr(ptr.into(), align)\n     }\n \n-    pub fn to_ptr_extra_aligned(self) -> (PtrAndAlign, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (Pointer, Align, PlaceExtra) {\n         match self {\n-            Place::Ptr { ptr, extra } => (ptr, extra),\n+            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n+    pub fn to_ptr_align(self) -> (Pointer, Align) {\n+        let (ptr, align, _extra) = self.to_ptr_align_extra();\n+        (ptr, align)\n+    }\n+\n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        let (ptr, extra) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n-        assert_eq!(extra, PlaceExtra::None);\n-        ptr.to_ptr()\n+        self.to_ptr_align().0.to_ptr()\n     }\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n@@ -102,13 +106,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Directly reading a static will always succeed\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n-                let cid = GlobalId {\n+                Ok(Some(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                };\n-                Ok(Some(Value::ByRef(\n-                    self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\"),\n-                )))\n+                }, self.layout_of(self.place_ty(place))?)))\n             }\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n@@ -169,9 +170,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn read_place(&self, place: Place) -> EvalResult<'tcx, Value> {\n         match place {\n-            Place::Ptr { ptr, extra } => {\n+            Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr))\n+                Ok(Value::ByRef(ptr, align))\n             }\n             Place::Local { frame, local } => self.stack[frame].get_local(local),\n         }\n@@ -192,8 +193,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     instance,\n                     promoted: None,\n                 };\n+                let layout = self.layout_of(self.place_ty(mir_place))?;\n                 Place::Ptr {\n                     ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n+                    align: layout.align,\n                     extra: PlaceExtra::None,\n                 }\n             }\n@@ -229,18 +232,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let offset = base_layout.fields.offset(field_index);\n \n         // Do not allocate in trivial cases\n-        let (base_ptr, base_extra) = match base {\n-            Place::Ptr { ptr, extra } => (ptr, extra),\n+        let (base_ptr, base_align, base_extra) = match base {\n+            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             Place::Local { frame, local } => {\n-                match self.stack[frame].get_local(local)? {\n+                match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n-                    Value::ByVal(_) if offset.bytes() == 0 &&\n-                                       field.size == base_layout.size => {\n+                    (&Value::ByVal(_), &layout::Abi::Scalar(_)) |\n+                    (&Value::ByValPair(..), &layout::Abi::ScalarPair(..))\n+                        if offset.bytes() == 0 && field.size == base_layout.size =>\n+                    {\n                         return Ok((base, field));\n                     }\n-                    Value::ByRef { .. } |\n-                    Value::ByValPair(..) |\n-                    Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n+                    _ => self.force_allocation(base)?.to_ptr_align_extra(),\n                 }\n             }\n         };\n@@ -249,18 +252,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             PlaceExtra::Vtable(tab) => {\n                 let (_, align) = self.size_and_align_of_dst(\n                     base_layout.ty,\n-                    base_ptr.ptr.to_value_with_vtable(tab),\n+                    base_ptr.to_value_with_vtable(tab),\n                 )?;\n                 offset.abi_align(align).bytes()\n             }\n             _ => offset.bytes(),\n         };\n \n-        let mut ptr = base_ptr.offset(offset, &self)?;\n-        // if we were unaligned, stay unaligned\n-        // no matter what we were, if we are packed, we must not be aligned anymore\n-        ptr.aligned &= !base_layout.is_packed();\n-\n+        let ptr = base_ptr.offset(offset, &self)?;\n+        let align = base_align.min(base_layout.align).min(field.align);\n         let extra = if !field.is_unsized() {\n             PlaceExtra::None\n         } else {\n@@ -275,26 +275,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             base_extra\n         };\n \n-        Ok((Place::Ptr { ptr, extra }, field))\n+        Ok((Place::Ptr { ptr, align, extra }, field))\n     }\n \n     pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n+        let layout = self.layout_of(ty)?;\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    ptr,\n+                    align: layout.align,\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = self.into_slice(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, aligned: true },\n+                    ptr,\n+                    align: layout.align,\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n-            _ => Place::from_primval_ptr(self.into_ptr(val)?),\n+            _ => Place::from_primval_ptr(self.into_ptr(val)?, layout.align),\n         })\n     }\n \n@@ -306,7 +309,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n-        let (base_ptr, _) = base.to_ptr_extra_aligned();\n+        let (base_ptr, align) = base.to_ptr_align();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n         let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -319,6 +322,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let ptr = base_ptr.offset(n * elem_size, &*self)?;\n         Ok(Place::Ptr {\n             ptr,\n+            align,\n             extra: PlaceExtra::None,\n         })\n     }\n@@ -330,9 +334,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // FIXME(solson)\n         let base = self.force_allocation(base)?;\n-        let (ptr, _) = base.to_ptr_extra_aligned();\n+        let (ptr, align) = base.to_ptr_align();\n         let extra = PlaceExtra::DowncastVariant(variant);\n-        Ok(Place::Ptr { ptr, extra })\n+        Ok(Place::Ptr { ptr, align, extra })\n     }\n \n     pub fn eval_place_projection(\n@@ -342,14 +346,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, Place> {\n         use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match *proj_elem {\n+        match *proj_elem {\n             Field(field, _) => {\n                 let layout = self.layout_of(base_ty)?;\n-                return Ok(self.place_field(base, field, layout)?.0);\n+                Ok(self.place_field(base, field, layout)?.0)\n             }\n \n             Downcast(_, variant) => {\n-                return self.place_downcast(base, variant);\n+                self.place_downcast(base, variant)\n             }\n \n             Deref => {\n@@ -364,14 +368,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                 trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                return self.val_to_place(val, pointee_type);\n+                self.val_to_place(val, pointee_type)\n             }\n \n             Index(local) => {\n                 let value = self.frame().get_local(local)?;\n                 let ty = self.tcx.types.usize;\n                 let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n-                return self.place_index(base, base_ty, n);\n+                self.place_index(base, base_ty, n)\n             }\n \n             ConstantIndex {\n@@ -381,7 +385,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_extra_aligned();\n+                let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -394,13 +398,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n \n                 let ptr = base_ptr.offset(index * elem_size, &self)?;\n-                (ptr, PlaceExtra::None)\n+                Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n             }\n \n             Subslice { from, to } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_extra_aligned();\n+                let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -412,11 +416,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 } else {\n                     PlaceExtra::Length(n - u64::from(to) - u64::from(from))\n                 };\n-                (ptr, extra)\n+                Ok(Place::Ptr { ptr, align, extra })\n             }\n-        };\n-\n-        Ok(Place::Ptr { ptr, extra })\n+        }\n     }\n \n     pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {"}, {"sha": "0b5801c3539953c064d627983321ba91094761e3", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -8,7 +8,7 @@ use rustc::mir;\n use rustc::ty::{self, Instance};\n use rustc::ty::layout::LayoutOf;\n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::{PtrAndAlign, GlobalId};\n+use rustc::mir::interpret::GlobalId;\n \n use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n use super::{EvalContext, StackPopCleanup, Place, Machine};\n@@ -179,16 +179,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         assert!(!layout.is_unsized());\n         let ptr = self.memory.allocate(\n             layout.size.bytes(),\n-            layout.align.abi(),\n+            layout.align,\n             None,\n         )?;\n-        self.tcx.interpret_interner.borrow_mut().cache(\n-            cid,\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: !layout.is_packed(),\n-            },\n-        );\n+        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n         let internally_mutable = !layout.ty.is_freeze(self.tcx, self.param_env, span);\n         let mutability = if mutability == Mutability::Mutable || internally_mutable {\n             Mutability::Mutable\n@@ -203,7 +197,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             instance,\n             span,\n             mir,\n-            Place::from_ptr(ptr),\n+            Place::from_ptr(ptr, layout.align),\n             cleanup,\n         )?;\n         Ok(true)\n@@ -270,22 +264,16 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                     assert!(!layout.is_unsized());\n                     let ptr = this.ecx.memory.allocate(\n                         layout.size.bytes(),\n-                        layout.align.abi(),\n+                        layout.align,\n                         None,\n                     )?;\n-                    this.ecx.tcx.interpret_interner.borrow_mut().cache(\n-                        cid,\n-                        PtrAndAlign {\n-                            ptr: ptr.into(),\n-                            aligned: !layout.is_packed(),\n-                        },\n-                    );\n+                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(\n                         this.instance,\n                         constant.span,\n                         mir,\n-                        Place::from_ptr(ptr),\n+                        Place::from_ptr(ptr, layout.align),\n                         StackPopCleanup::MarkStatic(Mutability::Immutable),\n                     )?;\n                     Ok(true)"}, {"sha": "c5942712b87ddfb8f7e95373ee1279964c35cdcd", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -21,16 +21,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let val = match self.force_allocation(place)? {\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::Vtable(vtable),\n-            } => ptr.ptr.to_value_with_vtable(vtable),\n+            } => ptr.to_value_with_vtable(vtable),\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::Length(len),\n-            } => ptr.ptr.to_value_with_len(len),\n+            } => ptr.to_value_with_len(len),\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::None,\n-            } => ptr.ptr.to_value(),\n+            } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span, target)"}, {"sha": "1f6e4a7cde7836ec85ef7b8443926a0fc5d605ab", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use rustc::mir::interpret::{PtrAndAlign, EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n use super::{EvalContext, eval_context,\n             Place, Machine, ValTy};\n \n@@ -327,15 +327,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if let ty::TyTuple(..) = args[1].ty.sty {\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 match args[1].value {\n-                                    Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n-                                        assert!(\n-                                            aligned,\n-                                            \"Unaligned ByRef-values cannot occur as function arguments\"\n-                                        );\n+                                    Value::ByRef(ptr, align) => {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n                                             let offset = layout.fields.offset(i).bytes();\n-                                            let arg = Value::by_ref(ptr.offset(offset, &self)?);\n+                                            let arg = Value::ByRef(ptr.offset(offset, &self)?,\n+                                                                   align.min(field.align));\n                                             let dest =\n                                                 self.eval_place(&mir::Place::Local(arg_local))?;\n                                             trace!(\n@@ -403,9 +400,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n+                let ptr_align = self.tcx.data_layout.pointer_align;\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n                 let fn_ptr = self.memory.read_ptr_sized_unsigned(\n-                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?\n+                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n+                    ptr_align\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();"}, {"sha": "22417201f0dc5d0f36ba5796b0e26597f53ad0ce", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -26,28 +26,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let align = layout.align.abi();\n \n         let ptr_size = self.memory.pointer_size();\n+        let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n-            ptr_size,\n+            ptr_align,\n             None,\n         )?;\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, PrimVal::Ptr(drop))?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, PrimVal::Bytes(size as u128))?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, PrimVal::Bytes(size as u128))?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, PrimVal::Bytes(align as u128))?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, PrimVal::Bytes(align as u128))?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, PrimVal::Ptr(fn_ptr))?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, PrimVal::Ptr(fn_ptr))?;\n             }\n         }\n \n@@ -64,7 +65,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n-        match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n+        let pointer_align = self.tcx.data_layout.pointer_align;\n+        match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n             Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n             Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n@@ -77,9 +79,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?)?.to_bytes()? as u64;\n+        let pointer_align = self.tcx.data_layout.pointer_align;\n+        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n         let align = self.memory.read_ptr_sized_unsigned(\n-            vtable.offset(pointer_size * 2, self)?\n+            vtable.offset(pointer_size * 2, self)?,\n+            pointer_align\n         )?.to_bytes()? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }"}, {"sha": "78ab25f222e50ed8e7a6cb991ba1fe4c9fe55200", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -30,7 +30,7 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use mir::place::{Alignment, PlaceRef};\n+use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n@@ -561,14 +561,14 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            OperandValue::Ref(val, Alignment::AbiAligned).store(bcx, dst)\n+            OperandValue::Ref(val, self.layout.align).store(bcx, dst)\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n-                bcx.store(val, cast_dst, Some(self.layout.align));\n+                bcx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -585,19 +585,20 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", cast.align(ccx));\n                 let scratch_size = cast.size(ccx);\n+                let scratch_align = cast.align(ccx);\n+                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", scratch_align);\n                 bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n-                bcx.store(val, llscratch, None);\n+                bcx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n                                   C_usize(ccx, self.layout.size.bytes()),\n-                                  self.layout.align.min(cast.align(ccx)));\n+                                  self.layout.align.min(scratch_align));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n             }"}, {"sha": "911ec56188752c5abaab0416bd0affcf1de69ecd", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -316,7 +316,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n-                        (src_f.alignment | dst_f.alignment).non_abi());\n+                        src_f.align.min(dst_f.align));\n                 } else {\n                     coerce_unsized_into(bcx, src_f, dst_f);\n                 }\n@@ -430,14 +430,13 @@ pub fn memcpy_ty<'a, 'tcx>(\n     dst: ValueRef,\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n-    align: Option<Align>,\n+    align: Align,\n ) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    let align = align.unwrap_or(layout.align);\n     call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n }\n "}, {"sha": "5b697d6b99c95d7a42a96b91291bed6a373610fe", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -518,13 +518,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n+    pub fn load(&self, ptr: ValueRef, align: Align) -> ValueRef {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(load, align.abi() as c_uint);\n             load\n         }\n     }\n@@ -573,16 +571,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<Align>) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            if let Some(align) = align {\n-                llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n-            }\n+            llvm::LLVMSetAlignment(store, align.abi() as c_uint);\n             store\n         }\n     }"}, {"sha": "9477adc17c01966eecc760c2f2f1e9dd87222f18", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -69,7 +69,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n             let field_ty = layout.field(ccx, i).ty;\n-            let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n@@ -81,6 +81,13 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // Return the sum of sizes and max of aligns.\n             let size = bcx.add(sized_size, unsized_size);\n \n+            // Packed types ignore the alignment of their fields.\n+            if let ty::TyAdt(def, _) = t.sty {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n             let align = match (const_to_opt_u128(sized_align, false),"}, {"sha": "f1cb8b224b3dc29ce9c74541bd8da2d05f97edd4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -14,7 +14,7 @@ use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType, PassMode};\n-use mir::place::{PlaceRef, Alignment};\n+use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n@@ -106,7 +106,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let name = &*tcx.item_name(def_id);\n \n     let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n-    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n+    let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n@@ -254,7 +254,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n                 let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bcx.load(ptr, align.non_abi())\n+                    bcx.load(ptr, align)\n                 } else {\n                     if dst.layout.is_zst() {\n                         return;\n@@ -330,9 +330,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n \n                             let dest = result.project_field(bcx, 0);\n-                            bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                            bcx.store(val, dest.llval, dest.align);\n                             let dest = result.project_field(bcx, 1);\n-                            bcx.store(overflow, dest.llval, dest.alignment.non_abi());\n+                            bcx.store(overflow, dest.llval, dest.align);\n \n                             return;\n                         },\n@@ -473,9 +473,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n \n                         let dest = result.project_field(bcx, 0);\n-                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(val, dest.llval, dest.align);\n                         let dest = result.project_field(bcx, 1);\n-                        bcx.store(success, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(success, dest.llval, dest.align);\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -544,7 +544,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             let dst = args[0].deref(bcx.ccx);\n             let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bcx.load(ptr, align.non_abi())\n+                bcx.load(ptr, align)\n             } else {\n                 from_immediate(bcx, args[1].immediate())\n             };\n@@ -677,7 +677,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     for i in 0..elems.len() {\n                         let dest = result.project_field(bcx, i);\n                         let val = bcx.extract_value(val, i as u64);\n-                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        bcx.store(val, dest.llval, dest.align);\n                     }\n                     return;\n                 }\n@@ -688,8 +688,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n-            bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n+            let ptr = bcx.pointercast(result.llval, ty.llvm_type(ccx).ptr_to());\n+            bcx.store(llval, ptr, result.align);\n         } else {\n             OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n                 .val.store(bcx, result);\n@@ -758,7 +758,8 @@ fn try_intrinsic<'a, 'tcx>(\n ) {\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, ptr_align);\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n     } else {\n@@ -833,7 +834,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.alloca(i64p, \"slot\", ccx.data_layout().pointer_align);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        let slot = bcx.alloca(i64p, \"slot\", ptr_align);\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -848,13 +850,15 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(ccx, 0), slot]);\n-        let addr = catchpad.load(slot, None);\n-        let arg1 = catchpad.load(addr, None);\n+        let addr = catchpad.load(slot, ptr_align);\n+\n+        let i64_align = bcx.tcx().data_layout.i64_align;\n+        let arg1 = catchpad.load(addr, i64_align);\n         let val1 = C_i32(ccx, 1);\n-        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), None);\n+        let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        catchpad.store(arg1, local_ptr, None);\n-        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), None);\n+        catchpad.store(arg1, local_ptr, i64_align);\n+        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n         caught.ret(C_i32(ccx, 1));\n@@ -863,7 +867,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest, None);\n+    let i32_align = bcx.tcx().data_layout.i32_align;\n+    bcx.store(ret, dest, i32_align);\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n@@ -923,14 +928,16 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.llfn());\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), ptr_align);\n         catch.ret(C_i32(ccx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest, None);\n+    let i32_align = bcx.tcx().data_layout.i32_align;\n+    bcx.store(ret, dest, i32_align);\n }\n \n // Helper function to give a Block to a closure to translate a shim function."}, {"sha": "4be2774d3c20c7ea079dcc6b490c719578effda3", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -40,7 +40,8 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        let ptr_align = bcx.tcx().data_layout.pointer_align;\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), ptr_align);\n         bcx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -52,7 +53,8 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n+        let usize_align = bcx.tcx().data_layout.pointer_align;\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), usize_align);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr"}, {"sha": "eba2928d84c18a73553338f2537eab941fcd352c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::Pos;\n \n use super::{MirContext, LocalRef};\n use super::constant::Const;\n-use super::place::{Alignment, PlaceRef};\n+use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n@@ -216,7 +216,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n                         let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n-                            bcx.load(llval, align.non_abi())\n+                            bcx.load(llval, align)\n                         } else {\n                             op.immediate_or_packed_pair(&bcx)\n                         }\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                             LocalRef::Place(tr_place) => {\n                                 OperandRef {\n-                                    val: Ref(tr_place.llval, tr_place.alignment),\n+                                    val: Ref(tr_place.llval, tr_place.align),\n                                     layout: tr_place.layout\n                                 }\n                             }\n@@ -240,14 +240,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 scratch.llval\n                             }\n                             Ref(llval, align) => {\n-                                assert_eq!(align, Alignment::AbiAligned,\n+                                assert_eq!(align.abi(), op.layout.align.abi(),\n                                            \"return place is unaligned!\");\n                                 llval\n                             }\n                         };\n                         bcx.load(\n                             bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n-                            Some(self.fn_ty.ret.layout.align))\n+                            self.fn_ty.ret.layout.align)\n                     }\n                 };\n                 bcx.ret(llval);\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         (&mir::Operand::Constant(_), Ref(..)) => {\n                             let tmp = PlaceRef::alloca(&bcx, op.layout, \"const\");\n                             op.val.store(&bcx, tmp);\n-                            op.val = Ref(tmp.llval, tmp.alignment);\n+                            op.val = Ref(tmp.llval, tmp.align);\n                         }\n                         _ => {}\n                     }\n@@ -639,38 +639,40 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     PassMode::Indirect(_) | PassMode::Cast(_) => {\n                         let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n                         op.val.store(bcx, scratch);\n-                        (scratch.llval, Alignment::AbiAligned, true)\n+                        (scratch.llval, scratch.align, true)\n                     }\n                     _ => {\n-                        (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n+                        (op.immediate_or_packed_pair(bcx), arg.layout.align, false)\n                     }\n                 }\n             }\n-            Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n-                // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n-                // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n-                // have scary latent bugs around.\n-\n-                let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n-                base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align.non_abi());\n-                (scratch.llval, Alignment::AbiAligned, true)\n+            Ref(llval, align) => {\n+                if arg.is_indirect() && align.abi() < arg.layout.align.abi() {\n+                    // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n+                    // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n+                    // have scary latent bugs around.\n+\n+                    let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n+                    base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align);\n+                    (scratch.llval, scratch.align, true)\n+                } else {\n+                    (llval, align, true)\n+                }\n             }\n-            Ref(llval, align) => (llval, align, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n-                                 (align | Alignment::Packed(arg.layout.align))\n-                                    .non_abi());\n+                                 align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bcx.load(llval, align.non_abi());\n+                llval = bcx.load(llval, align);\n                 if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bcx.range_metadata(llval, 0..2);\n@@ -820,21 +822,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             self.trans_place(bcx, dest)\n         };\n         if fn_ret.is_indirect() {\n-            match dest.alignment {\n-                Alignment::AbiAligned => {\n-                    llargs.push(dest.llval);\n-                    ReturnDest::Nothing\n-                },\n-                Alignment::Packed(_) => {\n-                    // Currently, MIR code generation does not create calls\n-                    // that store directly to fields of packed structs (in\n-                    // fact, the calls it creates write only to temps),\n-                    //\n-                    // If someone changes that, please update this code path\n-                    // to create a temporary.\n-                    span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n-                }\n+            if dest.align.abi() < dest.layout.align.abi() {\n+                // Currently, MIR code generation does not create calls\n+                // that store directly to fields of packed structs (in\n+                // fact, the calls it creates write only to temps),\n+                //\n+                // If someone changes that, please update this code path\n+                // to create a temporary.\n+                span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n             }\n+            llargs.push(dest.llval);\n+            ReturnDest::Nothing\n         } else {\n             ReturnDest::Store(dest)\n         }\n@@ -874,8 +872,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n-        src.val.store(bcx,\n-            PlaceRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n+        src.val.store(bcx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n \n "}, {"sha": "69105b0cd8678ef66a840770725cddf7a1cb61db", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -42,7 +42,6 @@ use syntax::ast;\n use std::fmt;\n use std::ptr;\n \n-use super::place::Alignment;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n@@ -182,12 +181,12 @@ impl<'a, 'tcx> Const<'tcx> {\n             let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n             OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n-                              Alignment::AbiAligned)\n+                              layout.align)\n         };\n \n         OperandRef {\n             val,\n-            layout: ccx.layout_of(self.ty)\n+            layout\n         }\n     }\n }\n@@ -1134,12 +1133,14 @@ fn trans_const_adt<'a, 'tcx>(\n             if let layout::FieldPlacement::Union(_) = l.fields {\n                 assert_eq!(variant_index, 0);\n                 assert_eq!(vals.len(), 1);\n+                let (field_size, field_align) = ccx.size_and_align_of(vals[0].ty);\n                 let contents = [\n                     vals[0].llval,\n-                    padding(ccx, l.size - ccx.size_of(vals[0].ty))\n+                    padding(ccx, l.size - field_size)\n                 ];\n \n-                Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n+                let packed = l.align.abi() < field_align.abi();\n+                Const::new(C_struct(ccx, &contents, packed), t)\n             } else {\n                 if let layout::Abi::Vector { .. } = l.abi {\n                     if let layout::FieldPlacement::Array { .. } = l.fields {\n@@ -1232,28 +1233,33 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // offset of current value\n+    let mut packed = false;\n     let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n     cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n     if let Some(discr) = discr {\n+        let (field_size, field_align) = ccx.size_and_align_of(discr.ty);\n+        packed |= layout.align.abi() < field_align.abi();\n         cfields.push(discr.llval);\n-        offset = ccx.size_of(discr.ty);\n+        offset = field_size;\n     }\n \n     let parts = layout.fields.index_by_increasing_offset().map(|i| {\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n+        let (field_size, field_align) = ccx.size_and_align_of(val.ty);\n+        packed |= layout.align.abi() < field_align.abi();\n         cfields.push(padding(ccx, target_offset - offset));\n         cfields.push(val.llval);\n-        offset = target_offset + ccx.size_of(val.ty);\n+        offset = target_offset + field_size;\n     }\n \n     // Pad to the size of the whole type, not e.g. the variant.\n     cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n \n-    Const::new(C_struct(ccx, &cfields, layout.is_packed()), layout.ty)\n+    Const::new(C_struct(ccx, &cfields, packed), layout.ty)\n }\n \n fn padding(ccx: &CrateContext, size: Size) -> ValueRef {"}, {"sha": "917ff87a674b6cc7121f1878637e07a5065f030c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::place::{Alignment, PlaceRef};\n+use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -279,9 +279,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_PLACE && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Place(PlaceRef::new_sized(llretptr,\n-                                                          layout,\n-                                                          Alignment::AbiAligned))\n+                    LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     LocalRef::Place(PlaceRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n@@ -474,7 +472,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            PlaceRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n+            PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n         } else {\n             let tmp = PlaceRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n@@ -532,11 +530,11 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = PlaceRef::alloca(bcx,\n+                let scratch = PlaceRef::alloca(bcx,\n                     bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n-                bcx.store(place.llval, alloc.llval, None);\n-                alloc.llval\n+                bcx.store(place.llval, scratch.llval, scratch.align);\n+                scratch.llval\n             } else {\n                 place.llval\n             };"}, {"sha": "c88235371f907d51d9749d86a6d60475ffca48e2", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty;\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -25,7 +25,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::place::{Alignment, PlaceRef};\n+use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -34,7 +34,7 @@ use super::place::{Alignment, PlaceRef};\n pub enum OperandValue {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(ValueRef, Alignment),\n+    Ref(ValueRef, Align),\n     /// A single LLVM value.\n     Immediate(ValueRef),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n@@ -107,11 +107,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n+        let layout = ccx.layout_of(projected_ty);\n         PlaceRef {\n             llval: llptr,\n             llextra,\n-            layout: ccx.layout_of(projected_ty),\n-            alignment: Alignment::AbiAligned,\n+            layout,\n+            align: layout.align,\n         }\n     }\n \n@@ -222,9 +223,9 @@ impl<'a, 'tcx> OperandValue {\n         match self {\n             OperandValue::Ref(r, source_align) =>\n                 base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n-                                (source_align | dest.alignment).non_abi()),\n+                                source_align.min(dest.align)),\n             OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n+                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.align);\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n@@ -233,7 +234,7 @@ impl<'a, 'tcx> OperandValue {\n                     if common::val_ty(x) == Type::i1(bcx.ccx) {\n                         llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                     }\n-                    bcx.store(base::from_immediate(bcx, x), llptr, dest.alignment.non_abi());\n+                    bcx.store(base::from_immediate(bcx, x), llptr, dest.align);\n                 }\n             }\n         }"}, {"sha": "b556b6a132312f0f98a02f7ce39d50264318fddf", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 37, "deletions": 80, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -24,54 +24,10 @@ use value::Value;\n use glue;\n \n use std::ptr;\n-use std::ops;\n \n use super::{MirContext, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Alignment {\n-    Packed(Align),\n-    AbiAligned,\n-}\n-\n-impl ops::BitOr for Alignment {\n-    type Output = Self;\n-\n-    fn bitor(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Alignment::Packed(a), Alignment::Packed(b)) => {\n-                Alignment::Packed(a.min(b))\n-            }\n-            (Alignment::Packed(x), _) | (_, Alignment::Packed(x)) => {\n-                Alignment::Packed(x)\n-            }\n-            (Alignment::AbiAligned, Alignment::AbiAligned) => {\n-                Alignment::AbiAligned\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> From<TyLayout<'a>> for Alignment {\n-    fn from(layout: TyLayout) -> Self {\n-        if layout.is_packed() {\n-            Alignment::Packed(layout.align)\n-        } else {\n-            Alignment::AbiAligned\n-        }\n-    }\n-}\n-\n-impl Alignment {\n-    pub fn non_abi(self) -> Option<Align> {\n-        match self {\n-            Alignment::Packed(x) => Some(x),\n-            Alignment::AbiAligned => None,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx> {\n     /// Pointer to the contents of the place\n@@ -83,28 +39,28 @@ pub struct PlaceRef<'tcx> {\n     /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n \n-    /// Whether this place is known to be aligned according to its layout\n-    pub alignment: Alignment,\n+    /// What alignment we know for this place\n+    pub align: Align,\n }\n \n impl<'a, 'tcx> PlaceRef<'tcx> {\n     pub fn new_sized(llval: ValueRef,\n                      layout: TyLayout<'tcx>,\n-                     alignment: Alignment)\n+                     align: Align)\n                      -> PlaceRef<'tcx> {\n         PlaceRef {\n             llval,\n             llextra: ptr::null_mut(),\n             layout,\n-            alignment\n+            align\n         }\n     }\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n-        Self::new_sized(tmp, layout, Alignment::AbiAligned)\n+        Self::new_sized(tmp, layout, layout.align)\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n@@ -171,7 +127,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             let llval = if !const_llval.is_null() {\n                 const_llval\n             } else {\n-                let load = bcx.load(self.llval, self.alignment.non_abi());\n+                let load = bcx.load(self.llval, self.align);\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n@@ -185,7 +141,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 if scalar.is_bool() {\n                     llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n                 }\n-                let load = bcx.load(llptr, self.alignment.non_abi());\n+                let load = bcx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n                     bcx.trunc(load, Type::i1(bcx.ccx))\n@@ -195,7 +151,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             };\n             OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n-            OperandValue::Ref(self.llval, self.alignment)\n+            OperandValue::Ref(self.llval, self.align)\n         };\n \n         OperandRef { val, layout: self.layout }\n@@ -206,7 +162,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let ccx = bcx.ccx;\n         let field = self.layout.field(ccx, ix);\n         let offset = self.layout.fields.offset(ix);\n-        let alignment = self.alignment | Alignment::from(self.layout);\n+        let align = self.align.min(self.layout.align).min(field.align);\n \n         let simple = || {\n             // Unions and newtypes only use an offset of 0.\n@@ -228,29 +184,31 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     ptr::null_mut()\n                 },\n                 layout: field,\n-                alignment,\n+                align,\n             }\n         };\n \n-        // Simple case - we can just GEP the field\n-        //   * Packed struct - There is no alignment padding\n-        //   * Field is sized - pointer is properly aligned already\n-        if self.layout.is_packed() || !field.is_unsized() {\n-            return simple();\n-        }\n-\n-        // If the type of the last field is [T], str or a foreign type, then we don't need to do\n-        // any adjusments\n+        // Simple cases, which don't need DST adjustment:\n+        //   * no metadata available - just log the case\n+        //   * known alignment - sized types, [T], str or a foreign type\n+        //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n+            _ if !self.has_extra() => {\n+                debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                    ix, Value(self.llval));\n+                return simple();\n+            }\n+            _ if !field.is_unsized() => return simple(),\n             ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n-            _ => ()\n-        }\n-\n-        // There's no metadata available, log the case and just do the GEP.\n-        if !self.has_extra() {\n-            debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                ix, Value(self.llval));\n-            return simple();\n+            ty::TyAdt(def, _) => {\n+                if def.repr.packed() {\n+                    // FIXME(eddyb) generalize the adjustment when we\n+                    // start supporting packing to larger alignments.\n+                    assert_eq!(self.layout.align.abi(), 1);\n+                    return simple();\n+                }\n+            }\n+            _ => {}\n         }\n \n         // We need to get the pointer manually now.\n@@ -273,17 +231,17 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let unaligned_offset = C_usize(ccx, offset.bytes());\n \n         // Get the alignment of the field\n-        let (_, align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n+        let (_, unsized_align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_usize(ccx, 1u64));\n+        let align_sub_1 = bcx.sub(unsized_align, C_usize(ccx, 1u64));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-        bcx.neg(align));\n+        bcx.neg(unsized_align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n@@ -299,7 +257,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n             layout: field,\n-            alignment,\n+            align,\n         }\n     }\n \n@@ -372,7 +330,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     .discriminant_for_variant(bcx.tcx(), variant_index)\n                     .to_u128_unchecked() as u64;\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n-                    ptr.llval, ptr.alignment.non_abi());\n+                    ptr.llval, ptr.align);\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -416,7 +374,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n             llextra: ptr::null_mut(),\n             layout: self.layout.field(bcx.ccx, 0),\n-            alignment: self.alignment\n+            align: self.align\n         }\n     }\n \n@@ -465,9 +423,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                PlaceRef::new_sized(consts::get_static(ccx, def_id),\n-                                     ccx.layout_of(self.monomorphize(&ty)),\n-                                     Alignment::AbiAligned)\n+                let layout = ccx.layout_of(self.monomorphize(&ty));\n+                PlaceRef::new_sized(consts::get_static(ccx, def_id), layout, layout.align)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,"}, {"sha": "9d705eda9fbef1e87d2b0b654beea1cfa747bb18", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -104,9 +104,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = dest.alignment.non_abi()\n-                        .unwrap_or(tr_elem.layout.align);\n-                    let align = C_i32(bcx.ccx, align.abi() as i32);\n+                    let align = C_i32(bcx.ccx, dest.align.abi() as i32);\n                     let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n@@ -139,7 +137,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n                 tr_elem.val.store(&body_bcx,\n-                    PlaceRef::new_sized(current, tr_elem.layout, dest.alignment));\n+                    PlaceRef::new_sized(current, tr_elem.layout, dest.align));\n \n                 let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n                 body_bcx.br(header_bcx.llbb());"}, {"sha": "8d9bc07fe5630257c60dd90846ec1027a3c62780", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -79,13 +79,14 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n             let fill = Type::padding_filler(ccx, layout.size, layout.align);\n+            let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &[fill], layout.is_packed())\n+                    Type::struct_(ccx, &[fill], packed)\n                 }\n                 Some(ref name) => {\n                     let mut llty = Type::named_struct(ccx, name);\n-                    llty.set_struct_body(&[fill], layout.is_packed());\n+                    llty.set_struct_body(&[fill], packed);\n                     llty\n                 }\n             }\n@@ -96,7 +97,8 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &struct_llfields(ccx, layout), layout.is_packed())\n+                    let (llfields, packed) = struct_llfields(ccx, layout);\n+                    Type::struct_(ccx, &llfields, packed)\n                 }\n                 Some(ref name) => {\n                     let llty = Type::named_struct(ccx, name);\n@@ -109,15 +111,19 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                             layout: TyLayout<'tcx>) -> Vec<Type> {\n+                             layout: TyLayout<'tcx>)\n+                             -> (Vec<Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n \n+    let mut packed = false;\n     let mut offset = Size::from_bytes(0);\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(ccx, i);\n+        packed |= layout.align.abi() < field.align.abi();\n+\n         let target_offset = layout.fields.offset(i as usize);\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n             i, field, offset, target_offset);\n@@ -129,15 +135,6 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(ccx));\n-\n-        if layout.is_packed() {\n-            assert_eq!(padding.bytes(), 0);\n-        } else {\n-            assert!(field.align.abi() <= layout.align.abi(),\n-                    \"non-packed type has field with larger align ({}): {:#?}\",\n-                    field.align.abi(), layout);\n-        }\n-\n         offset = target_offset + field.size;\n         prev_align = field.align;\n     }\n@@ -158,7 +155,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                offset, layout.size);\n     }\n \n-    result\n+    (result, packed)\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n@@ -301,7 +298,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n-            llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())\n+            let (llfields, packed) = struct_llfields(ccx, layout);\n+            llty.set_struct_body(&llfields, packed)\n         }\n \n         llty"}, {"sha": "86ea113061969f0227249807538e1504c77ad951", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3cc68bac7c89a81ec83cbd8f0aff9db001425c50/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=3cc68bac7c89a81ec83cbd8f0aff9db001425c50", "patch": "@@ -23,7 +23,7 @@\n # Each tool has a list of people to ping\n \n # ping @oli-obk @RalfJung @eddyb\n-miri = \"Testing\"\n+miri = \"Broken\"\n \n # ping @Manishearth @llogiq @mcarton @oli-obk\n clippy = \"Testing\""}]}