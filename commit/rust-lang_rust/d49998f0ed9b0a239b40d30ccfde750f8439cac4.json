{"sha": "d49998f0ed9b0a239b40d30ccfde750f8439cac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OTk5OGYwZWQ5YjBhMjM5YjQwZDMwY2NmZGU3NTBmODQzOWNhYzQ=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-27T01:00:33Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-27T22:20:58Z"}, "message": "Switching over to wrappers for spawning functions of multiple arguments. Doesn't quite work yet.", "tree": {"sha": "0d4de1a48c57f336578fc2fda528bbd9a16abb16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d4de1a48c57f336578fc2fda528bbd9a16abb16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d49998f0ed9b0a239b40d30ccfde750f8439cac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d49998f0ed9b0a239b40d30ccfde750f8439cac4", "html_url": "https://github.com/rust-lang/rust/commit/d49998f0ed9b0a239b40d30ccfde750f8439cac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d49998f0ed9b0a239b40d30ccfde750f8439cac4/comments", "author": null, "committer": null, "parents": [{"sha": "842bf7cad12dedbbd16e0838f4dd616acc765421", "url": "https://api.github.com/repos/rust-lang/rust/commits/842bf7cad12dedbbd16e0838f4dd616acc765421", "html_url": "https://github.com/rust-lang/rust/commit/842bf7cad12dedbbd16e0838f4dd616acc765421"}], "stats": {"total": 224, "additions": 164, "deletions": 60}, "files": [{"sha": "e80100cc55d6fae5be9841b7f7b1a8ee7770e26d", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -113,7 +113,7 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n                         T_ptr(T_tydesc(tn))),\n         new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n         start_task=d(\"start_task\", [T_taskptr(tn), \n-                                    T_int(), T_int(), T_size_t()],\n+                                    T_int(), T_int()],\n                      T_taskptr(tn)),\n         new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n         start_thread=d(\"start_thread\", [T_taskptr(tn), T_int(), T_int(),"}, {"sha": "9f3d4b8b3b31e2c8c4a1e64a555a9f59c310f1da", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 114, "deletions": 42, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -601,7 +601,7 @@ fn type_of_explicit_args(&@crate_ctxt cx, &ast::span sp,\n             assert (arg.mode == ty::mo_alias);\n             atys += [T_typaram_ptr(cx.tn)];\n         } else {\n-            let TypeRef t;\n+           let TypeRef t;\n             alt (arg.mode) {\n                 case (ty::mo_alias) {\n                     t = T_ptr(type_of_inner(cx, sp, arg.ty));\n@@ -5867,22 +5867,24 @@ fn trans_spawn(&@block_ctxt cx,\n     //\n     // 3. Fill the tuple with the arguments we evaluated.\n     // \n-    // 4. Pass a pointer to the spawnee function and the argument tuple to\n-    // upcall_start_task.\n+    // 3.5. Generate a wrapper function that takes the tuple and unpacks it to\n+    // call the real task.\n+    //\n+    // 4. Pass a pointer to the wrapper function and the argument tuple to\n+    // upcall_start_task. In order to do this, we need to allocate another\n+    // tuple that matches the arguments expected by rust_task::start.\n     //\n     // 5. Oh yeah, we have to create the task before we start it...\n     \n     // Translate the arguments, remembering their types and where the values\n     // ended up.\n \n-    // There are 3 integers, for magic.\n-    let vec[ty::t] arg_tys = [ty::idx_int, ty::idx_int, ty::idx_int];\n+    let vec[ty::t] arg_tys = [];\n     let vec[ValueRef] arg_vals = [];\n     for(@ast::expr e in args) {\n         auto arg = trans_expr(bcx, e);\n         \n         bcx = arg.bcx;\n-\n         vec::push[ValueRef](arg_vals, arg.val);\n         vec::push[ty::t](arg_tys,\n                          ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n@@ -5895,8 +5897,7 @@ fn trans_spawn(&@block_ctxt cx,\n     // Allocate and fill the tuple.\n     auto llargs = alloc_ty(bcx, args_ty);\n \n-    // 3 to skip all the magic\n-    auto i = 3u;\n+    auto i = 0u;\n     for(ValueRef v in arg_vals) {\n         // log_err #fmt(\"ty(llargs) = %s\", \n         //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n@@ -5919,45 +5920,21 @@ fn trans_spawn(&@block_ctxt cx,\n                               [bcx.fcx.lltaskptr, lltname]);\n \n     // Okay, start the task.\n-    // First we find the function\n-    auto fnptr = trans_lval(bcx, func).res;\n-    bcx = fnptr.bcx;\n-    \n-    auto llfnptr = bcx.build.GEP(fnptr.val,\n-                                 [C_int(0), C_int(0)]);\n-    log_err \"Casting llfnptr\";\n-    auto llfnptrptr_i = bcx.build.PointerCast(llfnptr,\n-                                              T_ptr(T_int()));\n-    // We'd better dereference this one more time, since that one points into\n-    // the symbol table or something.\n-    auto llfnptr_i = bcx.build.Load(llfnptrptr_i);\n-\n-    log_err \"Cassting llargs\";\n+\n     auto llargs_i = bcx.build.PointerCast(llargs.val,\n-                                   T_int());\n+                                          T_int());\n \n-    auto args_size = size_of(bcx, args_ty).val;\n+    // Generate the wrapper function\n+    auto wrapper = mk_spawn_wrapper(bcx, tname, func, args_ty);\n+    bcx = wrapper.bcx;\n+    auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n+    // TODO: this next line might be necessary...\n+    //llfnptr_i = bcx.build.Load(llfnptr_i);\n \n+    // And start the task\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n                    [bcx.fcx.lltaskptr, new_task,\n-                    llfnptr_i, llargs_i, args_size]);\n-\n-    /*\n-    alt(dom) {\n-        case(ast::dom_implicit) {\n-            // TODO\n-            log_err \"Spawning implicit domain tasks is not implemented.\";\n-            //fail;\n-        }\n-\n-        case(ast::dom_thread) {\n-            // TODO\n-            log_err \"Spawining new thread tasks is not implemented.\";\n-            // TODO: for now use the normal unimpl thing.\n-            fail;\n-        }\n-    }\n-    */\n+                    llfnptr_i, llargs_i]);\n \n     auto task_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto dropref = clean(bind drop_ty(_, new_task, task_ty));\n@@ -5966,6 +5943,101 @@ fn trans_spawn(&@block_ctxt cx,\n     ret res(bcx, new_task);\n }\n \n+fn mk_spawn_wrapper(&@block_ctxt cx, \n+                    &str tname, \n+                    &@ast::expr func, \n+                    &ty::t args_ty) -> result {\n+    auto llmod = cx.fcx.lcx.ccx.llmod;\n+    let TypeRef args_ty_tref = type_of(cx.fcx.lcx.ccx, cx.sp, args_ty);\n+    //let TypeRef wrapper_fn_type = T_fn([args_ty_tref], T_void());\n+\n+    let TypeRef wrapper_fn_type =\n+        type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n+                   [rec(mode = ty::mo_alias, ty = args_ty)],\n+                   ty::idx_nil,\n+                   0u);\n+\n+    log_err #fmt(\"wrapper args type: %s\",\n+                 ty_str(cx.fcx.lcx.ccx.tn, args_ty_tref));\n+    log_err #fmt(\"wrapper fn desired type: %s\",\n+                 ty_str(cx.fcx.lcx.ccx.tn, wrapper_fn_type));\n+\n+    // TODO: construct a name based on tname\n+    auto llfndecl = decl_cdecl_fn(llmod, \"spawn_wrap\",\n+                                  wrapper_fn_type);\n+\n+    log_err #fmt(\"spawn wrapper decl type: %s\", \n+                 val_str(cx.fcx.lcx.ccx.tn, llfndecl));\n+\n+    auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n+\n+    auto fbcx = new_top_block_ctxt(fcx);\n+\n+    log_err #fmt(\"spawn wrapper type: %s\", val_str(fcx.lcx.ccx.tn, \n+                                                  fcx.llfn));\n+\n+    // 3u to skip the three implicit args\n+    let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n+\n+    log_err #fmt(\"arg type: %s\", val_str(fbcx.fcx.lcx.ccx.tn, arg));\n+\n+    let vec[ValueRef] child_args = \n+        [llvm::LLVMGetParam(fcx.llfn, 0u),\n+         llvm::LLVMGetParam(fcx.llfn, 1u),\n+         llvm::LLVMGetParam(fcx.llfn, 2u)];\n+\n+    // unpack the arguments\n+    alt(ty::struct(fcx.lcx.ccx.tcx, args_ty)) {\n+        case(ty::ty_tup(?elements)) {\n+            auto i = 0;\n+            for(ty::mt m in elements) {\n+                log_err #fmt(\"GEP arg %d\", i);\n+                auto src = fbcx.build.GEP(arg, [C_int(0), C_int(i)]);\n+                i += 1;\n+\n+                log_err #fmt(\"generating load of type %s\",\n+                             val_str(fbcx.fcx.lcx.ccx.tn,\n+                                     src));\n+\n+                auto child_arg = fbcx.build.Load(src);\n+\n+                child_args += [child_arg];\n+            }\n+        }\n+    }\n+    \n+    // Find the function\n+    auto fnptr = trans_lval(fbcx, func).res;\n+    fbcx = fnptr.bcx;\n+    \n+    log_err \"SPAWN 1\";\n+    auto llfnptr = fbcx.build.GEP(fnptr.val,\n+                                  [C_int(0), C_int(0)]);\n+    auto llfn = fbcx.build.Load(llfnptr);\n+    \n+    log_err #fmt(\"Generating call to child function: %s\",\n+                 val_str(fbcx.fcx.lcx.ccx.tn,\n+                         llfn));\n+\n+    auto i = 0;\n+    for(ValueRef v in child_args) {\n+        log_err #fmt(\"Arg %d: %s\",\n+                     i,\n+                     val_str(fbcx.fcx.lcx.ccx.tn,\n+                             v));\n+        i += 1;\n+    }\n+\n+    fbcx.build.Call(llfn,\n+                    child_args);\n+    fbcx.build.RetVoid();\n+\n+    finish_fn(fcx, fbcx.llbb);\n+\n+    // TODO: make sure we clean up everything we need to.\n+    ret res(cx, llfndecl);\n+}\n+\n fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n               &ast::ann ann) -> result {\n     auto bcx = cx;"}, {"sha": "b23da1b128468619a3f6d2d4473ee1d176827259", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -171,12 +171,7 @@ rust_task::start(uintptr_t spawnee_fn,\n     src += 1;                  // spawn-call task slot\n     src += 1;                  // spawn-call closure-or-obj slot\n \n-    spp -= (args_size / sizeof(uintptr_t)) - 1;\n-    memmove(spp, src, args_size);\n-    spp--;\n-\n-    //*spp-- = (uintptr_t) *src;       // vec\n-    \n+    *spp-- = (uintptr_t) *src;       // vec\n     *spp-- = (uintptr_t) 0x0;        // closure-or-obj\n     *spp-- = (uintptr_t) this;       // task\n     *spp-- = (uintptr_t) dummy_ret;  // output address"}, {"sha": "966ddb15eee598c7bfdc09e94c262fc8fec551b7", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -466,17 +466,21 @@ extern \"C\" CDECL rust_task *\n upcall_start_task(rust_task *spawner,\n                   rust_task *task,\n                   uintptr_t spawnee_fn,\n-                  uintptr_t args,\n-                  size_t callsz) {\n+                  uintptr_t args) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n     DLOG(dom, task,\n-             \"upcall start_task(task %s @0x%\" PRIxPTR\n-             \", spawnee 0x%\" PRIxPTR\n-             \", callsz %\" PRIdPTR \")\", task->name, task,\n-             spawnee_fn, callsz);\n-    task->start(spawnee_fn, args, callsz);\n+         \"upcall start_task(task %s @0x%\" PRIxPTR\n+         \", spawnee 0x%\" PRIxPTR \")\", \n+         task->name, task,\n+         spawnee_fn);\n+\n+    // we used to be generating this tuple in rustc, but it's easier to do it\n+    // here.\n+    uintptr_t start_args[] = {0, 0, 0, args};\n+    \n+    task->start(spawnee_fn, (uintptr_t)&start_args, sizeof(start_args));\n     return task;\n }\n "}, {"sha": "dcee95ada00da65d803ed42081459eb477ceb63b", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -9,3 +9,11 @@ fn child(int i) {\n    log_err i;\n }\n \n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "13da73db36e6a33d28f7eb018876810cdb359edd", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d49998f0ed9b0a239b40d30ccfde750f8439cac4/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=d49998f0ed9b0a239b40d30ccfde750f8439cac4", "patch": "@@ -2,10 +2,35 @@\n // -*- rust -*-\n \n fn main() {\n-  spawn child(10, 20);\n+  spawn child(10, 20, 30, 40, 50, 60, 70, 80, 90);\n }\n \n-fn child(int i, int j) {\n-  log_err i;\n-  log_err j;\n+fn child(int i1,\n+         int i2,\n+         int i3,\n+         int i4,\n+         int i5,\n+         int i6,\n+         int i7,\n+         int i8,\n+         int i9) \n+{\n+  log_err i1;\n+  log_err i2;\n+  log_err i3;\n+  log_err i4;\n+  log_err i5;\n+  log_err i6;\n+  log_err i7;\n+  log_err i8;\n+  log_err i9;\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}]}