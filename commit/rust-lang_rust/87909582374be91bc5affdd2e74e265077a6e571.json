{"sha": "87909582374be91bc5affdd2e74e265077a6e571", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OTA5NTgyMzc0YmU5MWJjNWFmZmRkMmU3NGUyNjUwNzdhNmU1NzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-25T22:33:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-27T20:02:18Z"}, "message": "std: Avoid missing fns on i686-pc-windows-msvc\n\nIt turns out that the 32-bit toolchain for MSVC has many of these functions as\n`static inline` functions in header files so there's not actually a symbol for\nRust to call. All of the implementations just cast floats to their 64-bit\nvariants and then cast back to 32-bit at the end, so the standard library now\ntakes this strategy.", "tree": {"sha": "3a2ce54e6683a4c38fb85008e1cf909a59252d9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a2ce54e6683a4c38fb85008e1cf909a59252d9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87909582374be91bc5affdd2e74e265077a6e571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87909582374be91bc5affdd2e74e265077a6e571", "html_url": "https://github.com/rust-lang/rust/commit/87909582374be91bc5affdd2e74e265077a6e571", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87909582374be91bc5affdd2e74e265077a6e571/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de665e8b31fc0459839c6377157b9559e4679cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de665e8b31fc0459839c6377157b9559e4679cc", "html_url": "https://github.com/rust-lang/rust/commit/5de665e8b31fc0459839c6377157b9559e4679cc"}], "stats": {"total": 199, "additions": 157, "deletions": 42}, "files": [{"sha": "c8f95a3672d4a3d3e66cb821cd927f85fd117e80", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=87909582374be91bc5affdd2e74e265077a6e571", "patch": "@@ -215,13 +215,37 @@ impl Float for f32 {\n     /// Rounds towards minus infinity.\n     #[inline]\n     fn floor(self) -> f32 {\n-        unsafe { intrinsics::floorf32(self) }\n+        return floorf(self);\n+\n+        // On MSVC LLVM will lower many math intrinsics to a call to the\n+        // corresponding function. On MSVC, however, many of these functions\n+        // aren't actually available as symbols to call, but rather they are all\n+        // `static inline` functions in header files. This means that from a C\n+        // perspective it's \"compatible\", but not so much from an ABI\n+        // perspective (which we're worried about).\n+        //\n+        // The inline header functions always just cast to a f64 and do their\n+        // operation, so we do that here as well, but only for MSVC targets.\n+        //\n+        // Note that there are many MSVC-specific float operations which\n+        // redirect to this comment, so `floorf` is just one case of a missing\n+        // function on MSVC, but there are many others elsewhere.\n+        #[cfg(target_env = \"msvc\")]\n+        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n     }\n \n     /// Rounds towards plus infinity.\n     #[inline]\n     fn ceil(self) -> f32 {\n-        unsafe { intrinsics::ceilf32(self) }\n+        return ceilf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n     }\n \n     /// Rounds to nearest integer. Rounds half-way cases away from zero.\n@@ -299,7 +323,13 @@ impl Float for f32 {\n \n     #[inline]\n     fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n+        return powf(self, n);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n     }\n \n     #[inline]\n@@ -317,7 +347,13 @@ impl Float for f32 {\n     /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f32 {\n-        unsafe { intrinsics::expf32(self) }\n+        return expf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n     }\n \n     /// Returns 2 raised to the power of the number.\n@@ -329,7 +365,13 @@ impl Float for f32 {\n     /// Returns the natural logarithm of the number.\n     #[inline]\n     fn ln(self) -> f32 {\n-        unsafe { intrinsics::logf32(self) }\n+        return logf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -345,7 +387,13 @@ impl Float for f32 {\n     /// Returns the base 10 logarithm of the number.\n     #[inline]\n     fn log10(self) -> f32 {\n-        unsafe { intrinsics::log10f32(self) }\n+        return log10f(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n     }\n \n     /// Converts to degrees, assuming the number is in radians."}, {"sha": "9a22fe3a493f12eba582c940e79833d5f2afd7c7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=87909582374be91bc5affdd2e74e265077a6e571", "patch": "@@ -419,26 +419,40 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Rem for $t {\n-            type Output = $t;\n+rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n-            #[inline]\n-            fn rem(self, other: $t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(self, other) }\n-            }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f32 {\n+    type Output = f32;\n+\n+    // see notes in `core::f32::Float::floor`\n+    #[inline]\n+    #[cfg(target_env = \"msvc\")]\n+    fn rem(self, other: f32) -> f32 {\n+        (self as f64).rem(other as f64) as f32\n+    }\n \n-        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    #[inline]\n+    #[cfg(not(target_env = \"msvc\"))]\n+    fn rem(self, other: f32) -> f32 {\n+        extern { fn fmodf(a: f32, b: f32) -> f32; }\n+        unsafe { fmodf(self, other) }\n     }\n }\n \n-rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n-rem_float_impl! { f32, fmodf }\n-rem_float_impl! { f64, fmod }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f64 {\n+    type Output = f64;\n+\n+    #[inline]\n+    fn rem(self, other: f64) -> f64 {\n+        extern { fn fmod(a: f64, b: f64) -> f64; }\n+        unsafe { fmod(self, other) }\n+    }\n+}\n+\n+forward_ref_binop! { impl Rem, rem for f64, f64 }\n+forward_ref_binop! { impl Rem, rem for f32, f32 }\n \n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///"}, {"sha": "c2fb2fa417598a0bf0ef620403310c582ebabfef", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 74, "deletions": 21, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=87909582374be91bc5affdd2e74e265077a6e571", "patch": "@@ -18,6 +18,7 @@\n use prelude::v1::*;\n \n use core::num;\n+#[cfg(not(target_env = \"msvc\"))]\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n@@ -33,12 +34,7 @@ mod cmath {\n     use libc::{c_float, c_int};\n \n     extern {\n-        pub fn acosf(n: c_float) -> c_float;\n-        pub fn asinf(n: c_float) -> c_float;\n-        pub fn atanf(n: c_float) -> c_float;\n-        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n         pub fn cbrtf(n: c_float) -> c_float;\n-        pub fn coshf(n: c_float) -> c_float;\n         pub fn erff(n: c_float) -> c_float;\n         pub fn erfcf(n: c_float) -> c_float;\n         pub fn expm1f(n: c_float) -> c_float;\n@@ -51,32 +47,77 @@ mod cmath {\n         pub fn log1pf(n: c_float) -> c_float;\n         pub fn ilogbf(n: c_float) -> c_int;\n         pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;\n-        pub fn sinhf(n: c_float) -> c_float;\n-        pub fn tanf(n: c_float) -> c_float;\n-        pub fn tanhf(n: c_float) -> c_float;\n         pub fn tgammaf(n: c_float) -> c_float;\n \n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgammaf_r\")]\n         pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"_hypotf\")]\n         pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+    }\n \n-        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n+    // See the comments in `core::float::Float::floor` for why MSVC is special\n+    // here.\n+    #[cfg(not(target_env = \"msvc\"))]\n+    extern {\n+        pub fn acosf(n: c_float) -> c_float;\n+        pub fn asinf(n: c_float) -> c_float;\n+        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n+        pub fn atanf(n: c_float) -> c_float;\n+        pub fn coshf(n: c_float) -> c_float;\n         pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n-        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n         pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n+        pub fn sinhf(n: c_float) -> c_float;\n+        pub fn tanf(n: c_float) -> c_float;\n+        pub fn tanhf(n: c_float) -> c_float;\n     }\n \n-    #[cfg(all(windows, target_env = \"msvc\"))]\n-    pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n-        f64::ldexp(x as f64, n as isize) as c_float\n-    }\n+    #[cfg(target_env = \"msvc\")]\n+    pub use self::shims::*;\n+    #[cfg(target_env = \"msvc\")]\n+    mod shims {\n+        use libc::{c_float, c_int};\n+\n+        pub unsafe fn acosf(n: c_float) -> c_float {\n+            f64::acos(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn asinf(n: c_float) -> c_float {\n+            f64::asin(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn atan2f(n: c_float, b: c_float) -> c_float {\n+            f64::atan2(n as f64, b as f64) as c_float\n+        }\n+\n+        pub unsafe fn atanf(n: c_float) -> c_float {\n+            f64::atan(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn coshf(n: c_float) -> c_float {\n+            f64::cosh(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n+            let (a, b) = f64::frexp(x as f64);\n+            *value = b as c_int;\n+            a as c_float\n+        }\n+\n+        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n+            f64::ldexp(x as f64, n as isize) as c_float\n+        }\n+\n+        pub unsafe fn sinhf(n: c_float) -> c_float {\n+            f64::sinh(n as f64) as c_float\n+        }\n \n-    #[cfg(all(windows, target_env = \"msvc\"))]\n-    pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n-        let (a, b) = f64::frexp(x as f64);\n-        *value = b as c_int;\n-        a as c_float\n+        pub unsafe fn tanf(n: c_float) -> c_float {\n+            f64::tan(n as f64) as c_float\n+        }\n+\n+        pub unsafe fn tanhf(n: c_float) -> c_float {\n+            f64::tanh(n as f64) as c_float\n+        }\n     }\n }\n \n@@ -761,7 +802,13 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin(self) -> f32 {\n-        unsafe { intrinsics::sinf32(self) }\n+        return sinf(self);\n+\n+        // see notes in `core::f32::Float::floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn sinf(f: f32) -> f32 { (f as f64).sin() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn sinf(f: f32) -> f32 { unsafe { intrinsics::sinf32(f) } }\n     }\n \n     /// Computes the cosine of a number (in radians).\n@@ -778,7 +825,13 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn cos(self) -> f32 {\n-        unsafe { intrinsics::cosf32(self) }\n+        return cosf(self);\n+\n+        // see notes in `core::f32::Float::floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn cosf(f: f32) -> f32 { (f as f64).cos() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn cosf(f: f32) -> f32 { unsafe { intrinsics::cosf32(f) } }\n     }\n \n     /// Computes the tangent of a number (in radians)."}]}