{"sha": "4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZDJjMGVhN2NmYzFjYzk1MmNjNjZlNzhlMWI3MTE3MzY3ZGUyYzQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-30T23:03:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:30Z"}, "message": "Refactor `expand_*` into `expander.fold_*`.", "tree": {"sha": "faabce8ff1f85bfd36c908cbc61ddfe4f8a9334c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faabce8ff1f85bfd36c908cbc61ddfe4f8a9334c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "html_url": "https://github.com/rust-lang/rust/commit/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "503a10b34a89995ebea6b7a28aa2465038c99627", "url": "https://api.github.com/repos/rust-lang/rust/commits/503a10b34a89995ebea6b7a28aa2465038c99627", "html_url": "https://github.com/rust-lang/rust/commit/503a10b34a89995ebea6b7a28aa2465038c99627"}], "stats": {"total": 408, "additions": 194, "deletions": 214}, "files": [{"sha": "d3f8618aace9521c73cf20d5f73f34f96897908d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 194, "deletions": 214, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4ed2c0ea7cfc1cc952cc66e78e1b7117367de2c4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, PatKind};\n-use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n+use ast::{MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n use attr::{self, HasAttrs};\n@@ -143,15 +143,6 @@ enum InvocationKind {\n     },\n }\n \n-pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    if let ast::ExprKind::Mac(mac) = expr.node {\n-        let invoc = fld.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n-        expand_invoc(invoc, fld).make_expr()\n-    } else {\n-        P(noop_fold_expr(expr, fld))\n-    }\n-}\n-\n fn expand_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n     match invoc.kind {\n         InvocationKind::Bang { .. } => expand_bang_invoc(invoc, fld),\n@@ -345,191 +336,6 @@ fn expand_bang_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n     fully_expanded\n }\n \n-// does this attribute list contain \"macro_use\" ?\n-fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n-    for attr in attrs {\n-        let mut is_use = attr.check_name(\"macro_use\");\n-        if attr.check_name(\"macro_escape\") {\n-            let mut err =\n-                fld.cx.struct_span_warn(attr.span,\n-                                        \"macro_escape is a deprecated synonym for macro_use\");\n-            is_use = true;\n-            if let ast::AttrStyle::Inner = attr.node.style {\n-                err.help(\"consider an outer attribute, \\\n-                          #[macro_use] mod ...\").emit();\n-            } else {\n-                err.emit();\n-            }\n-        };\n-\n-        if is_use {\n-            if !attr.is_word() {\n-              fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-            }\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-/// Expand a stmt\n-fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n-    let (mac, style, attrs) = match stmt.node {\n-        StmtKind::Mac(mac) => mac.unwrap(),\n-        _ => return noop_fold_stmt(stmt, fld)\n-    };\n-\n-    let invoc = fld.new_bang_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n-    let mut fully_expanded = expand_invoc(invoc, fld).make_stmts();\n-\n-    // If this is a macro invocation with a semicolon, then apply that\n-    // semicolon to the final statement produced by expansion.\n-    if style == MacStmtStyle::Semicolon {\n-        if let Some(stmt) = fully_expanded.pop() {\n-            fully_expanded.push(stmt.add_trailing_semicolon());\n-        }\n-    }\n-\n-    fully_expanded\n-}\n-\n-fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n-    match p.node {\n-        PatKind::Mac(_) => {}\n-        _ => return noop_fold_pat(p, fld)\n-    }\n-    p.and_then(|p| match p.node {\n-        PatKind::Mac(mac) => {\n-            let invoc = fld.new_bang_invoc(mac, Vec::new(), p.span, ExpansionKind::Pat);\n-            expand_invoc(invoc, fld).make_pat()\n-        }\n-        _ => unreachable!(),\n-    })\n-}\n-\n-fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> Expansion {\n-    match a {\n-        Annotatable::Item(it) => Expansion::Items(expand_item(it, fld)),\n-        Annotatable::TraitItem(it) => Expansion::TraitItems(expand_trait_item(it.unwrap(), fld)),\n-        Annotatable::ImplItem(ii) => Expansion::ImplItems(expand_impl_item(ii.unwrap(), fld)),\n-    }\n-}\n-\n-fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> Expansion {\n-    let mut attr = None;\n-    item = item.map_attrs(|mut attrs| {\n-        for i in 0..attrs.len() {\n-            if let Some(extension) = fld.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                match *extension {\n-                    MultiModifier(..) | MultiDecorator(..) => {\n-                        attr = Some(attrs.remove(i));\n-                        break;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        attrs\n-    });\n-\n-    if let Some(attr) = attr {\n-        let kind = match item {\n-            Annotatable::Item(_) => ExpansionKind::Items,\n-            Annotatable::ImplItem(_) => ExpansionKind::ImplItems,\n-            Annotatable::TraitItem(_) => ExpansionKind::TraitItems,\n-        };\n-        let invoc = fld.new_invoc(kind, InvocationKind::Attr { attr: attr, item: item });\n-        expand_invoc(invoc, fld)\n-    } else {\n-        expand_multi_modified(item, fld)\n-    }\n-}\n-\n-fn expand_item(item: P<ast::Item>, fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n-    match item.node {\n-        ast::ItemKind::Mac(..) => {\n-            if match item.node {\n-                ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n-                _ => unreachable!(),\n-            } {\n-                return SmallVector::one(item);\n-            }\n-            item.and_then(|item| match item.node {\n-                ItemKind::Mac(mac) => {\n-                    let invoc =\n-                        fld.new_invoc(ExpansionKind::Items, InvocationKind::Bang {\n-                            mac: mac, attrs: item.attrs, ident: Some(item.ident), span: item.span,\n-                        });\n-                    expand_invoc(invoc, fld).make_items()\n-                }\n-                _ => unreachable!(),\n-            })\n-        }\n-        ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-            fld.cx.mod_push(item.ident);\n-            let macro_use = contains_macro_use(fld, &item.attrs);\n-\n-            let directory = fld.cx.directory.clone();\n-            if item.span.contains(inner) {\n-                fld.cx.directory.push(&*{\n-                    ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n-                        .unwrap_or(item.ident.name.as_str())\n-                });\n-            } else {\n-                fld.cx.directory = match inner {\n-                    syntax_pos::DUMMY_SP => PathBuf::new(),\n-                    _ => PathBuf::from(fld.cx.parse_sess.codemap().span_to_filename(inner)),\n-                };\n-                fld.cx.directory.pop();\n-            }\n-\n-            let result = fld.with_exts_frame(macro_use, |fld| noop_fold_item(item, fld));\n-            fld.cx.directory = directory;\n-\n-            fld.cx.mod_pop();\n-            result\n-        },\n-        _ => noop_fold_item(item, fld),\n-    }\n-}\n-\n-fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n-                 -> SmallVector<ast::ImplItem> {\n-    match ii.node {\n-        ast::ImplItemKind::Macro(mac) => {\n-            let invoc = fld.new_bang_invoc(mac, ii.attrs, ii.span, ExpansionKind::ImplItems);\n-            expand_invoc(invoc, fld).make_impl_items()\n-        }\n-        _ => fold::noop_fold_impl_item(ii, fld)\n-    }\n-}\n-\n-fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n-                     -> SmallVector<ast::TraitItem> {\n-    match ti.node {\n-        ast::TraitItemKind::Macro(mac) => {\n-            let invoc = fld.new_bang_invoc(mac, ti.attrs, ti.span, ExpansionKind::TraitItems);\n-            expand_invoc(invoc, fld).make_trait_items()\n-        }\n-        _ => fold::noop_fold_trait_item(ti, fld)\n-    }\n-}\n-\n-pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n-    let t = match t.node {\n-        ast::TyKind::Mac(_) => t.unwrap(),\n-        _ => return fold::noop_fold_ty(t, fld),\n-    };\n-\n-    match t.node {\n-        ast::TyKind::Mac(mac) => {\n-            let invoc = fld.new_bang_invoc(mac, Vec::new(), t.span, ExpansionKind::Ty);\n-            expand_invoc(invoc, fld).make_ty()\n-        }\n-        _ => unreachable!(),\n-    }\n-}\n-\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n@@ -612,6 +418,56 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })\n     }\n \n+    fn new_attr_invoc(&self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n+                      -> Invocation {\n+        self.new_invoc(kind, InvocationKind::Attr { attr: attr, item: item })\n+    }\n+\n+    // If `item` is an attr invocation, remove and return the macro attribute.\n+    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+        let mut attr = None;\n+        item = item.map_attrs(|mut attrs| {\n+            for i in 0..attrs.len() {\n+                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n+                    match *extension {\n+                        MultiModifier(..) | MultiDecorator(..) => {\n+                            attr = Some(attrs.remove(i));\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            attrs\n+        });\n+        (item, attr)\n+    }\n+\n+    // does this attribute list contain \"macro_use\" ?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            let mut is_use = attr.check_name(\"macro_use\");\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.cx.struct_span_warn(attr.span, msg);\n+                is_use = true;\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            };\n+\n+            if is_use {\n+                if !attr.is_word() {\n+                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                }\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     fn with_exts_frame<T, F: FnOnce(&mut Self) -> T>(&mut self, macros_escape: bool, f: F) -> T {\n         self.cx.syntax_env.push_frame();\n         self.cx.syntax_env.info().macros_escape = macros_escape;\n@@ -630,30 +486,59 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        expr.and_then(|expr| expand_expr(expr, self))\n+        let expr = expr.unwrap();\n+        if let ast::ExprKind::Mac(mac) = expr.node {\n+            let invoc = self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n+            expand_invoc(invoc, self).make_expr()\n+        } else {\n+            P(noop_fold_expr(expr, self))\n+        }\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        expr.and_then(|expr| match expr.node {\n-            ast::ExprKind::Mac(mac) => {\n-                let invoc =\n-                    self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n-                expand_invoc(invoc, self).make_opt_expr()\n-            }\n-            _ => Some(expand_expr(expr, self)),\n-        })\n+        let expr = expr.unwrap();\n+        if let ast::ExprKind::Mac(mac) = expr.node {\n+            let invoc =\n+                self.new_bang_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n+            expand_invoc(invoc, self).make_opt_expr()\n+        } else {\n+            Some(P(noop_fold_expr(expr, self)))\n+        }\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        expand_pat(pat, self)\n-    }\n+        match pat.node {\n+            PatKind::Mac(_) => {}\n+            _ => return noop_fold_pat(pat, self)\n+        }\n \n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        expand_annotatable(Annotatable::Item(item), self).make_items()\n+        pat.and_then(|pat| match pat.node {\n+            PatKind::Mac(mac) => {\n+                let invoc = self.new_bang_invoc(mac, Vec::new(), pat.span, ExpansionKind::Pat);\n+                expand_invoc(invoc, self).make_pat()\n+            }\n+            _ => unreachable!(),\n+        })\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        expand_stmt(stmt, self)\n+        let (mac, style, attrs) = match stmt.node {\n+            StmtKind::Mac(mac) => mac.unwrap(),\n+            _ => return noop_fold_stmt(stmt, self)\n+        };\n+\n+        let invoc = self.new_bang_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n+        let mut fully_expanded = expand_invoc(invoc, self).make_stmts();\n+\n+        // If this is a macro invocation with a semicolon, then apply that\n+        // semicolon to the final statement produced by expansion.\n+        if style == MacStmtStyle::Semicolon {\n+            if let Some(stmt) = fully_expanded.pop() {\n+                fully_expanded.push(stmt.add_trailing_semicolon());\n+            }\n+        }\n+\n+        fully_expanded\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n@@ -663,16 +548,111 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        expand_annotatable(Annotatable::TraitItem(P(i)), self).make_trait_items()\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let invoc = self.new_attr_invoc(attr, Annotatable::Item(item), ExpansionKind::Items);\n+            return expand_invoc(invoc, self).make_items();\n+        }\n+\n+        match item.node {\n+            ast::ItemKind::Mac(..) => {\n+                if match item.node {\n+                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n+                    _ => unreachable!(),\n+                } {\n+                    return SmallVector::one(item);\n+                }\n+\n+                item.and_then(|item| match item.node {\n+                    ItemKind::Mac(mac) => {\n+                        let invoc = self.new_invoc(ExpansionKind::Items, InvocationKind::Bang {\n+                            mac: mac,\n+                            attrs: item.attrs,\n+                            ident: Some(item.ident),\n+                            span: item.span,\n+                        });\n+                        expand_invoc(invoc, self).make_items()\n+                    }\n+                    _ => unreachable!(),\n+                })\n+            }\n+            ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n+                self.cx.mod_push(item.ident);\n+                let macro_use = self.contains_macro_use(&item.attrs);\n+\n+                let directory = self.cx.directory.clone();\n+                if item.span.contains(inner) {\n+                    self.cx.directory.push(&*{\n+                        ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n+                            .unwrap_or(item.ident.name.as_str())\n+                    });\n+                } else {\n+                    self.cx.directory = match inner {\n+                        syntax_pos::DUMMY_SP => PathBuf::new(),\n+                        _ => PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner)),\n+                    };\n+                    self.cx.directory.pop();\n+                }\n+                let result = self.with_exts_frame(macro_use, |this| noop_fold_item(item, this));\n+                self.cx.directory = directory;\n+\n+                self.cx.mod_pop();\n+                result\n+            },\n+            _ => noop_fold_item(item, self),\n+        }\n     }\n \n-    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        expand_annotatable(Annotatable::ImplItem(P(i)), self).make_impl_items()\n+    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let item = Annotatable::TraitItem(P(item));\n+            let invoc = self.new_attr_invoc(attr, item, ExpansionKind::TraitItems);\n+            return expand_invoc(invoc, self).make_trait_items();\n+        }\n+\n+        match item.node {\n+            ast::TraitItemKind::Macro(mac) => {\n+                let ast::TraitItem { attrs, span, .. } = item;\n+                let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::TraitItems);\n+                expand_invoc(invoc, self).make_trait_items()\n+            }\n+            _ => fold::noop_fold_trait_item(item, self),\n+        }\n+    }\n+\n+    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        let (item, attr) = self.classify_item(item);\n+        if let Some(attr) = attr {\n+            let item = Annotatable::ImplItem(P(item));\n+            let invoc = self.new_attr_invoc(attr, item, ExpansionKind::ImplItems);\n+            return expand_invoc(invoc, self).make_impl_items();\n+        }\n+\n+        match item.node {\n+            ast::ImplItemKind::Macro(mac) => {\n+                let ast::ImplItem { attrs, span, .. } = item;\n+                let invoc = self.new_bang_invoc(mac, attrs, span, ExpansionKind::ImplItems);\n+                expand_invoc(invoc, self).make_impl_items()\n+            }\n+            _ => fold::noop_fold_impl_item(item, self)\n+        }\n     }\n \n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        expand_type(ty, self)\n+        let ty = match ty.node {\n+            ast::TyKind::Mac(_) => ty.unwrap(),\n+            _ => return fold::noop_fold_ty(ty, self),\n+        };\n+\n+        match ty.node {\n+            ast::TyKind::Mac(mac) => {\n+                let invoc = self.new_bang_invoc(mac, Vec::new(), ty.span, ExpansionKind::Ty);\n+                expand_invoc(invoc, self).make_ty()\n+            }\n+            _ => unreachable!(),\n+        }\n     }\n }\n "}]}