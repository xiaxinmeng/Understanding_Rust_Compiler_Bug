{"sha": "3902190ac4d64962b2c1ac9a6ae88777b7112f82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MDIxOTBhYzRkNjQ5NjJiMmMxYWM5YTZhZTg4Nzc3YjcxMTJmODI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-10T09:04:39Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-26T13:08:54Z"}, "message": "Switch drop-flag to `u8` to allow special tags to instrument state.\n\nRefactored code so that the drop-flag values for initialized\n(`DTOR_NEEDED`) versus dropped (`DTOR_DONE`) are given explicit names.\n\nAdd `mem::dropped()` (which with `DTOR_DONE == 0` is semantically the\nsame as `mem::zeroed`, but the point is that it abstracts away from\nthe particular choice of value for `DTOR_DONE`).\n\nFilling-drop needs to use something other than `ptr::read_and_zero`,\nso I added such a function: `ptr::read_and_drop`.  But, libraries\nshould not use it if they can otherwise avoid it.\n\nFixes to tests to accommodate filling-drop.", "tree": {"sha": "61759f62fbca6a1e9c25e3e95dd1d957340510df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61759f62fbca6a1e9c25e3e95dd1d957340510df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3902190ac4d64962b2c1ac9a6ae88777b7112f82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3902190ac4d64962b2c1ac9a6ae88777b7112f82", "html_url": "https://github.com/rust-lang/rust/commit/3902190ac4d64962b2c1ac9a6ae88777b7112f82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3902190ac4d64962b2c1ac9a6ae88777b7112f82/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f", "html_url": "https://github.com/rust-lang/rust/commit/1501f33e76f6f9621aa08fb0cbbc5f85a5ac7f0f"}], "stats": {"total": 316, "additions": 258, "deletions": 58}, "files": [{"sha": "e107d19a87c04dcf1c3c666619511ca7cbcbfadf", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -354,7 +354,8 @@ impl<T> Drop for Arc<T> {\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n         let ptr = *self._ptr;\n-        if ptr.is_null() { return }\n+        // if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -485,7 +486,7 @@ impl<T> Drop for Weak<T> {\n         let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n-        if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "e0d7e32ecf504b0cff31bde6ac1f6790e12e181a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -160,7 +160,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::marker;\n-use core::mem::{min_align_of, size_of, forget};\n+use core::mem::{self, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n@@ -407,7 +407,7 @@ impl<T> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n@@ -718,7 +718,7 @@ impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared."}, {"sha": "bf57d745a0dcea07b244f2393d1c9bb8b5f77987", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -280,9 +280,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.is_null() {\n+        if self.keys.is_null() ||\n+            (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n+        {\n             // Since we have #[unsafe_no_drop_flag], we have to watch\n-            // out for a null value being stored in self.keys. (Using\n+            // out for the sentinel value being stored in self.keys. (Using\n             // null is technically a violation of the `Unique`\n             // requirements, though.)\n             return;"}, {"sha": "cf0163f3ef4a6b674d3d2423cc3ba457e01e9fdc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -1694,7 +1694,7 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        if self.cap != 0 {\n+        if self.cap != 0 && self.cap != mem::POST_DROP_USIZE {\n             unsafe {\n                 for x in &*self {\n                     ptr::read(x);\n@@ -1977,7 +1977,7 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        // self.ptr == self.end == null if drop has already been called,\n+        // self.ptr == self.end == mem::POST_DROP_USIZE if drop has already been called,\n         // so we can use #[unsafe_no_drop_flag].\n \n         // destroy the remaining elements"}, {"sha": "eb74a41db55e354f43641559f796d514ad0db26d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -191,13 +191,35 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n+    /// Create a value initialized to so that its drop flag,\n+    /// if any, says that it has been dropped.\n+    ///\n+    /// `init_dropped` is unsafe because it returns a datum with all\n+    /// of its bytes set to the drop flag, which generally does not\n+    /// correspond to a valid value.\n+    ///\n+    /// This intrinsic is likely to be deprecated in the future when\n+    /// Rust moves to non-zeroing dynamic drop (and thus removes the\n+    /// embedded drop flags that are being established by this\n+    /// intrinsic).\n+    #[cfg(not(stage0))]\n+    pub fn init_dropped<T>() -> T;\n+\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is Copy.\n+    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// `Copy`, an all-zero value may not correspond to any legitimate\n+    /// state for the type in question.\n     pub fn init<T>() -> T;\n \n     /// Create an uninitialized value.\n+    ///\n+    /// `uninit` is unsafe because there is no guarantee of what its\n+    /// contents are. In particular its drop-flag may be set to any\n+    /// state, which means it may claim either dropped or\n+    /// undropped. In the general case one must use `ptr::write` to\n+    /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n     /// Move a value out of scope without running drop glue."}, {"sha": "e5b6c3f3472ea18eb53195e5fc387659af1d3190", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -158,6 +158,29 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n+/// Create a value initialized to an unspecified series of bytes.\n+///\n+/// The byte sequence usually indicates that the value at the memory\n+/// in question has been dropped. Thus, *if* T carries a drop flag,\n+/// any associated destructor will not be run when the value falls out\n+/// of scope.\n+///\n+/// Some code at one time used the `zeroed` function above to\n+/// accomplish this goal.\n+///\n+/// This function is expected to be deprecated with the transition\n+/// to non-zeroing drop.\n+#[inline]\n+#[unstable(feature = \"filling_drop\")]\n+pub unsafe fn dropped<T>() -> T {\n+    let mut x: T = uninitialized();\n+    let p: *mut u8 = transmute(&mut x as *mut T);\n+    for i in 0..size_of::<T>() {\n+        *p.offset(i as isize) = POST_DROP_U8;\n+    }\n+    x\n+}\n+\n /// Create an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a destructor and the value\n@@ -291,6 +314,40 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+// NOTE: Keep synchronized with values used in librustc_trans::trans::adt.\n+//\n+// In particular, the POST_DROP_U8 marker must never equal the\n+// DTOR_NEEDED_U8 marker.\n+//\n+// For a while pnkfelix was using 0xc1 here.\n+// But having the sign bit set is a pain, so 0x1d is probably better.\n+//\n+// And of course, 0x00 brings back the old world of zero'ing on drop.\n+#[cfg(not(stage0))] pub const POST_DROP_U8: u8 = 0x0;\n+#[cfg(not(stage0))] pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n+#[cfg(not(stage0))] pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n+\n+#[cfg(target_pointer_width = \"32\")]\n+#[cfg(not(stage0))] pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n+#[cfg(target_pointer_width = \"64\")]\n+#[cfg(not(stage0))] pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n+\n+#[cfg(stage0)] pub const POST_DROP_U8: u8 = 0;\n+#[cfg(stage0)] pub const POST_DROP_U32: u32 = 0;\n+#[cfg(stage0)] pub const POST_DROP_U64: u64 = 0;\n+#[cfg(stage0)] pub const POST_DROP_USIZE: usize = 0;\n+\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by"}, {"sha": "7a9c9274f3b117f024df65db840de3ef2c091817", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -230,6 +230,21 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n+/// Variant of read_and_zero that writes the specific drop-flag byte\n+/// (which may be more apropriate than zero).\n+#[inline(always)]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n+pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n+    // Copy the data out from `dest`:\n+    let tmp = read(&*dest);\n+\n+    // Now mark `dest` as dropped:\n+    write_bytes(dest, mem::POST_DROP_U8, 1);\n+\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///"}, {"sha": "d583eef0e0f7b0ba9f529e910601b33a181d15bd", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -1528,7 +1528,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, &path1.node, scope, (),\n-                |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+                |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n     }"}, {"sha": "9f90b5cea5f6664d47044be4931031ee9673534a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -81,14 +81,18 @@ pub enum Repr<'tcx> {\n     /// Structs with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; this is included\n     /// in the `Struct` if present.\n-    Univariant(Struct<'tcx>, bool),\n+    /// (The flag if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    Univariant(Struct<'tcx>, u8),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     ///\n     /// Types with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; the last argument\n     /// indicates whether such a flag is present.\n-    General(IntType, Vec<Struct<'tcx>>, bool),\n+    /// (The flag, if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    General(IntType, Vec<Struct<'tcx>>, u8),\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n     /// `nndiscr` must have single field which is known to be nonnull due to its type.\n     /// The other case is known to be zero sized. Hence we represent the enum\n@@ -151,11 +155,59 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     repr\n }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+pub const DTOR_NEEDED: u8 = 0x1;\n+pub const DTOR_NEEDED_U32: u32 = repeat_u8_as_u32!(DTOR_NEEDED);\n+pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64!(DTOR_NEEDED);\n+#[allow(dead_code)]\n+pub fn dtor_needed_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_NEEDED_U32 as usize,\n+        \"64\" => DTOR_NEEDED_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+pub const DTOR_DONE: u8 = 0x0;\n+pub const DTOR_DONE_U32: u32 = repeat_u8_as_u32!(DTOR_DONE);\n+pub const DTOR_DONE_U64: u64 = repeat_u8_as_u64!(DTOR_DONE);\n+#[allow(dead_code)]\n+pub fn dtor_done_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_DONE_U32 as usize,\n+        \"64\" => DTOR_DONE_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+fn dtor_to_init_u8(dtor: bool) -> u8 {\n+    if dtor { DTOR_NEEDED } else { 0 }\n+}\n+\n+pub trait GetDtorType<'tcx> { fn dtor_type(&self) -> Ty<'tcx>; }\n+impl<'tcx> GetDtorType<'tcx> for ty::ctxt<'tcx> {\n+    fn dtor_type(&self) -> Ty<'tcx> { self.types.u8 }\n+}\n+\n+fn dtor_active(flag: u8) -> bool {\n+    flag != 0\n+}\n+\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t), false)\n+            Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,15 +217,15 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(cx.tcx().types.bool); }\n+            if dtor { ftys.push(cx.tcx().dtor_type()); }\n \n-            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n         ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[..], false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -186,9 +238,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n+                let ftys = if dtor { vec!(cx.tcx().dtor_type()) } else { vec!() };\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n@@ -218,9 +270,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n@@ -266,7 +318,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n@@ -319,13 +371,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n             ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n-            General(ity, fields, dtor)\n+            General(ity, fields, dtor_to_init_u8(dtor))\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n                            ty_to_string(cx.tcx(), t)))\n@@ -830,18 +882,18 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                   val)\n         }\n         General(ity, ref cases, dtor) => {\n-            if dtor {\n+            if dtor_active(dtor) {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n                                           cases[discr as uint].fields.len() - 2);\n-                Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n                   GEPi(bcx, val, &[0, 0]))\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            if dtor {\n-                Store(bcx, C_u8(bcx.ccx(), 1),\n+            if dtor_active(dtor) {\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize),\n                     GEPi(bcx, val, &[0, st.fields.len() - 1]));\n             }\n         }\n@@ -875,10 +927,10 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n         CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            st.fields.len() - (if dtor { 1 } else { 0 })\n+            st.fields.len() - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as uint].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -992,17 +1044,17 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.types.bool);\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.dtor_type());\n     match *r {\n-        Univariant(ref st, true) => {\n+        Univariant(ref st, dtor) if dtor_active(dtor) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n             datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n         }\n-        General(_, _, true) => {\n+        General(_, _, dtor) if dtor_active(dtor) => {\n             let fcx = bcx.fcx;\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, tcx.types.bool, \"drop_flag\",\n+                bcx, tcx.dtor_type(), \"drop_flag\",\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {"}, {"sha": "aee163973fdedbc396fff255a9191e309e9919d2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -1146,20 +1146,27 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+pub fn drop_done_fill_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() { return; }\n-    let _icx = push_ctxt(\"zero_mem\");\n+    let _icx = push_ctxt(\"drop_done_fill_mem\");\n     let bcx = cx;\n-    memzero(&B(bcx), llptr, t);\n+    memfill(&B(bcx), llptr, t, adt::DTOR_DONE);\n }\n \n-// Always use this function instead of storing a zero constant to the memory\n-// in question. If you store a zero constant, LLVM will drown in vreg\n+pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+    if cx.unreachable.get() { return; }\n+    let _icx = push_ctxt(\"init_zero_mem\");\n+    let bcx = cx;\n+    memfill(&B(bcx), llptr, t, 0);\n+}\n+\n+// Always use this function instead of storing a constant byte to the memory\n+// in question. e.g. if you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n-    let _icx = push_ctxt(\"memzero\");\n+fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n+    let _icx = push_ctxt(\"memfill\");\n     let ccx = b.ccx;\n \n     let llty = type_of::type_of(ccx, ty);\n@@ -1172,7 +1179,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n-    let llzeroval = C_u8(ccx, 0);\n+    let llzeroval = C_u8(ccx, byte as usize);\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);"}, {"sha": "c7897f9b62ea5b16a62b48669fe570d036825e84", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -1015,7 +1015,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n             glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n         };\n         if self.zero {\n-            base::zero_mem(bcx, self.val, self.ty);\n+            base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n     }"}, {"sha": "399b7eb102e83cc478a67588e90e43375b51ce7d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -307,8 +307,8 @@ impl KindOps for Lvalue {\n                               -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n         if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values by zeroing out\n-            let () = zero_mem(bcx, val, ty);\n+            // cancel cleanup of affine values by drop-filling the memory\n+            let () = drop_done_fill_mem(bcx, val, ty);\n             bcx\n         } else {\n             bcx"}, {"sha": "7eb4c6f8ca5615d2a152f52f513ecaea77fdb349", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -21,6 +21,7 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use trans::adt;\n+use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -39,6 +40,7 @@ use util::ppaux;\n \n use arena::TypedArena;\n use libc::c_uint;\n+use session::config::NoDebugInfo;\n use syntax::ast;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n@@ -231,9 +233,31 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n-    with_cond(bcx, load_ty(bcx, drop_flag.val, bcx.tcx().types.bool), |cx| {\n+    let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n+    let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+    let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n+\n+    let bcx = if bcx.tcx().sess.opts.debuginfo == NoDebugInfo {\n+        bcx\n+    } else {\n+        let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+        let done_val = C_integral(drop_flag_llty, adt::DTOR_DONE as u64, false);\n+        let not_init = ICmp(bcx, llvm::IntNE, loaded, init_val, DebugLoc::None);\n+        let not_done = ICmp(bcx, llvm::IntNE, loaded, done_val, DebugLoc::None);\n+        let drop_flag_neither_initialized_nor_cleared =\n+            And(bcx, not_init, not_done, DebugLoc::None);\n+        with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n+            let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n+            Call(cx, llfn, &[], None, DebugLoc::None);\n+            cx\n+        })\n+    };\n+\n+    let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n+    with_cond(bcx, drop_flag_dtor_needed, |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n+\n }\n \n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -395,13 +419,24 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n+\n+    // Only drop the value when it ... well, we used to check for\n+    // non-null, (and maybe we need to continue doing so), but we now\n+    // must definitely check for special bit-patterns corresponding to\n+    // the special dtor markings.\n+\n+    let inttype = Type::int(bcx.ccx());\n+    let dropped_pattern = C_integral(inttype, adt::dtor_done_usize(bcx.fcx.ccx) as u64, false);\n+\n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, Type::int(bcx.ccx()));\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                     let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                     let info = Load(bcx, info);\n@@ -420,8 +455,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             } else {\n                 let llval = v0;\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, inttype);\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                     trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n                 })"}, {"sha": "ee0274b182794b19c550ad7973d8f32ab832c2f7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -359,11 +359,18 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 &ccx.link_meta().crate_hash);\n             C_u64(ccx, hash)\n         }\n+        (_, \"init_dropped\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !return_type_is_void(ccx, tp_ty) {\n+                drop_done_fill_mem(bcx, llresult, tp_ty);\n+            }\n+            C_nil(ccx)\n+        }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !return_type_is_void(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n-                zero_mem(bcx, llresult, tp_ty);\n+                init_zero_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }"}, {"sha": "d24ec16cc2182751ae2898930251cda21abbf599", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -5384,7 +5384,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n-            \"init\" => (1, Vec::new(), param(ccx, 0)),\n+            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),"}, {"sha": "710f0fe19db8e6d36782a44700db27857982277a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -985,7 +985,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n             return;\n         }\n "}, {"sha": "d4451cc7b71243ea87a0b847d2e6941412a7d1f1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -40,7 +40,7 @@ impl<T> MoveMap<T> for Vec<T> {\n         for p in &mut self {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n-                ptr::write(p, f(ptr::read_and_zero(p)));\n+                ptr::write(p, f(ptr::read_and_drop(p)));\n             }\n         }\n         self"}, {"sha": "7e0bcd3e1dc3f8a2229823209c8d47a9cb722bdc", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -71,8 +71,8 @@ impl<T: 'static> P<T> {\n     {\n         unsafe {\n             let p = &mut *self.ptr;\n-            // FIXME(#5016) this shouldn't need to zero to be safe.\n-            ptr::write(p, f(ptr::read_and_zero(p)));\n+            // FIXME(#5016) this shouldn't need to drop-fill to be safe.\n+            ptr::write(p, f(ptr::read_and_drop(p)));\n         }\n         self\n     }"}, {"sha": "cd517bcad3000ee6f1ab7df27eb9502e556e8fd2", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3902190ac4d64962b2c1ac9a6ae88777b7112f82/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=3902190ac4d64962b2c1ac9a6ae88777b7112f82", "patch": "@@ -14,7 +14,7 @@\n #![feature(box_syntax)]\n #![feature(intrinsics)]\n \n-use std::mem::transmute;\n+use std::mem::{self, transmute};\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -30,6 +30,6 @@ pub fn main() {\n         let mut z: *const uint = transmute(&x);\n         rusti::move_val_init(&mut y, x);\n         assert_eq!(*y, 1);\n-        assert_eq!(*z, 0); // `x` is nulled out, not directly visible\n+        assert_eq!(*z, mem::POST_DROP_USIZE); // `x` is nulled out, not directly visible\n     }\n }"}]}