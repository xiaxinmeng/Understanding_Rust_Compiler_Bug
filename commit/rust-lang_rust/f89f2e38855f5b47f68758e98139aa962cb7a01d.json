{"sha": "f89f2e38855f5b47f68758e98139aa962cb7a01d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OWYyZTM4ODU1ZjViNDdmNjg3NThlOTgxMzlhYTk2MmNiN2EwMWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T08:07:09Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "More readable ast_src for keywords", "tree": {"sha": "7065879c9b77c2843959abdf82356d75f36c500f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7065879c9b77c2843959abdf82356d75f36c500f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89f2e38855f5b47f68758e98139aa962cb7a01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89f2e38855f5b47f68758e98139aa962cb7a01d", "html_url": "https://github.com/rust-lang/rust/commit/f89f2e38855f5b47f68758e98139aa962cb7a01d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89f2e38855f5b47f68758e98139aa962cb7a01d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff5643c52445c516b8b32bc6062c66203ca13ee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff5643c52445c516b8b32bc6062c66203ca13ee4", "html_url": "https://github.com/rust-lang/rust/commit/ff5643c52445c516b8b32bc6062c66203ca13ee4"}], "stats": {"total": 383, "additions": 210, "deletions": 173}, "files": [{"sha": "3b014e312df235be15ca3b68f27ac71e93261e17", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 77, "deletions": 69, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f89f2e38855f5b47f68758e98139aa962cb7a01d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89f2e38855f5b47f68758e98139aa962cb7a01d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=f89f2e38855f5b47f68758e98139aa962cb7a01d", "patch": "@@ -4,7 +4,7 @@ use super::tokens::*;\n use crate::{\n     ast::{self, support, AstChildren, AstNode},\n     SyntaxKind::{self, *},\n-    SyntaxNode, SyntaxToken,\n+    SyntaxNode, SyntaxToken, T,\n };\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n@@ -48,11 +48,13 @@ impl ast::DocCommentsOwner for FnDef {}\n impl ast::AttrsOwner for FnDef {}\n impl FnDef {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CONST_KW) }\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, DEFAULT_KW) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, ASYNC_KW) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNSAFE_KW) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, FN_KW) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![default])\n+    }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![async]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![fn]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n@@ -98,7 +100,7 @@ impl ast::TypeParamsOwner for StructDef {}\n impl ast::AttrsOwner for StructDef {}\n impl ast::DocCommentsOwner for StructDef {}\n impl StructDef {\n-    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, STRUCT_KW) }\n+    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![struct]) }\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n     pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n@@ -123,7 +125,7 @@ impl ast::TypeParamsOwner for UnionDef {}\n impl ast::AttrsOwner for UnionDef {}\n impl ast::DocCommentsOwner for UnionDef {}\n impl UnionDef {\n-    pub fn union_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNION_KW) }\n+    pub fn union_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![union]) }\n     pub fn record_field_def_list(&self) -> Option<RecordFieldDefList> {\n         support::child(&self.syntax)\n     }\n@@ -230,7 +232,7 @@ impl ast::TypeParamsOwner for EnumDef {}\n impl ast::AttrsOwner for EnumDef {}\n impl ast::DocCommentsOwner for EnumDef {}\n impl EnumDef {\n-    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, ENUM_KW) }\n+    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -299,9 +301,9 @@ impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n impl ast::TypeBoundsOwner for TraitDef {}\n impl TraitDef {\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNSAFE_KW) }\n-    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, AUTO_KW) }\n-    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, TRAIT_KW) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n+    pub fn auto_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![auto]) }\n+    pub fn trait_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![trait]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -324,7 +326,7 @@ impl ast::NameOwner for Module {}\n impl ast::AttrsOwner for Module {}\n impl ast::DocCommentsOwner for Module {}\n impl Module {\n-    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MOD_KW) }\n+    pub fn mod_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mod]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n     pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n }\n@@ -371,8 +373,10 @@ impl ast::AttrsOwner for ConstDef {}\n impl ast::DocCommentsOwner for ConstDef {}\n impl ast::TypeAscriptionOwner for ConstDef {}\n impl ConstDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, DEFAULT_KW) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CONST_KW) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![default])\n+    }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n@@ -399,8 +403,8 @@ impl ast::AttrsOwner for StaticDef {}\n impl ast::DocCommentsOwner for StaticDef {}\n impl ast::TypeAscriptionOwner for StaticDef {}\n impl StaticDef {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, STATIC_KW) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![static]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n@@ -427,8 +431,10 @@ impl ast::AttrsOwner for TypeAliasDef {}\n impl ast::DocCommentsOwner for TypeAliasDef {}\n impl ast::TypeBoundsOwner for TypeAliasDef {}\n impl TypeAliasDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, DEFAULT_KW) }\n-    pub fn type_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, TYPE_KW) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![default])\n+    }\n+    pub fn type_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![type]) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn semi_token(&self) -> Option<Semi> { support::token(&self.syntax) }\n@@ -451,12 +457,14 @@ impl AstNode for ImplDef {\n impl ast::TypeParamsOwner for ImplDef {}\n impl ast::AttrsOwner for ImplDef {}\n impl ImplDef {\n-    pub fn default_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, DEFAULT_KW) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CONST_KW) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNSAFE_KW) }\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, IMPL_KW) }\n+    pub fn default_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![default])\n+    }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![impl]) }\n     pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, FOR_KW) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -552,8 +560,8 @@ impl AstNode for PointerType {\n }\n impl PointerType {\n     pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CONST_KW) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -616,7 +624,7 @@ impl AstNode for ReferenceType {\n impl ReferenceType {\n     pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n     pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -654,8 +662,8 @@ impl AstNode for FnPointerType {\n }\n impl FnPointerType {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNSAFE_KW) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, FN_KW) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![fn]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n@@ -675,7 +683,7 @@ impl AstNode for ForType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ForType {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, FOR_KW) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -696,7 +704,7 @@ impl AstNode for ImplTraitType {\n }\n impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, IMPL_KW) }\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![impl]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n@@ -715,7 +723,7 @@ impl AstNode for DynTraitType {\n }\n impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n-    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, DYN_KW) }\n+    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![dyn]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n@@ -816,9 +824,9 @@ impl AstNode for LambdaExpr {\n }\n impl ast::AttrsOwner for LambdaExpr {}\n impl LambdaExpr {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, STATIC_KW) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, ASYNC_KW) }\n-    pub fn move_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MOVE_KW) }\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![static]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![async]) }\n+    pub fn move_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![move]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -840,7 +848,7 @@ impl AstNode for IfExpr {\n }\n impl ast::AttrsOwner for IfExpr {}\n impl IfExpr {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, IF_KW) }\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![if]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -861,7 +869,7 @@ impl AstNode for LoopExpr {\n impl ast::AttrsOwner for LoopExpr {}\n impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n-    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, LOOP_KW) }\n+    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![loop]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryBlockExpr {\n@@ -880,7 +888,7 @@ impl AstNode for TryBlockExpr {\n }\n impl ast::AttrsOwner for TryBlockExpr {}\n impl TryBlockExpr {\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, TRY_KW) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![try]) }\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -901,9 +909,9 @@ impl AstNode for ForExpr {\n impl ast::AttrsOwner for ForExpr {}\n impl ast::LoopBodyOwner for ForExpr {}\n impl ForExpr {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, FOR_KW) }\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, IN_KW) }\n+    pub fn in_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -924,7 +932,7 @@ impl AstNode for WhileExpr {\n impl ast::AttrsOwner for WhileExpr {}\n impl ast::LoopBodyOwner for WhileExpr {}\n impl WhileExpr {\n-    pub fn while_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, WHILE_KW) }\n+    pub fn while_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -945,7 +953,7 @@ impl AstNode for ContinueExpr {\n impl ast::AttrsOwner for ContinueExpr {}\n impl ContinueExpr {\n     pub fn continue_token(&self) -> Option<SyntaxToken> {\n-        support::token2(&self.syntax, CONTINUE_KW)\n+        support::token2(&self.syntax, T![continue])\n     }\n     pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n }\n@@ -966,7 +974,7 @@ impl AstNode for BreakExpr {\n }\n impl ast::AttrsOwner for BreakExpr {}\n impl BreakExpr {\n-    pub fn break_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, BREAK_KW) }\n+    pub fn break_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![break]) }\n     pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n@@ -1006,7 +1014,7 @@ impl AstNode for BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n     pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, UNSAFE_KW) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1130,7 +1138,7 @@ impl ast::AttrsOwner for AwaitExpr {}\n impl AwaitExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n-    pub fn await_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, AWAIT_KW) }\n+    pub fn await_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![await]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n@@ -1149,7 +1157,7 @@ impl AstNode for TryExpr {\n }\n impl ast::AttrsOwner for TryExpr {}\n impl TryExpr {\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, TRY_KW) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![try]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1170,7 +1178,7 @@ impl AstNode for CastExpr {\n impl ast::AttrsOwner for CastExpr {}\n impl CastExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, AS_KW) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![as]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1191,8 +1199,8 @@ impl AstNode for RefExpr {\n impl ast::AttrsOwner for RefExpr {}\n impl RefExpr {\n     pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, RAW_KW) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![raw]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1232,7 +1240,7 @@ impl AstNode for BoxExpr {\n }\n impl ast::AttrsOwner for BoxExpr {}\n impl BoxExpr {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, BOX_KW) }\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1308,7 +1316,7 @@ impl AstNode for MatchExpr {\n }\n impl ast::AttrsOwner for MatchExpr {}\n impl MatchExpr {\n-    pub fn match_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MATCH_KW) }\n+    pub fn match_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![match]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n@@ -1371,7 +1379,7 @@ impl AstNode for MatchGuard {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl MatchGuard {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, IF_KW) }\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1491,7 +1499,7 @@ impl AstNode for RefPat {\n }\n impl RefPat {\n     pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1510,7 +1518,7 @@ impl AstNode for BoxPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl BoxPat {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, BOX_KW) }\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1531,8 +1539,8 @@ impl AstNode for BindPat {\n impl ast::AttrsOwner for BindPat {}\n impl ast::NameOwner for BindPat {}\n impl BindPat {\n-    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, REF_KW) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, MUT_KW) }\n+    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![ref]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn at_token(&self) -> Option<At> { support::token(&self.syntax) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n@@ -1788,10 +1796,10 @@ impl AstNode for Visibility {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Visibility {\n-    pub fn pub_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, PUB_KW) }\n-    pub fn super_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, SUPER_KW) }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, SELF_KW) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CRATE_KW) }\n+    pub fn pub_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![pub]) }\n+    pub fn super_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![super]) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![self]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![crate]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n@@ -1996,7 +2004,7 @@ impl AstNode for TypeBound {\n }\n impl TypeBound {\n     pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CONST_KW) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2053,7 +2061,7 @@ impl AstNode for WhereClause {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl WhereClause {\n-    pub fn where_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, WHERE_KW) }\n+    pub fn where_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2112,7 +2120,7 @@ impl AstNode for LetStmt {\n impl ast::AttrsOwner for LetStmt {}\n impl ast::TypeAscriptionOwner for LetStmt {}\n impl LetStmt {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, LET_KW) }\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![let]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -2134,7 +2142,7 @@ impl AstNode for Condition {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Condition {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, LET_KW) }\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![let]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -2203,7 +2211,7 @@ impl ast::AttrsOwner for SelfParam {}\n impl SelfParam {\n     pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n     pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, SELF_KW) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![self]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n@@ -2244,7 +2252,7 @@ impl AstNode for UseItem {\n impl ast::AttrsOwner for UseItem {}\n impl ast::VisibilityOwner for UseItem {}\n impl UseItem {\n-    pub fn use_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, USE_KW) }\n+    pub fn use_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![use]) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2285,7 +2293,7 @@ impl AstNode for Alias {\n }\n impl ast::NameOwner for Alias {}\n impl Alias {\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, AS_KW) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![as]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n@@ -2325,8 +2333,8 @@ impl AstNode for ExternCrateItem {\n impl ast::AttrsOwner for ExternCrateItem {}\n impl ast::VisibilityOwner for ExternCrateItem {}\n impl ExternCrateItem {\n-    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, EXTERN_KW) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, CRATE_KW) }\n+    pub fn extern_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![extern]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![crate]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }"}, {"sha": "3da2805517d4a07773c2612b7dbc15773604448f", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f89f2e38855f5b47f68758e98139aa962cb7a01d/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89f2e38855f5b47f68758e98139aa962cb7a01d/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=f89f2e38855f5b47f68758e98139aa962cb7a01d", "patch": "@@ -233,7 +233,12 @@ pub(crate) struct AstSrc<'a> {\n pub(crate) struct AstNodeSrc<'a> {\n     pub(crate) name: &'a str,\n     pub(crate) traits: &'a [&'a str],\n-    pub(crate) fields: &'a [(&'a str, FieldSrc<'a>)],\n+    pub(crate) fields: &'a [Field<'a>],\n+}\n+\n+pub(crate) enum Field<'a> {\n+    Token(&'a str),\n+    Node { name: &'a str, src: FieldSrc<'a> },\n }\n \n pub(crate) enum FieldSrc<'a> {\n@@ -251,31 +256,34 @@ pub(crate) struct AstEnumSrc<'a> {\n macro_rules! ast_nodes {\n     ($(\n         struct $name:ident$(: $($trait:ident),*)? {\n-            $($field_name:ident $(: $ty:tt)?),*$(,)?\n+            $($field_name:ident $(![$token:tt])? $(: $ty:tt)?),*$(,)?\n         }\n     )*) => {\n         [$(\n             AstNodeSrc {\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n-                fields: &[$(\n-                    (stringify!($field_name), field_ty!($field_name $($ty)?))\n-                ),*],\n+                fields: &[\n+                    $(field!($(T![$token])? $field_name $($ty)?)),*\n+                ],\n \n             }\n         ),*]\n     };\n }\n \n-macro_rules! field_ty {\n+macro_rules! field {\n+    (T![$token:tt] T) => {\n+        Field::Token(stringify!($token))\n+    };\n     ($field_name:ident) => {\n-        FieldSrc::Shorthand\n+        Field::Node { name: stringify!($field_name), src: FieldSrc::Shorthand }\n     };\n     ($field_name:ident [$ty:ident]) => {\n-        FieldSrc::Many(stringify!($ty))\n+        Field::Node { name: stringify!($field_name), src: FieldSrc::Many(stringify!($ty)) }\n     };\n     ($field_name:ident $ty:ident) => {\n-        FieldSrc::Optional(stringify!($ty))\n+        Field::Node { name: stringify!($field_name), src: FieldSrc::Optional(stringify!($ty)) }\n     };\n }\n \n@@ -290,7 +298,6 @@ macro_rules! ast_enums {\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n                 variants: &[$(stringify!($variant)),*],\n-\n             }\n         ),*]\n     };\n@@ -304,11 +311,11 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n \n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n             Abi,\n-            ConstKw,\n-            DefaultKw,\n-            AsyncKw,\n-            UnsafeKw,\n-            FnKw,\n+            T![const],\n+            T![default],\n+            T![async],\n+            T![unsafe],\n+            T![fn],\n             ParamList,\n             RetType,\n             body: BlockExpr,\n@@ -318,13 +325,13 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct RetType { ThinArrow, TypeRef }\n \n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-            StructKw,\n+            T![struct],\n             FieldDefList,\n             Semi\n         }\n \n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-            UnionKw,\n+            T![union],\n             RecordFieldDefList,\n         }\n \n@@ -337,7 +344,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n \n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n-            EnumKw,\n+            T![enum],\n             variant_list: EnumVariantList,\n         }\n         struct EnumVariantList {\n@@ -352,14 +359,14 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n \n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n-            UnsafeKw,\n-            AutoKw,\n-            TraitKw,\n+            T![unsafe],\n+            T![auto],\n+            T![trait],\n             ItemList,\n         }\n \n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n-            ModKw,\n+            T![mod],\n             ItemList,\n             Semi\n         }\n@@ -371,105 +378,105 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n \n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n-            DefaultKw,\n-            ConstKw,\n+            T![default],\n+            T![const],\n             Eq,\n             body: Expr,\n             Semi\n         }\n \n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n-            StaticKw,\n-            MutKw,\n+            T![static],\n+            T![mut],\n             Eq,\n             body: Expr,\n             Semi\n         }\n \n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n-            DefaultKw,\n-            TypeKw,\n+            T![default],\n+            T![type],\n             Eq,\n             TypeRef,\n             Semi\n         }\n \n         struct ImplDef: TypeParamsOwner, AttrsOwner {\n-            DefaultKw,\n-            ConstKw,\n-            UnsafeKw,\n-            ImplKw,\n+            T![default],\n+            T![const],\n+            T![unsafe],\n+            T![impl],\n             Excl,\n-            ForKw,\n+            T![for],\n             ItemList,\n         }\n \n         struct ParenType { LParen, TypeRef, RParen }\n         struct TupleType { LParen, fields: [TypeRef], RParen }\n         struct NeverType { Excl }\n         struct PathType { Path }\n-        struct PointerType { Star, ConstKw, MutKw, TypeRef }\n+        struct PointerType { Star, T![const], T![mut], TypeRef }\n         struct ArrayType { LBrack, TypeRef, Semi, Expr, RBrack }\n         struct SliceType { LBrack, TypeRef, RBrack }\n-        struct ReferenceType { Amp, Lifetime, MutKw, TypeRef }\n+        struct ReferenceType { Amp, Lifetime, T![mut], TypeRef }\n         struct PlaceholderType { Underscore }\n-        struct FnPointerType { Abi, UnsafeKw, FnKw, ParamList, RetType }\n-        struct ForType { ForKw, TypeParamList, TypeRef }\n-        struct ImplTraitType: TypeBoundsOwner { ImplKw }\n-        struct DynTraitType: TypeBoundsOwner { DynKw }\n+        struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n+        struct ForType { T![for], TypeParamList, TypeRef }\n+        struct ImplTraitType: TypeBoundsOwner { T![impl] }\n+        struct DynTraitType: TypeBoundsOwner { T![dyn] }\n \n         struct TupleExpr: AttrsOwner { LParen, exprs: [Expr], RParen }\n         struct ArrayExpr: AttrsOwner { LBrack, exprs: [Expr], Semi, RBrack }\n         struct ParenExpr: AttrsOwner { LParen, Expr, RParen }\n         struct PathExpr  { Path }\n         struct LambdaExpr: AttrsOwner {\n-            StaticKw,\n-            AsyncKw,\n-            MoveKw,\n+            T![static],\n+            T![async],\n+            T![move],\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n-        struct IfExpr: AttrsOwner { IfKw, Condition }\n-        struct LoopExpr: AttrsOwner, LoopBodyOwner { LoopKw }\n-        struct TryBlockExpr: AttrsOwner { TryKw, body: BlockExpr }\n+        struct IfExpr: AttrsOwner { T![if], Condition }\n+        struct LoopExpr: AttrsOwner, LoopBodyOwner { T![loop] }\n+        struct TryBlockExpr: AttrsOwner { T![try], body: BlockExpr }\n         struct ForExpr: AttrsOwner, LoopBodyOwner {\n-            ForKw,\n+            T![for],\n             Pat,\n-            InKw,\n+            T![in],\n             iterable: Expr,\n         }\n-        struct WhileExpr: AttrsOwner, LoopBodyOwner { WhileKw, Condition }\n-        struct ContinueExpr: AttrsOwner { ContinueKw, Lifetime }\n-        struct BreakExpr: AttrsOwner { BreakKw, Lifetime, Expr }\n+        struct WhileExpr: AttrsOwner, LoopBodyOwner { T![while], Condition }\n+        struct ContinueExpr: AttrsOwner { T![continue], Lifetime }\n+        struct BreakExpr: AttrsOwner { T![break], Lifetime, Expr }\n         struct Label { Lifetime }\n-        struct BlockExpr: AttrsOwner { Label, UnsafeKw, Block  }\n+        struct BlockExpr: AttrsOwner { Label, T![unsafe], Block  }\n         struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n             Expr, Dot, NameRef, TypeArgList,\n         }\n         struct IndexExpr: AttrsOwner { LBrack, RBrack }\n         struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n-        struct AwaitExpr: AttrsOwner { Expr, Dot, AwaitKw }\n-        struct TryExpr: AttrsOwner { TryKw, Expr }\n-        struct CastExpr: AttrsOwner { Expr, AsKw, TypeRef }\n-        struct RefExpr: AttrsOwner { Amp, RawKw, MutKw, Expr }\n+        struct AwaitExpr: AttrsOwner { Expr, Dot, T![await] }\n+        struct TryExpr: AttrsOwner { T![try], Expr }\n+        struct CastExpr: AttrsOwner { Expr, T![as], TypeRef }\n+        struct RefExpr: AttrsOwner { Amp, T![raw], T![mut], Expr }\n         struct PrefixExpr: AttrsOwner { PrefixOp, Expr }\n-        struct BoxExpr: AttrsOwner { BoxKw, Expr }\n+        struct BoxExpr: AttrsOwner { T![box], Expr }\n         struct RangeExpr: AttrsOwner { RangeOp }\n         struct BinExpr: AttrsOwner { BinOp }\n         struct Literal { LiteralToken }\n \n-        struct MatchExpr: AttrsOwner { MatchKw, Expr, MatchArmList }\n+        struct MatchExpr: AttrsOwner { T![match], Expr, MatchArmList }\n         struct MatchArmList: AttrsOwner { LCurly, arms: [MatchArm], RCurly }\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n             FatArrow,\n             Expr,\n         }\n-        struct MatchGuard { IfKw, Expr }\n+        struct MatchGuard { T![if], Expr }\n \n         struct RecordLit { Path, RecordFieldList}\n         struct RecordFieldList {\n@@ -483,9 +490,9 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n \n         struct OrPat { pats: [Pat] }\n         struct ParenPat { LParen, Pat, RParen }\n-        struct RefPat { Amp, MutKw, Pat }\n-        struct BoxPat { BoxKw, Pat }\n-        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, At, Pat }\n+        struct RefPat { Amp, T![mut], Pat }\n+        struct BoxPat { T![box], Pat }\n+        struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], At, Pat }\n         struct PlaceholderPat { Underscore }\n         struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n@@ -508,7 +515,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct TupleStructPat { Path, LParen, args: [Pat], RParen }\n         struct TuplePat { LParen, args: [Pat], RParen }\n \n-        struct Visibility { PubKw, SuperKw, SelfKw, CrateKw }\n+        struct Visibility { T![pub], T![super], T![self], T![crate] }\n         struct Name { Ident }\n         struct NameRef { NameRefToken }\n \n@@ -534,20 +541,20 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             default_val: Expr,\n         }\n         struct LifetimeParam: AttrsOwner { Lifetime}\n-        struct TypeBound { Lifetime, /* Question,  */ ConstKw, /* Question,  */ TypeRef}\n+        struct TypeBound { Lifetime, /* Question,  */ T![const], /* Question,  */ TypeRef}\n         struct TypeBoundList { bounds: [TypeBound] }\n         struct WherePred: TypeBoundsOwner { Lifetime, TypeRef }\n-        struct WhereClause { WhereKw, predicates: [WherePred] }\n+        struct WhereClause { T![where], predicates: [WherePred] }\n         struct Abi { String }\n         struct ExprStmt: AttrsOwner { Expr, Semi }\n         struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n-            LetKw,\n+            T![let],\n             Pat,\n             Eq,\n             initializer: Expr,\n             Semi,\n         }\n-        struct Condition { LetKw, Pat, Eq, Expr }\n+        struct Condition { T![let], Pat, Eq, Expr }\n         struct Block: AttrsOwner, ModuleItemOwner {\n             LCurly,\n             statements: [Stmt],\n@@ -560,22 +567,22 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             params: [Param],\n             RParen\n         }\n-        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, SelfKw }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, T![self] }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n             Dotdotdot\n         }\n         struct UseItem: AttrsOwner, VisibilityOwner {\n-            UseKw,\n+            T![use],\n             UseTree,\n         }\n         struct UseTree {\n             Path, Star, UseTreeList, Alias\n         }\n-        struct Alias: NameOwner { AsKw }\n+        struct Alias: NameOwner { T![as] }\n         struct UseTreeList { LCurly, use_trees: [UseTree], RCurly }\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n-            ExternKw, CrateKw, NameRef, Alias,\n+            T![extern], T![crate], NameRef, Alias,\n         }\n         struct ArgList {\n             LParen,"}, {"sha": "c4fb29bbfa626d5bb61941c62b19d1f62b651aaf", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f89f2e38855f5b47f68758e98139aa962cb7a01d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89f2e38855f5b47f68758e98139aa962cb7a01d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=f89f2e38855f5b47f68758e98139aa962cb7a01d", "patch": "@@ -12,7 +12,7 @@ use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n \n use crate::{\n-    ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n+    ast_src::{AstSrc, Field, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n     codegen::{self, update, Mode},\n     project_root, Result,\n };\n@@ -189,46 +189,30 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n-        let methods = node.fields.iter().map(|(name, field)| {\n-            let is_kw = name.ends_with(\"Kw\");\n-            let method_name = match field {\n-                FieldSrc::Shorthand => {\n-                    let name = if is_kw { &name[..name.len() - 2] } else { &name };\n-                    format_ident!(\"{}\", to_lower_snake_case(name))\n-                }\n-                _ => format_ident!(\"{}\", name),\n-            };\n-            let ty = match field {\n-                FieldSrc::Optional(ty) | FieldSrc::Many(ty) => ty,\n-                FieldSrc::Shorthand => name,\n-            };\n-\n-            let ty = format_ident!(\"{}\", ty);\n+        let methods = node.fields.iter().map(|field| {\n+            let method_name = field.method_name();\n+            let ty = field.ty();\n \n-            match field {\n-                FieldSrc::Many(_) => {\n+            if field.is_many() {\n+                quote! {\n+                    pub fn #method_name(&self) -> AstChildren<#ty> {\n+                        support::children(&self.syntax)\n+                    }\n+                }\n+            } else {\n+                if let Some(token_kind) = field.token_kind() {\n                     quote! {\n-                        pub fn #method_name(&self) -> AstChildren<#ty> {\n-                            support::children(&self.syntax)\n+                        pub fn #method_name(&self) -> Option<#ty> {\n+                            support::token2(&self.syntax, #token_kind)\n                         }\n                     }\n-                }\n-                FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n+                } else {\n                     let is_token = token_kinds.contains(&ty.to_string());\n                     if is_token {\n                         let method_name = format_ident!(\"{}_token\", method_name);\n-                        if is_kw {\n-                            let token_kind = format_ident!(\"{}\", to_upper_snake_case(name));\n-                            quote! {\n-                                pub fn #method_name(&self) -> Option<SyntaxToken> {\n-                                    support::token2(&self.syntax, #token_kind)\n-                                }\n-                            }\n-                        } else {\n-                            quote! {\n-                                pub fn #method_name(&self) -> Option<#ty> {\n-                                    support::token(&self.syntax)\n-                                }\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::token(&self.syntax)\n                             }\n                         }\n                     } else {\n@@ -351,6 +335,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         use crate::{\n             SyntaxNode, SyntaxToken, SyntaxKind::{self, *},\n             ast::{self, AstNode, AstChildren, support},\n+            T,\n         };\n \n         use super::tokens::*;\n@@ -519,3 +504,40 @@ fn to_pascal_case(s: &str) -> String {\n     }\n     buf\n }\n+\n+impl Field<'_> {\n+    fn is_many(&self) -> bool {\n+        match self {\n+            Field::Node { src: FieldSrc::Many(_), .. } => true,\n+            _ => false,\n+        }\n+    }\n+    fn token_kind(&self) -> Option<proc_macro2::TokenStream> {\n+        let res = match self {\n+            Field::Token(token) => {\n+                let token = format_ident!(\"{}\", token);\n+                quote! { T![#token] }\n+            }\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn method_name(&self) -> proc_macro2::Ident {\n+        match self {\n+            Field::Token(name) => format_ident!(\"{}_token\", name),\n+            Field::Node { name, src } => match src {\n+                FieldSrc::Shorthand => format_ident!(\"{}\", to_lower_snake_case(name)),\n+                _ => format_ident!(\"{}\", name),\n+            },\n+        }\n+    }\n+    fn ty(&self) -> proc_macro2::Ident {\n+        match self {\n+            Field::Token(_) => format_ident!(\"SyntaxToken\"),\n+            Field::Node { name, src } => match src {\n+                FieldSrc::Optional(ty) | FieldSrc::Many(ty) => format_ident!(\"{}\", ty),\n+                FieldSrc::Shorthand => format_ident!(\"{}\", name),\n+            },\n+        }\n+    }\n+}"}]}