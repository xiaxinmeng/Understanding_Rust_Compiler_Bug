{"sha": "2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMmEzYTBjYzExYzQwYThmZDZkODAxNWQwYjdmYjExYjMwZDgxNTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-03T14:01:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-03T14:01:53Z"}, "message": "check that all syscall arguments are scalars", "tree": {"sha": "d1b5664292961e45419f01c04f0187ecfc8d7f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1b5664292961e45419f01c04f0187ecfc8d7f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "html_url": "https://github.com/rust-lang/rust/commit/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5", "html_url": "https://github.com/rust-lang/rust/commit/5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "7b417990af86754e56d2ad7396bd4d772987824b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "patch": "@@ -221,7 +221,7 @@ fn main() {\n                             ),\n                             FromHexError::OddLength =>\n                                 panic!(\"-Zmiri-seed should have an even number of digits\"),\n-                            err => panic!(\"Unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n+                            err => panic!(\"unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n                         });\n                     if seed_raw.len() > 8 {\n                         panic!(format!("}, {"sha": "04efa79b9d93fc61ff6d8e12ec3beb500650b6b2", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "patch": "@@ -113,16 +113,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n-                // FIXME: The libc syscall() function is a variadic function.\n-                // It's valid to call it with more arguments than a syscall\n-                // needs, so none of these syscalls should use check_arg_count.\n-                // It's even valid to call it with the wrong type of arguments,\n-                // as long as they'd end up in the same place with the calling\n-                // convention used. (E.g. using a `usize` instead of a pointer.)\n-                // It's not directly clear which number, size, and type of arguments\n-                // are acceptable in which cases and which aren't. (E.g. some\n-                // types might take up the space of two registers.)\n-                // So this needs to be researched first.\n+                // The syscall variadic function is legal to call with more arguments than needed,\n+                // extra arguments are simply ignored. However, all arguments need to be scalars;\n+                // other types might be treated differently by the calling convention.\n+                for arg in args {\n+                    if !matches!(arg.layout.abi, rustc_target::abi::Abi::Scalar(_)) {\n+                        throw_ub_format!(\"`syscall` arguments must all have scalar layout, but {} does not\", arg.layout.ty);\n+                    }\n+                }\n \n                 let sys_getrandom = this\n                     .eval_libc(\"SYS_getrandom\")?\n@@ -144,22 +142,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id, so skip over it.\n-                        let &[_, ptr, len, flags] = check_arg_count(args)?;\n-                        getrandom(this, ptr, len, flags, dest)?;\n+                        if args.len() < 4 {\n+                            throw_ub_format!(\"incorrect number of arguments for `getrandom` syscall: got {}, expected at least 4\", args.len());\n+                        }\n+                        getrandom(this, args[1], args[2], args[3], dest)?;\n                     }\n                     // `statx` is used by `libstd` to retrieve metadata information on `linux`\n                     // instead of using `stat`,`lstat` or `fstat` as on `macos`.\n                     id if id == sys_statx => {\n                         // The first argument is the syscall id, so skip over it.\n-                        let &[_, dirfd, pathname, flags, mask, statxbuf] = check_arg_count(args)?;\n-                        let result = this.linux_statx(dirfd, pathname, flags, mask, statxbuf)?;\n+                        if args.len() < 6 {\n+                            throw_ub_format!(\"incorrect number of arguments for `statx` syscall: got {}, expected at least 6\", args.len());\n+                        }\n+                        let result = this.linux_statx(args[1], args[2], args[3], args[4], args[5])?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n                         futex(this, args, dest)?;\n                     }\n-                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n+                    id => throw_unsup_format!(\"Miri does not support syscall ID {}\", id),\n                 }\n             }\n "}, {"sha": "9d124872f5cc9b60c6d80b13e7dcf2309e8125c3", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "patch": "@@ -17,8 +17,8 @@ pub fn futex<'tcx>(\n     // may or may not be left out from the `syscall()` call.\n     // Therefore we don't use `check_arg_count` here, but only check for the\n     // number of arguments to fall within a range.\n-    if !(4..=7).contains(&args.len()) {\n-        throw_ub_format!(\"incorrect number of arguments for futex syscall: got {}, expected between 4 and 7 (inclusive)\", args.len());\n+    if args.len() < 4 {\n+        throw_ub_format!(\"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\", args.len());\n     }\n \n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n@@ -49,13 +49,13 @@ pub fn futex<'tcx>(\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n         op if op & !futex_realtime == futex_wait => {\n             if args.len() < 5 {\n-                throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n+                throw_ub_format!(\"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\", args.len());\n             }\n             let timeout = args[4];\n             let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n                 None\n             } else {\n-                this.check_no_isolation(\"`syscall(SYS_FUTEX, op=FUTEX_WAIT)` with timeout\")?;\n+                this.check_no_isolation(\"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\")?;\n                 let duration = match this.read_timespec(timeout)? {\n                     Some(duration) => duration,\n                     None => {\n@@ -126,7 +126,7 @@ pub fn futex<'tcx>(\n             }\n             this.write_scalar(Scalar::from_machine_isize(n, this), dest)?;\n         }\n-        op => throw_unsup_format!(\"miri does not support SYS_futex operation {}\", op),\n+        op => throw_unsup_format!(\"Miri does not support `futex` syscall with op={}\", op),\n     }\n \n     Ok(())"}]}