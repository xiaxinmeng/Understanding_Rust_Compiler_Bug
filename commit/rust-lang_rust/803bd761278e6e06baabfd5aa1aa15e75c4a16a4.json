{"sha": "803bd761278e6e06baabfd5aa1aa15e75c4a16a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwM2JkNzYxMjc4ZTZlMDZiYWFiZmQ1YWExYWExNWU3NWM0YTE2YTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-15T10:41:19Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "introduce `Universe` struct", "tree": {"sha": "f914ed645d5ca3f341fabd6e3dc03b1c91b9be4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f914ed645d5ca3f341fabd6e3dc03b1c91b9be4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/803bd761278e6e06baabfd5aa1aa15e75c4a16a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/803bd761278e6e06baabfd5aa1aa15e75c4a16a4", "html_url": "https://github.com/rust-lang/rust/commit/803bd761278e6e06baabfd5aa1aa15e75c4a16a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/803bd761278e6e06baabfd5aa1aa15e75c4a16a4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85417f5938023d1491b44d94da705f539bb8b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a85417f5938023d1491b44d94da705f539bb8b17", "html_url": "https://github.com/rust-lang/rust/commit/a85417f5938023d1491b44d94da705f539bb8b17"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "26fcd5c3110563d98f6b77c85cdee02079570c34", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/803bd761278e6e06baabfd5aa1aa15e75c4a16a4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/803bd761278e6e06baabfd5aa1aa15e75c4a16a4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=803bd761278e6e06baabfd5aa1aa15e75c4a16a4", "patch": "@@ -1306,6 +1306,68 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n+/// \"Universes\" are used during type- and trait-checking in the\n+/// presence of `for<..>` binders to control what sets of names are\n+/// visible. Universes are arranged into a tree: the root universe\n+/// contains names that are always visible. But when you enter into\n+/// some subuniverse, then it may add names that are only visible\n+/// within that subtree (but it can still name the names of its\n+/// ancestor universes).\n+///\n+/// To make this more concrete, consider this program:\n+///\n+/// ```\n+/// struct Foo { }\n+/// fn bar<T>(x: T) {\n+///   let y: for<'a> fn(&'a u8, Foo) = ...;\n+/// }\n+/// ```\n+///\n+/// The struct name `Foo` is in the root universe U0. But the type\n+/// parameter `T`, introduced on `bar`, is in a subuniverse U1 --\n+/// i.e., within `bar`, we can name both `T` and `Foo`, but outside of\n+/// `bar`, we cannot name `T`. Then, within the type of `y`, the\n+/// region `'a` is in a subuniverse U2 of U1, because we can name it\n+/// inside the fn type but not outside.\n+///\n+/// Universes are related to **skolemization** -- which is a way of\n+/// doing type- and trait-checking around these \"forall\" binders (also\n+/// called **universal quantification**). The idea is that when, in\n+/// the body of `bar`, we refer to `T` as a type, we aren't referring\n+/// to any type in particular, but rather a kind of \"fresh\" type that\n+/// is distinct from all other types we have actually declared. This\n+/// is called a **skolemized** type, and we use universes to talk\n+/// about this. In other words, a type name in universe 0 always\n+/// corresponds to some \"ground\" type that the user declared, but a\n+/// type name in a non-zero universe is a skolemized type -- an\n+/// idealized representative of \"types in general\" that we use for\n+/// checking generic functions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct UniverseIndex(u32);\n+\n+impl UniverseIndex {\n+    /// The root universe, where things that the user defined are\n+    /// visible.\n+    pub fn root() -> UniverseIndex {\n+        UniverseIndex(0)\n+    }\n+\n+    /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n+    /// So, for example, suppose we have this type in universe `U`:\n+    ///\n+    /// ```\n+    /// for<'a> fn(&'a u32)\n+    /// ```\n+    ///\n+    /// Once we \"enter\" into this `for<'a>` quantifier, we are in a\n+    /// subuniverse of `U` -- in this new universe, we can name the\n+    /// region `'a`, but that region was not nameable from `U` because\n+    /// it was not in scope there.\n+    pub fn subuniverse(self) -> UniverseIndex {\n+        UniverseIndex(self.0 + 1)\n+    }\n+}\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}]}