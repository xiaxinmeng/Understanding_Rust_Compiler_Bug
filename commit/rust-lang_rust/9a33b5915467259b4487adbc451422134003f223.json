{"sha": "9a33b5915467259b4487adbc451422134003f223", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMzNiNTkxNTQ2NzI1OWI0NDg3YWRiYzQ1MTQyMjEzNDAwM2YyMjM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-13T13:04:28Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-27T19:06:35Z"}, "message": "minimal", "tree": {"sha": "89978881f86326d977d25800b4d30c59391a1e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89978881f86326d977d25800b4d30c59391a1e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a33b5915467259b4487adbc451422134003f223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a33b5915467259b4487adbc451422134003f223", "html_url": "https://github.com/rust-lang/rust/commit/9a33b5915467259b4487adbc451422134003f223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a33b5915467259b4487adbc451422134003f223/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "url": "https://api.github.com/repos/rust-lang/rust/commits/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58", "html_url": "https://github.com/rust-lang/rust/commit/104cb878e34da2f66c0d0b7e5ed388a2c5b96b58"}], "stats": {"total": 122, "additions": 44, "deletions": 78}, "files": [{"sha": "6f22a0f8ce31e8e80a8246abba4a5e16c82ae7a5", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=9a33b5915467259b4487adbc451422134003f223", "patch": "@@ -19,9 +19,9 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n-    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKint,\n-    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n-    TyVid, TypeAndMut,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n+    PredicateKint, ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind,\n+    TyS, TyVar, TyVid, TypeAndMut,\n };\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -2030,12 +2030,6 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n-        &self.0\n-    }\n-}\n-\n impl<'tcx> Borrow<PredicateKint<'tcx>> for Interned<'tcx, PredicateKint<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a PredicateKint<'tcx> {\n         &self.0"}, {"sha": "1afdc153fe551c717798f8e6fc34ff60bffcb06d", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=9a33b5915467259b4487adbc451422134003f223", "patch": "@@ -1063,7 +1063,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n \n         kind.hash_stable(hcx, hasher);\n     }\n+}\n \n+impl<'tcx> Predicate<'tcx> {\n     pub fn kint(self, tcx: TyCtxt<'tcx>) -> &'tcx PredicateKint<'tcx> {\n         // I am efficient\n         tcx.intern_predicate_kint(match *self.kind() {"}, {"sha": "c09eebc22c09d004b2ded2abfa7a02f731aded64", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 39, "deletions": 69, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a33b5915467259b4487adbc451422134003f223/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=9a33b5915467259b4487adbc451422134003f223", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::{self, Const, ToPolyTraitRef, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, Binder, Const, ToPredicate, Ty, TypeFoldable};\n use std::marker::PhantomData;\n \n use super::project;\n@@ -317,9 +317,15 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         let infcx = self.selcx.infcx();\n \n-        match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => {\n-                let trait_obligation = obligation.with(*data);\n+        match obligation.predicate.kint(infcx.tcx) {\n+            ty::PredicateKint::ForAll(binder) => {\n+                let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n+                ProcessResult::Changed(mk_pending(vec![\n+                    obligation.with(pred.to_predicate(infcx.tcx)),\n+                ]))\n+            }\n+            ty::PredicateKint::Trait(ref data, _) => {\n+                let trait_obligation = obligation.with(Binder::dummy(*data));\n \n                 if obligation.predicate.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n@@ -352,7 +358,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         // trait selection is because we don't have enough\n                         // information about the types in the trait.\n                         pending_obligation.stalled_on =\n-                            trait_ref_infer_vars(self.selcx, data.to_poly_trait_ref());\n+                            trait_ref_infer_vars(self.selcx, data.trait_ref);\n \n                         debug!(\n                             \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n@@ -373,80 +379,48 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::RegionOutlives(binder) => {\n-                match infcx.region_outlives_predicate(&obligation.cause, binder) {\n+            &ty::PredicateKint::RegionOutlives(data) => {\n+                match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n             }\n \n-            ty::PredicateKind::TypeOutlives(ref binder) => {\n-                // Check if there are higher-ranked vars.\n-                match binder.no_bound_vars() {\n-                    // If there are, inspect the underlying type further.\n-                    None => {\n-                        // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n-                        let binder = binder.map_bound_ref(|pred| pred.0);\n-\n-                        // Check if the type has any bound vars.\n-                        match binder.no_bound_vars() {\n-                            // If so, this obligation is an error (for now). Eventually we should be\n-                            // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-                            // NOTE: this is duplicate-implemented between here and fulfillment.\n-                            None => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n-                            // Otherwise, we have something of the form\n-                            // `for<'a> T: 'a where 'a not in T`, which we can treat as\n-                            // `T: 'static`.\n-                            Some(t_a) => {\n-                                let r_static = self.selcx.tcx().lifetimes.re_static;\n-                                if self.register_region_obligations {\n-                                    self.selcx.infcx().register_region_obligation_with_cause(\n-                                        t_a,\n-                                        r_static,\n-                                        &obligation.cause,\n-                                    );\n-                                }\n-                                ProcessResult::Changed(vec![])\n-                            }\n-                        }\n-                    }\n-                    // If there aren't, register the obligation.\n-                    Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                        if self.register_region_obligations {\n-                            self.selcx.infcx().register_region_obligation_with_cause(\n-                                t_a,\n-                                r_b,\n-                                &obligation.cause,\n-                            );\n-                        }\n-                        ProcessResult::Changed(vec![])\n-                    }\n+            ty::PredicateKint::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+                if self.register_region_obligations {\n+                    self.selcx.infcx().register_region_obligation_with_cause(\n+                        t_a,\n+                        r_b,\n+                        &obligation.cause,\n+                    );\n                 }\n+                ProcessResult::Changed(vec![])\n             }\n \n-            ty::PredicateKind::Projection(ref data) => {\n-                let project_obligation = obligation.with(*data);\n+            ty::PredicateKint::Projection(ref data) => {\n+                let project_obligation = obligation.with(Binder::dummy(*data));\n                 match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n                     Ok(None) => {\n-                        let tcx = self.selcx.tcx();\n-                        pending_obligation.stalled_on =\n-                            trait_ref_infer_vars(self.selcx, data.to_poly_trait_ref(tcx));\n+                        pending_obligation.stalled_on = trait_ref_infer_vars(\n+                            self.selcx,\n+                            data.projection_ty.trait_ref(infcx.tcx),\n+                        );\n                         ProcessResult::Unchanged\n                     }\n                     Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n                     Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n                 }\n             }\n \n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            &ty::PredicateKint::ObjectSafe(trait_def_id) => {\n                 if !self.selcx.tcx().is_object_safe(trait_def_id) {\n                     ProcessResult::Error(CodeSelectionError(Unimplemented))\n                 } else {\n                     ProcessResult::Changed(vec![])\n                 }\n             }\n \n-            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n+            &ty::PredicateKint::ClosureKind(_, closure_substs, kind) => {\n                 match self.selcx.infcx().closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -459,7 +433,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(arg) => {\n+            &ty::PredicateKint::WellFormed(arg) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n@@ -476,27 +450,24 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::Subtype(subtype) => {\n+            &ty::PredicateKint::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,\n-                    subtype,\n+                    Binder::dummy(subtype),\n                 ) {\n                     None => {\n                         // None means that both are unresolved.\n                         pending_obligation.stalled_on = vec![\n-                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().a).unwrap(),\n-                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().b).unwrap(),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),\n                         ];\n                         ProcessResult::Unchanged\n                     }\n                     Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n                     Some(Err(err)) => {\n-                        let expected_found = ExpectedFound::new(\n-                            subtype.skip_binder().a_is_expected,\n-                            subtype.skip_binder().a,\n-                            subtype.skip_binder().b,\n-                        );\n+                        let expected_found =\n+                            ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);\n                         ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n                             expected_found,\n                             err,\n@@ -505,7 +476,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKint::ConstEvaluatable(def_id, substs) => {\n                 match self.selcx.infcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -518,7 +489,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateKint::ConstEquate(c1, c2) => {\n                 debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n \n                 let stalled_on = &mut pending_obligation.stalled_on;\n@@ -601,12 +572,11 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n /// Returns the set of inference variables contained in a trait ref.\n fn trait_ref_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n         .resolve_vars_if_possible(&trait_ref)\n-        .skip_binder() // ok b/c this check doesn't care about regions\n         .substs\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that"}]}