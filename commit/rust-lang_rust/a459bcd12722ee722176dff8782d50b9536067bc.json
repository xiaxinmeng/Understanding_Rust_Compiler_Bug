{"sha": "a459bcd12722ee722176dff8782d50b9536067bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NTliY2QxMjcyMmVlNzIyMTc2ZGZmODc4MmQ1MGI5NTM2MDY3YmM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-12T03:04:16Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-12T03:04:16Z"}, "message": "Give the lexer a session so that it can fail more informatively", "tree": {"sha": "5223f42668991de283cfe99e5ee7ce9e93f20062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5223f42668991de283cfe99e5ee7ce9e93f20062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a459bcd12722ee722176dff8782d50b9536067bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a459bcd12722ee722176dff8782d50b9536067bc", "html_url": "https://github.com/rust-lang/rust/commit/a459bcd12722ee722176dff8782d50b9536067bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a459bcd12722ee722176dff8782d50b9536067bc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "531515d7ae3c9cf9addd47b17db951f9fd8635ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/531515d7ae3c9cf9addd47b17db951f9fd8635ed", "html_url": "https://github.com/rust-lang/rust/commit/531515d7ae3c9cf9addd47b17db951f9fd8635ed"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "1c9698bd4cd5db58ae73d45a7521c509c8f7b1e6", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=a459bcd12722ee722176dff8782d50b9536067bc", "patch": "@@ -123,7 +123,7 @@ fn pretty_print_input(session.session sess,\n     auto def = tup(ast.local_crate, 0);\n     auto p = front.parser.new_parser(sess, env, def, input, 0u);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_file(crate.node.module, input, std.IO.stdout());\n+    pretty.pprust.print_file(sess, crate.node.module, input, std.IO.stdout());\n }\n \n fn version(str argv0) {"}, {"sha": "21fce55ec8105b638440ce4800c65279f40ce1ae", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=a459bcd12722ee722176dff8782d50b9536067bc", "patch": "@@ -7,6 +7,7 @@ import std.Map.hashmap;\n import std.Option;\n import std.Option.some;\n import std.Option.none;\n+import driver.session.session;\n import util.common;\n import util.common.new_str_hash;\n \n@@ -24,11 +25,14 @@ state type reader = state obj {\n     fn get_keywords() -> hashmap[str,token.token];\n     fn get_reserved() -> hashmap[str,()];\n     fn get_filemap() -> codemap.filemap;\n+    fn err(str m);\n };\n \n-fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n-    -> reader {\n-    state obj reader(str file,\n+fn new_reader(session sess, IO.reader rdr, str filename,\n+              codemap.filemap filemap) -> reader {\n+\n+    state obj reader(session sess,\n+                     str file,\n                      uint len,\n                      mutable uint pos,\n                      mutable char ch,\n@@ -98,10 +102,14 @@ fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n         fn get_filemap() -> codemap.filemap {\n             ret fm;\n         }\n+\n+        fn err(str m) {\n+            sess.span_err(rec(lo=chpos, hi=chpos), m);\n+        }\n     }\n     auto file = Str.unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = vec();\n-    auto rd = reader(file, Str.byte_len(file), 0u, -1 as char,\n+    auto rd = reader(sess, file, Str.byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      strs, keyword_table(),\n                      reserved_word_table(),\n@@ -333,7 +341,7 @@ fn consume_block_comment(reader rdr) {\n             }\n         }\n         if (rdr.is_eof()) {\n-            log_err \"unterminated block comment\";\n+            rdr.err(\"unterminated block comment\");\n             fail;\n         }\n     }\n@@ -371,7 +379,7 @@ fn scan_exponent(reader rdr) -> Option.t[str] {\n             ret(some(res + exponent));\n         }\n         else {\n-            log_err (\"scan_exponent: bad fp literal\");\n+            rdr.err(\"scan_exponent: bad fp literal\");\n             fail;\n         }\n     }\n@@ -550,7 +558,7 @@ fn scan_numeric_escape(reader rdr) -> char {\n         case ('u') { n_hex_digits = 4; }\n         case ('U') { n_hex_digits = 8; }\n         case (?c) {\n-            log_err #fmt(\"unknown numeric character escape: %d\", c as int);\n+            rdr.err(#fmt(\"unknown numeric character escape: %d\", c as int));\n             fail;\n         }\n     }\n@@ -562,7 +570,7 @@ fn scan_numeric_escape(reader rdr) -> char {\n \n     while (n_hex_digits != 0) {\n         if (!is_hex_digit(n)) {\n-            log_err #fmt(\"illegal numeric character escape: %d\", n as int);\n+            rdr.err(#fmt(\"illegal numeric character escape: %d\", n as int));\n             fail;\n         }\n         accum_int *= 16;\n@@ -603,7 +611,7 @@ fn next_token(reader rdr) -> token.token {\n \n         auto rsvd = rdr.get_reserved();\n         if (rsvd.contains_key(accum_str)) {\n-            log_err #fmt(\"reserved keyword: %s\", accum_str);\n+            rdr.err(#fmt(\"reserved keyword: %s\", accum_str));\n             fail;\n         }\n \n@@ -726,16 +734,16 @@ fn next_token(reader rdr) -> token.token {\n                     case ('U') { c2 = scan_numeric_escape(rdr); }\n \n                     case (?c2) {\n-                        log_err #fmt(\"unknown character escape: %d\",\n-                                     c2 as int);\n+                        rdr.err(#fmt(\"unknown character escape: %d\",\n+                                     c2 as int));\n                         fail;\n                     }\n                 }\n                 rdr.bump();\n             }\n \n             if (rdr.next() != '\\'') {\n-                log_err \"unterminated character constant\";\n+                rdr.err(\"unterminated character constant\");\n                 fail;\n             }\n             rdr.bump(); // advance curr to closing '\n@@ -786,8 +794,8 @@ fn next_token(reader rdr) -> token.token {\n                             }\n \n                             case (?c2) {\n-                                log_err #fmt(\"unknown string escape: %d\",\n-                                             c2 as int);\n+                                rdr.err(#fmt(\"unknown string escape: %d\",\n+                                             c2 as int));\n                                 fail;\n                             }\n                         }\n@@ -853,7 +861,7 @@ fn next_token(reader rdr) -> token.token {\n         }\n \n         case (?c) {\n-            log_err #fmt(\"unkown start of token: %d\", c as int);\n+            rdr.err(#fmt(\"unkown start of token: %d\", c as int));\n             fail;\n         }\n     }\n@@ -917,16 +925,19 @@ fn read_block_comment(reader rdr) -> cmnt {\n             Str.push_char(val, rdr.curr());\n             rdr.bump();\n         }\n-        if (rdr.is_eof()) {fail;}\n+        if (rdr.is_eof()) {\n+            rdr.err(\"Unexpected end of file in block comment\");\n+            fail;\n+        }\n     }\n     ret rec(val=cmnt_block(lines),\n             pos=p,\n             space_after=consume_whitespace(rdr) > 1u);\n }\n \n-fn gather_comments(str path) -> vec[cmnt] {\n+fn gather_comments(session sess, str path) -> vec[cmnt] {\n     auto srdr = IO.file_reader(path);\n-    auto rdr = new_reader(srdr, path, codemap.new_filemap(path, 0u));\n+    auto rdr = new_reader(sess, srdr, path, codemap.new_filemap(path, 0u));\n     let vec[cmnt] comments = vec();\n     while (!rdr.is_eof()) {\n         while (true) {"}, {"sha": "85b1dc7d3157993f94b9370340d3c8d8d35042e9", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a459bcd12722ee722176dff8782d50b9536067bc", "patch": "@@ -142,7 +142,7 @@ fn new_parser(session.session sess,\n     auto srdr = IO.file_reader(path);\n     auto filemap = codemap.new_filemap(path, pos);\n     Vec.push[codemap.filemap](sess.get_codemap().files, filemap);\n-    auto rdr = lexer.new_reader(srdr, path, filemap);\n+    auto rdr = lexer.new_reader(sess, srdr, path, filemap);\n     // Make sure npos points at first actual token.\n     lexer.consume_any_whitespace(rdr);\n     auto npos = rdr.get_chpos();"}, {"sha": "3c417eff423515c82fb0ae25843ac1420640cf5d", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a459bcd12722ee722176dff8782d50b9536067bc/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=a459bcd12722ee722176dff8782d50b9536067bc", "patch": "@@ -2,6 +2,7 @@ import std.Vec;\n import std.Str;\n import std.IO;\n import std.Option;\n+import driver.session.session;\n import front.ast;\n import front.lexer;\n import util.common;\n@@ -15,8 +16,8 @@ type ps = @rec(pp.ps s,\n                Option.t[vec[lexer.cmnt]] comments,\n                mutable uint cur_cmnt);\n \n-fn print_file(ast._mod _mod, str filename, IO.writer out) {\n-    auto cmnts = lexer.gather_comments(filename);\n+fn print_file(session sess, ast._mod _mod, str filename, IO.writer out) {\n+    auto cmnts = lexer.gather_comments(sess, filename);\n     auto s = @rec(s=pp.mkstate(out, default_columns),\n                   comments=Option.some[vec[lexer.cmnt]](cmnts),\n                   mutable cur_cmnt=0u);"}]}