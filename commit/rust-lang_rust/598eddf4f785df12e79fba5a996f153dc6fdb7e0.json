{"sha": "598eddf4f785df12e79fba5a996f153dc6fdb7e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OGVkZGY0Zjc4NWRmMTJlNzlmYmE1YTk5NmYxNTNkYzZmZGI3ZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-24T20:15:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-24T20:15:21Z"}, "message": "Auto merge of #43454 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 11 pull requests\n\n- Successful merges: #43297, #43322, #43342, #43361, #43366, #43374, #43379, #43401, #43421, #43428, #43446\n- Failed merges:", "tree": {"sha": "3fb84fd0a941dcfa2aaf1d627259301732b0ec42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fb84fd0a941dcfa2aaf1d627259301732b0ec42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/598eddf4f785df12e79fba5a996f153dc6fdb7e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/598eddf4f785df12e79fba5a996f153dc6fdb7e0", "html_url": "https://github.com/rust-lang/rust/commit/598eddf4f785df12e79fba5a996f153dc6fdb7e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/598eddf4f785df12e79fba5a996f153dc6fdb7e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80e946101dd49dd1864b6229f9430c55036c7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80e946101dd49dd1864b6229f9430c55036c7ce", "html_url": "https://github.com/rust-lang/rust/commit/b80e946101dd49dd1864b6229f9430c55036c7ce"}, {"sha": "0bb4291295b672d53edf816b5bde2d78c110d654", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb4291295b672d53edf816b5bde2d78c110d654", "html_url": "https://github.com/rust-lang/rust/commit/0bb4291295b672d53edf816b5bde2d78c110d654"}], "stats": {"total": 471, "additions": 275, "deletions": 196}, "files": [{"sha": "e3ad7ce85f8ccbea3bca1bc69028178fea82004d", "filename": "configure", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -560,8 +560,8 @@ case \"$CFG_RELEASE_CHANNEL\" in\n           *-pc-windows-gnu)\n             ;;\n           *)\n-            CFG_ENABLE_DEBUGINFO_LINES=1\n-            CFG_ENABLE_DEBUGINFO_ONLY_STD=1\n+            enable_if_not_disabled debuginfo-lines\n+            enable_if_not_disabled debuginfo-only-std\n             ;;\n         esac\n \n@@ -572,8 +572,8 @@ case \"$CFG_RELEASE_CHANNEL\" in\n           *-pc-windows-gnu)\n             ;;\n           *)\n-            CFG_ENABLE_DEBUGINFO_LINES=1\n-            CFG_ENABLE_DEBUGINFO_ONLY_STD=1\n+            enable_if_not_disabled debuginfo-lines\n+            enable_if_not_disabled debuginfo-only-std\n             ;;\n         esac\n \t;;"}, {"sha": "ecbc860e25c03200be283cc7ab66a40f71a3e1d9", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -194,6 +194,14 @@ pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n }\n ```\n \n+In many cases, you may need to manually link to the `compiler_builtins` crate\n+when building a `no_std` binary. You may observe this via linker error messages\n+such as \"```undefined reference to `__rust_probestack'```\". Using this crate\n+also requires enabling the library feature `compiler_builtins_lib`. You can read\n+more about this [here][compiler-builtins-lib].\n+\n+[compiler-builtins-lib]: library-features/compiler-builtins-lib.html\n+\n ## More about the language items\n \n The compiler currently makes a few assumptions about symbols which are"}, {"sha": "6c71c3f2ce1917af1a8943b0d31735e99d3baa35", "filename": "src/doc/unstable-book/src/library-features/compiler-builtins-lib.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,35 @@\n+# `compiler_builtins_lib`\n+\n+The tracking issue for this feature is: None.\n+\n+------------------------\n+\n+This feature is required to link to the `compiler_builtins` crate which contains\n+\"compiler intrinsics\". Compiler intrinsics are software implementations of basic\n+operations like multiplication of `u64`s. These intrinsics are only required on\n+platforms where these operations don't directly map to a hardware instruction.\n+\n+You should never need to explicitly link to the `compiler_builtins` crate when\n+building \"std\" programs as `compiler_builtins` is already in the dependency\n+graph of `std`. But you may need it when building `no_std` **binary** crates. If\n+you get a *linker* error like:\n+\n+``` text\n+$PWD/src/main.rs:11: undefined reference to `__aeabi_lmul'\n+$PWD/src/main.rs:11: undefined reference to `__aeabi_uldivmod'\n+```\n+\n+That means that you need to link to this crate.\n+\n+When you link to this crate, make sure it only appears once in your crate\n+dependency graph. Also, it doesn't matter where in the dependency graph you\n+place the `compiler_builtins` crate.\n+\n+<!-- NOTE(ignore) doctests don't support `no_std` binaries -->\n+\n+``` rust,ignore\n+#![feature(compiler_builtins_lib)]\n+#![no_std]\n+\n+extern crate compiler_builtins;\n+```"}, {"sha": "ec7a2b6d0e8d92595fe8154b03e0e7b72887e3d8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -1252,12 +1252,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1286,12 +1287,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1323,12 +1325,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples"}, {"sha": "95b27751a6aaf973976cb4b2f69ebf9a03f0b4fd", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -847,7 +847,7 @@ macro_rules! generate_pattern_iterators {\n         internal:\n             $internal_iterator:ident yielding ($iterty:ty);\n \n-        // Kind of delgation - either single ended or double ended\n+        // Kind of delegation - either single ended or double ended\n         delegate $($t:tt)*\n     } => {\n         $(#[$forward_iterator_attribute])*"}, {"sha": "c4ff95b1d6a49dffc151b9a8c516e6218ab7f03b", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -83,7 +83,7 @@ pub enum SearchStep {\n     /// Note that there might be more than one `Reject` between two `Match`es,\n     /// there is no requirement for them to be combined into one.\n     Reject(usize, usize),\n-    /// Expresses that every byte of the haystack has been visted, ending\n+    /// Expresses that every byte of the haystack has been visited, ending\n     /// the iteration.\n     Done\n }\n@@ -101,7 +101,7 @@ pub enum SearchStep {\n /// the haystack. This enables consumers of this trait to\n /// slice the haystack without additional runtime checks.\n pub unsafe trait Searcher<'a> {\n-    /// Getter for the underlaying string to be searched in\n+    /// Getter for the underlying string to be searched in\n     ///\n     /// Will always return the same `&str`\n     fn haystack(&self) -> &'a str;\n@@ -1153,7 +1153,7 @@ impl TwoWaySearcher {\n     // The maximal suffix is a possible critical factorization (u', v') of `arr`.\n     //\n     // Returns `i` where `i` is the starting index of v', from the back;\n-    // returns immedately when a period of `known_period` is reached.\n+    // returns immediately when a period of `known_period` is reached.\n     //\n     // `order_greater` determines if lexical order is `<` or `>`. Both\n     // orders must be computed -- the ordering with the largest `i` gives"}, {"sha": "ec1e5ab1ef8baca57f8776bbebd9343572a87082", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -1 +1 @@\n-Subproject commit 2015cf17a6a2a2280e93d9c57214ba92dbbaf42f\n+Subproject commit ec1e5ab1ef8baca57f8776bbebd9343572a87082"}, {"sha": "4df5f0e64050c79290121b030e6bc8b9afdf1b0d", "filename": "src/librustc/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_LIBDIR_RELATIVE\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_COMPILER_HOST_TRIPLE\");\n+}"}, {"sha": "b52224eb5d7673e614d57c6f3a65b946cd4045c0", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -1708,7 +1708,7 @@ not apply to structs.\n representation of enums isn't strictly defined in Rust, and this attribute\n won't work on enums.\n \n-`#[repr(simd)]` will give a struct consisting of a homogenous series of machine\n+`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n SIMD. This doesn't make much sense for enums since they don't consist of a\n single list of data."}, {"sha": "7f76e1bf770bf26c5549a66aec2a51dc998869f6", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -136,6 +136,10 @@ impl DefIndex {\n     pub fn as_array_index(&self) -> usize {\n         (self.0 & !DEF_INDEX_HI_START.0) as usize\n     }\n+\n+    pub fn from_array_index(i: usize, address_space: DefIndexAddressSpace) -> DefIndex {\n+        DefIndex::new(address_space.start() + i)\n+    }\n }\n \n /// The start of the \"high\" range of DefIndexes."}, {"sha": "91bce64243e3f0ae98f7d175d48374f7bcbb6ada", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 19, "deletions": 66, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -18,7 +18,7 @@ use hir;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n                   CRATE_DEF_INDEX};\n use ich::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -36,7 +36,6 @@ use util::nodemap::NodeMap;\n /// There is one DefPathTable for each crate.\n pub struct DefPathTable {\n     index_to_key: [Vec<DefKey>; 2],\n-    key_to_index: FxHashMap<DefKey, DefIndex>,\n     def_path_hashes: [Vec<DefPathHash>; 2],\n }\n \n@@ -47,7 +46,6 @@ impl Clone for DefPathTable {\n         DefPathTable {\n             index_to_key: [self.index_to_key[0].clone(),\n                            self.index_to_key[1].clone()],\n-            key_to_index: self.key_to_index.clone(),\n             def_path_hashes: [self.def_path_hashes[0].clone(),\n                               self.def_path_hashes[1].clone()],\n         }\n@@ -65,10 +63,9 @@ impl DefPathTable {\n             let index_to_key = &mut self.index_to_key[address_space.index()];\n             let index = DefIndex::new(index_to_key.len() + address_space.start());\n             debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n-            index_to_key.push(key.clone());\n+            index_to_key.push(key);\n             index\n         };\n-        self.key_to_index.insert(key, index);\n         self.def_path_hashes[address_space.index()].push(def_path_hash);\n         debug_assert!(self.def_path_hashes[address_space.index()].len() ==\n                       self.index_to_key[address_space.index()].len());\n@@ -87,47 +84,6 @@ impl DefPathTable {\n                             [index.as_array_index()]\n     }\n \n-    #[inline(always)]\n-    pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n-        self.key_to_index.get(key).cloned()\n-    }\n-\n-    #[inline(always)]\n-    pub fn contains_key(&self, key: &DefKey) -> bool {\n-        self.key_to_index.contains_key(key)\n-    }\n-\n-    pub fn retrace_path(&self,\n-                        path_data: &[DisambiguatedDefPathData])\n-                        -> Option<DefIndex> {\n-        let root_key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n-\n-        let root_index = self.key_to_index\n-                             .get(&root_key)\n-                             .expect(\"no root key?\")\n-                             .clone();\n-\n-        debug!(\"retrace_path: root_index={:?}\", root_index);\n-\n-        let mut index = root_index;\n-        for data in path_data {\n-            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n-            debug!(\"retrace_path: key={:?}\", key);\n-            match self.key_to_index.get(&key) {\n-                Some(&i) => index = i,\n-                None => return None,\n-            }\n-        }\n-\n-        Some(index)\n-    }\n-\n     pub fn add_def_path_hashes_to(&self,\n                                   cnum: CrateNum,\n                                   out: &mut FxHashMap<DefPathHash, DefId>) {\n@@ -149,7 +105,7 @@ impl DefPathTable {\n     }\n \n     pub fn size(&self) -> usize {\n-        self.key_to_index.len()\n+        self.index_to_key.iter().map(|v| v.len()).sum()\n     }\n }\n \n@@ -179,19 +135,8 @@ impl Decodable for DefPathTable {\n         let index_to_key = [index_to_key_lo, index_to_key_hi];\n         let def_path_hashes = [def_path_hashes_lo, def_path_hashes_hi];\n \n-        let mut key_to_index = FxHashMap();\n-\n-        for space in &[DefIndexAddressSpace::Low, DefIndexAddressSpace::High] {\n-            key_to_index.extend(index_to_key[space.index()]\n-                .iter()\n-                .enumerate()\n-                .map(|(index, key)| (key.clone(),\n-                                     DefIndex::new(index + space.start()))))\n-        }\n-\n         Ok(DefPathTable {\n             index_to_key,\n-            key_to_index,\n             def_path_hashes,\n         })\n     }\n@@ -208,6 +153,7 @@ pub struct Definitions {\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n     macro_def_scopes: FxHashMap<Mark, DefId>,\n     expansions: FxHashMap<DefIndex, Mark>,\n+    keys_created: FxHashSet<DefKey>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -224,6 +170,7 @@ impl Clone for Definitions {\n             node_to_hir_id: self.node_to_hir_id.clone(),\n             macro_def_scopes: self.macro_def_scopes.clone(),\n             expansions: self.expansions.clone(),\n+            keys_created: self.keys_created.clone(),\n         }\n     }\n }\n@@ -448,14 +395,14 @@ impl Definitions {\n         Definitions {\n             table: DefPathTable {\n                 index_to_key: [vec![], vec![]],\n-                key_to_index: FxHashMap(),\n                 def_path_hashes: [vec![], vec![]],\n             },\n             node_to_def_index: NodeMap(),\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n             macro_def_scopes: FxHashMap(),\n             expansions: FxHashMap(),\n+            keys_created: FxHashSet(),\n         }\n     }\n \n@@ -478,10 +425,6 @@ impl Definitions {\n         self.table.def_path_hash(index)\n     }\n \n-    pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n-        self.table.def_index_for_def_key(&key)\n-    }\n-\n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this\n@@ -583,9 +526,10 @@ impl Definitions {\n             }\n         };\n \n-        while self.table.contains_key(&key) {\n+        while self.keys_created.contains(&key) {\n             key.disambiguated_data.disambiguator += 1;\n         }\n+        self.keys_created.insert(key.clone());\n \n         let parent_hash = self.table.def_path_hash(parent);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n@@ -710,6 +654,8 @@ macro_rules! define_global_metadata_kind {\n             $($variant),*\n         }\n \n+        const GLOBAL_MD_ADDRESS_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n+\n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {\n                 $({\n@@ -718,7 +664,7 @@ macro_rules! define_global_metadata_kind {\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n                         DefPathData::GlobalMetaData(instance.name()),\n-                        DefIndexAddressSpace::High,\n+                        GLOBAL_MD_ADDRESS_SPACE,\n                         Mark::root()\n                     );\n \n@@ -736,7 +682,14 @@ macro_rules! define_global_metadata_kind {\n                     }\n                 };\n \n-                def_path_table.key_to_index[&def_key]\n+                // These DefKeys are all right after the root,\n+                // so a linear search is fine.\n+                let index = def_path_table.index_to_key[GLOBAL_MD_ADDRESS_SPACE.index()]\n+                                          .iter()\n+                                          .position(|k| *k == def_key)\n+                                          .unwrap();\n+\n+                DefIndex::from_array_index(index, GLOBAL_MD_ADDRESS_SPACE)\n             }\n \n             fn name(&self) -> Symbol {"}, {"sha": "3fdd9c34f46d9f130a94bb7f695cfeb403a6d0d3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -17,7 +17,7 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode, DepKind};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndexAddressSpace};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n@@ -377,10 +377,6 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_path(def_id.index)\n     }\n \n-    pub fn def_index_for_def_key(&self, def_key: DefKey) -> Option<DefIndex> {\n-        self.definitions.def_index_for_def_key(def_key)\n-    }\n-\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\","}, {"sha": "48bddf2f71759bac89f34ca8ef72483b053e2c0e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -25,8 +25,7 @@\n use hir::def;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData,\n-                            DefPathTable};\n+use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n use ich;\n use middle::lang_items;\n@@ -269,10 +268,6 @@ pub trait CrateStore {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n-    fn retrace_path(&self,\n-                    cnum: CrateNum,\n-                    path_data: &[DisambiguatedDefPathData])\n-                    -> Option<DefId>;\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn def_path_hash(&self, def: DefId) -> hir_map::DefPathHash;\n@@ -392,13 +387,6 @@ impl CrateStore for DummyCrateStore {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n-    fn retrace_path(&self,\n-                    cnum: CrateNum,\n-                    path_data: &[DisambiguatedDefPathData])\n-                    -> Option<DefId> {\n-        None\n-    }\n-\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n     fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")"}, {"sha": "46e55102966520d5ddf5afc161df1a619e7aa5dd", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -88,15 +88,15 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // vary across impls\n     let target_substs = match target_node {\n         specialization_graph::Node::Impl(target_impl) => {\n-            // no need to translate if we're targetting the impl we started with\n+            // no need to translate if we're targeting the impl we started with\n             if source_impl == target_impl {\n                 return source_substs;\n             }\n \n             fulfill_implication(infcx, param_env, source_trait_ref, target_impl)\n                 .unwrap_or_else(|_| {\n                     bug!(\"When translating substitutions for specialization, the expected \\\n-                          specializaiton failed to hold\")\n+                          specialization failed to hold\")\n                 })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n@@ -107,7 +107,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n /// Given a selected impl described by `impl_data`, returns the\n-/// definition and substitions for the method with the name `name`\n+/// definition and substitutions for the method with the name `name`\n /// the kind `kind`, and trait method substitutions `substs`, in\n /// that impl, a less specialized impl, or the trait default,\n /// whichever applies.\n@@ -305,7 +305,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by\n     // negated CrateNum (so remote definitions are visited first) and then\n-    // by a flattend version of the DefIndex.\n+    // by a flattened version of the DefIndex.\n     trait_impls.sort_unstable_by_key(|def_id| {\n         (-(def_id.krate.as_u32() as i64),\n          def_id.index.address_space().index(),"}, {"sha": "45ddd4c0ff179ba7420c37e8bfc50b351c05b476", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -18,7 +18,7 @@ use hir::TraitMap;\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n-use hir::map::{DisambiguatedDefPathData, DefPathHash};\n+use hir::map::DefPathHash;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -570,23 +570,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn retrace_path(self,\n-                        krate: CrateNum,\n-                        path_data: &[DisambiguatedDefPathData])\n-                        -> Option<DefId> {\n-        debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n-\n-        if krate == LOCAL_CRATE {\n-            self.hir\n-                .definitions()\n-                .def_path_table()\n-                .retrace_path(path_data)\n-                .map(|def_index| DefId { krate: krate, index: def_index })\n-        } else {\n-            self.sess.cstore.retrace_path(krate, path_data)\n-        }\n-    }\n-\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }"}, {"sha": "16f0872b25ac119f1092831248e85d2587c6031e", "filename": "src/librustc_back/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_back%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_back%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_LINKER\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_AR\");\n+}"}, {"sha": "6e70944ce642f09ba23e8e76964cdeada774883d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -117,11 +117,11 @@ enum NodeState {\n     /// non-ambiguous result.\n     Pending,\n \n-    /// This obligation was selected successfuly, but may or\n+    /// This obligation was selected successfully, but may or\n     /// may not have subobligations.\n     Success,\n \n-    /// This obligation was selected sucessfully, but it has\n+    /// This obligation was selected successfully, but it has\n     /// a pending subobligation.\n     Waiting,\n "}, {"sha": "9844f3b557a1f264d71750066731ee537f54a4e6", "filename": "src/librustc_driver/build.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_driver%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_driver%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VER_DATE\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VER_HASH\");\n+}"}, {"sha": "f18a3f9b9401663d0d7e20c661d65af051e09bb7", "filename": "src/librustc_incremental/build.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_incremental%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_incremental%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+}"}, {"sha": "f18a3f9b9401663d0d7e20c661d65af051e09bb7", "filename": "src/librustc_metadata/build.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_metadata%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_metadata%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+}"}, {"sha": "5b0612ddab6060c71ace37da58bf500bf22dd059", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -22,7 +22,7 @@ use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData, DefPathHash};\n+use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n@@ -307,16 +307,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).is_no_builtins(&self.dep_graph)\n     }\n \n-    fn retrace_path(&self,\n-                    cnum: CrateNum,\n-                    path: &[DisambiguatedDefPathData])\n-                    -> Option<DefId> {\n-        let cdata = self.get_crate_data(cnum);\n-        cdata.def_path_table\n-             .retrace_path(&path)\n-             .map(|index| DefId { krate: cnum, index: index })\n-    }\n-\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to."}, {"sha": "648c376de1cdb583dcdbf909a06e5a0fb62f08b2", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     /// NOTE: lvalues behind references *do not* get a move path, which is\n     /// problematic for borrowck.\n     ///\n-    /// Maybe we should have seperate \"borrowck\" and \"moveck\" modes.\n+    /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>)\n                      -> Result<MovePathIndex, MovePathError>\n     {"}, {"sha": "144b484d7e819ee020c4095e2ff7e81be2c689dd", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -238,7 +238,7 @@ impl Uniform {\n \n pub trait LayoutExt<'tcx> {\n     fn is_aggregate(&self) -> bool;\n-    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n+    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n }\n \n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n@@ -258,7 +258,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n+    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n         match *self.layout {\n             // The primitives for this algorithm.\n             Layout::Scalar { value, .. } |\n@@ -291,7 +291,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n \n             Layout::Array { count, .. } => {\n                 if count > 0 {\n-                    self.field(ccx, 0).homogenous_aggregate(ccx)\n+                    self.field(ccx, 0).homogeneous_aggregate(ccx)\n                 } else {\n                     None\n                 }\n@@ -307,8 +307,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                     }\n \n                     let field = self.field(ccx, i);\n-                    match (result, field.homogenous_aggregate(ccx)) {\n-                        // The field itself must be a homogenous aggregate.\n+                    match (result, field.homogeneous_aggregate(ccx)) {\n+                        // The field itself must be a homogeneous aggregate.\n                         (_, None) => return None,\n                         // If this is the first field, record the unit.\n                         (None, Some(unit)) => {\n@@ -344,8 +344,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n \n                 for i in 0..self.field_count() {\n                     let field = self.field(ccx, i);\n-                    match (result, field.homogenous_aggregate(ccx)) {\n-                        // The field itself must be a homogenous aggregate.\n+                    match (result, field.homogeneous_aggregate(ccx)) {\n+                        // The field itself must be a homogeneous aggregate.\n                         (_, None) => return None,\n                         // If this is the first field, record the unit.\n                         (None, Some(unit)) => {\n@@ -830,7 +830,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n                 let size = arg.layout.size(ccx);\n \n-                if let Some(unit) = arg.layout.homogenous_aggregate(ccx) {\n+                if let Some(unit) = arg.layout.homogeneous_aggregate(ccx) {\n                     // Replace newtypes with their inner-most type.\n                     if unit.size == size {\n                         // Needs a cast as we've unpacked a newtype."}, {"sha": "97accbb4b8fe631b6ef2a07643bff9e1962bedb4", "filename": "src/librustc_trans/build.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_PREFIX\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_LLVM_ROOT\");\n+}"}, {"sha": "bf842e6358f87860a5835bbfd11865419e750779", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -11,9 +11,9 @@\n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n \n-fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size(ccx);\n \n         // Ensure we have at most four uniquely addressable members.\n@@ -43,7 +43,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n         ret.cast_to(ccx, uniform);\n         return;\n     }\n@@ -74,7 +74,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n         arg.cast_to(ccx, uniform);\n         return;\n     }"}, {"sha": "6fcd3ed581d27c85f2914cf200fce0c85eac108f", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -18,7 +18,7 @@ use context::CrateContext;\n \n fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n-        if let Some(unit) = ret.layout.homogenous_aggregate(ccx) {\n+        if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n             let size = ret.layout.size(ccx);\n             if unit.size == size {\n                 ret.cast_to(ccx, Uniform {"}, {"sha": "5c695387236fae4117d7d10562ddfc55ee28ea8e", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -15,9 +15,9 @@\n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n \n-fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size(ccx);\n \n         // Ensure we have at most eight uniquely addressable members.\n@@ -53,7 +53,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         ret.make_indirect(ccx);\n     }\n \n-    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n         ret.cast_to(ccx, uniform);\n         return;\n     }\n@@ -86,7 +86,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n \n-    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n         arg.cast_to(ccx, uniform);\n         return;\n     }"}, {"sha": "8383007550e1e7ef987f2b714bd8866c158a583d", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -13,9 +13,9 @@\n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n \n-fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size(ccx);\n \n         // Ensure we have at most eight uniquely addressable members.\n@@ -46,7 +46,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n \n-    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n         ret.cast_to(ccx, uniform);\n         return;\n     }\n@@ -80,7 +80,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n \n-    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n         arg.cast_to(ccx, uniform);\n         return;\n     }"}, {"sha": "8b024b8c97fa0940cc9ede65456dd3dab0ba74d8", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -74,7 +74,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if arg.is_ignore() || arg.is_indirect() { continue; }\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogenous_aggregate(ccx).unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n             let size = arg.layout.size(ccx);\n             assert_eq!(unit.size, size);\n             if unit.kind == RegKind::Float {"}, {"sha": "904cfb2acd74130da68b3043ce97aad838de2d9e", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -251,7 +251,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                                 exported_symbols,\n                                                                 trans_items);\n \n-    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n@@ -261,7 +261,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n-    // In the next step, we use the inlining map to determine which addtional\n+    // In the next step, we use the inlining map to determine which additional\n     // translation items have to go into each codegen unit. These additional\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline]."}, {"sha": "84ab88c4fdc08fe1cb97b7523eae166f628f5810", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -1065,6 +1065,7 @@\n         block(\"macro\", \"Macros\");\n         block(\"struct\", \"Structs\");\n         block(\"enum\", \"Enums\");\n+        block(\"union\", \"Unions\");\n         block(\"constant\", \"Constants\");\n         block(\"static\", \"Statics\");\n         block(\"trait\", \"Traits\");"}, {"sha": "6d67bbc06cc1b1a84bc8d3a0a478c1d5caacef1a", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -729,15 +729,15 @@ pub trait SpecializationError {\n     /// `S` is the encoder/decoder state type,\n     /// `T` is the type being encoded/decoded, and\n     /// the arguments are the names of the trait\n-    /// and method that should've been overriden.\n+    /// and method that should've been overridden.\n     fn not_found<S, T: ?Sized>(trait_name: &'static str,\n                                method_name: &'static str) -> Self;\n }\n \n impl<E> SpecializationError for E {\n     default fn not_found<S, T: ?Sized>(trait_name: &'static str,\n                                        method_name: &'static str) -> E {\n-        panic!(\"missing specializaiton: `<{} as {}<{}>>::{}` not overriden\",\n+        panic!(\"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n                unsafe { intrinsics::type_name::<S>() },\n                trait_name,\n                unsafe { intrinsics::type_name::<T>() },"}, {"sha": "12241b3f88187f17ba2c8653057c21faac58013e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -203,7 +203,7 @@ const DISPLACEMENT_THRESHOLD: usize = 128;\n // so we round that up to 128.\n //\n // At a load factor of \u03b1, the odds of finding the target bucket after exactly n\n-// unsuccesful probes[1] are\n+// unsuccessful probes[1] are\n //\n // Pr_\u03b1{displacement = n} =\n // (1 - \u03b1) / \u03b1 * \u2211_{k\u22651} e^(-k\u03b1) * (k\u03b1)^(k+n) / (k + n)! * (1 - k\u03b1 / (k + n + 1))"}, {"sha": "d765dd227be695b4cccaa96a466fb5668b0200ed", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -37,7 +37,7 @@ use memchr;\n /// use std::fs::File;\n ///\n /// # fn foo() -> std::io::Result<()> {\n-/// let mut f = File::open(\"log.txt\")?;\n+/// let f = File::open(\"log.txt\")?;\n /// let mut reader = BufReader::new(f);\n ///\n /// let mut line = String::new();\n@@ -64,8 +64,8 @@ impl<R: Read> BufReader<R> {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f = File::open(\"log.txt\")?;\n-    /// let mut reader = BufReader::new(f);\n+    /// let f = File::open(\"log.txt\")?;\n+    /// let reader = BufReader::new(f);\n     /// # Ok(())\n     /// # }\n     /// ```\n@@ -85,8 +85,8 @@ impl<R: Read> BufReader<R> {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f = File::open(\"log.txt\")?;\n-    /// let mut reader = BufReader::with_capacity(10, f);\n+    /// let f = File::open(\"log.txt\")?;\n+    /// let reader = BufReader::with_capacity(10, f);\n     /// # Ok(())\n     /// # }\n     /// ```\n@@ -116,8 +116,8 @@ impl<R: Read> BufReader<R> {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f1 = File::open(\"log.txt\")?;\n-    /// let mut reader = BufReader::new(f1);\n+    /// let f1 = File::open(\"log.txt\")?;\n+    /// let reader = BufReader::new(f1);\n     ///\n     /// let f2 = reader.get_ref();\n     /// # Ok(())\n@@ -137,7 +137,7 @@ impl<R: Read> BufReader<R> {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f1 = File::open(\"log.txt\")?;\n+    /// let f1 = File::open(\"log.txt\")?;\n     /// let mut reader = BufReader::new(f1);\n     ///\n     /// let f2 = reader.get_mut();\n@@ -158,8 +158,8 @@ impl<R: Read> BufReader<R> {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f1 = File::open(\"log.txt\")?;\n-    /// let mut reader = BufReader::new(f1);\n+    /// let f1 = File::open(\"log.txt\")?;\n+    /// let reader = BufReader::new(f1);\n     ///\n     /// let f2 = reader.into_inner();\n     /// # Ok(())"}, {"sha": "619d079542142100b5d1dc6ab39ea99865c8d1ea", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -476,7 +476,7 @@ impl<'a> Hash for PrefixComponent<'a> {\n \n /// A single component of a path.\n ///\n-/// A `Component` roughtly corresponds to a substring between path separators\n+/// A `Component` roughly corresponds to a substring between path separators\n /// (`/` or `\\`).\n ///\n /// This `enum` is created by iterating over [`Components`], which in turn is\n@@ -571,7 +571,7 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n     }\n }\n \n-/// An interator over the [`Component`]s of a [`Path`].\n+/// An iterator over the [`Component`]s of a [`Path`].\n ///\n /// This `struct` is created by the [`components`] method on [`Path`].\n /// See its documentation for more.\n@@ -2019,7 +2019,7 @@ impl Path {\n     /// * Repeated separators are ignored, so `a/b` and `a//b` both have\n     ///   `a` and `b` as components.\n     ///\n-    /// * Occurences of `.` are normalized away, except if they are at the\n+    /// * Occurrences of `.` are normalized away, except if they are at the\n     ///   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n     ///   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n     ///   an additional [`CurDir`] component."}, {"sha": "31809e382398fdbc5e3027cb0dbcd95df8beb51d", "filename": "src/libstd/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -799,8 +799,8 @@ impl From<fs::File> for Stdio {\n pub struct ExitStatus(imp::ExitStatus);\n \n impl ExitStatus {\n-    /// Was termination successful? Signal termination not considered a success,\n-    /// and success is defined as a zero exit status.\n+    /// Was termination successful? Signal termination is not considered a\n+    /// success, and success is defined as a zero exit status.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c35676f2709ccf2831838e3791c21d34d5ffe296", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -190,7 +190,7 @@ pub use self::local::{LocalKey, LocalKeyState, AccessError};\n /// - [`name`]: allows to give a name to the thread which is currently\n ///   only used in `panic` messages.\n /// - [`stack_size`]: specifies the desired stack size. Note that this can\n-///   be overriden by the OS.\n+///   be overridden by the OS.\n ///\n /// If the [`stack_size`] field is not specified, the stack size\n /// will be the `RUST_MIN_STACK` environment variable. If it is\n@@ -529,7 +529,7 @@ pub fn current() -> Thread {\n /// Thus the pattern of `yield`ing after a failed poll is rather common when\n /// implementing low-level shared resources or synchronization primitives.\n ///\n-/// However programmers will usualy prefer to use, [`channel`]s, [`Condvar`]s,\n+/// However programmers will usually prefer to use, [`channel`]s, [`Condvar`]s,\n /// [`Mutex`]es or [`join`] for their synchronisation routines, as they avoid\n /// thinking about thread schedulling.\n ///\n@@ -770,7 +770,7 @@ pub fn park_timeout_ms(ms: u32) {\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `dur` long.\n ///\n-/// See the [park dococumentation][park] for more details.\n+/// See the [park documentation][park] for more details.\n ///\n /// # Platform behavior\n ///\n@@ -891,7 +891,7 @@ struct Inner {\n /// The [`thread::current`] function is available even for threads not spawned\n /// by the APIs of this module.\n ///\n-/// There is usualy no need to create a `Thread` struct yourself, one\n+/// There is usually no need to create a `Thread` struct yourself, one\n /// should instead use a function like `spawn` to create new threads, see the\n /// docs of [`Builder`] and [`spawn`] for more details.\n ///"}, {"sha": "d39340c332690cd89078d33fb0314e1b632e2f8b", "filename": "src/libsyntax/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibsyntax%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibsyntax%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fbuild.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE_CHANNEL\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_DISABLE_UNSTABLE_FEATURES\");\n+}"}, {"sha": "820adc60999a45ff84d77b34920ac3a6ae9c0eb5", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -312,7 +312,7 @@ impl MultiSpan {\n         &self.primary_spans\n     }\n \n-    /// Replaces all occurances of one Span with another. Used to move Spans in areas that don't\n+    /// Replaces all occurrences of one Span with another. Used to move Spans in areas that don't\n     /// display well (like std macros). Returns true if replacements occurred.\n     pub fn replace(&mut self, before: Span, after: Span) -> bool {\n         let mut replacements_occurred = false;"}, {"sha": "6c3bc45d34aa49da123af35f8f69dc70b3fc2ba3", "filename": "src/test/parse-fail/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Fparse-fail%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Fparse-fail%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdefault.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// Test successful and unsucessful parsing of the `default` contextual keyword\n+// Test successful and unsuccessful parsing of the `default` contextual keyword\n \n trait Foo {\n     fn foo<T: Default>() -> T;"}, {"sha": "1236acf35112181ef840f2f65ee4199a19ec3b4d", "filename": "src/test/run-pass/backtrace-debuginfo-aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -16,7 +16,7 @@ pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n }\n \n // LLVM does not yet output the required debug info to support showing inlined\n-// function calls in backtraces when targetting MSVC, so disable inlining in\n+// function calls in backtraces when targeting MSVC, so disable inlining in\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]"}, {"sha": "b2ab25c44b82a4ece3c97ef597e11ba44037e5ce", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -10,7 +10,7 @@\n \n // We disable tail merging here because it can't preserve debuginfo and thus\n // potentially breaks the backtraces. Also, subtle changes can decide whether\n-// tail merging suceeds, so the test might work today but fail tomorrow due to a\n+// tail merging succeeds, so the test might work today but fail tomorrow due to a\n // seemingly completely unrelated change.\n // Unfortunately, LLVM has no \"disable\" option for this, so we have to set\n // \"enable\" to 0 instead.\n@@ -88,7 +88,7 @@ fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n }\n \n // LLVM does not yet output the required debug info to support showing inlined\n-// function calls in backtraces when targetting MSVC, so disable inlining in\n+// function calls in backtraces when targeting MSVC, so disable inlining in\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]"}, {"sha": "a2a264490a141848c2289953db12b9d3ef658f9e", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598eddf4f785df12e79fba5a996f153dc6fdb7e0/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=598eddf4f785df12e79fba5a996f153dc6fdb7e0", "patch": "@@ -247,6 +247,18 @@ pub fn collect_lang_features(base_src_path: &Path) -> Features {\n \n pub fn collect_lib_features(base_src_path: &Path) -> Features {\n     let mut lib_features = Features::new();\n+\n+    // This library feature is defined in the `compiler_builtins` crate, which\n+    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n+    // `tidy`, because we need to filter out its (submodule) directory. Manually\n+    // add it to the set of known library features so we can still generate docs.\n+    lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n+        level: Status::Unstable,\n+        since: \"\".to_owned(),\n+        has_gate_test: false,\n+        tracking_issue: None,\n+    });\n+\n     map_lib_features(base_src_path,\n                      &mut |res, _, _| {\n         match res {"}]}