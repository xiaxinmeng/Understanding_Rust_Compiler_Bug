{"sha": "594ea74bf0f735c7cd81a54409ab4d9005e07110", "node_id": "C_kwDOAAsO6NoAKDU5NGVhNzRiZjBmNzM1YzdjZDgxYTU0NDA5YWI0ZDkwMDVlMDcxMTA", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T20:06:47Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T20:10:19Z"}, "message": "Refactor Sharded out of non-parallel active query map", "tree": {"sha": "d44392ed53b570d8b50d05370d170198d149d989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44392ed53b570d8b50d05370d170198d149d989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594ea74bf0f735c7cd81a54409ab4d9005e07110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594ea74bf0f735c7cd81a54409ab4d9005e07110", "html_url": "https://github.com/rust-lang/rust/commit/594ea74bf0f735c7cd81a54409ab4d9005e07110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594ea74bf0f735c7cd81a54409ab4d9005e07110/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41f124c8248f360404b77cfa6a789de2fe90c1fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f124c8248f360404b77cfa6a789de2fe90c1fc", "html_url": "https://github.com/rust-lang/rust/commit/41f124c8248f360404b77cfa6a789de2fe90c1fc"}], "stats": {"total": 78, "additions": 51, "deletions": 27}, "files": [{"sha": "615309eadc98a314debc65809c540d4a912e2a0f", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/594ea74bf0f735c7cd81a54409ab4d9005e07110/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594ea74bf0f735c7cd81a54409ab4d9005e07110/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=594ea74bf0f735c7cd81a54409ab4d9005e07110", "patch": "@@ -8,10 +8,11 @@ use crate::query::config::{QueryDescription, QueryVtable};\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHasher};\n+use rustc_data_structures::fx::FxHashMap;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::profiling::TimingGuard;\n-use rustc_data_structures::sharded::{get_shard_index_by_hash, Sharded};\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{DiagnosticBuilder, FatalError};\n@@ -20,21 +21,15 @@ use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::mem;\n use std::ptr;\n \n-// We compute the key's hash once and then use it for both the\n-// shard lookup and the hashmap lookup. This relies on the fact\n-// that both of them use `FxHasher`.\n-fn hash_for_shard<K: Hash>(key: &K) -> u64 {\n-    let mut hasher = FxHasher::default();\n-    key.hash(&mut hasher);\n-    hasher.finish()\n-}\n-\n pub struct QueryState<K> {\n-    shards: Sharded<FxHashMap<K, QueryResult>>,\n+    #[cfg(parallel_compiler)]\n+    active: Sharded<FxHashMap<K, QueryResult>>,\n+    #[cfg(not(parallel_compiler))]\n+    active: Lock<FxHashMap<K, QueryResult>>,\n }\n \n /// Indicates the state of a query for a given key in a query map.\n@@ -52,8 +47,15 @@ where\n     K: Eq + Hash + Clone + Debug,\n {\n     pub fn all_inactive(&self) -> bool {\n-        let shards = self.shards.lock_shards();\n-        shards.iter().all(|shard| shard.is_empty())\n+        #[cfg(parallel_compiler)]\n+        {\n+            let shards = self.active.lock_shards();\n+            shards.iter().all(|shard| shard.is_empty())\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            self.active.lock().is_empty()\n+        }\n     }\n \n     pub fn try_collect_active_jobs<CTX: Copy>(\n@@ -62,11 +64,27 @@ where\n         make_query: fn(CTX, K) -> QueryStackFrame,\n         jobs: &mut QueryMap,\n     ) -> Option<()> {\n-        // We use try_lock_shards here since we are called from the\n-        // deadlock handler, and this shouldn't be locked.\n-        let shards = self.shards.try_lock_shards()?;\n-        for shard in shards.iter() {\n-            for (k, v) in shard.iter() {\n+        #[cfg(parallel_compiler)]\n+        {\n+            // We use try_lock_shards here since we are called from the\n+            // deadlock handler, and this shouldn't be locked.\n+            let shards = self.active.try_lock_shards()?;\n+            for shard in shards.iter() {\n+                for (k, v) in shard.iter() {\n+                    if let QueryResult::Started(ref job) = *v {\n+                        let query = make_query(tcx, k.clone());\n+                        jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n+                    }\n+                }\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            // We use try_lock here since we are called from the\n+            // deadlock handler, and this shouldn't be locked.\n+            // (FIXME: Is this relevant for non-parallel compilers? It doesn't\n+            // really hurt much.)\n+            for (k, v) in self.active.try_lock()?.iter() {\n                 if let QueryResult::Started(ref job) = *v {\n                     let query = make_query(tcx, k.clone());\n                     jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n@@ -80,7 +98,7 @@ where\n \n impl<K> Default for QueryState<K> {\n     fn default() -> QueryState<K> {\n-        QueryState { shards: Default::default() }\n+        QueryState { active: Default::default() }\n     }\n }\n \n@@ -135,7 +153,10 @@ where\n     where\n         CTX: QueryContext,\n     {\n-        let mut state_lock = state.shards.get_shard_by_value(&key).lock();\n+        #[cfg(parallel_compiler)]\n+        let mut state_lock = state.active.get_shard_by_value(&key).lock();\n+        #[cfg(not(parallel_compiler))]\n+        let mut state_lock = state.active.lock();\n         let lock = &mut *state_lock;\n \n         match lock.entry(key) {\n@@ -206,10 +227,11 @@ where\n         mem::forget(self);\n \n         let (job, result) = {\n-            let key_hash = hash_for_shard(&key);\n-            let shard = get_shard_index_by_hash(key_hash);\n             let job = {\n-                let mut lock = state.shards.get_shard_by_index(shard).lock();\n+                #[cfg(parallel_compiler)]\n+                let mut lock = state.active.get_shard_by_value(&key).lock();\n+                #[cfg(not(parallel_compiler))]\n+                let mut lock = state.active.lock();\n                 match lock.remove(&key).unwrap() {\n                     QueryResult::Started(job) => job,\n                     QueryResult::Poisoned => panic!(),\n@@ -233,9 +255,11 @@ where\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic.\n         let state = self.state;\n-        let shard = state.shards.get_shard_by_value(&self.key);\n         let job = {\n-            let mut shard = shard.lock();\n+            #[cfg(parallel_compiler)]\n+            let mut shard = state.active.get_shard_by_value(&self.key).lock();\n+            #[cfg(not(parallel_compiler))]\n+            let mut shard = state.active.lock();\n             let job = match shard.remove(&self.key).unwrap() {\n                 QueryResult::Started(job) => job,\n                 QueryResult::Poisoned => panic!(),"}]}