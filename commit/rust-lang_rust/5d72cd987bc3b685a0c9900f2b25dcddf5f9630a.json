{"sha": "5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "node_id": "C_kwDOAAsO6NoAKDVkNzJjZDk4N2JjM2I2ODVhMGM5OTAwZjJiMjVkY2RkZjVmOTYzMGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-18T20:38:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-18T20:38:37Z"}, "message": "Auto merge of #2024 - saethlin:better-local-check, r=RalfJung\n\nConsider the cargo workspace when checking if a frame is local\n\n`DefId::is_local` returns a result which is technically correct, but doesn't match the user's intuition when running integration tests or doctests. This incorporates the workspace crates mentioned in `cargo metadata` into the check for whether a frame is local to match user intuition.\n\nFor example, here is the backtrace you get from `MIRIFLAGS=-Zmiri-tag-raw-pointers cargo miri test` in `bytes` 1.1.0:\n```\n   --> /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/slice/raw.rs:131:14\n    |\n131 |     unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to reborrow for Unique at alloc67158, but parent tag <untagged> does not have an appropriate item in the borrow stack\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n\n    = note: inside `std::slice::from_raw_parts_mut::<u8>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/slice/raw.rs:131:14\n    = note: inside `bytes::bytes::rebuild_boxed_slice` at /tmp/bytes-1.1.0/src/bytes.rs:938:19\n    = note: inside closure at /tmp/bytes-1.1.0/src/bytes.rs:904:18\n    = note: inside `<std::sync::atomic::AtomicPtr<()> as bytes::loom::sync::atomic::AtomicMut<()>>::with_mut::<[closure@bytes::bytes::promotable_even_drop::{closure#0}], ()>` at /tmp/bytes-1.1.0/src/loom.rs:17:17\n    = note: inside `bytes::bytes::promotable_even_drop` at /tmp/bytes-1.1.0/src/bytes.rs:895:5\n    = note: inside `<bytes::Bytes as std::ops::Drop>::drop` at /tmp/bytes-1.1.0/src/bytes.rs:515:18\n    = note: inside `std::ptr::drop_in_place::<bytes::Bytes> - shim(Some(bytes::Bytes))` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:188:1\nnote: inside `copy_to_bytes_less` at tests/test_buf.rs:112:1\n   --> tests/test_buf.rs:112:1\n    |\n112 | }\n    | ^\nnote: inside closure at tests/test_buf.rs:106:1\n   --> tests/test_buf.rs:106:1\n    |\n105 |   #[test]\n    |   ------- in this procedural macro expansion\n106 | / fn copy_to_bytes_less() {\n107 | |     let mut buf = &b\"hello world\"[..];\n108 | |\n109 | |     let bytes = buf.copy_to_bytes(5);\n110 | |     assert_eq!(bytes, &b\"hello\"[..]);\n111 | |     assert_eq!(buf, &b\" world\"[..])\n112 | | }\n    | |_^\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\nWe get these because the integration tests are occurring in a crate called `test`, not the actual `bytes` crate. With this PR, we get this:\n```\n    = note: inside `std::slice::from_raw_parts_mut::<u8>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/slice/raw.rs:131:14\nnote: inside `bytes::bytes::rebuild_boxed_slice` at /tmp/bytes-1.1.0/src/bytes.rs:938:19\n   --> /tmp/bytes-1.1.0/src/bytes.rs:938:19\n    |\n938 |     Box::from_raw(slice::from_raw_parts_mut(buf, cap))\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure at /tmp/bytes-1.1.0/src/bytes.rs:904:18\n   --> /tmp/bytes-1.1.0/src/bytes.rs:904:18\n    |\n904 |             drop(rebuild_boxed_slice(buf, ptr, len));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `<std::sync::atomic::AtomicPtr<()> as bytes::loom::sync::atomic::AtomicMut<()>>::with_mut::<[closure@bytes::bytes::promotable_even_drop::{closure#0}], ()>` at /tmp/bytes-1.1.0/src/loom.rs:17:17\n   --> /tmp/bytes-1.1.0/src/loom.rs:17:17\n    |\n17  |                 f(self.get_mut())\n    |                 ^^^^^^^^^^^^^^^^^\nnote: inside `bytes::bytes::promotable_even_drop` at /tmp/bytes-1.1.0/src/bytes.rs:895:5\n   --> /tmp/bytes-1.1.0/src/bytes.rs:895:5\n    |\n895 | /     data.with_mut(|shared| {\n896 | |         let shared = *shared;\n897 | |         let kind = shared as usize & KIND_MASK;\n898 | |\n...   |\n905 | |         }\n906 | |     });\n    | |______^\nnote: inside `<bytes::Bytes as std::ops::Drop>::drop` at /tmp/bytes-1.1.0/src/bytes.rs:515:18\n   --> /tmp/bytes-1.1.0/src/bytes.rs:515:18\n    |\n515 |         unsafe { (self.vtable.drop)(&mut self.data, self.ptr, self.len) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: inside `std::ptr::drop_in_place::<bytes::Bytes> - shim(Some(bytes::Bytes))` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:188:1\nnote: inside `copy_to_bytes_less` at tests/test_buf.rs:112:1\n   --> tests/test_buf.rs:112:1\n    |\n112 | }\n    | ^\nnote: inside closure at tests/test_buf.rs:106:1\n   --> tests/test_buf.rs:106:1\n    |\n105 |   #[test]\n    |   ------- in this procedural macro expansion\n106 | / fn copy_to_bytes_less() {\n107 | |     let mut buf = &b\"hello world\"[..];\n108 | |\n109 | |     let bytes = buf.copy_to_bytes(5);\n110 | |     assert_eq!(bytes, &b\"hello\"[..]);\n111 | |     assert_eq!(buf, &b\" world\"[..])\n112 | | }\n    | |_^\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n```\n\nNote that this kind of inflation is rather rare to see. Most backtraces change not at all or only a tiny bit.\n\nI originally implemented this to support another improvement to Miri diagnostics, but I think this is hairy enough to deserve its own PR, if somewhat poorly-motivated.", "tree": {"sha": "57e653112c1a4dc2599772fa5190336c53289f8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57e653112c1a4dc2599772fa5190336c53289f8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "html_url": "https://github.com/rust-lang/rust/commit/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "html_url": "https://github.com/rust-lang/rust/commit/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83"}, {"sha": "65125df1cd31b467dba2a71c03d6c4343e2a05b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/65125df1cd31b467dba2a71c03d6c4343e2a05b8", "html_url": "https://github.com/rust-lang/rust/commit/65125df1cd31b467dba2a71c03d6c4343e2a05b8"}], "stats": {"total": 103, "additions": 79, "deletions": 24}, "files": [{"sha": "fb999d85a192c4af60d0767d2f59837ee4d70ec5", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "patch": "@@ -375,9 +375,12 @@ binaries, and as such worth documenting:\n   directory after loading all the source files, but before commencing\n   interpretation. This is useful if the interpreted program wants a different\n   working directory at run-time than at build-time.\n+* `MIRI_LOCAL_CRATES` is set by `cargo-miri` to tell the Miri driver which\n+  crates should be given special treatment in diagnostics, in addition to the\n+  crate currently being compiled.\n * `MIRI_VERBOSE` when set to any value tells the various `cargo-miri` phases to\n   perform verbose logging.\n-  \n+\n [testing-miri]: CONTRIBUTING.md#testing-the-miri-driver\n \n ## Miri `extern` functions"}, {"sha": "373c63647c35aed8401eb12746efd45a63fdf68d", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "patch": "@@ -482,12 +482,13 @@ path = \"lib.rs\"\n     }\n }\n \n-/// Detect the target directory by calling `cargo metadata`.\n-fn detect_target_dir() -> PathBuf {\n-    #[derive(Deserialize)]\n-    struct Metadata {\n-        target_directory: PathBuf,\n-    }\n+#[derive(Deserialize)]\n+struct Metadata {\n+    target_directory: PathBuf,\n+    workspace_members: Vec<String>,\n+}\n+\n+fn get_cargo_metadata() -> Metadata {\n     let mut cmd = cargo();\n     // `-Zunstable-options` is required by `--config`.\n     cmd.args([\"metadata\", \"--no-deps\", \"--format-version=1\", \"-Zunstable-options\"]);\n@@ -514,9 +515,25 @@ fn detect_target_dir() -> PathBuf {\n     if !status.success() {\n         std::process::exit(status.code().unwrap_or(-1));\n     }\n-    metadata\n-        .unwrap_or_else(|e| show_error(format!(\"invalid `cargo metadata` output: {}\", e)))\n-        .target_directory\n+    metadata.unwrap_or_else(|e| show_error(format!(\"invalid `cargo metadata` output: {}\", e)))\n+}\n+\n+/// Pulls all the crates in this workspace from the cargo metadata.\n+/// Workspace members are emitted like \"miri 0.1.0 (path+file:///path/to/miri)\"\n+/// Additionally, somewhere between cargo metadata and TyCtxt, '-' gets replaced with '_' so we\n+/// make that same transformation here.\n+fn local_crates(metadata: &Metadata) -> String {\n+    assert!(metadata.workspace_members.len() > 0);\n+    let mut local_crates = String::new();\n+    for member in &metadata.workspace_members {\n+        let name = member.split(\" \").nth(0).unwrap();\n+        let name = name.replace(\"-\", \"_\");\n+        local_crates.push_str(&name);\n+        local_crates.push(',');\n+    }\n+    local_crates.pop(); // Remove the trailing ','\n+\n+    local_crates\n }\n \n fn phase_cargo_miri(mut args: env::Args) {\n@@ -595,8 +612,10 @@ fn phase_cargo_miri(mut args: env::Args) {\n         }\n     }\n \n+    let metadata = get_cargo_metadata();\n+\n     // Detect the target directory if it's not specified via `--target-dir`.\n-    let target_dir = target_dir.get_or_insert_with(detect_target_dir);\n+    let target_dir = target_dir.get_or_insert_with(|| metadata.target_directory.clone());\n \n     // Set `--target-dir` to `miri` inside the original target directory.\n     target_dir.push(\"miri\");\n@@ -628,6 +647,8 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n+    cmd.env(\"MIRI_LOCAL_CRATES\", local_crates(&metadata));\n+\n     // Run cargo.\n     if verbose {\n         eprintln!(\"[cargo-miri miri] RUSTC_WRAPPER={:?}\", cargo_miri_path);"}, {"sha": "0815d73d9bcb791bfde9c6d7b894abdda481bc02", "filename": "src/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "patch": "@@ -4,7 +4,7 @@ use std::num::NonZeroU64;\n \n use log::trace;\n \n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::stacked_borrows::{AccessKind, SbTag};\n@@ -94,7 +94,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n             // Only prune frames if there is at least one local frame. This check ensures that if\n             // we get a backtrace that never makes it to the user code because it has detected a\n             // bug in the Rust runtime, we don't prune away every frame.\n-            let has_local_frame = stacktrace.iter().any(|frame| frame.instance.def_id().is_local());\n+            let has_local_frame = stacktrace.iter().any(|frame| ecx.machine.is_local(frame));\n             if has_local_frame {\n                 // This is part of the logic that `std` uses to select the relevant part of a\n                 // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n@@ -115,7 +115,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                 // This len check ensures that we don't somehow remove every frame, as doing so breaks\n                 // the primary error message.\n                 while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n+                    && stacktrace.last().map_or(false, |frame| !ecx.machine.is_local(frame))\n                 {\n                     stacktrace.pop();\n                 }\n@@ -218,7 +218,7 @@ pub fn report_error<'tcx, 'mir>(\n     e.print_backtrace();\n     msg.insert(0, e.to_string());\n     report_msg(\n-        *ecx.tcx,\n+        ecx,\n         DiagLevel::Error,\n         &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n         msg,\n@@ -264,19 +264,20 @@ pub fn report_error<'tcx, 'mir>(\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn report_msg<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,\n     mut helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n+    let sess = ecx.tcx.sess;\n     let mut err = match diag_level {\n-        DiagLevel::Error => tcx.sess.struct_span_err(span, title).forget_guarantee(),\n-        DiagLevel::Warning => tcx.sess.struct_span_warn(span, title),\n-        DiagLevel::Note => tcx.sess.diagnostic().span_note_diag(span, title),\n+        DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n+        DiagLevel::Warning => sess.struct_span_warn(span, title),\n+        DiagLevel::Note => sess.diagnostic().span_note_diag(span, title),\n     };\n \n     // Show main message.\n@@ -306,7 +307,7 @@ fn report_msg<'tcx>(\n     }\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n-        let is_local = frame_info.instance.def_id().is_local();\n+        let is_local = ecx.machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n             err.span_note(frame_info.span, &frame_info.to_string());\n@@ -426,7 +427,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     _ => (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n-                report_msg(*this.tcx, diag_level, title, vec![msg], vec![], &stacktrace);\n+                report_msg(this, diag_level, title, vec![msg], vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "3ffb983aa69ecff2390133bf42946a99baa79a60", "filename": "src/helpers.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{\n     layout::{LayoutOf, TyAndLayout},\n     List, TyCtxt,\n };\n-use rustc_span::Symbol;\n+use rustc_span::{def_id::CrateNum, Symbol};\n use rustc_target::abi::{Align, FieldsShape, Size, Variants};\n use rustc_target::spec::abi::Abi;\n \n@@ -775,3 +775,22 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n         name,\n     )))\n }\n+\n+/// Retrieve the list of local crates that should have been passed by cargo-miri in\n+/// MIRI_LOCAL_CRATES and turn them into `CrateNum`s.\n+pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n+    // Convert the local crate names from the passed-in config into CrateNums so that they can\n+    // be looked up quickly during execution\n+    let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n+        .map(|crates| crates.split(\",\").map(|krate| krate.to_string()).collect::<Vec<_>>())\n+        .unwrap_or_default();\n+    let mut local_crates = Vec::new();\n+    for &crate_num in tcx.crates(()) {\n+        let name = tcx.crate_name(crate_num);\n+        let name = name.as_str();\n+        if local_crate_names.iter().any(|local_name| local_name == name) {\n+            local_crates.push(crate_num);\n+        }\n+    }\n+    local_crates\n+}"}, {"sha": "2cf7cd0fae0e26f5a9d0ad37ed6422b7d69c4f72", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72cd987bc3b685a0c9900f2b25dcddf5f9630a/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=5d72cd987bc3b685a0c9900f2b25dcddf5f9630a", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::{\n         Instance, TyCtxt,\n     },\n };\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n@@ -349,10 +349,14 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Equivalent setting as RUST_BACKTRACE on encountering an error.\n     pub(crate) backtrace_style: BacktraceStyle,\n+\n+    /// Crates which are considered local for the purposes of error reporting.\n+    pub(crate) local_crates: Vec<CrateNum>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n+        let local_crates = helpers::get_local_crates(&layout_cx.tcx);\n         let layouts =\n             PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n         let profiler = config.measureme_out.as_ref().map(|out| {\n@@ -381,12 +385,19 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             exported_symbols_cache: FxHashMap::default(),\n             panic_on_unsupported: config.panic_on_unsupported,\n             backtrace_style: config.backtrace_style,\n+            local_crates,\n         }\n     }\n \n     pub(crate) fn communicate(&self) -> bool {\n         self.isolated_op == IsolatedOp::Allow\n     }\n+\n+    /// Check whether the stack frame that this `FrameInfo` refers to is part of a local crate.\n+    pub(crate) fn is_local(&self, frame: &FrameInfo<'_>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        def_id.is_local() || self.local_crates.contains(&def_id.krate)\n+    }\n }\n \n /// A rustc InterpCx for Miri."}]}