{"sha": "64e7fd952243b6724dcd4e14e177c3e972b342bc", "node_id": "C_kwDOAAsO6NoAKDY0ZTdmZDk1MjI0M2I2NzI0ZGNkNGUxNGUxNzdjM2U5NzJiMzQyYmM", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-02T22:08:54Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-02T22:08:54Z"}, "message": "Slightly tweak comments wrt `lint_overflowing_range_endpoint`", "tree": {"sha": "7dfd312c1a4d2000705c7b86e5eb1270d712f631", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dfd312c1a4d2000705c7b86e5eb1270d712f631"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64e7fd952243b6724dcd4e14e177c3e972b342bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64e7fd952243b6724dcd4e14e177c3e972b342bc", "html_url": "https://github.com/rust-lang/rust/commit/64e7fd952243b6724dcd4e14e177c3e972b342bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64e7fd952243b6724dcd4e14e177c3e972b342bc/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47b2eee1737cae830c4194858a5e8b8acaf2678b", "url": "https://api.github.com/repos/rust-lang/rust/commits/47b2eee1737cae830c4194858a5e8b8acaf2678b", "html_url": "https://github.com/rust-lang/rust/commit/47b2eee1737cae830c4194858a5e8b8acaf2678b"}], "stats": {"total": 78, "additions": 40, "deletions": 38}, "files": [{"sha": "3cdca2178657d78d910186e6848b480d9dcf0a65", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/64e7fd952243b6724dcd4e14e177c3e972b342bc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e7fd952243b6724dcd4e14e177c3e972b342bc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=64e7fd952243b6724dcd4e14e177c3e972b342bc", "patch": "@@ -116,8 +116,8 @@ impl TypeLimits {\n     }\n }\n \n-/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n-/// Returns `true` iff the lint was overridden.\n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint (`expr..MAX+1`).\n+/// Returns `true` iff the lint was emitted.\n fn lint_overflowing_range_endpoint<'tcx>(\n     cx: &LateContext<'tcx>,\n     lit: &hir::Lit,\n@@ -140,44 +140,46 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         return false;\n     }\n \n-    let mut overwritten = false;\n     // We can suggest using an inclusive range\n     // (`..=`) instead only if it is the `end` that is\n     // overflowing and only by 1.\n-    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max\n-        && let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span)\n-    {\n-        cx.struct_span_lint(\n-            OVERFLOWING_LITERALS,\n-            struct_expr.span,\n-            fluent::lint::range_endpoint_out_of_range,\n-            |lint| {\n-                use ast::{LitIntType, LitKind};\n-\n-                lint.set_arg(\"ty\", ty);\n-\n-                // We need to preserve the literal's suffix,\n-                // as it may determine typing information.\n-                let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                    _ => bug!(),\n-                };\n-                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                lint.span_suggestion(\n-                    struct_expr.span,\n-                    fluent::lint::suggestion,\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n-                overwritten = true;\n+    if !(eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max) {\n+        return false;\n+    };\n+    let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-                lint\n-            },\n-        );\n-    }\n-    overwritten\n+    cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        struct_expr.span,\n+        fluent::lint::range_endpoint_out_of_range,\n+        |lint| {\n+            use ast::{LitIntType, LitKind};\n+\n+            lint.set_arg(\"ty\", ty);\n+\n+            // We need to preserve the literal's suffix,\n+            // as it may determine typing information.\n+            let suffix = match lit.node {\n+                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+                _ => bug!(),\n+            };\n+            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+            lint.span_suggestion(\n+                struct_expr.span,\n+                fluent::lint::suggestion,\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+\n+            lint\n+        },\n+    );\n+\n+    // We've just emitted a lint, special cased for `(...)..MAX+1` ranges,\n+    // return `true` so the callers don't also emit a lint\n+    true\n }\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n@@ -358,7 +360,7 @@ fn lint_int_literal<'tcx>(\n         }\n \n         if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n \n@@ -427,7 +429,7 @@ fn lint_uint_literal<'tcx>(\n             }\n         }\n         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {"}]}