{"sha": "beb4f4954179998e317db33e47a48a9bb7374977", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYjRmNDk1NDE3OTk5OGUzMTdkYjMzZTQ3YTQ4YTliYjczNzQ5Nzc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-09T08:56:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-09T08:56:58Z"}, "message": "Merge #3513\n\n3513: Completion in macros r=matklad a=flodiebold\n\nI experimented a bit with completion in macros. It's kind of working, but there are a lot of rough edges.\r\n\r\n - I'm trying to expand the macro call with the inserted fake token. This requires some hacky additions on the HIR level to be able to do \"hypothetical\" expansions. There should probably be a nicer API for this, if we want to do it this way. I'm not sure whether it's worth it, because we still can't do a lot if the original macro call didn't expand in nearly the same way. E.g. if we have something like `println!(\"\", x<|>)` the expansions will look the same and everything is fine; but in that case we could maybe have achieved the same result in a simpler way. If we have something like `m!(<|>)` where `m!()` doesn't even expand or expands to something very different, we don't really know what to do anyway.\r\n - Relatedly, there are a lot of cases where this doesn't work because either the original call or the hypothetical call doesn't expand. E.g. if we have `m!(x.<|>)` the original token tree doesn't parse as an expression; if we have `m!(match x { <|> })` the hypothetical token tree doesn't parse. It would be nice if we could have better error recovery in these cases.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "e2af54ce707bfcdd0a0cd3fc5d547f43fc9fb7d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2af54ce707bfcdd0a0cd3fc5d547f43fc9fb7d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/beb4f4954179998e317db33e47a48a9bb7374977", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZgTaCRBK7hj4Ov3rIwAAdHIIAE0noRaugoKb3useSwDGbBKU\n6dZjjjEu+q018w0g4mUvwRkEjarPWKxUwX4qBq+Zd5nh9t92NlMFpH0952xMX7Nc\n70GnbiNuZEfyJTpKDgFlgi4YGv5pemPJiMXS3crYnM6GtJn7xXhVeVGYsqXenpVx\nwYEyWs9p2FQ9X9viS3I4wrObRp50ZfFi3AZESVCkc3ng1u6hDebBSsaW60UGHJZ1\nrm1ck/EerRSKyIeLMyTWPAEx+Y8Bc0v9Zz8dj/06+CTwFiAa2yqIn9OeuxP2iX8l\nX7wNhrTlfstW3ZmWvTngxaT7b6kbFbS+GfkClgCiZrKA95krwSdSGPLWm+gnq7Q=\n=MYnQ\n-----END PGP SIGNATURE-----\n", "payload": "tree e2af54ce707bfcdd0a0cd3fc5d547f43fc9fb7d1\nparent 30062da6284052deac04c759540f81d5b326689c\nparent afdf08e964345ac4a884a5630772611ba81f6969\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583744218 +0000\ncommitter GitHub <noreply@github.com> 1583744218 +0000\n\nMerge #3513\n\n3513: Completion in macros r=matklad a=flodiebold\n\nI experimented a bit with completion in macros. It's kind of working, but there are a lot of rough edges.\r\n\r\n - I'm trying to expand the macro call with the inserted fake token. This requires some hacky additions on the HIR level to be able to do \"hypothetical\" expansions. There should probably be a nicer API for this, if we want to do it this way. I'm not sure whether it's worth it, because we still can't do a lot if the original macro call didn't expand in nearly the same way. E.g. if we have something like `println!(\"\", x<|>)` the expansions will look the same and everything is fine; but in that case we could maybe have achieved the same result in a simpler way. If we have something like `m!(<|>)` where `m!()` doesn't even expand or expands to something very different, we don't really know what to do anyway.\r\n - Relatedly, there are a lot of cases where this doesn't work because either the original call or the hypothetical call doesn't expand. E.g. if we have `m!(x.<|>)` the original token tree doesn't parse as an expression; if we have `m!(match x { <|> })` the hypothetical token tree doesn't parse. It would be nice if we could have better error recovery in these cases.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/beb4f4954179998e317db33e47a48a9bb7374977", "html_url": "https://github.com/rust-lang/rust/commit/beb4f4954179998e317db33e47a48a9bb7374977", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/beb4f4954179998e317db33e47a48a9bb7374977/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30062da6284052deac04c759540f81d5b326689c", "url": "https://api.github.com/repos/rust-lang/rust/commits/30062da6284052deac04c759540f81d5b326689c", "html_url": "https://github.com/rust-lang/rust/commit/30062da6284052deac04c759540f81d5b326689c"}, {"sha": "afdf08e964345ac4a884a5630772611ba81f6969", "url": "https://api.github.com/repos/rust-lang/rust/commits/afdf08e964345ac4a884a5630772611ba81f6969", "html_url": "https://github.com/rust-lang/rust/commit/afdf08e964345ac4a884a5630772611ba81f6969"}], "stats": {"total": 570, "additions": 528, "deletions": 42}, "files": [{"sha": "2e052d267b56ca757e904eae11d3499698eb5762", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -960,6 +960,7 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"either\",\n+ \"itertools\",\n  \"log\",\n  \"ra_db\",\n  \"ra_hir_def\","}, {"sha": "266c4cff3829b8a6b4065e8e04a0291193a9a5de", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -12,6 +12,8 @@ log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n \n+itertools = \"0.8.2\"\n+\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "3782a9984b772716710aafac6933e9ebf62117e8", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    TraitId,\n+    AsMacroCall, TraitId,\n };\n use hir_expand::ExpansionInfo;\n use ra_db::{FileId, FileRange};\n@@ -70,6 +70,20 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         Some(node)\n     }\n \n+    pub fn expand_hypothetical(\n+        &self,\n+        actual_macro_call: &ast::MacroCall,\n+        hypothetical_args: &ast::TokenTree,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let macro_call =\n+            self.find_file(actual_macro_call.syntax().clone()).with_value(actual_macro_call);\n+        let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n+        let macro_call_id = macro_call\n+            .as_call_id(self.db, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n+        hir_expand::db::expand_hypothetical(self.db, macro_call_id, hypothetical_args, token_to_map)\n+    }\n+\n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n         let parent = token.parent();\n         let parent = self.find_file(parent);\n@@ -104,6 +118,25 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         node.ancestors_with_macros(self.db).map(|it| it.value)\n     }\n \n+    pub fn ancestors_at_offset_with_macros(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        use itertools::Itertools;\n+        node.token_at_offset(offset)\n+            .map(|token| self.ancestors_with_macros(token.parent()))\n+            .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n+    }\n+\n+    pub fn find_node_at_offset_with_macros<N: AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> Option<N> {\n+        self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n+    }\n+\n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n         self.analyze(expr.syntax()).type_of(self.db, &expr)\n     }"}, {"sha": "29dde3d807be977e2b8c40d4da3fa9b8f5abc479", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -72,6 +72,30 @@ pub trait AstDatabase: SourceDatabase {\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n }\n \n+/// This expands the given macro call, but with different arguments. This is\n+/// used for completion, where we want to see what 'would happen' if we insert a\n+/// token. The `token_to_map` mapped down into the expansion, with the mapped\n+/// token returned.\n+pub fn expand_hypothetical(\n+    db: &impl AstDatabase,\n+    actual_macro_call: MacroCallId,\n+    hypothetical_args: &ra_syntax::ast::TokenTree,\n+    token_to_map: ra_syntax::SyntaxToken,\n+) -> Option<(SyntaxNode, ra_syntax::SyntaxToken)> {\n+    let macro_file = MacroFile { macro_call_id: actual_macro_call };\n+    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(hypothetical_args.syntax()).unwrap();\n+    let range =\n+        token_to_map.text_range().checked_sub(hypothetical_args.syntax().text_range().start())?;\n+    let token_id = tmap_1.token_by_range(range)?;\n+    let macro_def = expander(db, actual_macro_call)?;\n+    let (node, tmap_2) =\n+        parse_macro_with_arg(db, macro_file, Some(std::sync::Arc::new((tt, tmap_1))))?;\n+    let token_id = macro_def.0.map_id_down(token_id);\n+    let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n+    let token = ra_syntax::algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n+    Some((node.syntax_node(), token))\n+}\n+\n pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n     let map =\n         db.parse_or_expand(file_id).map_or_else(AstIdMap::default, |it| AstIdMap::from_source(&it));\n@@ -129,16 +153,43 @@ pub(crate) fn macro_arg(\n pub(crate) fn macro_expand(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n+) -> Result<Arc<tt::Subtree>, String> {\n+    macro_expand_with_arg(db, id, None)\n+}\n+\n+fn expander(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n+    let lazy_id = match id {\n+        MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(_id) => {\n+            return None;\n+        }\n+    };\n+\n+    let loc = db.lookup_intern_macro(lazy_id);\n+    let macro_rules = db.macro_def(loc.def)?;\n+    Some(macro_rules)\n+}\n+\n+fn macro_expand_with_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> Result<Arc<tt::Subtree>, String> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n-            return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+            if arg.is_some() {\n+                return Err(\n+                    \"hypothetical macro expansion not implemented for eager macro\".to_owned()\n+                );\n+            } else {\n+                return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+            }\n         }\n     };\n \n     let loc = db.lookup_intern_macro(lazy_id);\n-    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+    let macro_arg = arg.or_else(|| db.macro_arg(id)).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n     let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n@@ -162,12 +213,24 @@ pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Optio\n pub(crate) fn parse_macro(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n+) -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n+    parse_macro_with_arg(db, macro_file, None)\n+}\n+\n+pub fn parse_macro_with_arg(\n+    db: &dyn AstDatabase,\n+    macro_file: MacroFile,\n+    arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n     let _p = profile(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n-    let tt = db\n-        .macro_expand(macro_call_id)\n+    let expansion = if let Some(arg) = arg {\n+        macro_expand_with_arg(db, macro_call_id, Some(arg))\n+    } else {\n+        db.macro_expand(macro_call_id)\n+    };\n+    let tt = expansion\n         .map_err(|err| {\n             // Note:\n             // The final goal we would like to make all parse_macro success,"}, {"sha": "f275305e2040b779f385c1d04f965394b9936047", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -38,7 +38,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n     for receiver in receiver.autoderef(ctx.db) {\n         for (field, ty) in receiver.fields(ctx.db) {\n-            if ctx.module.map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n+            if ctx.scope().module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n                 // Skip private field. FIXME: If the definition location of the\n                 // field is editable, we should show the completion\n                 continue;\n@@ -53,7 +53,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Ty\n }\n \n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n-    if let Some(krate) = ctx.module.map(|it| it.krate()) {\n+    if let Some(krate) = ctx.krate {\n         let mut seen_methods = FxHashSet::default();\n         let traits_in_scope = ctx.scope().traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n@@ -620,4 +620,102 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn works_in_simple_macro_1() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.x<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [156; 157),\n+                delete: [156; 157),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_recursive() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.x<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [156; 157),\n+                delete: [156; 157),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_2() {\n+        // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(a.<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"[]\"###\n+        );\n+    }\n+\n+    #[test]\n+    fn works_in_simple_macro_recursive_1() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    m!(m!(m!(a.x<|>)))\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [162; 163),\n+                delete: [162; 163),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "e1c0ffb1fb7c3621efd3bce9565fac1aac61fb23", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -79,6 +79,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n }\n \n fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n+    // FIXME move this to CompletionContext and make it handle macros\n     for node in leaf.parent().ancestors() {\n         if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n             break;"}, {"sha": "3c4a70561249f19a3ec72c5ed18baeda7047b8d5", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -1,4 +1,4 @@\n-//! Completion of paths, including when writing a single name.\n+//! Completion of paths, i.e. `some::prefix::<|>`.\n \n use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n@@ -48,7 +48,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             };\n             // Iterate assoc types separately\n             // FIXME: complete T::AssocType\n-            let krate = ctx.module.map(|m| m.krate());\n+            let krate = ctx.krate;\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope().traits_in_scope();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n@@ -934,4 +934,37 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn completes_in_simple_macro_call() {\n+        let completions = do_reference_completion(\n+            r#\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn main() { m!(self::f<|>); }\n+                fn foo() {}\n+            \"#,\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo()\",\n+                source_range: [93; 94),\n+                delete: [93; 94),\n+                insert: \"foo()$0\",\n+                kind: Function,\n+                lookup: \"foo\",\n+                detail: \"fn foo()\",\n+            },\n+            CompletionItem {\n+                label: \"main()\",\n+                source_range: [93; 94),\n+                delete: [93; 94),\n+                insert: \"main()$0\",\n+                kind: Function,\n+                lookup: \"main\",\n+                detail: \"fn main()\",\n+            },\n+        ]\n+        \"###);\n+    }\n }"}, {"sha": "fa8aecedad8c1194fac3fb3757dc7b189db41c4b", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -86,4 +86,22 @@ mod tests {\n         ]\n         \"###);\n     }\n+\n+    #[test]\n+    fn completes_in_simple_macro_call() {\n+        // FIXME: doesn't work yet because of missing error recovery in macro expansion\n+        let completions = complete(\n+            r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            enum E { X }\n+\n+            fn foo() {\n+               m!(match E::X {\n+                   <|>\n+               })\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"[]\"###);\n+    }\n }"}, {"sha": "65ecea12503bf46a496db74061d38c1a4e554383", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -67,8 +67,8 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n \n fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet: &str) -> Builder {\n     let edit = {\n-        let receiver_range =\n-            ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax().text_range();\n+        let receiver_syntax = ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax();\n+        let receiver_range = ctx.sema.original_range(receiver_syntax).range;\n         let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n         TextEdit::replace(delete_range, snippet.to_string())\n     };\n@@ -279,4 +279,65 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn works_in_simple_macro() {\n+        assert_debug_snapshot!(\n+            do_postfix_completion(\n+                r#\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn main() {\n+                    let bar: u8 = 12;\n+                    m!(bar.b<|>)\n+                }\n+                \"#,\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"box\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"Box::new(bar)\",\n+                detail: \"Box::new(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"dbg\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"dbg!(bar)\",\n+                detail: \"dbg!(expr)\",\n+            },\n+            CompletionItem {\n+                label: \"match\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"match bar {\\n    ${1:_} => {$0\\\\},\\n}\",\n+                detail: \"match expr {}\",\n+            },\n+            CompletionItem {\n+                label: \"not\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"!bar\",\n+                detail: \"!expr\",\n+            },\n+            CompletionItem {\n+                label: \"ref\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"&bar\",\n+                detail: \"&expr\",\n+            },\n+            CompletionItem {\n+                label: \"refm\",\n+                source_range: [149; 150),\n+                delete: [145; 150),\n+                insert: \"&mut bar\",\n+                detail: \"&mut expr\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "be6e4194fc6a114a61710e4b1a97d653f078af79", "filename": "crates/ra_ide/src/completion/complete_record_literal.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -153,4 +153,29 @@ mod tests {\n         ]\n         \"###);\n     }\n+\n+    #[test]\n+    fn test_record_literal_field_in_simple_macro() {\n+        let completions = complete(\n+            r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct A { the_field: u32 }\n+            fn foo() {\n+               m!(A { the<|> })\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [137; 140),\n+                delete: [137; 140),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+    }\n }"}, {"sha": "687c57d3eda23d6c9308920d243e0b0351fa0b28", "filename": "crates/ra_ide/src/completion/complete_record_pattern.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -87,4 +87,32 @@ mod tests {\n         ]\n         \"###);\n     }\n+\n+    #[test]\n+    fn test_record_pattern_field_in_simple_macro() {\n+        let completions = complete(\n+            r\"\n+            macro_rules! m { ($e:expr) => { $e } }\n+            struct S { foo: u32 }\n+\n+            fn process(f: S) {\n+                m!(match f {\n+                    S { f<|>: 92 } => (),\n+                })\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo\",\n+                source_range: [171; 172),\n+                delete: [171; 172),\n+                insert: \"foo\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###);\n+    }\n }"}, {"sha": "eb3c8cf1b6b491956b0ab5770910eb2f27c8e5dd", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! Completion of names from the current scope, e.g. locals and imported items.\n \n use crate::completion::{CompletionContext, Completions};\n \n@@ -797,4 +797,72 @@ mod tests {\n         \"###\n         )\n     }\n+\n+    #[test]\n+    fn completes_in_simple_macro_1() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn quux(x: i32) {\n+                    let y = 92;\n+                    m!(<|>);\n+                }\n+                \"\n+            ),\n+            @\"[]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_in_simple_macro_2() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn quux(x: i32) {\n+                    let y = 92;\n+                    m!(x<|>);\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m!\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"m!($0)\",\n+                kind: Macro,\n+                detail: \"macro_rules! m\",\n+            },\n+            CompletionItem {\n+                label: \"quux(\u2026)\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"quux(${1:x})$0\",\n+                kind: Function,\n+                lookup: \"quux\",\n+                detail: \"fn quux(x: i32)\",\n+            },\n+            CompletionItem {\n+                label: \"x\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"x\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+            CompletionItem {\n+                label: \"y\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"y\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n }"}, {"sha": "40535c09e1cad5d903e44a07abb253d833391f29", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 82, "deletions": 29, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -5,7 +5,7 @@ use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n-    ast, AstNode, SourceFile,\n+    ast, AstNode,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n@@ -20,8 +20,11 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) sema: Semantics<'a, RootDatabase>,\n     pub(super) db: &'a RootDatabase,\n     pub(super) offset: TextUnit,\n+    /// The token before the cursor, in the original file.\n+    pub(super) original_token: SyntaxToken,\n+    /// The token before the cursor, in the macro-expanded file.\n     pub(super) token: SyntaxToken,\n-    pub(super) module: Option<hir::Module>,\n+    pub(super) krate: Option<hir::Crate>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n     pub(super) function_syntax: Option<ast::FnDef>,\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n@@ -67,15 +70,20 @@ impl<'a> CompletionContext<'a> {\n             let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n+        let fake_ident_token =\n+            file_with_fake_ident.syntax().token_at_offset(position.offset).right_biased().unwrap();\n \n-        let module = sema.to_module_def(position.file_id);\n-        let token = original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let krate = sema.to_module_def(position.file_id).map(|m| m.krate());\n+        let original_token =\n+            original_file.syntax().token_at_offset(position.offset).left_biased()?;\n+        let token = sema.descend_into_macros(original_token.clone());\n         let mut ctx = CompletionContext {\n             sema,\n             db,\n+            original_token,\n             token,\n             offset: position.offset,\n-            module,\n+            krate,\n             name_ref_syntax: None,\n             function_syntax: None,\n             use_item_syntax: None,\n@@ -95,15 +103,57 @@ impl<'a> CompletionContext<'a> {\n             has_type_args: false,\n             dot_receiver_is_ambiguous_float_literal: false,\n         };\n-        ctx.fill(&original_file, file_with_fake_ident, position.offset);\n+\n+        let mut original_file = original_file.syntax().clone();\n+        let mut hypothetical_file = file_with_fake_ident.syntax().clone();\n+        let mut offset = position.offset;\n+        let mut fake_ident_token = fake_ident_token;\n+\n+        // Are we inside a macro call?\n+        while let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+            find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n+            find_node_at_offset::<ast::MacroCall>(&hypothetical_file, offset),\n+        ) {\n+            if actual_macro_call.path().as_ref().map(|s| s.syntax().text())\n+                != macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text())\n+            {\n+                break;\n+            }\n+            let hypothetical_args = match macro_call_with_fake_ident.token_tree() {\n+                Some(tt) => tt,\n+                None => break,\n+            };\n+            if let (Some(actual_expansion), Some(hypothetical_expansion)) = (\n+                ctx.sema.expand(&actual_macro_call),\n+                ctx.sema.expand_hypothetical(\n+                    &actual_macro_call,\n+                    &hypothetical_args,\n+                    fake_ident_token,\n+                ),\n+            ) {\n+                let new_offset = hypothetical_expansion.1.text_range().start();\n+                if new_offset >= actual_expansion.text_range().end() {\n+                    break;\n+                }\n+                original_file = actual_expansion;\n+                hypothetical_file = hypothetical_expansion.0;\n+                fake_ident_token = hypothetical_expansion.1;\n+                offset = new_offset;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        ctx.fill(&original_file, hypothetical_file, offset);\n         Some(ctx)\n     }\n \n     // The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n+        // check kind of macro-expanded token, but use range of original token\n         match self.token.kind() {\n             // workaroud when completion is triggered by trigger characters.\n-            IDENT => self.token.text_range(),\n+            IDENT => self.original_token.text_range(),\n             _ => TextRange::offset_len(self.offset, 0.into()),\n         }\n     }\n@@ -114,27 +164,24 @@ impl<'a> CompletionContext<'a> {\n \n     fn fill(\n         &mut self,\n-        original_file: &ast::SourceFile,\n-        file_with_fake_ident: ast::SourceFile,\n+        original_file: &SyntaxNode,\n+        file_with_fake_ident: SyntaxNode,\n         offset: TextUnit,\n     ) {\n         // First, let's try to complete a reference to some declaration.\n-        if let Some(name_ref) =\n-            find_node_at_offset::<ast::NameRef>(file_with_fake_ident.syntax(), offset)\n-        {\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&file_with_fake_ident, offset) {\n             // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n             // See RFC#1685.\n             if is_node::<ast::Param>(name_ref.syntax()) {\n                 self.is_param = true;\n                 return;\n             }\n-            self.classify_name_ref(original_file, name_ref);\n+            self.classify_name_ref(original_file, name_ref, offset);\n         }\n \n         // Otherwise, see if this is a declaration. We can use heuristics to\n         // suggest declaration names, see `CompletionKind::Magic`.\n-        if let Some(name) = find_node_at_offset::<ast::Name>(file_with_fake_ident.syntax(), offset)\n-        {\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n             if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n                 let parent = bind_pat.syntax().parent();\n                 if parent.clone().and_then(ast::MatchArm::cast).is_some()\n@@ -148,23 +195,29 @@ impl<'a> CompletionContext<'a> {\n                 return;\n             }\n             if name.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n-                self.record_lit_pat = find_node_at_offset(original_file.syntax(), self.offset);\n+                self.record_lit_pat =\n+                    self.sema.find_node_at_offset_with_macros(&original_file, offset);\n             }\n         }\n     }\n \n-    fn classify_name_ref(&mut self, original_file: &SourceFile, name_ref: ast::NameRef) {\n+    fn classify_name_ref(\n+        &mut self,\n+        original_file: &SyntaxNode,\n+        name_ref: ast::NameRef,\n+        offset: TextUnit,\n+    ) {\n         self.name_ref_syntax =\n-            find_node_at_offset(original_file.syntax(), name_ref.syntax().text_range().start());\n+            find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n         let name_range = name_ref.syntax().text_range();\n         if name_ref.syntax().parent().and_then(ast::RecordField::cast).is_some() {\n-            self.record_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n+            self.record_lit_syntax =\n+                self.sema.find_node_at_offset_with_macros(&original_file, offset);\n         }\n \n         self.impl_def = self\n-            .token\n-            .parent()\n-            .ancestors()\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::ImplDef::cast);\n \n@@ -183,12 +236,12 @@ impl<'a> CompletionContext<'a> {\n             _ => (),\n         }\n \n-        self.use_item_syntax = self.token.parent().ancestors().find_map(ast::UseItem::cast);\n+        self.use_item_syntax =\n+            self.sema.ancestors_with_macros(self.token.parent()).find_map(ast::UseItem::cast);\n \n         self.function_syntax = self\n-            .token\n-            .parent()\n-            .ancestors()\n+            .sema\n+            .ancestors_with_macros(self.token.parent())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::FnDef::cast);\n \n@@ -242,7 +295,7 @@ impl<'a> CompletionContext<'a> {\n \n                 if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n                     if let Some(if_expr) =\n-                        find_node_at_offset::<ast::IfExpr>(original_file.syntax(), off)\n+                        self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n                     {\n                         if if_expr.syntax().text_range().end()\n                             < name_ref.syntax().text_range().start()\n@@ -259,7 +312,7 @@ impl<'a> CompletionContext<'a> {\n             self.dot_receiver = field_expr\n                 .expr()\n                 .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+                .and_then(|r| find_node_with_range(original_file, r));\n             self.dot_receiver_is_ambiguous_float_literal =\n                 if let Some(ast::Expr::Literal(l)) = &self.dot_receiver {\n                     match l.kind() {\n@@ -275,7 +328,7 @@ impl<'a> CompletionContext<'a> {\n             self.dot_receiver = method_call_expr\n                 .expr()\n                 .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+                .and_then(|r| find_node_with_range(original_file, r));\n             self.is_call = true;\n         }\n     }"}, {"sha": "49c53183a1cc35f506513676a0eebad53bbf18b0", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb4f4954179998e317db33e47a48a9bb7374977/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=beb4f4954179998e317db33e47a48a9bb7374977", "patch": "@@ -247,6 +247,7 @@ impl<'a> TtIter<'a> {\n         ra_parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n \n         if !sink.cursor.is_root() || sink.error {\n+            // FIXME better recovery in this case would help completion inside macros immensely\n             return Err(());\n         }\n \n@@ -375,7 +376,8 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, Ex\n             return Ok(Some(Fragment::Tokens(tt)));\n         }\n     };\n-    let tt = input.expect_fragment(fragment).map_err(|()| err!())?;\n+    let tt =\n+        input.expect_fragment(fragment).map_err(|()| err!(\"fragment did not parse as {}\", kind))?;\n     let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n     Ok(Some(fragment))\n }"}]}