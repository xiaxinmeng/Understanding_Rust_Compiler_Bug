{"sha": "37974e617e22f46d14f1e2bd5ffde077cc3fd86c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3OTc0ZTYxN2UyMmY0NmQxNGYxZTJiZDVmZmRlMDc3Y2MzZmQ4NmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T10:21:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T10:21:08Z"}, "message": "Auto merge of #1855 - RalfJung:rustup, r=RalfJung\n\nrustup\n\nThis test was removed in rustc in https://github.com/rust-lang/rust/pull/87141.\n\nWe added it in https://github.com/rust-lang/miri/pull/1430, and possibly that \"interesting case in unsizing\" is not covered by tests now -- but I don't remember what that case is.^^ If/when `impl Trait` in bindings comes back, we should copy the new rustc tests to Miri as well.", "tree": {"sha": "2e17a15968bbccd273e5ae4eb527b472f003bd55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e17a15968bbccd273e5ae4eb527b472f003bd55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37974e617e22f46d14f1e2bd5ffde077cc3fd86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37974e617e22f46d14f1e2bd5ffde077cc3fd86c", "html_url": "https://github.com/rust-lang/rust/commit/37974e617e22f46d14f1e2bd5ffde077cc3fd86c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37974e617e22f46d14f1e2bd5ffde077cc3fd86c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "250eff85c86b089b77005691b899cea739f7e0cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/250eff85c86b089b77005691b899cea739f7e0cb", "html_url": "https://github.com/rust-lang/rust/commit/250eff85c86b089b77005691b899cea739f7e0cb"}, {"sha": "6ce77164c19dc42c5f58cd5f0fff001a2f2f23f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce77164c19dc42c5f58cd5f0fff001a2f2f23f4", "html_url": "https://github.com/rust-lang/rust/commit/6ce77164c19dc42c5f58cd5f0fff001a2f2f23f4"}], "stats": {"total": 70, "additions": 1, "deletions": 69}, "files": [{"sha": "dc2d4398c48af10da94d06dd97270df05fa31ff5", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37974e617e22f46d14f1e2bd5ffde077cc3fd86c/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/37974e617e22f46d14f1e2bd5ffde077cc3fd86c/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=37974e617e22f46d14f1e2bd5ffde077cc3fd86c", "patch": "@@ -1 +1 @@\n-c78ebb7bdcfc924a20fd069891ffe1364d6814e7\n+a72c360a30f9a8160e4f40340cecc9b1ce979cd7"}, {"sha": "e7a5f13923a8d0d407a856473cf2c92e85ee818c", "filename": "tests/run-pass/dyn-lcsit.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/250eff85c86b089b77005691b899cea739f7e0cb/tests%2Frun-pass%2Fdyn-lcsit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250eff85c86b089b77005691b899cea739f7e0cb/tests%2Frun-pass%2Fdyn-lcsit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdyn-lcsit.rs?ref=250eff85c86b089b77005691b899cea739f7e0cb", "patch": "@@ -1,68 +0,0 @@\n-// Taken from the rustc test suite; this triggers an interesting case in unsizing.\n-\n-#![allow(non_upper_case_globals, incomplete_features)]\n-#![feature(associated_type_bounds)]\n-#![feature(impl_trait_in_bindings)]\n-\n-use std::ops::Add;\n-\n-trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n-trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n-\n-fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n-fn assert_static<T: 'static>(_: T) {}\n-fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n-\n-#[derive(Copy, Clone)]\n-struct S1;\n-#[derive(Copy, Clone)]\n-struct S2;\n-impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n-\n-const cdef_et1: &dyn Tr1<As1: Copy> = &S1;\n-const sdef_et1: &dyn Tr1<As1: Copy> = &S1;\n-pub fn use_et1() { assert_copy(cdef_et1.mk()); assert_copy(sdef_et1.mk()); }\n-\n-const cdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n-static sdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n-pub fn use_et2() { assert_static(cdef_et2.mk()); assert_static(sdef_et2.mk()); }\n-\n-const cdef_et3: &dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = {\n-    struct A;\n-    impl Tr1 for A {\n-        type As1 = core::ops::Range<u8>;\n-        fn mk(&self) -> Self::As1 { 0..10 }\n-    }\n-    &A\n-};\n-pub fn use_et3() {\n-    let _0 = cdef_et3.mk().clone();\n-    let mut s = 0u8;\n-    for _1 in _0 {\n-        let _2 = _1 + 1u8;\n-        s += _2.into();\n-    }\n-    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n-}\n-\n-const cdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = {\n-    #[derive(Copy, Clone)]\n-    struct A;\n-    impl Tr1 for A {\n-        type As1 = A;\n-        fn mk(&self) -> A { A }\n-    }\n-    impl<'a> Tr2<'a> for A {\n-        fn tr2(self) -> &'a Self { &A }\n-    }\n-    &A\n-};\n-static sdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = cdef_et4;\n-pub fn use_et4() { assert_forall_tr2(cdef_et4.mk()); assert_forall_tr2(sdef_et4.mk()); }\n-\n-fn main() {\n-    let _ = use_et1();\n-    let _ = use_et2();\n-    let _ = use_et3();\n-    let _ = use_et4();\n-}"}]}