{"sha": "25315635ef50e57e70cc680a0f70926ec24ed0db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MzE1NjM1ZWY1MGU1N2U3MGNjNjgwYTBmNzA5MjZlYzI0ZWQwZGI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-14T15:54:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-14T15:54:46Z"}, "message": "Rollup merge of #81912 - sexxi-goose:Migrations2_review, r=nikomatsakis\n\nImplement the precise analysis pass for lint `disjoint_capture_drop_reorder`\n\nThe precision pass for the lint prevents the lint from triggering for a variable (that was previously entirely captured by the closure) if all paths that need Drop starting at root variable have been captured by the closure.\n\nr? `@nikomatsakis`", "tree": {"sha": "f9844cf05d1fc3818589528082f39f8a470d07e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9844cf05d1fc3818589528082f39f8a470d07e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25315635ef50e57e70cc680a0f70926ec24ed0db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgKUfHCRBK7hj4Ov3rIwAAdHIIAIVxbmVqO8sIW8TqC2+lrWnY\n1H7xbQ2w4rYnxtbTWkXJQ/hbOeYmZK4z//uq50IgeQS8AEeOYSy85x2gcvsF/XKi\ni0X6Em3HGo8k4BUglLMu7y2uKNUB4vniRWhvX7YsXtCUxBcY1Fmj5fWvkWEwgW9u\noOc0tGsMNT0xcwNRCfCaR6yKZcYbsgTEnWZTNtMgIiFuTha6PYNzkKSbU4af0iCA\n9B6RCML3nl+1A3tWIoWXaNqPKx4VmR3Cg4n1mnTVccPiF6y2vuXLxCjULBGFUDHv\n9eezvV6oLVunNxwaGVkJzvRsDWVwoN+9znGqV+9oCObmFDc6OpiAbPMR181/ITM=\n=H/Cn\n-----END PGP SIGNATURE-----\n", "payload": "tree f9844cf05d1fc3818589528082f39f8a470d07e1\nparent 641c3785dc875744fae75d5c1db12708a819e235\nparent 96c12f90cf62442bc5cba1d8c1c8049ee4652237\nauthor Dylan DPC <dylan.dpc@gmail.com> 1613318086 +0100\ncommitter GitHub <noreply@github.com> 1613318086 +0100\n\nRollup merge of #81912 - sexxi-goose:Migrations2_review, r=nikomatsakis\n\nImplement the precise analysis pass for lint `disjoint_capture_drop_reorder`\n\nThe precision pass for the lint prevents the lint from triggering for a variable (that was previously entirely captured by the closure) if all paths that need Drop starting at root variable have been captured by the closure.\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25315635ef50e57e70cc680a0f70926ec24ed0db", "html_url": "https://github.com/rust-lang/rust/commit/25315635ef50e57e70cc680a0f70926ec24ed0db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25315635ef50e57e70cc680a0f70926ec24ed0db/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "641c3785dc875744fae75d5c1db12708a819e235", "url": "https://api.github.com/repos/rust-lang/rust/commits/641c3785dc875744fae75d5c1db12708a819e235", "html_url": "https://github.com/rust-lang/rust/commit/641c3785dc875744fae75d5c1db12708a819e235"}, {"sha": "96c12f90cf62442bc5cba1d8c1c8049ee4652237", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c12f90cf62442bc5cba1d8c1c8049ee4652237", "html_url": "https://github.com/rust-lang/rust/commit/96c12f90cf62442bc5cba1d8c1c8049ee4652237"}], "stats": {"total": 515, "additions": 502, "deletions": 13}, "files": [{"sha": "d097f863ad2f9dd8b107c1dd7af929389d6ad18a", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 270, "deletions": 13, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/25315635ef50e57e70cc680a0f70926ec24ed0db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25315635ef50e57e70cc680a0f70926ec24ed0db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=25315635ef50e57e70cc680a0f70926ec24ed0db", "patch": "@@ -40,13 +40,16 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n+use rustc_index::vec::Idx;\n+use rustc_target::abi::VariantIdx;\n+\n /// Describe the relationship between the paths of two places\n /// eg:\n /// - `foo` is ancestor of `foo.bar.baz`\n@@ -535,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         body: &'tcx hir::Body<'tcx>,\n     ) {\n-        let need_migrations = self.compute_2229_migrations_first_pass(\n+        let need_migrations = self.compute_2229_migrations(\n             closure_def_id,\n             span,\n             capture_clause,\n@@ -544,9 +547,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         if !need_migrations.is_empty() {\n-            let need_migrations_hir_id = need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n-\n-            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n@@ -573,15 +574,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n     ///   enabled, **and**\n     /// - It wasn't completely captured by the closure, **and**\n-    /// - The type of the root variable needs Drop.\n-    fn compute_2229_migrations_first_pass(\n+    /// - One of the paths starting at this root variable, that is not captured needs Drop.\n+    fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         body: &'tcx hir::Body<'tcx>,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+    ) -> Vec<hir::HirId> {\n         fn resolve_ty<T: TypeFoldable<'tcx>>(\n             fcx: &FnCtxt<'_, 'tcx>,\n             span: Span,\n@@ -617,29 +618,285 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 match closure_clause {\n                     // Only migrate if closure is a move closure\n-                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+                    hir::CaptureBy::Value => need_migrations.push(var_hir_id),\n \n                     hir::CaptureBy::Ref => {}\n                 }\n \n                 continue;\n             };\n \n-            let is_moved = root_var_min_capture_list\n+            let projections_list = root_var_min_capture_list\n                 .iter()\n-                .any(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)));\n+                .filter_map(|captured_place| match captured_place.info.capture_kind {\n+                    // Only care about captures that are moved into the closure\n+                    ty::UpvarCapture::ByValue(..) => {\n+                        Some(captured_place.place.projections.as_slice())\n+                    }\n+                    ty::UpvarCapture::ByRef(..) => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let is_moved = !projections_list.is_empty();\n \n             let is_not_completely_captured =\n                 root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n \n-            if is_moved && is_not_completely_captured {\n-                need_migrations.push((var_hir_id, ty));\n+            if is_moved\n+                && is_not_completely_captured\n+                && self.has_significant_drop_outside_of_captures(\n+                    closure_def_id,\n+                    closure_span,\n+                    ty,\n+                    projections_list,\n+                )\n+            {\n+                need_migrations.push(var_hir_id);\n             }\n         }\n \n         need_migrations\n     }\n \n+    /// This is a helper function to `compute_2229_migrations_precise_pass`. Provided the type\n+    /// of a root variable and a list of captured paths starting at this root variable (expressed\n+    /// using list of `Projection` slices), it returns true if there is a path that is not\n+    /// captured starting at this root variable that implements Drop.\n+    ///\n+    /// FIXME(project-rfc-2229#35): This should return true only for significant drops.\n+    ///                             A drop is significant if it's implemented by the user or does\n+    ///                             anything that will have any observable behavior (other than\n+    ///                             freeing up memory).\n+    ///\n+    /// The way this function works is at a given call it looks at type `base_path_ty` of some base\n+    /// path say P and then list of projection slices which represent the different captures moved\n+    /// into the closure starting off of P.\n+    ///\n+    /// This will make more sense with an example:\n+    ///\n+    /// ```rust\n+    /// #![feature(capture_disjoint_fields)]\n+    ///\n+    /// struct FancyInteger(i32); // This implements Drop\n+    ///\n+    /// struct Point { x: FancyInteger, y: FancyInteger }\n+    /// struct Color;\n+    ///\n+    /// struct Wrapper { p: Point, c: Color }\n+    ///\n+    /// fn f(w: Wrapper) {\n+    ///   let c = || {\n+    ///       // Closure captures w.p.x and w.c by move.\n+    ///   };\n+    ///\n+    ///   c();\n+    /// }\n+    /// ```\n+    ///\n+    /// If `capture_disjoint_fields` wasn't enabled the closure would've moved `w` instead of the\n+    /// precise paths. If we look closely `w.p.y` isn't captured which implements Drop and\n+    /// therefore Drop ordering would change and we want this function to return true.\n+    ///\n+    /// Call stack to figure out if we need to migrate for `w` would look as follows:\n+    ///\n+    /// Our initial base path is just `w`, and the paths captured from it are `w[p, x]` and\n+    /// `w[c]`.\n+    /// Notation:\n+    /// - Ty(place): Type of place\n+    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_projs`\n+    /// respectively.\n+    /// ```\n+    ///                  (Ty(w), [ &[p, x], &[c] ])\n+    ///                                 |\n+    ///                    ----------------------------\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])          (Ty(w.c), [ &[] ]) // I(1)\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])                 false\n+    ///                    |\n+    ///                    |\n+    ///          -------------------------------\n+    ///          |                             |\n+    ///          v                             v\n+    ///     (Ty((w.p).x), [ &[] ])     (Ty((w.p).y), []) // IMP 2\n+    ///          |                             |\n+    ///          v                             v\n+    ///        false                     NeedsDrop(Ty(w.p.y))\n+    ///                                        |\n+    ///                                        v\n+    ///                                      true\n+    /// ```\n+    ///\n+    /// IMP 1 `(Ty(w.c), [ &[] ])`: Notice the single empty slice inside `captured_projs`.\n+    ///                             This implies that the `w.c` is completely captured by the closure.\n+    ///                             Since drop for this path will be called when the closure is\n+    ///                             dropped we don't need to migrate for it.\n+    ///\n+    /// IMP 2 `(Ty((w.p).y), [])`: Notice that `captured_projs` is empty. This implies that this\n+    ///                             path wasn't captured by the closure. Also note that even\n+    ///                             though we didn't capture this path, the function visits it,\n+    ///                             which is kind of the point of this function. We then return\n+    ///                             if the type of `w.p.y` implements Drop, which in this case is\n+    ///                             true.\n+    ///\n+    /// Consider another example:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl Drop for X {}\n+    ///\n+    /// struct Y(X);\n+    /// impl Drop for Y {}\n+    ///\n+    /// fn foo() {\n+    ///     let y = Y(X);\n+    ///     let c = || move(y.0);\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that `y.0` is captured by the closure. When this function is called for `y`, it will\n+    /// return true, because even though all paths starting at `y` are captured, `y` itself\n+    /// implements Drop which will be affected since `y` isn't completely captured.\n+    fn has_significant_drop_outside_of_captures(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        base_path_ty: Ty<'tcx>,\n+        captured_projs: Vec<&[Projection<'tcx>]>,\n+    ) -> bool {\n+        let needs_drop = |ty: Ty<'tcx>| {\n+            ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n+        };\n+\n+        let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n+            let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n+            let ty_params = self.tcx.mk_substs_trait(base_path_ty, &[]);\n+            self.tcx.type_implements_trait((\n+                drop_trait,\n+                ty,\n+                ty_params,\n+                self.tcx.param_env(closure_def_id.expect_local()),\n+            ))\n+        };\n+\n+        let is_drop_defined_for_ty = is_drop_defined_for_ty(base_path_ty);\n+\n+        // If there is a case where no projection is applied on top of current place\n+        // then there must be exactly one capture corresponding to such a case. Note that this\n+        // represents the case of the path being completely captured by the variable.\n+        //\n+        // eg. If `a.b` is captured and we are processing `a.b`, then we can't have the closure also\n+        //     capture `a.b.c`, because that voilates min capture.\n+        let is_completely_captured = captured_projs.iter().any(|projs| projs.is_empty());\n+\n+        assert!(!is_completely_captured || (captured_projs.len() == 1));\n+\n+        if is_completely_captured {\n+            // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n+            // when the closure is dropped.\n+            return false;\n+        }\n+\n+        if is_drop_defined_for_ty {\n+            // If drop is implemented for this type then we need it to be fully captured,\n+            // which we know it is not because of the previous check. Therefore we need to\n+            // do migrate.\n+            return true;\n+        }\n+\n+        if captured_projs.is_empty() {\n+            return needs_drop(base_path_ty);\n+        }\n+\n+        match base_path_ty.kind() {\n+            // Observations:\n+            // - `captured_projs` is not empty. Therefore we can call\n+            //   `captured_projs.first().unwrap()` safely.\n+            // - All entries in `captured_projs` have atleast one projection.\n+            //   Therefore we can call `captured_projs.first().unwrap().first().unwrap()` safely.\n+\n+            // We don't capture derefs in case of move captures, which would have be applied to\n+            // access any further paths.\n+            ty::Adt(def, _) if def.is_box() => unreachable!(),\n+            ty::Ref(..) => unreachable!(),\n+            ty::RawPtr(..) => unreachable!(),\n+\n+            ty::Adt(def, substs) => {\n+                // Multi-varaint enums are captured in entirety,\n+                // which would've been handled in the case of single empty slice in `captured_projs`.\n+                assert_eq!(def.variants.len(), 1);\n+\n+                // Only Field projections can be applied to a non-box Adt.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+                def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n+                    |(i, field)| {\n+                        let paths_using_field = captured_projs\n+                            .iter()\n+                            .filter_map(|projs| {\n+                                if let ProjectionKind::Field(field_idx, _) =\n+                                    projs.first().unwrap().kind\n+                                {\n+                                    if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                                } else {\n+                                    unreachable!();\n+                                }\n+                            })\n+                            .collect();\n+\n+                        let after_field_ty = field.ty(self.tcx, substs);\n+                        self.has_significant_drop_outside_of_captures(\n+                            closure_def_id,\n+                            closure_span,\n+                            after_field_ty,\n+                            paths_using_field,\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::Tuple(..) => {\n+                // Only Field projections can be applied to a tuple.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+\n+                base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n+                    let paths_using_field = captured_projs\n+                        .iter()\n+                        .filter_map(|projs| {\n+                            if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind\n+                            {\n+                                if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                            } else {\n+                                unreachable!();\n+                            }\n+                        })\n+                        .collect();\n+\n+                    self.has_significant_drop_outside_of_captures(\n+                        closure_def_id,\n+                        closure_span,\n+                        element_ty,\n+                        paths_using_field,\n+                    )\n+                })\n+            }\n+\n+            // Anything else would be completely captured and therefore handled already.\n+            _ => unreachable!(),\n+        }\n+    }\n+\n     fn init_capture_kind(\n         &self,\n         capture_clause: hir::CaptureBy,"}, {"sha": "79702cc6b56f3baf9b8f2ad1b5cc6583bd1a1176", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=25315635ef50e57e70cc680a0f70926ec24ed0db", "patch": "@@ -0,0 +1,78 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test that even if all paths starting at root variable that implement Drop are captured,\n+// the lint is triggered if the root variable implements drop and isn't captured.\n+fn test_precise_analysis_parent_root_impl_drop_not_captured() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test that lint is triggered if a path that implements Drop is not captured by move\n+fn test_precise_analysis_drop_paths_not_captured_by_move() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _t = &t.1;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test precise analysis for the lint works with paths longer than one.\n+fn test_precise_analysis_long_path_missing() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(u));\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_parent_root_impl_drop_not_captured();\n+    test_precise_analysis_drop_paths_not_captured_by_move();\n+    test_precise_analysis_long_path_missing();\n+}"}, {"sha": "968ca395f946ef9ccaab6fe357a776aa59905a75", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=25315635ef50e57e70cc680a0f70926ec24ed0db", "patch": "@@ -0,0 +1,49 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:27:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/precise.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:40:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t = &t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:63:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _x = u.0.0;\n+LL | |         let _x = u.0.1;\n+LL | |         let _x = u.1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(u));\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8af48501ca2952670fe96143363d1c8ad0f3b0a5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise_no_migrations.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25315635ef50e57e70cc680a0f70926ec24ed0db/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs?ref=25315635ef50e57e70cc680a0f70926ec24ed0db", "patch": "@@ -0,0 +1,105 @@\n+// run-pass\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_1() {\n+    let t = (Foo(10), Foo(20), Foo(30));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+        let _t = t.2;\n+    };\n+\n+    c();\n+}\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_2() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_1() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_2() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test that if the path is longer than just one element, precise analysis works correctly.\n+fn test_precise_analysis_long_path() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+        let _x = u.1.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_simple_1();\n+    test_precise_analysis_simple_2();\n+\n+    test_precise_analysis_parent_captured_1();\n+    test_precise_analysis_parent_captured_2();\n+\n+    test_precise_analysis_long_path();\n+}"}]}