{"sha": "c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NzdkYWY5N2NkN2FhOGI5NjRiOWI4OWU3ZWJkMmRhMjYwMjJiMmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-02T03:35:25Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-08T20:40:54Z"}, "message": "rustc_trans: avoid sizing_type_of everywhere possible.", "tree": {"sha": "c664de7df490f59060827810882fcbe1e36e610a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c664de7df490f59060827810882fcbe1e36e610a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "html_url": "https://github.com/rust-lang/rust/commit/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49872b859ec71e53266a717f4ec865c88e2bdefe", "url": "https://api.github.com/repos/rust-lang/rust/commits/49872b859ec71e53266a717f4ec865c88e2bdefe", "html_url": "https://github.com/rust-lang/rust/commit/49872b859ec71e53266a717f4ec865c88e2bdefe"}], "stats": {"total": 135, "additions": 53, "deletions": 82}, "files": [{"sha": "550f337d9b1c8ff010062c61c60e7d5e3de779f9", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -439,14 +439,10 @@ impl FnType {\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n-                    let llty = type_of::sizing_type_of(ccx, ty);\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    ret.attrs.set_dereferenceable(llsz);\n+                    ret.attrs.set_dereferenceable(ccx.size_of(ty));\n                 }\n                 ty::TyAdt(def, _) if def.is_box() => {\n-                    let llty = type_of::sizing_type_of(ccx, ret_ty.boxed_ty());\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    ret.attrs.set_dereferenceable(llsz);\n+                    ret.attrs.set_dereferenceable(ccx.size_of(ret_ty.boxed_ty()));\n                 }\n                 _ => {}\n             }\n@@ -517,9 +513,7 @@ impl FnType {\n                 args.push(info);\n             } else {\n                 if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n-                    let llty = type_of::sizing_type_of(ccx, inner);\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    arg.attrs.set_dereferenceable(llsz);\n+                    arg.attrs.set_dereferenceable(ccx.size_of(inner));\n                 }\n                 args.push(arg);\n             }"}, {"sha": "fb7ddd2bf4200b4ec8df061705c3e5ed91b3d3a9", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -47,7 +47,7 @@ use std;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n-use rustc::ty::{self, Ty, AdtKind};\n+use rustc::ty::{self, Ty};\n use common::*;\n use builder::Builder;\n use base;\n@@ -285,31 +285,24 @@ pub fn trans_get_discr<'a, 'tcx>(\n     cast_to: Option<Type>,\n     range_assert: bool\n ) -> ValueRef {\n-    let (def, substs) = match t.sty {\n-        ty::TyAdt(ref def, substs) if def.adt_kind() == AdtKind::Enum => (def, substs),\n-        _ => bug!(\"{} is not an enum\", t)\n-    };\n-\n     debug!(\"trans_get_discr t: {:?}\", t);\n     let l = bcx.ccx.layout_of(t);\n \n     let val = match *l {\n         layout::CEnum { discr, min, max, .. } => {\n             load_discr(bcx, discr, scrutinee, alignment, min, max, range_assert)\n         }\n-        layout::General { discr, .. } => {\n+        layout::General { discr, ref variants, .. } => {\n             let ptr = bcx.struct_gep(scrutinee, 0);\n             load_discr(bcx, discr, ptr, alignment,\n-                       0, def.variants.len() as u64 - 1,\n+                       0, variants.len() as u64 - 1,\n                        range_assert)\n         }\n         layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let llptrty = type_of::sizing_type_of(bcx.ccx,\n-                monomorphize::field_ty(bcx.tcx(), substs,\n-                &def.variants[nndiscr as usize].fields[0]));\n-            bcx.icmp(cmp, bcx.load(scrutinee, alignment.to_align()), C_null(llptrty))\n+            let discr = bcx.load(scrutinee, alignment.to_align());\n+            bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee, alignment)\n@@ -383,9 +376,8 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n             assert_eq!(to, Disr(0));\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n-                let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n+                let llptrty = val_ty(val).element_type();\n                 bcx.store(C_null(llptrty), val, None);\n             }\n         }"}, {"sha": "0b6d9cfd96fa45062773f9c0340a6b40513c3a14", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -59,7 +59,6 @@ use context::{SharedCrateContext, CrateContextList};\n use debuginfo;\n use declare;\n use machine;\n-use machine::llsize_of;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -534,14 +533,13 @@ pub fn memcpy_ty<'a, 'tcx>(\n ) {\n     let ccx = bcx.ccx;\n \n-    if type_is_zero_size(ccx, t) {\n+    let size = ccx.size_of(t);\n+    if size == 0 {\n         return;\n     }\n \n-    let llty = type_of::type_of(ccx, t);\n-    let llsz = llsize_of(ccx, llty);\n-    let llalign = align.unwrap_or_else(|| type_of::align_of(ccx, t));\n-    call_memcpy(bcx, dst, src, llsz, llalign as u32);\n+    let align = align.unwrap_or_else(|| ccx.align_of(t));\n+    call_memcpy(bcx, dst, src, C_uint(ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,"}, {"sha": "cd9635363685241c982a99b3b15d666fb1d507e8", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -125,10 +125,8 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n \n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    use machine::llsize_of_alloc;\n-    use type_of::sizing_type_of;\n-    let llty = sizing_type_of(ccx, ty);\n-    llsize_of_alloc(ccx, llty) == 0\n+    let layout = ccx.layout_of(ty);\n+    !layout.is_unsized() && layout.size(&ccx.tcx().data_layout).bytes() == 0\n }\n \n /*"}, {"sha": "6b6fa538dc03b655e72d8b3af5c663f1ea01e0c3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -255,7 +255,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n+        llvm::LLVMSetAlignment(g, ccx.align_of(ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "f1e1a3bb221360eab65b9cd01d02499cacffec6d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -1772,7 +1772,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n \n-    let global_align = type_of::align_of(cx, variable_type);\n+    let global_align = cx.align_of(variable_type);\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),"}, {"sha": "1b7cf26853bc137ebf91a01268069818776ae93e", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -449,7 +449,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         LocalVariable    |\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n-    let align = ::type_of::align_of(cx, variable_type);\n+    let align = cx.align_of(variable_type);\n \n     let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n     match (variable_access, &[][..]) {"}, {"sha": "c2aa6c829415ffb87d673c4660c6666f7faf2757", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -19,10 +19,8 @@ use llvm::{ValueRef};\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use common::*;\n-use machine::*;\n use meth;\n use monomorphize;\n-use type_of::{sizing_type_of, align_of};\n use value::Value;\n use builder::Builder;\n \n@@ -69,9 +67,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n     if bcx.ccx.shared().type_is_sized(t) {\n-        let sizing_type = sizing_type_of(bcx.ccx, t);\n-        let size = llsize_of_alloc(bcx.ccx, sizing_type);\n-        let align = align_of(bcx.ccx, t);\n+        let size = bcx.ccx.size_of(t);\n+        let align = bcx.ccx.align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n         let size = C_uint(bcx.ccx, size);\n@@ -82,9 +79,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         ty::TyAdt(def, substs) => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n-            // Don't use type_of::sizing_type_of because that expects t to be sized,\n-            // and it also rounds up to alignment, which we want to avoid,\n-            // as the unsized field's alignment could be smaller.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n@@ -154,14 +150,11 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(bcx.tcx());\n+            let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n-            let unit_align = llalign_of_min(bcx.ccx, llunit_ty);\n-            let unit_size = llsize_of_alloc(bcx.ccx, llunit_ty);\n-            (bcx.mul(info, C_uint(bcx.ccx, unit_size)),\n-             C_uint(bcx.ccx, unit_align))\n+            (bcx.mul(info, C_uint(bcx.ccx, bcx.ccx.size_of(unit))),\n+             C_uint(bcx.ccx, bcx.ccx.align_of(unit)))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "5e7d612d17f82e21eb12904140b5b21cabaa9b36", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -151,7 +151,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+            C_uint(ccx, ccx.align_of(tp_ty))\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -160,7 +160,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+                C_uint(ccx, ccx.align_of(tp_ty))\n             }\n         }\n         \"pref_align_of\" => {\n@@ -234,7 +234,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n             let load = bcx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n+                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty));\n             }\n             to_immediate(bcx, load, tp_ty)\n         },\n@@ -252,7 +252,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n+                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty));\n                 }\n             }\n             C_nil(ccx)\n@@ -634,7 +634,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n         if let Some(ty) = fn_ty.ret.cast {\n             let ptr = bcx.pointercast(llresult, ty.ptr_to());\n-            bcx.store(llval, ptr, Some(type_of::align_of(ccx, ret_ty)));\n+            bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n             store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n         }\n@@ -651,7 +651,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             -> ValueRef {\n     let ccx = bcx.ccx;\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n+    let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n \n@@ -685,7 +685,7 @@ fn memset_intrinsic<'a, 'tcx>(\n     count: ValueRef\n ) -> ValueRef {\n     let ccx = bcx.ccx;\n-    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n+    let align = C_i32(ccx, ccx.align_of(ty) as i32);\n     let lltp_ty = type_of::type_of(ccx, ty);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let dst = bcx.pointercast(dst, Type::i8p(ccx));"}, {"sha": "f5f924178589a04d2d0efe8b1fcd9d1384d1ce84", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -17,7 +17,6 @@ use consts;\n use machine;\n use monomorphize;\n use type_::Type;\n-use type_of::*;\n use value::Value;\n use rustc::ty;\n \n@@ -80,14 +79,10 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n \n-    let size_ty = sizing_type_of(ccx, ty);\n-    let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let align = align_of(ccx, ty);\n-\n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n-        C_uint(ccx, size),\n-        C_uint(ccx, align)\n+        C_uint(ccx, ccx.size_of(ty)),\n+        C_uint(ccx, ccx.align_of(ty))\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {"}, {"sha": "84ae8143b3013650042722e00f343478136d0587", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -24,8 +24,8 @@ use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n+use type_of;\n use tvec;\n-use type_of::{self, align_of};\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());;\n-        let llalign = cmp::min(align_of(bcx.ccx, in_type), align_of(bcx.ccx, out_type));\n+        let llalign = cmp::min(bcx.ccx.align_of(in_type), bcx.ccx.align_of(out_type));\n         self.store_operand(bcx, cast_ptr, Some(llalign), val);\n     }\n "}, {"sha": "bd58178b074254b9465bc190a94b772341141462", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> Const<'tcx> {\n         } else {\n             // Otherwise, or if the value is not immediate, we create\n             // a constant LLVM global and cast its address if necessary.\n-            let align = type_of::align_of(ccx, self.ty);\n+            let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n             OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()), Alignment::AbiAligned)\n         };\n@@ -717,7 +717,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n                         let align = if self.ccx.shared().type_is_sized(ty) {\n-                            type_of::align_of(self.ccx, ty)\n+                            self.ccx.align_of(ty)\n                         } else {\n                             self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n                         };\n@@ -1022,25 +1022,20 @@ fn trans_const<'a, 'tcx>(\n             C_vector(vals)\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = adt::compute_fields(ccx, t, nndiscr as usize, false)[0];\n             if variant_index as u64 == nndiscr {\n                 assert_eq!(vals.len(), 1);\n                 vals[0]\n             } else {\n-                C_null(type_of::sizing_type_of(ccx, nnty))\n+                C_null(type_of::type_of(ccx, t))\n             }\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n                 C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n             } else {\n-                let fields = adt::compute_fields(ccx, t, nndiscr as usize, false);\n-                let vals = fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `discrfield`th\n-                    // field; see #8506.\n-                    C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n+                // Always use null even if it's not the `discrfield`th\n+                // field; see #8506.\n+                C_null(type_of::type_of(ccx, t))\n             }\n         }\n         _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)"}, {"sha": "12633720ef87f463a6f5684e50b21f428ea596b4", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -438,7 +438,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n-                let align = type_of::align_of(bcx.ccx, content_ty);\n+                let align = bcx.ccx.align_of(content_ty);\n                 let llalign = C_uint(bcx.ccx, align);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);"}, {"sha": "b195429711d1518b6ee34f5da1adb5ef60b12455", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c977daf97cd7aa8b964b9b89e7ebd2da26022b2a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=c977daf97cd7aa8b964b9b89e7ebd2da26022b2a", "patch": "@@ -322,10 +322,16 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     llty\n }\n \n-pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n-                          -> machine::llalign {\n-    let layout = cx.layout_of(t);\n-    layout.align(&cx.tcx().data_layout).abi() as machine::llalign\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> machine::llalign {\n+        let layout = self.layout_of(ty);\n+        layout.align(&self.tcx().data_layout).abi() as machine::llalign\n+    }\n+\n+    pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n+        let layout = self.layout_of(ty);\n+        layout.size(&self.tcx().data_layout).bytes() as machine::llsize\n+    }\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {"}]}