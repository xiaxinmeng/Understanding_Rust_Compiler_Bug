{"sha": "097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "node_id": "C_kwDOAAsO6NoAKDA5N2VmNTE3ZmVkZDZjMWM5YWI0ZDM1MzA5YjgzZTZiNjJhYjcwM2M", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-02T13:48:14Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-05T13:31:02Z"}, "message": "refactor: remove unnecessary variables", "tree": {"sha": "2215163d040b0d37b8f9b5ec1d37fd30e6262f69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2215163d040b0d37b8f9b5ec1d37fd30e6262f69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "html_url": "https://github.com/rust-lang/rust/commit/097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcaddeeb23544eb2c86b600c3d775e2773758c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcaddeeb23544eb2c86b600c3d775e2773758c2", "html_url": "https://github.com/rust-lang/rust/commit/4bcaddeeb23544eb2c86b600c3d775e2773758c2"}], "stats": {"total": 143, "additions": 67, "deletions": 76}, "files": [{"sha": "6ee9e2e9754ced7799883f31b43fb3c23e92d9e5", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -798,57 +798,55 @@ fn walk_parents<'tcx>(\n                     }),\n                 ExprKind::MethodCall(_, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n-                    std::iter::once(receiver)\n-                        .chain(args.iter())\n-                        .position(|arg| arg.hir_id == child_id)\n-                        .map(|i| {\n-                            if i == 0 {\n-                                // Check for calls to trait methods where the trait is implemented on a reference.\n-                                // Two cases need to be handled:\n-                                // * `self` methods on `&T` will never have auto-borrow\n-                                // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n-                                //   priority.\n-                                if e.hir_id != child_id {\n-                                Position::ReborrowStable(precedence)\n-                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n-                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n-                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n-                                && let subs = match cx\n-                                    .typeck_results()\n-                                    .node_substs_opt(parent.hir_id)\n-                                    .and_then(|subs| subs.get(1..))\n-                                {\n-                                    Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n-                                } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n-                                    // Trait methods taking `&self`\n-                                    sub_ty\n-                                } else {\n-                                    // Trait methods taking `self`\n-                                    arg_ty\n-                                } && impl_ty.is_ref()\n-                                && cx.tcx.infer_ctxt().enter(|infcx|\n-                                    infcx\n-                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                        .must_apply_modulo_regions()\n-                                )\n+                    if receiver.hir_id == child_id {\n+                        // Check for calls to trait methods where the trait is implemented on a reference.\n+                        // Two cases need to be handled:\n+                        // * `self` methods on `&T` will never have auto-borrow\n+                        // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                        //   priority.\n+                        if e.hir_id != child_id {\n+                            return Some(Position::ReborrowStable(precedence))\n+                        } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                            && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                            && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                            && let subs = match cx\n+                                .typeck_results()\n+                                .node_substs_opt(parent.hir_id)\n+                                .and_then(|subs| subs.get(1..))\n                             {\n-                                Position::MethodReceiverRefImpl\n+                                Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n+                                None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n+                            } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                // Trait methods taking `&self`\n+                                sub_ty\n                             } else {\n-                                Position::MethodReceiver\n-                            }\n+                                // Trait methods taking `self`\n+                                arg_ty\n+                            } && impl_ty.is_ref()\n+                            && cx.tcx.infer_ctxt().enter(|infcx|\n+                                infcx\n+                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                    .must_apply_modulo_regions()\n+                            )\n+                        {\n+                            return Some(Position::MethodReceiverRefImpl)\n+                        } else {\n+                            return Some(Position::MethodReceiver)\n+                        }\n+                    }\n+                    args.iter()\n+                        .position(|arg| arg.hir_id == child_id)\n+                        .map(|i| {\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                            if let ty::Param(param_ty) = ty.kind() {\n+                                needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n                             } else {\n-                                let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n-                                if let ty::Param(param_ty) = ty.kind() {\n-                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n-                                } else {\n-                                    ty_auto_deref_stability(\n-                                        cx,\n-                                        cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                        precedence,\n-                                    )\n-                                    .position_for_arg()\n-                                }\n+                                ty_auto_deref_stability(\n+                                    cx,\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n+                                    precedence,\n+                                )\n+                                .position_for_arg()\n                             }\n                         })\n                 },"}, {"sha": "d55a8e1ead17d11eb02f135c361010dca7fb9a2c", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n             Finite => {\n                 return;\n-            },\n+            }\n         };\n         span_lint(cx, lint, expr.span, msg);\n     }\n@@ -229,11 +229,9 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                     return MaybeInfinite.and(is_infinite(cx, receiver));\n                 }\n             }\n-            if method.ident.name == sym!(last) {\n-                let not_double_ended = cx\n-                    .tcx\n-                    .get_diagnostic_item(sym::DoubleEndedIterator)\n-                    .map_or(false, |id| {\n+            if method.ident.name == sym!(last) && args.is_empty() {\n+                let not_double_ended =\n+                    cx.tcx.get_diagnostic_item(sym::DoubleEndedIterator).map_or(false, |id| {\n                         !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {"}, {"sha": "3cbdaff407b04383f07bf24c84dfb71d52bed93d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -370,15 +370,15 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, receiver, ..), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, receiver, &lit.node, op, compare_to);\n+        check_len(cx, span, method_path.ident.name, receiver, args, &lit.node, op, compare_to);\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n@@ -389,6 +389,7 @@ fn check_len(\n     span: Span,\n     method_name: Symbol,\n     receiver: &Expr<'_>,\n+    args: &[Expr<'_>],\n     lit: &LitKind,\n     op: &str,\n     compare_to: u32,\n@@ -399,7 +400,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == sym::len && has_is_empty(cx, receiver) {\n+        if method_name == sym::len && args.is_empty() && has_is_empty(cx, receiver) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "25a9e6dafea151e427ee385c26ce27643baa9921", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -21,10 +21,7 @@ pub(super) fn check(\n     receiver: &Expr<'_>,\n     args: &[Expr<'_>],\n ) {\n-    let arg = match args {\n-        [] if method_name == sym::clone => receiver,\n-        _ => return,\n-    };\n+    let arg = if method_name == sym::clone && args.is_empty() { receiver } else { return };\n     if cx\n         .typeck_results()\n         .type_dependent_def_id(expr.hir_id)"}, {"sha": "f82ca8912006180b5b853dd57f8af0538c423976", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -20,8 +20,7 @@ pub(super) fn check(\n     if !(args.is_empty() && method_name == sym::clone) {\n         return;\n     }\n-    let arg = receiver;\n-    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+    let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -34,7 +33,7 @@ pub(super) fn check(\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+        let snippet = snippet_with_macro_callsite(cx, receiver.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,"}, {"sha": "fc9ba15d82a40e4e00f59c35ef8c378c43e28847", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -3381,7 +3381,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, recv, [args @ ..], span)) = method_call(expr) {\n+        if let Some((name, recv, args, span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3485,7 +3485,7 @@ impl Methods {\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3500,7 +3500,7 @@ impl Methods {\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, recv2, [args @ ..], span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3520,7 +3520,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3593,7 +3593,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }"}, {"sha": "44b21e7b080d22c6aa8c8654ceb76b226ccba6d2", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -109,14 +109,12 @@ fn fetch_const<'a>(\n     args: &'a [Expr<'a>],\n     m: MinMax,\n ) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if (receiver.is_some() && args.len() != 1) || (receiver.is_none() && args.len() != 2) {\n+    let mut args = receiver.into_iter().chain(args.into_iter());\n+    let arg0 = args.next()?;\n+    let arg1 = args.next()?;\n+    if args.next().is_some() {\n         return None;\n     }\n-    let (arg0, arg1) = if let Some(receiver) = receiver {\n-        (receiver, &args[0])\n-    } else {\n-        (&args[0], &args[1])\n-    };\n     constant_simple(cx, cx.typeck_results(), arg0).map_or_else(\n         || constant_simple(cx, cx.typeck_results(), arg1).map(|c| (m, c, arg0)),\n         |c| {"}, {"sha": "cfc181e435b9c9da1068a6d642a16d4d9f789b71", "filename": "clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/097ef517fedd6c1c9ab4d35309b83e6b62ab703c/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=097ef517fedd6c1c9ab4d35309b83e6b62ab703c", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     ..\n                                 },\n                                 self_arg,\n-                                [remaining_args @ ..],\n+                                remaining_args,\n                                 _,\n                             ) => {\n                                 let method_name = method_name_ident.name.as_str();"}]}