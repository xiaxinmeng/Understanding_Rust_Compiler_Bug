{"sha": "4d669036f3264403f1663b14997a1e30db7b7e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjY5MDM2ZjMyNjQ0MDNmMTY2M2IxNDk5N2ExZTMwZGI3YjdlNzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-26T23:24:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T01:32:34Z"}, "message": "Add more std documentation", "tree": {"sha": "1d232920316333cbf8ccb287cf29f9756b60a3be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d232920316333cbf8ccb287cf29f9756b60a3be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d669036f3264403f1663b14997a1e30db7b7e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d669036f3264403f1663b14997a1e30db7b7e73", "html_url": "https://github.com/rust-lang/rust/commit/4d669036f3264403f1663b14997a1e30db7b7e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d669036f3264403f1663b14997a1e30db7b7e73/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b75e5c315f00e6a10b1eca0a2f501107fd8063e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b75e5c315f00e6a10b1eca0a2f501107fd8063e", "html_url": "https://github.com/rust-lang/rust/commit/1b75e5c315f00e6a10b1eca0a2f501107fd8063e"}], "stats": {"total": 944, "additions": 861, "deletions": 83}, "files": [{"sha": "32e39f85abcb3d1fbaf05d9c0ce563da4bc9423d", "filename": "doc/Topics.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/doc%2FTopics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/doc%2FTopics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FTopics.txt?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -145,10 +145,10 @@ Topic Type: Variant\n    Keywords:\n       variant, variants\n \n-#Alter Topic Type: Type\n+Alter Topic Type: Type\n \n-#    Keywords:\n-#       tag, tags\n+    Keywords:\n+       resource, resources\n \n Topic Type: Predicate\n "}, {"sha": "49f029052d664b0ebbd1ec058069f4eadf6ec8e2", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,3 +1,9 @@\n+/*\n+Module: os\n+\n+TODO: Restructure and document\n+*/\n+\n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n native \"cdecl\" mod libc = \"\" {"}, {"sha": "5f35d0d06d789f4ad2fba64d4ee283d92cf92a32", "filename": "src/lib/math.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -10,15 +10,72 @@ native \"llvm\" mod llvm {\n     fn atan(n: float) -> float = \"atan.f64\";\n }\n \n+/*\n+Function: sqrt\n+\n+Returns the square root\n+*/\n fn sqrt(x: float) -> float { llvm::sqrt(x) }\n+\n+/*\n+Function: sin\n+\n+Returns the sine of an angle\n+*/\n fn sin(x: float) -> float { llvm::sin(x) }\n+\n+/*\n+Function: cos\n+\n+Returns the cosine of an angle\n+*/\n fn cos(x: float) -> float { llvm::cos(x) }\n+\n+/*\n+Function: tan\n+\n+Returns the tangent of an angle\n+*/\n fn tan(x: float) -> float { llvm::tan(x) }\n+\n+/*\n+Function: asin\n+\n+Returns the arcsine of an angle\n+*/\n fn asin(x: float) -> float { llvm::asin(x) }\n+\n+/*\n+Function: acos\n+\n+Returns the arccosine of an angle\n+*/\n fn acos(x: float) -> float { llvm::acos(x) }\n+\n+/*\n+Function: atan\n+\n+Returns the arctangent of an angle\n+*/\n fn atan(x: float) -> float { llvm::atan(x) }\n \n+/*\n+Const: pi\n+\n+Archimedes' constant\n+*/\n const pi: float = 3.141592653589793;\n \n+/*\n+Function: min\n+\n+Returns the minimum of two values\n+*/\n fn min<T>(x: T, y: T) -> T { x < y ? x : y }\n+\n+/*\n+Function: max\n+\n+Returns the maximum of two values\n+*/\n fn max<T>(x: T, y: T) -> T { x < y ? y : x }"}, {"sha": "5ee7cfa602c49d7cbcb0a05eaa99dc70e5f9648b", "filename": "src/lib/net.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,8 +1,33 @@\n+/*\n+Module: net\n+*/\n+\n import vec;\n import uint;\n \n-tag ip_addr { ipv4(u8, u8, u8, u8); }\n+/* Section: Types */\n+\n+/*\n+Tag: ip_addr\n+\n+An IP address\n+*/\n+tag ip_addr {\n+    /*\n+    Variant: ipv4\n+\n+    An IPv4 address\n+    */\n+    ipv4(u8, u8, u8, u8);\n+}\n+\n+/* Section: Operations */\n \n+/*\n+Function: format_addr\n+\n+Convert an <ip_addr> to a str\n+*/\n fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n       ipv4(a, b, c, d) {\n@@ -12,6 +37,17 @@ fn format_addr(ip: ip_addr) -> str {\n     }\n }\n \n+/*\n+Function: parse_addr\n+\n+Convert a str to <ip_addr>\n+\n+Converts a string of the format \"x.x.x.x\" into an ip_addr tag.\n+\n+Failure:\n+\n+String must be a valid IPv4 address\n+*/\n fn parse_addr(ip: str) -> ip_addr {\n     let parts = vec::map({|s| uint::from_str(s) }, str::split(ip, \".\"[0]));\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }"}, {"sha": "2980113b6c8af10c373d67732a77d8790c02631d", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,4 +1,3 @@\n-\n native \"c-stack-cdecl\" mod rustrt {\n     fn rust_list_files(path: str) -> [str];\n }"}, {"sha": "35644ab840b14838f0b7b71c6103c8591c70396b", "filename": "src/lib/ptr.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fptr.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,13 +1,32 @@\n-// Unsafe pointer utility functions.\n+/*\n+Module: ptr\n \n+Unsafe pointer utility functions\n+*/\n native \"rust-intrinsic\" mod rusti {\n     fn addr_of<T>(val: T) -> *mutable T;\n     fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n }\n \n+/*\n+Function: addr_of\n+\n+Get an unsafe pointer to a value\n+*/\n fn addr_of<T>(val: T) -> *mutable T { ret rusti::addr_of(val); }\n+\n+/*\n+Function: offset\n+\n+Calculate the offset from a pointer\n+*/\n fn offset<T>(ptr: *T, count: uint) -> *T {\n     ret rusti::ptr_offset(ptr, count);\n }\n \n+/*\n+Function: null\n+\n+Create an unsafe null pointer\n+*/\n fn null<T>() -> *T { ret unsafe::reinterpret_cast(0u); }"}, {"sha": "df265a0c7efa8ca6ffe6379a5ddc4252890e7579", "filename": "src/lib/rand.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,24 +1,47 @@\n+/*\n+Module: rand\n \n-\n-\n-/**\n- * Bindings the runtime's random number generator (ISAAC).\n- */\n+Random number generation\n+*/\n native \"c-stack-cdecl\" mod rustrt {\n     type rctx;\n     fn rand_new() -> rctx;\n     fn rand_next(c: rctx) -> u32;\n     fn rand_free(c: rctx);\n }\n \n-type rng =\n-    obj {\n-        fn next() -> u32;\n-        fn next_float() -> float;\n-    };\n+/* Section: Types */\n+\n+/*\n+Obj: rng\n+\n+A random number generator\n+*/\n+type rng = obj {\n+    /*\n+    Method: next\n+\n+    Return the next random integer\n+    */\n+    fn next() -> u32;\n+\n+    /*\n+    Method: next_float\n+\n+    Return the next random float\n+    */\n+    fn next_float() -> float;\n+};\n \n resource rand_res(c: rustrt::rctx) { rustrt::rand_free(c); }\n \n+/* Section: Operations */\n+\n+/*\n+Function: mk_rng\n+\n+Create a random number generator\n+*/\n fn mk_rng() -> rng {\n     obj rt_rng(c: @rand_res) {\n         fn next() -> u32 { ret rustrt::rand_next(**c); }"}, {"sha": "e4913b54184fde12dce68fc5d24f2a891e33d73e", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 174, "deletions": 38, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,4 +1,8 @@\n+/*\n+Module: run\n \n+Process spawning\n+*/\n import str::sbuf;\n \n export program;\n@@ -13,13 +17,102 @@ native \"c-stack-cdecl\" mod rustrt {\n        int;\n }\n \n+/* Section: Types */\n+\n+/*\n+Resource: program_res\n+\n+A resource that manages the destruction of a <program> object\n+\n+program_res ensures that the destroy method is called on a\n+program object in order to close open file descriptors.\n+*/\n+resource program_res(p: program) { p.destroy(); }\n+\n+/*\n+Obj: program\n+\n+An object representing a child process\n+*/\n+type program = obj {\n+    /*\n+    Method: get_id\n+\n+    Returns the process id of the program\n+    */\n+    fn get_id() -> int;\n+\n+    /*\n+    Method: input\n+\n+    Returns an io::writer that can be used to write to stdin\n+    */\n+    fn input() -> io::writer;\n+\n+    /*\n+    Method: output\n+\n+    Returns an io::reader that can be used to read from stdout\n+    */\n+    fn output() -> io::reader;\n+\n+    /*\n+    Method: err\n+\n+    Returns an io::reader that can be used to read from stderr\n+    */\n+    fn err() -> io::reader;\n+\n+    /*\n+    Method: close_input\n+\n+    Closes the handle to the child processes standard input\n+    */\n+    fn close_input();\n+\n+    /*\n+    Method: finish\n+\n+    Waits for the child process to terminate. Closes the handle\n+    to stdin if necessary.\n+    */\n+    fn finish() -> int;\n+\n+    /*\n+    Method: destroy\n+\n+    Closes open handles\n+    */\n+    fn destroy();\n+};\n+\n+\n+/* Section: Operations */\n+\n fn arg_vec(prog: str, args: [@str]) -> [sbuf] {\n     let argptrs = str::as_buf(prog, {|buf| [buf] });\n     for arg in args { argptrs += str::as_buf(*arg, {|buf| [buf] }); }\n     argptrs += [unsafe::reinterpret_cast(0)];\n     ret argptrs;\n }\n \n+/*\n+Function: spawn_process\n+\n+Run a program, providing stdin, stdout and stderr handles\n+\n+Parameters:\n+\n+prog - The path to an executable\n+args - Vector of arguments to pass to the child process\n+in_fd - A file descriptor for the child to use as std input\n+out_fd - A file descriptor for the child to use as std output\n+err_fd - A file descriptor for the child to use as std error\n+\n+Returns:\n+\n+The process id of the spawned process\n+*/\n fn spawn_process(prog: str, args: [str], in_fd: int, out_fd: int, err_fd: int)\n    -> int unsafe {\n     // Note: we have to hold on to these vector references while we hold a\n@@ -33,23 +126,42 @@ fn spawn_process(prog: str, args: [str], in_fd: int, out_fd: int, err_fd: int)\n     ret pid;\n }\n \n+/*\n+Function: run_program\n+\n+Spawns a process and waits for it to terminate\n+\n+Parameters:\n+\n+prog - The path to an executable\n+args - Vector of arguments to pass to the child process\n+\n+Returns:\n+\n+The process id\n+*/\n fn run_program(prog: str, args: [str]) -> int {\n     ret waitpid(spawn_process(prog, args, 0, 0, 0));\n }\n \n-type program =\n-    obj {\n-        fn get_id() -> int;\n-        fn input() -> io::writer;\n-        fn output() -> io::reader;\n-        fn err() -> io::reader;\n-        fn close_input();\n-        fn finish() -> int;\n-        fn destroy();\n-    };\n+/*\n+Function: start_program\n \n-resource program_res(p: program) { p.destroy(); }\n+Spawns a process and returns a boxed <program_res>\n+\n+The returned value is a boxed resource containing a <program> object that can\n+be used for sending and recieving data over the standard file descriptors.\n+The resource will ensure that file descriptors are closed properly.\n+\n+Parameters:\n+\n+prog - The path to an executable\n+args - Vector of arguments to pass to the child process\n+\n+Returns:\n \n+A boxed resource of <program>\n+*/\n fn start_program(prog: str, args: [str]) -> @program_res {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n@@ -110,6 +222,22 @@ fn read_all(rd: io::reader) -> str {\n     ret buf;\n }\n \n+/*\n+Function: program_output\n+\n+Spawns a process, waits for it to exit, and returns the exit code, and\n+contents of stdout and stderr.\n+\n+Parameters:\n+\n+prog - The path to an executable\n+args - Vector of arguments to pass to the child process\n+\n+Returns:\n+\n+A record, {status: int, out: str, err: str} containing the exit code,\n+the contents of stdout and the contents of stderr.\n+*/\n fn program_output(prog: str, args: [str]) ->\n    {status: int, out: str, err: str} {\n     let pr = start_program(prog, args);\n@@ -119,41 +247,49 @@ fn program_output(prog: str, args: [str]) ->\n     ret {status: pr.finish(), out: out, err: err};\n }\n \n-/* Returns an exit status */\n-#[cfg(target_os = \"win32\")]\n-fn waitpid(pid: int) -> int {\n-    os::waitpid(pid)\n-}\n+/*\n+Function: waitpid\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n+Waits for a process to exit and returns the exit code\n+*/\n fn waitpid(pid: int) -> int {\n-    #[cfg(target_os = \"linux\")]\n-    fn WIFEXITED(status: int) -> bool {\n-        (status & 0xff) == 0\n-    }\n+    ret waitpid_os(pid);\n \n-    #[cfg(target_os = \"macos\")]\n-    fn WIFEXITED(status: int) -> bool {\n-        (status & 0x7f) == 0\n+    #[cfg(target_os = \"win32\")]\n+    fn waitpid_os(pid: int) -> int {\n+        os::waitpid(pid)\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn WEXITSTATUS(status: int) -> int {\n-        (status >> 8) & 0xff\n-    }\n-\n     #[cfg(target_os = \"macos\")]\n-    fn WEXITSTATUS(status: int) -> int {\n-        status >> 8\n-    }\n+    fn waitpid_os(pid: int) -> int {\n+        #[cfg(target_os = \"linux\")]\n+        fn WIFEXITED(status: int) -> bool {\n+            (status & 0xff) == 0\n+        }\n \n-    let status = os::waitpid(pid);\n-    ret if WIFEXITED(status) {\n-        WEXITSTATUS(status)\n-    } else {\n-        1\n-    };\n+        #[cfg(target_os = \"macos\")]\n+        fn WIFEXITED(status: int) -> bool {\n+            (status & 0x7f) == 0\n+        }\n+\n+        #[cfg(target_os = \"linux\")]\n+        fn WEXITSTATUS(status: int) -> int {\n+            (status >> 8) & 0xff\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        fn WEXITSTATUS(status: int) -> int {\n+            status >> 8\n+        }\n+\n+        let status = os::waitpid(pid);\n+        ret if WIFEXITED(status) {\n+            WEXITSTATUS(status)\n+        } else {\n+            1\n+        };\n+    }\n }\n \n // Local Variables:"}, {"sha": "323f37f4a4a7d8b3bd2632430a5e14c7a88206f2", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 63, "deletions": 16, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,3 +1,19 @@\n+/*\n+Module: sha1\n+\n+An implementation of the SHA-1 cryptographic hash.\n+\n+First create a <sha1> object using the <mk_sha1> constructor, then\n+feed it input using the <input> or <input_str> methods, which may be\n+called any number of times.\n+\n+After the entire input has been fed to the hash read the result using\n+the <result> or <result_str> methods.\n+\n+The <sha1> object may be reused to create multiple hashes by calling\n+the <reset> method.\n+*/\n+\n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n  * implementation, which is written for clarity, not speed. At some\n@@ -6,22 +22,49 @@\n export sha1;\n export mk_sha1;\n \n-type sha1 =\n-    // Provide message input as bytes\n-    // Provide message input as string\n-    // Read the digest as a vector of 20 bytes. After calling this no further\n-    // input may provided until reset is called\n-    // Same as above, just a hex-string version.\n-    // Reset the sha1 state for reuse. This is called\n-    // automatically during construction\n-    obj {\n-        fn input([u8]);\n-        fn input_str(str);\n-        fn result() -> [u8];\n-        fn result_str() -> str;\n-        fn reset();\n-    };\n+/* Section: Types */\n \n+/*\n+Obj: sha1\n+\n+The SHA-1 object\n+*/\n+type sha1 = obj {\n+    /*\n+    Method: input\n+\n+    Provide message input as bytes\n+    */\n+    fn input([u8]);\n+    /*\n+    Method: input_str\n+\n+    Provide message input as string\n+    */\n+    fn input_str(str);\n+    /*\n+    Method: result\n+\n+    Read the digest as a vector of 20 bytes. After calling this no further\n+    input may be provided until reset is called.\n+    */\n+    fn result() -> [u8];\n+    /*\n+    Method: result_str\n+\n+    Read the digest as a hex string. After calling this no further\n+    input may be provided until reset is called.\n+    */\n+    fn result_str() -> str;\n+    /*\n+    Method: reset\n+\n+    Reset the SHA-1 state for reuse\n+    */\n+    fn reset();\n+};\n+\n+/* Section: Operations */\n \n // Some unexported constants\n const digest_buf_len: uint = 5u;\n@@ -33,7 +76,11 @@ const k2: u32 = 0x8F1BBCDCu32;\n const k3: u32 = 0xCA62C1D6u32;\n \n \n-// Builds a sha1 object\n+/*\n+Function: mk_sha1\n+\n+Construct a <sha1> object\n+*/\n fn mk_sha1() -> sha1 {\n     type sha1state =\n         {h: [mutable u32],"}, {"sha": "f9e59820294f5fb5984842fb4d8ed2117802cb1c", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,38 +1,76 @@\n+/*\n+Module: smallintmap\n \n-\n-/// A simple map based on a vector for small integer keys. Space requirements\n-/// are O(highest integer key).\n+A simple map based on a vector for small integer keys. Space requirements\n+are O(highest integer key).\n+*/\n import option::{some, none};\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n+/*\n+Type: smallintmap\n+*/\n type smallintmap<T> = @{mutable v: [mutable option::t<T>]};\n \n+/*\n+Function: mk\n+\n+Create a smallintmap\n+*/\n fn mk<T>() -> smallintmap<T> {\n     let v: [mutable option::t<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n+/*\n+Function: insert\n+\n+Add a value to the map. If the map already contains a value for\n+the specified key then the original value is replaced.\n+*/\n fn insert<T>(m: smallintmap<T>, key: uint, val: T) {\n     vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n+/*\n+Function: find\n+\n+Get the value for the specified key. If the key does not exist\n+in the map then returns none.\n+*/\n fn find<T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n \n+/*\n+Method: get\n+\n+Get the value for the specified key\n+\n+Failure:\n+\n+If the key does not exist in the map\n+*/\n fn get<T>(m: smallintmap<T>, key: uint) -> T {\n     alt find::<T>(m, key) {\n       none::<T>. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some::<T>(v) { ret v; }\n     }\n }\n \n+/*\n+Method: contains_key\n+\n+Returns true if the map contains a value for the specified key\n+*/\n fn contains_key<T>(m: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find::<T>(m, key));\n }\n \n+// FIXME: Are these really useful?\n+\n fn truncate<T>(m: smallintmap<T>, len: uint) {\n     m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n }"}, {"sha": "6d4ead4c429935ac7b61380d327adb4ea8cb9f19", "filename": "src/lib/sort.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,12 +1,25 @@\n+/*\n+Module: sort\n \n+Sorting methods\n+*/\n import vec::{len, slice};\n \n export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n+/* Type: lteq */\n type lteq<T> = block(T, T) -> bool;\n \n+/*\n+Function: merge_sort\n+\n+Merge sort. Returns a new vector containing the sorted list.\n+\n+Has worst case O(n log n) performance, best case O(n), but\n+is not space efficient. This is a stable sort.\n+*/\n fn merge_sort<T>(le: lteq<T>, v: [T]) -> [T] {\n     fn merge<T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n         let rs: [T] = [];\n@@ -68,16 +81,19 @@ fn qsort<T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n     }\n }\n \n+/*\n+Function: quick_sort\n+\n+Quicksort. Sorts a mutable vector in place.\n+\n+Has worst case O(n^2) performance, average case O(n log n).\n+This is an unstable sort.\n+*/\n fn quick_sort<T>(compare_func: lteq<T>, arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n-\n-// Based on algorithm presented by Sedgewick and Bentley here:\n-// http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n-// According to these slides this is the algorithm of choice for\n-// 'randomly ordered keys, abstract compare' & 'small number of key values'\n fn qsort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n               arr: [mutable T], left: int, right: int) {\n     if right <= left { ret; }\n@@ -126,6 +142,19 @@ fn qsort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n+// FIXME: This should take lt and eq types\n+/*\n+Function: quick_sort3\n+\n+Fancy quicksort. Sorts a mutable vector in place.\n+\n+Based on algorithm presented by Sedgewick and Bentley\n+<http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf>.\n+According to these slides this is the algorithm of choice for\n+'randomly ordered keys, abstract compare' & 'small number of key values'.\n+\n+This is an unstable sort.\n+*/\n fn quick_sort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n                   arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }"}, {"sha": "1b759ffb8cfd82b0cfce3663c2ced61540c7bee3", "filename": "src/lib/str.rs", "status": "modified", "additions": 356, "deletions": 2, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,3 +1,9 @@\n+/*\n+Module: str\n+\n+String manipulation.\n+*/\n+\n export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len, index,\n        rindex, find, starts_with, ends_with, substr, slice, split, concat,\n        connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n@@ -11,10 +17,25 @@ native \"c-stack-cdecl\" mod rustrt {\n     fn rust_str_push(&s: str, ch: u8);\n }\n \n+/*\n+Function: eq\n+\n+Bytewise string equality\n+*/\n fn eq(&&a: str, &&b: str) -> bool { a == b }\n \n+/*\n+Function: lteq\n+\n+Bytewise less than or equal\n+*/\n fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n \n+/*\n+Function: hash\n+\n+String hash function\n+*/\n fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n@@ -38,6 +59,11 @@ const tag_five_b: uint = 248u;\n const max_five_b: uint = 67108864u;\n const tag_six_b: uint = 252u;\n \n+/*\n+Function: is_utf8\n+\n+Determines if a vector uf bytes contains valid UTF-8\n+*/\n fn is_utf8(v: [u8]) -> bool {\n     let i = 0u;\n     let total = vec::len::<u8>(v);\n@@ -55,28 +81,52 @@ fn is_utf8(v: [u8]) -> bool {\n     ret true;\n }\n \n+/*\n+Function: is_ascii\n+\n+Determines if a string contains only ASCII characters\n+*/\n fn is_ascii(s: str) -> bool {\n     let i: uint = byte_len(s);\n     while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n     ret true;\n }\n \n-/// Returns true if the string has length 0\n+/*\n+Predicate: is_empty\n+\n+Returns true if the string has length 0\n+*/\n pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n \n-/// Returns true if the string has length greater than 0\n+/*\n+Predicate: is_not_empty\n+\n+Returns true if the string has length greater than 0\n+*/\n pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n \n+/*\n+Function: is_whitespace\n+\n+Returns true if the string contains only whitespace\n+*/\n fn is_whitespace(s: str) -> bool {\n     let i = 0u;\n     let len = char_len(s);\n     while i < len {\n+        // FIXME: This is not how char_at works\n         if !char::is_whitespace(char_at(s, i)) { ret false; }\n         i += 1u;\n     }\n     ret true;\n }\n \n+/*\n+Function: byte_len\n+\n+Returns the length in bytes of a string\n+*/\n fn byte_len(s: str) -> uint {\n     let v: [u8] = unsafe::reinterpret_cast(s);\n     let vlen = vec::len(v);\n@@ -86,20 +136,37 @@ fn byte_len(s: str) -> uint {\n     ret vlen - 1u;\n }\n \n+/*\n+Function: bytes\n+\n+Converts a string to a vector of bytes\n+*/\n fn bytes(s: str) -> [u8] {\n     let v = unsafe::reinterpret_cast(s);\n     let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n     unsafe::leak(v);\n     ret vcopy;\n }\n \n+/*\n+Function: unsafe_from_bytes\n+\n+Converts a vector of bytes to a string. Does not verify that the\n+vector contains valid UTF-8.\n+*/\n fn unsafe_from_bytes(v: [mutable? u8]) -> str {\n     let vcopy: [u8] = v + [0u8];\n     let scopy: str = unsafe::reinterpret_cast(vcopy);\n     unsafe::leak(vcopy);\n     ret scopy;\n }\n \n+/*\n+Function: unsafe_from_byte\n+\n+Converts a byte to a string. Does not verify that the byte is\n+valid UTF-8.\n+*/\n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n fn push_utf8_bytes(&s: str, ch: char) {\n@@ -131,18 +198,33 @@ fn push_utf8_bytes(&s: str, ch: char) {\n     push_bytes(s, bytes);\n }\n \n+/*\n+Function: from_char\n+\n+Convert a char to a string\n+*/\n fn from_char(ch: char) -> str {\n     let buf = \"\";\n     push_utf8_bytes(buf, ch);\n     ret buf;\n }\n \n+/*\n+Function: from_chars\n+\n+Convert a vector of chars to a string\n+*/\n fn from_chars(chs: [char]) -> str {\n     let buf = \"\";\n     for ch: char in chs { push_utf8_bytes(buf, ch); }\n     ret buf;\n }\n \n+/*\n+Function: utf8_char_width\n+\n+FIXME: What does this function do?\n+*/\n fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { ret 1u; }\n@@ -157,6 +239,37 @@ fn utf8_char_width(b: u8) -> uint {\n     ret 6u;\n }\n \n+/*\n+Function: char_range_at\n+\n+Pluck a character out of a string and return the index of the next character.\n+This function can be used to iterate over the unicode characters of a string.\n+\n+Example:\n+\n+> let s = \"Clam chowder, hot sauce, pork rinds\";\n+> let i = 0;\n+> while i < len(s) {\n+>   let {ch, next} = char_range_at(s, i);\n+>   log ch;\n+>   i = next;\n+> }\n+\n+Parameters:\n+\n+s - The string\n+i - The byte offset of the char to extract\n+\n+Returns:\n+\n+A record {ch: char, next: uint} containing the char value and the byte\n+index of the next unicode character.\n+\n+Failure:\n+\n+If `i` is greater than or equal to the length of the string.\n+If `i` is not the index of the beginning of a valid UTF-8 character.\n+*/\n fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n@@ -179,8 +292,18 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n+/*\n+Function: char_at\n+\n+Pluck a character out of a string\n+*/\n fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n+/*\n+Function: char_len\n+\n+Count the number of unicode characters in a string\n+*/\n fn char_len(s: str) -> uint {\n     let i = 0u;\n     let len = 0u;\n@@ -195,6 +318,11 @@ fn char_len(s: str) -> uint {\n     ret len;\n }\n \n+/*\n+Function: to_chars\n+\n+Convert a string to a vector of characters\n+*/\n fn to_chars(s: str) -> [char] {\n     let buf: [char] = [];\n     let i = 0u;\n@@ -207,8 +335,22 @@ fn to_chars(s: str) -> [char] {\n     ret buf;\n }\n \n+/*\n+Function: push_char\n+\n+Append a character to a string\n+*/\n fn push_char(&s: str, ch: char) { s += from_char(ch); }\n \n+/*\n+Function: pop_char\n+\n+Remove the final character from a string and return it.\n+\n+Failure:\n+\n+If the string does not contain any characters.\n+*/\n fn pop_char(&s: str) -> char {\n     let end = byte_len(s);\n     while end > 0u && s[end - 1u] & 192u8 == tag_cont_u8 { end -= 1u; }\n@@ -218,26 +360,67 @@ fn pop_char(&s: str) -> char {\n     ret ch;\n }\n \n+/*\n+Function: shift_char\n+\n+Remove the first character from a string and return it.\n+\n+Failure:\n+\n+If the string does not contain any characters.\n+*/\n fn shift_char(&s: str) -> char {\n     let r = char_range_at(s, 0u);\n     s = substr(s, r.next, byte_len(s) - r.next);\n     ret r.ch;\n }\n \n+/*\n+Function: unshift_char\n+\n+Prepend a char to a string\n+*/\n fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n+/*\n+Function: index\n+\n+Returns the index of the first matching byte. Returns -1 if\n+no match is found.\n+*/\n fn index(s: str, c: u8) -> int {\n     let i: int = 0;\n     for k: u8 in s { if k == c { ret i; } i += 1; }\n     ret -1;\n }\n \n+/*\n+Function: rindex\n+\n+Returns the index of the last matching byte. Returns -1\n+if no match is found.\n+*/\n fn rindex(s: str, c: u8) -> int {\n     let n: int = byte_len(s) as int;\n     while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n     ret n;\n }\n \n+/*\n+Function: find\n+\n+Finds the index of the first matching substring.\n+Returns -1 if `haystack` does not contain `needle`.\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+\n+Returns:\n+\n+The index of the first occurance of `needle`, or -1 if not found.\n+*/\n fn find(haystack: str, needle: str) -> int {\n     let haystack_len: int = byte_len(haystack) as int;\n     let needle_len: int = byte_len(needle) as int;\n@@ -255,10 +438,30 @@ fn find(haystack: str, needle: str) -> int {\n     ret -1;\n }\n \n+/*\n+Function: contains\n+\n+Returns true if one string contains another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n fn contains(haystack: str, needle: str) -> bool {\n     0 <= find(haystack, needle)\n }\n \n+/*\n+Function: starts_with\n+\n+Returns true if one string starts with another\n+\n+Parameters:\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n fn starts_with(haystack: str, needle: str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n@@ -267,6 +470,14 @@ fn starts_with(haystack: str, needle: str) -> bool {\n     ret eq(substr(haystack, 0u, needle_len), needle);\n }\n \n+/*\n+Function: ends_with\n+\n+Returns true if one string ends with another\n+\n+haystack - The string to look in\n+needle - The string to look for\n+*/\n fn ends_with(haystack: str, needle: str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n@@ -280,10 +491,35 @@ fn ends_with(haystack: str, needle: str) -> bool {\n         };\n }\n \n+/*\n+Function: substr\n+\n+Take a substring of another. Returns a string containing `len` bytes\n+starting at byte offset `begin`.\n+\n+This function is not unicode-safe.\n+\n+Failure:\n+\n+If `begin` + `len` is is greater than the byte length of the string\n+*/\n fn substr(s: str, begin: uint, len: uint) -> str {\n     ret slice(s, begin, begin + len);\n }\n \n+/*\n+Function: slice\n+\n+Takes a bytewise slice from a string. Returns the substring from\n+[`begin`..`end`).\n+\n+This function is not unicode-safe.\n+\n+Failure:\n+\n+- If begin is greater than end.\n+- If end is greater than the length of the string.\n+*/\n fn slice(s: str, begin: uint, end: uint) -> str {\n     // FIXME: Typestate precondition\n     assert (begin <= end);\n@@ -298,12 +534,22 @@ fn slice(s: str, begin: uint, end: uint) -> str {\n     ret s2;\n }\n \n+/*\n+Function: safe_slice\n+*/\n fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n     // would need some magic to make this a precondition\n     assert (end <= byte_len(s));\n     ret slice(s, begin, end);\n }\n \n+/*\n+Function: shift_byte\n+\n+Removes the first byte from a string and returns it.\n+\n+This function is not unicode-safe.\n+*/\n fn shift_byte(&s: str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n@@ -312,6 +558,13 @@ fn shift_byte(&s: str) -> u8 {\n     ret b;\n }\n \n+/*\n+Function: pop_byte\n+\n+Removes the last byte from a string and returns it.\n+\n+This function is not unicode-safe.\n+*/\n fn pop_byte(&s: str) -> u8 {\n     let len = byte_len(s);\n     assert (len > 0u);\n@@ -320,12 +573,35 @@ fn pop_byte(&s: str) -> u8 {\n     ret b;\n }\n \n+/*\n+Function: push_byte\n+\n+Appends a byte to a string.\n+\n+This function is not unicode-safe.\n+*/\n fn push_byte(&s: str, b: u8) { rustrt::rust_str_push(s, b); }\n \n+/*\n+Function: push_bytes\n+\n+Appends a vector of bytes to a string.\n+\n+This function is not unicode-safe.\n+*/\n fn push_bytes(&s: str, bytes: [u8]) {\n     for byte in bytes { rustrt::rust_str_push(s, byte); }\n }\n \n+/*\n+Function: split\n+\n+Split a string at each occurance of a given separator\n+\n+Returns:\n+\n+A vector containing all the strings between each occurance of the separator\n+*/\n fn split(s: str, sep: u8) -> [str] {\n     let v: [str] = [];\n     let accum: str = \"\";\n@@ -341,12 +617,22 @@ fn split(s: str, sep: u8) -> [str] {\n     ret v;\n }\n \n+/*\n+Function: concat\n+\n+Concatenate a vector of strings\n+*/\n fn concat(v: [str]) -> str {\n     let s: str = \"\";\n     for ss: str in v { s += ss; }\n     ret s;\n }\n \n+/*\n+Function: connect\n+\n+Concatenate a vector of strings, placing a given separator between each\n+*/\n fn connect(v: [str], sep: str) -> str {\n     let s: str = \"\";\n     let first: bool = true;\n@@ -358,6 +644,11 @@ fn connect(v: [str], sep: str) -> str {\n }\n \n // FIXME: This only handles ASCII\n+/*\n+Function: to_upper\n+\n+Convert a string to uppercase\n+*/\n fn to_upper(s: str) -> str {\n     let outstr = \"\";\n     let ascii_a = 'a' as u8;\n@@ -374,6 +665,21 @@ fn to_upper(s: str) -> str {\n }\n \n // FIXME: This is super-inefficient\n+/*\n+Function: replace\n+\n+Replace all occurances of one string with another\n+\n+Parameters:\n+\n+s - The string containing substrings to replace\n+from - The string to replace\n+to - The replacement string\n+\n+Returns:\n+\n+The original string with all occurances of `from` replaced with `to`\n+*/\n fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n     // FIXME (694): Shouldn't have to check this\n     check (is_not_empty(from));\n@@ -388,10 +694,27 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n }\n \n // FIXME: Also not efficient\n+/*\n+Function: char_slice\n+\n+Unicode-safe slice. Returns a slice of the given string containing\n+the characters in the range [`begin`..`end`). `begin` and `end` are\n+character indexes, not byte indexes.\n+\n+Failure:\n+\n+- If begin is greater than end\n+- If end is greater than the character length of the string\n+*/\n fn char_slice(s: str, begin: uint, end: uint) -> str {\n     from_chars(vec::slice(to_chars(s), begin, end))\n }\n \n+/*\n+Function: trim_left\n+\n+Returns a string with leading whitespace removed.\n+*/\n fn trim_left(s: str) -> str {\n     fn count_whities(s: [char]) -> uint {\n         let i = 0u;\n@@ -406,6 +729,11 @@ fn trim_left(s: str) -> str {\n     ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n+/*\n+Function: trim_right\n+\n+Returns a string with trailing whitespace removed.\n+*/\n fn trim_right(s: str) -> str {\n     fn count_whities(s: [char]) -> uint {\n         let i = vec::len(s);\n@@ -420,8 +748,18 @@ fn trim_right(s: str) -> str {\n     ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n+/*\n+Function: trim\n+\n+Returns a string with leading and trailing whitespace removed\n+*/\n fn trim(s: str) -> str { trim_left(trim_right(s)) }\n \n+/*\n+Type: sbuf\n+\n+An unsafe buffer of bytes. Corresponds to a C char pointer.\n+*/\n type sbuf = *u8;\n \n // NB: This is intentionally unexported because it's easy to misuse (there's\n@@ -433,10 +771,26 @@ unsafe fn buf(s: str) -> sbuf {\n     ret buf;\n }\n \n+/*\n+Function: as_buf\n+\n+Work with the byte buffer of a string. Allows for unsafe manipulation\n+of strings, which is useful for native interop.\n+\n+Example:\n+\n+> let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+\n+*/\n fn as_buf<T>(s: str, f: block(sbuf) -> T) -> T unsafe {\n     let buf = buf(s); f(buf)\n }\n \n+/*\n+Function: str_from_cstr\n+\n+Create a Rust string from a null-terminated C string\n+*/\n unsafe fn str_from_cstr(cstr: sbuf) -> str {\n     let res = \"\";\n     let start = cstr;"}, {"sha": "874694d37c57fc9025d39686ab7a574f8a1b4daa", "filename": "src/lib/sys.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d669036f3264403f1663b14997a1e30db7b7e73/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=4d669036f3264403f1663b14997a1e30db7b7e73", "patch": "@@ -1,7 +1,8 @@\n+/*\n+Module: sys\n \n-//export rustrt;\n-//export size_of;\n-\n+Misc low level stuff\n+*/\n tag type_desc {\n     type_desc(@type_desc);\n }\n@@ -22,30 +23,63 @@ native \"rust-intrinsic\" mod rusti {\n     fn get_type_desc<T>() -> *type_desc;\n }\n \n+/*\n+Function: get_type_desc\n+\n+Returns a pointer to a type descriptor. Useful for calling certain\n+function in the Rust runtime or otherwise performing dark magick.\n+*/\n fn get_type_desc<T>() -> *type_desc {\n     ret rusti::get_type_desc::<T>();\n }\n \n+/*\n+Function: last_os_error\n+\n+Get a string representing the platform-dependent last error\n+*/\n fn last_os_error() -> str {\n     ret rustrt::last_os_error();\n }\n \n+/*\n+Function: size_of\n+\n+Returns the size of a type\n+*/\n fn size_of<T>() -> uint {\n     ret rustrt::size_of(get_type_desc::<T>());\n }\n \n+/*\n+Function: align_of\n+\n+Returns the alignment of a type\n+*/\n fn align_of<T>() -> uint {\n     ret rustrt::align_of(get_type_desc::<T>());\n }\n \n+/*\n+Function: refcount\n+\n+Returns the refcount of a shared box\n+*/\n fn refcount<T>(t: @T) -> uint {\n     ret rustrt::refcount::<T>(t);\n }\n \n+/*\n+Function: do_gc\n+\n+Force a garbage collection\n+*/\n fn do_gc() -> () {\n     ret rustrt::do_gc();\n }\n \n+// FIXME: There's a wrapper for this in the task module and this really\n+// just belongs there\n fn unsupervise() -> () {\n     ret rustrt::unsupervise();\n }"}]}