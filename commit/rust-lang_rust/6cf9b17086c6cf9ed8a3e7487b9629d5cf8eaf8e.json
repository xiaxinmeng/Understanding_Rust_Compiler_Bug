{"sha": "6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZjliMTcwODZjNmNmOWVkOGEzZTc0ODdiOTYyOWQ1Y2Y4ZWFmOGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T09:04:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T22:23:11Z"}, "message": "rustc: Make name resolution errors less fatal\n\nFailure happens at the end of name resolution\n\nIssue #440", "tree": {"sha": "366d68856e3ab2164c64c7150058693596d3942b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366d68856e3ab2164c64c7150058693596d3942b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e", "html_url": "https://github.com/rust-lang/rust/commit/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5238d57eb7d34eae711741ffdef9a4607aa6cb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5238d57eb7d34eae711741ffdef9a4607aa6cb7", "html_url": "https://github.com/rust-lang/rust/commit/c5238d57eb7d34eae711741ffdef9a4607aa6cb7"}], "stats": {"total": 131, "additions": 80, "deletions": 51}, "files": [{"sha": "e8333d09fb08026af973eb892c77c5bed670a02c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 80, "deletions": 51, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6cf9b17086c6cf9ed8a3e7487b9629d5cf8eaf8e", "patch": "@@ -236,8 +236,11 @@ fn map_crate(&@env e, &@ast::crate c) {\n             case (\n                  //if it really is a glob import, that is\n                  ast::view_item_import_glob(?path, _)) {\n-                find_mod(e, sc).glob_imports +=\n-                    [follow_import(*e, sc, path, vi.span)];\n+                auto imp = follow_import(*e, sc, path, vi.span);\n+                if (option::is_some(imp)) {\n+                    find_mod(e, sc).glob_imports +=\n+                        [option::get(imp)];\n+                }\n             }\n             case (_) { }\n         }\n@@ -266,14 +269,15 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n+    e.sess.abort_if_errors();\n+\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n             case (ast::expr_path(?p, ?a)) {\n-                auto df =\n-                    lookup_path_strict(*e, sc, exp.span, p.node.idents,\n-                                       ns_value);\n-                e.def_map.insert(a.id, df);\n+                maybe_insert(e, a.id,\n+                             lookup_path_strict(*e, sc, exp.span,\n+                                                p.node.idents, ns_value));\n             }\n             case (_) { }\n         }\n@@ -282,19 +286,17 @@ fn resolve_names(&@env e, &@ast::crate c) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n             case (ast::ty_path(?p, ?a)) {\n-                auto new_def =\n-                    lookup_path_strict(*e, sc, t.span, p.node.idents,\n-                                       ns_type);\n-                e.def_map.insert(a.id, new_def);\n+                maybe_insert(e, a.id,\n+                             lookup_path_strict(*e, sc, t.span,\n+                                                p.node.idents, ns_type));\n             }\n             case (_) { }\n         }\n     }\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        auto new_def =\n-            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n-                               ns_value);\n-        e.def_map.insert(c.node.ann.id, new_def);\n+        maybe_insert(e, c.node.ann.id,\n+                     lookup_path_strict(*e, sc, c.span,\n+                                        c.node.path.node.idents, ns_value));\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         walk_pat(*e, sc, a.pat);\n@@ -306,21 +308,32 @@ fn resolve_names(&@env e, &@ast::crate c) {\n                 auto fnd =\n                     lookup_path_strict(e, sc, p.span, p.node.idents,\n                                        ns_value);\n-                alt (fnd) {\n-                    case (ast::def_variant(?did, ?vid)) {\n-                        e.def_map.insert(a.id, fnd);\n-                    }\n-                    case (_) {\n-                        e.sess.span_fatal(p.span,\n-                                        \"not a tag variant: \" +\n+                if (option::is_some(fnd)) {\n+                    alt (option::get(fnd)) {\n+                        case (ast::def_variant(?did, ?vid)) {\n+                            e.def_map.insert(a.id, option::get(fnd));\n+                            for (@ast::pat child in children) {\n+                                walk_pat(e, sc, child);\n+                            }\n+                        }\n+                        case (_) {\n+                            e.sess.span_err(p.span,\n+                                            \"not a tag variant: \" +\n                                             ast::path_name(p));\n+                        }\n                     }\n                 }\n-                for (@ast::pat child in children) { walk_pat(e, sc, child); }\n             }\n             case (_) { }\n         }\n     }\n+\n+    fn maybe_insert(@env e, uint id,\n+                    option::t[def] def) {\n+        if (option::is_some(def)) {\n+            e.def_map.insert(id, option::get(def));\n+        }\n+    }\n }\n \n \n@@ -370,42 +383,51 @@ fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n     visit::visit_expr(x, new_sc, v);\n }\n \n-fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n+fn follow_import(&env e, &scopes sc,\n+                 vec[ident] path, &span sp) -> option::t[def] {\n     auto path_len = vec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     auto i = 1u;\n-    while (true) {\n+    while (true && option::is_some(dcur)) {\n         if (i == path_len) { break; }\n         dcur =\n-            lookup_in_mod_strict(e, dcur, sp, path.(i), ns_module, outside);\n+            lookup_in_mod_strict(e, option::get(dcur),\n+                                 sp, path.(i), ns_module, outside);\n         i += 1u;\n     }\n-    alt (dcur) {\n-        case (ast::def_mod(?def_id)) { ret dcur; }\n-        case (ast::def_native_mod(?def_id)) { ret dcur; }\n-        case (_) {\n-            e.sess.span_fatal(sp,\n-                            str::connect(path, \"::\") +\n+    if (i == path_len) {\n+        alt (option::get(dcur)) {\n+            case (ast::def_mod(?def_id)) { ret dcur; }\n+            case (ast::def_native_mod(?def_id)) { ret dcur; }\n+            case (_) {\n+                e.sess.span_err(sp,\n+                                str::connect(path, \"::\") +\n                                 \" does not name a module.\");\n+                ret none;\n+            }\n         }\n+    } else {\n+        ret none;\n     }\n }\n \n fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n                   &vt[scopes] v) {\n-    let def new_def =\n+    auto new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n-    alt (new_def) {\n-        case (ast::def_fn(?pred_id)) {\n-            let ty::constr_general[uint] c_ =\n-                rec(path=c.node.path, args=c.node.args, id=pred_id);\n-            let ty::constr_def new_constr = respan(c.span, c_);\n-            add_constr(e, d_id, new_constr);\n-        }\n-        case (_) {\n-            e.sess.span_fatal(c.span,\n-                            \"Non-predicate in constraint: \" +\n+    if (option::is_some(new_def)) {\n+        alt (option::get(new_def)) {\n+            case (ast::def_fn(?pred_id)) {\n+                let ty::constr_general[uint] c_ =\n+                    rec(path=c.node.path, args=c.node.args, id=pred_id);\n+                let ty::constr_def new_constr = respan(c.span, c_);\n+                add_constr(e, d_id, new_constr);\n+            }\n+            case (_) {\n+                e.sess.span_err(c.span,\n+                                \"Non-predicate in constraint: \" +\n                                 ty::path_to_str(c.node.path));\n+            }\n         }\n     }\n }\n@@ -529,24 +551,28 @@ fn mk_unresolved_msg(&ident id, &str kind) -> str {\n \n // Lookup helpers\n fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n-                      namespace ns) -> def {\n+                      namespace ns) -> option::t[def] {\n     auto n_idents = vec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;\n-    while (i < n_idents) {\n+    while (i < n_idents && option::is_some(dcur)) {\n         auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n-        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), curns, outside);\n+        dcur = lookup_in_mod_strict(e, option::get(dcur),\n+                                    sp, idents.(i), curns, outside);\n         i += 1u;\n     }\n     ret dcur;\n }\n \n fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident id,\n-                          namespace ns) -> def {\n+                          namespace ns) -> option::t[def] {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n-        case (none) { unresolved_fatal(e, sp, id, ns_name(ns)); }\n-        case (some(?d)) { ret d; }\n+        case (none) {\n+            unresolved_err(e, sp, id, ns_name(ns));\n+            ret none;\n+        }\n+        case (some(?d)) { ret some(d); }\n     }\n }\n \n@@ -796,10 +822,13 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n }\n \n fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id, namespace ns,\n-                        dir dr) -> def {\n+                        dir dr) -> option::t[def] {\n     alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n-        case (none) { unresolved_fatal(e, sp, id, ns_name(ns)); }\n-        case (some(?d)) { ret d; }\n+        case (none) {\n+            unresolved_err(e, sp, id, ns_name(ns));\n+            ret none;\n+        }\n+        case (some(?d)) { ret some(d); }\n     }\n }\n "}]}