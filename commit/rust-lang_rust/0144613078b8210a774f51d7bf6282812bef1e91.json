{"sha": "0144613078b8210a774f51d7bf6282812bef1e91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDQ2MTMwNzhiODIxMGE3NzRmNTFkN2JmNjI4MjgxMmJlZjFlOTE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-11T20:53:20Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-11T20:53:20Z"}, "message": "Move rvalue checking to MIR\n\nFixes #41139.", "tree": {"sha": "40baf0b2876d022e6edb68df4f5b4d8e790d45a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40baf0b2876d022e6edb68df4f5b4d8e790d45a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0144613078b8210a774f51d7bf6282812bef1e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0144613078b8210a774f51d7bf6282812bef1e91", "html_url": "https://github.com/rust-lang/rust/commit/0144613078b8210a774f51d7bf6282812bef1e91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0144613078b8210a774f51d7bf6282812bef1e91/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "384ec80d2b3dd61a5f9910dc660bffea8710002e", "url": "https://api.github.com/repos/rust-lang/rust/commits/384ec80d2b3dd61a5f9910dc660bffea8710002e", "html_url": "https://github.com/rust-lang/rust/commit/384ec80d2b3dd61a5f9910dc660bffea8710002e"}], "stats": {"total": 244, "additions": 97, "deletions": 147}, "files": [{"sha": "4dfffe7fd5c983c33ed605561e4cc4f3e84db452", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -35,7 +35,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n+use rustc_passes::{ast_validation, no_asm, loops, consts,\n                    static_recursion, hir_stats, mir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n@@ -957,10 +957,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"liveness checking\",\n              || middle::liveness::check_crate(tcx));\n \n-        time(time_passes,\n-             \"rvalue checking\",\n-             || rvalues::check_crate(tcx));\n-\n         time(time_passes,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n@@ -976,8 +972,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));"}, {"sha": "bb07081fe433b74dab3ccf6ae1fbce3480616218", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -244,6 +244,39 @@ let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n ```\n \"##,\n \n+E0161: r##\"\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```\n+\"##,\n+\n E0396: r##\"\n The value behind a raw pointer can't be determined at compile-time\n (or even link-time), which means it can't be used in a constant"}, {"sha": "f209b93cee18f589cc5558de940d21288232000f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -24,6 +24,7 @@ use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n@@ -87,6 +88,11 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n+    fn visit_local_decl(&mut self, local_decl: &LocalDecl<'tcx>) {\n+        self.super_local_decl(local_decl);\n+        self.sanitize_type(local_decl, local_decl.ty);\n+    }\n+\n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n         self.sanitize_type(&\"return type\", mir.return_ty);\n         for local_decl in &mir.local_decls {\n@@ -317,6 +323,7 @@ pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n+    reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -326,6 +333,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP,\n             body_id: body_id,\n+            reported_errors: FxHashSet(),\n         }\n     }\n \n@@ -641,9 +649,39 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn check_local(&mut self, mir: &Mir<'gcx>, local: Local, local_decl: &LocalDecl<'gcx>) {\n+        match mir.local_kind(local) {\n+            LocalKind::ReturnPointer | LocalKind::Arg => {\n+                // return values of normal functions are required to be\n+                // sized by typeck, but return values of ADT constructors are\n+                // not because we don't include a `Self: Sized` bounds on them.\n+                //\n+                // Unbound parts of arguments were never required to be Sized\n+                // - maybe we should make that a warning.\n+                return\n+            }\n+            LocalKind::Var | LocalKind::Temp => {}\n+        }\n+\n+        let span = local_decl.source_info.span;\n+        let ty = local_decl.ty;\n+        if !ty.is_sized(self.tcx().global_tcx(), self.infcx.param_env(), span) {\n+            if let None = self.reported_errors.replace((ty, span)) {\n+                span_err!(self.tcx().sess, span, E0161,\n+                          \"cannot move a value of type {0}: the size of {0} \\\n+                           cannot be statically determined\", ty);\n+            }\n+        }\n+    }\n+\n+    fn typeck_mir(&mut self, mir: &Mir<'gcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n+\n+        for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+            self.check_local(mir, local, local_decl);\n+        }\n+\n         for block in mir.basic_blocks() {\n             for stmt in &block.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n@@ -698,16 +736,18 @@ impl TypeckMir {\n impl<'tcx> MirPass<'tcx> for TypeckMir {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n-        debug!(\"run_pass: {}\", tcx.node_path_str(src.item_id()));\n+        let item_id = src.item_id();\n+        let def_id = tcx.hir.local_def_id(item_id);\n+        debug!(\"run_pass: {}\", tcx.item_path_str(def_id));\n \n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, item_id);\n         tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, src.item_id());\n+            let mut checker = TypeChecker::new(&infcx, item_id);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "036a52d5a3db3491e4ff8a8f1e52bd18b5d200b6", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -82,39 +82,6 @@ extern {\n ```\n \"##,\n \n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n E0265: r##\"\n This error indicates that a static or constant references itself.\n All statics and constants need to resolve to a value in an acyclic manner."}, {"sha": "22566c813d86ae4da36bd7ed0994e989a566277a", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -47,5 +47,4 @@ pub mod hir_stats;\n pub mod loops;\n pub mod mir_stats;\n pub mod no_asm;\n-pub mod rvalues;\n pub mod static_recursion;"}, {"sha": "c367e71fcd24619417dd41e20e2077739503b535", "filename": "src/librustc_passes/rvalues.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/384ec80d2b3dd61a5f9910dc660bffea8710002e/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384ec80d2b3dd61a5f9910dc660bffea8710002e/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=384ec80d2b3dd61a5f9910dc660bffea8710002e", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Checks that all rvalues in a crate have statically known size. check_crate\n-// is the public starting point.\n-\n-use rustc::dep_graph::DepNode;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::traits::Reveal;\n-\n-use rustc::hir;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut rvcx = RvalueContext { tcx: tcx };\n-    tcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor());\n-}\n-\n-struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-            let mut delegate = RvalueContextDelegate {\n-                tcx: infcx.tcx,\n-                param_env: &infcx.parameter_environment\n-            };\n-            euv::ExprUseVisitor::new(&mut delegate, &infcx).consume_body(body);\n-        });\n-        self.visit_body(body);\n-    }\n-}\n-\n-struct RvalueContextDelegate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'gcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tcx> {\n-    fn consume(&mut self,\n-               _: ast::NodeId,\n-               span: Span,\n-               cmt: mc::cmt<'tcx>,\n-               _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        let ty = self.tcx.lift_to_global(&cmt.ty).unwrap();\n-        if !ty.is_sized(self.tcx.global_tcx(), self.param_env, span) {\n-            span_err!(self.tcx.sess, span, E0161,\n-                \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                ty);\n-        }\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {\n-    }\n-\n-    fn borrow(&mut self,\n-              _borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              _cmt: mc::cmt,\n-              _loan_region: &'tcx ty::Region,\n-              _bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause) {\n-    }\n-\n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {\n-    }\n-\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {\n-    }\n-}"}, {"sha": "15ca151c49a79b5079763d6b8029af21c17d88f8", "filename": "src/test/compile-fail/issue-41139.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0144613078b8210a774f51d7bf6282812bef1e91/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144613078b8210a774f51d7bf6282812bef1e91/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs?ref=0144613078b8210a774f51d7bf6282812bef1e91", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+fn get_function<'a>() -> &'a Fn() -> Trait { panic!(\"\") }\n+\n+fn main() {\n+    let t : &Trait = &get_function()();\n+    //~^ ERROR cannot move a value of type Trait + 'static\n+}"}]}