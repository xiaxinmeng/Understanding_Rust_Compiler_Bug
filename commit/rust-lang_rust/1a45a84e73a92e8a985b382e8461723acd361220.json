{"sha": "1a45a84e73a92e8a985b382e8461723acd361220", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNDVhODRlNzNhOTJlOGE5ODViMzgyZTg0NjE3MjNhY2QzNjEyMjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T12:00:41Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T12:17:27Z"}, "message": "Start using copy glue to copy bits that may contain ivecs\n\nThis is not currently necessary, but will be, when I land the new ivec\nrepresentation.", "tree": {"sha": "d46e28be16df083646dbb6c55dfda0e6587cacb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d46e28be16df083646dbb6c55dfda0e6587cacb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a45a84e73a92e8a985b382e8461723acd361220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a45a84e73a92e8a985b382e8461723acd361220", "html_url": "https://github.com/rust-lang/rust/commit/1a45a84e73a92e8a985b382e8461723acd361220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a45a84e73a92e8a985b382e8461723acd361220/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3948f132d9236fe46c225ccae6973daa950aa190", "url": "https://api.github.com/repos/rust-lang/rust/commits/3948f132d9236fe46c225ccae6973daa950aa190", "html_url": "https://github.com/rust-lang/rust/commit/3948f132d9236fe46c225ccae6973daa950aa190"}], "stats": {"total": 69, "additions": 43, "deletions": 26}, "files": [{"sha": "58edce732a2bb460d05ec7cae9f270fa26197a04", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1a45a84e73a92e8a985b382e8461723acd361220", "patch": "@@ -1272,7 +1272,10 @@ fn emit_tydescs(ccx: &@crate_ctxt) {\n     }\n }\n \n-fn make_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) {\n+// NOTE this is currently just a complicated way to do memmove. I'm working on\n+// a representation of ivecs that will need pointers into itself, which must\n+// be adjusted when copying. Will flesh this out when the time comes.\n+fn make_copy_glue(cx: &@block_ctxt, src: ValueRef, dst: ValueRef, t: ty::t) {\n     let bcx = memmove_ty(cx, dst, src, t).bcx;\n     build_return(bcx);\n }\n@@ -2369,9 +2372,12 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         let bcx = if action == DROP_EXISTING {\n             drop_ty(cx, dst, t).bcx\n         } else { cx };\n-        bcx = memmove_ty(bcx, dst, src, t).bcx;\n-        bcx = take_ty(bcx, dst, t).bcx;\n-        ret bcx;\n+        if ty::type_needs_copy_glue(ccx.tcx, t) {\n+            ret call_copy_glue(bcx, dst, src, t, true);\n+        } else {\n+            bcx = memmove_ty(bcx, dst, src, t).bcx;\n+            ret take_ty(bcx, dst, t).bcx;\n+        }\n     }\n     ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n                      ty_to_str(ccx.tcx, t));\n@@ -2386,16 +2392,16 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: &lval_result, t: ty::t) -> @block_ctxt {\n     let src_val = src.res.val;\n-    if ty::type_is_scalar(bcx_tcx(cx), t) ||\n-           ty::type_is_native(bcx_tcx(cx), t) {\n+    let tcx = bcx_tcx(cx);\n+    if ty::type_is_scalar(tcx, t) ||\n+           ty::type_is_native(tcx, t) {\n         if src.is_mem { src_val = cx.build.Load(src_val); }\n         cx.build.Store(src_val, dst);\n         ret cx;\n-    } else if ty::type_is_nil(bcx_tcx(cx), t) ||\n-                  ty::type_is_bot(bcx_tcx(cx), t) {\n+    } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n-    } else if ty::type_is_unique(bcx_tcx(cx), t) ||\n-                  ty::type_is_boxed(bcx_tcx(cx), t) {\n+    } else if ty::type_is_unique(tcx, t) ||\n+                  ty::type_is_boxed(tcx, t) {\n         if src.is_mem { src_val = cx.build.Load(src_val); }\n         if action == DROP_EXISTING {\n             cx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n@@ -2406,10 +2412,13 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n-    } else if ty::type_is_structural(bcx_tcx(cx), t) ||\n-                  ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n+    } else if type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t).bcx; }\n-        cx = memmove_ty(cx, dst, src_val, t).bcx;\n+        if ty::type_needs_copy_glue(tcx, t) {\n+            cx = call_copy_glue(cx, dst, src_val, t, false);\n+        } else {\n+            cx = memmove_ty(cx, dst, src_val, t).bcx;\n+        }\n         if src.is_mem {\n             ret zero_alloca(cx, src_val, t).bcx;\n         } else { // Temporary value\n@@ -2418,7 +2427,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         }\n     }\n     bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n-                             ty_to_str(bcx_tcx(cx), t));\n+                             ty_to_str(tcx, t));\n }\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n@@ -5049,16 +5058,14 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n \n         let rhs_res = trans_lval(lhs_res.res.bcx, src);\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n-        let tmp_res = alloc_ty(rhs_res.res.bcx, t);\n+        let {bcx, val: tmp_alloc} = alloc_ty(rhs_res.res.bcx, t);\n         // Swap through a temporary.\n \n-        let move1_res =\n-            memmove_ty(tmp_res.bcx, tmp_res.val, lhs_res.res.val, t);\n-        let move2_res =\n-            memmove_ty(move1_res.bcx, lhs_res.res.val, rhs_res.res.val, t);\n-        let move3_res =\n-            memmove_ty(move2_res.bcx, rhs_res.res.val, tmp_res.val, t);\n-        ret rslt(move3_res.bcx, C_nil());\n+        bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n+        bcx = move_val(bcx, INIT, lhs_res.res.val, rhs_res, t);\n+        bcx = move_val(bcx, INIT, rhs_res.res.val,\n+                       lval_mem(bcx, tmp_alloc), t);\n+        ret rslt(bcx, C_nil());\n       }\n       ast::expr_assign_op(op, dst, src) {\n         let t = ty::expr_ty(bcx_tcx(cx), src);"}, {"sha": "814776625c662eb76264bf1319cad35361c4ccbd", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=1a45a84e73a92e8a985b382e8461723acd361220", "patch": "@@ -526,11 +526,9 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n             let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n             let llty = trans::type_of(ccx, pat.span, ty);\n             let alloc = trans::alloca(bcx, llty);\n-            bcx = trans::memmove_ty(bcx, alloc, val, ty).bcx;\n-            let loaded = trans::load_if_immediate(bcx, alloc, ty);\n-            bcx = trans::take_ty(bcx, loaded, ty).bcx;\n+            bcx = trans::copy_val(bcx, trans::INIT, alloc,\n+                                  trans::load_if_immediate(bcx, val, ty), ty);\n             table.insert(pat.id, alloc);\n-            trans_common::add_clean(bcx, alloc, ty);\n         } else { table.insert(pat.id, val); }\n       }\n       ast::pat_tag(_, sub) {"}, {"sha": "7a98b5a8cab6ed3e024f8ddb25a62f2a973a73c7", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a45a84e73a92e8a985b382e8461723acd361220/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=1a45a84e73a92e8a985b382e8461723acd361220", "patch": "@@ -155,6 +155,7 @@ export type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n+export type_needs_copy_glue;\n export type_has_pointers;\n export type_needs_drop;\n export type_is_bool;\n@@ -1175,6 +1176,17 @@ fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n     });\n }\n \n+fn type_needs_copy_glue(cx: &ctxt, ty: t) -> bool {\n+    ret type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n+        ret alt sty {\n+          ty_param(_, _) { true }\n+          ty_vec(_) { true }\n+          ty_istr. { true }\n+          _ { false }\n+        };\n+    });\n+}\n+\n fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }"}]}