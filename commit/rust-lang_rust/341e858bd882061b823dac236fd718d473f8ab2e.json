{"sha": "341e858bd882061b823dac236fd718d473f8ab2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MWU4NThiZDg4MjA2MWI4MjNkYWMyMzZmZDcxOGQ0NzNmOGFiMmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:02:44Z"}, "message": "rollup merge of #20790: japaric/for-loops\n\nAs per [RFC #235][rfc], you can now do:\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0235-collections-conventions.md#intoiterator-and-iterable\n\n``` rust\nlet mut v = vec![1];\n\n// iterate over immutable references\nfor x in &v {\n    assert_eq!(x, &1);\n}\n\n// iterate over mutable references\nfor x in &mut v {\n    assert_eq!(x, &mut 1);\n}\n\n// iterate over values, this consumes `v`\nfor x in v {\n    assert_eq!(x, 1);\n}\n```\n\n[breaking-change]s\n\nFor loops now \"consume\" (move) the iterator, this breaks iterating over mutable references to iterators, and also breaks multiple iterations over the same iterator:\n\n``` rust\nfn foo(mut it: &mut Iter) {  // `Iter` implements `Iterator`\n    for x in it { .. }  //~ error: `&mut Iter` doesn't implement Iterator\n}\n\nfn bar() {\n    for x in it { .. }  //~ note: `it` moved here\n    for x in it { .. }  //~ error: `it` has been moved\n}\n```\n\nBoth cases can be fixed using the `by_ref()` adapter to create an iterator from the mutable reference:\n\n``` rust\nfn foo(mut it: &mut Iter) {\n    for x in it.by_ref() { .. }\n}\n\nfn bar() {\n    for x in it.by_ref() { .. }\n    for x in it { .. }\n}\n```\n\nThis PR also makes iterator non-implicitly copyable, as this was source of subtle bugs in the libraries. You can still use `clone()` to explictly copy the iterator.\n\nFinally, since the for loops are implemented in the frontend and use global paths to `IntoIterator`, `Iterator` and `Option` variants, users of the `core` crate will have to use add an `std` module to the root of their crate to be able to use for loops:\n\n``` rust\n#![no_std]\n\nextern crate core;\n\nfn main() {\n    for x in 0..10 {}\n}\n\n#[doc(hidden)]\nmod std {\n    // these imports are needed to use for-loops\n    pub use core::iter;\n    pub use core::option;\n}\n```\n\n---\n\nr? @nikomatsakis @aturon\ncc #18424\ncloses #18045", "tree": {"sha": "2e6d18523dcd67f28fe0a527f02102072ce14996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e6d18523dcd67f28fe0a527f02102072ce14996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/341e858bd882061b823dac236fd718d473f8ab2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/341e858bd882061b823dac236fd718d473f8ab2e", "html_url": "https://github.com/rust-lang/rust/commit/341e858bd882061b823dac236fd718d473f8ab2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/341e858bd882061b823dac236fd718d473f8ab2e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a51eb9cca3ae5f815825096de4dfbdc9267f735", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a51eb9cca3ae5f815825096de4dfbdc9267f735", "html_url": "https://github.com/rust-lang/rust/commit/1a51eb9cca3ae5f815825096de4dfbdc9267f735"}, {"sha": "b9a9030ed68f135e116e9a5d32663e00b897cf4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a9030ed68f135e116e9a5d32663e00b897cf4f", "html_url": "https://github.com/rust-lang/rust/commit/b9a9030ed68f135e116e9a5d32663e00b897cf4f"}], "stats": {"total": 1187, "additions": 588, "deletions": 599}, "files": [{"sha": "2bd86fa987f4be962bd3ec3086dd5ee2b8cf5b2e", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -576,6 +576,10 @@ extern fn panic_fmt(args: &core::fmt::Arguments,\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n # #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n # fn main() {}\n+# mod std {  // for-loops\n+#     pub use core::iter;\n+#     pub use core::option;\n+# }\n ```\n \n Note that there is one extra lang item here which differs from the examples"}, {"sha": "8c2163d7e14a6caa5457def193495217068060e9", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -153,7 +153,7 @@\n use core::prelude::*;\n \n use core::default::Default;\n-use core::iter::FromIterator;\n+use core::iter::{FromIterator, IntoIterator};\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n@@ -655,6 +655,22 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     }\n }\n \n+impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {"}, {"sha": "d676cfca9294e6ab2a0f07a03c94aeed28a36055", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -89,7 +89,7 @@ use core::fmt;\n use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n-use core::iter::{self, FromIterator};\n+use core::iter::{self, FromIterator, IntoIterator};\n use core::num::Int;\n use core::ops::Index;\n use core::slice;\n@@ -1070,6 +1070,14 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n     }\n }\n \n+impl<'a> IntoIterator for &'a Bitv {\n+    type Iter = Iter<'a>;\n+\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding unsigned numerical elements.\n ///\n@@ -1873,6 +1881,13 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n+impl<'a> IntoIterator for &'a BitvSet {\n+    type Iter = SetIter<'a>;\n+\n+    fn into_iter(self) -> SetIter<'a> {\n+        self.iter()\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "27783ff941a4152ea6fb4afa4af162642a9bfdc1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -24,7 +24,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Map, FromIterator};\n+use core::iter::{Map, FromIterator, IntoIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n@@ -478,6 +478,30 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n+impl<K, V> IntoIterator for BTreeMap<K, V> {\n+    type Iter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n+    type Iter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n+    type Iter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n /// A helper enum useful for deciding whether to continue a loop since we can't\n /// return from a closure\n enum Continuation<A, B> {"}, {"sha": "8d6f06b25c5be42512197325e74381087784be10", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -271,7 +271,7 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n #[unsafe_destructor]\n impl<T> Drop for RawItems<T> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n     }\n }\n \n@@ -1374,9 +1374,9 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n     fn drop(&mut self) {\n         // We need to cleanup the stored values manually, as the RawItems destructor would run\n         // after our deallocation.\n-        for _ in self.keys {}\n-        for _ in self.vals {}\n-        for _ in self.edges {}\n+        for _ in self.keys.by_ref() {}\n+        for _ in self.vals.by_ref() {}\n+        for _ in self.edges.by_ref() {}\n \n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);"}, {"sha": "e6d7d2a37eb78a435fc539e3fa4b7abe7e35fb44", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -18,7 +18,7 @@ use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n use core::fmt::Debug;\n use core::fmt;\n-use core::iter::{Peekable, Map, FromIterator};\n+use core::iter::{Peekable, Map, FromIterator, IntoIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use btree_map::{BTreeMap, Keys};\n@@ -480,6 +480,22 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n+impl<T> IntoIterator for BTreeSet<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "48bf820e6f6a233991a3e26c724012a41ad2a638", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -28,7 +28,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Writer, Hasher, Hash};\n-use core::iter::{self, FromIterator};\n+use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n@@ -830,6 +830,30 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n+impl<T> IntoIterator for DList<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a DList<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut DList<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for DList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {"}, {"sha": "a9e64a5c282ea4e8bfdb3cd69276f74a89742426", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -16,7 +16,7 @@\n use core::prelude::*;\n use core::fmt;\n use core::num::Int;\n-use core::iter::FromIterator;\n+use core::iter::{FromIterator, IntoIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be wrong here)\n@@ -256,6 +256,14 @@ impl<E:CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n+impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n+    type Iter = Iter<E>;\n+\n+    fn into_iter(self) -> Iter<E> {\n+        self.iter()\n+    }\n+}\n+\n impl<E:CLike> Extend<E> for EnumSet<E> {\n     fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) {\n         for element in iterator {"}, {"sha": "f28262dc0fea746ab5c06c0ac394810414428afd", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -34,6 +34,8 @@\n #![feature(unicode)]\n #![feature(hash)]\n #![cfg_attr(test, feature(test))]\n+// NOTE(stage0): remove after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n #[macro_use]\n extern crate core;\n@@ -114,6 +116,8 @@ mod std {\n     pub use core::marker;   // derive(Copy)\n     pub use core::hash;     // derive(Hash)\n     pub use core::ops;      // RangeFull\n+    // for-loops\n+    pub use core::iter;\n }\n \n #[cfg(test)]"}, {"sha": "a19b3c221b1ef6f9bfcca8a4dc1f0d75b30b08ae", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -19,7 +19,7 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n@@ -1510,7 +1510,7 @@ pub struct Drain<'a, T: 'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n         self.inner.head = 0;\n         self.inner.tail = 0;\n     }\n@@ -1609,6 +1609,30 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n+impl<T> IntoIterator for RingBuf<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for RingBuf<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {"}, {"sha": "57ee4704a9ee099b376bd791ba53be8057a202bb", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1958,7 +1958,7 @@ mod tests {\n             let mut amt = 0;\n             let mut it = v.permutations();\n             let (min_size, max_opt) = it.size_hint();\n-            for _perm in it {\n+            for _perm in it.by_ref() {\n                 amt += 1;\n             }\n             assert_eq!(amt, it.swaps.swaps_made);"}, {"sha": "d6ee4dc5f6742e3ffd853647aa55bda0e423a71a", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -199,7 +199,7 @@ impl<'a> Iterator for Decompositions<'a> {\n         }\n \n         if !self.sorted {\n-            for ch in self.iter {\n+            for ch in self.iter.by_ref() {\n                 let buffer = &mut self.buffer;\n                 let sorted = &mut self.sorted;\n                 {\n@@ -279,7 +279,7 @@ impl<'a> Iterator for Recompositions<'a> {\n         loop {\n             match self.state {\n                 Composing => {\n-                    for ch in self.iter {\n+                    for ch in self.iter.by_ref() {\n                         let ch_class = unicode::char::canonical_combining_class(ch);\n                         if self.composee.is_none() {\n                             if ch_class != 0 {\n@@ -2154,7 +2154,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut it = s.chars();\n         it.next();\n-        assert!(it.zip(it.clone()).all(|(x,y)| x == y));\n+        assert!(it.clone().zip(it).all(|(x,y)| x == y));\n     }\n \n     #[test]"}, {"sha": "1d20d39b115128d8c3ba6dd98cbfdc8e2c6ba515", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -56,7 +56,7 @@ use core::cmp::{Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::iter::{repeat, FromIterator};\n+use core::iter::{repeat, FromIterator, IntoIterator};\n use core::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n@@ -65,6 +65,7 @@ use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n+use core::slice;\n use core::uint;\n \n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n@@ -1404,6 +1405,30 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n+impl<T> IntoIterator for Vec<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a Vec<T> {\n+    type Iter = slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut Vec<T> {\n+    type Iter = slice::IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n@@ -1623,7 +1648,7 @@ impl<T> IntoIter<T> {\n     #[unstable(feature = \"collections\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n-            for _x in self { }\n+            for _x in self.by_ref() { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n             Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n@@ -1701,7 +1726,7 @@ impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         if self.cap != 0 {\n-            for _x in *self {}\n+            for _x in self.by_ref() {}\n             unsafe {\n                 dealloc(self.allocation, self.cap);\n             }\n@@ -1791,7 +1816,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n         // so we can use #[unsafe_no_drop_flag].\n \n         // destroy the remaining elements\n-        for _x in *self {}\n+        for _x in self.by_ref() {}\n     }\n }\n "}, {"sha": "2846414bb9accd8df3c5fa838e2b6961c2fd873b", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -19,7 +19,7 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Writer, Hasher};\n-use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n+use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n use core::ops::{Index, IndexMut};\n@@ -536,6 +536,30 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n     }\n }\n \n+impl<T> IntoIterator for VecMap<T> {\n+    type Iter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a VecMap<T> {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {"}, {"sha": "ec3d9783255cb77a13c09e24d45fc606bb7c57d9", "filename": "src/libcore/array.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -18,12 +18,14 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use hash::{Hash, Hasher, self};\n+use iter::IntoIterator;\n use marker::Copy;\n #[cfg(stage0)]\n use ops::{Deref, FullRange};\n #[cfg(not(stage0))]\n use ops::Deref;\n use option::Option;\n+use slice::{Iter, IterMut, SliceExt};\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! array_impls {\n@@ -49,6 +51,22 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            impl<'a, T> IntoIterator for &'a [T; $N] {\n+                type Iter = Iter<'a, T>;\n+\n+                fn into_iter(self) -> Iter<'a, T> {\n+                    self.iter()\n+                }\n+            }\n+\n+            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n+                type Iter = IterMut<'a, T>;\n+\n+                fn into_iter(self) -> IterMut<'a, T> {\n+                    self.iter_mut()\n+                }\n+            }\n+\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]"}, {"sha": "b0906651da803abfa24e682c9eecbcd2f1967b1b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -122,6 +122,22 @@ pub trait FromIterator<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n+/// Conversion into an `Iterator`\n+pub trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    /// Consumes `Self` and returns an iterator over it\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n /// A type growable from an `Iterator` implementation\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n@@ -178,7 +194,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in *self {\n+        for x in self.by_ref() {\n             if n == 0 { return Some(x) }\n             n -= 1;\n         }\n@@ -475,7 +491,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// fn process<U: Iterator<Item=isize>>(it: U) -> isize {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n-    ///     for x in it {\n+    ///     for x in it.by_ref() {\n     ///         if x > 5 {\n     ///             break;\n     ///         }\n@@ -643,7 +659,7 @@ pub trait IteratorExt: Iterator + Sized {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(Self::Item) -> bool {\n-        for x in *self { if f(x) { return true; } }\n+        for x in self.by_ref() { if f(x) { return true; } }\n         false\n     }\n \n@@ -663,7 +679,7 @@ pub trait IteratorExt: Iterator + Sized {\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        for x in *self {\n+        for x in self.by_ref() {\n             if predicate(&x) { return Some(x) }\n         }\n         None\n@@ -686,7 +702,7 @@ pub trait IteratorExt: Iterator + Sized {\n         P: FnMut(Self::Item) -> bool,\n     {\n         let mut i = 0;\n-        for x in *self {\n+        for x in self.by_ref() {\n             if predicate(x) {\n                 return Some(i);\n             }\n@@ -1312,7 +1328,7 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n {}\n \n /// An iterator that repeats endlessly\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cycle<I> {\n@@ -1647,7 +1663,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n             } else {\n@@ -1711,7 +1727,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             match (self.f)(x) {\n                 Some(y) => return Some(y),\n                 None => ()\n@@ -1810,7 +1826,6 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy)]\n pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     iter: I,\n     peeked: Option<T>,\n@@ -1897,7 +1912,7 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        for x in self.iter {\n+        for x in self.iter.by_ref() {\n             if self.flag || !(self.predicate)(&x) {\n                 self.flag = true;\n                 return Some(x);\n@@ -2190,7 +2205,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     fn next(&mut self) -> Option<B> {\n         loop {\n             for inner in self.frontiter.iter_mut() {\n-                for x in *inner {\n+                for x in inner.by_ref() {\n                     return Some(x)\n                 }\n             }\n@@ -2484,7 +2499,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n \n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n@@ -2520,7 +2535,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n }\n \n /// An iterator over the range [start, stop)\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n pub struct Range<A> {"}, {"sha": "353d4252dfb05c296bcf7049710d97014adab999", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -65,6 +65,8 @@\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(on_unimplemented)]\n #![deny(missing_docs)]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n #[macro_use]\n mod macros;\n@@ -158,4 +160,6 @@ mod std {\n     pub use marker;\n     pub use ops;\n     pub use option;\n+    // for-loops\n+    pub use iter;\n }"}, {"sha": "1be7a0fb066b5bb8b384fd94841df901deb749bd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1524,7 +1524,7 @@ macro_rules! from_str_radix_float_impl {\n                 let mut exp_info = None::<(char, uint)>;\n \n                 // Parse the integer part of the significand\n-                for (i, c) in cs {\n+                for (i, c) in cs.by_ref() {\n                     match c.to_digit(radix) {\n                         Some(digit) => {\n                             // shift significand one digit left\n@@ -1572,7 +1572,7 @@ macro_rules! from_str_radix_float_impl {\n                 // part of the significand\n                 if exp_info.is_none() {\n                     let mut power = 1.0;\n-                    for (i, c) in cs {\n+                    for (i, c) in cs.by_ref() {\n                         match c.to_digit(radix) {\n                             Some(digit) => {\n                                 // Decrease power one order of magnitude"}, {"sha": "a368ddba9bc30d177d8b7913c69ee54c1d176532", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -41,7 +41,6 @@ use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use marker::Copy;\n use num::Int;\n use ops::{FnMut, self, Index};\n #[cfg(stage0)]\n@@ -637,6 +636,22 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n+impl<'a, T> IntoIterator for &'a [T] {\n+    type Iter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut [T] {\n+    type Iter = IterMut<'a, T>;\n+\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -784,16 +799,14 @@ impl<'a, T> Iter<'a, T> {\n     }\n }\n \n-impl<'a,T> Copy for Iter<'a,T> {}\n-\n iterator!{struct Iter -> *const T, &'a T}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { *self }\n+    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, marker: self.marker } }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]"}, {"sha": "f545c56a060ca5e2f930ee8eb11f5a7170126b70", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -18,6 +18,7 @@\n \n use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n+use clone::Clone;\n use cmp::{self, Eq};\n use default::Default;\n use error::Error;\n@@ -279,7 +280,7 @@ Section: Iterators\n /// Iterator for the char (representing *Unicode Scalar Values*) of a string\n ///\n /// Created with the method `.chars()`.\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n@@ -1007,11 +1008,11 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n     let whole = iter.as_slice();\n     loop {\n         // save the current thing we're pointing at.\n-        let old = *iter;\n+        let old = iter.clone();\n \n         // restore the iterator we had at the start of this codepoint.\n         macro_rules! err { () => {{\n-            *iter = old;\n+            *iter = old.clone();\n             return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n         }}}\n "}, {"sha": "2590b204502182e7959403571bf56060696ed87c", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -366,32 +366,32 @@ fn test_iterator_size_hint() {\n     let vi = v.iter();\n \n     assert_eq!(c.size_hint(), (uint::MAX, None));\n-    assert_eq!(vi.size_hint(), (10, Some(10)));\n-\n-    assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-    assert_eq!(c.skip(5).size_hint().1, None);\n-    assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n-    assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n-    assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n-    assert_eq!(c.scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n-    assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.map(|_| 0i).size_hint(), (uint::MAX, None));\n+    assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n+\n+    assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(c.clone().skip(5).size_hint().1, None);\n+    assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().enumerate().size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().chain(vi.clone().map(|&i| i)).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n+    assert_eq!(c.clone().scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n+    assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map(|_| 0i).size_hint(), (uint::MAX, None));\n     assert_eq!(c.filter_map(|_| Some(0i)).size_hint(), (0, None));\n \n-    assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n-    assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n-    assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n-    assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n-    assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n-    assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n-    assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n-    assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.map(|&i| i+1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(vi.clone().take(12).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n+    assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n+    assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n+    assert_eq!(vi.clone().chain(v2.iter()).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.clone().zip(v2.iter()).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.clone().scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().filter(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map(|&i| i+1).size_hint(), (10, Some(10)));\n     assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n }\n \n@@ -904,7 +904,7 @@ fn bench_multiple_take(b: &mut Bencher) {\n     b.iter(|| {\n         let n = it.next().unwrap();\n         for _ in 0u..n {\n-            it.take(it.next().unwrap()).all(|_| true);\n+            it.clone().take(it.next().unwrap()).all(|_| true);\n         }\n     });\n }"}, {"sha": "8c50550a6e84cd3a8c78d8c7be48f55f05ee1977", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -498,6 +498,8 @@ mod std {\n     pub use core::{option, fmt}; // panic!()\n     pub use core::clone; // derive Clone\n     pub use core::marker;\n+    // for-loops\n+    pub use core::iter;\n }\n \n #[cfg(test)]"}, {"sha": "a38e8bb45361eab7e362c6e6185dc3ff27f253f2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -41,6 +41,8 @@\n #![feature(unicode)]\n #![feature(hash)]\n #![cfg_attr(test, feature(test))]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "e594d462ff385d77a10792ff1e7ef4e26c2907ed", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1163,6 +1163,7 @@ impl LintPass for UnusedParens {\n                 ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n                 ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n                 ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n             },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),"}, {"sha": "0a575a31eadc0841f940a40e29ea139f66f8f68e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -263,43 +263,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-                //\n-                //          [pred]\n-                //            |\n-                //            v 1\n-                //          [head]\n-                //            |\n-                //            v 2\n-                //        [loopback] <--+ 7\n-                //            |         |\n-                //            v 3       |\n-                //   +------[cond]      |\n-                //   |        |         |\n-                //   |        v 5       |\n-                //   |       [pat]      |\n-                //   |        |         |\n-                //   |        v 6       |\n-                //   v 4    [body] -----+\n-                // [expr]\n-                //\n-                // Note that `break` and `continue` statements\n-                // may cause additional edges.\n-\n-                let head = self.expr(&**head, pred);             // 1\n-                let loopback = self.add_dummy_node(&[head]);     // 2\n-                let cond = self.add_dummy_node(&[loopback]);     // 3\n-                let expr_exit = self.add_node(expr.id, &[cond]); // 4\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit,\n-                });\n-                let pat = self.pat(&**pat, cond);               // 5\n-                let body = self.block(&**body, pat);            // 6\n-                self.add_contained_edge(body, loopback);        // 7\n-                self.loop_scopes.pop();\n-                expr_exit\n+            ast::ExprForLoop(..) => {\n+                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprLoop(ref body, _) => {"}, {"sha": "41ef55933cda2e841f14d54f9af249fdf29b0fa8", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -45,10 +45,6 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprForLoop(_, ref e, ref b, _) => {\n-                self.visit_expr(&**e);\n-                self.with_context(Loop, |v| v.visit_block(&**b));\n-            }\n             ast::ExprClosure(_, _, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }"}, {"sha": "aded63336dcd538676c1caaa2f7f27d311bdd7eb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -221,21 +221,8 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 .flat_map(|arm| arm.0.iter())\n                 .map(|pat| vec![&**pat])\n                 .collect();\n-            check_exhaustive(cx, ex.span, &matrix);\n+            check_exhaustive(cx, ex.span, &matrix, source);\n         },\n-        ast::ExprForLoop(ref pat, _, _, _) => {\n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n-            is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                span_err!(cx.tcx.sess, pat.span, E0297,\n-                    \"refutable pattern in `for` loop binding: \\\n-                            `{}` not covered\",\n-                            pat_to_string(uncovered_pat));\n-            });\n-\n-            // Check legality of move bindings.\n-            check_legality_of_move_bindings(cx, false, slice::ref_slice(pat));\n-            check_legality_of_bindings_in_at_patterns(cx, &**pat);\n-        }\n         _ => ()\n     }\n }\n@@ -327,6 +314,14 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n+                        ast::MatchSource::ForLoopDesugar => {\n+                            // this is a bug, because on `match iter.next()` we cover\n+                            // `Some(<head>)` and `None`. It's impossible to have an unreachable\n+                            // pattern\n+                            // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n+                            cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n+                        },\n+\n                         ast::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n@@ -351,18 +346,37 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match &pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n-            span_err!(cx.tcx.sess, sp, E0004,\n-                \"non-exhaustive patterns: `{}` not covered\",\n-                pat_to_string(witness)\n-            );\n+            match source {\n+                ast::MatchSource::ForLoopDesugar => {\n+                    // `witness` has the form `Some(<head>)`, peel off the `Some`\n+                    let witness = match witness.node {\n+                        ast::PatEnum(_, Some(ref pats)) => match &pats[] {\n+                            [ref pat] => &**pat,\n+                            _ => unreachable!(),\n+                        },\n+                        _ => unreachable!(),\n+                    };\n+\n+                    span_err!(cx.tcx.sess, sp, E0297,\n+                        \"refutable pattern in `for` loop binding: \\\n+                                `{}` not covered\",\n+                                pat_to_string(witness));\n+                },\n+                _ => {\n+                    span_err!(cx.tcx.sess, sp, E0004,\n+                        \"non-exhaustive patterns: `{}` not covered\",\n+                        pat_to_string(witness)\n+                    );\n+                },\n+            }\n         }\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "a79e6fac0cc260d3ea33df4821649c7f15fae13c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -537,22 +537,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-                // The pattern lives as long as the block.\n-                debug!(\"walk_expr for loop case: blk id={}\", blk.id);\n-                self.consume_expr(&**head);\n-\n-                // Fetch the type of the value that the iteration yields to\n-                // produce the pattern's categorized mutable type.\n-                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n-                let blk_scope = region::CodeExtent::from_node_id(blk.id);\n-                let pat_cmt = self.mc.cat_rvalue(pat.id,\n-                                                 pat.span,\n-                                                 ty::ReScope(blk_scope),\n-                                                 pattern_type);\n-                self.walk_irrefutable_pat(pat_cmt, &**pat);\n-\n-                self.walk_block(&**blk);\n+            ast::ExprForLoop(..) => {\n+                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n \n             ast::ExprUnary(op, ref lhs) => {"}, {"sha": "29a615f2b4052bd4ffe51417615a60327be18bf3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -325,8 +325,6 @@ lets_do_this! {\n \n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n-    IteratorItem,                    \"iterator\",                iterator;\n-\n     StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;"}, {"sha": "982bc41f06a849cf38034487a7a8303b19ff5163", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -135,8 +135,6 @@ enum LoopKind<'a> {\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n-    /// A `for` loop, with the given pattern to bind.\n-    ForLoop(&'a ast::Pat),\n }\n \n #[derive(Copy, PartialEq)]\n@@ -490,19 +488,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, _, _, _) => {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {:?}\",\n-                   p_id, bm);\n-            let name = path1.node;\n-            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n-            ir.add_variable(Local(LocalInfo {\n-                id: p_id,\n-                ident: name\n-            }));\n-        });\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr);\n+      ast::ExprForLoop(..) => {\n+          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1034,9 +1021,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n \n-          ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n-            let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n-            self.propagate_through_expr(&**head, ln)\n+          ast::ExprForLoop(..) => {\n+              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n@@ -1373,7 +1359,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n-            ForLoop(ref pat) => self.define_bindings_in_pat(*pat, ln),\n             WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n@@ -1386,9 +1371,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             let new_cond_ln = match kind {\n                 LoopLoop => ln,\n-                ForLoop(ref pat) => {\n-                    self.define_bindings_in_pat(*pat, ln)\n-                }\n                 WhileLoop(ref cond) => {\n                     self.propagate_through_expr(&**cond, ln)\n                 }\n@@ -1476,14 +1458,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n-      ast::ExprForLoop(ref pat, _, _, _) => {\n-        this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n-            this.warn_about_unused(sp, id, ln, var);\n-        });\n-\n-        visit::walk_expr(this, expr);\n-      }\n-\n       // no correctness conditions related to liveness\n       ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n       ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n@@ -1503,6 +1477,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n+      ast::ExprForLoop(..) => {\n+        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+      }\n     }\n }\n "}, {"sha": "7de6b70b15955767b8b1cec3fc1328476dd3d98c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -536,8 +536,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-          ast::ExprForLoop(..) => {\n+          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n@@ -547,6 +546,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprWhileLet(..) => {\n             self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n+          ast::ExprForLoop(..) => {\n+            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+          }\n         }\n     }\n "}, {"sha": "c70532dbb30cb03723499a0e03bb23ad17f2e9d3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -701,14 +701,6 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n                 terminating(body.id);\n             }\n \n-            ast::ExprForLoop(ref _pat, ref _head, ref body, _) => {\n-                terminating(body.id);\n-\n-                // The variable parent of everything inside (most importantly, the\n-                // pattern) is the body.\n-                visitor.cx.var_parent = InnermostDeclaringBlock::Block(body.id);\n-            }\n-\n             ast::ExprMatch(..) => {\n                 visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n             }"}, {"sha": "19b788a38e6f8162dda9e6361a23b67226e8705f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -4493,9 +4493,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n-            // `for` loops are statements\n-            ast::ExprForLoop(..) => RvalueStmtExpr,\n-\n             // in the general case, result could be any type, use DPS\n             _ => RvalueDpsExpr\n         };\n@@ -4582,6 +4579,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n         }\n \n+        ast::ExprForLoop(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n+        }\n+\n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }\n@@ -4619,8 +4620,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLoop(..) |\n         ast::ExprAssign(..) |\n         ast::ExprInlineAsm(..) |\n-        ast::ExprAssignOp(..) |\n-        ast::ExprForLoop(..) => {\n+        ast::ExprAssignOp(..) => {\n             RvalueStmtExpr\n         }\n "}, {"sha": "a433161d659e8a5a4f0350de4f93b2da4dcec4e4", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -96,7 +96,7 @@ impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> b\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::ExprLoop(..) | ast::ExprWhile(..) | ast::ExprForLoop(..) => {}\n+          ast::ExprLoop(..) | ast::ExprWhile(..) => {}\n           _ => visit::walk_expr(self, e)\n         }\n     }"}, {"sha": "dd9a52aa705555f71351458029f25bc00a915edb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -100,6 +100,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               ast::ExprMethodCall(..) => \"method call\",\n               ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n               ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n               ast::ExprMatch(..) => \"match\",\n               _ => \"expression\",\n           },"}, {"sha": "3d7adc9934fb55f488b19556b9fcff71ac0775bb", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -252,7 +252,6 @@ mod svh_visitor {\n         SawExprStruct,\n         SawExprRepeat,\n         SawExprParen,\n-        SawExprForLoop,\n     }\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n@@ -288,9 +287,9 @@ mod svh_visitor {\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n             ExprParen(..)            => SawExprParen,\n-            ExprForLoop(..)          => SawExprForLoop,\n \n             // just syntactic artifacts, expanded away by time of SVH.\n+            ExprForLoop(..)          => unreachable!(),\n             ExprIfLet(..)            => unreachable!(),\n             ExprWhileLet(..)         => unreachable!(),\n             ExprMac(..)              => unreachable!(),"}, {"sha": "89d36ef5801013fe8e53e3e74ebf59c0d0cfb305", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -68,7 +68,7 @@ use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n+use syntax::ast::{ExprClosure, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n@@ -4562,39 +4562,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n \n-            ExprForLoop(ref pattern, ref head, ref body, optional_label) => {\n-                self.resolve_expr(&**head);\n-\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n-\n-                self.resolve_pattern(&**pattern,\n-                                     LocalIrrefutableMode,\n-                                     &mut HashMap::new());\n-\n-                match optional_label {\n-                    None => {}\n-                    Some(label) => {\n-                        self.label_ribs\n-                            .push(Rib::new(NormalRibKind));\n-                        let def_like = DlDef(DefLabel(expr.id));\n-\n-                        {\n-                            let rib = self.label_ribs.last_mut().unwrap();\n-                            let renamed = mtwt::resolve(label);\n-                            rib.bindings.insert(renamed, def_like);\n-                        }\n-                    }\n-                }\n-\n-                self.resolve_block(&**body);\n-\n-                if optional_label.is_some() {\n-                    drop(self.label_ribs.pop())\n-                }\n-\n-                self.value_ribs.pop();\n-            }\n-\n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {"}, {"sha": "bee320c682922a76ae4fbefaf7464e869ebdb69d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -41,6 +41,8 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(hash)]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "7074a970ba91ccda454e0e87c1c0e040adee5350", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1537,31 +1537,6 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Generates code for the pattern binding in a `for` loop like\n-/// `for <pat> in <expr> { ... }`.\n-pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          pat: &ast::Pat,\n-                                          llvalue: ValueRef,\n-                                          body_scope: cleanup::ScopeId)\n-                                          -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_for_loop_binding\");\n-\n-    if simple_identifier(&*pat).is_some() &&\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        // Generate nicer LLVM for the common case of a `for` loop pattern\n-        // like `for x in blahblah { ... }`.\n-        let binding_type = node_id_type(bcx, pat.id);\n-        bcx.fcx.lllocals.borrow_mut().insert(pat.id,\n-                                             Datum::new(llvalue,\n-                                                        binding_type,\n-                                                        Lvalue));\n-        return bcx\n-    }\n-\n-    // General path. Copy out the values that are used in the pattern.\n-    bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n-}\n-\n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n                                        ident: &ast::Ident,"}, {"sha": "c4388603145fe2796b46a0926ef3d7e57c135cb2", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -11,26 +11,19 @@\n use llvm::ValueRef;\n use middle::def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n-use trans::_match;\n-use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::common::*;\n use trans::consts;\n-use trans::datum;\n use trans::debuginfo;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n-use trans::meth;\n-use trans::type_::Type;\n use trans;\n use middle::ty;\n-use middle::ty::MethodCall;\n use util::ppaux::Repr;\n-use util::ppaux;\n \n use syntax::ast;\n use syntax::ast::Ident;\n@@ -259,135 +252,6 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return next_bcx_in;\n }\n \n-/// Translates a `for` loop.\n-pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeIdAndSpan,\n-                             pat: &ast::Pat,\n-                             head: &ast::Expr,\n-                             body: &ast::Block)\n-                             -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"trans_for\");\n-\n-    //            bcx\n-    //             |\n-    //      loopback_bcx_in  <-------+\n-    //             |                 |\n-    //      loopback_bcx_out         |\n-    //           |      |            |\n-    //           |    body_bcx_in    |\n-    // cleanup_blk      |            |\n-    //    |           body_bcx_out --+\n-    // next_bcx_in\n-\n-    // Codegen the head to create the iterator value.\n-    let iterator_datum =\n-        unpack_datum!(bcx, expr::trans_to_lvalue(bcx, head, \"for_head\"));\n-    let iterator_type = node_id_type(bcx, head.id);\n-    debug!(\"iterator type is {}, datum type is {}\",\n-           ppaux::ty_to_string(bcx.tcx(), iterator_type),\n-           ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n-\n-    let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n-\n-    // Create our basic blocks and set up our loop cleanups.\n-    let next_bcx_in = bcx.fcx.new_id_block(\"for_exit\", loop_info.id);\n-    let loopback_bcx_in = bcx.fcx.new_id_block(\"for_loopback\", head.id);\n-    let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n-    bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n-                                    [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n-    let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n-                                                 cleanup::EXIT_BREAK);\n-\n-    // Set up the method call (to `.next()`).\n-    let method_call = MethodCall::expr(loop_info.id);\n-    let method_type = (*loopback_bcx_in.tcx()\n-                                     .method_map\n-                                     .borrow())[method_call]\n-                                     .ty;\n-    let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type =\n-        ty::assert_no_late_bound_regions( // LB regions are instantiated in invoked methods\n-            loopback_bcx_in.tcx(), &ty::ty_fn_ret(method_type)).unwrap();\n-    let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n-\n-    // Compile the method call (to `.next()`).\n-    let mut loopback_bcx_out = loopback_bcx_in;\n-    let option_datum =\n-        unpack_datum!(loopback_bcx_out,\n-                      datum::lvalue_scratch_datum(loopback_bcx_out,\n-                                                  method_result_type,\n-                                                  \"loop_option\",\n-                                                  false,\n-                                                  option_cleanup_scope_id,\n-                                                  (),\n-                                                  |(), bcx, lloption| {\n-        let Result {\n-            bcx,\n-            val: _\n-        } = callee::trans_call_inner(bcx,\n-                                     Some(loop_info),\n-                                     method_type,\n-                                     |bcx, arg_cleanup_scope| {\n-                                         meth::trans_method_callee(\n-                                             bcx,\n-                                             method_call,\n-                                             None,\n-                                             arg_cleanup_scope)\n-                                     },\n-                                     callee::ArgVals(&[lliterator]),\n-                                     Some(expr::SaveIn(lloption)));\n-        bcx\n-    }));\n-\n-    // Check the discriminant; if the `None` case, exit the loop.\n-    let option_representation = adt::represent_type(loopback_bcx_out.ccx(),\n-                                                    method_result_type);\n-    let lldiscriminant = adt::trans_get_discr(loopback_bcx_out,\n-                                              &*option_representation,\n-                                              option_datum.val,\n-                                              None);\n-    let i1_type = Type::i1(loopback_bcx_out.ccx());\n-    let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n-\n-    // Now we're in the body. Unpack the `Option` value into the programmer-\n-    // supplied pattern.\n-    let llpayload = adt::trans_field_ptr(body_bcx_in,\n-                                         &*option_representation,\n-                                         option_datum.val,\n-                                         1,\n-                                         0);\n-    let binding_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let binding_cleanup_scope_id =\n-        cleanup::CustomScope(binding_cleanup_scope);\n-    let mut body_bcx_out =\n-        _match::store_for_loop_binding(body_bcx_in,\n-                                       pat,\n-                                       llpayload,\n-                                       binding_cleanup_scope_id);\n-\n-    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n-\n-    // Codegen the body.\n-    body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        binding_cleanup_scope);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n-\n-    // Codegen cleanups and leave.\n-    next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n-    next_bcx_in\n-}\n-\n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               loop_expr: &ast::Expr,\n                               body: &ast::Block)"}, {"sha": "4f9c97795e1987428575ae03b5ae03237bf7d272", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1053,48 +1053,6 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     })\n }\n \n-/// Creates debug information for the given for-loop variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// loop variable in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let def_map = &bcx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      LocalVariable,\n-                      span);\n-    })\n-}\n-\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -3627,24 +3585,9 @@ fn create_scope_map(cx: &CrateContext,\n                                               Found unexpanded while-let.\");\n             }\n \n-            ast::ExprForLoop(ref pattern, ref head, ref body, _) => {\n-                walk_expr(cx, &**head, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               exp.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    scope_map.insert(exp.id,\n-                                     scope_stack.last()\n-                                                .unwrap()\n-                                                .scope_metadata);\n-                    walk_pattern(cx,\n-                                 &**pattern,\n-                                 scope_stack,\n-                                 scope_map);\n-                    walk_block(cx, &**body, scope_stack, scope_map);\n-                })\n+            ast::ExprForLoop(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                              Found unexpanded for loop.\");\n             }\n \n             ast::ExprMac(_) => {"}, {"sha": "46726f78d04f571e2b8616ec4bfb072a38180007", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -927,13 +927,6 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr, &**cond, &**body)\n         }\n-        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-            controlflow::trans_for(bcx,\n-                                   expr_info(expr),\n-                                   &**pat,\n-                                   &**head,\n-                                   &**body)\n-        }\n         ast::ExprLoop(ref body, _) => {\n             controlflow::trans_loop(bcx, expr, &**body)\n         }"}, {"sha": "12bf507c05735fc47940ba6061f1b43b3d98585e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 103, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -87,7 +87,6 @@ use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::{const_eval, def};\n use middle::infer;\n-use middle::lang_items::IteratorItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n@@ -2140,92 +2139,6 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     })\n }\n \n-/// Given the head of a `for` expression, looks up the `next` method in the\n-/// `Iterator` trait. Panics if the expression does not implement `next`.\n-///\n-/// The return type of this function represents the concrete element type\n-/// `A` in the type `Iterator<A>` that the method returns.\n-fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        iterator_expr: &ast::Expr,\n-                                        loop_id: ast::NodeId)\n-                                        -> Ty<'tcx> {\n-    let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n-        Ok(trait_did) => trait_did,\n-        Err(ref err_string) => {\n-            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n-                                    \"{}\", &err_string[]);\n-            return fcx.tcx().types.err\n-        }\n-    };\n-\n-    let expr_type = fcx.expr_ty(&*iterator_expr);\n-    let method = method::lookup_in_trait(fcx,\n-                                         iterator_expr.span,\n-                                         Some(&*iterator_expr),\n-                                         token::intern(\"next\"),\n-                                         trait_did,\n-                                         expr_type,\n-                                         None);\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = match method {\n-        Some(ref method) => method.ty,\n-        None => {\n-            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(&expr_type);\n-\n-            if !ty::type_is_error(true_expr_type) {\n-                let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n-                                        \"`for` loop expression has type `{}` which does \\\n-                                                not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\", ty_string);\n-            }\n-            fcx.tcx().types.err\n-        }\n-    };\n-    let return_type = check_method_argument_types(fcx,\n-                                                  iterator_expr.span,\n-                                                  method_type,\n-                                                  iterator_expr,\n-                                                  &[],\n-                                                  AutorefArgs::No,\n-                                                  DontTupleArguments,\n-                                                  NoExpectation);\n-\n-    match method {\n-        Some(method) => {\n-            fcx.inh.method_map.borrow_mut().insert(MethodCall::expr(loop_id),\n-                                                   method);\n-\n-            // We expect the return type to be `Option` or something like it.\n-            // Grab the first parameter of its type substitution.\n-            let return_type = match return_type {\n-                ty::FnConverging(return_type) =>\n-                    structurally_resolved_type(fcx, iterator_expr.span, return_type),\n-                ty::FnDiverging => fcx.tcx().types.err\n-            };\n-            match return_type.sty {\n-                ty::ty_enum(_, ref substs)\n-                        if !substs.types.is_empty_in(subst::TypeSpace) => {\n-                    *substs.types.get(subst::TypeSpace, 0)\n-                }\n-                ty::ty_err => {\n-                    fcx.tcx().types.err\n-                }\n-                _ => {\n-                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n-                                            \"`next` method of the `Iterator` \\\n-                                                    trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type));\n-                    fcx.tcx().types.err\n-                }\n-            }\n-        }\n-        None => fcx.tcx().types.err\n-    }\n-}\n-\n fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n@@ -3762,22 +3675,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprWhileLet(..) => {\n         tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n-        check_expr(fcx, &**head);\n-        let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable::select_new_fcx_obligations(fcx);\n-\n-        debug!(\"ExprForLoop each item has type {}\",\n-               fcx.infcx().resolve_type_vars_if_possible(&typ).repr(fcx.tcx()));\n-\n-        let pcx = pat_ctxt {\n-            fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &**pat),\n-        };\n-        _match::check_pat(&pcx, &**pat, typ);\n-\n-        check_block_no_value(fcx, &**block);\n-        fcx.write_nil(id);\n+      ast::ExprForLoop(..) => {\n+        tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);"}, {"sha": "8b5ad1357004e5de2f2466b0a62699311e289ffd", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -658,30 +658,6 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n-            constrain_bindings_in_pat(&**pat, rcx);\n-\n-            {\n-                let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                let pat_ty = rcx.resolve_node_type(pat.id);\n-                let pat_cmt = mc.cat_rvalue(pat.id,\n-                                            pat.span,\n-                                            ty::ReScope(CodeExtent::from_node_id(body.id)),\n-                                            pat_ty);\n-                link_pattern(rcx, mc, pat_cmt, &**pat);\n-            }\n-\n-            rcx.visit_expr(&**head);\n-            type_of_node_must_outlive(rcx,\n-                                      infer::AddrOf(expr.span),\n-                                      head.id,\n-                                      ty::ReScope(CodeExtent::from_node_id(expr.id)));\n-\n-            let repeating_scope = rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body);\n-            rcx.set_repeating_scope(repeating_scope);\n-        }\n-\n         _ => {\n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "98f997c5990ba43de4e5f8749afdb62d47b9476d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -84,6 +84,8 @@ This API is completely unstable and subject to change.\n #![feature(core)]\n #![feature(rustc_private)]\n #![feature(std_misc)]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "4e811844ea9b62f2e2fe953828ec374a47a58814", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -32,6 +32,8 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(hash)]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "b1c1dd1a9f65ba2f9153cbc5e8271177088ca006", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -1772,7 +1772,7 @@ mod test_map {\n                 }\n             });\n \n-            for _ in half {}\n+            for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n                 let nk = (0u..100).filter(|&i| {"}, {"sha": "141c51d8363d86de319d49ae3842347fa49747f5", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -15,7 +15,7 @@ use self::BucketState::*;\n use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n-use iter::{Iterator, ExactSizeIterator, count};\n+use iter::{Iterator, IteratorExt, ExactSizeIterator, count};\n use marker::{Copy, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n@@ -921,7 +921,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n #[unsafe_destructor]\n impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n     fn drop(&mut self) {\n-        for _ in *self {}\n+        for _ in self.by_ref() {}\n     }\n }\n "}, {"sha": "54e2eaf16ee10764264e284f3b82112170ad4977", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -123,6 +123,8 @@\n #![feature(rand)]\n #![feature(hash)]\n #![cfg_attr(test, feature(test))]\n+// NOTE(stage0): remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n // Don't link to std. We are std.\n #![no_std]\n@@ -310,4 +312,6 @@ mod std {\n     pub use slice;\n \n     pub use boxed; // used for vec![]\n+    // for-loops\n+    pub use iter;\n }"}, {"sha": "98e0320cd14d21f0c8ee7ae20fbe36b3cb62b5b5", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -557,7 +557,7 @@ impl GenericPath for Path {\n                     }\n                     (Some(a), Some(_)) => {\n                         comps.push(\"..\");\n-                        for _ in itb {\n+                        for _ in itb.by_ref() {\n                             comps.push(\"..\");\n                         }\n                         comps.push(a);"}, {"sha": "a71676c6bf229984c65710829674622a86305110", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -54,7 +54,7 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n         let mut chars = inner.chars();\n         while valid {\n             let mut i = 0;\n-            for c in chars {\n+            for c in chars.by_ref() {\n                 if c.is_numeric() {\n                     i = i * 10 + c as uint - '0' as uint;\n                 } else {"}, {"sha": "d7283db25a5f2eedc23e4347b721e79716b599ce", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -788,6 +788,7 @@ pub enum MatchSource {\n     Normal,\n     IfLetDesugar { contains_else_clause: bool },\n     WhileLetDesugar,\n+    ForLoopDesugar,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "5736400313e95f92dd40f5c6e5cd682f500836a6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -225,11 +225,101 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n+        // Desugar ExprForLoop\n+        // From: `[opt_ident]: for <pat> in <head> <body>`\n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n+            // to:\n+            //\n+            //   match ::std::iter::IntoIterator::into_iter(<head>) {\n+            //     mut iter => {\n+            //       [opt_ident]: loop {\n+            //         match ::std::iter::Iterator::next(&mut iter) {\n+            //           ::std::option::Option::Some(<pat>) => <body>,\n+            //           ::std::option::Option::None => break\n+            //         }\n+            //       }\n+            //     }\n+            //   }\n+\n+            // expand <head>\n             let head = fld.fold_expr(head);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n+\n+            // create an hygienic ident\n+            let iter = {\n+                let ident = fld.cx.ident_of(\"iter\");\n+                let new_ident = fresh_name(&ident);\n+                let rename = (ident, new_ident);\n+                let mut rename_list = vec![rename];\n+                let mut rename_fld = IdentRenamer{ renames: &mut rename_list };\n+\n+                rename_fld.fold_ident(ident)\n+            };\n+\n+            let pat_span = pat.span;\n+            // `:;std::option::Option::Some(<pat>) => <body>`\n+            let pat_arm = {\n+                let body_expr = fld.cx.expr_block(body);\n+                let some_pat = fld.cx.pat_some(pat_span, pat);\n+\n+                fld.cx.arm(pat_span, vec![some_pat], body_expr)\n+            };\n+\n+            // `::std::option::Option::None => break`\n+            let break_arm = {\n+                let break_expr = fld.cx.expr_break(span);\n+\n+                fld.cx.arm(span, vec![fld.cx.pat_none(span)], break_expr)\n+            };\n+\n+            // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+            let match_expr = {\n+                let next_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"Iterator\"),\n+                        fld.cx.ident_of(\"next\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+                let ref_mut_iter = fld.cx.expr_mut_addr_of(span, fld.cx.expr_ident(span, iter));\n+                let next_expr =\n+                    fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n+                let arms = vec![pat_arm, break_arm];\n+\n+                fld.cx.expr(pat_span,\n+                            ast::ExprMatch(next_expr, arms, ast::MatchSource::ForLoopDesugar))\n+            };\n+\n+            // `[opt_ident]: loop { ... }`\n+            let loop_block = fld.cx.block_expr(match_expr);\n+            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n+            let loop_expr = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n+\n+            // `mut iter => { ... }`\n+            let iter_arm = {\n+                let iter_pat =\n+                    fld.cx.pat_ident_binding_mode(span, iter, ast::BindByValue(ast::MutMutable));\n+                fld.cx.arm(span, vec![iter_pat], loop_expr)\n+            };\n+\n+            // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+            let into_iter_expr = {\n+                let into_iter_path = {\n+                    let strs = vec![\n+                        fld.cx.ident_of(\"std\"),\n+                        fld.cx.ident_of(\"iter\"),\n+                        fld.cx.ident_of(\"IntoIterator\"),\n+                        fld.cx.ident_of(\"into_iter\"),\n+                    ];\n+\n+                    fld.cx.path_global(span, strs)\n+                };\n+\n+                fld.cx.expr_call(span, fld.cx.expr_path(into_iter_path), vec![head])\n+            };\n+            fld.cx.expr_match(span, into_iter_expr, vec![iter_arm])\n         }\n \n         ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {"}, {"sha": "5b78d5b1405e730d33da1ac0d2b6f03f86a3166e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -39,6 +39,8 @@\n #![feature(rustc_private)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+// NOTE(stage0) remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "4497832ba7ecde4f0267998c1e291d9948828278", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -44,6 +44,8 @@\n #![feature(rustc_private)]\n #![feature(std_misc)]\n #![feature(hash)]\n+// NOTE(stage0): remove cfg_attr after a snapshot\n+#![cfg_attr(not(stage0), allow(unused_mut))]\n \n extern crate getopts;\n extern crate serialize;"}, {"sha": "659d57b729214e65dbcb19b9bc56e661e4c0f130", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -84,4 +84,7 @@ mod std {\n     pub use core::cmp;\n     pub use core::fmt;\n     pub use core::marker;\n+    // for-loops\n+    pub use core::iter;\n+    pub use core::option;\n }"}, {"sha": "9a757c0c980dde279e0e2412fb6af74ac34c5906", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -447,7 +447,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n             Some(Utf16Item::LoneSurrogate(u))\n         } else {\n             // preserve state for rewinding.\n-            let old = self.iter;\n+            let old = self.iter.clone();\n \n             let u2 = match self.iter.next() {\n                 Some(u2) => *u2,\n@@ -457,7 +457,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n             if u2 < 0xDC00 || u2 > 0xDFFF {\n                 // not a trailing surrogate so we're not a valid\n                 // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n+                self.iter = old.clone();\n                 return Some(Utf16Item::LoneSurrogate(u))\n             }\n "}, {"sha": "c5b3fceaf4a5febc01773f6a43254baf8f587e42", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -15,7 +15,7 @@ pub struct TreeBuilder<H>;\n impl<H> TreeBuilder<H> {\n     pub fn process_token(&mut self) {\n         match self {\n-            _ => for _y in *self {}\n+            _ => for _y in self.by_ref() {}\n         }\n     }\n }"}, {"sha": "6bc0e74a2eb58f16b8f0d4e970069a0e65a695db", "filename": "src/test/compile-fail/for-loop-bogosity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -24,7 +24,10 @@ pub fn main() {\n         x: 1,\n         y: 2,\n     };\n-    for x in bogus { //~ ERROR has type `MyStruct` which does not implement the `Iterator` trait\n+    for x in bogus { //~ ERROR `core::iter::Iterator` is not implemented for the type `MyStruct`\n+    //~^ ERROR\n+    //~^^ ERROR\n+    // FIXME(#21528) not fulfilled obligation error should be reported once, not thrice\n         drop(x);\n     }\n }"}, {"sha": "ff6f848ab598d7313ca216841d7d9a24c73e2c8e", "filename": "src/test/compile-fail/for-loop-hygiene.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// for-loops are expanded in the front end, and use an `iter` ident in their expansion. Check that\n+// `iter` is not accessible inside the for loop.\n+\n+#![allow(unstable)]\n+\n+fn main() {\n+    for _ in 0..10 {\n+        iter.next();  //~ error: unresolved name `iter`\n+    }\n+}"}, {"sha": "fa55e7215c0b260698751fee63b6eec7ef743f97", "filename": "src/test/compile-fail/for-loop-refutable-pattern-error-message.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n fn main() {\n     for\n         &1is //~ ERROR refutable pattern in `for` loop binding"}, {"sha": "251da2c6b3ee979c020bf7e21c55d490c5a4dadd", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -32,7 +32,7 @@ impl Node for Stuff {\n \n fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n     for node in graph.iter() { //~ ERROR does not implement any method in scope named\n-        node.zomg();\n+        node.zomg();  //~ error: the type of this value must be known in this context\n     }\n }\n "}, {"sha": "f336fdbfbed9552d6210296fc14b52aefccd51f6", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(unused_variables)]\n+#![feature(core)]\n \n fn main() {\n     for _ in 1is..101 {"}, {"sha": "87b7616db8ed23b35619a2f6603e55a5f48e95a7", "filename": "src/test/compile-fail/issue-20605.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20605.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn changer<'a>(mut things: Box<Iterator<Item=&'a mut u8>>) {\n+    for item in *things { *item = 0 }\n+//~^ ERROR the trait `core::marker::Sized` is not implemented for the type `core::iter::Iterator\n+//~^^ ERROR\n+//~^^^ ERROR\n+// FIXME(#21528) error should be reported once, not thrice\n+}\n+\n+fn main() {}"}, {"sha": "68195985eec4ba2fd2f6019be389995530483f46", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -11,6 +11,7 @@\n #![deny(unreachable_code)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n+#![feature(core)]\n \n fn fail_len(v: Vec<isize> ) -> usize {\n     let mut i = 3;"}, {"sha": "ebcf46f7277d6f41e23d5cdf0c02ef3c28258198", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -11,6 +11,7 @@\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n+#![feature(core)]\n #![feature(os)]\n \n fn f1(x: isize) {"}, {"sha": "fbc9ad99b72434c8299f7a5f13ee37a7eb73603a", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -17,7 +17,10 @@ pub fn main() {\n \n     // Float => does not implement iterator.\n     for i in 0f32..42f32 {}\n-    //~^ ERROR `for` loop expression has type `core::ops::Range<f32>` which does not implement\n+    //~^ ERROR `core::iter::Iterator` is not implemented for the type `core::ops::Range<f32>`\n+    //~^^ ERROR\n+    //~^^^ ERROR\n+    // FIXME(#21528) not fulfilled obligation error should be reported once, not thrice\n \n     // Unsized type.\n     let arr: &[_] = &[1us, 2, 3];"}, {"sha": "7564efbd9e56ba483ebe65f102df68dbf1f06814", "filename": "src/test/run-pass/for-loop-into-iterator.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Ffor-loop-into-iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Ffor-loop-into-iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-into-iterator.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that for loops can do what RFC #235 claims\n+\n+fn main() {\n+    let mut v = vec![1];\n+\n+    for x in &v {\n+        assert_eq!(x, &1);\n+    }\n+\n+    for x in &mut v {\n+        assert_eq!(x, &mut 1);\n+    }\n+\n+    for x in v {\n+        assert_eq!(x, 1);\n+    }\n+}"}, {"sha": "7c71c8ea464db43996963c83e03a004560d78ef4", "filename": "src/test/run-pass/foreach-external-iterators-hashmap-break-restart.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-external-iterators-hashmap-break-restart.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n \n     let mut i = h.iter();\n \n-    for (&k,&v) in i {\n+    for (&k,&v) in i.by_ref() {\n         x += k;\n         y += v;\n         break;"}, {"sha": "b9b1e5f3337cd1b7791785550c8b191dc069321a", "filename": "src/test/run-pass/issue-21655.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Fissue-21655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341e858bd882061b823dac236fd718d473f8ab2e/src%2Ftest%2Frun-pass%2Fissue-21655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21655.rs?ref=341e858bd882061b823dac236fd718d473f8ab2e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn test(it: &mut Iterator<Item=i32>) {\n+    for x in it {\n+        assert_eq!(x, 1)\n+    }\n+}\n+\n+fn main() {\n+    let v = vec![1];\n+    test(&mut v.into_iter())\n+}"}]}