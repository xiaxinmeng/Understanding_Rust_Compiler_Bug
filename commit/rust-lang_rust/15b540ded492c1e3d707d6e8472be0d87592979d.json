{"sha": "15b540ded492c1e3d707d6e8472be0d87592979d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YjU0MGRlZDQ5MmMxZTNkNzA3ZDZlODQ3MmJlMGQ4NzU5Mjk3OWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-24T14:30:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-24T14:57:33Z"}, "message": "Use a single builder object throughout\n\nThis seems to be faster than creating separate ones for each block\ncontext.", "tree": {"sha": "bb383eb1c9caa5ad3614c13b3aaa20e0d466388d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb383eb1c9caa5ad3614c13b3aaa20e0d466388d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15b540ded492c1e3d707d6e8472be0d87592979d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15b540ded492c1e3d707d6e8472be0d87592979d", "html_url": "https://github.com/rust-lang/rust/commit/15b540ded492c1e3d707d6e8472be0d87592979d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15b540ded492c1e3d707d6e8472be0d87592979d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9112525ba27d46e056dcab303c27bb43073c4fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9112525ba27d46e056dcab303c27bb43073c4fc", "html_url": "https://github.com/rust-lang/rust/commit/b9112525ba27d46e056dcab303c27bb43073c4fc"}], "stats": {"total": 384, "additions": 271, "deletions": 113}, "files": [{"sha": "f694bd3c82d04dfd85c5e6447f7861ca8be788cb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=15b540ded492c1e3d707d6e8472be0d87592979d", "patch": "@@ -4889,7 +4889,6 @@ fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n     let llbb: BasicBlockRef = llvm::LLVMAppendBasicBlock(cx.llfn, s);\n     ret @{llbb: llbb,\n           mutable terminated: false,\n-          build: bld::BuilderRef_res(bld::mk_builder(llbb)),\n           parent: parent,\n           kind: kind,\n           mutable cleanups: [],\n@@ -4925,7 +4924,6 @@ fn new_sub_block_ctxt(bcx: &@block_ctxt, n: &str) -> @block_ctxt {\n fn new_raw_block_ctxt(fcx: &@fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n     ret @{llbb: llbb,\n           mutable terminated: false,\n-          build: bld::BuilderRef_res(bld::mk_builder(llbb)),\n           parent: parent_none,\n           kind: NON_SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -4992,7 +4990,6 @@ iter block_locals(b: &ast::blk) -> @ast::local {\n fn llstaticallocas_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n     ret @{llbb: fcx.llstaticallocas,\n           mutable terminated: false,\n-          build: bld::BuilderRef_res(bld::mk_builder(fcx.llstaticallocas)),\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -5003,7 +5000,6 @@ fn llstaticallocas_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n fn llderivedtydescs_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n     ret @{llbb: fcx.llderivedtydescs,\n           mutable terminated: false,\n-          build: bld::BuilderRef_res(bld::mk_builder(fcx.llderivedtydescs)),\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n@@ -6210,15 +6206,6 @@ fn decl_no_op_type_glue(llmod: ModuleRef, taskptr_type: TypeRef) -> ValueRef {\n     ret decl_fastcall_fn(llmod, abi::no_op_type_glue_name(), ty);\n }\n \n-fn make_no_op_type_glue(fun: ValueRef) {\n-    let bb_name = str::buf(\"_rust_no_op_type_glue_bb\");\n-    let llbb = llvm::LLVMAppendBasicBlock(fun, bb_name);\n-    let llbuild = llvm::LLVMCreateBuilder();\n-    llvm::LLVMPositionBuilderAtEnd(llbuild, llbb);\n-    llvm::LLVMBuildRetVoid(llbuild);\n-    llvm::LLVMDisposeBuilder(llbuild);\n-}\n-\n fn vec_fill(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n     ret bld::Load(bcx, bld::GEP(bcx, v,\n                                      [C_int(0), C_int(abi::vec_elt_fill)]));\n@@ -6397,6 +6384,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n           task_type: task_type,\n+          builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n           shape_cx: shape::mk_ctxt(llmod),\n           gc_cx: gc::mk_ctxt()};\n     let cx = new_local_ctxt(ccx);"}, {"sha": "d1a5055d589c9afc542adbbcd127b959a4dfd4b2", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 265, "deletions": 99, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=15b540ded492c1e3d707d6e8472be0d87592979d", "patch": "@@ -5,354 +5,492 @@ import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n               Opcode, ModuleRef};\n import trans_common::block_ctxt;\n \n-resource BuilderRef_res(B: llvm::BuilderRef) {\n-    llvm::LLVMDisposeBuilder(B);\n-}\n-\n-fn mk_builder(llbb: BasicBlockRef) -> BuilderRef {\n-    let B = llvm::LLVMCreateBuilder();\n-    llvm::LLVMPositionBuilderAtEnd(B, llbb);\n-    ret B;\n-}\n-\n fn RetVoid(cx: &@block_ctxt) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildRetVoid(*cx.build);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildRetVoid(B);\n }\n \n fn Ret(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildRet(*cx.build, V);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildRet(B, V);\n }\n \n fn AggregateRet(cx: &@block_ctxt, RetVals: &[ValueRef]) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildAggregateRet(*cx.build, vec::to_ptr(RetVals),\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildAggregateRet(B, vec::to_ptr(RetVals),\n                                     vec::len(RetVals));\n }\n \n fn Br(cx: &@block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildBr(*cx.build, Dest);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildBr(B, Dest);\n }\n \n fn CondBr(cx: &@block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildCondBr(*cx.build, If, Then, Else);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildCondBr(B, If, Then, Else);\n }\n \n fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef,\n           NumCases: uint) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildSwitch(*cx.build, V, Else, NumCases);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSwitch(B, V, Else, NumCases);\n }\n \n fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef,\n               NumDests: uint) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildIndirectBr(*cx.build, Addr, NumDests);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n }\n \n fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildInvoke(*cx.build, Fn, vec::to_ptr(Args),\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args),\n                               vec::len(Args), Then, Catch, str::buf(\"\"));\n }\n \n fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildUnreachable(*cx.build);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildUnreachable(B);\n }\n \n /* Arithmetic */\n fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildAdd(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNSWAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNUWAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFAdd(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFAdd(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSub(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNSWSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNSWSub(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNUWSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNUWSub(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFSub(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFSub(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildMul(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNSWMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNSWMul(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNUWMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNUWMul(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFMul(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFMul(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildUDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildUDiv(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildSDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSDiv(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildExactSDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFDiv(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFDiv(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildURem(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildURem(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildSRem(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSRem(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFRem(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFRem(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildShl(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildShl(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildLShr(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildLShr(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildAShr(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildAShr(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildAnd(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildAnd(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildOr(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildOr(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildXor(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildXor(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n          RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildBinOp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, str::buf(\"\"));\n }\n \n fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNeg(*cx.build, V, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNeg(B, V, str::buf(\"\"));\n }\n \n fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNSWNeg(*cx.build, V, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNSWNeg(B, V, str::buf(\"\"));\n }\n \n fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNUWNeg(*cx.build, V, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNUWNeg(B, V, str::buf(\"\"));\n }\n fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFNeg(*cx.build, V, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFNeg(B, V, str::buf(\"\"));\n }\n fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildNot(*cx.build, V, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildNot(B, V, str::buf(\"\"));\n }\n \n /* Memory */\n fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildMalloc(*cx.build, Ty, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildMalloc(B, Ty, str::buf(\"\"));\n }\n \n fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildArrayMalloc(*cx.build, Ty, Val, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, str::buf(\"\"));\n }\n \n fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildAlloca(*cx.build, Ty, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildAlloca(B, Ty, str::buf(\"\"));\n }\n \n fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildArrayAlloca(*cx.build, Ty, Val, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, str::buf(\"\"));\n }\n \n fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFree(*cx.build, PointerVal);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFree(B, PointerVal);\n }\n \n fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildLoad(*cx.build, PointerVal, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildLoad(B, PointerVal, str::buf(\"\"));\n }\n \n fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildStore(*cx.build, Val, Ptr);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildStore(B, Val, Ptr);\n }\n \n fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n        Indices: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMBuildGEP(*cx.build, Pointer, vec::to_ptr(Indices),\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n                            vec::len(Indices), str::buf(\"\"));\n }\n \n fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n                Indices: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMBuildInBoundsGEP(*cx.build, Pointer, vec::to_ptr(Indices),\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n                                    vec::len(Indices), str::buf(\"\"));\n }\n \n fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    ret llvm::LLVMBuildStructGEP(*cx.build, Pointer, Idx, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, str::buf(\"\"));\n }\n \n fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret llvm::LLVMBuildGlobalString(*cx.build, _Str, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildGlobalString(B, _Str, str::buf(\"\"));\n }\n \n fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret llvm::LLVMBuildGlobalStringPtr(*cx.build, _Str, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildGlobalStringPtr(B, _Str, str::buf(\"\"));\n }\n \n /* Casts */\n fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildTrunc(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildTrunc(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildZExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildZExt(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildSExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSExt(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildFPToUI(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFPToUI(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildFPToSI(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFPToSI(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildUIToFP(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildUIToFP(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildSIToFP(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSIToFP(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildFPTrunc(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildFPExt(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFPExt(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildPtrToInt(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildIntToPtr(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildBitCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildZExtOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildSExtOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                   DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildTruncOrBitCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n         DestTy: TypeRef, _Name: sbuf) ->\n     ValueRef {\n-    ret llvm::LLVMBuildCast(*cx.build, Op, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildCast(B, Op, Val, DestTy, str::buf(\"\"));\n }\n \n fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildPointerCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildPointerCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildIntCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildIntCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildFPCast(*cx.build, Val, DestTy, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFPCast(B, Val, DestTy, str::buf(\"\"));\n }\n \n \n /* Comparisons */\n fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildICmp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, str::buf(\"\"));\n }\n \n fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildFCmp(*cx.build, Op, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, str::buf(\"\"));\n }\n \n \n /* Miscellaneous instructions */\n fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n        bbs: &[BasicBlockRef]) -> ValueRef {\n-    let phi = llvm::LLVMBuildPhi(*cx.build, Ty, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n@@ -366,84 +504,112 @@ fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n }\n \n fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                             str::buf(\"\"));\n }\n \n fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     let v =\n-        llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                             str::buf(\"\"));\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n     ret v;\n }\n \n fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n                 Conv: uint) -> ValueRef {\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     let v =\n-        llvm::LLVMBuildCall(*cx.build, Fn, vec::to_ptr(Args), vec::len(Args),\n+        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                             str::buf(\"\"));\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n     ret v;\n }\n \n fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n           Else: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildSelect(*cx.build, If, Then, Else, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildSelect(B, If, Then, Else, str::buf(\"\"));\n }\n \n fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    ret llvm::LLVMBuildVAArg(*cx.build, list, Ty, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildVAArg(B, list, Ty, str::buf(\"\"));\n }\n \n fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n                   Index: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildExtractElement(*cx.build, VecVal, Index, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildExtractElement(B, VecVal, Index, str::buf(\"\"));\n }\n \n fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) ->\n     ValueRef {\n-    ret llvm::LLVMBuildInsertElement(*cx.build, VecVal, EltVal, Index,\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n                                      str::buf(\"\"));\n }\n \n fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildShuffleVector(*cx.build, V1, V2, Mask, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, str::buf(\"\"));\n }\n \n fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    ret llvm::LLVMBuildExtractValue(*cx.build, AggVal, Index, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildExtractValue(B, AggVal, Index, str::buf(\"\"));\n }\n \n fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n                EltVal: ValueRef, Index: uint) -> ValueRef {\n-    ret llvm::LLVMBuildInsertValue(*cx.build, AggVal, EltVal, Index,\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index,\n                                    str::buf(\"\"));\n }\n \n fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildIsNull(*cx.build, Val, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildIsNull(B, Val, str::buf(\"\"));\n }\n \n fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildIsNotNull(*cx.build, Val, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildIsNotNull(B, Val, str::buf(\"\"));\n }\n \n fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret llvm::LLVMBuildPtrDiff(*cx.build, LHS, RHS, str::buf(\"\"));\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, str::buf(\"\"));\n }\n \n fn Trap(cx: &@block_ctxt) -> ValueRef {\n-    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(*cx.build);\n+    let B = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n+    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(B);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n     let T: ValueRef =\n         llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    ret llvm::LLVMBuildCall(*cx.build, T, vec::to_ptr(Args), vec::len(Args),\n+    ret llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args),\n                             str::buf(\"\"));\n }\n "}, {"sha": "b457ff22b3077fb3af1f29e13bc0c21da933494c", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b540ded492c1e3d707d6e8472be0d87592979d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=15b540ded492c1e3d707d6e8472be0d87592979d", "patch": "@@ -111,6 +111,10 @@ type stats =\n      mutable n_real_glues: uint,\n      fn_times: @mutable [{ident: str, time: int}]};\n \n+resource BuilderRef_res(B: llvm::BuilderRef) {\n+    llvm::LLVMDisposeBuilder(B);\n+}\n+\n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n     // A mapping from the def_id of each item in this crate to the address\n@@ -149,6 +153,7 @@ type crate_ctxt =\n      rust_object_type: TypeRef,\n      tydesc_type: TypeRef,\n      task_type: TypeRef,\n+     builder: BuilderRef_res,\n      shape_cx: shape::ctxt,\n      gc_cx: gc::ctxt};\n \n@@ -401,7 +406,6 @@ type block_ctxt =\n     // attached.\n     {llbb: BasicBlockRef,\n      mutable terminated: bool,\n-     build: bld::BuilderRef_res,\n      parent: block_parent,\n      kind: block_kind,\n      mutable cleanups: [cleanup],"}]}