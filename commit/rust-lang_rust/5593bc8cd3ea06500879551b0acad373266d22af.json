{"sha": "5593bc8cd3ea06500879551b0acad373266d22af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1OTNiYzhjZDNlYTA2NTAwODc5NTUxYjBhY2FkMzczMjY2ZDIyYWY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-05-14T14:12:58Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-05-14T14:12:58Z"}, "message": "Update cranelift", "tree": {"sha": "a786b1a2bf3dfa59c77fb6147d7e3b9ee1f29d39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a786b1a2bf3dfa59c77fb6147d7e3b9ee1f29d39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5593bc8cd3ea06500879551b0acad373266d22af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5593bc8cd3ea06500879551b0acad373266d22af", "html_url": "https://github.com/rust-lang/rust/commit/5593bc8cd3ea06500879551b0acad373266d22af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5593bc8cd3ea06500879551b0acad373266d22af/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0046ce4c85d7db52923578a0d907597aa26b61e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0046ce4c85d7db52923578a0d907597aa26b61e4", "html_url": "https://github.com/rust-lang/rust/commit/0046ce4c85d7db52923578a0d907597aa26b61e4"}], "stats": {"total": 175, "additions": 100, "deletions": 75}, "files": [{"sha": "2bc1af2fc59a50c7446516c29241d1cac4832490", "filename": "src/base.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=5593bc8cd3ea06500879551b0acad373266d22af", "patch": "@@ -9,14 +9,13 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n ) {\n     let tcx = cx.tcx;\n \n-    // Step 1. Get mir\n     let mir = tcx.instance_mir(instance.def);\n \n-    // Step 2. Check fn sig for u128 and i128 and replace those functions with a trap.\n+    // Check fn sig for u128 and i128 and replace those functions with a trap.\n     {\n         // FIXME implement u128 and i128 support\n \n-        // Step 2a. Check sig for u128 and i128\n+        // Check sig for u128 and i128\n         let fn_sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &instance.fn_sig(tcx));\n \n         struct UI128Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, bool);\n@@ -35,12 +34,12 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         let mut visitor = UI128Visitor(tcx, false);\n         fn_sig.visit_with(&mut visitor);\n \n-        // Step 2b. If found replace function with a trap.\n+        //If found replace function with a trap.\n         if visitor.1 {\n             tcx.sess.warn(\"u128 and i128 are not yet supported. \\\n             Functions using these as args will be replaced with a trap.\");\n \n-            // Step 2b1. Declare function with fake signature\n+            // Declare function with fake signature\n             let sig = Signature {\n                 params: vec![AbiParam::new(types::INVALID)],\n                 returns: vec![],\n@@ -49,7 +48,7 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n             let name = tcx.symbol_name(instance).as_str();\n             let func_id = cx.module.declare_function(&*name, linkage, &sig).unwrap();\n \n-            // Step 2b2. Create trapping function\n+            // Create trapping function\n             let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n             let mut func_ctx = FunctionBuilderContext::new();\n             let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n@@ -79,7 +78,7 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n             fx.bcx.seal_all_blocks();\n             fx.bcx.finalize();\n \n-            // Step 2b3. Define function\n+            // Define function\n             cx.caches.context.func = func;\n             cx.module\n                 .define_function(func_id, &mut cx.caches.context)\n@@ -89,27 +88,27 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         }\n     }\n \n-    // Step 3. Declare function\n+    // Declare function\n     let (name, sig) = get_function_name_and_sig(tcx, instance, false);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n     let mut debug_context = cx\n         .debug_context\n         .as_mut()\n         .map(|debug_context| FunctionDebugContext::new(tcx, debug_context, mir, &name, &sig));\n \n-    // Step 4. Make FunctionBuilder\n+    // Make FunctionBuilder\n     let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n \n-    // Step 5. Predefine ebb's\n+    // Predefine ebb's\n     let start_ebb = bcx.create_ebb();\n     let mut ebb_map: HashMap<BasicBlock, Ebb> = HashMap::new();\n     for (bb, _bb_data) in mir.basic_blocks().iter_enumerated() {\n         ebb_map.insert(bb, bcx.create_ebb());\n     }\n \n-    // Step 6. Make FunctionCx\n+    // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n@@ -131,38 +130,46 @@ pub fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         source_info_set: indexmap::IndexSet::new(),\n     };\n \n-    // Step 7. Codegen function\n     with_unimpl_span(fx.mir.span, || {\n         crate::abi::codegen_fn_prelude(&mut fx, start_ebb);\n         codegen_fn_content(&mut fx);\n     });\n-    let source_info_set = fx.source_info_set.clone();\n \n-    // Step 8. Write function to file for debugging\n+    // Recover all necessary data from fx, before accessing func will prevent future access to it.\n+    let instance = fx.instance;\n+    let clif_comments = fx.clif_comments;\n+    let source_info_set = fx.source_info_set;\n+\n     #[cfg(debug_assertions)]\n-    fx.write_clif_file();\n+    crate::pretty_clif::write_clif_file(cx.tcx, \"unopt\", instance, &func, &clif_comments, None);\n \n-    // Step 9. Verify function\n-    verify_func(tcx, fx.clif_comments, &func);\n+    // Verify function\n+    verify_func(tcx, &clif_comments, &func);\n \n-    // Step 10. Define function\n-    cx.caches.context.func = func;\n+    // Define function\n+    let context = &mut cx.caches.context;\n+    context.func = func;\n     cx.module\n-        .define_function(func_id, &mut cx.caches.context)\n+        .define_function(func_id, context)\n         .unwrap();\n \n-    // Step 11. Define debuginfo for function\n-    let context = &cx.caches.context;\n+    let value_ranges = context.build_value_labels_ranges(cx.module.isa()).expect(\"value location ranges\");\n+\n+    // Write optimized function to file for debugging\n+    #[cfg(debug_assertions)]\n+    crate::pretty_clif::write_clif_file(cx.tcx, \"opt\", instance, &context.func, &clif_comments, Some(&value_ranges));\n+\n+    // Define debuginfo for function\n     let isa = cx.module.isa();\n     debug_context\n         .as_mut()\n         .map(|x| x.define(tcx, context, isa, &source_info_set));\n \n-    // Step 12. Clear context to make it usable for the next function\n-    cx.caches.context.clear();\n+    // Clear context to make it usable for the next function\n+    context.clear();\n }\n \n-fn verify_func(tcx: TyCtxt, writer: crate::pretty_clif::CommentWriter, func: &Function) {\n+fn verify_func(tcx: TyCtxt, writer: &crate::pretty_clif::CommentWriter, func: &Function) {\n     let flags = settings::Flags::new(settings::builder());\n     match ::cranelift::codegen::verify_function(&func, &flags) {\n         Ok(_) => {}\n@@ -171,7 +178,7 @@ fn verify_func(tcx: TyCtxt, writer: crate::pretty_clif::CommentWriter, func: &Fu\n             let pretty_error = ::cranelift::codegen::print_errors::pretty_verifier_error(\n                 &func,\n                 None,\n-                Some(Box::new(&writer)),\n+                Some(Box::new(writer)),\n                 err,\n             );\n             tcx.sess"}, {"sha": "c48482344c79a1e46bdc3193c51454b551268edf", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=5593bc8cd3ea06500879551b0acad373266d22af", "patch": "@@ -1,5 +1,3 @@\n-use std::fmt;\n-\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use cranelift_module::Module;\n@@ -583,23 +581,6 @@ pub struct FunctionCx<'a, 'tcx: 'a, B: Backend> {\n     pub source_info_set: indexmap::IndexSet<SourceInfo>,\n }\n \n-impl<'a, 'tcx: 'a, B: Backend + 'a> fmt::Debug for FunctionCx<'a, 'tcx, B> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        writeln!(f, \"{:?}\", self.instance.substs)?;\n-        writeln!(f, \"{:?}\", self.local_map)?;\n-\n-        let mut clif = String::new();\n-        ::cranelift::codegen::write::decorate_function(\n-            &mut &self.clif_comments,\n-            &mut clif,\n-            &self.bcx.func,\n-            None,\n-        )\n-        .unwrap();\n-        writeln!(f, \"\\n{}\", clif)\n-    }\n-}\n-\n impl<'a, 'tcx: 'a, B: Backend> LayoutOf for FunctionCx<'a, 'tcx, B> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;"}, {"sha": "66b3c66334f80aa4698accfd343f48864dc89efb", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 67, "deletions": 30, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5593bc8cd3ea06500879551b0acad373266d22af/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=5593bc8cd3ea06500879551b0acad373266d22af", "patch": "@@ -2,9 +2,16 @@ use std::borrow::Cow;\n use std::collections::HashMap;\n use std::fmt;\n \n-use cranelift::codegen::entity::SecondaryMap;\n-use cranelift::codegen::ir::entities::AnyEntity;\n-use cranelift::codegen::write::{FuncWriter, PlainWriter};\n+use cranelift::codegen::{\n+    entity::SecondaryMap,\n+    ir::{\n+        self,\n+        entities::AnyEntity,\n+        function::DisplayFunctionAnnotations,\n+    },\n+    write::{FuncWriter, PlainWriter},\n+    ValueLabelsRanges,\n+};\n \n use crate::prelude::*;\n \n@@ -184,42 +191,72 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             }\n         }\n     }\n+}\n+\n+pub fn write_clif_file<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    postfix: &str,\n+    instance: Instance<'tcx>,\n+    func: &ir::Function,\n+    mut clif_comments: &CommentWriter,\n+    value_ranges: Option<&ValueLabelsRanges>,\n+) {\n+    use std::io::Write;\n+\n+    let symbol_name = tcx.symbol_name(instance).as_str();\n+    let clif_file_name = format!(\n+        \"{}/{}__{}.{}.clif\",\n+        concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/target/out/clif\"),\n+        tcx.crate_name(LOCAL_CRATE),\n+        symbol_name,\n+        postfix,\n+    );\n \n-    pub fn write_clif_file(&mut self) {\n-        use std::io::Write;\n+    let mut clif = String::new();\n+    cranelift::codegen::write::decorate_function(\n+        &mut clif_comments,\n+        &mut clif,\n+        &func,\n+        &DisplayFunctionAnnotations {\n+            isa: Some(&*crate::build_isa(tcx.sess)),\n+            value_ranges,\n+        },\n+    )\n+    .unwrap();\n+\n+    match ::std::fs::File::create(clif_file_name) {\n+        Ok(mut file) => {\n+            let target_triple: ::target_lexicon::Triple =\n+                tcx.sess.target.target.llvm_target.parse().unwrap();\n+            writeln!(file, \"test compile\").unwrap();\n+            writeln!(file, \"set is_pic\").unwrap();\n+            writeln!(file, \"target {}\", target_triple).unwrap();\n+            writeln!(file, \"\").unwrap();\n+            file.write(clif.as_bytes()).unwrap();\n+        }\n+        Err(e) => {\n+            tcx.sess.warn(&format!(\"err opening clif file: {:?}\", e));\n+        }\n+    }\n+}\n \n-        let symbol_name = self.tcx.symbol_name(self.instance).as_str();\n-        let clif_file_name = format!(\n-            \"{}/{}__{}.clif\",\n-            concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/target/out/clif\"),\n-            self.tcx.crate_name(LOCAL_CRATE),\n-            symbol_name,\n-        );\n+impl<'a, 'tcx: 'a, B: Backend + 'a> fmt::Debug for FunctionCx<'a, 'tcx, B> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        writeln!(f, \"{:?}\", self.instance.substs)?;\n+        writeln!(f, \"{:?}\", self.local_map)?;\n \n         let mut clif = String::new();\n         ::cranelift::codegen::write::decorate_function(\n             &mut &self.clif_comments,\n             &mut clif,\n             &self.bcx.func,\n-            None,\n+            // FIXME use DisplayFunctionAnnotations::default() instead\n+            &DisplayFunctionAnnotations {\n+                isa: None,\n+                value_ranges: None,\n+            },\n         )\n         .unwrap();\n-\n-        match ::std::fs::File::create(clif_file_name) {\n-            Ok(mut file) => {\n-                let target_triple: ::target_lexicon::Triple =\n-                    self.tcx.sess.target.target.llvm_target.parse().unwrap();\n-                writeln!(file, \"test compile\").unwrap();\n-                writeln!(file, \"set is_pic\").unwrap();\n-                writeln!(file, \"target {}\", target_triple).unwrap();\n-                writeln!(file, \"\").unwrap();\n-                file.write(clif.as_bytes()).unwrap();\n-            }\n-            Err(e) => {\n-                self.tcx\n-                    .sess\n-                    .warn(&format!(\"err opening clif file: {:?}\", e));\n-            }\n-        }\n+        writeln!(f, \"\\n{}\", clif)\n     }\n }"}]}