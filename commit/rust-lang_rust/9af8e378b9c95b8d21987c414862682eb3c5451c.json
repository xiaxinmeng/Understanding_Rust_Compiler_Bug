{"sha": "9af8e378b9c95b8d21987c414862682eb3c5451c", "node_id": "C_kwDOAAsO6NoAKDlhZjhlMzc4YjljOTViOGQyMTk4N2M0MTQ4NjI2ODJlYjNjNTQ1MWM", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-10-21T11:11:36Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-10-21T11:11:36Z"}, "message": "Merge commit '91496c2ac6abf6454c413bb23e8becf6b6dc20ea' into clippyup", "tree": {"sha": "8ddb1a07016d0ca55b16a9d5959359955a1d8a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ddb1a07016d0ca55b16a9d5959359955a1d8a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9af8e378b9c95b8d21987c414862682eb3c5451c", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmFxSusACgkQHKDfKvWd\naKUSpRAAujBB//e0zMVUex7ZA2AfNdhv07XZGhUNX7gvtaGDlXz1HKIL0GL5Fr1k\nxcZ67eP1zfurrrWIZdEBndgbCBCN3tdbDIKQgu2n8RPI9swksIesa60V7fm6av6U\nSCMhMQb8/VD1EpBp7hk+PF/+gnPYMrX3BTxQ5BOiG0hBCfxCPGDLzN8LdTmXiO6L\nFC0Tj2hAsn/5gSAMM68zsD9UdohatO9kxI+SEiZc4jKv5k2RYIwcPrevzmYxwfR3\nrva2CkMvNijPwD94s98Rr3ggWc1lgmozWH4Deuw3q0Evb5ANjFVMmfK/IUbvqCUh\n4wurTxUm6sGuz8MbrvsP5HlMrl6qE0cJQyPMcGkJzZnbcMFwOBN5VDU2dFMAqWvo\n2EwQnUZNu9LBfTO9NkRlJbmYBnwtqABsRKS0+IKISj61qMKgaJ2BMcnv+b6SOcvi\n+uzvU3vhdkG9g8mkgA4uKDHBYCIvjEOV5AV71WmyZ5JZmkvZPcd3s4yTnNvkmF/G\nwWs9FOpH//KsK2qFvUqc4fB72/nD74km3Jr2d2jBaZ4PExsl6TqROHtp2tnIZ7/B\nP9YQrYB94Qb31yTJXT3AEQS5eG/tq+UNNQzQ2CPS7DVs2JNsPjz1vgBYmY1TJIJ4\n2wFYmK11zZUvptN95yYb/W/9hSlgozuDKsU0c8xlDBlk/fdT7Yk=\n=Fm3k\n-----END PGP SIGNATURE-----", "payload": "tree 8ddb1a07016d0ca55b16a9d5959359955a1d8a0b\nparent 40ebd073829959d47b977c168096968a6ed753f9\nparent 91496c2ac6abf6454c413bb23e8becf6b6dc20ea\nauthor flip1995 <philipp.krones@embecosm.com> 1634814696 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1634814696 +0200\n\nMerge commit '91496c2ac6abf6454c413bb23e8becf6b6dc20ea' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9af8e378b9c95b8d21987c414862682eb3c5451c", "html_url": "https://github.com/rust-lang/rust/commit/9af8e378b9c95b8d21987c414862682eb3c5451c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9af8e378b9c95b8d21987c414862682eb3c5451c/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ebd073829959d47b977c168096968a6ed753f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ebd073829959d47b977c168096968a6ed753f9", "html_url": "https://github.com/rust-lang/rust/commit/40ebd073829959d47b977c168096968a6ed753f9"}, {"sha": "91496c2ac6abf6454c413bb23e8becf6b6dc20ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/91496c2ac6abf6454c413bb23e8becf6b6dc20ea", "html_url": "https://github.com/rust-lang/rust/commit/91496c2ac6abf6454c413bb23e8becf6b6dc20ea"}], "stats": {"total": 4962, "additions": 4334, "deletions": 628}, "files": [{"sha": "3b4c687209e11dfa8ebb9454ad8c4af571a9677f", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -2730,11 +2730,13 @@ Released 2018-09-13\n [`fn_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_address_comparisons\n [`fn_params_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_params_excessive_bools\n [`fn_to_numeric_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast\n+[`fn_to_numeric_cast_any`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_any\n [`fn_to_numeric_cast_with_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_with_truncation\n [`for_kv_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_kv_map\n [`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n+[`format_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_in_format_args\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n [`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n@@ -2836,6 +2838,7 @@ Released 2018-09-13\n [`match_result_ok`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_result_ok\n [`match_same_arms`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_same_arms\n [`match_single_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_single_binding\n+[`match_str_case_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_str_case_mismatch\n [`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n [`match_wildcard_for_single_variants`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wildcard_for_single_variants\n [`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n@@ -2896,6 +2899,7 @@ Released 2018-09-13\n [`new_ret_no_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_ret_no_self\n [`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n [`no_effect`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect\n+[`no_effect_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect_underscore_binding\n [`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n [`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n [`non_send_fields_in_send_ty`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_send_fields_in_send_ty\n@@ -3012,16 +3016,19 @@ Released 2018-09-13\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n+[`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n [`toplevel_ref_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#toplevel_ref_arg\n+[`trailing_empty_array`]: https://rust-lang.github.io/rust-clippy/master/index.html#trailing_empty_array\n [`trait_duplication_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#trait_duplication_in_bounds\n [`transmute_bytes_to_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_bytes_to_str\n [`transmute_float_to_int`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_float_to_int\n [`transmute_int_to_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_bool\n [`transmute_int_to_char`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_char\n [`transmute_int_to_float`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_float\n+[`transmute_num_to_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_num_to_bytes\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n@@ -3031,10 +3038,12 @@ Released 2018-09-13\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n [`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n [`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n+[`undocumented_unsafe_blocks`]: https://rust-lang.github.io/rust-clippy/master/index.html#undocumented_unsafe_blocks\n [`undropped_manually_drops`]: https://rust-lang.github.io/rust-clippy/master/index.html#undropped_manually_drops\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n+[`uninit_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_vec\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord"}, {"sha": "ed7fb1440139f7d199f5632cb54525633c0d48a1", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.57\"\n+version = \"0.1.58\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "affb283017c8ce50252ae6d9750e553591e21497", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -6,6 +6,7 @@ edition = \"2021\"\n [dependencies]\n bytecount = \"0.6\"\n clap = \"2.33\"\n+indoc = \"1.0\"\n itertools = \"0.10\"\n opener = \"0.5\"\n regex = \"1.5\""}, {"sha": "b5c04efce3bc95bca885102df44ed2c612c6e8f1", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -28,6 +28,7 @@ fn main() {\n                 matches.value_of(\"pass\"),\n                 matches.value_of(\"name\"),\n                 matches.value_of(\"category\"),\n+                matches.is_present(\"msrv\"),\n             ) {\n                 Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n                 Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n@@ -147,6 +148,11 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                             \"internal_warn\",\n                         ])\n                         .takes_value(true),\n+                )\n+                .arg(\n+                    Arg::with_name(\"msrv\")\n+                        .long(\"msrv\")\n+                        .help(\"Add MSRV config code to the lint\"),\n                 ),\n         )\n         .subcommand("}, {"sha": "25320907bb492767f36da58f48e97d0b2d366477", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 142, "deletions": 78, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,4 +1,5 @@\n use crate::clippy_project_root;\n+use indoc::indoc;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, ErrorKind};\n@@ -32,37 +33,20 @@ impl<T> Context for io::Result<T> {\n /// # Errors\n ///\n /// This function errors out if the files couldn't be created or written to.\n-pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>) -> io::Result<()> {\n+pub fn create(pass: Option<&str>, lint_name: Option<&str>, category: Option<&str>, msrv: bool) -> io::Result<()> {\n     let lint = LintData {\n         pass: pass.expect(\"`pass` argument is validated by clap\"),\n         name: lint_name.expect(\"`name` argument is validated by clap\"),\n         category: category.expect(\"`category` argument is validated by clap\"),\n         project_root: clippy_project_root(),\n     };\n \n-    create_lint(&lint).context(\"Unable to create lint implementation\")?;\n+    create_lint(&lint, msrv).context(\"Unable to create lint implementation\")?;\n     create_test(&lint).context(\"Unable to create a test for the new lint\")\n }\n \n-fn create_lint(lint: &LintData<'_>) -> io::Result<()> {\n-    let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n-        \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n-        \"late\" => (\"LateLintPass\", \"<'_>\", \"use rustc_hir::*;\", \"LateContext\"),\n-        _ => {\n-            unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n-        },\n-    };\n-\n-    let camel_case_name = to_camel_case(lint.name);\n-    let lint_contents = get_lint_file_contents(\n-        pass_type,\n-        pass_lifetimes,\n-        lint.name,\n-        &camel_case_name,\n-        lint.category,\n-        pass_import,\n-        context_import,\n-    );\n+fn create_lint(lint: &LintData<'_>, enable_msrv: bool) -> io::Result<()> {\n+    let lint_contents = get_lint_file_contents(lint, enable_msrv);\n \n     let lint_path = format!(\"clippy_lints/src/{}.rs\", lint.name);\n     write_file(lint.project_root.join(&lint_path), lint_contents.as_bytes())\n@@ -122,12 +106,13 @@ fn to_camel_case(name: &str) -> String {\n \n fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {\n     let mut contents = format!(\n-        \"#![warn(clippy::{})]\n+        indoc! {\"\n+            #![warn(clippy::{})]\n \n-fn main() {{\n-    // test code goes here\n-}}\n-\",\n+            fn main() {{\n+                // test code goes here\n+            }}\n+        \"},\n         lint_name\n     );\n \n@@ -140,64 +125,143 @@ fn main() {{\n \n fn get_manifest_contents(lint_name: &str, hint: &str) -> String {\n     format!(\n-        r#\"\n-# {}\n+        indoc! {r#\"\n+            # {}\n \n-[package]\n-name = \"{}\"\n-version = \"0.1.0\"\n-publish = false\n+            [package]\n+            name = \"{}\"\n+            version = \"0.1.0\"\n+            publish = false\n \n-[workspace]\n-\"#,\n+            [workspace]\n+        \"#},\n         hint, lint_name\n     )\n }\n \n-fn get_lint_file_contents(\n-    pass_type: &str,\n-    pass_lifetimes: &str,\n-    lint_name: &str,\n-    camel_case_name: &str,\n-    category: &str,\n-    pass_import: &str,\n-    context_import: &str,\n-) -> String {\n-    format!(\n-        \"use rustc_lint::{{{type}, {context_import}}};\n-use rustc_session::{{declare_lint_pass, declare_tool_lint}};\n-{pass_import}\n-\n-declare_clippy_lint! {{\n-    /// ### What it does\n-    ///\n-    /// ### Why is this bad?\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // example code where clippy issues a warning\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// // example code which does not raise clippy warning\n-    /// ```\n-    pub {name_upper},\n-    {category},\n-    \\\"default lint description\\\"\n-}}\n-\n-declare_lint_pass!({name_camel} => [{name_upper}]);\n-\n-impl {type}{lifetimes} for {name_camel} {{}}\n-\",\n-        type=pass_type,\n-        lifetimes=pass_lifetimes,\n-        name_upper=lint_name.to_uppercase(),\n-        name_camel=camel_case_name,\n-        category=category,\n-        pass_import=pass_import,\n-        context_import=context_import\n-    )\n+fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n+    let mut result = String::new();\n+\n+    let (pass_type, pass_lifetimes, pass_import, context_import) = match lint.pass {\n+        \"early\" => (\"EarlyLintPass\", \"\", \"use rustc_ast::ast::*;\", \"EarlyContext\"),\n+        \"late\" => (\"LateLintPass\", \"<'_>\", \"use rustc_hir::*;\", \"LateContext\"),\n+        _ => {\n+            unreachable!(\"`pass_type` should only ever be `early` or `late`!\");\n+        },\n+    };\n+\n+    let lint_name = lint.name;\n+    let pass_name = lint.pass;\n+    let category = lint.category;\n+    let name_camel = to_camel_case(lint.name);\n+    let name_upper = lint_name.to_uppercase();\n+\n+    result.push_str(&if enable_msrv {\n+        format!(\n+            indoc! {\"\n+                use clippy_utils::msrvs;\n+                {pass_import}\n+                use rustc_lint::{{{context_import}, {pass_type}, LintContext}};\n+                use rustc_semver::RustcVersion;\n+                use rustc_session::{{declare_tool_lint, impl_lint_pass}};\n+\n+            \"},\n+            pass_type = pass_type,\n+            pass_import = pass_import,\n+            context_import = context_import,\n+        )\n+    } else {\n+        format!(\n+            indoc! {\"\n+                {pass_import}\n+                use rustc_lint::{{{context_import}, {pass_type}}};\n+                use rustc_session::{{declare_lint_pass, declare_tool_lint}};\n+\n+            \"},\n+            pass_import = pass_import,\n+            pass_type = pass_type,\n+            context_import = context_import\n+        )\n+    });\n+\n+    result.push_str(&format!(\n+        indoc! {\"\n+            declare_clippy_lint! {{\n+                /// ### What it does\n+                ///\n+                /// ### Why is this bad?\n+                ///\n+                /// ### Example\n+                /// ```rust\n+                /// // example code where clippy issues a warning\n+                /// ```\n+                /// Use instead:\n+                /// ```rust\n+                /// // example code which does not raise clippy warning\n+                /// ```\n+                pub {name_upper},\n+                {category},\n+                \\\"default lint description\\\"\n+            }}\n+        \"},\n+        name_upper = name_upper,\n+        category = category,\n+    ));\n+\n+    result.push_str(&if enable_msrv {\n+        format!(\n+            indoc! {\"\n+                pub struct {name_camel} {{\n+                    msrv: Option<RustcVersion>,\n+                }}\n+\n+                impl {name_camel} {{\n+                    #[must_use]\n+                    pub fn new(msrv: Option<RustcVersion>) -> Self {{\n+                        Self {{ msrv }}\n+                    }}\n+                }}\n+\n+                impl_lint_pass!({name_camel} => [{name_upper}]);\n+\n+                impl {pass_type}{pass_lifetimes} for {name_camel} {{\n+                    extract_msrv_attr!({context_import});\n+                }}\n+\n+                // TODO: Register the lint pass in `clippy_lints/src/lib.rs`,\n+                //       e.g. store.register_{pass_name}_pass(move || Box::new({module_name}::{name_camel}::new(msrv)));\n+                // TODO: Add MSRV level to `clippy_utils/src/msrvs.rs` if needed.\n+                // TODO: Add MSRV test to `tests/ui/min_rust_version_attr.rs`.\n+                // TODO: Update msrv config comment in `clippy_lints/src/utils/conf.rs`\n+            \"},\n+            pass_type = pass_type,\n+            pass_lifetimes = pass_lifetimes,\n+            pass_name = pass_name,\n+            name_upper = name_upper,\n+            name_camel = name_camel,\n+            module_name = lint_name,\n+            context_import = context_import,\n+        )\n+    } else {\n+        format!(\n+            indoc! {\"\n+                declare_lint_pass!({name_camel} => [{name_upper}]);\n+\n+                impl {pass_type}{pass_lifetimes} for {name_camel} {{}}\n+                //\n+                // TODO: Register the lint pass in `clippy_lints/src/lib.rs`,\n+                //       e.g. store.register_{pass_name}_pass(|| Box::new({module_name}::{name_camel}));\n+            \"},\n+            pass_type = pass_type,\n+            pass_lifetimes = pass_lifetimes,\n+            pass_name = pass_name,\n+            name_upper = name_upper,\n+            name_camel = name_camel,\n+            module_name = lint_name,\n+        )\n+    });\n+\n+    result\n }\n \n #[test]"}, {"sha": "23f58bc4915f919eed14c71f50684c77ff2b52c9", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -619,8 +619,8 @@ mod tests {\n             Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n         ];\n         let expected = vec![\n-            format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK.to_string()),\n-            format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK.to_string()),\n+            format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK),\n+            format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK),\n         ];\n         assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n     }"}, {"sha": "aaf9ac83d49005dad0df8a05de2dc7818dcedd06", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.57\"\n+version = \"0.1.58\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "03621887a34a67e1771da65174ad9f0cd452f8f5", "filename": "src/tools/clippy/clippy_lints/src/casts/fn_to_numeric_cast_any.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_any.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::FN_TO_NUMERIC_CAST_ANY;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    // We allow casts from any function type to any function type.\n+    match cast_to.kind() {\n+        ty::FnDef(..) | ty::FnPtr(..) => return,\n+        _ => { /* continue to checks */ },\n+    }\n+\n+    match cast_from.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"..\", &mut applicability);\n+\n+            span_lint_and_sugg(\n+                cx,\n+                FN_TO_NUMERIC_CAST_ANY,\n+                expr.span,\n+                &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                \"did you mean to invoke the function?\",\n+                format!(\"{}() as {}\", from_snippet, cast_to),\n+                applicability,\n+            );\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "f0800c6a6f18f788bbb2804b20aaba1b8b362fc6", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -7,6 +7,7 @@ mod cast_ref_to_mut;\n mod cast_sign_loss;\n mod char_lit_as_u8;\n mod fn_to_numeric_cast;\n+mod fn_to_numeric_cast_any;\n mod fn_to_numeric_cast_with_truncation;\n mod ptr_as_ptr;\n mod unnecessary_cast;\n@@ -251,6 +252,42 @@ declare_clippy_lint! {\n     \"casting a function pointer to a numeric type not wide enough to store the address\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for casts of a function pointer to any integer type.\n+    ///\n+    /// ### Why is this bad?\n+    /// Casting a function pointer to an integer can have surprising results and can occur\n+    /// accidentally if parantheses are omitted from a function call. If you aren't doing anything\n+    /// low-level with function pointers then you can opt-out of casting functions to integers in\n+    /// order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n+    /// pointer casts in your code.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad: fn1 is cast as `usize`\n+    /// fn fn1() -> u16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn1 as usize;\n+    ///\n+    /// // Good: maybe you intended to call the function?\n+    /// fn fn2() -> u16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn2() as usize;\n+    ///\n+    /// // Good: maybe you intended to cast it to a function type?\n+    /// fn fn3() -> u16 {\n+    ///     1\n+    /// }\n+    /// let _ = fn3 as fn() -> u16;\n+    /// ```\n+    pub FN_TO_NUMERIC_CAST_ANY,\n+    restriction,\n+    \"casting a function pointer to any integer type\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for casts of `&T` to `&mut T` anywhere in the code.\n@@ -360,6 +397,7 @@ impl_lint_pass!(Casts => [\n     CAST_REF_TO_MUT,\n     CAST_PTR_ALIGNMENT,\n     UNNECESSARY_CAST,\n+    FN_TO_NUMERIC_CAST_ANY,\n     FN_TO_NUMERIC_CAST,\n     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     CHAR_LIT_AS_U8,\n@@ -385,6 +423,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 return;\n             }\n \n+            fn_to_numeric_cast_any::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {"}, {"sha": "8abf10c0d1c2d174b1380b5a3c01d5ef5b17d3ee", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -459,12 +459,10 @@ fn emit_branches_sharing_code_lint(\n         } else {\n             sm.stmt_span(block.stmts[block.stmts.len() - end_stmts].span, block.span)\n         };\n-        let moved_end = block\n-            .expr\n-            .map_or_else(\n-                || sm.stmt_span(block.stmts[block.stmts.len() - 1].span, block.span),\n-                |expr| expr.span.source_callsite(),\n-            );\n+        let moved_end = block.expr.map_or_else(\n+            || sm.stmt_span(block.stmts[block.stmts.len() - 1].span, block.span),\n+            |expr| expr.span.source_callsite(),\n+        );\n \n         let moved_span = moved_start.to(moved_end);\n         let moved_snipped = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);"}, {"sha": "cde27d3ad2a0ce3def12b28ab0e5ebfddb640489", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::ty::{has_drop, is_copy};\n use clippy_utils::{any_parent_is_automatically_derived, contains_name, in_macro, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n@@ -139,6 +140,13 @@ impl LateLintPass<'_> for Default {\n                     .fields\n                     .iter()\n                     .all(|field| field.vis.is_accessible_from(module_did, cx.tcx));\n+                let all_fields_are_copy = variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| {\n+                        is_copy(cx, cx.tcx.type_of(field.did))\n+                    });\n+                if !has_drop(cx, binding_type) || all_fields_are_copy;\n                 then {\n                     (local, variant, ident.name, binding_type, expr.span)\n                 } else {"}, {"sha": "48f781516f4228c2aecdb5f738d76c47942772ff", "filename": "src/tools/clippy/clippy_lints/src/disallowed_type.rs", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_type.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,12 +1,14 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_then;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     def::Res, def_id::DefId, Item, ItemKind, PolyTraitRef, PrimTy, TraitBoundModifier, Ty, TyKind, UseKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n+\n+use crate::utils::conf;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -19,7 +21,15 @@ declare_clippy_lint! {\n     /// An example clippy.toml configuration:\n     /// ```toml\n     /// # clippy.toml\n-    /// disallowed-types = [\"std::collections::BTreeMap\"]\n+    /// disallowed-types = [\n+    ///     # Can use a string as the path of the disallowed type.\n+    ///     \"std::collections::BTreeMap\",\n+    ///     # Can also use an inline table with a `path` key.\n+    ///     { path = \"std::net::TcpListener\" },\n+    ///     # When using an inline table, can add a `reason` for why the type\n+    ///     # is disallowed.\n+    ///     { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n+    /// ]\n     /// ```\n     ///\n     /// ```rust,ignore\n@@ -38,33 +48,30 @@ declare_clippy_lint! {\n }\n #[derive(Clone, Debug)]\n pub struct DisallowedType {\n-    disallowed: FxHashSet<Vec<Symbol>>,\n-    def_ids: FxHashSet<DefId>,\n-    prim_tys: FxHashSet<PrimTy>,\n+    conf_disallowed: Vec<conf::DisallowedType>,\n+    def_ids: FxHashMap<DefId, Option<String>>,\n+    prim_tys: FxHashMap<PrimTy, Option<String>>,\n }\n \n impl DisallowedType {\n-    pub fn new(disallowed: &FxHashSet<String>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedType>) -> Self {\n         Self {\n-            disallowed: disallowed\n-                .iter()\n-                .map(|s| s.split(\"::\").map(Symbol::intern).collect::<Vec<_>>())\n-                .collect(),\n-            def_ids: FxHashSet::default(),\n-            prim_tys: FxHashSet::default(),\n+            conf_disallowed,\n+            def_ids: FxHashMap::default(),\n+            prim_tys: FxHashMap::default(),\n         }\n     }\n \n     fn check_res_emit(&self, cx: &LateContext<'_>, res: &Res, span: Span) {\n         match res {\n             Res::Def(_, did) => {\n-                if self.def_ids.contains(did) {\n-                    emit(cx, &cx.tcx.def_path_str(*did), span);\n+                if let Some(reason) = self.def_ids.get(did) {\n+                    emit(cx, &cx.tcx.def_path_str(*did), span, reason.as_deref());\n                 }\n             },\n             Res::PrimTy(prim) => {\n-                if self.prim_tys.contains(prim) {\n-                    emit(cx, prim.name_str(), span);\n+                if let Some(reason) = self.prim_tys.get(prim) {\n+                    emit(cx, prim.name_str(), span, reason.as_deref());\n                 }\n             },\n             _ => {},\n@@ -76,14 +83,21 @@ impl_lint_pass!(DisallowedType => [DISALLOWED_TYPE]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        for path in &self.disallowed {\n-            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n-            match clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>()) {\n+        for conf in &self.conf_disallowed {\n+            let (path, reason) = match conf {\n+                conf::DisallowedType::Simple(path) => (path, None),\n+                conf::DisallowedType::WithReason { path, reason } => (\n+                    path,\n+                    reason.as_ref().map(|reason| format!(\"{} (from clippy.toml)\", reason)),\n+                ),\n+            };\n+            let segs: Vec<_> = path.split(\"::\").collect();\n+            match clippy_utils::path_to_res(cx, &segs) {\n                 Res::Def(_, id) => {\n-                    self.def_ids.insert(id);\n+                    self.def_ids.insert(id, reason);\n                 },\n                 Res::PrimTy(ty) => {\n-                    self.prim_tys.insert(ty);\n+                    self.prim_tys.insert(ty, reason);\n                 },\n                 _ => {},\n             }\n@@ -107,11 +121,16 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n     }\n }\n \n-fn emit(cx: &LateContext<'_>, name: &str, span: Span) {\n-    span_lint(\n+fn emit(cx: &LateContext<'_>, name: &str, span: Span, reason: Option<&str>) {\n+    span_lint_and_then(\n         cx,\n         DISALLOWED_TYPE,\n         span,\n         &format!(\"`{}` is not allowed according to config\", name),\n+        |diag| {\n+            if let Some(reason) = reason {\n+                diag.note(reason);\n+            }\n+        },\n     );\n }"}, {"sha": "5511c3ea9b6889701a2dbdfaf015fdec0fa5b987", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,3 +1,4 @@\n+use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note};\n use clippy_utils::source::first_line_of_span;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n@@ -297,6 +298,17 @@ fn lint_for_missing_headers<'tcx>(\n     if !cx.access_levels.is_exported(def_id) {\n         return; // Private functions do not require doc comments\n     }\n+\n+    // do not lint if any parent has `#[doc(hidden)]` attribute (#7347)\n+    if cx\n+        .tcx\n+        .hir()\n+        .parent_iter(cx.tcx.hir().local_def_id_to_hir_id(def_id))\n+        .any(|(id, _node)| is_doc_hidden(cx.tcx.hir().attrs(id)))\n+    {\n+        return;\n+    }\n+\n     if !headers.safety && sig.header.unsafety == hir::Unsafety::Unsafe {\n         span_lint(\n             cx,"}, {"sha": "655560afd4250045d8675529fc41bb5abf6f8677", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, in_macro, is_expn_of};\n+use clippy_utils::{\n+    ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, in_macro, is_expn_of, is_in_test_function,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n@@ -81,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         if macro_args.len() == 2;\n                         let (lhs, rhs) = (macro_args[0], macro_args[1]);\n                         if eq_expr_value(cx, lhs, rhs);\n-\n+                        if !is_in_test_function(cx.tcx, e.hir_id);\n                         then {\n                             span_lint(\n                                 cx,\n@@ -108,7 +110,10 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_useless_with_eq_exprs(op.node.into()) && eq_expr_value(cx, left, right) {\n+            if is_useless_with_eq_exprs(op.node.into())\n+                && eq_expr_value(cx, left, right)\n+                && !is_in_test_function(cx.tcx, e.hir_id)\n+            {\n                 span_lint(\n                     cx,\n                     EQ_OP,"}, {"sha": "e8b1d6f6edaaaeb27b1a41daf89a9cd1e0580248", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::implements_trait;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -77,9 +77,9 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                 let pat_str = match pat.kind {\n                     PatKind::Struct(..) => format!(\n                         \"({})\",\n-                        snippet_with_applicability(cx, pat.span, \"..\", &mut applicability),\n+                        snippet_with_context(cx, pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n                     ),\n-                    _ => snippet_with_applicability(cx, pat.span, \"..\", &mut applicability).to_string(),\n+                    _ => snippet_with_context(cx, pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n                 };\n                 span_lint_and_sugg(\n                     cx,\n@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                     \"try\",\n                     format!(\n                         \"{} == {}\",\n-                        snippet_with_applicability(cx, exp.span, \"..\", &mut applicability),\n+                        snippet_with_context(cx, exp.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n                         pat_str,\n                     ),\n                     applicability,"}, {"sha": "c22f9d0e170326c79fbdd0df8cc2228b27822aaf", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::FormatExpn;\n-use clippy_utils::last_path_segment;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, QPath};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -69,8 +68,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if format_args.args.iter().all(is_display_arg);\n-                if format_args.fmt_expr.map_or(true, check_unformatted);\n+                if let Some(args) = format_args.args();\n+                if args.iter().all(|arg| arg.is_display() && !arg.has_string_formatting());\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,\n@@ -101,47 +100,3 @@ fn span_useless_format(cx: &LateContext<'_>, span: Span, sugg: String, applicabi\n         applicability,\n     );\n }\n-\n-fn is_display_arg(expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::Call(_, [_, fmt]) = expr.kind;\n-        if let ExprKind::Path(QPath::Resolved(_, path)) = fmt.kind;\n-        if let [.., t, _] = path.segments;\n-        if t.ident.name == sym::Display;\n-        then { true } else { false }\n-    }\n-}\n-\n-/// Checks if the expression matches\n-/// ```rust,ignore\n-/// &[_ {\n-///    format: _ {\n-///         width: _::Implied,\n-///         precision: _::Implied,\n-///         ...\n-///    },\n-///    ...,\n-/// }]\n-/// ```\n-fn check_unformatted(expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-        if let ExprKind::Array([expr]) = expr.kind;\n-        // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, fields, _) = expr.kind;\n-        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-        // struct `core::fmt::rt::v1::FormatSpec`\n-        if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n-        if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n-        if last_path_segment(precision_path).ident.name == sym::Implied;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym::width);\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n-        if last_path_segment(width_qpath).ident.name == sym::Implied;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}"}, {"sha": "8b27442aa94656453060d0f80f558ae972b7a69e", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,223 @@\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::higher::{FormatArgsArg, FormatArgsExpn, FormatExpn};\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnKind, Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects `format!` within the arguments of another macro that does\n+    /// formatting such as `format!` itself, `write!` or `println!`. Suggests\n+    /// inlining the `format!` call.\n+    ///\n+    /// ### Why is this bad?\n+    /// The recommended code is both shorter and avoids a temporary allocation.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller());\n+    /// ```\n+    pub FORMAT_IN_FORMAT_ARGS,\n+    perf,\n+    \"`format!` used in a macro that does formatting\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for [`ToString::to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)\n+    /// applied to a type that implements [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)\n+    /// in a macro that does formatting.\n+    ///\n+    /// ### Why is this bad?\n+    /// Since the type implements `Display`, the use of `to_string` is\n+    /// unnecessary.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller().to_string());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::panic::Location;\n+    /// println!(\"error: something failed at {}\", Location::caller());\n+    /// ```\n+    pub TO_STRING_IN_FORMAT_ARGS,\n+    perf,\n+    \"`to_string` applied to a type that implements `Display` in format args\"\n+}\n+\n+declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n+\n+const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n+    &paths::FORMAT_ARGS_MACRO,\n+    &paths::ASSERT_EQ_MACRO,\n+    &paths::ASSERT_MACRO,\n+    &paths::ASSERT_NE_MACRO,\n+    &paths::EPRINT_MACRO,\n+    &paths::EPRINTLN_MACRO,\n+    &paths::PRINT_MACRO,\n+    &paths::PRINTLN_MACRO,\n+    &paths::WRITE_MACRO,\n+    &paths::WRITELN_MACRO,\n+];\n+\n+const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n+\n+impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let Some(format_args) = FormatArgsExpn::parse(expr);\n+            let expr_expn_data = expr.span.ctxt().outer_expn_data();\n+            let outermost_expn_data = outermost_expn_data(expr_expn_data);\n+            if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n+            if FORMAT_MACRO_PATHS\n+                .iter()\n+                .any(|path| match_def_path(cx, macro_def_id, path))\n+                || FORMAT_MACRO_DIAG_ITEMS\n+                    .iter()\n+                    .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id));\n+            if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n+            if let Some(args) = format_args.args();\n+            then {\n+                for (i, arg) in args.iter().enumerate() {\n+                    if !arg.is_display() {\n+                        continue;\n+                    }\n+                    if arg.has_string_formatting() {\n+                        continue;\n+                    }\n+                    if is_aliased(&args, i) {\n+                        continue;\n+                    }\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg);\n+                    check_to_string_in_format_args(cx, name, arg);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n+    if expn_data.call_site.from_expansion() {\n+        outermost_expn_data(expn_data.call_site.ctxt().outer_expn_data())\n+    } else {\n+        expn_data\n+    }\n+}\n+\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &FormatArgsArg<'_>) {\n+    if_chain! {\n+        if FormatExpn::parse(arg.value).is_some();\n+        if !arg.value.span.ctxt().outer_expn_data().call_site.from_expansion();\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                FORMAT_IN_FORMAT_ARGS,\n+                trim_semicolon(cx, call_site),\n+                &format!(\"`format!` in `{}!` args\", name),\n+                |diag| {\n+                    diag.help(&format!(\n+                        \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n+                        name\n+                    ));\n+                    diag.help(\"or consider changing `format!` to `format_args!`\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn check_to_string_in_format_args<'tcx>(cx: &LateContext<'tcx>, name: Symbol, arg: &FormatArgsArg<'tcx>) {\n+    let value = arg.value;\n+    if_chain! {\n+        if !value.span.from_expansion();\n+        if let ExprKind::MethodCall(_, _, [receiver], _) = value.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n+        if is_diag_trait_item(cx, method_def_id, sym::ToString);\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        if let Some(display_trait_id) = cx.tcx.get_diagnostic_item(sym::Display);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let (n_needed_derefs, target) = count_needed_derefs(\n+                receiver_ty,\n+                cx.typeck_results().expr_adjustments(receiver).iter(),\n+            );\n+            if implements_trait(cx, target, display_trait_id, &[]) {\n+                if n_needed_derefs == 0 {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TO_STRING_IN_FORMAT_ARGS,\n+                        value.span.with_lo(receiver.span.hi()),\n+                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n+                        \"remove this\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TO_STRING_IN_FORMAT_ARGS,\n+                        value.span,\n+                        &format!(\"`to_string` applied to a type that implements `Display` in `{}!` args\", name),\n+                        \"use this\",\n+                        format!(\"{:*>width$}{}\", \"\", receiver_snippet, width = n_needed_derefs),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns true if `args[i]` \"refers to\" or \"is referred to by\" another argument.\n+fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n+    let value = args[i].value;\n+    args.iter()\n+        .enumerate()\n+        .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n+}\n+\n+fn trim_semicolon(cx: &LateContext<'_>, span: Span) -> Span {\n+    snippet_opt(cx, span).map_or(span, |snippet| {\n+        let snippet = snippet.trim_end_matches(';');\n+        span.with_hi(span.lo() + BytePos(u32::try_from(snippet.len()).unwrap()))\n+    })\n+}\n+\n+fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n+where\n+    I: Iterator<Item = &'tcx Adjustment<'tcx>>,\n+{\n+    let mut n_total = 0;\n+    let mut n_needed = 0;\n+    loop {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n+            n_total += 1;\n+            if overloaded_deref.is_some() {\n+                n_needed = n_total;\n+            }\n+            ty = target;\n+        } else {\n+            return (n_needed, ty);\n+        }\n+    }\n+}"}, {"sha": "d7c5ec9ba355bdf4bcc4118bc518554718afd4cf", "filename": "src/tools/clippy/clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -91,11 +91,9 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for a [`#[must_use]`] attribute on\n+    /// Checks for a `#[must_use]` attribute on\n     /// unit-returning functions and methods.\n     ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n     /// ### Why is this bad?\n     /// Unit values are useless. The attribute is likely\n     /// a remnant of a refactoring that removed the return type.\n@@ -112,12 +110,10 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for a [`#[must_use]`] attribute without\n+    /// Checks for a `#[must_use]` attribute without\n     /// further information on functions and methods that return a type already\n     /// marked as `#[must_use]`.\n     ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n     /// ### Why is this bad?\n     /// The attribute isn't needed. Not using the result\n     /// will already be reported. Alternatively, one can add some text to the\n@@ -138,11 +134,9 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for public functions that have no\n-    /// [`#[must_use]`] attribute, but return something not already marked\n+    /// `#[must_use]` attribute, but return something not already marked\n     /// must-use, have no mutable arg and mutate no statics.\n     ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n     /// ### Why is this bad?\n     /// Not bad at all, this lint just shows places where\n     /// you could add the attribute."}, {"sha": "414f465c49414088113b36ee2eb09f45c72b9964", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -66,7 +66,6 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n         && constant_simple(cx, cx.typeck_results(), left) == Some(Constant::Int(1))\n }\n \n-#[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e) {\n         let check = match *cx.typeck_results().expr_ty(e).kind() {"}, {"sha": "e8cea5529e889100e88514becadc89e37aedec5e", "filename": "src/tools/clippy/clippy_lints/src/if_then_panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_panic.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -78,10 +78,10 @@ impl LateLintPass<'_> for IfThenPanic {\n                     if let Expr{kind: ExprKind::Unary(UnOp::Not, not_expr), ..} = e {\n                          sugg::Sugg::hir_with_applicability(cx, not_expr, \"..\", &mut applicability).maybe_par().to_string()\n                     } else {\n-                       format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, e, \"..\", &mut applicability).maybe_par().to_string())\n+                       format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, e, \"..\", &mut applicability).maybe_par())\n                     }\n                 } else {\n-                   format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par().to_string())\n+                   format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par())\n                 };\n \n                 span_lint_and_sugg("}, {"sha": "a4f60ded3a6e0ebcaadab8e2b92ab712211d5159", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             return;\n         }\n         if_chain! {\n-            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n+            if let Some(higher::If { cond, then, r#else: None }) = higher::If::hir(expr);\n \n             // Check if the conditional expression is a binary operation\n             if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;"}, {"sha": "61dd0eb4af7ed37d7239f2b334bbed4712a7edf8", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -138,10 +138,10 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n             item.span,\n             &format!(\n                 \"type `{}` implements inherent method `to_string(&self) -> String` which shadows the implementation of `Display`\",\n-                self_type.to_string()\n+                self_type\n             ),\n             None,\n-            &format!(\"remove the inherent method from type `{}`\", self_type.to_string()),\n+            &format!(\"remove the inherent method from type `{}`\", self_type),\n         );\n     } else {\n         span_lint_and_help(\n@@ -150,10 +150,10 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n             item.span,\n             &format!(\n                 \"implementation of inherent method `to_string(&self) -> String` for type `{}`\",\n-                self_type.to_string()\n+                self_type\n             ),\n             None,\n-            &format!(\"implement trait `Display` for type `{}` instead\", self_type.to_string()),\n+            &format!(\"implement trait `Display` for type `{}` instead\", self_type),\n         );\n     }\n }"}, {"sha": "9efd7aba7e83bccf09af6aea4f86da86285eeeda", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -10,12 +10,11 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `let _ = <expr>`\n-    /// where expr is #[must_use]\n+    /// Checks for `let _ = <expr>` where expr is `#[must_use]`\n     ///\n     /// ### Why is this bad?\n-    /// It's better to explicitly\n-    /// handle the value of a #[must_use] expr\n+    /// It's better to explicitly handle the value of a `#[must_use]`\n+    /// expr\n     ///\n     /// ### Example\n     /// ```rust"}, {"sha": "c949ee23ecc7a94858ce40214e496a881c8a08fd", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -60,6 +60,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(format::USELESS_FORMAT),\n+    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n+    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n@@ -118,6 +120,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n+    LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n@@ -265,6 +268,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n     LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n+    LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n@@ -277,6 +281,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(types::VEC_BOX),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),"}, {"sha": "c51341bdf0c233bbcd11a18a7759994acc83d8bc", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -82,6 +82,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n     LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n+    LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n     LintId::of(types::BORROWED_BOX),\n     LintId::of(types::TYPE_COMPLEXITY),"}, {"sha": "ff56a6081fb57f8cbc44c08f785b2981900147f4", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -36,6 +36,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(loops::ITER_NEXT_LOOP),\n     LintId::of(loops::NEVER_LOOP),\n     LintId::of(loops::WHILE_IMMUTABLE_CONDITION),\n+    LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n@@ -62,6 +63,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),"}, {"sha": "e8dd3708c8ed406dc3f92b6bff81332d49d9757e", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -67,6 +67,7 @@ store.register_lints(&[\n     casts::CAST_SIGN_LOSS,\n     casts::CHAR_LIT_AS_U8,\n     casts::FN_TO_NUMERIC_CAST,\n+    casts::FN_TO_NUMERIC_CAST_ANY,\n     casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     casts::PTR_AS_PTR,\n     casts::UNNECESSARY_CAST,\n@@ -138,6 +139,8 @@ store.register_lints(&[\n     floating_point_arithmetic::IMPRECISE_FLOPS,\n     floating_point_arithmetic::SUBOPTIMAL_FLOPS,\n     format::USELESS_FORMAT,\n+    format_args::FORMAT_IN_FORMAT_ARGS,\n+    format_args::TO_STRING_IN_FORMAT_ARGS,\n     formatting::POSSIBLE_MISSING_COMMA,\n     formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     formatting::SUSPICIOUS_ELSE_FORMATTING,\n@@ -225,6 +228,7 @@ store.register_lints(&[\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n     match_on_vec_items::MATCH_ON_VEC_ITEMS,\n     match_result_ok::MATCH_RESULT_OK,\n+    match_str_case_mismatch::MATCH_STR_CASE_MISMATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n     matches::MATCH_AS_REF,\n     matches::MATCH_BOOL,\n@@ -359,6 +363,7 @@ store.register_lints(&[\n     neg_multiply::NEG_MULTIPLY,\n     new_without_default::NEW_WITHOUT_DEFAULT,\n     no_effect::NO_EFFECT,\n+    no_effect::NO_EFFECT_UNDERSCORE_BINDING,\n     no_effect::UNNECESSARY_OPERATION,\n     non_copy_const::BORROW_INTERIOR_MUTABLE_CONST,\n     non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST,\n@@ -438,6 +443,7 @@ store.register_lints(&[\n     temporary_assignment::TEMPORARY_ASSIGNMENT,\n     to_digit_is_some::TO_DIGIT_IS_SOME,\n     to_string_in_display::TO_STRING_IN_DISPLAY,\n+    trailing_empty_array::TRAILING_EMPTY_ARRAY,\n     trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n     trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n     transmute::CROSSPOINTER_TRANSMUTE,\n@@ -447,6 +453,7 @@ store.register_lints(&[\n     transmute::TRANSMUTE_INT_TO_BOOL,\n     transmute::TRANSMUTE_INT_TO_CHAR,\n     transmute::TRANSMUTE_INT_TO_FLOAT,\n+    transmute::TRANSMUTE_NUM_TO_BYTES,\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n@@ -463,10 +470,12 @@ store.register_lints(&[\n     types::REDUNDANT_ALLOCATION,\n     types::TYPE_COMPLEXITY,\n     types::VEC_BOX,\n+    undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS,\n     undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n     unicode::INVISIBLE_CHARACTERS,\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n+    uninit_vec::UNINIT_VEC,\n     unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n     unit_types::LET_UNIT_VALUE,\n     unit_types::UNIT_ARG,"}, {"sha": "1e54482a8dafdc7b5f73d3798f5fd5a04864cc2b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -25,6 +25,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(regex::TRIVIAL_REGEX),\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n+    LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),\n ])"}, {"sha": "268349d28481182fdbac33fe20ba0d0312430fbf", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -72,6 +72,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(needless_continue::NEEDLESS_CONTINUE),\n     LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n     LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n+    LintId::of(no_effect::NO_EFFECT_UNDERSCORE_BINDING),\n     LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n     LintId::of(non_expressive_names::SIMILAR_NAMES),\n     LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),"}, {"sha": "a0d5cf9418e0b32f7244fbd48759acb925e9997f", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -5,6 +5,8 @@\n store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(escape::BOXED_LOCAL),\n+    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n+    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),"}, {"sha": "3d68a6e900958fbcfcd886007abc15c468b5ceef", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -8,6 +8,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(as_conversions::AS_CONVERSIONS),\n     LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n     LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n+    LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),\n     LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n@@ -56,6 +57,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(strings::STR_TO_STRING),\n     LintId::of(types::RC_BUFFER),\n     LintId::of(types::RC_MUTEX),\n+    LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),\n     LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n     LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n     LintId::of(verbose_file_reads::VERBOSE_FILE_READS),"}, {"sha": "ed7e827702395dc72336e5f2adaf24709324e6ac", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -218,6 +218,7 @@ mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n+mod format_args;\n mod formatting;\n mod from_over_into;\n mod from_str_radix_10;\n@@ -265,6 +266,7 @@ mod map_err_ignore;\n mod map_unit_fn;\n mod match_on_vec_items;\n mod match_result_ok;\n+mod match_str_case_mismatch;\n mod matches;\n mod mem_forget;\n mod mem_replace;\n@@ -352,13 +354,16 @@ mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n mod to_string_in_display;\n+mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n mod try_err;\n mod types;\n+mod undocumented_unsafe_blocks;\n mod undropped_manually_drops;\n mod unicode;\n+mod uninit_vec;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n@@ -516,6 +521,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n     store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n+    store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n     store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n     store.register_late_pass(|| Box::new(strings::StringAdd));\n     store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));\n@@ -754,8 +760,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n     store.register_early_pass(move || Box::new(module_style::ModStyle));\n     store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n-    let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(&disallowed_types)));\n+    let disallowed_types = conf.disallowed_types.clone();\n+    store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(disallowed_types.clone())));\n     let import_renames = conf.enforced_import_renames.clone();\n     store.register_late_pass(move || Box::new(missing_enforced_import_rename::ImportRename::new(import_renames.clone())));\n     let scripts = conf.allowed_scripts.clone();\n@@ -767,6 +773,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(if_then_panic::IfThenPanic));\n     let enable_raw_pointer_heuristic_for_send = conf.enable_raw_pointer_heuristic_for_send;\n     store.register_late_pass(move || Box::new(non_send_fields_in_send_ty::NonSendFieldInSendTy::new(enable_raw_pointer_heuristic_for_send)));\n+    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n+    store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n+    store.register_late_pass(move || Box::new(format_args::FormatArgs));\n+    store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n+\n }\n \n #[rustfmt::skip]"}, {"sha": "ecf6ad316a46124a121e0be7de6264ace3ed1098", "filename": "src/tools/clippy/clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -35,7 +35,7 @@ declare_clippy_lint! {\n     /// }\n     ///\n     /// if let Ok(value) = iter.next() {\n-    ///        vec.push_value)\n+    ///        vec.push(value)\n     /// }\n     /// ```\n     pub MATCH_RESULT_OK,"}, {"sha": "a83f38e3d516e5c74c345cc2de119f57468710e2", "filename": "src/tools/clippy/clippy_lints/src/match_str_case_mismatch.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,171 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::SymbolStr;\n+use rustc_span::{sym, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match` expressions modifying the case of a string with non-compliant arms\n+    ///\n+    /// ### Why is this bad?\n+    /// The arm is unreachable, which is likely a mistake\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let text = \"Foo\";\n+    ///\n+    /// match &*text.to_ascii_lowercase() {\n+    ///     \"foo\" => {},\n+    ///     \"Bar\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let text = \"Foo\";\n+    ///\n+    /// match &*text.to_ascii_lowercase() {\n+    ///     \"foo\" => {},\n+    ///     \"bar\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    pub MATCH_STR_CASE_MISMATCH,\n+    correctness,\n+    \"creation of a case altering match expression with non-compliant arms\"\n+}\n+\n+declare_lint_pass!(MatchStrCaseMismatch => [MATCH_STR_CASE_MISMATCH]);\n+\n+#[derive(Debug)]\n+enum CaseMethod {\n+    LowerCase,\n+    AsciiLowerCase,\n+    UpperCase,\n+    AsciiUppercase,\n+}\n+\n+impl LateLintPass<'_> for MatchStrCaseMismatch {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if !in_external_macro(cx.tcx.sess, expr.span);\n+            if let ExprKind::Match(match_expr, arms, MatchSource::Normal) = expr.kind;\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(match_expr).kind();\n+            if let ty::Str = ty.kind();\n+            then {\n+                let mut visitor = MatchExprVisitor {\n+                    cx,\n+                    case_method: None,\n+                };\n+\n+                visitor.visit_expr(match_expr);\n+\n+                if let Some(case_method) = visitor.case_method {\n+                    if let Some((bad_case_span, bad_case_str)) = verify_case(&case_method, arms) {\n+                        lint(cx, &case_method, bad_case_span, &bad_case_str);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct MatchExprVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    case_method: Option<CaseMethod>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for MatchExprVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        match ex.kind {\n+            ExprKind::MethodCall(segment, _, [receiver], _)\n+                if self.case_altered(&*segment.ident.as_str(), receiver) => {},\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MatchExprVisitor<'a, 'tcx> {\n+    fn case_altered(&mut self, segment_ident: &str, receiver: &Expr<'_>) -> bool {\n+        if let Some(case_method) = get_case_method(segment_ident) {\n+            let ty = self.cx.typeck_results().expr_ty(receiver).peel_refs();\n+\n+            if is_type_diagnostic_item(self.cx, ty, sym::String) || ty.kind() == &ty::Str {\n+                self.case_method = Some(case_method);\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n+fn get_case_method(segment_ident_str: &str) -> Option<CaseMethod> {\n+    match segment_ident_str {\n+        \"to_lowercase\" => Some(CaseMethod::LowerCase),\n+        \"to_ascii_lowercase\" => Some(CaseMethod::AsciiLowerCase),\n+        \"to_uppercase\" => Some(CaseMethod::UpperCase),\n+        \"to_ascii_uppercase\" => Some(CaseMethod::AsciiUppercase),\n+        _ => None,\n+    }\n+}\n+\n+fn verify_case<'a>(case_method: &'a CaseMethod, arms: &'a [Arm<'_>]) -> Option<(Span, SymbolStr)> {\n+    let case_check = match case_method {\n+        CaseMethod::LowerCase => |input: &str| -> bool { input.chars().all(char::is_lowercase) },\n+        CaseMethod::AsciiLowerCase => |input: &str| -> bool { input.chars().all(|c| matches!(c, 'a'..='z')) },\n+        CaseMethod::UpperCase => |input: &str| -> bool { input.chars().all(char::is_uppercase) },\n+        CaseMethod::AsciiUppercase => |input: &str| -> bool { input.chars().all(|c| matches!(c, 'A'..='Z')) },\n+    };\n+\n+    for arm in arms {\n+        if_chain! {\n+            if let PatKind::Lit(Expr {\n+                                kind: ExprKind::Lit(lit),\n+                                ..\n+                            }) = arm.pat.kind;\n+            if let LitKind::Str(symbol, _) = lit.node;\n+            let input = symbol.as_str();\n+            if !case_check(&input);\n+            then {\n+                return Some((lit.span, input));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn lint(cx: &LateContext<'_>, case_method: &CaseMethod, bad_case_span: Span, bad_case_str: &str) {\n+    let (method_str, suggestion) = match case_method {\n+        CaseMethod::LowerCase => (\"to_lower_case\", bad_case_str.to_lowercase()),\n+        CaseMethod::AsciiLowerCase => (\"to_ascii_lowercase\", bad_case_str.to_ascii_lowercase()),\n+        CaseMethod::UpperCase => (\"to_uppercase\", bad_case_str.to_uppercase()),\n+        CaseMethod::AsciiUppercase => (\"to_ascii_uppercase\", bad_case_str.to_ascii_uppercase()),\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MATCH_STR_CASE_MISMATCH,\n+        bad_case_span,\n+        \"this `match` arm has a differing case than its expression\",\n+        &*format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n+        format!(\"\\\"{}\\\"\", suggestion),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "b643fba5d328865baded5f1192cca02fa6ae979a", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1187,7 +1187,7 @@ where\n     'b: 'a,\n     I: Clone + Iterator<Item = &'a Pat<'b>>,\n {\n-    if !has_only_ref_pats(pats.clone()) {\n+    if !has_multiple_ref_pats(pats.clone()) {\n         return;\n     }\n \n@@ -1693,26 +1693,26 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n     None\n }\n \n-fn has_only_ref_pats<'a, 'b, I>(pats: I) -> bool\n+fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n where\n     'b: 'a,\n     I: Iterator<Item = &'a Pat<'b>>,\n {\n-    let mut at_least_one_is_true = false;\n+    let mut ref_count = 0;\n     for opt in pats.map(|pat| match pat.kind {\n         PatKind::Ref(..) => Some(true), // &-patterns\n         PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n         _ => None,                      // any other pattern is not fine\n     }) {\n         if let Some(inner) = opt {\n             if inner {\n-                at_least_one_is_true = true;\n+                ref_count += 1;\n             }\n         } else {\n             return false;\n         }\n     }\n-    at_least_one_is_true\n+    ref_count > 1\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>"}, {"sha": "26c29fbb289cb7f8d11e1aa41ce5d22d46a07cb0", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1777,14 +1777,13 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usages of `str::splitn(2, _)`\n-    ///\n-    /// **Why is this bad?** `split_once` is both clearer in intent and slightly more efficient.\n-    ///\n-    /// **Known problems:** None.\n+    /// ### What it does\n+    /// Checks for usages of `str::splitn(2, _)`\n     ///\n-    /// **Example:**\n+    /// ### Why is this bad?\n+    /// `split_once` is both clearer in intent and slightly more efficient.\n     ///\n+    /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n     ///  let (key, value) = _.splitn(2, '=').next_tuple()?;"}, {"sha": "ce89189bce9779e12305ca5c269ef9c4e359e30d", "filename": "src/tools/clippy/clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,9 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_path_def_path, match_def_path, paths};\n+use clippy_utils::{is_expr_path_def_path, paths, ty::is_uninit_value_valid_for_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty};\n \n use super::UNINIT_ASSUMED_INIT;\n \n@@ -13,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n         if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n+        if !is_uninit_value_valid_for_ty(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint(\n                 cx,\n@@ -24,12 +23,3 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         }\n     }\n }\n-\n-fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Array(component, _) => is_maybe_uninit_ty_valid(cx, component),\n-        ty::Tuple(types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n-        _ => false,\n-    }\n-}"}, {"sha": "b593c747498e397b76ba9819b3d7388a87f41bd0", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -8,7 +8,7 @@ use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// it lints if an exported function, method, trait method with default impl,\n+    /// It lints if an exported function, method, trait method with default impl,\n     /// or trait method impl is not `#[inline]`.\n     ///\n     /// ### Why is this bad?"}, {"sha": "7c4cac29ba8e8c699b7a5cfdeea61678f0a477ba", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -82,6 +82,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n+        if in_external_macro(self.cx.sess(), ty.span) {\n+            return;\n+        }\n+\n         if let hir::TyKind::Rptr(\n             _,\n             hir::MutTy {"}, {"sha": "6dae8f320436fc49609aa428cc808a218f84edd7", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 115, "deletions": 64, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n+use clippy_utils::is_lint_allowed;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{is_range_literal, BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n+use rustc_hir::{is_range_literal, BinOpKind, BlockCheckMode, Expr, ExprKind, PatKind, Stmt, StmtKind, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::ops::Deref;\n@@ -13,7 +14,7 @@ declare_clippy_lint! {\n     /// Checks for statements which have no effect.\n     ///\n     /// ### Why is this bad?\n-    /// Similar to dead code, these statements are actually\n+    /// Unlike dead code, these statements are actually\n     /// executed. However, as they have no effect, all they do is make the code less\n     /// readable.\n     ///\n@@ -26,6 +27,28 @@ declare_clippy_lint! {\n     \"statements with no effect\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for binding to underscore prefixed variable without side-effects.\n+    ///\n+    /// ### Why is this bad?\n+    /// Unlike dead code, these bindings are actually\n+    /// executed. However, as they have no effect and shouldn't be used further on, all they\n+    /// do is make the code less readable.\n+    ///\n+    /// ### Known problems\n+    /// Further usage of this variable is not checked, which can lead to false positives if it is\n+    /// used later in the code.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _i_serve_no_purpose = 1;\n+    /// ```\n+    pub NO_EFFECT_UNDERSCORE_BINDING,\n+    pedantic,\n+    \"binding to `_` prefixed variable with no side-effect\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for expression statements that can be reduced to a\n@@ -44,6 +67,46 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n+declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION, NO_EFFECT_UNDERSCORE_BINDING]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NoEffect {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if check_no_effect(cx, stmt) {\n+            return;\n+        }\n+        check_unnecessary_operation(cx, stmt);\n+    }\n+}\n+\n+fn check_no_effect(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> bool {\n+    if let StmtKind::Semi(expr) = stmt.kind {\n+        if has_no_effect(cx, expr) {\n+            span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n+            return true;\n+        }\n+    } else if let StmtKind::Local(local) = stmt.kind {\n+        if_chain! {\n+            if !is_lint_allowed(cx, NO_EFFECT_UNDERSCORE_BINDING, local.hir_id);\n+            if let Some(init) = local.init;\n+            if !local.pat.span.from_expansion();\n+            if has_no_effect(cx, init);\n+            if let PatKind::Binding(_, _, ident, _) = local.pat.kind;\n+            if ident.name.to_ident_string().starts_with('_');\n+            then {\n+                span_lint_hir(\n+                    cx,\n+                    NO_EFFECT_UNDERSCORE_BINDING,\n+                    init.hir_id,\n+                    stmt.span,\n+                    \"binding to `_` prefixed variable with no side-effect\"\n+                );\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n@@ -88,71 +151,59 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for NoEffect {\n-    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Semi(expr) = stmt.kind {\n-            if has_no_effect(cx, expr) {\n-                span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n-            } else if let Some(reduced) = reduce_expression(cx, expr) {\n-                for e in &reduced {\n-                    if e.span.from_expansion() {\n-                        return;\n-                    }\n-                }\n-                if let ExprKind::Index(..) = &expr.kind {\n-                    let snippet;\n-                    if_chain! {\n-                        if let Some(arr) = snippet_opt(cx, reduced[0].span);\n-                        if let Some(func) = snippet_opt(cx, reduced[1].span);\n-                        then {\n-                            snippet = format!(\"assert!({}.len() > {});\", &arr, &func);\n-                        } else {\n-                            return;\n-                        }\n-                    }\n-                    span_lint_hir_and_then(\n-                        cx,\n-                        UNNECESSARY_OPERATION,\n-                        expr.hir_id,\n-                        stmt.span,\n-                        \"unnecessary operation\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                stmt.span,\n-                                \"statement can be written as\",\n-                                snippet,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        },\n-                    );\n+fn check_unnecessary_operation(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+    if_chain! {\n+        if let StmtKind::Semi(expr) = stmt.kind;\n+        if let Some(reduced) = reduce_expression(cx, expr);\n+        if !&reduced.iter().any(|e| e.span.from_expansion());\n+        then {\n+            if let ExprKind::Index(..) = &expr.kind {\n+                let snippet;\n+                if let (Some(arr), Some(func)) = (snippet_opt(cx, reduced[0].span), snippet_opt(cx, reduced[1].span)) {\n+                    snippet = format!(\"assert!({}.len() > {});\", &arr, &func);\n                 } else {\n-                    let mut snippet = String::new();\n-                    for e in reduced {\n-                        if let Some(snip) = snippet_opt(cx, e.span) {\n-                            snippet.push_str(&snip);\n-                            snippet.push(';');\n-                        } else {\n-                            return;\n-                        }\n+                    return;\n+                }\n+                span_lint_hir_and_then(\n+                    cx,\n+                    UNNECESSARY_OPERATION,\n+                    expr.hir_id,\n+                    stmt.span,\n+                    \"unnecessary operation\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            stmt.span,\n+                            \"statement can be written as\",\n+                            snippet,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    },\n+                );\n+            } else {\n+                let mut snippet = String::new();\n+                for e in reduced {\n+                    if let Some(snip) = snippet_opt(cx, e.span) {\n+                        snippet.push_str(&snip);\n+                        snippet.push(';');\n+                    } else {\n+                        return;\n                     }\n-                    span_lint_hir_and_then(\n-                        cx,\n-                        UNNECESSARY_OPERATION,\n-                        expr.hir_id,\n-                        stmt.span,\n-                        \"unnecessary operation\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                stmt.span,\n-                                \"statement can be reduced to\",\n-                                snippet,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n                 }\n+                span_lint_hir_and_then(\n+                    cx,\n+                    UNNECESSARY_OPERATION,\n+                    expr.hir_id,\n+                    stmt.span,\n+                    \"unnecessary operation\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            stmt.span,\n+                            \"statement can be reduced to\",\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n             }\n         }\n     }"}, {"sha": "92a4801a8468ae3d3e592212280e8dd7959c9bc5", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -139,6 +139,7 @@ declare_clippy_lint! {\n     /// unsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n     /// ```\n     ///\n+    /// ```ignore\n     /// // Good\n     /// unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n     /// ```"}, {"sha": "4d616e26bfc1da1dab23a26aaaf0dcbc3b009cf5", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -4,10 +4,10 @@ use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local_id};\n+use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -48,16 +48,20 @@ impl QuestionMark {\n     /// }\n     /// ```\n     ///\n+    /// ```ignore\n+    /// if result.is_err() {\n+    ///     return result;\n+    /// }\n+    /// ```\n+    ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_is_none_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n-            if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n-            if Self::is_option(cx, subject);\n-\n+            if (Self::option_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_none)) ||\n+                (Self::result_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_err));\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n@@ -95,31 +99,24 @@ impl QuestionMark {\n         }\n     }\n \n-    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_if_let_some_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n                 = higher::IfLet::hir(cx, expr);\n-            if Self::is_option(cx, let_expr);\n-\n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n-            if is_lang_ctor(cx, path1, OptionSome);\n+            if (Self::option_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, OptionSome)) ||\n+                (Self::result_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, ResultOk));\n+\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-\n             if let ExprKind::Block(block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n-\n-            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-                let replacement = format!(\n-                    \"{}{}?\",\n-                    receiver_str,\n-                    if by_ref { \".as_ref()\" } else { \"\" },\n-                );\n+                let replacement = format!(\"{}{}?\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" },);\n \n                 span_lint_and_sugg(\n                     cx,\n@@ -134,6 +131,14 @@ impl QuestionMark {\n         }\n     }\n \n+    fn result_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n+        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(cx, nested_expr, expr)\n+    }\n+\n+    fn option_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n+        Self::is_option(cx, expr) && Self::expression_returns_none(cx, nested_expr)\n+    }\n+\n     fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.typeck_results().expr_ty(expression);\n \n@@ -146,6 +151,12 @@ impl QuestionMark {\n         is_type_diagnostic_item(cx, expr_ty, sym::Option)\n     }\n \n+    fn is_result(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n+\n+        is_type_diagnostic_item(cx, expr_ty, sym::Result)\n+    }\n+\n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n             ExprKind::Block(block, _) => {\n@@ -161,6 +172,27 @@ impl QuestionMark {\n         }\n     }\n \n+    fn expression_returns_unmodified_err(\n+        cx: &LateContext<'_>,\n+        expression: &Expr<'_>,\n+        origin_hir_id: &Expr<'_>,\n+    ) -> bool {\n+        match expression.kind {\n+            ExprKind::Block(block, _) => {\n+                if let Some(return_expression) = Self::return_expression(block) {\n+                    return Self::expression_returns_unmodified_err(cx, return_expression, origin_hir_id);\n+                }\n+\n+                false\n+            },\n+            ExprKind::Ret(Some(expr)) | ExprKind::Call(expr, _) => {\n+                Self::expression_returns_unmodified_err(cx, expr, origin_hir_id)\n+            },\n+            ExprKind::Path(_) => path_to_local(expression) == path_to_local(origin_hir_id),\n+            _ => false,\n+        }\n+    }\n+\n     fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n@@ -189,7 +221,7 @@ impl QuestionMark {\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        Self::check_is_none_and_early_return_none(cx, expr);\n-        Self::check_if_let_some_and_early_return_none(cx, expr);\n+        Self::check_is_none_or_err_and_early_return(cx, expr);\n+        Self::check_if_let_some_or_err_and_early_return(cx, expr);\n     }\n }"}, {"sha": "c0e4914efe0bd1778a8ba68d4505c65048bdb310", "filename": "src/tools/clippy/clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,7 +1,7 @@\n use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{in_macro, sugg};\n+use clippy_utils::sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Block, ExprKind};\n@@ -39,7 +39,7 @@ declare_lint_pass!(SemicolonIfNothingReturned => [SEMICOLON_IF_NOTHING_RETURNED]\n impl LateLintPass<'_> for SemicolonIfNothingReturned {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) {\n         if_chain! {\n-            if !in_macro(block.span);\n+            if !block.span.from_expansion();\n             if let Some(expr) = block.expr;\n             let t_expr = cx.typeck_results().expr_ty(expr);\n             if t_expr.is_unit();"}, {"sha": "64841f33cc385afa389801c7ab9f19d2d3032514", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -162,11 +162,7 @@ fn lint_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, shadowed: HirId, span: Span)\n             (SHADOW_SAME, msg)\n         },\n         Some(expr) if is_local_used(cx, expr, shadowed) => {\n-            let msg = format!(\n-                \"`{}` is shadowed by `{}` which reuses the original value\",\n-                snippet(cx, pat.span, \"_\"),\n-                snippet(cx, expr.span, \"..\")\n-            );\n+            let msg = format!(\"`{}` is shadowed\", snippet(cx, pat.span, \"_\"));\n             (SHADOW_REUSE, msg)\n         },\n         _ => {"}, {"sha": "201aa06782405c17921c5c08e2c2b47b9162ef78", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -678,7 +678,7 @@ fn suggestion_with_swapped_ident(\n         Some(format!(\n             \"{}{}{}\",\n             snippet_with_applicability(cx, expr.span.with_hi(current_ident.span.lo()), \"..\", applicability),\n-            new_ident.to_string(),\n+            new_ident,\n             snippet_with_applicability(cx, expr.span.with_lo(current_ident.span.hi()), \"..\", applicability),\n         ))\n     })"}, {"sha": "c216a1f81ea547630840e7403bd0f8ebe4820204", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::{HirId, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Const;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Displays a warning when a struct with a trailing zero-sized array is declared without a `repr` attribute.\n+    ///\n+    /// ### Why is this bad?\n+    /// Zero-sized arrays aren't very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjuction with manual allocation to make it easy to compute the offset of the array). Either way, `#[repr(C)]` (or another `repr` attribute) is needed.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct RarelyUseful {\n+    ///     some_field: u32,\n+    ///     last: [u32; 0],\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct MoreOftenUseful {\n+    ///     some_field: usize,\n+    ///     last: [u32; 0],\n+    /// }\n+    /// ```\n+    pub TRAILING_EMPTY_ARRAY,\n+    nursery,\n+    \"struct with a trailing zero-sized array but without `#[repr(C)]` or another `repr` attribute\"\n+}\n+declare_lint_pass!(TrailingEmptyArray => [TRAILING_EMPTY_ARRAY]);\n+\n+impl<'tcx> LateLintPass<'tcx> for TrailingEmptyArray {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if is_struct_with_trailing_zero_sized_array(cx, item) && !has_repr_attr(cx, item.hir_id()) {\n+            span_lint_and_help(\n+                cx,\n+                TRAILING_EMPTY_ARRAY,\n+                item.span,\n+                \"trailing zero-sized array in a struct which is not marked with a `repr` attribute\",\n+                None,\n+                &format!(\n+                    \"consider annotating `{}` with `#[repr(C)]` or another `repr` attribute\",\n+                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) -> bool {\n+    if_chain! {\n+        // First check if last field is an array\n+        if let ItemKind::Struct(data, _) = &item.kind;\n+        if let Some(last_field) = data.fields().last();\n+        if let rustc_hir::TyKind::Array(_, length) = last_field.ty.kind;\n+\n+        // Then check if that that array zero-sized\n+        let length_ldid = cx.tcx.hir().local_def_id(length.hir_id);\n+        let length = Const::from_anon_const(cx.tcx, length_ldid);\n+        let length = length.try_eval_usize(cx.tcx, cx.param_env);\n+        if let Some(length) = length;\n+        then {\n+            length == 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn has_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    cx.tcx.hir().attrs(hir_id).iter().any(|attr| attr.has_name(sym::repr))\n+}"}, {"sha": "e6acf1a94c9299c6b2c59abfaa83a15da0441cb7", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -3,6 +3,7 @@ mod transmute_float_to_int;\n mod transmute_int_to_bool;\n mod transmute_int_to_char;\n mod transmute_int_to_float;\n+mod transmute_num_to_bytes;\n mod transmute_ptr_to_ptr;\n mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n@@ -261,6 +262,28 @@ declare_clippy_lint! {\n     \"transmutes from a float to an integer\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmutes from a number to an array of `u8`\n+    ///\n+    /// ### Why this is bad?\n+    /// Transmutes are dangerous and error-prone, whereas `to_ne_bytes`\n+    /// is intuitive and safe.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// unsafe {\n+    ///     let x: [u8; 8] = std::mem::transmute(1i64);\n+    /// }\n+    ///\n+    /// // should be\n+    /// let x: [u8; 8] = 0i64.to_ne_bytes();\n+    /// ```\n+    pub TRANSMUTE_NUM_TO_BYTES,\n+    complexity,\n+    \"transmutes from a number to an array of `u8`\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for transmutes from a pointer to a pointer, or\n@@ -330,6 +353,7 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_INT_TO_BOOL,\n     TRANSMUTE_INT_TO_FLOAT,\n     TRANSMUTE_FLOAT_TO_INT,\n+    TRANSMUTE_NUM_TO_BYTES,\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n ]);\n@@ -365,6 +389,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 linted |= transmute_int_to_bool::check(cx, e, from_ty, to_ty, args);\n                 linted |= transmute_int_to_float::check(cx, e, from_ty, to_ty, args, const_context);\n                 linted |= transmute_float_to_int::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= transmute_num_to_bytes::check(cx, e, from_ty, to_ty, args, const_context);\n                 linted |= unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n \n                 if !linted {"}, {"sha": "e83d2e06b9a8d26800e7b0a65b6f02e2b42221c8", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -33,7 +33,7 @@ pub(super) fn check<'tcx>(\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using\",\n-                        format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                        format!(\"std::char::from_u32({}).unwrap()\", arg),\n                         Applicability::Unspecified,\n                     );\n                 },"}, {"sha": "05eee380d6f409bdf275384d089a16b4334abf80", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using\",\n-                        format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                        format!(\"{}::from_bits({})\", to_ty, arg),\n                         Applicability::Unspecified,\n                     );\n                 },"}, {"sha": "5ba58a764940191728d0266f5c77b2e2cc113ef2", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_num_to_bytes.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,49 @@\n+use super::TRANSMUTE_NUM_TO_BYTES;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, UintTy};\n+\n+/// Checks for `transmute_int_to_float` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(_) | ty::Uint(_) | ty::Float(_), ty::Array(arr_ty, _)) => {\n+            if !matches!(arr_ty.kind(), ty::Uint(UintTy::U8)) {\n+                return false;\n+            }\n+            if matches!(from_ty.kind(), ty::Float(_)) && const_context {\n+                // TODO: Remove when const_float_bits_conv is stabilized\n+                // rust#72447\n+                return false;\n+            }\n+\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_NUM_TO_BYTES,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using `to_ne_bytes()`\",\n+                        format!(\"{}.to_ne_bytes()\", arg),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "e08e4d03c7efef5c651cdd46fcfb4ada153400d3", "filename": "src/tools/clippy/clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,225 @@\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n+use clippy_utils::{in_macro, is_lint_allowed};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, HirId, Local, UnsafeSource};\n+use rustc_lexer::TokenKind;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{BytePos, Span};\n+use std::borrow::Cow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `unsafe` blocks without a `// Safety: ` comment\n+    /// explaining why the unsafe operations performed inside\n+    /// the block are safe.\n+    ///\n+    /// ### Why is this bad?\n+    /// Undocumented unsafe blocks can make it difficult to\n+    /// read and maintain code, as well as uncover unsoundness\n+    /// and bugs.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// let ptr = unsafe { NonNull::new_unchecked(a) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// // Safety: references are guaranteed to be non-null.\n+    /// let ptr = unsafe { NonNull::new_unchecked(a) };\n+    /// ```\n+    pub UNDOCUMENTED_UNSAFE_BLOCKS,\n+    restriction,\n+    \"creating an unsafe block without explaining why it is safe\"\n+}\n+\n+impl_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n+\n+#[derive(Default)]\n+pub struct UndocumentedUnsafeBlocks {\n+    pub local_level: u32,\n+    pub local_span: Option<Span>,\n+    // The local was already checked for an overall safety comment\n+    // There is no need to continue checking the blocks in the local\n+    pub local_checked: bool,\n+    // Since we can only check the blocks from expanded macros\n+    // We have to omit the suggestion due to the actual definition\n+    // Not being available to us\n+    pub macro_expansion: bool,\n+}\n+\n+impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n+    fn check_block(&mut self, cx: &LateContext<'_>, block: &'_ Block<'_>) {\n+        if_chain! {\n+            if !self.local_checked;\n+            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id);\n+            if !in_external_macro(cx.tcx.sess, block.span);\n+            if let BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) = block.rules;\n+            if let Some(enclosing_scope_hir_id) = cx.tcx.hir().get_enclosing_scope(block.hir_id);\n+            if self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, block.span) == Some(false);\n+            then {\n+                let mut span = block.span;\n+\n+                if let Some(local_span) = self.local_span {\n+                    span = local_span;\n+\n+                    let result = self.block_has_safety_comment(cx.tcx, enclosing_scope_hir_id, span);\n+\n+                    if result.unwrap_or(true) {\n+                        self.local_checked = true;\n+                        return;\n+                    }\n+                }\n+\n+                self.lint(cx, span);\n+            }\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &LateContext<'_>, local: &'_ Local<'_>) {\n+        if_chain! {\n+            if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, local.hir_id);\n+            if !in_external_macro(cx.tcx.sess, local.span);\n+            if let Some(init) = local.init;\n+            then {\n+                self.visit_expr(init);\n+\n+                if self.local_level > 0 {\n+                    self.local_span = Some(local.span);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_block_post(&mut self, _: &LateContext<'_>, _: &'_ Block<'_>) {\n+        self.local_level = self.local_level.saturating_sub(1);\n+\n+        if self.local_level == 0 {\n+            self.local_checked = false;\n+            self.local_span = None;\n+        }\n+    }\n+}\n+\n+impl<'hir> Visitor<'hir> for UndocumentedUnsafeBlocks {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n+        match ex.kind {\n+            ExprKind::Block(_, _) => self.local_level = self.local_level.saturating_add(1),\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+}\n+\n+impl UndocumentedUnsafeBlocks {\n+    fn block_has_safety_comment(&mut self, tcx: TyCtxt<'_>, enclosing_hir_id: HirId, block_span: Span) -> Option<bool> {\n+        let map = tcx.hir();\n+        let source_map = tcx.sess.source_map();\n+\n+        let enclosing_scope_span = map.opt_span(enclosing_hir_id)?;\n+\n+        let between_span = if in_macro(block_span) {\n+            self.macro_expansion = true;\n+            enclosing_scope_span.with_hi(block_span.hi())\n+        } else {\n+            self.macro_expansion = false;\n+            enclosing_scope_span.to(block_span)\n+        };\n+\n+        let file_name = source_map.span_to_filename(between_span);\n+        let source_file = source_map.get_source_file(&file_name)?;\n+\n+        let lex_start = (between_span.lo().0 + 1) as usize;\n+        let src_str = source_file.src.as_ref()?[lex_start..between_span.hi().0 as usize].to_string();\n+\n+        let mut pos = 0;\n+        let mut comment = false;\n+\n+        for token in rustc_lexer::tokenize(&src_str) {\n+            match token.kind {\n+                TokenKind::LineComment { doc_style: None }\n+                | TokenKind::BlockComment {\n+                    doc_style: None,\n+                    terminated: true,\n+                } => {\n+                    let comment_str = src_str[pos + 2..pos + token.len].to_ascii_uppercase();\n+\n+                    if comment_str.contains(\"SAFETY:\") {\n+                        comment = true;\n+                    }\n+                },\n+                // We need to add all whitespace to `pos` before checking the comment's line number\n+                TokenKind::Whitespace => {},\n+                _ => {\n+                    if comment {\n+                        // Get the line number of the \"comment\" (really wherever the trailing whitespace ended)\n+                        let comment_line_num = source_file\n+                            .lookup_file_pos_with_col_display(BytePos((lex_start + pos).try_into().unwrap()))\n+                            .0;\n+                        // Find the block/local's line number\n+                        let block_line_num = tcx.sess.source_map().lookup_char_pos(block_span.lo()).line;\n+\n+                        // Check the comment is immediately followed by the block/local\n+                        if block_line_num == comment_line_num + 1 || block_line_num == comment_line_num {\n+                            return Some(true);\n+                        }\n+\n+                        comment = false;\n+                    }\n+                },\n+            }\n+\n+            pos += token.len;\n+        }\n+\n+        Some(false)\n+    }\n+\n+    fn lint(&self, cx: &LateContext<'_>, mut span: Span) {\n+        let source_map = cx.tcx.sess.source_map();\n+\n+        if source_map.is_multiline(span) {\n+            span = source_map.span_until_char(span, '\\n');\n+        }\n+\n+        if self.macro_expansion {\n+            span_lint_and_help(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe block in macro expansion missing a safety comment\",\n+                None,\n+                \"consider adding a safety comment in the macro definition\",\n+            );\n+        } else {\n+            let block_indent = indent_of(cx, span);\n+            let suggestion = format!(\"// Safety: ...\\n{}\", snippet(cx, span, \"..\"));\n+\n+            span_lint_and_sugg(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe block missing a safety comment\",\n+                \"consider adding a safety comment\",\n+                reindent_multiline(Cow::Borrowed(&suggestion), true, block_indent).to_string(),\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+    }\n+}"}, {"sha": "f3e8b6881058f93907762baedb2a472ab74fc1bc", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,223 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span};\n+\n+// TODO: add `ReadBuf` (RFC 2930) in \"How to fix\" once it is available in std\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `set_len()` call that creates `Vec` with uninitialized elements.\n+    /// This is commonly caused by calling `set_len()` right after allocating or\n+    /// reserving a buffer with `new()`, `default()`, `with_capacity()`, or `reserve()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It creates a `Vec` with uninitialized data, which leads to\n+    /// undefined behavior with most safe operations. Notably, uninitialized\n+    /// `Vec<u8>` must not be used with generic `Read`.\n+    ///\n+    /// Moreover, calling `set_len()` on a `Vec` created with `new()` or `default()`\n+    /// creates out-of-bound values that lead to heap memory corruption when used.\n+    ///\n+    /// ### Known Problems\n+    /// This lint only checks directly adjacent statements.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    /// unsafe { vec.set_len(1000); }\n+    /// reader.read(&mut vec); // undefined behavior!\n+    /// ```\n+    ///\n+    /// ### How to fix?\n+    /// 1. Use an initialized buffer:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = vec![0; 1000];\n+    ///    reader.read(&mut vec);\n+    ///    ```\n+    /// 2. Wrap the content in `MaybeUninit`:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+    ///    vec.set_len(1000);  // `MaybeUninit` can be uninitialized\n+    ///    ```\n+    /// 3. If you are on nightly, `Vec::spare_capacity_mut()` is available:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    ///    let remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`\n+    ///    // perform initialization with `remaining`\n+    ///    vec.set_len(...);  // Safe to call `set_len()` on initialized part\n+    ///    ```\n+    pub UNINIT_VEC,\n+    correctness,\n+    \"Vec with uninitialized data\"\n+}\n+\n+declare_lint_pass!(UninitVec => [UNINIT_VEC]);\n+\n+// FIXME: update to a visitor-based implementation.\n+// Threads: https://github.com/rust-lang/rust-clippy/pull/7682#discussion_r710998368\n+impl<'tcx> LateLintPass<'tcx> for UninitVec {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        if !in_external_macro(cx.tcx.sess, block.span) {\n+            for w in block.stmts.windows(2) {\n+                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = w[1].kind {\n+                    handle_uninit_vec_pair(cx, &w[0], expr);\n+                }\n+            }\n+\n+            if let (Some(stmt), Some(expr)) = (block.stmts.last(), block.expr) {\n+                handle_uninit_vec_pair(cx, stmt, expr);\n+            }\n+        }\n+    }\n+}\n+\n+fn handle_uninit_vec_pair(\n+    cx: &LateContext<'tcx>,\n+    maybe_init_or_reserve: &'tcx Stmt<'tcx>,\n+    maybe_set_len: &'tcx Expr<'tcx>,\n+) {\n+    if_chain! {\n+        if let Some(vec) = extract_init_or_reserve_target(cx, maybe_init_or_reserve);\n+        if let Some((set_len_self, call_span)) = extract_set_len_self(cx, maybe_set_len);\n+        if vec.location.eq_expr(cx, set_len_self);\n+        if let ty::Ref(_, vec_ty, _) = cx.typeck_results().expr_ty_adjusted(set_len_self).kind();\n+        if let ty::Adt(_, substs) = vec_ty.kind();\n+        // `#[allow(...)]` attribute can be set on enclosing unsafe block of `set_len()`\n+        if !is_lint_allowed(cx, UNINIT_VEC, maybe_set_len.hir_id);\n+        then {\n+            if vec.has_capacity() {\n+                // with_capacity / reserve -> set_len\n+\n+                // Check T of Vec<T>\n+                if !is_uninit_value_valid_for_ty(cx, substs.type_at(0)) {\n+                    // FIXME: #7698, false positive of the internal lints\n+                    #[allow(clippy::collapsible_span_lint_calls)]\n+                    span_lint_and_then(\n+                        cx,\n+                        UNINIT_VEC,\n+                        vec![call_span, maybe_init_or_reserve.span],\n+                        \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n+                        |diag| {\n+                            diag.help(\"initialize the buffer or wrap the content in `MaybeUninit`\");\n+                        },\n+                    );\n+                }\n+            } else {\n+                // new / default -> set_len\n+                span_lint(\n+                    cx,\n+                    UNINIT_VEC,\n+                    vec![call_span, maybe_init_or_reserve.span],\n+                    \"calling `set_len()` on empty `Vec` creates out-of-bound values\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// The target `Vec` that is initialized or reserved\n+#[derive(Clone, Copy)]\n+struct TargetVec<'tcx> {\n+    location: VecLocation<'tcx>,\n+    /// `None` if `reserve()`\n+    init_kind: Option<VecInitKind>,\n+}\n+\n+impl TargetVec<'_> {\n+    pub fn has_capacity(self) -> bool {\n+        !matches!(self.init_kind, Some(VecInitKind::New | VecInitKind::Default))\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum VecLocation<'tcx> {\n+    Local(HirId),\n+    Expr(&'tcx Expr<'tcx>),\n+}\n+\n+impl<'tcx> VecLocation<'tcx> {\n+    pub fn eq_expr(self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+        match self {\n+            VecLocation::Local(hir_id) => path_to_local_id(expr, hir_id),\n+            VecLocation::Expr(self_expr) => SpanlessEq::new(cx).eq_expr(self_expr, expr),\n+        }\n+    }\n+}\n+\n+/// Finds the target location where the result of `Vec` initialization is stored\n+/// or `self` expression for `Vec::reserve()`.\n+fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> Option<TargetVec<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Local(local) => {\n+            if_chain! {\n+                if let Some(init_expr) = local.init;\n+                if let PatKind::Binding(_, hir_id, _, None) = local.pat.kind;\n+                if let Some(init_kind) = get_vec_init_kind(cx, init_expr);\n+                then {\n+                    return Some(TargetVec {\n+                        location: VecLocation::Local(hir_id),\n+                        init_kind: Some(init_kind),\n+                    })\n+                }\n+            }\n+        },\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n+            ExprKind::Assign(lhs, rhs, _span) => {\n+                if let Some(init_kind) = get_vec_init_kind(cx, rhs) {\n+                    return Some(TargetVec {\n+                        location: VecLocation::Expr(lhs),\n+                        init_kind: Some(init_kind),\n+                    });\n+                }\n+            },\n+            ExprKind::MethodCall(path, _, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+                return Some(TargetVec {\n+                    location: VecLocation::Expr(self_expr),\n+                    init_kind: None,\n+                });\n+            },\n+            _ => (),\n+        },\n+        StmtKind::Item(_) => (),\n+    }\n+    None\n+}\n+\n+fn is_reserve(cx: &LateContext<'_>, path: &PathSegment<'_>, self_expr: &Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr).peel_refs(), sym::Vec)\n+        && path.ident.name.as_str() == \"reserve\"\n+}\n+\n+/// Returns self if the expression is `Vec::set_len()`\n+fn extract_set_len_self(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&'tcx Expr<'tcx>, Span)> {\n+    // peel unsafe blocks in `unsafe { vec.set_len() }`\n+    let expr = peel_hir_expr_while(expr, |e| {\n+        if let ExprKind::Block(block, _) = e.kind {\n+            // Extract the first statement/expression\n+            match (block.stmts.get(0).map(|stmt| &stmt.kind), block.expr) {\n+                (None, Some(expr)) => Some(expr),\n+                (Some(StmtKind::Expr(expr) | StmtKind::Semi(expr)), _) => Some(expr),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(path, _, [self_expr, _], _) => {\n+            let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n+            if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n+                Some((self_expr, expr.span))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "26b56e0f2f316c69b7e53e9f5f50020f25290c3b", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n@@ -193,10 +193,15 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n \n+            if_chain! {\n             if let ExprKind::Path(QPath::Resolved(_, Path {\n                 segments: [PathSegment { ident: left_name, .. }], ..\n-            })) = &left_expr.kind {\n-                if left_name == left_ident {\n+            })) = &left_expr.kind;\n+            if left_name == left_ident;\n+            if cx.tcx.get_diagnostic_item(sym::Ord).map_or(false, |id| {\n+                implements_trait(cx, cx.typeck_results().expr_ty(left_expr), id, &[])\n+            });\n+                then {\n                     return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }));\n                 }\n             }"}, {"sha": "d05c52122d5ee518ab1d00f0349851909026151b", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -23,6 +23,14 @@ pub enum DisallowedMethod {\n     WithReason { path: String, reason: Option<String> },\n }\n \n+/// A single disallowed type, used by the `DISALLOWED_TYPE` lint.\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(untagged)]\n+pub enum DisallowedType {\n+    Simple(String),\n+    WithReason { path: String, reason: Option<String> },\n+}\n+\n /// Conf with parse errors\n #[derive(Default)]\n pub struct TryConf {\n@@ -255,7 +263,7 @@ define_Conf! {\n     /// Lint: DISALLOWED_TYPE.\n     ///\n     /// The list of disallowed types, written as fully qualified paths.\n-    (disallowed_types: Vec<String> = Vec::new()),\n+    (disallowed_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL.\n     ///\n     /// Should the fraction of a decimal be linted to include separators."}, {"sha": "824ec53ab9c75301f822805eaf5cf860fe03ff74", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -770,8 +770,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n             if let Some(ty_did) = path_to_res(cx, &segments[..]).opt_def_id();\n             // Check if the matched type is a diagnostic item\n-            let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n-            if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n+            if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n             then {\n                 // TODO: check paths constants from external crates.\n                 let cx_snippet = snippet(cx, context.span, \"_\");"}, {"sha": "b92b6ca4f4380f981ee9f9ed163d44470994555c", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,16 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, path_to_local, path_to_local_id, paths};\n+use clippy_utils::{path_to_local, path_to_local_id};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span};\n-use std::convert::TryInto;\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -41,11 +39,6 @@ pub struct VecInitThenPush {\n     searcher: Option<VecPushSearcher>,\n }\n \n-#[derive(Clone, Copy)]\n-enum VecInitKind {\n-    New,\n-    WithCapacity(u64),\n-}\n struct VecPushSearcher {\n     local_id: HirId,\n     init: VecInitKind,\n@@ -58,7 +51,8 @@ impl VecPushSearcher {\n     fn display_err(&self, cx: &LateContext<'_>) {\n         match self.init {\n             _ if self.found == 0 => return,\n-            VecInitKind::WithCapacity(x) if x > self.found => return,\n+            VecInitKind::WithLiteralCapacity(x) if x > self.found => return,\n+            VecInitKind::WithExprCapacity(_) => return,\n             _ => (),\n         };\n \n@@ -152,37 +146,3 @@ impl LateLintPass<'_> for VecInitThenPush {\n         }\n     }\n }\n-\n-fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n-    if let ExprKind::Call(func, args) = expr.kind {\n-        match func.kind {\n-            ExprKind::Path(QPath::TypeRelative(ty, name))\n-                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n-            {\n-                if name.ident.name == sym::new {\n-                    return Some(VecInitKind::New);\n-                } else if name.ident.name.as_str() == \"with_capacity\" {\n-                    return args.get(0).and_then(|arg| {\n-                        if_chain! {\n-                            if let ExprKind::Lit(lit) = &arg.kind;\n-                            if let LitKind::Int(num, _) = lit.node;\n-                            then {\n-                                Some(VecInitKind::WithCapacity(num.try_into().ok()?))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    });\n-                }\n-            }\n-            ExprKind::Path(QPath::Resolved(_, path))\n-                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n-                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n-            {\n-                return Some(VecInitKind::New);\n-            }\n-            _ => (),\n-        }\n-    }\n-    None\n-}"}, {"sha": "d99a3d9359e1f439ba973431874f2b2b3c3941d1", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.57\"\n+version = \"0.1.58\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "60c4cb361aa6c0dfbc2d9ff534ca2569d9e7db18", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 154, "deletions": 3, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -2,13 +2,16 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::{is_expn_of, match_def_path, paths};\n+use crate::ty::is_type_diagnostic_item;\n+use crate::{is_expn_of, last_path_segment, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n+use rustc_hir::{\n+    Arm, Block, BorrowKind, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath, StmtKind, UnOp,\n+};\n use rustc_lint::LateContext;\n-use rustc_span::{sym, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, symbol, ExpnKind, Span, Symbol};\n \n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n@@ -569,6 +572,106 @@ impl FormatArgsExpn<'tcx> {\n             }\n         }\n     }\n+\n+    /// Returns a vector of `FormatArgsArg`.\n+    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n+        if let Some(expr) = self.fmt_expr {\n+            if_chain! {\n+                if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n+                if let ExprKind::Array(exprs) = expr.kind;\n+                then {\n+                    exprs.iter().map(|fmt| {\n+                        if_chain! {\n+                            // struct `core::fmt::rt::v1::Argument`\n+                            if let ExprKind::Struct(_, fields, _) = fmt.kind;\n+                            if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n+                            if let ExprKind::Lit(lit) = &position_field.expr.kind;\n+                            if let LitKind::Int(position, _) = lit.node;\n+                            then {\n+                                let i = usize::try_from(position).unwrap();\n+                                Some(FormatArgsArg { value: self.value_args[i], arg: &self.args[i], fmt: Some(fmt) })\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    }).collect()\n+                } else {\n+                    None\n+                }\n+            }\n+        } else {\n+            Some(\n+                self.value_args\n+                    .iter()\n+                    .zip(self.args.iter())\n+                    .map(|(value, arg)| FormatArgsArg { value, arg, fmt: None })\n+                    .collect(),\n+            )\n+        }\n+    }\n+}\n+\n+/// Type representing a `FormatArgsExpn`'s format arguments\n+pub struct FormatArgsArg<'tcx> {\n+    /// An element of `value_args` according to `position`\n+    pub value: &'tcx Expr<'tcx>,\n+    /// An element of `args` according to `position`\n+    pub arg: &'tcx Expr<'tcx>,\n+    /// An element of `fmt_expn`\n+    pub fmt: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsArg<'tcx> {\n+    /// Returns true if any formatting parameters are used that would have an effect on strings,\n+    /// like `{:+2}` instead of just `{}`.\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.fmt.map_or(false, |fmt| {\n+            // `!` because these conditions check that `self` is unformatted.\n+            !if_chain! {\n+                // struct `core::fmt::rt::v1::Argument`\n+                if let ExprKind::Struct(_, fields, _) = fmt.kind;\n+                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n+                // struct `core::fmt::rt::v1::FormatSpec`\n+                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n+                let mut precision_found = false;\n+                let mut width_found = false;\n+                if subfields.iter().all(|field| {\n+                    match field.ident.name {\n+                        sym::precision => {\n+                            precision_found = true;\n+                            if let ExprKind::Path(ref precision_path) = field.expr.kind {\n+                                last_path_segment(precision_path).ident.name == sym::Implied\n+                            } else {\n+                                false\n+                            }\n+                        }\n+                        sym::width => {\n+                            width_found = true;\n+                            if let ExprKind::Path(ref width_qpath) = field.expr.kind {\n+                                last_path_segment(width_qpath).ident.name == sym::Implied\n+                            } else {\n+                                false\n+                            }\n+                        }\n+                        _ => true,\n+                    }\n+                });\n+                if precision_found && width_found;\n+                then { true } else { false }\n+            }\n+        })\n+    }\n+\n+    /// Returns true if the argument is formatted using `Display::fmt`.\n+    pub fn is_display(&self) -> bool {\n+        if_chain! {\n+            if let ExprKind::Call(_, [_, format_field]) = self.arg.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = format_field.kind;\n+            if let [.., t, _] = path.segments;\n+            if t.ident.name == sym::Display;\n+            then { true } else { false }\n+        }\n+    }\n }\n \n /// Checks if a `let` statement is from a `for` loop desugaring.\n@@ -631,3 +734,51 @@ impl PanicExpn<'tcx> {\n         }\n     }\n }\n+\n+/// A parsed `Vec` initialization expression\n+#[derive(Clone, Copy)]\n+pub enum VecInitKind {\n+    /// `Vec::new()`\n+    New,\n+    /// `Vec::default()` or `Default::default()`\n+    Default,\n+    /// `Vec::with_capacity(123)`\n+    WithLiteralCapacity(u64),\n+    /// `Vec::with_capacity(slice.len())`\n+    WithExprCapacity(HirId),\n+}\n+\n+/// Checks if given expression is an initialization of `Vec` and returns its kind.\n+pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name == symbol::kw::Default {\n+                    return Some(VecInitKind::Default);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    let arg = args.get(0)?;\n+                    if_chain! {\n+                        if let ExprKind::Lit(lit) = &arg.kind;\n+                        if let LitKind::Int(num, _) = lit.node;\n+                        then {\n+                            return Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n+                        }\n+                    }\n+                    return Some(VecInitKind::WithExprCapacity(arg.hir_id));\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n+            {\n+                return Some(VecInitKind::Default);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}"}, {"sha": "9bc380ca6caa6501c526c4edd18b2faa11df4a5c", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 83, "deletions": 35, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -69,11 +69,13 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n-    PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs,\n+    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node,\n+    Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -251,11 +253,7 @@ pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem\n /// Returns `true` if this `span` was expanded by any macro.\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n-    if span.from_expansion() {\n-        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-    } else {\n-        false\n-    }\n+    span.from_expansion() && !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n }\n \n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n@@ -1285,10 +1283,9 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n     }\n     let enclosing_body = cx.tcx.hir().local_def_id(cx.tcx.hir().enclosing_body_owner(e.hir_id));\n     if let Some((Constant::Int(v), _)) = constant(cx, cx.tcx.typeck(enclosing_body), e) {\n-        value == v\n-    } else {\n-        false\n+        return value == v;\n     }\n+    false\n }\n \n /// Checks whether the given expression is a constant literal of the given value.\n@@ -1315,7 +1312,7 @@ pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n \n /// Returns the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n-/// See also `is_direct_expn_of`.\n+/// See also [`is_direct_expn_of`].\n #[must_use]\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n@@ -1338,13 +1335,13 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n \n /// Returns the pre-expansion span if the span directly comes from an expansion\n /// of the macro `name`.\n-/// The difference with `is_expn_of` is that in\n-/// ```rust,ignore\n+/// The difference with [`is_expn_of`] is that in\n+/// ```rust\n+/// # macro_rules! foo { ($e:tt) => { $e } }; macro_rules! bar { ($e:expr) => { $e } }\n /// foo!(bar!(42));\n /// ```\n /// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n-/// `bar!` by\n-/// `is_direct_expn_of`.\n+/// from `bar!` by `is_direct_expn_of`.\n #[must_use]\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     if span.from_expansion() {\n@@ -1467,11 +1464,9 @@ pub fn is_self(slf: &Param<'_>) -> bool {\n }\n \n pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(None, path)) = slf.kind;\n-        if let Res::SelfTy(..) = path.res;\n-        then {\n-            return true\n+    if let TyKind::Path(QPath::Resolved(None, path)) = slf.kind {\n+        if let Res::SelfTy(..) = path.res {\n+            return true;\n         }\n     }\n     false\n@@ -2062,27 +2057,80 @@ macro_rules! unwrap_cargo_metadata {\n }\n \n pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-        if let Res::Def(_, def_id) = path.res;\n-        then {\n-            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n-        } else {\n-            false\n+    if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+        if let Res::Def(_, def_id) = path.res {\n+            return cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr);\n         }\n     }\n+    false\n }\n \n-/// Checks whether item either has `test` attribute applied, or\n-/// is a module with `test` in its name.\n-pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n-    if let Some(def_id) = tcx.hir().opt_local_def_id(item.hir_id()) {\n-        if tcx.has_attr(def_id.to_def_id(), sym::test) {\n-            return true;\n+struct VisitConstTestStruct<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    names: Vec<Symbol>,\n+    found: bool,\n+}\n+impl<'hir> ItemLikeVisitor<'hir> for VisitConstTestStruct<'hir> {\n+    fn visit_item(&mut self, item: &Item<'_>) {\n+        if let ItemKind::Const(ty, _body) = item.kind {\n+            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+                // We could also check for the type name `test::TestDescAndFn`\n+                // and the `#[rustc_test_marker]` attribute?\n+                if let Res::Def(DefKind::Struct, _) = path.res {\n+                    let has_test_marker = self\n+                        .tcx\n+                        .hir()\n+                        .attrs(item.hir_id())\n+                        .iter()\n+                        .any(|a| a.has_name(sym::rustc_test_marker));\n+                    if has_test_marker && self.names.contains(&item.ident.name) {\n+                        self.found = true;\n+                    }\n+                }\n+            }\n         }\n     }\n+    fn visit_trait_item(&mut self, _: &TraitItem<'_>) {}\n+    fn visit_impl_item(&mut self, _: &ImplItem<'_>) {}\n+    fn visit_foreign_item(&mut self, _: &ForeignItem<'_>) {}\n+}\n+\n+/// Checks if the function containing the given `HirId` is a `#[test]` function\n+///\n+/// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n+pub fn is_in_test_function(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n+    let names: Vec<_> = tcx\n+        .hir()\n+        .parent_iter(id)\n+        // Since you can nest functions we need to collect all until we leave\n+        // function scope\n+        .filter_map(|(_id, node)| {\n+            if let Node::Item(item) = node {\n+                if let ItemKind::Fn(_, _, _) = item.kind {\n+                    return Some(item.ident.name);\n+                }\n+            }\n+            None\n+        })\n+        .collect();\n+    let parent_mod = tcx.parent_module(id);\n+    let mut vis = VisitConstTestStruct {\n+        tcx,\n+        names,\n+        found: false,\n+    };\n+    tcx.hir().visit_item_likes_in_module(parent_mod, &mut vis);\n+    vis.found\n+}\n \n-    matches!(item.kind, ItemKind::Mod(..)) && item.ident.name.as_str().contains(\"test\")\n+/// Checks whether item either has `test` attribute appelied, or\n+/// is a module with `test` in its name.\n+///\n+/// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n+pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n+    is_in_test_function(tcx, item.hir_id())\n+        || matches!(item.kind, ItemKind::Mod(..))\n+            && item.ident.name.as_str().split('_').any(|a| a == \"test\" || a == \"tests\")\n }\n \n macro_rules! op_utils {"}, {"sha": "501b08a47f161103b9f34b46760ae2502df8d4bc", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -17,6 +17,12 @@ pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n #[cfg(feature = \"metadata-collector-lint\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_EQ_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_eq\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"assert\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const ASSERT_NE_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_ne\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n@@ -41,11 +47,17 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n #[cfg(feature = \"internal-lints\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const EPRINT_MACRO: [&str; 3] = [\"std\", \"macros\", \"eprint\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const EPRINTLN_MACRO: [&str; 3] = [\"std\", \"macros\", \"eprintln\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const FORMAT_ARGS_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"format_args\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n@@ -108,6 +120,10 @@ pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"Permis\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const PRINT_MACRO: [&str; 3] = [\"std\", \"macros\", \"print\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const PRINTLN_MACRO: [&str; 3] = [\"std\", \"macros\", \"println\"];\n pub const PTR_COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const PTR_COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n@@ -184,3 +200,7 @@ pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const WRITE_MACRO: [&str; 3] = [\"core\", \"macros\", \"write\"];\n+#[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n+pub const WRITELN_MACRO: [&str; 3] = [\"core\", \"macros\", \"writeln\"];"}, {"sha": "ca64ac7de3eea4b98fd9f609a82d153008dbc9df", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -367,3 +367,13 @@ pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         _ => a == b,\n     }\n }\n+\n+/// Checks if a given type looks safe to be uninitialized.\n+pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+        ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n+        _ => false,\n+    }\n+}"}, {"sha": "57a90a924ec3cf9fd0a58ab6d3d969a2b1b91ef8", "filename": "src/tools/clippy/doc/basics.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -96,6 +96,7 @@ cargo dev setup git-hook\n # (experimental) Setup Clippy to work with IntelliJ-Rust\n cargo dev setup intellij\n ```\n+More about intellij command usage and reasons [here](../CONTRIBUTING.md#intellij-rust)\n \n ## lintcheck\n `cargo lintcheck` will build and run clippy on a fixed set of crates and generate a log of the results.  "}, {"sha": "67eaf286004f9515cabbfefe3d889ec4b9c74b3f", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-10-07\"\n+channel = \"nightly-2021-10-21\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "c15835ef2995687327d9227c861b1decd8b3f85d", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -149,6 +149,19 @@ fn run_ui(cfg: &mut compiletest::Config) {\n     compiletest::run_tests(cfg);\n }\n \n+fn run_ui_test(cfg: &mut compiletest::Config) {\n+    cfg.mode = TestMode::Ui;\n+    cfg.src_base = Path::new(\"tests\").join(\"ui_test\");\n+    let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", std::fs::canonicalize(\"tests\").unwrap());\n+    let rustcflags = cfg.target_rustcflags.get_or_insert_with(Default::default);\n+    let len = rustcflags.len();\n+    rustcflags.push_str(\" --test\");\n+    compiletest::run_tests(cfg);\n+    if let Some(ref mut flags) = &mut cfg.target_rustcflags {\n+        flags.truncate(len);\n+    }\n+}\n+\n fn run_internal_tests(cfg: &mut compiletest::Config) {\n     // only run internal tests with the internal-tests feature\n     if !RUN_INTERNAL_TESTS {\n@@ -312,6 +325,7 @@ fn compile_test() {\n     prepare_env();\n     let mut config = default_config();\n     run_ui(&mut config);\n+    run_ui_test(&mut config);\n     run_ui_toml(&mut config);\n     run_ui_cargo(&mut config);\n     run_internal_tests(&mut config);"}, {"sha": "12e05eaa7a09ab1070681f50275dbffff46e065d", "filename": "src/tools/clippy/tests/ui-internal/unnecessary_symbol_str.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_symbol_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_symbol_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Funnecessary_symbol_str.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -27,12 +27,13 @@ error: unnecessary `Symbol` to string conversion\n   --> $DIR/unnecessary_symbol_str.rs:14:5\n    |\n LL |     &*Ident::empty().as_str() == \"clippy\";\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Ident::empty().name == rustc_span::sym::clippy`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Ident::empty().name == rustc_span::sym::clippy`\n \n error: unnecessary `Symbol` to string conversion\n   --> $DIR/unnecessary_symbol_str.rs:15:5\n    |\n LL |     \"clippy\" == Ident::empty().to_string();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::clippy == Ident::empty().name`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::clippy == Ident::empty().name`\n \n error: aborting due to 5 previous errors\n+"}, {"sha": "6cb9e2ef95467be59c0ba74c9dc8d25de2411c09", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_type/clippy.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -7,5 +7,9 @@ disallowed-types = [\n     \"std::time::Instant\",\n     \"std::io::Read\",\n     \"std::primitive::usize\",\n-    \"bool\"\n+    \"bool\",\n+    # can give path and reason with an inline table\n+    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n+    # can use an inline table but omit reason\n+    { path = \"std::net::TcpListener\" },\n ]"}, {"sha": "410f076505511c6d84c4eae6224ae4625517d516", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_type/conf_disallowed_type.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -25,6 +25,10 @@ struct GenArg<const U: usize>([u8; U]);\n \n static BAD: foo::atomic::AtomicPtr<()> = foo::atomic::AtomicPtr::new(std::ptr::null_mut());\n \n+fn ip(_: std::net::Ipv4Addr) {}\n+\n+fn listener(_: std::net::TcpListener) {}\n+\n #[allow(clippy::diverging_sub_expression)]\n fn main() {\n     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();"}, {"sha": "08a400a83675b916a59ca597472bdd6a7c6cb524", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_type/conf_disallowed_type.stderr", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -60,59 +60,73 @@ error: `usize` is not allowed according to config\n LL | struct GenArg<const U: usize>([u8; U]);\n    |                        ^^^^^\n \n+error: `std::net::Ipv4Addr` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:28:10\n+   |\n+LL | fn ip(_: std::net::Ipv4Addr) {}\n+   |          ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: no IPv4 allowed (from clippy.toml)\n+\n+error: `std::net::TcpListener` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:30:16\n+   |\n+LL | fn listener(_: std::net::TcpListener) {}\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+\n error: `std::collections::HashMap` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:30:48\n+  --> $DIR/conf_disallowed_type.rs:34:48\n    |\n LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `std::collections::HashMap` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:30:12\n+  --> $DIR/conf_disallowed_type.rs:34:12\n    |\n LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `std::time::Instant` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:31:13\n+  --> $DIR/conf_disallowed_type.rs:35:13\n    |\n LL |     let _ = Sneaky::now();\n    |             ^^^^^^\n \n error: `std::sync::atomic::AtomicU32` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:32:13\n+  --> $DIR/conf_disallowed_type.rs:36:13\n    |\n LL |     let _ = foo::atomic::AtomicU32::new(0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^\n \n error: `std::sync::atomic::AtomicU32` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:33:17\n+  --> $DIR/conf_disallowed_type.rs:37:17\n    |\n LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `std::sync::atomic::AtomicU32` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:33:48\n+  --> $DIR/conf_disallowed_type.rs:37:48\n    |\n LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^\n \n error: `syn::TypePath` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:34:43\n+  --> $DIR/conf_disallowed_type.rs:38:43\n    |\n LL |     let _: std::collections::BTreeMap<(), syn::TypePath> = Default::default();\n    |                                           ^^^^^^^^^^^^^\n \n error: `syn::Ident` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:35:13\n+  --> $DIR/conf_disallowed_type.rs:39:13\n    |\n LL |     let _ = syn::Ident::new(\"\", todo!());\n    |             ^^^^^^^^^^\n \n error: `usize` is not allowed according to config\n-  --> $DIR/conf_disallowed_type.rs:37:12\n+  --> $DIR/conf_disallowed_type.rs:41:12\n    |\n LL |     let _: usize = 64_usize;\n    |            ^^^^^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "0251fada9e85a6ea8aa5dbfc954292835fab394c", "filename": "src/tools/clippy/tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -113,3 +113,10 @@ macro_rules! default_numeric_fallback {\n         let x = 22;\n     };\n }\n+\n+#[macro_export]\n+macro_rules! mut_mut {\n+    () => {\n+        let mut_mut_ty: &mut &mut u32 = &mut &mut 1u32;\n+    };\n+}"}, {"sha": "061a4ab9b2ef8da2809901e986d07b3b45ab64ca", "filename": "src/tools/clippy/tests/ui/cfg_attr_rustfmt.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![feature(stmt_expr_attributes)]\n \n-#![allow(unused, clippy::no_effect)]\n+#![allow(unused, clippy::no_effect, clippy::unnecessary_operation)]\n #![warn(clippy::deprecated_cfg_attr)]\n \n // This doesn't get linted, see known problems"}, {"sha": "035169fab85befb570e7d06ebcc5ff518652109b", "filename": "src/tools/clippy/tests/ui/cfg_attr_rustfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcfg_attr_rustfmt.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![feature(stmt_expr_attributes)]\n \n-#![allow(unused, clippy::no_effect)]\n+#![allow(unused, clippy::no_effect, clippy::unnecessary_operation)]\n #![warn(clippy::deprecated_cfg_attr)]\n \n // This doesn't get linted, see known problems"}, {"sha": "03bb30f9083ac4f3c21ab23a635747ef8ba128fd", "filename": "src/tools/clippy/tests/ui/doc_unsafe.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdoc_unsafe.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -115,3 +115,13 @@ fn main() {\n         drive();\n     }\n }\n+\n+// do not lint if any parent has `#[doc(hidden)]` attribute\n+// see #7347\n+#[doc(hidden)]\n+pub mod __macro {\n+    pub struct T;\n+    impl T {\n+        pub unsafe fn f() {}\n+    }\n+}"}, {"sha": "88918d9671e42f6d90037eae22fc8985ab5de651", "filename": "src/tools/clippy/tests/ui/equatable_if_let.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -66,4 +66,13 @@ fn main() {\n     if g == NotStructuralEq::A {}\n     if let Some(NotPartialEq::A) = Some(f) {}\n     if Some(g) == Some(NotStructuralEq::A) {}\n+\n+    macro_rules! m1 {\n+        (x) => {\n+            \"abc\"\n+        };\n+    }\n+    if \"abc\" == m1!(x) {\n+        println!(\"OK\");\n+    }\n }"}, {"sha": "9a7ab75ef450f528f5ff1543f3bdd361c1881f67", "filename": "src/tools/clippy/tests/ui/equatable_if_let.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -66,4 +66,13 @@ fn main() {\n     if let NotStructuralEq::A = g {}\n     if let Some(NotPartialEq::A) = Some(f) {}\n     if let Some(NotStructuralEq::A) = Some(g) {}\n+\n+    macro_rules! m1 {\n+        (x) => {\n+            \"abc\"\n+        };\n+    }\n+    if let m1!(x) = \"abc\" {\n+        println!(\"OK\");\n+    }\n }"}, {"sha": "760ff88f448f094561f008b0e29be43824306260", "filename": "src/tools/clippy/tests/ui/equatable_if_let.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fequatable_if_let.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -60,5 +60,11 @@ error: this pattern matching can be expressed using equality\n LL |     if let Some(NotStructuralEq::A) = Some(g) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(g) == Some(NotStructuralEq::A)`\n \n-error: aborting due to 10 previous errors\n+error: this pattern matching can be expressed using equality\n+  --> $DIR/equatable_if_let.rs:75:8\n+   |\n+LL |     if let m1!(x) = \"abc\" {\n+   |        ^^^^^^^^^^^^^^^^^^ help: try: `\"abc\" == m1!(x)`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "cf923a6a5940c3574216eca71be849f9cd89d6e5", "filename": "src/tools/clippy/tests/ui/expect_fun_call.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::expect_fun_call)]\n+#![allow(clippy::to_string_in_format_args)]\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n "}, {"sha": "e6f252259df70427e2da39b9ca9a3c6172f51659", "filename": "src/tools/clippy/tests/ui/expect_fun_call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::expect_fun_call)]\n+#![allow(clippy::to_string_in_format_args)]\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n "}, {"sha": "ac48a06671cd2e0d572ecc36637c0237bc90426c", "filename": "src/tools/clippy/tests/ui/expect_fun_call.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,73 +1,73 @@\n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:28:26\n+  --> $DIR/expect_fun_call.rs:29:26\n    |\n LL |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n    |\n    = note: `-D clippy::expect-fun-call` implied by `-D warnings`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:31:26\n+  --> $DIR/expect_fun_call.rs:32:26\n    |\n LL |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:41:25\n+  --> $DIR/expect_fun_call.rs:42:25\n    |\n LL |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:44:25\n+  --> $DIR/expect_fun_call.rs:45:25\n    |\n LL |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:56:17\n+  --> $DIR/expect_fun_call.rs:57:17\n    |\n LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:77:21\n+  --> $DIR/expect_fun_call.rs:78:21\n    |\n LL |         Some(\"foo\").expect(&get_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:78:21\n+  --> $DIR/expect_fun_call.rs:79:21\n    |\n LL |         Some(\"foo\").expect(get_string().as_ref());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:79:21\n+  --> $DIR/expect_fun_call.rs:80:21\n    |\n LL |         Some(\"foo\").expect(get_string().as_str());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:81:21\n+  --> $DIR/expect_fun_call.rs:82:21\n    |\n LL |         Some(\"foo\").expect(get_static_str());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_static_str()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:82:21\n+  --> $DIR/expect_fun_call.rs:83:21\n    |\n LL |         Some(\"foo\").expect(get_non_static_str(&0));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_non_static_str(&0).to_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:86:16\n+  --> $DIR/expect_fun_call.rs:87:16\n    |\n LL |     Some(true).expect(&format!(\"key {}, {}\", 1, 2));\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"key {}, {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:92:17\n+  --> $DIR/expect_fun_call.rs:93:17\n    |\n LL |         opt_ref.expect(&format!(\"{:?}\", opt_ref));\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{:?}\", opt_ref))`"}, {"sha": "7367910eaa126fdc54319aa3d7232765dcca376d", "filename": "src/tools/clippy/tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -183,3 +183,67 @@ struct WrapperMulti<T, U> {\n     i: T,\n     j: U,\n }\n+\n+mod issue6312 {\n+    use std::sync::atomic::AtomicBool;\n+    use std::sync::Arc;\n+\n+    // do not lint: type implements `Drop` but not all fields are `Copy`\n+    #[derive(Clone, Default)]\n+    pub struct ImplDropNotAllCopy {\n+        name: String,\n+        delay_data_sync: Arc<AtomicBool>,\n+    }\n+\n+    impl Drop for ImplDropNotAllCopy {\n+        fn drop(&mut self) {\n+            self.close()\n+        }\n+    }\n+\n+    impl ImplDropNotAllCopy {\n+        fn new(name: &str) -> Self {\n+            let mut f = ImplDropNotAllCopy::default();\n+            f.name = name.to_owned();\n+            f\n+        }\n+        fn close(&self) {}\n+    }\n+\n+    // lint: type implements `Drop` and all fields are `Copy`\n+    #[derive(Clone, Default)]\n+    pub struct ImplDropAllCopy {\n+        name: usize,\n+        delay_data_sync: bool,\n+    }\n+\n+    impl Drop for ImplDropAllCopy {\n+        fn drop(&mut self) {\n+            self.close()\n+        }\n+    }\n+\n+    impl ImplDropAllCopy {\n+        fn new(name: &str) -> Self {\n+            let mut f = ImplDropAllCopy::default();\n+            f.name = name.len();\n+            f\n+        }\n+        fn close(&self) {}\n+    }\n+\n+    // lint: type does not implement `Drop` though all fields are `Copy`\n+    #[derive(Clone, Default)]\n+    pub struct NoDropAllCopy {\n+        name: usize,\n+        delay_data_sync: bool,\n+    }\n+\n+    impl NoDropAllCopy {\n+        fn new(name: &str) -> Self {\n+            let mut f = NoDropAllCopy::default();\n+            f.name = name.len();\n+            f\n+        }\n+    }\n+}"}, {"sha": "3ce4b91a54869d13c4b72ce7235cc51981a6169e", "filename": "src/tools/clippy/tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffield_reassign_with_default.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -107,5 +107,29 @@ note: consider initializing the variable with `WrapperMulti::<i32, i64> { i: 42,\n LL |     let mut a: WrapperMulti<i32, i64> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:229:13\n+   |\n+LL |             f.name = name.len();\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `issue6312::ImplDropAllCopy { name: name.len(), ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:228:13\n+   |\n+LL |             let mut f = ImplDropAllCopy::default();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:245:13\n+   |\n+LL |             f.name = name.len();\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `issue6312::NoDropAllCopy { name: name.len(), ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:244:13\n+   |\n+LL |             let mut f = NoDropAllCopy::default();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "46704683926b2c8bae4ea25c538af783f1d9cc6d", "filename": "src/tools/clippy/tests/ui/fn_to_numeric_cast_any.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,76 @@\n+#![warn(clippy::fn_to_numeric_cast_any)]\n+#![allow(clippy::fn_to_numeric_cast, clippy::fn_to_numeric_cast_with_truncation)]\n+\n+fn foo() -> u8 {\n+    0\n+}\n+\n+fn generic_foo<T>(x: T) -> T {\n+    x\n+}\n+\n+trait Trait {\n+    fn static_method() -> u32 {\n+        2\n+    }\n+}\n+\n+struct Struct;\n+\n+impl Trait for Struct {}\n+\n+fn fn_pointer_to_integer() {\n+    let _ = foo as i8;\n+    let _ = foo as i16;\n+    let _ = foo as i32;\n+    let _ = foo as i64;\n+    let _ = foo as i128;\n+    let _ = foo as isize;\n+\n+    let _ = foo as u8;\n+    let _ = foo as u16;\n+    let _ = foo as u32;\n+    let _ = foo as u64;\n+    let _ = foo as u128;\n+    let _ = foo as usize;\n+}\n+\n+fn static_method_to_integer() {\n+    let _ = Struct::static_method as usize;\n+}\n+\n+fn fn_with_fn_arg(f: fn(i32) -> u32) -> usize {\n+    f as usize\n+}\n+\n+fn fn_with_generic_static_trait_method<T: Trait>() -> usize {\n+    T::static_method as usize\n+}\n+\n+fn closure_to_fn_to_integer() {\n+    let clos = |x| x * 2_u32;\n+\n+    let _ = (clos as fn(u32) -> u32) as usize;\n+}\n+\n+fn fn_to_raw_ptr() {\n+    let _ = foo as *const ();\n+}\n+\n+fn cast_fn_to_self() {\n+    // Casting to the same function pointer type should be permitted.\n+    let _ = foo as fn() -> u8;\n+}\n+\n+fn cast_generic_to_concrete() {\n+    // Casting to a more concrete function pointer type should be permitted.\n+    let _ = generic_foo as fn(usize) -> usize;\n+}\n+\n+fn cast_closure_to_fn() {\n+    // Casting a closure to a function pointer should be permitted.\n+    let id = |x| x;\n+    let _ = id as fn(usize) -> usize;\n+}\n+\n+fn main() {}"}, {"sha": "a6c4a77672f86116229fec67ec2d58c97b36689a", "filename": "src/tools/clippy/tests/ui/fn_to_numeric_cast_any.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffn_to_numeric_cast_any.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,106 @@\n+error: casting function pointer `foo` to `i8`\n+  --> $DIR/fn_to_numeric_cast_any.rs:23:13\n+   |\n+LL |     let _ = foo as i8;\n+   |             ^^^^^^^^^ help: did you mean to invoke the function?: `foo() as i8`\n+   |\n+   = note: `-D clippy::fn-to-numeric-cast-any` implied by `-D warnings`\n+\n+error: casting function pointer `foo` to `i16`\n+  --> $DIR/fn_to_numeric_cast_any.rs:24:13\n+   |\n+LL |     let _ = foo as i16;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as i16`\n+\n+error: casting function pointer `foo` to `i32`\n+  --> $DIR/fn_to_numeric_cast_any.rs:25:13\n+   |\n+LL |     let _ = foo as i32;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as i32`\n+\n+error: casting function pointer `foo` to `i64`\n+  --> $DIR/fn_to_numeric_cast_any.rs:26:13\n+   |\n+LL |     let _ = foo as i64;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as i64`\n+\n+error: casting function pointer `foo` to `i128`\n+  --> $DIR/fn_to_numeric_cast_any.rs:27:13\n+   |\n+LL |     let _ = foo as i128;\n+   |             ^^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as i128`\n+\n+error: casting function pointer `foo` to `isize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:28:13\n+   |\n+LL |     let _ = foo as isize;\n+   |             ^^^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as isize`\n+\n+error: casting function pointer `foo` to `u8`\n+  --> $DIR/fn_to_numeric_cast_any.rs:30:13\n+   |\n+LL |     let _ = foo as u8;\n+   |             ^^^^^^^^^ help: did you mean to invoke the function?: `foo() as u8`\n+\n+error: casting function pointer `foo` to `u16`\n+  --> $DIR/fn_to_numeric_cast_any.rs:31:13\n+   |\n+LL |     let _ = foo as u16;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as u16`\n+\n+error: casting function pointer `foo` to `u32`\n+  --> $DIR/fn_to_numeric_cast_any.rs:32:13\n+   |\n+LL |     let _ = foo as u32;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as u32`\n+\n+error: casting function pointer `foo` to `u64`\n+  --> $DIR/fn_to_numeric_cast_any.rs:33:13\n+   |\n+LL |     let _ = foo as u64;\n+   |             ^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as u64`\n+\n+error: casting function pointer `foo` to `u128`\n+  --> $DIR/fn_to_numeric_cast_any.rs:34:13\n+   |\n+LL |     let _ = foo as u128;\n+   |             ^^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as u128`\n+\n+error: casting function pointer `foo` to `usize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:35:13\n+   |\n+LL |     let _ = foo as usize;\n+   |             ^^^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as usize`\n+\n+error: casting function pointer `Struct::static_method` to `usize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:39:13\n+   |\n+LL |     let _ = Struct::static_method as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean to invoke the function?: `Struct::static_method() as usize`\n+\n+error: casting function pointer `f` to `usize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:43:5\n+   |\n+LL |     f as usize\n+   |     ^^^^^^^^^^ help: did you mean to invoke the function?: `f() as usize`\n+\n+error: casting function pointer `T::static_method` to `usize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:47:5\n+   |\n+LL |     T::static_method as usize\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean to invoke the function?: `T::static_method() as usize`\n+\n+error: casting function pointer `(clos as fn(u32) -> u32)` to `usize`\n+  --> $DIR/fn_to_numeric_cast_any.rs:53:13\n+   |\n+LL |     let _ = (clos as fn(u32) -> u32) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean to invoke the function?: `(clos as fn(u32) -> u32)() as usize`\n+\n+error: casting function pointer `foo` to `*const ()`\n+  --> $DIR/fn_to_numeric_cast_any.rs:57:13\n+   |\n+LL |     let _ = foo as *const ();\n+   |             ^^^^^^^^^^^^^^^^ help: did you mean to invoke the function?: `foo() as *const ()`\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "73fc750511c78684cdd8650d03e6ce1dc40582b1", "filename": "src/tools/clippy/tests/ui/format.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::print_literal, clippy::redundant_clone)]\n+#![allow(clippy::print_literal, clippy::redundant_clone, clippy::to_string_in_format_args)]\n #![warn(clippy::useless_format)]\n \n struct Foo(pub String);"}, {"sha": "2f4595650cbf3c8d3cdd716e3ea32a0e24113b58", "filename": "src/tools/clippy/tests/ui/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::print_literal, clippy::redundant_clone)]\n+#![allow(clippy::print_literal, clippy::redundant_clone, clippy::to_string_in_format_args)]\n #![warn(clippy::useless_format)]\n \n struct Foo(pub String);"}, {"sha": "8376566c4d62d57fcfa1c51198500c4ac517e904", "filename": "src/tools/clippy/tests/ui/format_args.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unreachable_code)]\n+#![allow(unused_macros)]\n+#![allow(unused_variables)]\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+struct Somewhere;\n+\n+impl ToString for Somewhere {\n+    fn to_string(&self) -> String {\n+        String::from(\"somewhere\")\n+    }\n+}\n+\n+struct X(u32);\n+\n+impl Deref for X {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+struct Y<'a>(&'a X);\n+\n+impl<'a> Deref for Y<'a> {\n+    type Target = &'a X;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+struct Z(u32);\n+\n+impl Deref for Z {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+impl std::fmt::Display for Z {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Z\")\n+    }\n+}\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: something failed at {}\", Location::caller().to_string());\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        Location::caller().to_string()\n+    };\n+}\n+\n+fn main() {\n+    let x = &X(1);\n+    let x_ref = &x;\n+\n+    let _ = format!(\"error: something failed at {}\", Location::caller());\n+    let _ = write!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller()\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller()\n+    );\n+    print!(\"error: something failed at {}\", Location::caller());\n+    println!(\"error: something failed at {}\", Location::caller());\n+    eprint!(\"error: something failed at {}\", Location::caller());\n+    eprintln!(\"error: something failed at {}\", Location::caller());\n+    let _ = format_args!(\"error: something failed at {}\", Location::caller());\n+    assert!(true, \"error: something failed at {}\", Location::caller());\n+    assert_eq!(0, 0, \"error: something failed at {}\", Location::caller());\n+    assert_ne!(0, 0, \"error: something failed at {}\", Location::caller());\n+    panic!(\"error: something failed at {}\", Location::caller());\n+    println!(\"{}\", *X(1));\n+    println!(\"{}\", ***Y(&X(1)));\n+    println!(\"{}\", Z(1));\n+    println!(\"{}\", **x);\n+    println!(\"{}\", ***x_ref);\n+\n+    println!(\"error: something failed at {}\", Somewhere.to_string());\n+    println!(\"{} and again {0}\", x.to_string());\n+    my_macro!();\n+    println!(\"error: something failed at {}\", my_other_macro!());\n+}"}, {"sha": "164cc07066dc3b892022b616b34f4130083c12ce", "filename": "src/tools/clippy/tests/ui/format_args.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unreachable_code)]\n+#![allow(unused_macros)]\n+#![allow(unused_variables)]\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+struct Somewhere;\n+\n+impl ToString for Somewhere {\n+    fn to_string(&self) -> String {\n+        String::from(\"somewhere\")\n+    }\n+}\n+\n+struct X(u32);\n+\n+impl Deref for X {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+struct Y<'a>(&'a X);\n+\n+impl<'a> Deref for Y<'a> {\n+    type Target = &'a X;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+struct Z(u32);\n+\n+impl Deref for Z {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &u32 {\n+        &self.0\n+    }\n+}\n+\n+impl std::fmt::Display for Z {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Z\")\n+    }\n+}\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: something failed at {}\", Location::caller().to_string());\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        Location::caller().to_string()\n+    };\n+}\n+\n+fn main() {\n+    let x = &X(1);\n+    let x_ref = &x;\n+\n+    let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n+    let _ = write!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller().to_string()\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: something failed at {}\",\n+        Location::caller().to_string()\n+    );\n+    print!(\"error: something failed at {}\", Location::caller().to_string());\n+    println!(\"error: something failed at {}\", Location::caller().to_string());\n+    eprint!(\"error: something failed at {}\", Location::caller().to_string());\n+    eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n+    let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n+    assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n+    assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+    assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+    panic!(\"error: something failed at {}\", Location::caller().to_string());\n+    println!(\"{}\", X(1).to_string());\n+    println!(\"{}\", Y(&X(1)).to_string());\n+    println!(\"{}\", Z(1).to_string());\n+    println!(\"{}\", x.to_string());\n+    println!(\"{}\", x_ref.to_string());\n+\n+    println!(\"error: something failed at {}\", Somewhere.to_string());\n+    println!(\"{} and again {0}\", x.to_string());\n+    my_macro!();\n+    println!(\"error: something failed at {}\", my_other_macro!());\n+}"}, {"sha": "9cfc97edeafb8215fabae9014bc1b543840a650c", "filename": "src/tools/clippy/tests/ui/format_args.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,106 @@\n+error: `to_string` applied to a type that implements `Display` in `format!` args\n+  --> $DIR/format_args.rs:75:72\n+   |\n+LL |     let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                        ^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::to-string-in-format-args` implied by `-D warnings`\n+\n+error: `to_string` applied to a type that implements `Display` in `write!` args\n+  --> $DIR/format_args.rs:79:27\n+   |\n+LL |         Location::caller().to_string()\n+   |                           ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `writeln!` args\n+  --> $DIR/format_args.rs:84:27\n+   |\n+LL |         Location::caller().to_string()\n+   |                           ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `print!` args\n+  --> $DIR/format_args.rs:86:63\n+   |\n+LL |     print!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                               ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:87:65\n+   |\n+LL |     println!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                 ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `eprint!` args\n+  --> $DIR/format_args.rs:88:64\n+   |\n+LL |     eprint!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `eprintln!` args\n+  --> $DIR/format_args.rs:89:66\n+   |\n+LL |     eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                  ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `format_args!` args\n+  --> $DIR/format_args.rs:90:77\n+   |\n+LL |     let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                             ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert!` args\n+  --> $DIR/format_args.rs:91:70\n+   |\n+LL |     assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                      ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert_eq!` args\n+  --> $DIR/format_args.rs:92:73\n+   |\n+LL |     assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                         ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `assert_ne!` args\n+  --> $DIR/format_args.rs:93:73\n+   |\n+LL |     assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n+   |                                                                         ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `panic!` args\n+  --> $DIR/format_args.rs:94:63\n+   |\n+LL |     panic!(\"error: something failed at {}\", Location::caller().to_string());\n+   |                                                               ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:95:20\n+   |\n+LL |     println!(\"{}\", X(1).to_string());\n+   |                    ^^^^^^^^^^^^^^^^ help: use this: `*X(1)`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:96:20\n+   |\n+LL |     println!(\"{}\", Y(&X(1)).to_string());\n+   |                    ^^^^^^^^^^^^^^^^^^^^ help: use this: `***Y(&X(1))`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:97:24\n+   |\n+LL |     println!(\"{}\", Z(1).to_string());\n+   |                        ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:98:20\n+   |\n+LL |     println!(\"{}\", x.to_string());\n+   |                    ^^^^^^^^^^^^^ help: use this: `**x`\n+\n+error: `to_string` applied to a type that implements `Display` in `println!` args\n+  --> $DIR/format_args.rs:99:20\n+   |\n+LL |     println!(\"{}\", x_ref.to_string());\n+   |                    ^^^^^^^^^^^^^^^^^ help: use this: `***x_ref`\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "a8c06c2bde6645e418bd8d3f76599e24be4d9c2e", "filename": "src/tools/clippy/tests/ui/format_args_unfixable.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,60 @@\n+#![allow(clippy::assertions_on_constants)]\n+#![allow(clippy::eq_op)]\n+#![warn(clippy::format_in_format_args)]\n+#![warn(clippy::to_string_in_format_args)]\n+\n+use std::io::{stdout, Error, ErrorKind, Write};\n+use std::ops::Deref;\n+use std::panic::Location;\n+\n+macro_rules! my_macro {\n+    () => {\n+        // here be dragons, do not enter (or lint)\n+        println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    };\n+}\n+\n+macro_rules! my_other_macro {\n+    () => {\n+        format!(\"something failed at {}\", Location::caller())\n+    };\n+}\n+\n+fn main() {\n+    let error = Error::new(ErrorKind::Other, \"bad thing\");\n+    let x = 'x';\n+\n+    println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n+    println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n+    let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    let _ = write!(\n+        stdout(),\n+        \"error: {}\",\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+    let _ = writeln!(\n+        stdout(),\n+        \"error: {}\",\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+    print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+\n+    println!(\"error: {}\", format_args!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {:>70}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"error: {} {0}\", format!(\"something failed at {}\", Location::caller()));\n+    println!(\"{} and again {0}\", format!(\"hi {}\", x));\n+    my_macro!();\n+    println!(\"error: {}\", my_other_macro!());\n+}"}, {"sha": "4476218ad58e91a3d0a4e0b5c7a23b5d1c0e43b4", "filename": "src/tools/clippy/tests/ui/format_args_unfixable.stderr", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformat_args_unfixable.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,175 @@\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:27:5\n+   |\n+LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::format-in-format-args` implied by `-D warnings`\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:28:5\n+   |\n+LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:29:5\n+   |\n+LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:30:5\n+   |\n+LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:31:5\n+   |\n+LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:32:5\n+   |\n+LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `println!` args\n+  --> $DIR/format_args_unfixable.rs:33:5\n+   |\n+LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `println!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `format!` args\n+  --> $DIR/format_args_unfixable.rs:34:13\n+   |\n+LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `format!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `write!` args\n+  --> $DIR/format_args_unfixable.rs:35:13\n+   |\n+LL |       let _ = write!(\n+   |  _____________^\n+LL | |         stdout(),\n+LL | |         \"error: {}\",\n+LL | |         format!(\"something failed at {}\", Location::caller())\n+LL | |     );\n+   | |_____^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `write!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `writeln!` args\n+  --> $DIR/format_args_unfixable.rs:40:13\n+   |\n+LL |       let _ = writeln!(\n+   |  _____________^\n+LL | |         stdout(),\n+LL | |         \"error: {}\",\n+LL | |         format!(\"something failed at {}\", Location::caller())\n+LL | |     );\n+   | |_____^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `writeln!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `print!` args\n+  --> $DIR/format_args_unfixable.rs:45:5\n+   |\n+LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `print!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `eprint!` args\n+  --> $DIR/format_args_unfixable.rs:46:5\n+   |\n+LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `eprint!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `eprintln!` args\n+  --> $DIR/format_args_unfixable.rs:47:5\n+   |\n+LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `eprintln!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `format_args!` args\n+  --> $DIR/format_args_unfixable.rs:48:13\n+   |\n+LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `format_args!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert!` args\n+  --> $DIR/format_args_unfixable.rs:49:5\n+   |\n+LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert_eq!` args\n+  --> $DIR/format_args_unfixable.rs:50:5\n+   |\n+LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert_eq!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `assert_ne!` args\n+  --> $DIR/format_args_unfixable.rs:51:5\n+   |\n+LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `assert_ne!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: `format!` in `panic!` args\n+  --> $DIR/format_args_unfixable.rs:52:5\n+   |\n+LL |     panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: combine the `format!(..)` arguments with the outer `panic!(..)` call\n+   = help: or consider changing `format!` to `format_args!`\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "e6f57e9267eac93091e423180bbaef8f9d97315b", "filename": "src/tools/clippy/tests/ui/implicit_saturating_sub.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -157,4 +157,12 @@ fn main() {\n     if i_64 != 0 {\n         i_64 -= 1;\n     }\n+\n+    // issue #7831\n+    // No Lint\n+    if u_32 > 0 {\n+        u_32 -= 1;\n+    } else {\n+        println!(\"side effect\");\n+    }\n }"}, {"sha": "8bb28d149c62895c210a5e4ba68082daf6ff9813", "filename": "src/tools/clippy/tests/ui/implicit_saturating_sub.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_saturating_sub.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -203,4 +203,12 @@ fn main() {\n     if i_64 != 0 {\n         i_64 -= 1;\n     }\n+\n+    // issue #7831\n+    // No Lint\n+    if u_32 > 0 {\n+        u_32 -= 1;\n+    } else {\n+        println!(\"side effect\");\n+    }\n }"}, {"sha": "d7cedf9f9f1596dfabb659099e2922281b410f93", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.stderr", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -110,23 +110,6 @@ LL | |             _ => false,\n LL | |         };\n    | |_________^ help: try this: `matches!(&val, &Some(ref _a))`\n \n-error: you don't need to add `&` to both the expression and the patterns\n-  --> $DIR/match_expr_like_matches_macro.rs:166:20\n-   |\n-LL |           let _res = match &val {\n-   |  ____________________^\n-LL | |             &Some(ref _a) => true,\n-LL | |             _ => false,\n-LL | |         };\n-   | |_________^\n-   |\n-   = note: `-D clippy::match-ref-pats` implied by `-D warnings`\n-help: try\n-   |\n-LL ~         let _res = match val {\n-LL ~             Some(ref _a) => true,\n-   |\n-\n error: match expression looks like `matches!` macro\n   --> $DIR/match_expr_like_matches_macro.rs:178:20\n    |\n@@ -137,21 +120,5 @@ LL | |             _ => false,\n LL | |         };\n    | |_________^ help: try this: `matches!(&val, &Some(ref _a))`\n \n-error: you don't need to add `&` to both the expression and the patterns\n-  --> $DIR/match_expr_like_matches_macro.rs:178:20\n-   |\n-LL |           let _res = match &val {\n-   |  ____________________^\n-LL | |             &Some(ref _a) => true,\n-LL | |             _ => false,\n-LL | |         };\n-   | |_________^\n-   |\n-help: try\n-   |\n-LL ~         let _res = match val {\n-LL ~             Some(ref _a) => true,\n-   |\n-\n-error: aborting due to 14 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "ff91c4498ec62afd43c12497579a6a66925fd42a", "filename": "src/tools/clippy/tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -10,98 +10,95 @@ fn overlapping() {\n     const FOO: u64 = 2;\n \n     match 42 {\n-        0..=10 => println!(\"0 ... 10\"),\n-        0..=11 => println!(\"0 ... 11\"),\n+        0..=10 => println!(\"0..=10\"),\n+        0..=11 => println!(\"0..=11\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..=5 => println!(\"0 ... 5\"),\n-        6..=7 => println!(\"6 ... 7\"),\n-        FOO..=11 => println!(\"0 ... 11\"),\n+        0..=5 => println!(\"0..=5\"),\n+        6..=7 => println!(\"6..=7\"),\n+        FOO..=11 => println!(\"FOO..=11\"),\n         _ => (),\n     }\n \n     match 42 {\n         2 => println!(\"2\"),\n-        0..=5 => println!(\"0 ... 5\"),\n+        0..=5 => println!(\"0..=5\"),\n         _ => (),\n     }\n \n     match 42 {\n         2 => println!(\"2\"),\n-        0..=2 => println!(\"0 ... 2\"),\n+        0..=2 => println!(\"0..=2\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..=10 => println!(\"0 ... 10\"),\n-        11..=50 => println!(\"11 ... 50\"),\n+        0..=10 => println!(\"0..=10\"),\n+        11..=50 => println!(\"11..=50\"),\n         _ => (),\n     }\n \n     match 42 {\n         2 => println!(\"2\"),\n-        0..2 => println!(\"0 .. 2\"),\n+        0..2 => println!(\"0..2\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..10 => println!(\"0 .. 10\"),\n-        10..50 => println!(\"10 .. 50\"),\n+        0..10 => println!(\"0..10\"),\n+        10..50 => println!(\"10..50\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..11 => println!(\"0 .. 11\"),\n-        0..=11 => println!(\"0 ... 11\"),\n+        0..11 => println!(\"0..11\"),\n+        0..=11 => println!(\"0..=11\"),\n         _ => (),\n     }\n \n     match 42 {\n-        5..7 => println!(\"5 .. 7\"),\n-        0..10 => println!(\"0 .. 10\"),\n+        5..7 => println!(\"5..7\"),\n+        0..10 => println!(\"0..10\"),\n         _ => (),\n     }\n \n     match 42 {\n-        5..10 => println!(\"5 .. 10\"),\n-        0..=10 => println!(\"0 ... 10\"),\n+        5..10 => println!(\"5..10\"),\n+        0..=10 => println!(\"0..=10\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..14 => println!(\"0 .. 14\"),\n-        5..10 => println!(\"5 .. 10\"),\n+        0..14 => println!(\"0..14\"),\n+        5..10 => println!(\"5..10\"),\n         _ => (),\n     }\n \n     match 42 {\n-        5..14 => println!(\"5 .. 14\"),\n-        0..=10 => println!(\"0 ... 10\"),\n+        5..14 => println!(\"5..14\"),\n+        0..=10 => println!(\"0..=10\"),\n         _ => (),\n     }\n \n     match 42 {\n-        0..7 => println!(\"0 .. 7\"),\n-        0..=10 => println!(\"0 ... 10\"),\n+        0..7 => println!(\"0..7\"),\n+        0..=10 => println!(\"0..=10\"),\n         _ => (),\n     }\n \n-    /*\n-    // FIXME(JohnTitor): uncomment this once rustfmt knows half-open patterns\n     match 42 {\n-        0.. => println!(\"0 .. 42\"),\n-        3.. => println!(\"3 .. 42\"),\n+        3.. => println!(\"3..\"),\n+        0.. => println!(\"0..\"),\n         _ => (),\n     }\n \n     match 42 {\n-        ..=23 => println!(\"0 ... 23\"),\n-        ..26 => println!(\"0 .. 26\"),\n+        ..=23 => println!(\"..=23\"),\n+        ..26 => println!(\"..26\"),\n         _ => (),\n     }\n-    */\n \n     if let None = Some(42) {\n         // nothing"}, {"sha": "c2b3f173c2b80bc7102261d8db7d7862e643d875", "filename": "src/tools/clippy/tests/ui/match_overlapping_arm.stderr", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_overlapping_arm.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,63 +1,75 @@\n error: some ranges overlap\n   --> $DIR/match_overlapping_arm.rs:13:9\n    |\n-LL |         0..=10 => println!(\"0 ... 10\"),\n+LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-overlapping-arm` implied by `-D warnings`\n note: overlaps with this\n   --> $DIR/match_overlapping_arm.rs:14:9\n    |\n-LL |         0..=11 => println!(\"0 ... 11\"),\n+LL |         0..=11 => println!(\"0..=11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n   --> $DIR/match_overlapping_arm.rs:19:9\n    |\n-LL |         0..=5 => println!(\"0 ... 5\"),\n+LL |         0..=5 => println!(\"0..=5\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n   --> $DIR/match_overlapping_arm.rs:21:9\n    |\n-LL |         FOO..=11 => println!(\"0 ... 11\"),\n+LL |         FOO..=11 => println!(\"FOO..=11\"),\n    |         ^^^^^^^^\n \n error: some ranges overlap\n   --> $DIR/match_overlapping_arm.rs:56:9\n    |\n-LL |         0..11 => println!(\"0 .. 11\"),\n+LL |         0..11 => println!(\"0..11\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n   --> $DIR/match_overlapping_arm.rs:57:9\n    |\n-LL |         0..=11 => println!(\"0 ... 11\"),\n+LL |         0..=11 => println!(\"0..=11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n   --> $DIR/match_overlapping_arm.rs:81:9\n    |\n-LL |         0..=10 => println!(\"0 ... 10\"),\n+LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n   --> $DIR/match_overlapping_arm.rs:80:9\n    |\n-LL |         5..14 => println!(\"5 .. 14\"),\n+LL |         5..14 => println!(\"5..14\"),\n    |         ^^^^^\n \n error: some ranges overlap\n   --> $DIR/match_overlapping_arm.rs:86:9\n    |\n-LL |         0..7 => println!(\"0 .. 7\"),\n+LL |         0..7 => println!(\"0..7\"),\n    |         ^^^^\n    |\n note: overlaps with this\n   --> $DIR/match_overlapping_arm.rs:87:9\n    |\n-LL |         0..=10 => println!(\"0 ... 10\"),\n+LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: some ranges overlap\n+  --> $DIR/match_overlapping_arm.rs:98:9\n+   |\n+LL |         ..=23 => println!(\"..=23\"),\n+   |         ^^^^^\n+   |\n+note: overlaps with this\n+  --> $DIR/match_overlapping_arm.rs:99:9\n+   |\n+LL |         ..26 => println!(\"..26\"),\n+   |         ^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "50246486bb6fc9371206f17adfe284b5e722a566", "filename": "src/tools/clippy/tests/ui/match_ref_pats.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -72,4 +72,46 @@ mod ice_3719 {\n     }\n }\n \n+mod issue_7740 {\n+    macro_rules! foobar_variant(\n+        ($idx:expr) => (FooBar::get($idx).unwrap())\n+    );\n+\n+    enum FooBar {\n+        Foo,\n+        Bar,\n+        FooBar,\n+        BarFoo,\n+    }\n+\n+    impl FooBar {\n+        fn get(idx: u8) -> Option<&'static Self> {\n+            match idx {\n+                0 => Some(&FooBar::Foo),\n+                1 => Some(&FooBar::Bar),\n+                2 => Some(&FooBar::FooBar),\n+                3 => Some(&FooBar::BarFoo),\n+                _ => None,\n+            }\n+        }\n+    }\n+\n+    fn issue_7740() {\n+        // Issue #7740\n+        match foobar_variant!(0) {\n+            &FooBar::Foo => println!(\"Foo\"),\n+            &FooBar::Bar => println!(\"Bar\"),\n+            &FooBar::FooBar => println!(\"FooBar\"),\n+            _ => println!(\"Wild\"),\n+        }\n+\n+        // This shouldn't trigger\n+        if let &FooBar::BarFoo = foobar_variant!(3) {\n+            println!(\"BarFoo\");\n+        } else {\n+            println!(\"Wild\");\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "901820077e20e974b651c9a68ef26df9b364cf59", "filename": "src/tools/clippy/tests/ui/match_ref_pats.stderr", "status": "modified", "additions": 10, "deletions": 47, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_ref_pats.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -15,21 +15,6 @@ LL ~             Some(v) => println!(\"{:?}\", v),\n LL ~             None => println!(\"none\"),\n    |\n \n-error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:18:5\n-   |\n-LL | /     match tup {\n-LL | |         &(v, 1) => println!(\"{}\", v),\n-LL | |         _ => println!(\"none\"),\n-LL | |     }\n-   | |_____^\n-   |\n-help: instead of prefixing all patterns with `&`, you can dereference the expression\n-   |\n-LL ~     match *tup {\n-LL ~         (v, 1) => println!(\"{}\", v),\n-   |\n-\n error: you don't need to add `&` to both the expression and the patterns\n   --> $DIR/match_ref_pats.rs:24:5\n    |\n@@ -54,52 +39,30 @@ LL |     if let &None = a {\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n-error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:36:5\n-   |\n-LL | /     if let &None = a {\n-LL | |         println!(\"none\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: instead of prefixing all patterns with `&`, you can dereference the expression\n-   |\n-LL |     if let None = *a {\n-   |            ~~~~   ~~\n-\n error: redundant pattern matching, consider using `is_none()`\n   --> $DIR/match_ref_pats.rs:41:12\n    |\n LL |     if let &None = &b {\n    |     -------^^^^^----- help: try this: `if b.is_none()`\n \n-error: you don't need to add `&` to both the expression and the patterns\n-  --> $DIR/match_ref_pats.rs:41:5\n-   |\n-LL | /     if let &None = &b {\n-LL | |         println!(\"none\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try\n-   |\n-LL |     if let None = b {\n-   |            ~~~~   ~\n-\n error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:68:9\n+  --> $DIR/match_ref_pats.rs:101:9\n    |\n-LL | /         match foo_variant!(0) {\n-LL | |             &Foo::A => println!(\"A\"),\n+LL | /         match foobar_variant!(0) {\n+LL | |             &FooBar::Foo => println!(\"Foo\"),\n+LL | |             &FooBar::Bar => println!(\"Bar\"),\n+LL | |             &FooBar::FooBar => println!(\"FooBar\"),\n LL | |             _ => println!(\"Wild\"),\n LL | |         }\n    | |_________^\n    |\n help: instead of prefixing all patterns with `&`, you can dereference the expression\n    |\n-LL ~         match *foo_variant!(0) {\n-LL ~             Foo::A => println!(\"A\"),\n+LL ~         match *foobar_variant!(0) {\n+LL ~             FooBar::Foo => println!(\"Foo\"),\n+LL ~             FooBar::Bar => println!(\"Bar\"),\n+LL ~             FooBar::FooBar => println!(\"FooBar\"),\n    |\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "208a4bba3d23c40d5cf2cbe4a2f650c18ba584b5", "filename": "src/tools/clippy/tests/ui/match_str_case_mismatch.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,98 @@\n+#![warn(clippy::match_str_case_mismatch)]\n+\n+// Valid\n+\n+fn as_str_match() {\n+    let var = \"BAR\";\n+\n+    match var.to_ascii_lowercase().as_str() {\n+        \"foo\" => {},\n+        \"bar\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn addrof_unary_match() {\n+    let var = \"BAR\";\n+\n+    match &*var.to_ascii_lowercase() {\n+        \"foo\" => {},\n+        \"bar\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn alternating_chain() {\n+    let var = \"BAR\";\n+\n+    match &*var\n+        .to_ascii_lowercase()\n+        .to_uppercase()\n+        .to_lowercase()\n+        .to_ascii_uppercase()\n+    {\n+        \"FOO\" => {},\n+        \"BAR\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn unrelated_method() {\n+    struct Item {\n+        a: String,\n+    }\n+\n+    impl Item {\n+        #[allow(clippy::wrong_self_convention)]\n+        fn to_lowercase(self) -> String {\n+            self.a\n+        }\n+    }\n+\n+    let item = Item { a: String::from(\"BAR\") };\n+\n+    match &*item.to_lowercase() {\n+        \"FOO\" => {},\n+        \"BAR\" => {},\n+        _ => {},\n+    }\n+}\n+\n+// Invalid\n+\n+fn as_str_match_mismatch() {\n+    let var = \"BAR\";\n+\n+    match var.to_ascii_lowercase().as_str() {\n+        \"foo\" => {},\n+        \"Bar\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn addrof_unary_match_mismatch() {\n+    let var = \"BAR\";\n+\n+    match &*var.to_ascii_lowercase() {\n+        \"foo\" => {},\n+        \"Bar\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn alternating_chain_mismatch() {\n+    let var = \"BAR\";\n+\n+    match &*var\n+        .to_ascii_lowercase()\n+        .to_uppercase()\n+        .to_lowercase()\n+        .to_ascii_uppercase()\n+    {\n+        \"FOO\" => {},\n+        \"bAR\" => {},\n+        _ => {},\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fa023477a9c334d20c7a934e93091b270bd41bf0", "filename": "src/tools/clippy/tests/ui/match_str_case_mismatch.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_str_case_mismatch.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,36 @@\n+error: this `match` arm has a differing case than its expression\n+  --> $DIR/match_str_case_mismatch.rs:68:9\n+   |\n+LL |         \"Bar\" => {},\n+   |         ^^^^^\n+   |\n+   = note: `-D clippy::match-str-case-mismatch` implied by `-D warnings`\n+help: consider changing the case of this arm to respect `to_ascii_lowercase`\n+   |\n+LL |         \"bar\" => {},\n+   |         ~~~~~\n+\n+error: this `match` arm has a differing case than its expression\n+  --> $DIR/match_str_case_mismatch.rs:78:9\n+   |\n+LL |         \"Bar\" => {},\n+   |         ^^^^^\n+   |\n+help: consider changing the case of this arm to respect `to_ascii_lowercase`\n+   |\n+LL |         \"bar\" => {},\n+   |         ~~~~~\n+\n+error: this `match` arm has a differing case than its expression\n+  --> $DIR/match_str_case_mismatch.rs:93:9\n+   |\n+LL |         \"bAR\" => {},\n+   |         ^^^^^\n+   |\n+help: consider changing the case of this arm to respect `to_ascii_uppercase`\n+   |\n+LL |         \"BAR\" => {},\n+   |         ~~~~~\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "be854d94183329d547df961f1690f32d10d01139", "filename": "src/tools/clippy/tests/ui/mut_mut.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,6 +1,11 @@\n+// aux-build:macro_rules.rs\n+\n #![allow(unused, clippy::no_effect, clippy::unnecessary_operation)]\n #![warn(clippy::mut_mut)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n fn fun(x: &mut &mut u32) -> bool {\n     **x > 0\n }\n@@ -47,3 +52,8 @@ fn issue939() {\n         println!(\":{}\", arg);\n     }\n }\n+\n+fn issue6922() {\n+    // do not lint from an external macro\n+    mut_mut!();\n+}"}, {"sha": "6820a85aa54337f2cad40936ed7d0f6bad95358b", "filename": "src/tools/clippy/tests/ui/mut_mut.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmut_mut.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,19 +1,19 @@\n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:4:11\n+  --> $DIR/mut_mut.rs:9:11\n    |\n LL | fn fun(x: &mut &mut u32) -> bool {\n    |           ^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mut-mut` implied by `-D warnings`\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:20:17\n+  --> $DIR/mut_mut.rs:25:17\n    |\n LL |     let mut x = &mut &mut 1u32;\n    |                 ^^^^^^^^^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:14:9\n+  --> $DIR/mut_mut.rs:19:9\n    |\n LL |         &mut $p\n    |         ^^^^^^^\n@@ -24,37 +24,37 @@ LL |     let mut z = mut_ptr!(&mut 3u32);\n    = note: this error originates in the macro `mut_ptr` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: this expression mutably borrows a mutable reference. Consider reborrowing\n-  --> $DIR/mut_mut.rs:22:21\n+  --> $DIR/mut_mut.rs:27:21\n    |\n LL |         let mut y = &mut x;\n    |                     ^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:26:32\n+  --> $DIR/mut_mut.rs:31:32\n    |\n LL |         let y: &mut &mut u32 = &mut &mut 2;\n    |                                ^^^^^^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:26:16\n+  --> $DIR/mut_mut.rs:31:16\n    |\n LL |         let y: &mut &mut u32 = &mut &mut 2;\n    |                ^^^^^^^^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:31:37\n+  --> $DIR/mut_mut.rs:36:37\n    |\n LL |         let y: &mut &mut &mut u32 = &mut &mut &mut 2;\n    |                                     ^^^^^^^^^^^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:31:16\n+  --> $DIR/mut_mut.rs:36:16\n    |\n LL |         let y: &mut &mut &mut u32 = &mut &mut &mut 2;\n    |                ^^^^^^^^^^^^^^^^^^\n \n error: generally you want to avoid `&mut &mut _` if possible\n-  --> $DIR/mut_mut.rs:31:21\n+  --> $DIR/mut_mut.rs:36:21\n    |\n LL |         let y: &mut &mut &mut u32 = &mut &mut &mut 2;\n    |                     ^^^^^^^^^^^^^"}, {"sha": "7bcc4cad0d363a78153e36456b0e128eaeef8e45", "filename": "src/tools/clippy/tests/ui/no_effect.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,5 +1,5 @@\n #![feature(box_syntax)]\n-#![warn(clippy::no_effect)]\n+#![warn(clippy::no_effect_underscore_binding)]\n #![allow(dead_code)]\n #![allow(path_statements)]\n #![allow(clippy::deref_addrof)]\n@@ -90,13 +90,19 @@ fn main() {\n     || x += 5;\n     let s: String = \"foo\".into();\n     FooString { s: s };\n+    let _unused = 1;\n+    let _penguin = || println!(\"Some helpful closure\");\n+    let _duck = Struct { field: 0 };\n+    let _cat = [2, 4, 6, 8][2];\n \n     #[allow(clippy::no_effect)]\n     0;\n \n     // Do not warn\n     get_number();\n     unsafe { unsafe_fn() };\n+    let _used = get_struct();\n+    let _x = vec![1];\n     DropUnit;\n     DropStruct { field: 0 };\n     DropTuple(0);"}, {"sha": "a5dbc9fef455a4e71028acbfcfa78c4577dda5e5", "filename": "src/tools/clippy/tests/ui/no_effect.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fno_effect.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -156,5 +156,31 @@ error: statement with no effect\n LL |     FooString { s: s };\n    |     ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 26 previous errors\n+error: binding to `_` prefixed variable with no side-effect\n+  --> $DIR/no_effect.rs:93:5\n+   |\n+LL |     let _unused = 1;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::no-effect-underscore-binding` implied by `-D warnings`\n+\n+error: binding to `_` prefixed variable with no side-effect\n+  --> $DIR/no_effect.rs:94:5\n+   |\n+LL |     let _penguin = || println!(\"Some helpful closure\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: binding to `_` prefixed variable with no side-effect\n+  --> $DIR/no_effect.rs:95:5\n+   |\n+LL |     let _duck = Struct { field: 0 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: binding to `_` prefixed variable with no side-effect\n+  --> $DIR/no_effect.rs:96:5\n+   |\n+LL |     let _cat = [2, 4, 6, 8][2];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 30 previous errors\n "}, {"sha": "4077f1920a3837758a6f02f6f5b5ea8c6a2b078e", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,8 +1,7 @@\n // edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n-#![allow(clippy::redundant_closure)]\n-#![allow(clippy::ref_option_ref, clippy::equatable_if_let)]\n+#![allow(clippy::redundant_closure, clippy::ref_option_ref, clippy::equatable_if_let)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     string.map_or((false, \"hello\"), |x| (true, x))"}, {"sha": "2f414e129d5a77c9952b88bd8e9efa5d0acc4249", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,8 +1,7 @@\n // edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n-#![allow(clippy::redundant_closure)]\n-#![allow(clippy::ref_option_ref, clippy::equatable_if_let)]\n+#![allow(clippy::redundant_closure, clippy::ref_option_ref, clippy::equatable_if_let)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     if let Some(x) = string {"}, {"sha": "803d941c36df8b2d8aa80ca7fa381ee8c35c780a", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:8:5\n+  --> $DIR/option_if_let_else.rs:7:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,19 +11,19 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:25:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:27:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:28:13\n+  --> $DIR/option_if_let_else.rs:27:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -43,13 +43,13 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:34:13\n+  --> $DIR/option_if_let_else.rs:33:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:35:13\n+  --> $DIR/option_if_let_else.rs:34:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:41:13\n+  --> $DIR/option_if_let_else.rs:40:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -89,7 +89,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:50:5\n+  --> $DIR/option_if_let_else.rs:49:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -108,7 +108,7 @@ LL +     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:63:13\n+  --> $DIR/option_if_let_else.rs:62:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:72:13\n+  --> $DIR/option_if_let_else.rs:71:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -143,13 +143,13 @@ LL ~     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:101:13\n+  --> $DIR/option_if_let_else.rs:100:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:110:13\n+  --> $DIR/option_if_let_else.rs:109:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^\n@@ -171,13 +171,13 @@ LL ~         });\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:138:13\n+  --> $DIR/option_if_let_else.rs:137:13\n    |\n LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:142:13\n+  --> $DIR/option_if_let_else.rs:141:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^"}, {"sha": "ccb2e5a302e91590feb0ba2af50ae467e00e8115", "filename": "src/tools/clippy/tests/ui/question_mark.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -104,6 +104,21 @@ fn func() -> Option<i32> {\n     Some(0)\n }\n \n+fn result_func(x: Result<i32, &str>) -> Result<i32, &str> {\n+    let _ = x?;\n+\n+    x?;\n+\n+    // No warning\n+    let y = if let Ok(x) = x {\n+        x\n+    } else {\n+        return Err(\"some error\");\n+    };\n+\n+    Ok(y)\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -123,4 +138,6 @@ fn main() {\n     returns_something_similar_to_option(so);\n \n     func();\n+\n+    let _ = result_func(Ok(42));\n }"}, {"sha": "ca3722371f524b53b27ca94f15fd1a46e7d867ca", "filename": "src/tools/clippy/tests/ui/question_mark.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -134,6 +134,23 @@ fn func() -> Option<i32> {\n     Some(0)\n }\n \n+fn result_func(x: Result<i32, &str>) -> Result<i32, &str> {\n+    let _ = if let Ok(x) = x { x } else { return x };\n+\n+    if x.is_err() {\n+        return x;\n+    }\n+\n+    // No warning\n+    let y = if let Ok(x) = x {\n+        x\n+    } else {\n+        return Err(\"some error\");\n+    };\n+\n+    Ok(y)\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -153,4 +170,6 @@ fn main() {\n     returns_something_similar_to_option(so);\n \n     func();\n+\n+    let _ = result_func(Ok(42));\n }"}, {"sha": "161588cb73cba06797561917e4ee5fe6fa3710d9", "filename": "src/tools/clippy/tests/ui/question_mark.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fquestion_mark.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -100,5 +100,19 @@ LL | |         return None;\n LL | |     }\n    | |_____^ help: replace it with: `f()?;`\n \n-error: aborting due to 11 previous errors\n+error: this if-let-else may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:138:13\n+   |\n+LL |     let _ = if let Ok(x) = x { x } else { return x };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x?`\n+\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:140:5\n+   |\n+LL | /     if x.is_err() {\n+LL | |         return x;\n+LL | |     }\n+   | |_____^ help: replace it with: `x?;`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "7a45f1b18d4af2c8d920676b4f96b755083867d1", "filename": "src/tools/clippy/tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -98,3 +98,15 @@ fn unsafe_checks() {\n     let mut s = MaybeUninit::<String>::uninit();\n     let _d = || unsafe { ptr::drop_in_place(s.as_mut_ptr()) };\n }\n+\n+// Issue #7768\n+#[rustfmt::skip]\n+fn macro_with_semicolon() {\n+    macro_rules! repro {\n+        () => {\n+            while false {\n+            }\n+        };\n+    }\n+    repro!();\n+}"}, {"sha": "55caef59f7f683f5509412a2065391fb211f4c03", "filename": "src/tools/clippy/tests/ui/shadow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -17,6 +17,11 @@ fn shadow_reuse() -> Option<()> {\n     let x = foo(x);\n     let x = || x;\n     let x = Some(1).map(|_| x)?;\n+    let y = 1;\n+    let y = match y {\n+        1 => 2,\n+        _ => 3,\n+    };\n     None\n }\n "}, {"sha": "feed6e1ba8b8660ff2f73dc71a956fb135c62235", "filename": "src/tools/clippy/tests/ui/shadow.stderr", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshadow.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -47,7 +47,7 @@ note: previous binding is here\n LL |     let x = &mut x;\n    |         ^\n \n-error: `x` is shadowed by `x.0` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:13:9\n    |\n LL |     let x = x.0;\n@@ -60,7 +60,7 @@ note: previous binding is here\n LL |     let x = ([[0]], ());\n    |         ^\n \n-error: `x` is shadowed by `x[0]` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:14:9\n    |\n LL |     let x = x[0];\n@@ -72,7 +72,7 @@ note: previous binding is here\n LL |     let x = x.0;\n    |         ^\n \n-error: `x` is shadowed by `x` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:15:10\n    |\n LL |     let [x] = x;\n@@ -84,7 +84,7 @@ note: previous binding is here\n LL |     let x = x[0];\n    |         ^\n \n-error: `x` is shadowed by `Some(x)` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:16:9\n    |\n LL |     let x = Some(x);\n@@ -96,7 +96,7 @@ note: previous binding is here\n LL |     let [x] = x;\n    |          ^\n \n-error: `x` is shadowed by `foo(x)` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:17:9\n    |\n LL |     let x = foo(x);\n@@ -108,7 +108,7 @@ note: previous binding is here\n LL |     let x = Some(x);\n    |         ^\n \n-error: `x` is shadowed by `|| x` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:18:9\n    |\n LL |     let x = || x;\n@@ -120,7 +120,7 @@ note: previous binding is here\n LL |     let x = foo(x);\n    |         ^\n \n-error: `x` is shadowed by `Some(1).map(|_| x)?` which reuses the original value\n+error: `x` is shadowed\n   --> $DIR/shadow.rs:19:9\n    |\n LL |     let x = Some(1).map(|_| x)?;\n@@ -132,102 +132,114 @@ note: previous binding is here\n LL |     let x = || x;\n    |         ^\n \n+error: `y` is shadowed\n+  --> $DIR/shadow.rs:21:9\n+   |\n+LL |     let y = match y {\n+   |         ^\n+   |\n+note: previous binding is here\n+  --> $DIR/shadow.rs:20:9\n+   |\n+LL |     let y = 1;\n+   |         ^\n+\n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = 2;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:24:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:30:13\n+  --> $DIR/shadow.rs:35:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:10\n+  --> $DIR/shadow.rs:34:10\n    |\n LL |     fn f(x: u32) {\n    |          ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:35:14\n+  --> $DIR/shadow.rs:40:14\n    |\n LL |         Some(x) => {\n    |              ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:37:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:36:17\n+  --> $DIR/shadow.rs:41:17\n    |\n LL |             let x = 1;\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:35:14\n+  --> $DIR/shadow.rs:40:14\n    |\n LL |         Some(x) => {\n    |              ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:40:17\n+  --> $DIR/shadow.rs:45:17\n    |\n LL |     if let Some(x) = Some(1) {}\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:37:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:41:20\n+  --> $DIR/shadow.rs:46:20\n    |\n LL |     while let Some(x) = Some(1) {}\n    |                    ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:37:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:42:15\n+  --> $DIR/shadow.rs:47:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:37:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:43:13\n+  --> $DIR/shadow.rs:48:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:42:15\n+  --> $DIR/shadow.rs:47:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "3ccdcd1117b5a5d47dcf87f95b30acbdba631e13", "filename": "src/tools/clippy/tests/ui/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fto_string_in_display.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::to_string_in_display)]\n-#![allow(clippy::inherent_to_string_shadow_display)]\n+#![allow(clippy::inherent_to_string_shadow_display, clippy::to_string_in_format_args)]\n \n use std::fmt;\n "}, {"sha": "501c9eb7651f8320b7e0d914de982b879ab382a3", "filename": "src/tools/clippy/tests/ui/trailing_empty_array.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,186 @@\n+#![warn(clippy::trailing_empty_array)]\n+#![feature(const_generics_defaults)]\n+\n+// Do lint:\n+\n+struct RarelyUseful {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+struct OnlyField {\n+    first_and_last: [usize; 0],\n+}\n+\n+struct GenericArrayType<T> {\n+    field: i32,\n+    last: [T; 0],\n+}\n+\n+#[must_use]\n+struct OnlyAnotherAttribute {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[derive(Debug)]\n+struct OnlyADeriveAttribute {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+const ZERO: usize = 0;\n+struct ZeroSizedWithConst {\n+    field: i32,\n+    last: [usize; ZERO],\n+}\n+\n+#[allow(clippy::eq_op)]\n+const fn compute_zero() -> usize {\n+    (4 + 6) - (2 * 5)\n+}\n+struct ZeroSizedWithConstFunction {\n+    field: i32,\n+    last: [usize; compute_zero()],\n+}\n+\n+const fn compute_zero_from_arg(x: usize) -> usize {\n+    x - 1\n+}\n+struct ZeroSizedWithConstFunction2 {\n+    field: i32,\n+    last: [usize; compute_zero_from_arg(1)],\n+}\n+\n+struct ZeroSizedArrayWrapper([usize; 0]);\n+\n+struct TupleStruct(i32, [usize; 0]);\n+\n+struct LotsOfFields {\n+    f1: u32,\n+    f2: u32,\n+    f3: u32,\n+    f4: u32,\n+    f5: u32,\n+    f6: u32,\n+    f7: u32,\n+    f8: u32,\n+    f9: u32,\n+    f10: u32,\n+    f11: u32,\n+    f12: u32,\n+    f13: u32,\n+    f14: u32,\n+    f15: u32,\n+    f16: u32,\n+    last: [usize; 0],\n+}\n+\n+// Don't lint\n+\n+#[repr(C)]\n+struct GoodReason {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[repr(C)]\n+struct OnlyFieldWithReprC {\n+    first_and_last: [usize; 0],\n+}\n+\n+struct NonZeroSizedArray {\n+    field: i32,\n+    last: [usize; 1],\n+}\n+\n+struct NotLastField {\n+    f1: u32,\n+    zero_sized: [usize; 0],\n+    last: i32,\n+}\n+\n+const ONE: usize = 1;\n+struct NonZeroSizedWithConst {\n+    field: i32,\n+    last: [usize; ONE],\n+}\n+\n+#[derive(Debug)]\n+#[repr(C)]\n+struct AlsoADeriveAttribute {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[must_use]\n+#[repr(C)]\n+struct AlsoAnotherAttribute {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[repr(packed)]\n+struct ReprPacked {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[repr(C, packed)]\n+struct ReprCPacked {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+#[repr(align(64))]\n+struct ReprAlign {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+#[repr(C, align(64))]\n+struct ReprCAlign {\n+    field: i32,\n+    last: [usize; 0],\n+}\n+\n+// NOTE: because of https://doc.rust-lang.org/stable/reference/type-layout.html#primitive-representation-of-enums-with-fields and I'm not sure when in the compilation pipeline that would happen\n+#[repr(C)]\n+enum DontLintAnonymousStructsFromDesuraging {\n+    A(u32),\n+    B(f32, [u64; 0]),\n+    C { x: u32, y: [u64; 0] },\n+}\n+\n+#[repr(C)]\n+struct TupleStructReprC(i32, [usize; 0]);\n+\n+type NamedTuple = (i32, [usize; 0]);\n+\n+#[rustfmt::skip] // [rustfmt#4995](https://github.com/rust-lang/rustfmt/issues/4995)\n+struct ConstParamZeroDefault<const N: usize = 0> {\n+    field: i32,\n+    last: [usize; N],\n+}\n+\n+struct ConstParamNoDefault<const N: usize> {\n+    field: i32,\n+    last: [usize; N],\n+}\n+\n+#[rustfmt::skip] \n+struct ConstParamNonZeroDefault<const N: usize = 1> {\n+    field: i32,\n+    last: [usize; N],\n+}\n+\n+struct TwoGenericParams<T, const N: usize> {\n+    field: i32,\n+    last: [T; N],\n+}\n+\n+type A = ConstParamZeroDefault;\n+type B = ConstParamZeroDefault<0>;\n+type C = ConstParamNoDefault<0>;\n+type D = ConstParamNonZeroDefault<0>;\n+\n+fn main() {}"}, {"sha": "d88aa0504b537b39f2176d4346a261aa0be1e9f4", "filename": "src/tools/clippy/tests/ui/trailing_empty_array.stderr", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrailing_empty_array.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,120 @@\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:6:1\n+   |\n+LL | / struct RarelyUseful {\n+LL | |     field: i32,\n+LL | |     last: [usize; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::trailing-empty-array` implied by `-D warnings`\n+   = help: consider annotating `RarelyUseful` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:11:1\n+   |\n+LL | / struct OnlyField {\n+LL | |     first_and_last: [usize; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `OnlyField` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:15:1\n+   |\n+LL | / struct GenericArrayType<T> {\n+LL | |     field: i32,\n+LL | |     last: [T; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `GenericArrayType` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:21:1\n+   |\n+LL | / struct OnlyAnotherAttribute {\n+LL | |     field: i32,\n+LL | |     last: [usize; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `OnlyAnotherAttribute` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:27:1\n+   |\n+LL | / struct OnlyADeriveAttribute {\n+LL | |     field: i32,\n+LL | |     last: [usize; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `OnlyADeriveAttribute` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:33:1\n+   |\n+LL | / struct ZeroSizedWithConst {\n+LL | |     field: i32,\n+LL | |     last: [usize; ZERO],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ZeroSizedWithConst` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:42:1\n+   |\n+LL | / struct ZeroSizedWithConstFunction {\n+LL | |     field: i32,\n+LL | |     last: [usize; compute_zero()],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ZeroSizedWithConstFunction` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:50:1\n+   |\n+LL | / struct ZeroSizedWithConstFunction2 {\n+LL | |     field: i32,\n+LL | |     last: [usize; compute_zero_from_arg(1)],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ZeroSizedWithConstFunction2` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:55:1\n+   |\n+LL | struct ZeroSizedArrayWrapper([usize; 0]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider annotating `ZeroSizedArrayWrapper` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:57:1\n+   |\n+LL | struct TupleStruct(i32, [usize; 0]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider annotating `TupleStruct` with `#[repr(C)]` or another `repr` attribute\n+\n+error: trailing zero-sized array in a struct which is not marked with a `repr` attribute\n+  --> $DIR/trailing_empty_array.rs:59:1\n+   |\n+LL | / struct LotsOfFields {\n+LL | |     f1: u32,\n+LL | |     f2: u32,\n+LL | |     f3: u32,\n+...  |\n+LL | |     last: [usize; 0],\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `LotsOfFields` with `#[repr(C)]` or another `repr` attribute\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "6a7037d8f3826e962594836a03ee0ed9ffce9a7f", "filename": "src/tools/clippy/tests/ui/transmute.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -103,6 +103,33 @@ mod int_to_float {\n     }\n }\n \n+mod num_to_bytes {\n+    fn test() {\n+        unsafe {\n+            let _: [u8; 1] = std::mem::transmute(0u8);\n+            let _: [u8; 4] = std::mem::transmute(0u32);\n+            let _: [u8; 16] = std::mem::transmute(0u128);\n+            let _: [u8; 1] = std::mem::transmute(0i8);\n+            let _: [u8; 4] = std::mem::transmute(0i32);\n+            let _: [u8; 16] = std::mem::transmute(0i128);\n+            let _: [u8; 4] = std::mem::transmute(0.0f32);\n+            let _: [u8; 8] = std::mem::transmute(0.0f64);\n+        }\n+    }\n+    const fn test_const() {\n+        unsafe {\n+            let _: [u8; 1] = std::mem::transmute(0u8);\n+            let _: [u8; 4] = std::mem::transmute(0u32);\n+            let _: [u8; 16] = std::mem::transmute(0u128);\n+            let _: [u8; 1] = std::mem::transmute(0i8);\n+            let _: [u8; 4] = std::mem::transmute(0i32);\n+            let _: [u8; 16] = std::mem::transmute(0i128);\n+            let _: [u8; 4] = std::mem::transmute(0.0f32);\n+            let _: [u8; 8] = std::mem::transmute(0.0f64);\n+        }\n+    }\n+}\n+\n fn bytes_to_str(b: &[u8], mb: &mut [u8]) {\n     let _: &str = unsafe { std::mem::transmute(b) };\n     let _: &mut str = unsafe { std::mem::transmute(mb) };"}, {"sha": "86537153e322897de816064f7b80041c88418c0d", "filename": "src/tools/clippy/tests/ui/transmute.stderr", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -140,19 +140,105 @@ error: transmute from a `i64` to a `f64`\n LL |         let _: f64 = unsafe { std::mem::transmute(0_i64) };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f64::from_bits(0_i64 as u64)`\n \n+error: transmute from a `u8` to a `[u8; 1]`\n+  --> $DIR/transmute.rs:109:30\n+   |\n+LL |             let _: [u8; 1] = std::mem::transmute(0u8);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u8.to_ne_bytes()`\n+   |\n+   = note: `-D clippy::transmute-num-to-bytes` implied by `-D warnings`\n+\n+error: transmute from a `u32` to a `[u8; 4]`\n+  --> $DIR/transmute.rs:110:30\n+   |\n+LL |             let _: [u8; 4] = std::mem::transmute(0u32);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u32.to_ne_bytes()`\n+\n+error: transmute from a `u128` to a `[u8; 16]`\n+  --> $DIR/transmute.rs:111:31\n+   |\n+LL |             let _: [u8; 16] = std::mem::transmute(0u128);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u128.to_ne_bytes()`\n+\n+error: transmute from a `i8` to a `[u8; 1]`\n+  --> $DIR/transmute.rs:112:30\n+   |\n+LL |             let _: [u8; 1] = std::mem::transmute(0i8);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i8.to_ne_bytes()`\n+\n+error: transmute from a `i32` to a `[u8; 4]`\n+  --> $DIR/transmute.rs:113:30\n+   |\n+LL |             let _: [u8; 4] = std::mem::transmute(0i32);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i32.to_ne_bytes()`\n+\n+error: transmute from a `i128` to a `[u8; 16]`\n+  --> $DIR/transmute.rs:114:31\n+   |\n+LL |             let _: [u8; 16] = std::mem::transmute(0i128);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i128.to_ne_bytes()`\n+\n+error: transmute from a `f32` to a `[u8; 4]`\n+  --> $DIR/transmute.rs:115:30\n+   |\n+LL |             let _: [u8; 4] = std::mem::transmute(0.0f32);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0.0f32.to_ne_bytes()`\n+\n+error: transmute from a `f64` to a `[u8; 8]`\n+  --> $DIR/transmute.rs:116:30\n+   |\n+LL |             let _: [u8; 8] = std::mem::transmute(0.0f64);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0.0f64.to_ne_bytes()`\n+\n+error: transmute from a `u8` to a `[u8; 1]`\n+  --> $DIR/transmute.rs:121:30\n+   |\n+LL |             let _: [u8; 1] = std::mem::transmute(0u8);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u8.to_ne_bytes()`\n+\n+error: transmute from a `u32` to a `[u8; 4]`\n+  --> $DIR/transmute.rs:122:30\n+   |\n+LL |             let _: [u8; 4] = std::mem::transmute(0u32);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u32.to_ne_bytes()`\n+\n+error: transmute from a `u128` to a `[u8; 16]`\n+  --> $DIR/transmute.rs:123:31\n+   |\n+LL |             let _: [u8; 16] = std::mem::transmute(0u128);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0u128.to_ne_bytes()`\n+\n+error: transmute from a `i8` to a `[u8; 1]`\n+  --> $DIR/transmute.rs:124:30\n+   |\n+LL |             let _: [u8; 1] = std::mem::transmute(0i8);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i8.to_ne_bytes()`\n+\n+error: transmute from a `i32` to a `[u8; 4]`\n+  --> $DIR/transmute.rs:125:30\n+   |\n+LL |             let _: [u8; 4] = std::mem::transmute(0i32);\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i32.to_ne_bytes()`\n+\n+error: transmute from a `i128` to a `[u8; 16]`\n+  --> $DIR/transmute.rs:126:31\n+   |\n+LL |             let _: [u8; 16] = std::mem::transmute(0i128);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `to_ne_bytes()`: `0i128.to_ne_bytes()`\n+\n error: transmute from a `&[u8]` to a `&str`\n-  --> $DIR/transmute.rs:107:28\n+  --> $DIR/transmute.rs:134:28\n    |\n LL |     let _: &str = unsafe { std::mem::transmute(b) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8(b).unwrap()`\n    |\n    = note: `-D clippy::transmute-bytes-to-str` implied by `-D warnings`\n \n error: transmute from a `&mut [u8]` to a `&mut str`\n-  --> $DIR/transmute.rs:108:32\n+  --> $DIR/transmute.rs:135:32\n    |\n LL |     let _: &mut str = unsafe { std::mem::transmute(mb) };\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8_mut(mb).unwrap()`\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 38 previous errors\n "}, {"sha": "52577323a5837255f37698f6ff8076a941bd205c", "filename": "src/tools/clippy/tests/ui/undocumented_unsafe_blocks.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,287 @@\n+#![warn(clippy::undocumented_unsafe_blocks)]\n+\n+// Valid comments\n+\n+fn nested_local() {\n+    let _ = {\n+        let _ = {\n+            // Safety:\n+            let _ = unsafe {};\n+        };\n+    };\n+}\n+\n+fn deep_nest() {\n+    let _ = {\n+        let _ = {\n+            // Safety:\n+            let _ = unsafe {};\n+\n+            // Safety:\n+            unsafe {};\n+\n+            let _ = {\n+                let _ = {\n+                    let _ = {\n+                        let _ = {\n+                            let _ = {\n+                                // Safety:\n+                                let _ = unsafe {};\n+\n+                                // Safety:\n+                                unsafe {};\n+                            };\n+                        };\n+                    };\n+\n+                    // Safety:\n+                    unsafe {};\n+                };\n+            };\n+        };\n+\n+        // Safety:\n+        unsafe {};\n+    };\n+\n+    // Safety:\n+    unsafe {};\n+}\n+\n+fn local_tuple_expression() {\n+    // Safety:\n+    let _ = (42, unsafe {});\n+}\n+\n+fn line_comment() {\n+    // Safety:\n+    unsafe {}\n+}\n+\n+fn line_comment_newlines() {\n+    // Safety:\n+\n+    unsafe {}\n+}\n+\n+fn line_comment_empty() {\n+    // Safety:\n+    //\n+    //\n+    //\n+    unsafe {}\n+}\n+\n+fn line_comment_with_extras() {\n+    // This is a description\n+    // Safety:\n+    unsafe {}\n+}\n+\n+fn block_comment() {\n+    /* Safety: */\n+    unsafe {}\n+}\n+\n+fn block_comment_newlines() {\n+    /* Safety: */\n+\n+    unsafe {}\n+}\n+\n+#[rustfmt::skip]\n+fn inline_block_comment() {\n+    /* Safety: */unsafe {}\n+}\n+\n+fn block_comment_with_extras() {\n+    /* This is a description\n+     * Safety:\n+     */\n+    unsafe {}\n+}\n+\n+fn block_comment_terminator_same_line() {\n+    /* This is a description\n+     * Safety: */\n+    unsafe {}\n+}\n+\n+fn buried_safety() {\n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\n+    // incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation\n+    // ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in\n+    // reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint\n+    // occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est\n+    // laborum. Safety:\n+    // Tellus elementum sagittis vitae et leo duis ut diam quam. Sit amet nulla facilisi\n+    // morbi tempus iaculis urna. Amet luctus venenatis lectus magna. At quis risus sed vulputate odio\n+    // ut. Luctus venenatis lectus magna fringilla urna. Tortor id aliquet lectus proin nibh nisl\n+    // condimentum id venenatis. Vulputate dignissim suspendisse in est ante in nibh mauris cursus.\n+    unsafe {}\n+}\n+\n+fn safety_with_prepended_text() {\n+    // This is a test. Safety:\n+    unsafe {}\n+}\n+\n+fn local_line_comment() {\n+    // Safety:\n+    let _ = unsafe {};\n+}\n+\n+fn local_block_comment() {\n+    /* Safety: */\n+    let _ = unsafe {};\n+}\n+\n+fn comment_array() {\n+    // Safety:\n+    let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+}\n+\n+fn comment_tuple() {\n+    // Safety:\n+    let _ = (42, unsafe {}, \"test\", unsafe {});\n+}\n+\n+fn comment_unary() {\n+    // Safety:\n+    let _ = *unsafe { &42 };\n+}\n+\n+#[allow(clippy::match_single_binding)]\n+fn comment_match() {\n+    // Safety:\n+    let _ = match unsafe {} {\n+        _ => {},\n+    };\n+}\n+\n+fn comment_addr_of() {\n+    // Safety:\n+    let _ = &unsafe {};\n+}\n+\n+fn comment_repeat() {\n+    // Safety:\n+    let _ = [unsafe {}; 5];\n+}\n+\n+fn comment_macro_call() {\n+    macro_rules! t {\n+        ($b:expr) => {\n+            $b\n+        };\n+    }\n+\n+    t!(\n+        // Safety:\n+        unsafe {}\n+    );\n+}\n+\n+fn comment_macro_def() {\n+    macro_rules! t {\n+        () => {\n+            // Safety:\n+            unsafe {}\n+        };\n+    }\n+\n+    t!();\n+}\n+\n+fn non_ascii_comment() {\n+    // \u0950\u19fb\u0ed2 Safety: \u0bf5\u2230\n+    unsafe {};\n+}\n+\n+fn local_commented_block() {\n+    let _ =\n+        // Safety:\n+        unsafe {};\n+}\n+\n+fn local_nest() {\n+    // Safety:\n+    let _ = [(42, unsafe {}, unsafe {}), (52, unsafe {}, unsafe {})];\n+}\n+\n+// Invalid comments\n+\n+fn no_comment() {\n+    unsafe {}\n+}\n+\n+fn no_comment_array() {\n+    let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+}\n+\n+fn no_comment_tuple() {\n+    let _ = (42, unsafe {}, \"test\", unsafe {});\n+}\n+\n+fn no_comment_unary() {\n+    let _ = *unsafe { &42 };\n+}\n+\n+#[allow(clippy::match_single_binding)]\n+fn no_comment_match() {\n+    let _ = match unsafe {} {\n+        _ => {},\n+    };\n+}\n+\n+fn no_comment_addr_of() {\n+    let _ = &unsafe {};\n+}\n+\n+fn no_comment_repeat() {\n+    let _ = [unsafe {}; 5];\n+}\n+\n+fn local_no_comment() {\n+    let _ = unsafe {};\n+}\n+\n+fn no_comment_macro_call() {\n+    macro_rules! t {\n+        ($b:expr) => {\n+            $b\n+        };\n+    }\n+\n+    t!(unsafe {});\n+}\n+\n+fn no_comment_macro_def() {\n+    macro_rules! t {\n+        () => {\n+            unsafe {}\n+        };\n+    }\n+\n+    t!();\n+}\n+\n+fn trailing_comment() {\n+    unsafe {} // Safety:\n+}\n+\n+fn internal_comment() {\n+    unsafe {\n+        // Safety:\n+    }\n+}\n+\n+fn interference() {\n+    // Safety\n+\n+    let _ = 42;\n+\n+    unsafe {};\n+}\n+\n+fn main() {}"}, {"sha": "613e9ffca456559a9352d85166f44711d7c7b787", "filename": "src/tools/clippy/tests/ui/undocumented_unsafe_blocks.stderr", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,159 @@\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:215:5\n+   |\n+LL |     unsafe {}\n+   |     ^^^^^^^^^\n+   |\n+   = note: `-D clippy::undocumented-unsafe-blocks` implied by `-D warnings`\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     unsafe {}\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:219:5\n+   |\n+LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:223:5\n+   |\n+LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = (42, unsafe {}, \"test\", unsafe {});\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:227:5\n+   |\n+LL |     let _ = *unsafe { &42 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = *unsafe { &42 };\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:232:5\n+   |\n+LL |     let _ = match unsafe {} {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = match unsafe {} {\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:238:5\n+   |\n+LL |     let _ = &unsafe {};\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = &unsafe {};\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:242:5\n+   |\n+LL |     let _ = [unsafe {}; 5];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = [unsafe {}; 5];\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:246:5\n+   |\n+LL |     let _ = unsafe {};\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     let _ = unsafe {};\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:256:8\n+   |\n+LL |     t!(unsafe {});\n+   |        ^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     t!(// Safety: ...\n+LL ~     unsafe {});\n+   |\n+\n+error: unsafe block in macro expansion missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:262:13\n+   |\n+LL |             unsafe {}\n+   |             ^^^^^^^^^\n+...\n+LL |     t!();\n+   |     ---- in this macro invocation\n+   |\n+   = help: consider adding a safety comment in the macro definition\n+   = note: this error originates in the macro `t` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:270:5\n+   |\n+LL |     unsafe {} // Safety:\n+   |     ^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL ~     unsafe {} // Safety:\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:274:5\n+   |\n+LL |     unsafe {\n+   |     ^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL +     unsafe {\n+   |\n+\n+error: unsafe block missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:284:5\n+   |\n+LL |     unsafe {};\n+   |     ^^^^^^^^^\n+   |\n+help: consider adding a safety comment\n+   |\n+LL ~     // Safety: ...\n+LL ~     unsafe {};\n+   |\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "dc150cf28f2cce48b79d9df965539d5482cc445f", "filename": "src/tools/clippy/tests/ui/uninit_vec.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,94 @@\n+#![warn(clippy::uninit_vec)]\n+\n+use std::mem::MaybeUninit;\n+\n+#[derive(Default)]\n+struct MyVec {\n+    vec: Vec<u8>,\n+}\n+\n+fn main() {\n+    // with_capacity() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // reserve() -> set_len() should be detected\n+    vec.reserve(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // new() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Vec::new();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // default() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Default::default();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    let mut vec: Vec<u8> = Vec::default();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // test when both calls are enclosed in the same unsafe block\n+    unsafe {\n+        let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        vec.reserve(1000);\n+        vec.set_len(200);\n+    }\n+\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        // test the case where there are other statements in the following unsafe block\n+        vec.set_len(200);\n+        assert!(vec.len() == 200);\n+    }\n+\n+    // handle vec stored in the field of a struct\n+    let mut my_vec = MyVec::default();\n+    my_vec.vec.reserve(1000);\n+    unsafe {\n+        my_vec.vec.set_len(200);\n+    }\n+\n+    my_vec.vec = Vec::with_capacity(1000);\n+    unsafe {\n+        my_vec.vec.set_len(200);\n+    }\n+\n+    // Test `#[allow(...)]` attributes on inner unsafe block (shouldn't trigger)\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    #[allow(clippy::uninit_vec)]\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // MaybeUninit-wrapped types should not be detected\n+    unsafe {\n+        let mut vec: Vec<MaybeUninit<u8>> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        let mut vec: Vec<(MaybeUninit<u8>, MaybeUninit<bool>)> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        let mut vec: Vec<(MaybeUninit<u8>, [MaybeUninit<bool>; 2])> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+    }\n+\n+    // known false negative\n+    let mut vec1: Vec<u8> = Vec::with_capacity(1000);\n+    let mut vec2: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec1.set_len(200);\n+        vec2.set_len(200);\n+    }\n+}"}, {"sha": "520bfb26b62e1b7c23c521cb859113fb31aa540e", "filename": "src/tools/clippy/tests/ui/uninit_vec.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funinit_vec.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,105 @@\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:12:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::uninit-vec` implied by `-D warnings`\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:18:5\n+   |\n+LL |     vec.reserve(1000);\n+   |     ^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:24:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:30:5\n+   |\n+LL |     let mut vec: Vec<u8> = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:35:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:49:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:58:5\n+   |\n+LL |     my_vec.vec.reserve(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         my_vec.vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:63:5\n+   |\n+LL |     my_vec.vec = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         my_vec.vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:42:9\n+   |\n+LL |         let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:45:9\n+   |\n+LL |         vec.reserve(1000);\n+   |         ^^^^^^^^^^^^^^^^^^\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "d806d620b176a3efd702bef0b00b0fb4755ce1dd", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(clippy::stable_sort_primitive)]\n \n+use std::cell::Ref;\n use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {\n@@ -33,6 +34,10 @@ fn unnecessary_sort_by() {\n     // `Reverse(b)` would borrow in the following cases, don't lint\n     vec.sort_by(|a, b| b.cmp(a));\n     vec.sort_unstable_by(|a, b| b.cmp(a));\n+\n+    // No warning if element does not implement `Ord`\n+    let mut vec: Vec<Ref<usize>> = Vec::new();\n+    vec.sort_unstable_by(|a, b| a.cmp(b));\n }\n \n // Do not suggest returning a reference to the closure parameter of `Vec::sort_by_key`"}, {"sha": "6ee9c3af455dfbd39c98264d2f9f386b5bc8a85b", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(clippy::stable_sort_primitive)]\n \n+use std::cell::Ref;\n use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {\n@@ -33,6 +34,10 @@ fn unnecessary_sort_by() {\n     // `Reverse(b)` would borrow in the following cases, don't lint\n     vec.sort_by(|a, b| b.cmp(a));\n     vec.sort_unstable_by(|a, b| b.cmp(a));\n+\n+    // No warning if element does not implement `Ord`\n+    let mut vec: Vec<Ref<usize>> = Vec::new();\n+    vec.sort_unstable_by(|a, b| a.cmp(b));\n }\n \n // Do not suggest returning a reference to the closure parameter of `Vec::sort_by_key`"}, {"sha": "ca9641e880316533eda97e7f6904efccc7297380", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -1,73 +1,73 @@\n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:14:5\n+  --> $DIR/unnecessary_sort_by.rs:15:5\n    |\n LL |     vec.sort_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort()`\n    |\n    = note: `-D clippy::unnecessary-sort-by` implied by `-D warnings`\n \n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:15:5\n+  --> $DIR/unnecessary_sort_by.rs:16:5\n    |\n LL |     vec.sort_unstable_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:16:5\n+  --> $DIR/unnecessary_sort_by.rs:17:5\n    |\n LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (a + 5).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:17:5\n+  --> $DIR/unnecessary_sort_by.rs:18:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| id(-a))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:20:5\n+  --> $DIR/unnecessary_sort_by.rs:21:5\n    |\n LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|b| Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:21:5\n+  --> $DIR/unnecessary_sort_by.rs:22:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|b| Reverse(id(-b)))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:31:5\n+  --> $DIR/unnecessary_sort_by.rs:32:5\n    |\n LL |     vec.sort_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (***a).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:32:5\n+  --> $DIR/unnecessary_sort_by.rs:33:5\n    |\n LL |     vec.sort_unstable_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| (***a).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:88:9\n+  --> $DIR/unnecessary_sort_by.rs:93:9\n    |\n LL |         args.sort_by(|a, b| a.name().cmp(&b.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|a| a.name())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:89:9\n+  --> $DIR/unnecessary_sort_by.rs:94:9\n    |\n LL |         args.sort_unstable_by(|a, b| a.name().cmp(&b.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|a| a.name())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:91:9\n+  --> $DIR/unnecessary_sort_by.rs:96:9\n    |\n LL |         args.sort_by(|a, b| b.name().cmp(&a.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|b| Reverse(b.name()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:92:9\n+  --> $DIR/unnecessary_sort_by.rs:97:9\n    |\n LL |         args.sort_unstable_by(|a, b| b.name().cmp(&a.name()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|b| Reverse(b.name()))`"}, {"sha": "98bc1e80731ff3934643d2c565f70ad241ddd7f1", "filename": "src/tools/clippy/tests/ui/wildcard_imports.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -230,4 +230,12 @@ mod super_imports {\n             let _ = foofoo();\n         }\n     }\n+\n+    mod attestation_should_be_replaced {\n+        use super::foofoo;\n+\n+        fn with_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n }"}, {"sha": "4ef61f9245b58f9420daded6c79a1d84e201edb9", "filename": "src/tools/clippy/tests/ui/wildcard_imports.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -231,4 +231,12 @@ mod super_imports {\n             let _ = foofoo();\n         }\n     }\n+\n+    mod attestation_should_be_replaced {\n+        use super::*;\n+\n+        fn with_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n }"}, {"sha": "d7af0c046e88694f34a1ff399931fe346cc8904c", "filename": "src/tools/clippy/tests/ui/wildcard_imports.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -122,5 +122,11 @@ error: usage of wildcard import\n LL |         use super::super::super_imports::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `super::super::super_imports::foofoo`\n \n-error: aborting due to 20 previous errors\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:236:13\n+   |\n+LL |         use super::*;\n+   |             ^^^^^^^^ help: try: `super::foofoo`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "f2f5f1e588ed408e8a252148e7c9f48b48001bda", "filename": "src/tools/clippy/tests/ui_test/eq_op.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9af8e378b9c95b8d21987c414862682eb3c5451c/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs?ref=9af8e378b9c95b8d21987c414862682eb3c5451c", "patch": "@@ -0,0 +1,15 @@\n+#[warn(clippy::eq_op)]\n+#[test]\n+fn eq_op_shouldnt_trigger_in_tests() {\n+    let a = 1;\n+    let result = a + 1 == 1 + a;\n+    assert!(result);\n+}\n+\n+#[test]\n+fn eq_op_macros_shouldnt_trigger_in_tests() {\n+    let a = 1;\n+    let b = 2;\n+    assert_eq!(a, a);\n+    assert_eq!(a + b, b + a);\n+}"}]}