{"sha": "36a7a654b080f4b9d714a904f4ffde7e2483b4fc", "node_id": "C_kwDOAAsO6NoAKDM2YTdhNjU0YjA4MGY0YjlkNzE0YTkwNGY0ZmZkZTdlMjQ4M2I0ZmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-17T14:40:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-17T14:40:37Z"}, "message": "Auto merge of #2378 - RalfJung:sb, r=RalfJung\n\nuse PlaceTy visitor and dedup sime retagging code\n\nI benchmarked this and as far as I can see the difference to the old code is totally within noise. And this makes the code a lot simpler and removes duplication so yay. :)", "tree": {"sha": "c7d5497aec0c83ee5830a7cc7d031181100da148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d5497aec0c83ee5830a7cc7d031181100da148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36a7a654b080f4b9d714a904f4ffde7e2483b4fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36a7a654b080f4b9d714a904f4ffde7e2483b4fc", "html_url": "https://github.com/rust-lang/rust/commit/36a7a654b080f4b9d714a904f4ffde7e2483b4fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36a7a654b080f4b9d714a904f4ffde7e2483b4fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "416cddb2516dea056bf6269eaaa5ba4d24ad0832", "url": "https://api.github.com/repos/rust-lang/rust/commits/416cddb2516dea056bf6269eaaa5ba4d24ad0832", "html_url": "https://github.com/rust-lang/rust/commit/416cddb2516dea056bf6269eaaa5ba4d24ad0832"}, {"sha": "39866f817a002505f63f0e5d7ff06b9e99453015", "url": "https://api.github.com/repos/rust-lang/rust/commits/39866f817a002505f63f0e5d7ff06b9e99453015", "html_url": "https://github.com/rust-lang/rust/commit/39866f817a002505f63f0e5d7ff06b9e99453015"}], "stats": {"total": 95, "additions": 38, "deletions": 57}, "files": [{"sha": "9040d03632ed9051f41f7afc996d540f83a945df", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/36a7a654b080f4b9d714a904f4ffde7e2483b4fc/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a7a654b080f4b9d714a904f4ffde7e2483b4fc/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=36a7a654b080f4b9d714a904f4ffde7e2483b4fc", "patch": "@@ -1021,6 +1021,10 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n+        let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n+        return visitor.visit_value(place);\n+\n         // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n@@ -1037,90 +1041,67 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }, false)),\n-                // Boxes are handled separately due to that allocator situation.\n+                // Boxes are handled separately due to that allocator situation,\n+                // see the visitor below.\n                 _ => None,\n             }\n         }\n \n-        // We need a visitor to visit all references. However, that requires\n-        // a `MPlaceTy` (or `OpTy`), so we have a fast path for reference types that\n-        // avoids allocating.\n-\n-        if let Some((ref_kind, protector)) = qualify(place.layout.ty, kind) {\n-            // Fast path.\n-            let val = this.read_immediate(&this.place_to_op(place)?)?;\n-            let val = this.retag_reference(&val, ref_kind, protector)?;\n-            this.write_immediate(*val, place)?;\n-            return Ok(());\n-        }\n-\n-        // If we don't want to recurse, we are already done.\n-        // EXCEPT if this is a `Box`, then we have to recurse because allocators.\n-        // (Yes this means we technically also recursively retag the allocator itself even if field\n-        // retagging is not enabled. *shrug*)\n-        if !this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields\n-            && !place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n-        {\n-            return Ok(());\n-        }\n-\n-        // Skip some types that have no further structure we might care about.\n-        if matches!(\n-            place.layout.ty.kind(),\n-            ty::RawPtr(..)\n-                | ty::Ref(..)\n-                | ty::Int(..)\n-                | ty::Uint(..)\n-                | ty::Float(..)\n-                | ty::Bool\n-                | ty::Char\n-        ) {\n-            return Ok(());\n-        }\n-        // Now go visit this thing.\n-        let place = this.force_allocation(place)?;\n-\n-        let mut visitor = RetagVisitor { ecx: this, kind };\n-        return visitor.visit_value(&place);\n-\n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n             kind: RetagKind,\n+            retag_fields: bool,\n+        }\n+        impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n+            #[inline(always)] // yes this helps in our benchmarks\n+            fn retag_place(\n+                &mut self,\n+                place: &PlaceTy<'tcx, Tag>,\n+                ref_kind: RefKind,\n+                protector: bool,\n+            ) -> InterpResult<'tcx> {\n+                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n+                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n+                self.ecx.write_immediate(*val, place)?;\n+                Ok(())\n+            }\n         }\n         impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for RetagVisitor<'ecx, 'mir, 'tcx>\n         {\n-            type V = MPlaceTy<'tcx, Tag>;\n+            type V = PlaceTy<'tcx, Tag>;\n \n             #[inline(always)]\n             fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n                 self.ecx\n             }\n \n-            fn visit_box(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_box(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                let (ref_kind, protector) = (RefKind::Unique { two_phase: false }, false);\n-\n-                let val = self.ecx.read_immediate(&place.into())?;\n-                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                self.ecx.write_immediate(*val, &place.into())?;\n-                Ok(())\n+                self.retag_place(\n+                    place,\n+                    RefKind::Unique { two_phase: false },\n+                    /*protector*/ false,\n+                )\n             }\n \n-            fn visit_value(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_value(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    let val = self.ecx.read_immediate(&place.into())?;\n-                    let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n-                    self.ecx.write_immediate(*val, &place.into())?;\n+                    self.retag_place(place, ref_kind, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n                     // Wide raw pointers *do* have fields and their types are strange.\n                     // vtables have a type like `&[*const (); 3]` or so!\n                     // Do *not* recurse into them.\n-                    // (No need to worry about wide references or boxes, those always \"qualify\".)\n-                } else {\n-                    // Maybe we need to go deeper.\n+                    // (No need to worry about wide references, those always \"qualify\". And Boxes\n+                    // are handles specially by the visitor anyway.)\n+                } else if self.retag_fields\n+                    || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n+                {\n+                    // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`.\n+                    // (Yes this means we technically also recursively retag the allocator itself\n+                    // even if field retagging is not enabled. *shrug*)\n                     self.walk_value(place)?;\n                 }\n                 Ok(())"}]}