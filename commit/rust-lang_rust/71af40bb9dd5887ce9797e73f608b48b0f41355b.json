{"sha": "71af40bb9dd5887ce9797e73f608b48b0f41355b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYWY0MGJiOWRkNTg4N2NlOTc5N2U3M2Y2MDhiNDhiMGY0MTM1NWI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-23T16:26:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-23T16:26:52Z"}, "message": "revised mir-dataflow so bitvectors carry a phantom type for their index domain.\n\nAs some drive-by's:\n\n * moved bitwise operators into `mod bitslice`\n\n * factored out `fn gen` and `fn kill` methods on `BlockSets` type\n\n * removed outdated comment about `fn propagate_call_return`", "tree": {"sha": "97622f8afe12f44346718a4dd251de9a6daf7794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97622f8afe12f44346718a4dd251de9a6daf7794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71af40bb9dd5887ce9797e73f608b48b0f41355b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71af40bb9dd5887ce9797e73f608b48b0f41355b", "html_url": "https://github.com/rust-lang/rust/commit/71af40bb9dd5887ce9797e73f608b48b0f41355b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71af40bb9dd5887ce9797e73f608b48b0f41355b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0796ee77baf4a186413c1176878e6705fa9dc377", "url": "https://api.github.com/repos/rust-lang/rust/commits/0796ee77baf4a186413c1176878e6705fa9dc377", "html_url": "https://github.com/rust-lang/rust/commit/0796ee77baf4a186413c1176878e6705fa9dc377"}], "stats": {"total": 452, "additions": 272, "deletions": 180}, "files": [{"sha": "7a203b7f0b71691f9088d96c2f945568df84c2fe", "filename": "src/librustc_borrowck/bitslice.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fbitslice.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -109,3 +109,32 @@ pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n     result.push(']');\n     return result\n }\n+\n+#[inline]\n+pub fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                                   in_vec: &[usize],\n+                                   op: &Op) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n+        let old_val = *out_elt;\n+        let new_val = op.join(old_val, *in_elt);\n+        *out_elt = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n+    fn join(&self, pred1: usize, pred2: usize) -> usize;\n+}\n+\n+pub struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n+}\n+pub struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n+}"}, {"sha": "5a8b3ec32062cca88f8645091d56966cdaa2eed7", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -54,8 +54,9 @@ struct Graph<'a, 'tcx, MWF:'a> where MWF: MirWithFlowState<'tcx>,\n \n pub fn print_borrowck_graph_to<'a, 'tcx, BD>(\n     mbcx: &MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>,\n-    path: &Path) -> io::Result<()> where BD: BitDenotation,\n-                                        BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+    path: &Path)\n+    -> io::Result<()>\n+    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>,\n {\n     let g = Graph { mbcx: mbcx, phantom: PhantomData };\n     let mut v = Vec::new();\n@@ -180,7 +181,7 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n                                         <td></td></tr>\",\n                        bg = BG_FLOWCONTENT,\n                        face = FACE_MONOSPACE,\n-                       entrybits=bits_to_string(entry, bits_per_block))\n+                       entrybits=bits_to_string(entry.words(), bits_per_block))\n             },\n             |w| {\n                 let ctxt = self.mbcx.analysis_ctxt();\n@@ -197,7 +198,7 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n                                            <td></td></tr>\",\n                            bg = BG_FLOWCONTENT,\n                            face = FACE_MONOSPACE,\n-                           genbits=bits_to_string(gen, bits_per_block))?;\n+                           genbits=bits_to_string(gen.words(), bits_per_block))?;\n                 }\n \n                 {\n@@ -209,7 +210,7 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n                            bg = BG_FLOWCONTENT,\n                            align = ALIGN_RIGHT,\n                            face = FACE_MONOSPACE,\n-                           killbits=bits_to_string(kill, bits_per_block))?;\n+                           killbits=bits_to_string(kill.words(), bits_per_block))?;\n                 }\n \n                 // (chunked_present_right)"}, {"sha": "e1459ad2abeaeb33c9d4455bbe9f4a143674160a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 141, "deletions": 156, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -24,6 +24,8 @@ use super::gather_moves::{MoveOut, MovePath};\n use super::DropFlagState;\n \n use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+use bitslice::{bitwise, BitwiseOperator};\n+use indexed_set::{Idx, IdxSet, OwnIdxSet};\n \n pub use self::sanity_check::sanity_check_via_rustc_peek;\n \n@@ -35,7 +37,9 @@ pub trait Dataflow {\n }\n \n impl<'a, 'tcx: 'a, BD> Dataflow for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where BD: BitDenotation + DataflowOperator, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+    where BD: BitDenotation + DataflowOperator,\n+          BD::Bit: Debug,\n+          BD::Ctxt: HasMoveData<'tcx>\n {\n     fn dataflow(&mut self) {\n         self.flow_state.build_sets();\n@@ -46,7 +50,7 @@ impl<'a, 'tcx: 'a, BD> Dataflow for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n }\n \n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n-    where O: 'b + BitDenotation, O::Ctxt: HasMoveData<'tcx>,\n+    where O: 'b + BitDenotation, O::Ctxt: HasMoveData<'tcx>\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n     changed: bool,\n@@ -56,7 +60,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n     where BD: BitDenotation + DataflowOperator, BD::Ctxt: HasMoveData<'tcx>\n {\n     fn propagate(&mut self) {\n-        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n+        let mut temp = OwnIdxSet::new_empty(self.flow_state.sets.bits_per_block);\n         let mut propcx = PropagationContext {\n             builder: self,\n             changed: true,\n@@ -102,23 +106,23 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n     where BD: BitDenotation + DataflowOperator, BD::Ctxt: HasMoveData<'tcx>\n {\n-    fn reset(&mut self, bits: &mut [usize]) {\n-        let e = if BD::bottom_value() {usize::MAX} else {0};\n-        for b in bits {\n+    fn reset(&mut self, bits: &mut IdxSet<BD::Idx>) {\n+        let e = if BD::bottom_value() {!0} else {0};\n+        for b in bits.words_mut() {\n             *b = e;\n         }\n     }\n \n-    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n+    fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n         let mir = self.builder.mir;\n         for (bb_idx, bb_data) in mir.basic_blocks.iter().enumerate() {\n             let builder = &mut self.builder;\n             {\n                 let sets = builder.flow_state.sets.for_block(bb_idx);\n-                debug_assert!(in_out.len() == sets.on_entry.len());\n-                in_out.clone_from_slice(sets.on_entry);\n-                bitwise(in_out, sets.gen_set, &Union);\n-                bitwise(in_out, sets.kill_set, &Subtract);\n+                debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n+                in_out.clone_from(sets.on_entry);\n+                in_out.union(sets.gen_set);\n+                in_out.subtract(sets.kill_set);\n             }\n             builder.propagate_bits_into_graph_successors_of(in_out,\n                                                             &mut self.changed,\n@@ -161,14 +165,18 @@ impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n }\n \n /// Maps each block to a set of bits\n-#[derive(Clone, Debug)]\n-struct Bits {\n-    bits: Vec<usize>,\n+#[derive(Debug)]\n+struct Bits<E:Idx> {\n+    bits: OwnIdxSet<E>,\n+}\n+\n+impl<E:Idx> Clone for Bits<E> {\n+    fn clone(&self) -> Self { Bits { bits: self.bits.clone() } }\n }\n \n-impl Bits {\n-    fn new(init_word: usize, num_words: usize) -> Self {\n-        Bits { bits: vec![init_word; num_words] }\n+impl<E:Idx> Bits<E> {\n+    fn new(bits: OwnIdxSet<E>) -> Self {\n+        Bits { bits: bits }\n     }\n }\n \n@@ -201,25 +209,23 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n \n-#[derive(Debug)]\n-pub struct DataflowResults<O: BitDenotation>(DataflowState<O>);\n+pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n \n // FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n // references it in a method signature. Look into using `pub(crate)` to address this.\n-#[derive(Debug)]\n pub struct DataflowState<O: BitDenotation>\n {\n     /// All the sets for the analysis. (Factored into its\n     /// own structure so that we can borrow it mutably\n     /// on its own separate from other fields.)\n-    pub sets: AllSets,\n+    pub sets: AllSets<O::Idx>,\n \n     /// operator used to initialize, combine, and interpret bits.\n     operator: O,\n }\n \n #[derive(Debug)]\n-pub struct AllSets {\n+pub struct AllSets<E: Idx> {\n     /// Analysis bitwidth for each block.\n     bits_per_block: usize,\n \n@@ -230,59 +236,71 @@ pub struct AllSets {\n     /// For each block, bits generated by executing the statements in\n     /// the block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Bits,\n+    gen_sets: Bits<E>,\n \n     /// For each block, bits killed by executing the statements in the\n     /// block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Bits,\n+    kill_sets: Bits<E>,\n \n     /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits,\n+    on_entry_sets: Bits<E>,\n }\n \n-pub struct BlockSets<'a> {\n-    on_entry: &'a mut [usize],\n-    gen_set: &'a mut [usize],\n-    kill_set: &'a mut [usize],\n+pub struct BlockSets<'a, E: Idx> {\n+    on_entry: &'a mut IdxSet<E>,\n+    gen_set: &'a mut IdxSet<E>,\n+    kill_set: &'a mut IdxSet<E>,\n }\n \n-impl AllSets {\n+impl<'a, E:Idx> BlockSets<'a, E> {\n+    fn gen(&mut self, e: &E) {\n+        self.gen_set.add(e);\n+        self.kill_set.remove(e);\n+    }\n+    fn kill(&mut self, e: &E) {\n+        self.gen_set.remove(e);\n+        self.kill_set.add(e);\n+    }\n+}\n+\n+impl<E:Idx> AllSets<E> {\n     pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n-    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n+    pub fn for_block(&mut self, block_idx: usize) -> BlockSets<E> {\n         let offset = self.words_per_block * block_idx;\n-        let range = offset..(offset + self.words_per_block);\n+        let range = E::new(offset)..E::new(offset + self.words_per_block);\n         BlockSets {\n-            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n-            gen_set: &mut self.gen_sets.bits[range.clone()],\n-            kill_set: &mut self.kill_sets.bits[range],\n+            on_entry: self.on_entry_sets.bits.range_mut(&range),\n+            gen_set: self.gen_sets.bits.range_mut(&range),\n+            kill_set: self.kill_sets.bits.range_mut(&range),\n         }\n     }\n \n-    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n+    fn lookup_set_for<'a>(&self, sets: &'a Bits<E>, block_idx: usize) -> &'a IdxSet<E> {\n         let offset = self.words_per_block * block_idx;\n-        &sets.bits[offset..(offset + self.words_per_block)]\n+        let range = E::new(offset)..E::new(offset + self.words_per_block);\n+        sets.bits.range(&range)\n     }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n+    pub fn gen_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.gen_sets, block_idx)\n     }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n+    pub fn kill_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.kill_sets, block_idx)\n     }\n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.on_entry_sets, block_idx)\n     }\n }\n \n impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &[usize], mut f: F)\n+    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &IdxSet<O::Idx>, mut f: F)\n         where F: FnMut(usize) {\n         //! Helper for iterating over the bits in a bitvector.\n \n         let bits_per_block = self.operator.bits_per_block(ctxt);\n         let usize_bits: usize = mem::size_of::<usize>() * 8;\n \n-        for (word_index, &word) in words.iter().enumerate() {\n+        for (word_index, &word) in words.words().iter().enumerate() {\n             if word != 0 {\n                 let base_index = word_index * usize_bits;\n                 for offset in 0..usize_bits {\n@@ -307,7 +325,7 @@ impl<O: BitDenotation> DataflowState<O> {\n         }\n     }\n \n-    pub fn interpret_set<'c>(&self, ctxt: &'c O::Ctxt, words: &[usize]) -> Vec<&'c O::Bit> {\n+    pub fn interpret_set<'c>(&self, ctxt: &'c O::Ctxt, words: &IdxSet<O::Idx>) -> Vec<&'c O::Bit> {\n         let mut v = Vec::new();\n         self.each_bit(ctxt, words, |i| {\n             v.push(self.operator.interpret(ctxt, i));\n@@ -316,11 +334,6 @@ impl<O: BitDenotation> DataflowState<O> {\n     }\n }\n \n-pub trait BitwiseOperator {\n-    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n-    fn join(&self, pred1: usize, pred2: usize) -> usize;\n-}\n-\n /// Parameterization for the precise form of data flow that is used.\n pub trait DataflowOperator: BitwiseOperator {\n     /// Specifies the initial value for each bit in the `on_entry` set\n@@ -331,6 +344,9 @@ pub trait BitDenotation {\n     /// Specifies what is represented by each bit in the dataflow bitvector.\n     type Bit;\n \n+    /// Specifies what index type is used to access the bitvector.\n+    type Idx: Idx;\n+\n     /// Specifies what, if any, separate context needs to be supplied for methods below.\n     type Ctxt;\n \n@@ -359,7 +375,7 @@ pub trait BitDenotation {\n     /// (Typically this should only modify `sets.on_entry`, since the\n     /// gen and kill sets should reflect the effects of *executing*\n     /// the start block itself.)\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets);\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<Self::Idx>);\n \n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating statement.\n@@ -373,7 +389,7 @@ pub trait BitDenotation {\n     /// in the basic block.\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets,\n+                        sets: &mut BlockSets<Self::Idx>,\n                         bb: repr::BasicBlock,\n                         idx_stmt: usize);\n \n@@ -393,7 +409,7 @@ pub trait BitDenotation {\n     /// terminator took.\n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets,\n+                         sets: &mut BlockSets<Self::Idx>,\n                          bb: repr::BasicBlock,\n                          idx_term: usize);\n \n@@ -411,21 +427,17 @@ pub trait BitDenotation {\n     /// flow-dependent, the current MIR cannot encode them via just\n     /// GEN and KILL sets attached to the block, and so instead we add\n     /// this extra machinery to represent the flow-dependent effect.\n-    ///\n-    /// Note: as a historical artifact, this currently takes as input\n-    /// the *entire* packed collection of bitvectors in `in_out`.  We\n-    /// might want to look into narrowing that to something more\n-    /// specific, just to make the interface more self-documenting.\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n-                             in_out: &mut [usize],\n+                             in_out: &mut IdxSet<Self::Idx>,\n                              call_bb: repr::BasicBlock,\n                              dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue);\n }\n \n impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n-    where D: BitDenotation + DataflowOperator, D::Ctxt: HasMoveData<'tcx>\n+    where D: BitDenotation + DataflowOperator,\n+          D::Ctxt: HasMoveData<'tcx>\n {\n     pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n@@ -434,33 +446,41 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         let bits_per_block = denotation.bits_per_block(&ctxt);\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-        let num_blocks = mir.basic_blocks.len();\n-        let num_words = num_blocks * words_per_block;\n \n-        let entry = if D::bottom_value() { usize::MAX } else {0};\n+        // (now rounded up to multiple of word size)\n+        let bits_per_block = words_per_block * usize_bits;\n \n-        let zeroes = Bits::new(0, num_words);\n-        let on_entry = Bits::new(entry, num_words);\n+        let num_blocks = mir.basic_blocks.len();\n+        let num_overall = num_blocks * bits_per_block;\n \n-        DataflowAnalysis { flow_state: DataflowState {\n-            sets: AllSets {\n-                bits_per_block: bits_per_block,\n-                words_per_block: words_per_block,\n-                gen_sets: zeroes.clone(),\n-                kill_sets: zeroes,\n-                on_entry_sets: on_entry,\n+        let zeroes = Bits::new(OwnIdxSet::new_empty(num_overall));\n+        let on_entry = Bits::new(if D::bottom_value() {\n+            OwnIdxSet::new_filled(num_overall)\n+        } else {\n+            OwnIdxSet::new_empty(num_overall)\n+        });\n+\n+        DataflowAnalysis {\n+            ctxt: ctxt,\n+            mir: mir,\n+            flow_state: DataflowState {\n+                sets: AllSets {\n+                    bits_per_block: bits_per_block,\n+                    words_per_block: words_per_block,\n+                    gen_sets: zeroes.clone(),\n+                    kill_sets: zeroes,\n+                    on_entry_sets: on_entry,\n+                },\n+                operator: denotation,\n             },\n-            operator: denotation,\n-        },\n-                           ctxt: ctxt,\n-                           mir: mir,\n         }\n \n     }\n }\n \n impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n-    where D: BitDenotation + DataflowOperator, D::Ctxt: HasMoveData<'tcx>\n+    where D: BitDenotation + DataflowOperator,\n+          D::Ctxt: HasMoveData<'tcx>,\n {\n     /// Propagates the bits of `in_out` into all the successors of `bb`,\n     /// using bitwise operator denoted by `self.operator`.\n@@ -477,7 +497,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n     /// unwind target).\n     fn propagate_bits_into_graph_successors_of(\n         &mut self,\n-        in_out: &mut [usize],\n+        in_out: &mut IdxSet<D::Idx>,\n         changed: &mut bool,\n         (bb, bb_data): (repr::BasicBlock, &repr::BasicBlockData))\n     {\n@@ -518,11 +538,13 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n-                                         in_out: &[usize],\n+                                         in_out: &IdxSet<D::Idx>,\n                                          changed: &mut bool,\n                                          bb: &repr::BasicBlock) {\n         let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n-        let set_changed = bitwise(entry_set, in_out, &self.flow_state.operator);\n+        let set_changed = bitwise(entry_set.words_mut(),\n+                                  in_out.words(),\n+                                  &self.flow_state.operator);\n         if set_changed {\n             *changed = true;\n         }\n@@ -694,6 +716,7 @@ pub struct MovingOutStatements<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n+    type Idx = MoveOutIndex;\n     type Bit = MoveOut;\n     type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n     fn name() -> &'static str { \"moving_out\" }\n@@ -703,13 +726,13 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n         &ctxt.2.moves[idx]\n     }\n-    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets) {\n+    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n         // no move-statements have been executed prior to function\n         // execution, so this method has no effect on `_sets`.\n     }\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets,\n+                        sets: &mut BlockSets<MoveOutIndex>,\n                         bb: repr::BasicBlock,\n                         idx: usize) {\n         let &(tcx, mir, ref move_data) = ctxt;\n@@ -725,7 +748,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             // Every path deinitialized by a *particular move*\n             // has corresponding bit, \"gen'ed\" (i.e. set)\n             // here, in dataflow vector\n-            zero_to_one(&mut sets.gen_set, *move_index);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n         let bits_per_block = self.bits_per_block(ctxt);\n         match stmt.kind {\n@@ -740,15 +763,15 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                             move_path_index,\n                                             |mpi| for moi in &path_map[mpi] {\n                                                 assert!(moi.idx() < bits_per_block);\n-                                                sets.kill_set.set_bit(moi.idx());\n+                                                sets.kill_set.add(&moi);\n                                             });\n             }\n         }\n     }\n \n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets,\n+                         sets: &mut BlockSets<MoveOutIndex>,\n                          bb: repr::BasicBlock,\n                          statements_len: usize)\n     {\n@@ -761,13 +784,13 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n         let bits_per_block = self.bits_per_block(ctxt);\n         for move_index in &loc_map[loc] {\n             assert!(move_index.idx() < bits_per_block);\n-            zero_to_one(&mut sets.gen_set, *move_index);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n     }\n \n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n-                             in_out: &mut [usize],\n+                             in_out: &mut IdxSet<MoveOutIndex>,\n                              _call_bb: repr::BasicBlock,\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n@@ -782,63 +805,46 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                     move_path_index,\n                                     |mpi| for moi in &path_map[mpi] {\n                                         assert!(moi.idx() < bits_per_block);\n-                                        in_out.clear_bit(moi.idx());\n+                                        in_out.remove(&moi);\n                                     });\n     }\n }\n \n impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: super::DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => {\n-                sets.gen_set.clear_bit(path.idx());\n-                sets.kill_set.set_bit(path.idx());\n-            }\n-            DropFlagState::Present => {\n-                sets.gen_set.set_bit(path.idx());\n-                sets.kill_set.clear_bit(path.idx());\n-            }\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n         }\n     }\n }\n \n impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: super::DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => {\n-                sets.gen_set.set_bit(path.idx());\n-                sets.kill_set.clear_bit(path.idx());\n-            }\n-            DropFlagState::Present => {\n-                sets.gen_set.clear_bit(path.idx());\n-                sets.kill_set.set_bit(path.idx());\n-            }\n+            DropFlagState::Absent => sets.gen(&path),\n+            DropFlagState::Present => sets.kill(&path),\n         }\n     }\n }\n \n impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: super::DropFlagState)\n     {\n         match state {\n-            DropFlagState::Absent => {\n-                sets.gen_set.clear_bit(path.idx());\n-                sets.kill_set.set_bit(path.idx());\n-            }\n-            DropFlagState::Present => {\n-                sets.gen_set.set_bit(path.idx());\n-                sets.kill_set.clear_bit(path.idx());\n-            }\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n         }\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n     type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n     fn name() -> &'static str { \"maybe_init\" }\n@@ -848,19 +854,19 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n         &ctxt.2.move_paths[MovePathIndex::new(idx)]\n     }\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets)\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n     {\n         super::drop_flag_effects_for_function_entry(\n             ctxt.0, ctxt.1, &ctxt.2,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.set_bit(path.idx());\n+                sets.on_entry.add(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets,\n+                        sets: &mut BlockSets<MovePathIndex>,\n                         bb: repr::BasicBlock,\n                         idx: usize)\n     {\n@@ -873,7 +879,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n \n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets,\n+                         sets: &mut BlockSets<MovePathIndex>,\n                          bb: repr::BasicBlock,\n                          statements_len: usize)\n     {\n@@ -886,7 +892,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n \n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n-                             in_out: &mut [usize],\n+                             in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: repr::BasicBlock,\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n@@ -897,12 +903,13 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n         super::on_all_children_bits(\n             ctxt.0, ctxt.1, &ctxt.2,\n             move_path_index,\n-            |mpi| { in_out.set_bit(mpi.idx()); }\n+            |mpi| { in_out.add(&mpi); }\n         );\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n     type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n     fn name() -> &'static str { \"maybe_uninit\" }\n@@ -914,21 +921,21 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n \n     // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets) {\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        for e in &mut sets.on_entry[..] { *e = !0; }\n+        for e in sets.on_entry.words_mut() { *e = !0; }\n \n         super::drop_flag_effects_for_function_entry(\n             ctxt.0, ctxt.1, &ctxt.2,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.clear_bit(path.idx());\n+                sets.on_entry.remove(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets,\n+                        sets: &mut BlockSets<MovePathIndex>,\n                         bb: repr::BasicBlock,\n                         idx: usize)\n     {\n@@ -941,7 +948,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n \n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets,\n+                         sets: &mut BlockSets<MovePathIndex>,\n                          bb: repr::BasicBlock,\n                          statements_len: usize)\n     {\n@@ -954,7 +961,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n \n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n-                             in_out: &mut [usize],\n+                             in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: repr::BasicBlock,\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n@@ -964,12 +971,13 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n         super::on_all_children_bits(\n             ctxt.0, ctxt.1, &ctxt.2,\n             move_path_index,\n-            |mpi| { in_out.clear_bit(mpi.idx()); }\n+            |mpi| { in_out.remove(&mpi); }\n         );\n     }\n }\n \n impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n     type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n     fn name() -> &'static str { \"definite_init\" }\n@@ -981,20 +989,20 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n \n     // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets) {\n-        for e in &mut sets.on_entry[..] { *e = 0; }\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+        for e in sets.on_entry.words_mut() { *e = 0; }\n \n         super::drop_flag_effects_for_function_entry(\n             ctxt.0, ctxt.1, &ctxt.2,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n-                sets.on_entry.set_bit(path.idx());\n+                sets.on_entry.add(&path);\n             });\n     }\n \n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets,\n+                        sets: &mut BlockSets<MovePathIndex>,\n                         bb: repr::BasicBlock,\n                         idx: usize)\n     {\n@@ -1007,7 +1015,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n \n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets,\n+                         sets: &mut BlockSets<MovePathIndex>,\n                          bb: repr::BasicBlock,\n                          statements_len: usize)\n     {\n@@ -1020,7 +1028,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n \n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n-                             in_out: &mut [usize],\n+                             in_out: &mut IdxSet<MovePathIndex>,\n                              _call_bb: repr::BasicBlock,\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n@@ -1030,7 +1038,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n         super::on_all_children_bits(\n             ctxt.0, ctxt.1, &ctxt.2,\n             move_path_index,\n-            |mpi| { in_out.set_bit(mpi.idx()); }\n+            |mpi| { in_out.add(&mpi); }\n         );\n     }\n }\n@@ -1106,26 +1114,3 @@ impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-#[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n-                               in_vec: &[usize],\n-                               op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-struct Union;\n-impl BitwiseOperator for Union {\n-    fn join(&self, a: usize, b: usize) -> usize { a | b }\n-}\n-struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n-}"}, {"sha": "6cf20def0e0c497a7d5f66ab3b6516585f26b058", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -15,10 +15,7 @@ use syntax::codemap::Span;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};\n \n-use bitslice::BitSlice;\n-\n-use super::super::gather_moves::MovePath;\n-use super::{bitwise, Union, Subtract};\n+use super::super::gather_moves::{MovePath, MovePathIndex};\n use super::BitDenotation;\n use super::DataflowResults;\n use super::HasMoveData;\n@@ -45,7 +42,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 _attributes: &[ast::Attribute],\n                                                 flow_ctxt: &O::Ctxt,\n                                                 results: &DataflowResults<O>)\n-    where O: BitDenotation<Bit=MovePath<'tcx>>, O::Ctxt: HasMoveData<'tcx>\n+    where O: BitDenotation<Bit=MovePath<'tcx>, Idx=MovePathIndex>, O::Ctxt: HasMoveData<'tcx>\n {\n     debug!(\"sanity_check_via_rustc_peek id: {:?}\", id);\n     // FIXME: this is not DRY. Figure out way to abstract this and\n@@ -87,9 +84,9 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // include terminator (since we are peeking the state of the\n         // argument at time immediate preceding Call to `rustc_peek`).\n \n-        let mut sets = super::BlockSets { on_entry: &mut entry[..],\n-                                          gen_set: &mut gen[..],\n-                                          kill_set: &mut kill[..] };\n+        let mut sets = super::BlockSets { on_entry: &mut entry,\n+                                          gen_set: &mut gen,\n+                                          kill_set: &mut kill };\n \n         for (j, stmt) in statements.iter().enumerate() {\n             debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n@@ -105,7 +102,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                          ref peeking_at_lval) = *rvalue {\n                     // Okay, our search is over.\n                     let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n-                    let bit_state = sets.on_entry.get_bit(peek_mpi.idx());\n+                    let bit_state = sets.on_entry.contains(&peek_mpi);\n                     debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n                            lvalue, peeking_at_lval, bit_state);\n                     if !bit_state {\n@@ -126,11 +123,11 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n                    lvalue, lhs_mpi, stmt);\n             // reset GEN and KILL sets before emulating their effect.\n-            for e in &mut sets.gen_set[..] { *e = 0; }\n-            for e in &mut sets.kill_set[..] { *e = 0; }\n+            for e in sets.gen_set.words_mut() { *e = 0; }\n+            for e in sets.kill_set.words_mut() { *e = 0; }\n             results.0.operator.statement_effect(flow_ctxt, &mut sets, bb, j);\n-            bitwise(sets.on_entry, sets.gen_set, &Union);\n-            bitwise(sets.on_entry, sets.kill_set, &Subtract);\n+            sets.on_entry.union(sets.gen_set);\n+            sets.on_entry.subtract(sets.kill_set);\n         }\n \n         tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\"}, {"sha": "e196de46ee67181b790c0a609e8a09dc03f69550", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -20,6 +20,7 @@ use std::iter;\n use std::ops::Index;\n \n use super::abs_domain::{AbstractElem, Lift};\n+use indexed_set::{Idx, Indexed};\n \n // This submodule holds some newtype'd Index wrappers that are using\n // NonZero to ensure that Option<Index> occupies only a single word.\n@@ -28,17 +29,21 @@ use super::abs_domain::{AbstractElem, Lift};\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n     use core::nonzero::NonZero;\n+    use indexed_set::Idx;\n \n     macro_rules! new_index {\n         ($Index:ident) => {\n             #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n             pub struct $Index(NonZero<usize>);\n \n             impl $Index {\n-                pub fn new(idx: usize) -> Self {\n+            }\n+\n+            impl Idx for $Index {\n+                fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n-                pub fn idx(&self) -> usize {\n+                fn idx(&self) -> usize {\n                     *self.0 - 1\n                 }\n             }\n@@ -55,6 +60,14 @@ mod indexes {\n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n+impl<'tcx> Indexed for MovePath<'tcx> {\n+    type Idx = MovePathIndex;\n+}\n+\n+impl Indexed for MoveOut {\n+    type Idx = MoveOutIndex;\n+}\n+\n impl self::indexes::MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n         move_data.moves[self.idx()].path"}, {"sha": "c37f8e09e0ac2b1bf88f24757b8a99d6012b929c", "filename": "src/librustc_borrowck/indexed_set.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71af40bb9dd5887ce9797e73f608b48b0f41355b/src%2Flibrustc_borrowck%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Findexed_set.rs?ref=71af40bb9dd5887ce9797e73f608b48b0f41355b", "patch": "@@ -11,13 +11,16 @@\n use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n+use std::ops::{Deref, DerefMut, Range};\n use bitslice::{BitSlice, Word};\n+use bitslice::{bitwise, Union, Subtract};\n \n pub trait Indexed {\n     type Idx: Idx;\n }\n \n-pub trait Idx {\n+pub trait Idx: 'static {\n+    fn new(usize) -> Self;\n     fn idx(&self) -> usize;\n }\n \n@@ -26,10 +29,16 @@ pub struct OwnIdxSet<T: Idx> {\n     bits: Vec<Word>,\n }\n \n+impl<T: Idx> Clone for OwnIdxSet<T> {\n+    fn clone(&self) -> Self {\n+        OwnIdxSet { _pd: PhantomData, bits: self.bits.clone() }\n+    }\n+}\n+\n // pnkfelix wants to have this be `IdxSet<T>([Word]) and then pass\n // around `&mut IdxSet<T>` or `&IdxSet<T>`.\n //\n-// Mmapping a `&OwnIdxSet<T>` to `&IdxSet<T>` (at least today)\n+// WARNING: Mapping a `&OwnIdxSet<T>` to `&IdxSet<T>` (at least today)\n // requires a transmute relying on representation guarantees that may\n // not hold in the future.\n \n@@ -65,9 +74,41 @@ impl<T: Idx> OwnIdxSet<T> {\n     pub fn new_empty(universe_size: usize) -> Self {\n         Self::new(0, universe_size)\n     }\n+}\n+\n+impl<T: Idx> IdxSet<T> {\n+    unsafe fn from_slice(s: &[Word]) -> &Self {\n+        mem::transmute(s) // (see above WARNING)\n+    }\n+\n+    unsafe fn from_slice_mut(s: &mut [Word]) -> &mut Self {\n+        mem::transmute(s) // (see above WARNING)\n+    }\n+}\n+\n+impl<T: Idx> Deref for OwnIdxSet<T> {\n+    type Target = IdxSet<T>;\n+    fn deref(&self) -> &IdxSet<T> {\n+        unsafe { IdxSet::from_slice(&self.bits[..]) }\n+    }\n+}\n+\n+impl<T: Idx> DerefMut for OwnIdxSet<T> {\n+    fn deref_mut(&mut self) -> &mut IdxSet<T> {\n+        unsafe { IdxSet::from_slice_mut(&mut self.bits[..]) }\n+    }\n+}\n+\n+impl<T: Idx> IdxSet<T> {\n+    pub fn to_owned(&self) -> OwnIdxSet<T> {\n+        OwnIdxSet {\n+            _pd: Default::default(),\n+            bits: self.bits.to_owned(),\n+        }\n+    }\n \n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n-    pub fn clear(&mut self, elem: &T) -> bool {\n+    pub fn remove(&mut self, elem: &T) -> bool {\n         self.bits.clear_bit(elem.idx())\n     }\n \n@@ -76,12 +117,38 @@ impl<T: Idx> OwnIdxSet<T> {\n         self.bits.set_bit(elem.idx())\n     }\n \n+    pub fn range(&self, elems: &Range<T>) -> &Self {\n+        let elems = elems.start.idx()..elems.end.idx();\n+        unsafe { Self::from_slice(&self.bits[elems]) }\n+    }\n+\n+    pub fn range_mut(&mut self, elems: &Range<T>) -> &mut Self {\n+        let elems = elems.start.idx()..elems.end.idx();\n+        unsafe { Self::from_slice_mut(&mut self.bits[elems]) }\n+    }\n+\n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n         self.bits.get_bit(elem.idx())\n     }\n \n-    pub fn bits(&self) -> &[Word] {\n+    pub fn words(&self) -> &[Word] {\n         &self.bits[..]\n     }\n+\n+    pub fn words_mut(&mut self) -> &mut [Word] {\n+        &mut self.bits[..]\n+    }\n+\n+    pub fn clone_from(&mut self, other: &IdxSet<T>) {\n+        self.words_mut().clone_from_slice(other.words());\n+    }\n+\n+    pub fn union(&mut self, other: &IdxSet<T>) -> bool {\n+        bitwise(self.words_mut(), other.words(), &Union)\n+    }\n+\n+    pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n+        bitwise(self.words_mut(), other.words(), &Subtract)\n+    }\n }"}]}