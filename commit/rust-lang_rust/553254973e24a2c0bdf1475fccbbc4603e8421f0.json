{"sha": "553254973e24a2c0bdf1475fccbbc4603e8421f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MzI1NDk3M2UyNGEyYzBiZGYxNDc1ZmNjYmJjNDYwM2U4NDIxZjA=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-26T16:12:26Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-26T16:12:26Z"}, "message": "Skip trival token in original_range", "tree": {"sha": "a97feb3e004489c7b9896ba753a891cc7c07a8e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a97feb3e004489c7b9896ba753a891cc7c07a8e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553254973e24a2c0bdf1475fccbbc4603e8421f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553254973e24a2c0bdf1475fccbbc4603e8421f0", "html_url": "https://github.com/rust-lang/rust/commit/553254973e24a2c0bdf1475fccbbc4603e8421f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553254973e24a2c0bdf1475fccbbc4603e8421f0/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dee0779e9977e4570122c42ac35c4183bb8e604", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dee0779e9977e4570122c42ac35c4183bb8e604", "html_url": "https://github.com/rust-lang/rust/commit/2dee0779e9977e4570122c42ac35c4183bb8e604"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "5b0b94e34d44c4a020ecb5ff9d3c5492b132d7f6", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=553254973e24a2c0bdf1475fccbbc4603e8421f0", "patch": "@@ -8,8 +8,9 @@ use hir_def::{\n };\n use ra_db::{FileId, FileRange};\n use ra_syntax::{\n-    algo::find_covering_element, ast, match_ast, AstNode, NodeOrToken, SyntaxElement, SyntaxNode,\n-    SyntaxToken, TextRange, TextUnit,\n+    algo::{find_covering_element, skip_trivia_token},\n+    ast, match_ast, AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n+    TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -384,11 +385,12 @@ fn original_range_and_origin(\n     };\n \n     // the input node has only one token ?\n-    let single = node.value.first_token()? == node.value.last_token()?;\n+    let single = skip_trivia_token(node.value.first_token()?, Direction::Next)?\n+        == skip_trivia_token(node.value.last_token()?, Direction::Prev)?;\n \n     return Some(node.value.descendants().find_map(|it| {\n-        let first = it.first_token()?;\n-        let last = it.last_token()?;\n+        let first = skip_trivia_token(it.first_token()?, Direction::Next)?;\n+        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n \n         if !single && first == last {\n             return None;"}, {"sha": "2e09bd1ec3faa3ac8d1f818dee74915d82c68ec8", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=553254973e24a2c0bdf1475fccbbc4603e8421f0", "patch": "@@ -5,7 +5,7 @@ use std::iter::successors;\n use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo::{self, find_covering_element},\n+    algo::{self, find_covering_element, skip_trivia_token},\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken,\n     SyntaxKind::{self, *},\n@@ -118,14 +118,14 @@ fn extend_tokens_from_range(\n         NodeOrToken::Token(it) => (it.clone(), it),\n     };\n \n-    let mut first_token = skip_whitespace(first_token, Direction::Next)?;\n-    let mut last_token = skip_whitespace(last_token, Direction::Prev)?;\n+    let mut first_token = skip_trivia_token(first_token, Direction::Next)?;\n+    let mut last_token = skip_trivia_token(last_token, Direction::Prev)?;\n \n     while !first_token.text_range().is_subrange(&original_range) {\n-        first_token = skip_whitespace(first_token.next_token()?, Direction::Next)?;\n+        first_token = skip_trivia_token(first_token.next_token()?, Direction::Next)?;\n     }\n     while !last_token.text_range().is_subrange(&original_range) {\n-        last_token = skip_whitespace(last_token.prev_token()?, Direction::Prev)?;\n+        last_token = skip_trivia_token(last_token.prev_token()?, Direction::Prev)?;\n     }\n \n     // compute original mapped token range\n@@ -149,14 +149,14 @@ fn extend_tokens_from_range(\n     // Find the first and last text range under expanded parent\n     let first = successors(Some(first_token), |token| {\n         let token = token.prev_token()?;\n-        skip_whitespace(token, Direction::Prev)\n+        skip_trivia_token(token, Direction::Prev)\n     })\n     .take_while(validate)\n     .last()?;\n \n     let last = successors(Some(last_token), |token| {\n         let token = token.next_token()?;\n-        skip_whitespace(token, Direction::Next)\n+        skip_trivia_token(token, Direction::Next)\n     })\n     .take_while(validate)\n     .last()?;\n@@ -169,16 +169,6 @@ fn extend_tokens_from_range(\n     }\n }\n \n-fn skip_whitespace(mut token: SyntaxToken, direction: Direction) -> Option<SyntaxToken> {\n-    while token.kind() == WHITESPACE {\n-        token = match direction {\n-            Direction::Next => token.next_token()?,\n-            Direction::Prev => token.prev_token()?,\n-        }\n-    }\n-    Some(token)\n-}\n-\n fn union_range(range: TextRange, r: TextRange) -> TextRange {\n     let start = range.start().min(r.start());\n     let end = range.end().max(r.end());"}, {"sha": "177038e206642b1d150070ca033c42a00696af28", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=553254973e24a2c0bdf1475fccbbc4603e8421f0", "patch": "@@ -174,6 +174,10 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         .ancestors()\n         .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n \n+    // FIXME: Currently `hover::typeof` do not work inside\n+    // macro expansion such that if the hover range is pointing to\n+    // a string literal, the following type_of will return None.\n+    // See also `test_hover_through_literal_string_in_macro`\n     let frange = sema.original_range(&node);\n     res.extend(type_of(db, frange).map(rust_code_markup));\n     if res.is_empty() {\n@@ -250,6 +254,11 @@ mod tests {\n         content[hover.range].to_string()\n     }\n \n+    fn check_hover_no_result(fixture: &str) {\n+        let (analysis, position) = analysis_and_position(fixture);\n+        assert!(analysis.hover(position).unwrap().is_none());\n+    }\n+\n     #[test]\n     fn hover_shows_type_of_an_expression() {\n         let (analysis, position) = single_file_with_position(\n@@ -774,6 +783,24 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         assert_eq!(hover_on, \"bar\")\n     }\n \n+    #[test]\n+    fn test_hover_through_literal_string_in_macro() {\n+        // FIXME: Currently `hover::type_of` do not work inside\n+        // macro expansion\n+        check_hover_no_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! arr {\n+                ($($tt:tt)*) => { [$($tt)*)] }\n+            }\n+            fn foo() {\n+                let mastered_for_itunes = \"\";\n+                let _ = arr!(\"Tr<|>acks\", &mastered_for_itunes);\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_hover_non_ascii_space_doc() {\n         check_hover_result("}, {"sha": "ebf59288a3f096a25204316a05c4293088ece9ac", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553254973e24a2c0bdf1475fccbbc4603e8421f0/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=553254973e24a2c0bdf1475fccbbc4603e8421f0", "patch": "@@ -7,7 +7,8 @@ use ra_text_edit::TextEditBuilder;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n-    AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n+    AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n+    TextRange, TextUnit,\n };\n \n /// Returns ancestors of the node at the offset, sorted by length. This should\n@@ -37,6 +38,17 @@ pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) ->\n     ancestors_at_offset(syntax, offset).find_map(N::cast)\n }\n \n+/// Skip to next non `trivia` token\n+pub fn skip_trivia_token(mut token: SyntaxToken, direction: Direction) -> Option<SyntaxToken> {\n+    while token.kind().is_trivia() {\n+        token = match direction {\n+            Direction::Next => token.next_token()?,\n+            Direction::Prev => token.prev_token()?,\n+        }\n+    }\n+    Some(token)\n+}\n+\n /// Finds the first sibling in the given direction which is not `trivia`\n pub fn non_trivia_sibling(element: SyntaxElement, direction: Direction) -> Option<SyntaxElement> {\n     return match element {"}]}