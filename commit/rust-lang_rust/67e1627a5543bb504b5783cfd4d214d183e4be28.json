{"sha": "67e1627a5543bb504b5783cfd4d214d183e4be28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZTE2MjdhNTU0M2JiNTA0YjU3ODNjZmQ0ZDIxNGQxODNlNGJlMjg=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-16T07:55:00Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T06:03:34Z"}, "message": "Rename PrimVal::Pointer to PrimVal::Ptr.\n\nAlso fill out the PrimVal doc comments.", "tree": {"sha": "f0f74cbe0e17cc1737f270dd4c56c5dae04fa8f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0f74cbe0e17cc1737f270dd4c56c5dae04fa8f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e1627a5543bb504b5783cfd4d214d183e4be28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e1627a5543bb504b5783cfd4d214d183e4be28", "html_url": "https://github.com/rust-lang/rust/commit/67e1627a5543bb504b5783cfd4d214d183e4be28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e1627a5543bb504b5783cfd4d214d183e4be28/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36a83171bf0de5a1b8d139363b1b469e273c994", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36a83171bf0de5a1b8d139363b1b469e273c994", "html_url": "https://github.com/rust-lang/rust/commit/b36a83171bf0de5a1b8d139363b1b469e273c994"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "f00dbcec499d90f37b68ff210eb9dc0b7e682505", "filename": "src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=67e1627a5543bb504b5783cfd4d214d183e4be28", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar if v as u8 as u64 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            TyRawPtr(_) => Ok(PrimVal::Pointer(Pointer::from_int(v))),\n+            TyRawPtr(_) => Ok(PrimVal::Ptr(Pointer::from_int(v))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyRef(..) | TyRawPtr(_) | TyFnPtr(_) | TyInt(_) | TyUint(_) =>\n-                Ok(PrimVal::Pointer(ptr)),\n+                Ok(PrimVal::Ptr(ptr)),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }"}, {"sha": "eca0684dcb95affedb3a6f6b4a945c9bcc286f26", "filename": "src/eval_context.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=67e1627a5543bb504b5783cfd4d214d183e4be28", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::Pointer(ptr), PrimVal::from_uint(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_uint(s.len() as u64)))\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                PrimVal::Pointer(ptr)\n+                PrimVal::Ptr(ptr)\n             }\n \n             Struct(_)    => unimplemented!(),\n@@ -563,12 +563,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ref(_, _, ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let (raw_ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n-                let ptr = PrimVal::Pointer(raw_ptr);\n+                let ptr = PrimVal::Ptr(raw_ptr);\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n                     LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_uint(len)),\n-                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Pointer(vtable)),\n+                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::Pointer(ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnDef(def_id, substs, fn_ty) => {\n                             let fn_ty = self.tcx.erase_regions(&fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::Pointer(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n                     },\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let (def_id, substs, _, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx, def_id, substs, unsafe_fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::Pointer(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n@@ -1150,23 +1150,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::Pointer)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::Ptr)?,\n             ty::TyBox(ty) |\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 let p = self.memory.read_ptr(ptr)?;\n                 if self.type_is_sized(ty) {\n-                    PrimVal::Pointer(p)\n+                    PrimVal::Ptr(p)\n                 } else {\n                     trace!(\"reading fat pointer extra of type {}\", ty);\n                     let extra = ptr.offset(self.memory.pointer_size());\n                     let extra = match self.tcx.struct_tail(ty).sty {\n-                        ty::TyDynamic(..) => PrimVal::Pointer(self.memory.read_ptr(extra)?),\n+                        ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n                         ty::TyStr => PrimVal::from_uint(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n-                    return Ok(Some(Value::ByValPair(PrimVal::Pointer(p), extra)));\n+                    return Ok(Some(Value::ByValPair(PrimVal::Ptr(p), extra)));\n                 }\n             }\n \n@@ -1225,7 +1225,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                         let ptr = src.read_ptr(&self.memory)?;\n                         let len = PrimVal::from_uint(length as u64);\n-                        let ptr = PrimVal::Pointer(ptr);\n+                        let ptr = PrimVal::Ptr(ptr);\n                         self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n                     }\n                     (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n@@ -1239,8 +1239,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let trait_ref = self.tcx.erase_regions(&trait_ref);\n                         let vtable = self.get_vtable(trait_ref)?;\n                         let ptr = src.read_ptr(&self.memory)?;\n-                        let ptr = PrimVal::Pointer(ptr);\n-                        let extra = PrimVal::Pointer(vtable);\n+                        let ptr = PrimVal::Ptr(ptr);\n+                        let extra = PrimVal::Ptr(vtable);\n                         self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)?;\n                     },\n "}, {"sha": "732e4f555a9a582f2a4ef4a309344a7c715d3c34", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=67e1627a5543bb504b5783cfd4d214d183e4be28", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n                 let new_ptr = ptr.signed_offset(offset);\n-                self.write_primval(dest, PrimVal::Pointer(new_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.signed_offset(offset * pointee_size);\n-                self.write_primval(dest, PrimVal::Pointer(result_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {"}, {"sha": "06c006baeed720d3836529047fcae47f6aafb5ee", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=67e1627a5543bb504b5783cfd4d214d183e4be28", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64();\n                 let align = self.value_to_primval(args[1], usize)?.to_u64();\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.write_primval(dest, PrimVal::Pointer(ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n             \"__rust_deallocate\" => {\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.value_to_primval(args[2], usize)?.to_u64();\n                 let align = self.value_to_primval(args[3], usize)?.to_u64();\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n-                self.write_primval(dest, PrimVal::Pointer(new_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n             \"memcmp\" => {\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 ptr\n                             },\n                         };\n-                        args[0].0 = Value::ByVal(PrimVal::Pointer(ptr));\n+                        args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n \n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n                     let (self_ptr, vtable) = first_arg.expect_ptr_vtable_pair(&self.memory)?;\n-                    *first_arg = Value::ByVal(PrimVal::Pointer(self_ptr));\n+                    *first_arg = Value::ByVal(PrimVal::Ptr(self_ptr));\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n@@ -633,7 +633,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 // run drop impl before the fields' drop impls\n                 if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, Value::ByVal(PrimVal::Pointer(adt_ptr)), substs));\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::Ptr(adt_ptr)), substs));\n                 }\n                 let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n@@ -701,7 +701,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let (def_id, substs, _abi, sig) = self.memory.get_fn(drop_fn.alloc_id)?;\n                     let real_ty = sig.inputs()[0];\n                     self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                    drop.push((def_id, Value::ByVal(PrimVal::Pointer(ptr)), substs));\n+                    drop.push((def_id, Value::ByVal(PrimVal::Ptr(ptr)), substs));\n                 } else {\n                     // just a sanity check\n                     assert_eq!(drop_fn.offset, 0);"}, {"sha": "943f096c7ed824e5c64f24614312be80ff06acae", "filename": "src/value.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1627a5543bb504b5783cfd4d214d183e4be28/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=67e1627a5543bb504b5783cfd4d214d183e4be28", "patch": "@@ -43,19 +43,22 @@ pub enum Value {\n     ByValPair(PrimVal, PrimVal),\n }\n \n-/// A `PrimVal` represents an immediate, primitive value existing outside of an allocation. It is\n-/// considered to be like a\n+/// A `PrimVal` represents an immediate, primitive value existing outside of a\n+/// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n+/// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n+/// of a simple value, a pointer into another `Allocation`, or be undefined.\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum PrimVal {\n+    /// The raw bytes of a simple value.\n     Bytes(u64),\n \n-    // FIXME(solson): Rename this variant to Ptr.\n-    // FIXME(solson): Outdated comment, pulled from `relocations` field I deleted.\n-    /// This field is initialized when the `PrimVal` represents a pointer into an `Allocation`. An\n-    /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n-    /// large enough to contain one, hence the `Option`.\n-    Pointer(Pointer),\n+    /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n+    /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n+    /// relocation and its associated offset together as a `Pointer` here.\n+    Ptr(Pointer),\n \n+    /// An undefined `PrimVal`, for representing values that aren't safe to examine, but are safe\n+    /// to copy around, just like undefined bytes in an `Allocation`.\n     Undefined,\n }\n \n@@ -119,15 +122,15 @@ impl PrimVal {\n     pub fn bits(&self) -> u64 {\n         match *self {\n             PrimVal::Bytes(b) => b,\n-            PrimVal::Pointer(p) => p.offset,\n+            PrimVal::Ptr(p) => p.offset,\n             PrimVal::Undefined => panic!(\".bits()() on PrimVal::Undefined\"),\n         }\n     }\n \n     // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n     // stick around with this name.\n     pub fn relocation(&self) -> Option<AllocId> {\n-        if let PrimVal::Pointer(ref p) = *self {\n+        if let PrimVal::Ptr(ref p) = *self {\n             Some(p.alloc_id)\n         } else {\n             None"}]}