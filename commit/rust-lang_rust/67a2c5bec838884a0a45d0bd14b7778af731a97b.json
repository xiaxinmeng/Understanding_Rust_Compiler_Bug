{"sha": "67a2c5bec838884a0a45d0bd14b7778af731a97b", "node_id": "C_kwDOAAsO6NoAKDY3YTJjNWJlYzgzODg4NGEwYTQ1ZDBiZDE0Yjc3NzhhZjczMWE5N2I", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-03-19T17:32:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-03-22T09:55:55Z"}, "message": "rustc: Remove unused `Session` argument from some attribute functions", "tree": {"sha": "d2eed50231a5d3cc518782e0b114d0a6b88d8509", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2eed50231a5d3cc518782e0b114d0a6b88d8509"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67a2c5bec838884a0a45d0bd14b7778af731a97b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67a2c5bec838884a0a45d0bd14b7778af731a97b", "html_url": "https://github.com/rust-lang/rust/commit/67a2c5bec838884a0a45d0bd14b7778af731a97b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67a2c5bec838884a0a45d0bd14b7778af731a97b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89", "html_url": "https://github.com/rust-lang/rust/commit/9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89"}], "stats": {"total": 472, "additions": 173, "deletions": 299}, "files": [{"sha": "c4771115cacf2b868a584e42a31873ea346dc432", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -180,6 +180,12 @@ impl Attribute {\n         self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n     }\n \n+    pub fn is_proc_macro_attr(&self) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.has_name(*kind))\n+    }\n+\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match &self.kind {\n@@ -627,6 +633,22 @@ pub fn mk_attr_name_value_str(\n     mk_attr(g, style, path, args, span)\n }\n \n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n+    attrs.iter().filter(move |attr| attr.has_name(name))\n+}\n+\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n+    filter_by_name(attrs, name).next()\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n+    find_by_name(attrs, name).and_then(|attr| attr.value_str())\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n+    find_by_name(attrs, name).is_some()\n+}\n+\n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }"}, {"sha": "0b6b02ba00fb59f6e5f3c7fc2839e4eed983d3be", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -2185,7 +2185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             def_id: self.local_def_id(param.id),\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n             source,"}, {"sha": "93c854cc8094286560acfbfc133c4171e7220188", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -799,11 +799,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| attr.is_proc_macro_attr()) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -973,7 +973,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n-                    && !self.session.contains_name(&item.attrs, sym::path)\n+                    && !attr::contains_name(&item.attrs, sym::path)\n                 {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n@@ -1248,7 +1248,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n "}, {"sha": "344a1e7f5e795d2bd8078421f4f62f103780ac32", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n+use rustc_ast::{attr, AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n@@ -232,7 +232,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if self.sess.contains_name(&i.attrs, sym::start) {\n+                if attr::contains_name(&i.attrs, sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -245,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n+                for attr in attr::filter_by_name(&i.attrs, sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -306,7 +306,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm =\n                     link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {"}, {"sha": "d6dbdd3975e93e3fba93551b4529d2ff7de307c8", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n@@ -556,8 +556,8 @@ where\n     (stab, const_stab, body_stab)\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n #[derive(Clone, Debug)]\n@@ -1177,7 +1177,7 @@ fn allow_unstable<'a>(\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n ) -> impl Iterator<Item = Symbol> + 'a {\n-    let attrs = sess.filter_by_name(attrs, symbol);\n+    let attrs = attr::filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {"}, {"sha": "cc32739d083c729f09dc6fe1b1b678a8093f02af", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use rustc_ast as ast;\n-use rustc_ast::{walk_list, EnumDef, VariantData};\n+use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -106,7 +106,7 @@ fn extract_default_variant<'a>(\n     let default_variants: SmallVec<[_; 1]> = enum_def\n         .variants\n         .iter()\n-        .filter(|variant| cx.sess.contains_name(&variant.attrs, kw::Default))\n+        .filter(|variant| attr::contains_name(&variant.attrs, kw::Default))\n         .collect();\n \n     let variant = match default_variants.as_slice() {\n@@ -116,7 +116,7 @@ fn extract_default_variant<'a>(\n                 .variants\n                 .iter()\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n-                .filter(|variant| !cx.sess.contains_name(&variant.attrs, sym::non_exhaustive));\n+                .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n             let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n             diag.help(\"make a unit variant default by placing `#[default]` above it\");\n@@ -146,7 +146,7 @@ fn extract_default_variant<'a>(\n                         if v.span == variant.span {\n                             None\n                         } else {\n-                            Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n+                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n                         }\n                     })\n                     .collect();\n@@ -174,7 +174,7 @@ fn extract_default_variant<'a>(\n         return Err(());\n     }\n \n-    if let Some(non_exhaustive_attr) = cx.sess.find_by_name(&variant.attrs, sym::non_exhaustive) {\n+    if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n         cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n             .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n             .help(\"consider a manual implementation of `Default`\")\n@@ -191,7 +191,7 @@ fn validate_default_attribute(\n     default_variant: &rustc_ast::Variant,\n ) -> Result<(), ()> {\n     let attrs: SmallVec<[_; 1]> =\n-        cx.sess.filter_by_name(&default_variant.attrs, kw::Default).collect();\n+        attr::filter_by_name(&default_variant.attrs, kw::Default).collect();\n \n     let attr = match attrs.as_slice() {\n         [attr] => attr,"}, {"sha": "a73fed6ccb222e466c66bccda77848729b222759", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast::{self as ast, attr, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{parse_macro_name_and_helper_attrs, ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n@@ -34,7 +34,6 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -56,7 +55,6 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n-        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -160,7 +158,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -176,7 +174,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if self.sess.is_proc_macro_attr(&attr) {\n+            if attr.is_proc_macro_attr() {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();"}, {"sha": "caed40d9fa81b02e5e00e160ca43e7b0132a840c", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n@@ -16,10 +16,10 @@ pub fn inject(\n     let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return krate;\n-    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n-        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n+        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]"}, {"sha": "44b9c4718a75feec636591e387204d5afb3b36c3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,12 +1,11 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_expand::base::*;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileNameDisplayPreference, Span};\n use std::iter;\n@@ -291,14 +290,11 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\n-                                        \"ignore\",\n-                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n-                                    ),\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item)),),\n                                     // ignore_message: Some(\"...\") | None\n                                     field(\n                                         \"ignore_message\",\n-                                        if let Some(msg) = should_ignore_message(cx, &item) {\n+                                        if let Some(msg) = should_ignore_message(&item) {\n                                             cx.expr_some(sp, cx.expr_str(sp, msg))\n                                         } else {\n                                             cx.expr_none(sp)\n@@ -425,12 +421,12 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n-    sess.contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n-    match cx.sess.find_by_name(&i.attrs, sym::ignore) {\n+fn should_ignore_message(i: &ast::Item) -> Option<Symbol> {\n+    match attr::find_by_name(&i.attrs, sym::ignore) {\n         Some(attr) => {\n             match attr.meta_item_list() {\n                 // Handle #[ignore(bar = \"foo\")]\n@@ -444,7 +440,7 @@ fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let sd = &cx.sess.parse_sess.span_diagnostic;\n \n@@ -510,7 +506,7 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {"}, {"sha": "2d491b2dac8b250bbfdb410c4aa5a352415ddad7", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -47,11 +47,11 @@ pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n \n     if sess.opts.test {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n@@ -123,7 +123,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if let Some(name) = get_test_name(&self.cx.ext_cx.sess, &item) {\n+        if let Some(name) = get_test_name(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident, name };\n@@ -145,12 +145,12 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n // Beware, this is duplicated in librustc_passes/entry.rs (with\n // `rustc_hir::Item`), so make sure to keep them in sync.\n-fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {\n     match item.kind {\n         ast::ItemKind::Fn(..) => {\n-            if sess.contains_name(&item.attrs, sym::start) {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n+            } else if attr::contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::RustcMainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 0 {\n@@ -184,7 +184,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         // Remove any #[rustc_main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry_point_type(self.sess, &item, self.depth) {\n+        let item = match entry_point_type(&item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_dead_code = attr::mk_attr_nested_word(\n@@ -373,16 +373,12 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn get_test_name(sess: &Session, i: &ast::Item) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n+fn get_test_name(i: &ast::Item) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(\n-    sess: &Session,\n-    sd: &rustc_errors::Handler,\n-    krate: &ast::Crate,\n-) -> Option<ast::Path> {\n-    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "9463a1418ce31bc5242c3288155c51a2d8a482c7", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{attr, AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -36,7 +36,7 @@ pub fn warn_on_duplicate_attribute(ecx: &ExtCtxt<'_>, item: &Annotatable, name:\n         _ => None,\n     };\n     if let Some(attrs) = attrs {\n-        if let Some(attr) = ecx.sess.find_by_name(attrs, name) {\n+        if let Some(attr) = attr::find_by_name(attrs, name) {\n             ecx.parse_sess().buffer_lint(\n                 DUPLICATE_MACRO_ATTRIBUTES,\n                 attr.span,"}, {"sha": "ff2b005d757672cf666734e0890cba1c5abc8e40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -5,12 +5,12 @@ use crate::llvm;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::value::Value;\n+use rustc_ast::attr;\n use rustc_codegen_ssa::base::collect_debugger_visualizers_transitive;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_session::config::{CrateType, DebugInfo};\n-\n use rustc_span::symbol::sym;\n use rustc_span::DebuggerVisualizerType;\n \n@@ -87,7 +87,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        cx.tcx.sess.contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+        attr::contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     // To ensure the section `__rustc_debug_gdb_scripts_section__` will not create\n     // ODR violations at link time, this section will not be emitted for rlibs since"}, {"sha": "7ce72d2172799ceaeb85ce9f0345f29d04cfbb82", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n use jobserver::{Acquired, Client};\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -447,8 +448,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n-    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let no_builtins = attr::contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = attr::contains_name(crate_attrs, sym::compiler_builtins);\n \n     let crate_info = CrateInfo::new(tcx, target_cpu);\n "}, {"sha": "4d34b3da5f501e82750fc61188390eefa953650f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -809,7 +809,7 @@ impl CrateInfo {\n             .collect();\n         let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-        let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+        let subsystem = attr::first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n                 tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });"}, {"sha": "6eb0d24eb976ea253a8007c428540dacfb68bf92", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -776,16 +776,14 @@ impl SyntaxExtension {\n         let allow_internal_unstable =\n             attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>();\n \n-        let allow_internal_unsafe = sess.contains_name(attrs, sym::allow_internal_unsafe);\n-        let local_inner_macros = sess\n-            .find_by_name(attrs, sym::macro_export)\n+        let allow_internal_unsafe = attr::contains_name(attrs, sym::allow_internal_unsafe);\n+        let local_inner_macros = attr::find_by_name(attrs, sym::macro_export)\n             .and_then(|macro_export| macro_export.meta_item_list())\n             .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n-        let collapse_debuginfo = sess.contains_name(attrs, sym::collapse_debuginfo);\n+        let collapse_debuginfo = attr::contains_name(attrs, sym::collapse_debuginfo);\n         tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n-        let (builtin_name, helper_attrs) = sess\n-            .find_by_name(attrs, sym::rustc_builtin_macro)\n+        let (builtin_name, helper_attrs) = attr::find_by_name(attrs, sym::rustc_builtin_macro)\n             .map(|attr| {\n                 // Override `helper_attrs` passed above if it's a built-in macro,\n                 // marking `proc_macro_derive` macros as built-in is not a realistic use case."}, {"sha": "1c58caa03532eaaf5ecf7e3868a02e619d021360", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -8,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n \n     for id in tcx.hir().items() {\n         let attrs = tcx.hir().attrs(id.hir_id());\n-        if tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+        if attr::contains_name(attrs, sym::rustc_proc_macro_decls) {\n             decls = Some(id.owner_id.def_id);\n         }\n     }"}, {"sha": "8abdcebb7516d373796c4d53471fab75ce75b59b", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -505,7 +505,7 @@ pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> Outpu\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(sess, attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| sess.io.input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "29ba480cdd20e4505f3701c5b9342f35096d76f1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -358,29 +358,29 @@ impl EarlyLintPass for UnsafeCode {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionFn);\n                 }\n             }\n \n             ast::ItemKind::Static(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionStatic);\n                 }\n             }\n@@ -391,10 +391,10 @@ impl EarlyLintPass for UnsafeCode {\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         if let ast::AssocItemKind::Fn(..) = it.kind {\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleMethod);\n             }\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameMethod);\n             }\n         }\n@@ -1123,12 +1123,12 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n         };\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = cx.sess().find_by_name(attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = attr::find_by_name(attrs, sym::no_mangle) {\n                     check_no_mangle_on_generic_fn(no_mangle_attr, None, generics, it.span);\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                if attr::contains_name(attrs, sym::no_mangle) {\n                     // account for \"pub const\" (#45562)\n                     let start = cx\n                         .tcx\n@@ -1152,9 +1152,8 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             hir::ItemKind::Impl(hir::Impl { generics, items, .. }) => {\n                 for it in *items {\n                     if let hir::AssocItemKind::Fn { .. } = it.kind {\n-                        if let Some(no_mangle_attr) = cx\n-                            .sess()\n-                            .find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n+                        if let Some(no_mangle_attr) =\n+                            attr::find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n                         {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n@@ -1836,7 +1835,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n         }\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n-        if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n+        if let Some(attr) = attr::find_by_name(attrs, sym::rustc_test_marker) {\n             cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }"}, {"sha": "9efc14849c76fb1fcb004df4b6f4431d8512aa64", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -328,8 +328,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            cx.sess()\n-                .find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n+            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -489,7 +488,7 @@ impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n-            hir::ItemKind::Static(..) if !cx.sess().contains_name(attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "0dea1c52d1f2fa7ae9340cc11ab159f3c727e35d", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -720,8 +720,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // compilation mode also comes into play.\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n-        let mut needs_panic_runtime =\n-            self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n+        let mut needs_panic_runtime = attr::contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n         for (cnum, data) in self.cstore.iter_crate_data() {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n@@ -789,7 +788,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         info!(\"loading profiler\");\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n-        if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if name == sym::profiler_builtins && attr::contains_name(&krate.attrs, sym::no_core) {\n             self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n@@ -803,14 +802,14 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n-        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess\n                     .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n@@ -822,7 +821,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        if !self.sess.contains_name(&krate.attrs, sym::needs_allocator)\n+        if !attr::contains_name(&krate.attrs, sym::needs_allocator)\n             && !self.cstore.iter_crate_data().any(|(_, data)| data.needs_allocator())\n         {\n             return;\n@@ -881,7 +880,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             // allocator. At this point our allocator request is typically fulfilled\n             // by the standard library, denoted by the `#![default_lib_allocator]`\n             // attribute.\n-            if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+            if !attr::contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n                 self.sess.emit_err(errors::GlobalAllocRequired);\n@@ -1003,7 +1002,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if self.sess.contains_name(&item.attrs, sym::no_link) {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     CrateDepKind::MacrosOnly\n                 } else {\n                     CrateDepKind::Explicit\n@@ -1049,16 +1048,15 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n }\n \n-fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1067,21 +1065,20 @@ fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n \n-fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1090,7 +1087,7 @@ fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }"}, {"sha": "eb4d9343f1dfb19425affeb4b711f8ef83c8533c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -681,17 +681,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n                 has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n-                has_default_lib_allocator: tcx\n-                    .sess\n-                    .contains_name(&attrs, sym::default_lib_allocator),\n+                has_default_lib_allocator: attr::contains_name(&attrs, sym::default_lib_allocator),\n                 proc_macro_data,\n                 debugger_visualizers,\n-                compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n-                needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n-                needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n-                no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n-                panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n-                profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n+                compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+                needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+                needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+                no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+                panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+                profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n                 symbol_mangling_version: tcx.sess.opts.get_symbol_mangling_version(),\n \n                 crate_deps,\n@@ -1730,11 +1728,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n                 // so downstream crates need access to them.\n                 let attrs = hir.attrs(proc_macro);\n-                let macro_kind = if tcx.sess.contains_name(attrs, sym::proc_macro) {\n+                let macro_kind = if attr::contains_name(attrs, sym::proc_macro) {\n                     MacroKind::Bang\n-                } else if tcx.sess.contains_name(attrs, sym::proc_macro_attribute) {\n+                } else if attr::contains_name(attrs, sym::proc_macro_attribute) {\n                     MacroKind::Attr\n-                } else if let Some(attr) = tcx.sess.find_by_name(attrs, sym::proc_macro_derive) {\n+                } else if let Some(attr) = attr::find_by_name(attrs, sym::proc_macro_derive) {\n                     // This unwrap chain should have been checked by the proc-macro harness.\n                     name = attr.meta_item_list().unwrap()[0]\n                         .meta_item()"}, {"sha": "a1c1acc4a25414754a010d900f31dade4af3b851", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -28,7 +28,7 @@ use crate::ty::{\n     TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::intern::Interned;\n@@ -2520,9 +2520,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n     providers.is_panic_runtime =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n     providers.is_compiler_builtins =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n     providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())"}, {"sha": "1923e10ddb5865afd09dbe85ce2be51b604aee83", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -3,6 +3,7 @@ use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -680,7 +681,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();\n         // Constants always need overflow checks."}, {"sha": "1c459edabb89e1082fc6b4c6f724380fe7aebf54", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1907,7 +1907,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Fn => {\n                 for attr in attrs {\n-                    if self.tcx.sess.is_proc_macro_attr(attr) {\n+                    if attr.is_proc_macro_attr() {\n                         debug!(\"Is proc macro attr\");\n                         return true;\n                     }"}, {"sha": "f3e683f4b3a0af4545159ee1d7159d9e543e02ed", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n@@ -37,7 +38,7 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if tcx.sess.contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n+    if attr::contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n         return None;\n     }\n \n@@ -57,9 +58,9 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n // An equivalent optimization was not applied to the duplicated code in test_harness.rs.\n fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> EntryPointType {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if ctxt.tcx.sess.contains_name(attrs, sym::start) {\n+    if attr::contains_name(attrs, sym::start) {\n         EntryPointType::Start\n-    } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n+    } else if attr::contains_name(attrs, sym::rustc_main) {\n         EntryPointType::RustcMainAttr\n     } else {\n         if let Some(name) = ctxt.tcx.opt_item_name(id.owner_id.to_def_id())\n@@ -78,7 +79,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n \n fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n+    attr::find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {"}, {"sha": "f79807fee3957f17ef296711f77ce28845006a70", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -685,7 +685,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || attr::contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -750,7 +750,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -1168,12 +1168,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n+        if attr::contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n-        {\n+        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n                     return Some((MacroKind::Derive, ident, ident.span));\n@@ -1228,7 +1227,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1488,13 +1487,12 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         self.r.visibilities.insert(def_id, vis);\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n-        let ctor_vis = if vis.is_public()\n-            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n-        {\n-            ty::Visibility::Restricted(CRATE_DEF_ID)\n-        } else {\n-            vis\n-        };\n+        let ctor_vis =\n+            if vis.is_public() && attr::contains_name(&variant.attrs, sym::non_exhaustive) {\n+                ty::Visibility::Restricted(CRATE_DEF_ID)\n+            } else {\n+                vis\n+            };\n \n         // Define a constructor name in the value namespace.\n         if let Some((ctor_kind, ctor_node_id)) = CtorKind::from_ast(&variant.data) {"}, {"sha": "a0b9188c3159e6543c03b7c4ce915eaaa668fe52", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -23,7 +23,7 @@ extern crate tracing;\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{self as ast, attr, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n@@ -1190,7 +1190,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n             krate.spans.inner_span,\n-            tcx.sess.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1222,9 +1222,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !tcx.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !tcx.sess.contains_name(&krate.attrs, sym::no_std) {\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }"}, {"sha": "9c22ed7a2d7c17c2f6b1d0cbe33f01bd129ab4a3", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -5,7 +5,7 @@ use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n-use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n+use rustc_ast::{self as ast, attr, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::intern::Interned;\n@@ -113,7 +113,7 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n     let mut registered_tools = RegisteredTools::default();\n     let krate = tcx.crate_for_resolver(()).borrow();\n-    for attr in tcx.sess.filter_by_name(&krate.attrs, sym::register_tool) {\n+    for attr in attr::filter_by_name(&krate.attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {"}, {"sha": "fdb9fae44e153b4fce833ae0efda61c276b84df6", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -5,7 +5,7 @@ use crate::errors::{\n     InvalidCharacterInCrateName,\n };\n use crate::Session;\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n use std::path::{Path, PathBuf};\n@@ -56,7 +56,7 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute]) -> Symbol {\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n     let attr_crate_name =\n-        sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n+        attr::find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n         let s = Symbol::intern(s);"}, {"sha": "700a059c368ba8164f63b4417ec716c2d9aded79", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -30,7 +30,7 @@ use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, RealFileLoader, SourceMap, Span};\n-use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n+use rustc_span::{SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{\n@@ -1003,40 +1003,6 @@ impl Session {\n         || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n     }\n \n-    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n-        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-            .iter()\n-            .any(|kind| attr.has_name(*kind))\n-    }\n-\n-    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| item.has_name(name))\n-    }\n-\n-    pub fn find_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| attr.has_name(name))\n-    }\n-\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| attr.has_name(name))\n-    }\n-\n-    pub fn first_attr_value_str_by_name(\n-        &self,\n-        attrs: &[Attribute],\n-        name: Symbol,\n-    ) -> Option<Symbol> {\n-        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n-    }\n-\n     pub fn diagnostic_width(&self) -> usize {\n         let default_column_width = 140;\n         if let Some(width) = self.opts.diagnostic_width {"}, {"sha": "67877780c0e901652d4f8c7acef783019013f99d", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n+        } else if is_public && !is_proc_macro(attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n@@ -51,7 +51,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if is_public\n-            && !is_proc_macro(cx.sess(), attrs)\n+            && !is_proc_macro(attrs)\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n@@ -78,7 +78,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n-            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+            if attr.is_none() && is_public && !is_proc_macro(attrs) {\n                 check_must_use_candidate(\n                     cx,\n                     sig.decl,"}, {"sha": "bc3d774540a51ca494a60f1dfdf3c94f3f35d97c", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -145,8 +145,8 @@ pub fn get_unique_attr<'a>(\n \n /// Return true if the attributes contain any of `proc_macro`,\n /// `proc_macro_derive` or `proc_macro_attribute`, false otherwise\n-pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| sess.is_proc_macro_attr(attr))\n+pub fn is_proc_macro(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.is_proc_macro_attr())\n }\n \n /// Return true if the attributes contain `#[doc(hidden)]`"}, {"sha": "22e45082a9f71b1d86e5e1f8d65feb493cb89ce2", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast;\n use rustc_ast::HasAttrs;\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span};\n \n use self::doc_comment::DocCommentFormatter;\n use crate::comment::{contains_comment, rewrite_doc_comment, CommentStyle};\n@@ -19,20 +19,6 @@ use crate::utils::{count_newlines, mk_sp};\n \n mod doc_comment;\n \n-pub(crate) fn contains_name(attrs: &[ast::Attribute], name: Symbol) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(name))\n-}\n-\n-pub(crate) fn first_attr_value_str_by_name(\n-    attrs: &[ast::Attribute],\n-    name: Symbol,\n-) -> Option<Symbol> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.has_name(name))\n-        .and_then(|attr| attr.value_str())\n-}\n-\n /// Returns attributes on the given statement.\n pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     stmt.attrs()"}, {"sha": "6bc53159b38ba50e97895aedd2c1c5b72f7c3b86", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -2,13 +2,12 @@ use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::{Path, PathBuf};\n \n use rustc_ast::token::TokenKind;\n-use rustc_ast::{ast, ptr};\n+use rustc_ast::{ast, attr, ptr};\n use rustc_errors::Diagnostic;\n use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n use rustc_span::{sym, Span};\n use thin_vec::ThinVec;\n \n-use crate::attr::first_attr_value_str_by_name;\n use crate::parse::session::ParseSess;\n use crate::Input;\n \n@@ -93,7 +92,7 @@ pub(crate) enum ParserError {\n \n impl<'a> Parser<'a> {\n     pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n-        let path_sym = first_attr_value_str_by_name(attrs, sym::path)?;\n+        let path_sym = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n         let path_str = path_sym.as_str();\n \n         // On windows, the base path might have the form"}, {"sha": "3bddf4c1b6a41d82f827d1e3733e12341eb7ba74", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -8,7 +8,7 @@\n \n use std::cmp::{Ord, Ordering};\n \n-use rustc_ast::ast;\n+use rustc_ast::{ast, attr};\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n@@ -167,7 +167,7 @@ fn rewrite_reorderable_or_regroupable_items(\n }\n \n fn contains_macro_use_attr(item: &ast::Item) -> bool {\n-    crate::attr::contains_name(&item.attrs, sym::macro_use)\n+    attr::contains_name(&item.attrs, sym::macro_use)\n }\n \n /// Divides imports into three groups, corresponding to standard, external"}, {"sha": "a3b570ad8c40c5e572ba483eb4963980dfda68af", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=9bdb4881c7e6061fa8acdbb3ddfcd2dd7e11cc89", "patch": "@@ -1,80 +0,0 @@\n-// force-host\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_driver;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_span;\n-#[macro_use]\n-extern crate rustc_session;\n-extern crate rustc_ast;\n-\n-use rustc_ast::attr;\n-use rustc_driver::plugin::Registry;\n-use rustc_lint::{LateContext, LateLintPass, LintContext, LintPass};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::symbol::Symbol;\n-\n-macro_rules! fake_lint_pass {\n-    ($struct:ident, $($attr:expr),*) => {\n-        struct $struct;\n-\n-        impl LintPass for $struct {\n-            fn name(&self) -> &'static str {\n-                stringify!($struct)\n-            }\n-        }\n-\n-        impl LateLintPass<'_> for $struct {\n-            fn check_crate(&mut self, cx: &LateContext) {\n-                let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-                let span = cx.tcx.def_span(CRATE_DEF_ID);\n-                $(\n-                    if !cx.sess().contains_name(attrs, $attr) {\n-                        cx.lint(CRATE_NOT_OKAY, |lint| {\n-                             let msg = format!(\"crate is not marked with #![{}]\", $attr);\n-                             lint.build(&msg).set_span(span).emit();\n-                        });\n-                    }\n-                )*\n-            }\n-        }\n-\n-    }\n-}\n-\n-declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n-declare_lint!(CRATE_NOT_RED, Warn, \"crate not marked with #![crate_red]\");\n-declare_lint!(CRATE_NOT_BLUE, Warn, \"crate not marked with #![crate_blue]\");\n-declare_lint!(CRATE_NOT_GREY, Warn, \"crate not marked with #![crate_grey]\");\n-declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n-\n-fake_lint_pass! {\n-    PassOkay,\n-    Symbol::intern(\"crate_okay\")\n-}\n-\n-fake_lint_pass! {\n-    PassRedBlue,\n-    Symbol::intern(\"crate_red\"), Symbol::intern(\"crate_blue\")\n-}\n-\n-fake_lint_pass! {\n-    PassGreyGreen,\n-    Symbol::intern(\"crate_grey\"), Symbol::intern(\"crate_green\")\n-}\n-\n-#[no_mangle]\n-fn __rustc_plugin_registrar(reg: &mut Registry) {\n-    reg.lint_store.register_lints(&[\n-        &CRATE_NOT_OKAY,\n-        &CRATE_NOT_RED,\n-        &CRATE_NOT_BLUE,\n-        &CRATE_NOT_GREY,\n-        &CRATE_NOT_GREEN,\n-    ]);\n-    reg.lint_store.register_late_pass(|_| Box::new(PassOkay));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassRedBlue));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassGreyGreen));\n-}"}, {"sha": "6304c07d2c7ce6fe88118d7e3f41f3ae7d5a314e", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67a2c5bec838884a0a45d0bd14b7778af731a97b/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a2c5bec838884a0a45d0bd14b7778af731a97b/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=67a2c5bec838884a0a45d0bd14b7778af731a97b", "patch": "@@ -4,13 +4,13 @@\n \n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use]\n extern crate rustc_lint;\n #[macro_use]\n extern crate rustc_session;\n extern crate rustc_ast;\n extern crate rustc_span;\n \n+use rustc_ast::attr;\n use rustc_driver::plugin::Registry;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_span::def_id::CRATE_DEF_ID;\n@@ -28,12 +28,10 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext) {\n         let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n         let span = cx.tcx.def_span(CRATE_DEF_ID);\n-        if !cx.sess().contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n-            cx.lint(\n-                CRATE_NOT_OKAY,\n-                \"crate is not marked with #![crate_okay]\",\n-                |lint| lint.set_span(span)\n-            );\n+        if !attr::contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n+            cx.lint(CRATE_NOT_OKAY, \"crate is not marked with #![crate_okay]\", |lint| {\n+                lint.set_span(span)\n+            });\n         }\n     }\n }"}]}