{"sha": "8467279faccc3837cddf854e30eafb3a086c3c9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjcyNzlmYWNjYzM4MzdjZGRmODU0ZTMwZWFmYjNhMDg2YzNjOWU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-11T23:31:03Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-11T23:34:56Z"}, "message": "Add a new AST node for unsuffixed integer types.", "tree": {"sha": "6980e71b1a286ecd2a093a96205bbe8971cb450d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6980e71b1a286ecd2a093a96205bbe8971cb450d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8467279faccc3837cddf854e30eafb3a086c3c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8467279faccc3837cddf854e30eafb3a086c3c9e", "html_url": "https://github.com/rust-lang/rust/commit/8467279faccc3837cddf854e30eafb3a086c3c9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8467279faccc3837cddf854e30eafb3a086c3c9e/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baf58a764b4cc5ffc3de7bf43b549a4cc59a57a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/baf58a764b4cc5ffc3de7bf43b549a4cc59a57a4", "html_url": "https://github.com/rust-lang/rust/commit/baf58a764b4cc5ffc3de7bf43b549a4cc59a57a4"}], "stats": {"total": 99, "additions": 63, "deletions": 36}, "files": [{"sha": "536ce3c294ef682fcb3955c1a756e4f64c52b80c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -402,6 +402,7 @@ enum lit_ {\n     lit_str(str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n+    lit_int_unsuffixed(i64, int_ty),\n     lit_float(str, float_ty),\n     lit_nil,\n     lit_bool(bool),"}, {"sha": "aff0334a946bbde234aa2ce50dbdb57d025ebdd5", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -51,7 +51,14 @@ fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n \n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n     alt ex.node {\n-      ast::expr_lit(@{node: ast::lit_int(_, ast::ty_i), _}) { true }\n+      ast::expr_lit(node) {\n+        alt node {\n+          @{node: ast::lit_int(_, ast::ty_i), _} |\n+          @{node: ast::lit_int_unsuffixed(_, ast::ty_i), _}\n+          { true }\n+          _ { false }\n+        }\n+      }\n       ast::expr_binary(_, _, sub) | ast::expr_unary(_, sub) |\n       ast::expr_move(_, sub) | ast::expr_copy(sub) |\n       ast::expr_assign(_, sub) |"}, {"sha": "115a9957c28f89793404d1131289b6f9da03247a", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -282,7 +282,10 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n-        ret token::LIT_INT(parsed as i64, ast::ty_i);\n+\n+        #debug[\"lexing %s as an unsuffixed integer literal\",\n+               num_str];\n+        ret token::LIT_INT_UNSUFFIXED(parsed as i64, ast::ty_i);\n     }\n }\n "}, {"sha": "7e6fb726f673706c7ef20b604d400a342a162c5e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -507,7 +507,7 @@ class parser {\n             let lo = self.span.lo;\n             self.bump();\n             alt copy self.token {\n-              token::LIT_INT(num, ty_i) {\n+              token::LIT_INT_UNSUFFIXED(num, _) {\n                 self.bump();\n                 some(mac_var(num as uint))\n               }\n@@ -519,7 +519,7 @@ class parser {\n                 some(mac_aq(mk_sp(lo,hi), e))\n               }\n               _ {\n-                self.fatal(\"expected `(` or integer literal\");\n+                self.fatal(\"expected `(` or unsuffixed integer literal\");\n               }\n             }\n           }\n@@ -540,7 +540,7 @@ class parser {\n               token::UNDERSCORE {\n                 self.bump(); some(vstore_fixed(none))\n               }\n-              token::LIT_INT(i, ty_i) if i >= 0i64 {\n+              token::LIT_INT_UNSUFFIXED(i, _) if i >= 0i64 {\n                 self.bump(); some(vstore_fixed(some(i as uint)))\n               }\n               token::BINOP(token::AND) {\n@@ -559,6 +559,7 @@ class parser {\n         alt tok {\n           token::LIT_INT(i, it) { lit_int(i, it) }\n           token::LIT_UINT(u, ut) { lit_uint(u, ut) }\n+          token::LIT_INT_UNSUFFIXED(i, it) { lit_int_unsuffixed(i, it) }\n           token::LIT_FLOAT(s, ft) { lit_float(self.get_str(s), ft) }\n           token::LIT_STR(s) { lit_str(self.get_str(s)) }\n           token::LPAREN { self.expect(token::RPAREN); lit_nil }"}, {"sha": "989699ab247110e06224d96aee368ed9d360af49", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -58,6 +58,7 @@ enum token {\n     /* Literals */\n     LIT_INT(i64, ast::int_ty),\n     LIT_UINT(u64, ast::uint_ty),\n+    LIT_INT_UNSUFFIXED(i64, ast::int_ty),\n     LIT_FLOAT(str_num, ast::float_ty),\n     LIT_STR(str_num),\n \n@@ -132,6 +133,9 @@ fn to_str(in: interner<@str>, t: token) -> str {\n       LIT_UINT(u, t) {\n         ret uint::to_str(u as uint, 10u) + ast_util::uint_ty_to_str(t);\n       }\n+      LIT_INT_UNSUFFIXED(i, t) {\n+        ret int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t);\n+      }\n       LIT_FLOAT(s, t) {\n         ret *interner::get(in, s) +\n             ast_util::float_ty_to_str(t);\n@@ -161,6 +165,7 @@ pure fn can_begin_expr(t: token) -> bool {\n       TILDE { true }\n       LIT_INT(_, _) { true }\n       LIT_UINT(_, _) { true }\n+      LIT_INT_UNSUFFIXED(_, _) { true }\n       LIT_FLOAT(_, _) { true }\n       LIT_STR(_) { true }\n       POUND { true }\n@@ -178,6 +183,7 @@ fn is_lit(t: token::token) -> bool {\n     ret alt t {\n           token::LIT_INT(_, _) { true }\n           token::LIT_UINT(_, _) { true }\n+          token::LIT_INT_UNSUFFIXED(_, _) { true }\n           token::LIT_FLOAT(_, _) { true }\n           token::LIT_STR(_) { true }\n           _ { false }"}, {"sha": "97135a7bb752f650ad83a95f4a862314b0399128", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -1628,6 +1628,17 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n              u64::to_str(u, 10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n+      ast::lit_int_unsuffixed(i, t) {\n+        if i < 0_i64 {\n+            word(s.s,\n+                 \"-\" + u64::to_str(-i as u64, 10u)\n+                 + ast_util::int_ty_to_str(t));\n+        } else {\n+            word(s.s,\n+                 u64::to_str(i as u64, 10u)\n+                 + ast_util::int_ty_to_str(t));\n+        }\n+      }\n       ast::lit_float(f, t) {\n         word(s.s, f + ast_util::float_ty_to_str(t));\n       }"}, {"sha": "d0e4b715988fe050e63ae225fba68adaae5f36c9", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -111,6 +111,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_str(s) { const_str(s) }\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n+      lit_int_unsuffixed(n, _) { const_int(n) }\n       lit_float(n, _) { const_float(option::get(float::from_str(n)) as f64) }\n       lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }"}, {"sha": "07216030767925a7b8ba0a7b1b4c1db7af0a8491", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -1483,6 +1483,11 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     alt lit.node {\n       ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n+      ast::lit_int_unsuffixed(i, t) {\n+        // FIXME (#1425): should we be using cx.fcx.infcx to figure out what\n+        // to actually generate from this?\n+        C_integral(T_int_ty(cx, t), i as u64, True)\n+      }\n       ast::lit_float(fs, t) { C_floating(fs, T_float_ty(cx, t)) }\n       ast::lit_bool(b) { C_bool(b) }\n       ast::lit_nil { C_nil() }"}, {"sha": "bc7f46703e0127e81af0f0935c2987f7db18fcee", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467279faccc3837cddf854e30eafb3a086c3c9e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=8467279faccc3837cddf854e30eafb3a086c3c9e", "patch": "@@ -629,40 +629,32 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n \n     alt lit.node {\n       ast::lit_str(_) { ty::mk_str(tcx) }\n-      ast::lit_int(v, t) {\n-        alt t {\n-          ty_char | ty_i8 | ty_i16 | ty_i32 | ty_i64 {\n-            // If it's a char or has an explicit suffix, give it the\n-            // appropriate integral type.\n-            ty::mk_mach_int(tcx, t)\n-          }\n-          ty_i {\n-            // Otherwise, an unsuffixed integer literal parses to a\n-            // `ty_i`.  In that case, it could have any integral type,\n-            // so create an integral type variable for it.\n-            let vid = fcx.infcx.next_ty_var_integral_id();\n-\n-            // We need to sniff at the value `v` provided and figure\n-            // out how big of an int it is; that determines the set of\n-            // possibly types it could take on.\n-            let possible_types = alt v {\n-              0i64 to 127i64 { min_8bit_tys() }\n-              128i64 to 65535i64 { min_16bit_tys() }\n-              65536i64 to 4294967295i64 { min_32bit_tys() }\n-              _ { min_64bit_tys() }\n-          };\n+      ast::lit_int(_, t) { ty::mk_mach_int(tcx, t) }\n+      ast::lit_uint(_, t) { ty::mk_mach_uint(tcx, t) }\n+      ast::lit_int_unsuffixed(v, t) {\n+        // An unsuffixed integer literal could have any integral type,\n+        // so we create an integral type variable for it.\n+        let vid = fcx.infcx.next_ty_var_integral_id();\n+\n+        // We need to sniff at the value `v` and figure out how big of\n+        // an int it is; that determines the range of possible types\n+        // that the integral type variable could take on.\n+        let possible_types = alt v {\n+          0i64 to 127i64 { min_8bit_tys() }\n+          128i64 to 65535i64 { min_16bit_tys() }\n+          65536i64 to 4294967295i64 { min_32bit_tys() }\n+          _ { min_64bit_tys() }\n+        };\n \n-            // Store the set of possible types\n-            fcx.infcx.set(fcx.infcx.tvib, vid,\n-                          root(possible_types));\n-            ty::mk_var_integral(tcx, vid);\n+        // Store the set of possible types and return the integral\n+        // type variable.\n+        fcx.infcx.set(fcx.infcx.tvib, vid,\n+                      root(possible_types));\n+        ty::mk_var_integral(tcx, vid);\n \n-            // FIXME: remove me when #1425 is finished.\n-            ty::mk_mach_int(tcx, t)\n-          }\n-        }\n+        // FIXME: remove me when #1425 is finished.\n+        ty::mk_mach_int(tcx, t)\n       }\n-      ast::lit_uint(_, t) { ty::mk_mach_uint(tcx, t) }\n       ast::lit_float(_, t) { ty::mk_mach_float(tcx, t) }\n       ast::lit_nil { ty::mk_nil(tcx) }\n       ast::lit_bool(_) { ty::mk_bool(tcx) }"}]}