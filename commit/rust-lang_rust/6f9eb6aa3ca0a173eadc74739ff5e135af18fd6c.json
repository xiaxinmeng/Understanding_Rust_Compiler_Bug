{"sha": "6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOWViNmFhM2NhMGExNzNlYWRjNzQ3MzlmZjVlMTM1YWYxOGZkNmM=", "commit": {"author": {"name": "Seth Pink", "email": "sethpink@gmail.com", "date": "2013-02-21T04:57:27Z"}, "committer": {"name": "Seth Pink", "email": "sethpink@gmail.com", "date": "2013-02-21T05:32:20Z"}, "message": "Implement #[deriving_eq] on tuple like structs", "tree": {"sha": "7902c638a2c0156ff3510631cc4acef56ae5610f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7902c638a2c0156ff3510631cc4acef56ae5610f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "html_url": "https://github.com/rust-lang/rust/commit/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/comments", "author": {"login": "sp0", "id": 1902223, "node_id": "MDQ6VXNlcjE5MDIyMjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1902223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sp0", "html_url": "https://github.com/sp0", "followers_url": "https://api.github.com/users/sp0/followers", "following_url": "https://api.github.com/users/sp0/following{/other_user}", "gists_url": "https://api.github.com/users/sp0/gists{/gist_id}", "starred_url": "https://api.github.com/users/sp0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sp0/subscriptions", "organizations_url": "https://api.github.com/users/sp0/orgs", "repos_url": "https://api.github.com/users/sp0/repos", "events_url": "https://api.github.com/users/sp0/events{/privacy}", "received_events_url": "https://api.github.com/users/sp0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sp0", "id": 1902223, "node_id": "MDQ6VXNlcjE5MDIyMjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1902223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sp0", "html_url": "https://github.com/sp0", "followers_url": "https://api.github.com/users/sp0/followers", "following_url": "https://api.github.com/users/sp0/following{/other_user}", "gists_url": "https://api.github.com/users/sp0/gists{/gist_id}", "starred_url": "https://api.github.com/users/sp0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sp0/subscriptions", "organizations_url": "https://api.github.com/users/sp0/orgs", "repos_url": "https://api.github.com/users/sp0/repos", "events_url": "https://api.github.com/users/sp0/events{/privacy}", "received_events_url": "https://api.github.com/users/sp0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aa1aaa2c1d095365e341017e443d61a960e0af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa1aaa2c1d095365e341017e443d61a960e0af6", "html_url": "https://github.com/rust-lang/rust/commit/0aa1aaa2c1d095365e341017e443d61a960e0af6"}], "stats": {"total": 146, "additions": 132, "deletions": 14}, "files": [{"sha": "094eea81fd2fd40f2f45fd7e05c43df35a16ace1", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 89, "deletions": 14, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "patch": "@@ -489,20 +489,36 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n     let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_struct_method(cx,\n-                                                     span,\n-                                                     struct_def,\n-                                                     eq_ident,\n-                                                     type_ident,\n-                                                     ty_params,\n-                                                     Conjunction);\n-    let ne_method = expand_deriving_eq_struct_method(cx,\n-                                                     span,\n-                                                     struct_def,\n-                                                     ne_ident,\n-                                                     type_ident,\n-                                                     ty_params,\n-                                                     Disjunction);\n+\n+    let is_struct_tuple =\n+    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n+        match f.node.kind {\n+            named_field(*) => false,\n+            unnamed_field => true\n+        }\n+    });\n+\n+    let derive_struct_fn = if is_struct_tuple {\n+        expand_deriving_eq_struct_tuple_method\n+    } else {\n+        expand_deriving_eq_struct_method\n+    };\n+\n+\n+    let eq_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     eq_ident,\n+                                     type_ident,\n+                                     ty_params,\n+                                     Conjunction);\n+    let ne_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     ne_ident,\n+                                     type_ident,\n+                                     ty_params,\n+                                     Disjunction);\n \n     // Create the implementation.\n     return create_derived_eq_impl(cx,\n@@ -811,6 +827,65 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                             self_match_expr);\n }\n \n+fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n+                                          span: span,\n+                                          struct_def: &struct_def,\n+                                          method_ident: ident,\n+                                          type_ident: ident,\n+                                          ty_params: &[ty_param],\n+                                          junction: Junction)\n+                                        -> @method {\n+    let self_str = ~\"self\";\n+    let other_str = ~\"__other\";\n+    let type_path = build::mk_raw_path(span, ~[type_ident]);\n+    let fields = struct_def.fields;\n+\n+    // Create comparison expression, comparing each of the fields\n+    let mut match_body = None;\n+    for fields.eachi |i, _| {\n+        let other_field_ident = cx.ident_of(other_str + i.to_str());\n+        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n+\n+        let self_field_ident = cx.ident_of(self_str + i.to_str());\n+        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+        call_substructure_eq_method(cx, span, self_field, other_field,\n+            method_ident, junction, &mut match_body);\n+    }\n+    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n+\n+    // Create arm for the '__other' match, containing the comparison expr\n+    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n+    let other_arm = ast::arm {\n+        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, match_body),\n+    };\n+\n+    // Create the match on '__other'\n+    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n+    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n+    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n+\n+    // Create arm for the 'self' match, which contains the '__other' match\n+    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n+    let self_arm = ast::arm {\n+        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, other_match_expr),\n+    };\n+\n+    // Create the match on 'self'\n+    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+\n+    create_eq_method(cx, span, method_ident,\n+        type_ident, ty_params, self_match_expr)\n+}\n+\n fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n                                           span: span,\n                                           enum_definition: &enum_def)"}, {"sha": "70a13f972b80681d5ed2e7ecc7a4ce44597951e2", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving_eq]\n+struct Foo;\n+\n+pub fn main() {\n+  assert Foo == Foo;\n+  assert !(Foo != Foo);\n+}\n\\ No newline at end of file"}, {"sha": "3a4f373fed2753be87a9ac7d19dbed63f2c9b9c6", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=6f9eb6aa3ca0a173eadc74739ff5e135af18fd6c", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving_eq]\n+struct Foo(int, int, ~str);\n+\n+pub fn main() {\n+  let a1 = Foo(5, 6, ~\"abc\");\n+  let a2 = Foo(5, 6, ~\"abc\");\n+  let b = Foo(5, 7, ~\"def\");\n+\n+  assert a1 == a1;\n+  assert a1 == a2;\n+  assert !(a1 == b);\n+\n+  assert a1 != b;\n+  assert !(a1 != a1);\n+  assert !(a1 != a2);\n+}"}]}