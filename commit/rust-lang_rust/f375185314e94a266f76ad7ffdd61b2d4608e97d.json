{"sha": "f375185314e94a266f76ad7ffdd61b2d4608e97d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNzUxODUzMTRlOTRhMjY2Zjc2YWQ3ZmZkZDYxYjJkNDYwOGU5N2Q=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-10T10:28:39Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T16:49:18Z"}, "message": "rustc_codegen_llvm: use safe references for Value.", "tree": {"sha": "d6c6c5916c94c03cac0f1de43b1626bf495bec69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c6c5916c94c03cac0f1de43b1626bf495bec69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f375185314e94a266f76ad7ffdd61b2d4608e97d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f375185314e94a266f76ad7ffdd61b2d4608e97d", "html_url": "https://github.com/rust-lang/rust/commit/f375185314e94a266f76ad7ffdd61b2d4608e97d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f375185314e94a266f76ad7ffdd61b2d4608e97d/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d1768434168875e9ce2d4273ca1ed9e6f69d18f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d1768434168875e9ce2d4273ca1ed9e6f69d18f", "html_url": "https://github.com/rust-lang/rust/commit/8d1768434168875e9ce2d4273ca1ed9e6f69d18f"}], "stats": {"total": 2448, "additions": 1216, "deletions": 1232}, "files": [{"sha": "44982eee86b3cec02e2e4163b950233c8d8892fa", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, AttributePlace};\n+use llvm::{self, AttributePlace};\n use base;\n use builder::{Builder, MemFlags};\n use common::{ty_fn_sig, C_usize};\n@@ -17,6 +17,7 @@ use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n+use value::Value;\n \n use rustc_target::abi::{LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty};\n@@ -46,12 +47,12 @@ impl ArgAttributeExt for ArgAttribute {\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef);\n-    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef);\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value);\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value);\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -76,7 +77,7 @@ impl ArgAttributesExt for ArgAttributes {\n         }\n     }\n \n-    fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -164,24 +165,24 @@ impl LlvmType for CastTarget {\n     }\n }\n \n-pub trait ArgTypeExt<'a, 'tcx> {\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n-    fn store(&self, bx: &Builder<'a, 'll, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>);\n-    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>);\n+pub trait ArgTypeExt<'ll, 'tcx> {\n+    fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>);\n+    fn store_fn_arg(&self, bx: &Builder<'_, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>);\n }\n \n-impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n+impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n+    fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'a, 'll, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n+    fn store(&self, bx: &Builder<'_, 'll, 'tcx>, val: &'ll Value, dst: PlaceRef<'ll, 'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -234,7 +235,7 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'ll, 'tcx>) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n@@ -252,48 +253,48 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     }\n }\n \n-pub trait FnTypeExt<'a, 'tcx> {\n-    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+pub trait FnTypeExt<'tcx> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n                    -> Self;\n-    fn new(cx: &CodegenCx<'a, 'tcx>,\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n            sig: ty::FnSig<'tcx>,\n            extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n                   sig: ty::FnSig<'tcx>,\n                   extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_internal(\n-        cx: &CodegenCx<'a, 'tcx>,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n     ) -> Self;\n     fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'a, 'tcx>,\n+                      cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n-    fn apply_attrs_llfn(&self, llfn: ValueRef);\n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: ValueRef);\n+    fn apply_attrs_llfn(&self, llfn: &'ll Value);\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n         let fn_ty = instance.ty(cx.tcx);\n         let sig = ty_fn_sig(cx, fn_ty);\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         FnType::new(cx, sig, &[])\n     }\n \n-    fn new(cx: &CodegenCx<'a, 'tcx>,\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, _| {\n             ArgType::new(cx.layout_of(ty))\n         })\n     }\n \n-    fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> Self {\n         FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n@@ -316,7 +317,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n \n     fn new_internal(\n-        cx: &CodegenCx<'a, 'tcx>,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n@@ -497,7 +498,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n \n     fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'a, 'tcx>,\n+                      cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n@@ -564,7 +565,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n@@ -629,7 +630,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_llfn(&self, llfn: ValueRef) {\n+    fn apply_attrs_llfn(&self, llfn: &'ll Value) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n@@ -659,7 +660,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: &'ll Value) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);"}, {"sha": "5d27f8eab3ecea095fc275fca1cb473ede236181", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use common::*;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use builder::Builder;\n+use value::Value;\n \n use rustc::hir;\n \n@@ -27,8 +28,8 @@ use libc::{c_uint, c_char};\n pub fn codegen_inline_asm(\n     bx: &Builder<'a, 'll, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<PlaceRef<'tcx>>,\n-    mut inputs: Vec<ValueRef>\n+    outputs: Vec<PlaceRef<'ll, 'tcx>>,\n+    mut inputs: Vec<&'ll Value>\n ) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n@@ -111,7 +112,7 @@ pub fn codegen_inline_asm(\n         let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n+        let val: &'ll Value = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));"}, {"sha": "c52f894410899bf26578f0a214fcfb48a08e32f6", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -22,15 +22,17 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n use attributes;\n-use llvm::{self, Attribute, ValueRef};\n+use llvm::{self, Attribute};\n use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n+\n use context::CodegenCx;\n+use value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-pub fn inline(val: ValueRef, inline: InlineAttr) {\n+pub fn inline(val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n@@ -46,38 +48,38 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n \n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n-pub fn emit_uwtable(val: ValueRef, emit: bool) {\n+pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n     Attribute::UWTable.toggle_llfn(Function, val, emit);\n }\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n-pub fn unwind(val: ValueRef, can_unwind: bool) {\n+pub fn unwind(val: &'ll Value, can_unwind: bool) {\n     Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n /// Tell LLVM whether it should optimize function for size.\n #[inline]\n #[allow(dead_code)] // possibly useful function\n-pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n+pub fn set_optimize_for_size(val: &'ll Value, optimize: bool) {\n     Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n /// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n #[inline]\n-pub fn naked(val: ValueRef, is_naked: bool) {\n+pub fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     if cx.sess().must_not_eliminate_frame_pointers() {\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n     }\n }\n \n-pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n+pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n     if !cx.sess().target.target.options.stack_probes {\n@@ -123,7 +125,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n+pub fn from_fn_attrs(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value, id: DefId) {\n     let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(id);\n \n     inline(llfn, codegen_fn_attrs.inline);"}, {"sha": "40115266e2e2a45a2b82a89e878a1e4f7f46252a", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -17,7 +17,7 @@\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n+//!   * There's no way to find out the Ty type of a Value.  Doing so\n //!     would be \"trying to get the eggs out of an omelette\" (credit:\n //!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n //!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n@@ -31,8 +31,7 @@ use super::ModuleKind;\n use abi;\n use back::link;\n use back::write::{self, OngoingCodegen};\n-use llvm::{TypeKind, ValueRef, get_param};\n-use llvm;\n+use llvm::{self, TypeKind, get_param};\n use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n@@ -87,6 +86,8 @@ use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use rustc::hir::{self, CodegenFnAttrs};\n \n+use value::Value;\n+\n use mir::operand::OperandValue;\n \n use rustc_codegen_utils::check_for_rustc_errors_attr;\n@@ -157,12 +158,12 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n \n pub fn compare_simd_types(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    lhs: ValueRef,\n-    rhs: ValueRef,\n+    lhs: &'ll Value,\n+    rhs: &'ll Value,\n     t: Ty<'tcx>,\n     ret_ty: &'ll Type,\n     op: hir::BinOpKind\n-) -> ValueRef {\n+) -> &'ll Value {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n@@ -187,11 +188,12 @@ pub fn compare_simd_types(\n /// The `old_info` argument is a bit funny. It is intended for use\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n-pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n-                                source: Ty<'tcx>,\n-                                target: Ty<'tcx>,\n-                                old_info: Option<ValueRef>)\n-                                -> ValueRef {\n+pub fn unsized_info(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<&'ll Value>,\n+) -> &'ll Value {\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n@@ -218,10 +220,10 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    src: ValueRef,\n+    src: &'ll Value,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n-) -> (ValueRef, ValueRef) {\n+) -> (&'ll Value, &'ll Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(_, a, _),\n@@ -273,8 +275,8 @@ pub fn unsize_thin_ptr(\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    src: PlaceRef<'tcx>,\n-    dst: PlaceRef<'tcx>\n+    src: PlaceRef<'ll, 'tcx>,\n+    dst: PlaceRef<'ll, 'tcx>\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n@@ -331,19 +333,19 @@ pub fn coerce_unsized_into(\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &Builder, op: hir::BinOpKind, lhs: ValueRef, rhs: ValueRef\n-) -> ValueRef {\n+    cx: &Builder<'_, 'll, '_>, op: hir::BinOpKind, lhs: &'ll Value, rhs: &'ll Value\n+) -> &'ll Value {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n-                        lhs: ValueRef,\n-                        rhs: ValueRef,\n+                        lhs: &'ll Value,\n+                        rhs: &'ll Value,\n                         trunc: F,\n                         zext: G)\n-                        -> ValueRef\n-    where F: FnOnce(ValueRef, &'ll Type) -> ValueRef,\n-          G: FnOnce(ValueRef, &'ll Type) -> ValueRef\n+                        -> &'ll Value\n+    where F: FnOnce(&'ll Value, &'ll Type) -> &'ll Value,\n+          G: FnOnce(&'ll Value, &'ll Type) -> &'ll Value\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n@@ -380,39 +382,41 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume(bx: &Builder<'a, 'll, 'tcx>, val: ValueRef) {\n+pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n     let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate(bx: &Builder, val: ValueRef) -> ValueRef {\n+pub fn from_immediate(bx: &Builder<'_, 'll, '_>, val: &'ll Value) -> &'ll Value {\n     if val_ty(val) == Type::i1(bx.cx) {\n         bx.zext(val, Type::i8(bx.cx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n+pub fn to_immediate(bx: &Builder<'_, 'll, '_>, val: &'ll Value, layout: layout::TyLayout) -> &'ll Value {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n     }\n     val\n }\n \n-pub fn to_immediate_scalar(bx: &Builder, val: ValueRef, scalar: &layout::Scalar) -> ValueRef {\n+pub fn to_immediate_scalar(bx: &Builder<'_, 'll, '_>, val: &'ll Value, scalar: &layout::Scalar) -> &'ll Value {\n     if scalar.is_bool() {\n         return bx.trunc(val, Type::i1(bx.cx));\n     }\n     val\n }\n \n-pub fn call_memcpy(bx: &Builder,\n-                   dst: ValueRef,\n-                   src: ValueRef,\n-                   n_bytes: ValueRef,\n-                   align: Align,\n-                   flags: MemFlags) {\n+pub fn call_memcpy(\n+    bx: &Builder<'_, 'll, '_>,\n+    dst: &'ll Value,\n+    src: &'ll Value,\n+    n_bytes: &'ll Value,\n+    align: Align,\n+    flags: MemFlags,\n+) {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, align);\n@@ -433,9 +437,9 @@ pub fn call_memcpy(bx: &Builder,\n }\n \n pub fn memcpy_ty(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    dst: ValueRef,\n-    src: ValueRef,\n+    bx: &Builder<'_, 'll, 'tcx>,\n+    dst: &'ll Value,\n+    src: &'ll Value,\n     layout: TyLayout<'tcx>,\n     align: Align,\n     flags: MemFlags,\n@@ -449,13 +453,13 @@ pub fn memcpy_ty(\n }\n \n pub fn call_memset(\n-    bx: &Builder<'a, 'll, 'tcx>,\n-    ptr: ValueRef,\n-    fill_byte: ValueRef,\n-    size: ValueRef,\n-    align: ValueRef,\n+    bx: &Builder<'_, 'll, '_>,\n+    ptr: &'ll Value,\n+    fill_byte: &'ll Value,\n+    size: &'ll Value,\n+    align: &'ll Value,\n     volatile: bool,\n-) -> ValueRef {\n+) -> &'ll Value {\n     let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n@@ -514,7 +518,7 @@ pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'\n     mir::codegen_mir(cx, lldecl, &mir, instance, sig);\n }\n \n-pub fn set_link_section(llval: ValueRef, attrs: &CodegenFnAttrs) {\n+pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n     let sect = match attrs.link_section {\n         Some(name) => name,\n         None => return,\n@@ -552,11 +556,13 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         None => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'cx>(cx: &'cx CodegenCx,\n-                       sp: Span,\n-                       rust_main: ValueRef,\n-                       rust_main_def_id: DefId,\n-                       use_start_lang_item: bool) {\n+    fn create_entry_fn(\n+        cx: &CodegenCx<'ll, '_>,\n+        sp: Span,\n+        rust_main: &'ll Value,\n+        rust_main_def_id: DefId,\n+        use_start_lang_item: bool,\n+    ) {\n         let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n@@ -678,26 +684,24 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     return metadata;\n }\n \n-pub struct ValueIter {\n-    cur: ValueRef,\n-    step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n+pub struct ValueIter<'ll> {\n+    cur: Option<&'ll Value>,\n+    step: unsafe extern \"C\" fn(&'ll Value) -> Option<&'ll Value>,\n }\n \n-impl Iterator for ValueIter {\n-    type Item = ValueRef;\n+impl Iterator for ValueIter<'ll> {\n+    type Item = &'ll Value;\n \n-    fn next(&mut self) -> Option<ValueRef> {\n+    fn next(&mut self) -> Option<&'ll Value> {\n         let old = self.cur;\n-        if !old.is_null() {\n+        if let Some(old) = old {\n             self.cur = unsafe { (self.step)(old) };\n-            Some(old)\n-        } else {\n-            None\n         }\n+        old\n     }\n }\n \n-pub fn iter_globals(llmod: &llvm::Module) -> ValueIter {\n+pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     unsafe {\n         ValueIter {\n             cur: llvm::LLVMGetFirstGlobal(llmod),"}, {"sha": "19ae990fa65ffcc1e92236c090a8cd08563f0001", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 207, "deletions": 245, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -10,10 +10,9 @@\n \n #![allow(dead_code)] // FFI wrappers\n \n-use llvm;\n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n-use llvm::{ValueRef, BasicBlockRef};\n+use llvm::{self, BasicBlockRef};\n use common::*;\n use type_::Type;\n use value::Value;\n@@ -60,7 +59,7 @@ bitflags! {\n }\n \n impl Builder<'a, 'll, 'tcx> {\n-    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n@@ -97,7 +96,7 @@ impl Builder<'a, 'll, 'tcx> {\n         self.cx.tcx\n     }\n \n-    pub fn llfn(&self) -> ValueRef {\n+    pub fn llfn(&self) -> &'ll Value {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())\n         }\n@@ -122,14 +121,14 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn set_value_name(&self, value: ValueRef, name: &str) {\n+    pub fn set_value_name(&self, value: &'ll Value, name: &str) {\n         let cname = CString::new(name.as_bytes()).unwrap();\n         unsafe {\n             llvm::LLVMSetValueName(value, cname.as_ptr());\n         }\n     }\n \n-    pub fn position_before(&self, insn: ValueRef) {\n+    pub fn position_before(&self, insn: &'ll Value) {\n         unsafe {\n             llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);\n         }\n@@ -154,14 +153,14 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn ret(&self, v: ValueRef) {\n+    pub fn ret(&self, v: &'ll Value) {\n         self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n-    pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n+    pub fn aggregate_ret(&self, ret_vals: &[&'ll Value]) {\n         unsafe {\n             llvm::LLVMBuildAggregateRet(self.llbuilder,\n                                         ret_vals.as_ptr(),\n@@ -176,40 +175,37 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn cond_br(&self, cond: ValueRef, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n+    pub fn cond_br(&self, cond: &'ll Value, then_llbb: BasicBlockRef, else_llbb: BasicBlockRef) {\n         self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n     }\n \n-    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: usize) -> ValueRef {\n+    pub fn switch(&self, v: &'ll Value, else_llbb: BasicBlockRef, num_cases: usize) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n-    pub fn indirect_br(&self, addr: ValueRef, num_dests: usize) {\n+    pub fn indirect_br(&self, addr: &'ll Value, num_dests: usize) {\n         self.count_insn(\"indirectbr\");\n         unsafe {\n             llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n         }\n     }\n \n     pub fn invoke(&self,\n-                  llfn: ValueRef,\n-                  args: &[ValueRef],\n+                  llfn: &'ll Value,\n+                  args: &[&'ll Value],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  bundle: Option<&OperandBundleDef>) -> ValueRef {\n+                  bundle: Option<&OperandBundleDef>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n-        debug!(\"Invoke {:?} with args ({})\",\n-               Value(llfn),\n-               args.iter()\n-                   .map(|&v| format!(\"{:?}\", Value(v)))\n-                   .collect::<Vec<String>>()\n-                   .join(\", \"));\n+        debug!(\"Invoke {:?} with args ({:?})\",\n+               llfn,\n+               args);\n \n         let args = self.check_call(\"invoke\", llfn, args);\n         let bundle = bundle.as_ref().and_then(|b| NonNull::new(b.raw()));\n@@ -234,35 +230,35 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Arithmetic */\n-    pub fn add(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn add(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nswadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nswadd\");\n         unsafe {\n             llvm::LLVMBuildNSWAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nuwadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nuwadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nuwadd\");\n         unsafe {\n             llvm::LLVMBuildNUWAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fadd(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fadd_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fadd_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n@@ -271,35 +267,35 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn sub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn sub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nswsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nswsub\");\n         unsafe {\n             llvm::LLVMBuildNSWSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nuwsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nuwsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nuwsub\");\n         unsafe {\n             llvm::LLVMBuildNUWSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fsub(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fsub_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fsub_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n@@ -308,35 +304,35 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn mul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn mul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nswmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nswmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nswmul\");\n         unsafe {\n             llvm::LLVMBuildNSWMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn nuwmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn nuwmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nuwmul\");\n         unsafe {\n             llvm::LLVMBuildNUWMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fmul(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fmul_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fmul_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n@@ -346,42 +342,42 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    pub fn udiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn udiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactudiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn exactudiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn sdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn exactsdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn exactsdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fdiv(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fdiv_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fdiv_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n@@ -390,28 +386,28 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn urem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn urem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn srem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn srem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn frem(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn frem_fast(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn frem_fast(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n@@ -420,99 +416,99 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn shl(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn shl(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn lshr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn lshr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn ashr(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn ashr(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn and(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn and(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn or(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn or(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn xor(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn xor(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn binop(&self, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n-              -> ValueRef {\n+    pub fn binop(&self, op: Opcode, lhs: &'ll Value, rhs: &'ll Value)\n+              -> &'ll Value {\n         self.count_insn(\"binop\");\n         unsafe {\n             llvm::LLVMBuildBinOp(self.llbuilder, op, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn neg(&self, v: ValueRef) -> ValueRef {\n+    pub fn neg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nswneg(&self, v: ValueRef) -> ValueRef {\n+    pub fn nswneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nswneg\");\n         unsafe {\n             llvm::LLVMBuildNSWNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nuwneg(&self, v: ValueRef) -> ValueRef {\n+    pub fn nuwneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"nuwneg\");\n         unsafe {\n             llvm::LLVMBuildNUWNeg(self.llbuilder, v, noname())\n         }\n     }\n-    pub fn fneg(&self, v: ValueRef) -> ValueRef {\n+    pub fn fneg(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn not(&self, v: ValueRef) -> ValueRef {\n+    pub fn not(&self, v: &'ll Value) -> &'ll Value {\n         self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> ValueRef {\n+    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -527,14 +523,14 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn free(&self, ptr: ValueRef) {\n+    pub fn free(&self, ptr: &'ll Value) {\n         self.count_insn(\"free\");\n         unsafe {\n             llvm::LLVMBuildFree(self.llbuilder, ptr);\n         }\n     }\n \n-    pub fn load(&self, ptr: ValueRef, align: Align) -> ValueRef {\n+    pub fn load(&self, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -543,7 +539,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn volatile_load(&self, ptr: ValueRef) -> ValueRef {\n+    pub fn volatile_load(&self, ptr: &'ll Value) -> &'ll Value {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n@@ -552,7 +548,7 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_load(&self, ptr: ValueRef, order: AtomicOrdering, align: Align) -> ValueRef {\n+    pub fn atomic_load(&self, ptr: &'ll Value, order: AtomicOrdering, align: Align) -> &'ll Value {\n         self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(self.llbuilder, ptr, noname(), order);\n@@ -565,7 +561,7 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n \n-    pub fn range_metadata(&self, load: ValueRef, range: Range<u128>) {\n+    pub fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n         unsafe {\n             let llty = val_ty(load);\n             let v = [\n@@ -580,25 +576,25 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn nonnull_metadata(&self, load: ValueRef) {\n+    pub fn nonnull_metadata(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Align) -> ValueRef {\n+    pub fn store(&self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n     pub fn store_with_flags(\n         &self,\n-        val: ValueRef,\n-        ptr: ValueRef,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n         align: Align,\n         flags: MemFlags,\n-    ) -> ValueRef {\n-        debug!(\"Store {:?} -> {:?} ({:?})\", Value(val), Value(ptr), flags);\n+    ) -> &'ll Value {\n+        debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n@@ -625,9 +621,9 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef,\n+    pub fn atomic_store(&self, val: &'ll Value, ptr: &'ll Value,\n                         order: AtomicOrdering, align: Align) {\n-        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n+        debug!(\"Store {:?} -> {:?}\", val, ptr);\n         self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n@@ -638,172 +634,172 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+    pub fn gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+    pub fn inbounds_gep(&self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: u64) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn global_string(&self, _str: *const c_char) -> ValueRef {\n+    pub fn global_string(&self, _str: *const c_char) -> &'ll Value {\n         self.count_insn(\"globalstring\");\n         unsafe {\n             llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n         }\n     }\n \n-    pub fn global_string_ptr(&self, _str: *const c_char) -> ValueRef {\n+    pub fn global_string_ptr(&self, _str: *const c_char) -> &'ll Value {\n         self.count_insn(\"globalstringptr\");\n         unsafe {\n             llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n         }\n     }\n \n     /* Casts */\n-    pub fn trunc(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptoui(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptosi(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    pub fn uitofp(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sitofp(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptrunc(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fpext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn ptrtoint(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn inttoptr(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn zext_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"zextorbitcast\");\n         unsafe {\n             llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn sext_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sextorbitcast\");\n         unsafe {\n             llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn trunc_or_bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"truncorbitcast\");\n         unsafe {\n             llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn cast(&self, op: Opcode, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"cast\");\n         unsafe {\n             llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn pointercast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn intcast(&self, val: ValueRef, dest_ty: &'ll Type, is_signed: bool) -> ValueRef {\n+    pub fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    pub fn fpcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n+    pub fn fpcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpcast\");\n         unsafe {\n             llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty, noname())\n@@ -812,29 +808,29 @@ impl Builder<'a, 'll, 'tcx> {\n \n \n     /* Comparisons */\n-    pub fn icmp(&self, op: IntPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn icmp(&self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"icmp\");\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn fcmp(&self, op: RealPredicate, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn fcmp(&self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     /* Miscellaneous instructions */\n-    pub fn empty_phi(&self, ty: &'ll Type) -> ValueRef {\n+    pub fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    pub fn phi(&self, ty: &'ll Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+    pub fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[BasicBlockRef]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -873,9 +869,9 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                         inputs: &[ValueRef], output: &'ll Type,\n+                         inputs: &[&'ll Value], output: &'ll Type,\n                          volatile: bool, alignstack: bool,\n-                         dia: AsmDialect) -> ValueRef {\n+                         dia: AsmDialect) -> &'ll Value {\n         self.count_insn(\"inlineasm\");\n \n         let volatile = if volatile { llvm::True }\n@@ -884,7 +880,7 @@ impl Builder<'a, 'll, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", Value(*v));\n+            debug!(\"Asm Input Type: {:?}\", *v);\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n@@ -897,16 +893,13 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                bundle: Option<&OperandBundleDef>) -> ValueRef {\n+    pub fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n+                bundle: Option<&OperandBundleDef>) -> &'ll Value {\n         self.count_insn(\"call\");\n \n-        debug!(\"Call {:?} with args ({})\",\n-               Value(llfn),\n-               args.iter()\n-                   .map(|&v| format!(\"{:?}\", Value(v)))\n-                   .collect::<Vec<String>>()\n-                   .join(\", \"));\n+        debug!(\"Call {:?} with args ({:?})\",\n+               llfn,\n+               args);\n \n         let args = self.check_call(\"call\", llfn, args);\n         let bundle = bundle.as_ref().and_then(|b| NonNull::new(b.raw()));\n@@ -917,63 +910,65 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn minnum(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n         }\n     }\n-    pub fn maxnum(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn maxnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\")\n         }\n     }\n \n-    pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n+    pub fn select(\n+        &self, cond: &'ll Value,\n+        then_val: &'ll Value,\n+        else_val: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n-    pub fn va_arg(&self, list: ValueRef, ty: &'ll Type) -> ValueRef {\n+    pub fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n-    pub fn extract_element(&self, vec: ValueRef, idx: ValueRef) -> ValueRef {\n+    pub fn extract_element(&self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n-    pub fn insert_element(&self, vec: ValueRef, elt: ValueRef, idx: ValueRef) -> ValueRef {\n+    pub fn insert_element(\n+        &self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n         self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n     }\n \n-    pub fn shuffle_vector(&self, v1: ValueRef, v2: ValueRef, mask: ValueRef) -> ValueRef {\n+    pub fn shuffle_vector(&self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n         self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: usize, elt: ValueRef) -> ValueRef {\n+    pub fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n@@ -983,157 +978,122 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fadd_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n-            }\n+            let instr = instr.expect(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmul_fast(&self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n             // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n-            }\n+            let instr = instr.expect(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_add(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_add(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.add\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_mul(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_mul(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.mul\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_and(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_and(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.and\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_or(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_or(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.or\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_xor(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_xor(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.xor\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmin(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmax(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmin_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n-            }\n+            let instr = instr.expect(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n+    pub fn vector_reduce_fmax_fast(&self, src: &'ll Value) -> &'ll Value {\n         self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n-            }\n+            let instr = instr.expect(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n-    pub fn vector_reduce_min(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+    pub fn vector_reduce_min(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.min\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\")\n         }\n     }\n-    pub fn vector_reduce_max(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+    pub fn vector_reduce_max(&self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"vector.reduce.max\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed);\n-            if instr.is_null() {\n-                bug!(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\");\n-            }\n-            instr\n+            instr.expect(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\")\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n-    pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: u64) -> ValueRef {\n+    pub fn insert_value(&self, agg_val: &'ll Value, elt: &'ll Value,\n+                       idx: u64) -> &'ll Value {\n         self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n@@ -1142,61 +1102,60 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn is_null(&self, val: ValueRef) -> ValueRef {\n+    pub fn is_null(&self, val: &'ll Value) -> &'ll Value {\n         self.count_insn(\"isnull\");\n         unsafe {\n             llvm::LLVMBuildIsNull(self.llbuilder, val, noname())\n         }\n     }\n \n-    pub fn is_not_null(&self, val: ValueRef) -> ValueRef {\n+    pub fn is_not_null(&self, val: &'ll Value) -> &'ll Value {\n         self.count_insn(\"isnotnull\");\n         unsafe {\n             llvm::LLVMBuildIsNotNull(self.llbuilder, val, noname())\n         }\n     }\n \n-    pub fn ptrdiff(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    pub fn ptrdiff(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"ptrdiff\");\n         unsafe {\n             llvm::LLVMBuildPtrDiff(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: ValueRef,\n-                       num_clauses: usize) -> ValueRef {\n+    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n+                       num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n-    pub fn add_clause(&self, landing_pad: ValueRef, clause: ValueRef) {\n+    pub fn add_clause(&self, landing_pad: &'ll Value, clause: &'ll Value) {\n         unsafe {\n             llvm::LLVMAddClause(landing_pad, clause);\n         }\n     }\n \n-    pub fn set_cleanup(&self, landing_pad: ValueRef) {\n+    pub fn set_cleanup(&self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n-    pub fn resume(&self, exn: ValueRef) -> ValueRef {\n+    pub fn resume(&self, exn: &'ll Value) -> &'ll Value {\n         self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n     }\n \n     pub fn cleanup_pad(&self,\n-                       parent: Option<ValueRef>,\n-                       args: &[ValueRef]) -> ValueRef {\n+                       parent: Option<&'ll Value>,\n+                       args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"cleanuppad\");\n-        let parent = parent.and_then(NonNull::new);\n         let name = CString::new(\"cleanuppad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1205,87 +1164,91 @@ impl Builder<'a, 'll, 'tcx> {\n                                           args.as_ptr(),\n                                           name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for cleanuppad\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for cleanuppad\")\n     }\n \n-    pub fn cleanup_ret(&self, cleanup: ValueRef,\n-                       unwind: Option<BasicBlockRef>) -> ValueRef {\n+    pub fn cleanup_ret(&self, cleanup: &'ll Value,\n+                       unwind: Option<BasicBlockRef>) -> &'ll Value {\n         self.count_insn(\"cleanupret\");\n         let unwind = unwind.and_then(NonNull::new);\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for cleanupret\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for cleanupret\")\n     }\n \n     pub fn catch_pad(&self,\n-                     parent: ValueRef,\n-                     args: &[ValueRef]) -> ValueRef {\n+                     parent: &'ll Value,\n+                     args: &[&'ll Value]) -> &'ll Value {\n         self.count_insn(\"catchpad\");\n         let name = CString::new(\"catchpad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n                                         args.len() as c_uint, args.as_ptr(),\n                                         name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchpad\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchpad\")\n     }\n \n-    pub fn catch_ret(&self, pad: ValueRef, unwind: BasicBlockRef) -> ValueRef {\n+    pub fn catch_ret(&self, pad: &'ll Value, unwind: BasicBlockRef) -> &'ll Value {\n         self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, pad, unwind)\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchret\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchret\")\n     }\n \n-    pub fn catch_switch(&self,\n-                        parent: Option<ValueRef>,\n-                        unwind: Option<BasicBlockRef>,\n-                        num_handlers: usize) -> ValueRef {\n+    pub fn catch_switch(\n+        &self,\n+        parent: Option<&'ll Value>,\n+        unwind: Option<BasicBlockRef>,\n+        num_handlers: usize,\n+    ) -> &'ll Value {\n         self.count_insn(\"catchswitch\");\n-        let parent = parent.and_then(NonNull::new);\n         let unwind = unwind.and_then(NonNull::new);\n         let name = CString::new(\"catchswitch\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n                                            num_handlers as c_uint,\n                                            name.as_ptr())\n         };\n-        assert!(!ret.is_null(), \"LLVM does not have support for catchswitch\");\n-        return ret\n+        ret.expect(\"LLVM does not have support for catchswitch\")\n     }\n \n-    pub fn add_handler(&self, catch_switch: ValueRef, handler: BasicBlockRef) {\n+    pub fn add_handler(&self, catch_switch: &'ll Value, handler: BasicBlockRef) {\n         unsafe {\n             llvm::LLVMRustAddHandler(catch_switch, handler);\n         }\n     }\n \n-    pub fn set_personality_fn(&self, personality: ValueRef) {\n+    pub fn set_personality_fn(&self, personality: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n     }\n \n     // Atomic Operations\n-    pub fn atomic_cmpxchg(&self, dst: ValueRef,\n-                         cmp: ValueRef, src: ValueRef,\n-                         order: AtomicOrdering,\n-                         failure_order: AtomicOrdering,\n-                         weak: llvm::Bool) -> ValueRef {\n+    pub fn atomic_cmpxchg(\n+        &self,\n+        dst: &'ll Value,\n+        cmp: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+        failure_order: AtomicOrdering,\n+        weak: llvm::Bool,\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n                                          order, failure_order, weak)\n         }\n     }\n-    pub fn atomic_rmw(&self, op: AtomicRmwBinOp,\n-                     dst: ValueRef, src: ValueRef,\n-                     order: AtomicOrdering) -> ValueRef {\n+    pub fn atomic_rmw(\n+        &self,\n+        op: AtomicRmwBinOp,\n+        dst: &'ll Value,\n+        src: &'ll Value,\n+        order: AtomicOrdering,\n+    ) -> &'ll Value {\n         unsafe {\n             llvm::LLVMBuildAtomicRMW(self.llbuilder, op, dst, src, order, False)\n         }\n@@ -1297,20 +1260,20 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn add_case(&self, s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n+    pub fn add_case(&self, s: &'ll Value, on_val: &'ll Value, dest: BasicBlockRef) {\n         unsafe {\n             llvm::LLVMAddCase(s, on_val, dest)\n         }\n     }\n \n-    pub fn add_incoming_to_phi(&self, phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n+    pub fn add_incoming_to_phi(&self, phi: &'ll Value, val: &'ll Value, bb: BasicBlockRef) {\n         self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }\n     }\n \n-    pub fn set_invariant_load(&self, load: ValueRef) {\n+    pub fn set_invariant_load(&self, load: &'ll Value) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n@@ -1319,8 +1282,8 @@ impl Builder<'a, 'll, 'tcx> {\n \n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n-                       val: ValueRef,\n-                       ptr: ValueRef) -> ValueRef {\n+                       val: &'ll Value,\n+                       ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = val_ty(ptr);\n         let stored_ty = val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n@@ -1340,8 +1303,8 @@ impl Builder<'a, 'll, 'tcx> {\n     /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(&self,\n                       typ: &str,\n-                      llfn: ValueRef,\n-                      args: &'b [ValueRef]) -> Cow<'b, [ValueRef]> {\n+                      llfn: &'ll Value,\n+                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n         let mut fn_ty = val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n@@ -1369,8 +1332,7 @@ impl Builder<'a, 'll, 'tcx> {\n                 if expected_ty != actual_ty {\n                     debug!(\"Type mismatch in function call of {:?}. \\\n                             Expected {:?} for param {}, got {:?}; injecting bitcast\",\n-                           Value(llfn),\n-                           expected_ty, i, actual_ty);\n+                           llfn, expected_ty, i, actual_ty);\n                     self.bitcast(actual_val, expected_ty)\n                 } else {\n                     actual_val\n@@ -1381,11 +1343,11 @@ impl Builder<'a, 'll, 'tcx> {\n         return Cow::Owned(casted_args);\n     }\n \n-    pub fn lifetime_start(&self, ptr: ValueRef, size: Size) {\n+    pub fn lifetime_start(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n \n-    pub fn lifetime_end(&self, ptr: ValueRef, size: Size) {\n+    pub fn lifetime_end(&self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n@@ -1397,7 +1359,7 @@ impl Builder<'a, 'll, 'tcx> {\n     ///\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n-    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n+    fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }"}, {"sha": "e64dedac55a247e343d0c86f5962bd104c323301", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -18,9 +18,10 @@ use attributes;\n use common::{self, CodegenCx};\n use consts;\n use declare;\n-use llvm::{self, ValueRef};\n+use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n+use value::Value;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n@@ -34,10 +35,10 @@ use rustc::ty::subst::Substs;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                        instance: Instance<'tcx>)\n-                        -> ValueRef\n-{\n+pub fn get_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+) -> &'ll Value {\n     let tcx = cx.tcx;\n \n     debug!(\"get_fn(instance={:?})\", instance);\n@@ -204,11 +205,11 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     llfn\n }\n \n-pub fn resolve_and_get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    def_id: DefId,\n-                                    substs: &'tcx Substs<'tcx>)\n-                                    -> ValueRef\n-{\n+pub fn resolve_and_get_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> &'ll Value {\n     get_fn(\n         cx,\n         ty::Instance::resolve("}, {"sha": "90e42dd803aad8ad908227665e83a2d88a38d841", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -12,8 +12,7 @@\n \n //! Code that is useful in various codegen modules.\n \n-use llvm;\n-use llvm::{ValueRef, TypeKind};\n+use llvm::{self, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n@@ -25,6 +24,7 @@ use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n+\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n@@ -90,20 +90,20 @@ pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bo\n /// When inside of a landing pad, each function call in LLVM IR needs to be\n /// annotated with which landing pad it's a part of. This is accomplished via\n /// the `OperandBundleDef` value created for MSVC landing pads.\n-pub struct Funclet {\n-    cleanuppad: ValueRef,\n+pub struct Funclet<'ll> {\n+    cleanuppad: &'ll Value,\n     operand: OperandBundleDef,\n }\n \n-impl Funclet {\n-    pub fn new(cleanuppad: ValueRef) -> Funclet {\n+impl Funclet<'ll> {\n+    pub fn new(cleanuppad: &'ll Value) -> Self {\n         Funclet {\n             cleanuppad,\n             operand: OperandBundleDef::new(\"funclet\", &[cleanuppad]),\n         }\n     }\n \n-    pub fn cleanuppad(&self) -> ValueRef {\n+    pub fn cleanuppad(&self) -> &'ll Value {\n         self.cleanuppad\n     }\n \n@@ -112,62 +112,61 @@ impl Funclet {\n     }\n }\n \n-// TODO: use proper lifetime in return type\n-pub fn val_ty(v: ValueRef) -> &'static Type {\n+pub fn val_ty(v: &'ll Value) -> &'ll Type {\n     unsafe {\n-        llvm::LLVMTypeOf(&*v)\n+        llvm::LLVMTypeOf(v)\n     }\n }\n \n // LLVM constant constructors.\n-pub fn C_null(t: &Type) -> ValueRef {\n+pub fn C_null(t: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstNull(t)\n     }\n }\n \n-pub fn C_undef(t: &Type) -> ValueRef {\n+pub fn C_undef(t: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMGetUndef(t)\n     }\n }\n \n-pub fn C_int(t: &Type, i: i64) -> ValueRef {\n+pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstInt(t, i as u64, True)\n     }\n }\n \n-pub fn C_uint(t: &Type, i: u64) -> ValueRef {\n+pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstInt(t, i, False)\n     }\n }\n \n-pub fn C_uint_big(t: &Type, u: u128) -> ValueRef {\n+pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n     unsafe {\n         let words = [u as u64, (u >> 64) as u64];\n         llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n     }\n }\n \n-pub fn C_bool(cx: &CodegenCx, val: bool) -> ValueRef {\n+pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n     C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32(cx: &CodegenCx, i: i32) -> ValueRef {\n+pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n     C_int(Type::i32(cx), i as i64)\n }\n \n-pub fn C_u32(cx: &CodegenCx, i: u32) -> ValueRef {\n+pub fn C_u32(cx: &CodegenCx<'ll, '_>, i: u32) -> &'ll Value {\n     C_uint(Type::i32(cx), i as u64)\n }\n \n-pub fn C_u64(cx: &CodegenCx, i: u64) -> ValueRef {\n+pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n+pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n@@ -177,14 +176,14 @@ pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n     C_uint(cx.isize_ty, i)\n }\n \n-pub fn C_u8(cx: &CodegenCx, i: u8) -> ValueRef {\n+pub fn C_u8(cx: &CodegenCx<'ll, '_>, i: u8) -> &'ll Value {\n     C_uint(Type::i8(cx), i as u64)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CodegenCx, s: LocalInternedString, null_terminated: bool) -> ValueRef {\n+pub fn C_cstr(cx: &CodegenCx<'ll, '_>, s: LocalInternedString, null_terminated: bool) -> &'ll Value {\n     unsafe {\n         if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n@@ -209,68 +208,68 @@ pub fn C_cstr(cx: &CodegenCx, s: LocalInternedString, null_terminated: bool) ->\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CodegenCx, s: LocalInternedString) -> ValueRef {\n+pub fn C_str_slice(cx: &CodegenCx<'ll, '_>, s: LocalInternedString) -> &'ll Value {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n         cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n     C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n-pub fn C_fat_ptr(cx: &CodegenCx, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n+pub fn C_fat_ptr(cx: &CodegenCx<'ll, '_>, ptr: &'ll Value, meta: &'ll Value) -> &'ll Value {\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n     C_struct(cx, &[ptr, meta], false)\n }\n \n-pub fn C_struct(cx: &CodegenCx, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(cx: &CodegenCx<'ll, '_>, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n     C_struct_in_context(cx.llcx, elts, packed)\n }\n \n-pub fn C_struct_in_context(llcx: &llvm::Context, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct_in_context(llcx: &'ll llvm::Context, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstStructInContext(llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n }\n \n-pub fn C_array(ty: &Type, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n     unsafe {\n         return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n-pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n+pub fn C_vector(elts: &[&'ll Value]) -> &'ll Value {\n     unsafe {\n         return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n-pub fn C_bytes(cx: &CodegenCx, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(cx: &CodegenCx<'ll, '_>, bytes: &[u8]) -> &'ll Value {\n     C_bytes_in_context(cx.llcx, bytes)\n }\n \n-pub fn C_bytes_in_context(llcx: &llvm::Context, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n     unsafe {\n         let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n-pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n+pub fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n     unsafe {\n         assert_eq!(idx as c_uint as u64, idx);\n         let us = &[idx as c_uint];\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n-               Value(v), idx, Value(r));\n+               v, idx, r);\n \n         r\n     }\n }\n \n-pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n+pub fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n     unsafe {\n         if is_const_real(v) {\n             let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n@@ -283,21 +282,21 @@ pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n     }\n }\n \n-pub fn const_to_uint(v: ValueRef) -> u64 {\n+pub fn const_to_uint(v: &'ll Value) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n     }\n }\n \n-pub fn is_const_integral(v: ValueRef) -> bool {\n+pub fn is_const_integral(v: &'ll Value) -> bool {\n     unsafe {\n-        !llvm::LLVMIsAConstantInt(v).is_null()\n+        llvm::LLVMIsAConstantInt(v).is_some()\n     }\n }\n \n-pub fn is_const_real(v: ValueRef) -> bool {\n+pub fn is_const_real(v: &'ll Value) -> bool {\n     unsafe {\n-        !llvm::LLVMIsAConstantFP(v).is_null()\n+        llvm::LLVMIsAConstantFP(v).is_some()\n     }\n }\n \n@@ -307,7 +306,7 @@ fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)\n }\n \n-pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n+pub fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n             let (mut lo, mut hi) = (0u64, 0u64);\n@@ -348,18 +347,18 @@ pub fn langcall(tcx: TyCtxt,\n \n pub fn build_unchecked_lshift(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    lhs: ValueRef,\n-    rhs: ValueRef\n-) -> ValueRef {\n+    lhs: &'ll Value,\n+    rhs: &'ll Value\n+) -> &'ll Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n }\n \n pub fn build_unchecked_rshift(\n-    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n-) -> ValueRef {\n+    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: &'ll Value, rhs: &'ll Value\n+) -> &'ll Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n@@ -371,7 +370,7 @@ pub fn build_unchecked_rshift(\n     }\n }\n \n-fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n     let rhs_llty = val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n@@ -381,7 +380,7 @@ pub fn shift_mask_val(\n     llty: &'ll Type,\n     mask_llty: &'ll Type,\n     invert: bool\n-) -> ValueRef {\n+) -> &'ll Value {\n     let kind = llty.kind();\n     match kind {\n         TypeKind::Integer => {"}, {"sha": "72ff65361cada9d3e6974d100f27f1a61f2f76fe", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -9,9 +9,7 @@\n // except according to those terms.\n \n use libc::c_uint;\n-use llvm;\n-use llvm::{SetUnnamedAddr};\n-use llvm::{ValueRef, True};\n+use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use debuginfo;\n@@ -24,27 +22,29 @@ use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n+use value::Value;\n use rustc::ty::{self, Ty};\n+\n use rustc::ty::layout::{Align, LayoutOf};\n \n use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n-pub fn ptrcast(val: ValueRef, ty: &Type) -> ValueRef {\n+pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstPointerCast(val, ty)\n     }\n }\n \n-pub fn bitcast(val: ValueRef, ty: &Type) -> ValueRef {\n+pub fn bitcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMConstBitCast(val, ty)\n     }\n }\n \n-fn set_global_alignment(cx: &CodegenCx,\n-                        gv: ValueRef,\n+fn set_global_alignment(cx: &CodegenCx<'ll, '_>,\n+                        gv: &'ll Value,\n                         mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n@@ -62,11 +62,12 @@ fn set_global_alignment(cx: &CodegenCx,\n     }\n }\n \n-pub fn addr_of_mut(cx: &CodegenCx,\n-                   cv: ValueRef,\n-                   align: Align,\n-                   kind: &str)\n-                    -> ValueRef {\n+pub fn addr_of_mut(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: &'ll Value,\n+    align: Align,\n+    kind: &str,\n+) -> &'ll Value {\n     unsafe {\n         let name = cx.generate_local_symbol_name(kind);\n         let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n@@ -80,11 +81,12 @@ pub fn addr_of_mut(cx: &CodegenCx,\n     }\n }\n \n-pub fn addr_of(cx: &CodegenCx,\n-               cv: ValueRef,\n-               align: Align,\n-               kind: &str)\n-               -> ValueRef {\n+pub fn addr_of(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: &'ll Value,\n+    align: Align,\n+    kind: &str,\n+) -> &'ll Value {\n     if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n@@ -104,7 +106,7 @@ pub fn addr_of(cx: &CodegenCx,\n     gv\n }\n \n-pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n+pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n     let instance = Instance::mono(cx.tcx, def_id);\n     if let Some(&g) = cx.instances.borrow().get(&instance) {\n         return g;\n@@ -213,13 +215,13 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n-fn check_and_apply_linkage<'tcx>(\n-    cx: &CodegenCx<'_, 'tcx>,\n+fn check_and_apply_linkage(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: LocalInternedString,\n     span: Option<Span>\n-) -> ValueRef {\n+) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     if let Some(linkage) = attrs.linkage {\n         debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);"}, {"sha": "417af8b2b09ac1d62ba924b908efcf4fd2cc4e42", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -10,7 +10,6 @@\n \n use common;\n use llvm;\n-use llvm::ValueRef;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -19,6 +18,7 @@ use callee;\n use base;\n use declare;\n use monomorphize::Instance;\n+use value::Value;\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n@@ -56,38 +56,38 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    pub instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n-                                Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n+                                Option<ty::PolyExistentialTraitRef<'tcx>>), &'a Value>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, ValueRef>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n-    /// Key is a ValueRef holding a *T,\n-    /// Val is a ValueRef holding a *[T].\n+    /// Key is a Value holding a *T,\n+    /// Val is a Value holding a *[T].\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n     /// when we ptrcast, and we have to ptrcast during codegen\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    pub const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_unsized: RefCell<FxHashMap<&'a Value, &'a Value>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    pub const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_globals: RefCell<FxHashMap<&'a Value, &'a Value>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    pub statics: RefCell<FxHashMap<ValueRef, DefId>>,\n+    pub statics: RefCell<FxHashMap<&'a Value, DefId>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when codegen is complete.\n-    /// (We have to make sure we don't invalidate any ValueRefs referring\n+    /// (We have to make sure we don't invalidate any Values referring\n     /// to constants.)\n-    pub statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+    pub statics_to_rauw: RefCell<Vec<(&'a Value, &'a Value)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n-    pub used_statics: RefCell<Vec<ValueRef>>,\n+    pub used_statics: RefCell<Vec<&'a Value>>,\n \n     pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), &'a Type>>,\n     pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'a Type>>,\n@@ -96,11 +96,11 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n \n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'a, 'tcx>>,\n \n-    eh_personality: Cell<Option<ValueRef>>,\n-    eh_unwind_resume: Cell<Option<ValueRef>>,\n-    pub rust_try_fn: Cell<Option<ValueRef>>,\n+    eh_personality: Cell<Option<&'a Value>>,\n+    eh_unwind_resume: Cell<Option<&'a Value>>,\n+    pub rust_try_fn: Cell<Option<&'a Value>>,\n \n-    intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, &'a Value>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -314,7 +314,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         &self.tcx.sess\n     }\n \n-    pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n+    pub fn get_intrinsic(&self, key: &str) -> &'b Value {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -338,7 +338,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         name\n     }\n \n-    pub fn eh_personality(&self) -> ValueRef {\n+    pub fn eh_personality(&self) -> &'b Value {\n         // The exception handling personality function.\n         //\n         // If our compilation unit has the `eh_personality` lang item somewhere\n@@ -381,9 +381,9 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         llfn\n     }\n \n-    // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n+    // Returns a Value of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> ValueRef {\n+    pub fn eh_unwind_resume(&self) -> &'b Value {\n         use attributes;\n         let unwresume = &self.eh_unwind_resume;\n         if let Some(llfn) = unwresume.get() {\n@@ -471,7 +471,7 @@ impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n+fn declare_intrinsic(cx: &CodegenCx<'ll, '_>, key: &str) -> Option<&'ll Value> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {"}, {"sha": "08128a729b5f0ca02dc8bcc31e4ac929a2cdac2c", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -15,8 +15,9 @@ use llvm;\n use common::{C_bytes, CodegenCx, C_i32};\n use builder::Builder;\n use declare;\n-use type_::Type;\n use rustc::session::config::NoDebugInfo;\n+use type_::Type;\n+use value::Value;\n \n use syntax::attr;\n \n@@ -39,8 +40,8 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n-                                                  -> llvm::ValueRef {\n+pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n+                                                  -> &'ll Value {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n \n@@ -49,7 +50,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n                                  c_section_var_name.as_ptr() as *const _)\n     };\n \n-    if section_var.is_null() {\n+    section_var.unwrap_or_else(|| {\n         let section_name = b\".debug_gdb_scripts\\0\";\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n@@ -71,9 +72,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n             llvm::LLVMSetAlignment(section_var, 1);\n             section_var\n         }\n-    } else {\n-        section_var\n-    }\n+    })\n }\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {"}, {"sha": "69ef92ed98e52d51112f59381e14efc8828a3393", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -18,8 +18,9 @@ use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n+use value::Value;\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n@@ -890,7 +891,7 @@ pub fn compile_unit_metadata(tcx: TyCtxt,\n         return unit_metadata;\n     };\n \n-    fn path_to_mdstring(llcx: &llvm::Context, path: &Path) -> llvm::ValueRef {\n+    fn path_to_mdstring(llcx: &'ll llvm::Context, path: &Path) -> &'ll Value {\n         let path_str = path2cstr(path);\n         unsafe {\n             llvm::LLVMMDStringInContext(llcx,\n@@ -1679,9 +1680,11 @@ fn create_union_stub(\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CodegenCx,\n-                                  def_id: DefId,\n-                                  global: ValueRef) {\n+pub fn create_global_var_metadata(\n+    cx: &CodegenCx<'ll, '_>,\n+    def_id: DefId,\n+    global: &'ll Value,\n+) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -1759,9 +1762,11 @@ pub fn extend_scope_to_file(\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                        ty: ty::Ty<'tcx>,\n-                                        vtable: ValueRef) {\n+pub fn create_vtable_metadata(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: ty::Ty<'tcx>,\n+    vtable: &'ll Value,\n+) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }"}, {"sha": "3b6b7b2d77b1c3132e67f360e195d59139a24646", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -21,7 +21,6 @@ use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n-use llvm::ValueRef;\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, DIArray, DIFlags};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n@@ -35,6 +34,7 @@ use rustc::ty::{self, ParamEnv, Ty, InstanceDef};\n use rustc::mir;\n use rustc::session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use value::Value;\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -135,12 +135,12 @@ pub struct FunctionDebugContextData<'ll> {\n     pub defining_crate: CrateNum,\n }\n \n-pub enum VariableAccess<'a> {\n+pub enum VariableAccess<'a, 'll> {\n     // The llptr given is an alloca containing the variable's value\n-    DirectVariable { alloca: ValueRef },\n+    DirectVariable { alloca: &'ll Value },\n     // The llptr given is an alloca containing the start of some pointer chain\n     // leading to the variable's content.\n-    IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n+    IndirectVariable { alloca: &'ll Value, address_operations: &'a [i64] }\n }\n \n pub enum VariableKind {\n@@ -204,7 +204,7 @@ pub fn create_function_debug_context(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n-    llfn: ValueRef,\n+    llfn: &'ll Value,\n     mir: &mir::Mir,\n ) -> FunctionDebugContext<'ll> {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n@@ -482,7 +482,7 @@ pub fn declare_local(\n     variable_name: ast::Name,\n     variable_type: Ty<'tcx>,\n     scope_metadata: &'ll DIScope,\n-    variable_access: VariableAccess,\n+    variable_access: VariableAccess<'_, 'll>,\n     variable_kind: VariableKind,\n     span: Span,\n ) {"}, {"sha": "55cf139394344d0e9a53f18467cca59ef9754e61", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -19,7 +19,6 @@ use llvm::debuginfo::DIScope;\n use builder::Builder;\n \n use libc::c_uint;\n-use std::ptr::NonNull;\n use syntax_pos::{Span, Pos};\n \n /// Sets the current debug location at the beginning of the span.\n@@ -96,7 +95,7 @@ pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDeb\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n-                NonNull::new(llvm::LLVMRustDIBuilderCreateDebugLocation(\n+                Some(llvm::LLVMRustDIBuilderCreateDebugLocation(\n                     debug_context(bx.cx).llcontext,\n                     line as c_uint,\n                     col_used,"}, {"sha": "c7cd06669fab193c8f333431ea3d22496038dd54", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -16,11 +16,11 @@\n //! Some useful guidelines:\n //!\n //! * Use declare_* family of methods if you are declaring, but are not\n-//!   interested in defining the ValueRef they return.\n-//! * Use define_* family of methods when you might be defining the ValueRef.\n+//!   interested in defining the Value they return.\n+//! * Use define_* family of methods when you might be defining the Value.\n //! * When in doubt, define.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -39,8 +39,8 @@ use std::ffi::CString;\n /// Declare a global value.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// return its ValueRef instead.\n-pub fn declare_global(cx: &CodegenCx, name: &str, ty: &Type) -> llvm::ValueRef {\n+/// return its Value instead.\n+pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'ll Value {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n@@ -54,8 +54,8 @@ pub fn declare_global(cx: &CodegenCx, name: &str, ty: &Type) -> llvm::ValueRef {\n /// Declare a function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: &Type) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+fn declare_raw_fn(cx: &CodegenCx<'ll, '_>, name: &str, callconv: llvm::CallConv, ty: &'ll Type) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n@@ -114,18 +114,21 @@ fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: &Typ\n /// `declare_fn` instead.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: &Type) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+pub fn declare_cfn(cx: &CodegenCx<'ll, '_>, name: &str, fn_type: &'ll Type) -> &'ll Value {\n     declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n \n /// Declare a Rust function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n-                            fn_type: Ty<'tcx>) -> ValueRef {\n+/// update the declaration and return existing Value instead.\n+pub fn declare_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n     let sig = common::ty_fn_sig(cx, fn_type);\n     let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n@@ -154,7 +157,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(cx: &CodegenCx, name: &str, ty: &Type) -> Option<ValueRef> {\n+pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Option<&'ll Value> {\n     if get_defined_value(cx, name).is_some() {\n         None\n     } else {\n@@ -167,9 +170,11 @@ pub fn define_global(cx: &CodegenCx, name: &str, ty: &Type) -> Option<ValueRef>\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                           name: &str,\n-                           fn_type: Ty<'tcx>) -> ValueRef {\n+pub fn define_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     if get_defined_value(cx, name).is_some() {\n         cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n@@ -182,34 +187,29 @@ pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                    name: &str,\n-                                    fn_type: Ty<'tcx>) -> ValueRef {\n+pub fn define_internal_fn(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    fn_type: Ty<'tcx>,\n+) -> &'ll Value {\n     let llfn = define_fn(cx, name, fn_type);\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     llfn\n }\n \n \n /// Get declared value by name.\n-pub fn get_declared_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+pub fn get_declared_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) };\n-    if val.is_null() {\n-        debug!(\"get_declared_value: {:?} value is null\", name);\n-        None\n-    } else {\n-        debug!(\"get_declared_value: {:?} => {:?}\", name, Value(val));\n-        Some(val)\n-    }\n+    unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) }\n }\n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-pub fn get_defined_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+pub fn get_defined_value(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     get_declared_value(cx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0"}, {"sha": "37ce51da778235f7e58a4a83ef7dcf52c0477126", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -16,37 +16,36 @@ use std;\n \n use builder::Builder;\n use common::*;\n-use llvm::{ValueRef};\n use llvm;\n use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n \n-pub fn size_and_align_of_dst(bx: &Builder<'a, 'll, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n-                                       -> (ValueRef, ValueRef) {\n+pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Option<&'ll Value>)\n+                                       -> (&'ll Value, &'ll Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n-           t, Value(info));\n+           t, info);\n     if bx.cx.type_is_sized(t) {\n         let (size, align) = bx.cx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n-               t, Value(info), size, align);\n+               t, info, size, align);\n         let size = C_usize(bx.cx, size.bytes());\n         let align = C_usize(bx.cx, align.abi());\n         return (size, align);\n     }\n-    assert!(!info.is_null());\n     match t.sty {\n         ty::TyDynamic(..) => {\n             // load size/align from vtable\n-            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n+            let vtable = info.unwrap();\n+            (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n+            (bx.mul(info.unwrap(), C_usize(bx.cx, size.bytes())),\n              C_usize(bx.cx, align.abi()))\n         }\n         _ => {"}, {"sha": "06a5c34a4cae058ce7c9b94431fb8120543b7ba6", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -11,8 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use intrinsics::{self, Intrinsic};\n-use llvm;\n-use llvm::{TypeKind, ValueRef};\n+use llvm::{self, TypeKind};\n use abi::{Abi, FnType, LlvmType, PassMode};\n use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n@@ -28,14 +27,15 @@ use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use builder::Builder;\n+use value::Value;\n \n use rustc::session::Session;\n use syntax_pos::Span;\n \n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -89,8 +89,8 @@ pub fn codegen_intrinsic_call(\n     bx: &Builder<'a, 'll, 'tcx>,\n     callee_ty: Ty<'tcx>,\n     fn_ty: &FnType<'tcx, Ty<'tcx>>,\n-    args: &[OperandRef<'tcx>],\n-    llresult: ValueRef,\n+    args: &[OperandRef<'ll, 'tcx>],\n+    llresult: &'ll Value,\n     span: Span,\n ) {\n     let cx = bx.cx;\n@@ -148,7 +148,7 @@ pub fn codegen_intrinsic_call(\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llsize\n             } else {\n                 C_usize(cx, cx.size_of(tp_ty).bytes())\n@@ -162,7 +162,7 @@ pub fn codegen_intrinsic_call(\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llalign\n             } else {\n                 C_usize(cx, cx.align_of(tp_ty).abi())\n@@ -592,9 +592,8 @@ pub fn codegen_intrinsic_call(\n             fn modify_as_needed(\n                 bx: &Builder<'a, 'll, 'tcx>,\n                 t: &intrinsics::Type,\n-                arg: &OperandRef<'tcx>,\n-            ) -> Vec<ValueRef>\n-            {\n+                arg: &OperandRef<'ll, 'tcx>,\n+            ) -> Vec<&'ll Value> {\n                 match *t {\n                     intrinsics::Type::Aggregate(true, ref contents) => {\n                         // We found a tuple that needs squishing! So\n@@ -685,10 +684,10 @@ fn copy_intrinsic(\n     allow_overlap: bool,\n     volatile: bool,\n     ty: Ty<'tcx>,\n-    dst: ValueRef,\n-    src: ValueRef,\n-    count: ValueRef,\n-) -> ValueRef {\n+    dst: &'ll Value,\n+    src: &'ll Value,\n+    count: &'ll Value,\n+) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n@@ -720,10 +719,10 @@ fn memset_intrinsic(\n     bx: &Builder<'a, 'll, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n-    dst: ValueRef,\n-    val: ValueRef,\n-    count: ValueRef\n-) -> ValueRef {\n+    dst: &'ll Value,\n+    val: &'ll Value,\n+    count: &'ll Value\n+) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n@@ -734,11 +733,11 @@ fn memset_intrinsic(\n \n fn try_intrinsic(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx,\n-    func: ValueRef,\n-    data: ValueRef,\n-    local_ptr: ValueRef,\n-    dest: ValueRef,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n ) {\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n@@ -760,11 +759,11 @@ fn try_intrinsic(\n // as the old ones are still more optimized.\n fn codegen_msvc_try(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx,\n-    func: ValueRef,\n-    data: ValueRef,\n-    local_ptr: ValueRef,\n-    dest: ValueRef,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n@@ -870,11 +869,11 @@ fn codegen_msvc_try(\n // the right personality function.\n fn codegen_gnu_try(\n     bx: &Builder<'a, 'll, 'tcx>,\n-    cx: &CodegenCx,\n-    func: ValueRef,\n-    data: ValueRef,\n-    local_ptr: ValueRef,\n-    dest: ValueRef,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func: &'ll Value,\n+    data: &'ll Value,\n+    local_ptr: &'ll Value,\n+    dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n@@ -936,7 +935,7 @@ fn gen_fn<'ll, 'tcx>(\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> ValueRef {\n+) -> &'ll Value {\n     let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n@@ -957,7 +956,7 @@ fn gen_fn<'ll, 'tcx>(\n fn get_rust_try_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n-) -> ValueRef {\n+) -> &'ll Value {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n@@ -986,11 +985,11 @@ fn generic_simd_intrinsic(\n     bx: &Builder<'a, 'll, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n-    args: &[OperandRef<'tcx>],\n+    args: &[OperandRef<'ll, 'tcx>],\n     ret_ty: Ty<'tcx>,\n     llret_ty: &'ll Type,\n     span: Span\n-) -> Result<ValueRef, ()> {\n+) -> Result<&'ll Value, ()> {\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -1167,8 +1166,8 @@ fn generic_simd_intrinsic(\n         in_len: usize,\n         bx: &Builder<'a, 'll, 'tcx>,\n         span: Span,\n-        args: &[OperandRef<'tcx>],\n-    ) -> Result<ValueRef, ()> {\n+        args: &[OperandRef<'ll, 'tcx>],\n+    ) -> Result<&'ll Value, ()> {\n         macro_rules! emit_error {\n             ($msg: tt) => {\n                 emit_error!($msg, )"}, {"sha": "e4c278442d91c1063669713ac78e4d41002d7228", "filename": "src/librustc_codegen_llvm/llvm/diagnostic.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -14,8 +14,9 @@ pub use self::OptimizationDiagnosticKind::*;\n pub use self::Diagnostic::*;\n \n use libc::c_uint;\n+use value::Value;\n \n-use super::{DiagnosticInfoRef, TwineRef, ValueRef};\n+use super::{DiagnosticInfoRef, TwineRef};\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {\n@@ -41,21 +42,22 @@ impl OptimizationDiagnosticKind {\n     }\n }\n \n-pub struct OptimizationDiagnostic {\n+pub struct OptimizationDiagnostic<'ll> {\n     pub kind: OptimizationDiagnosticKind,\n     pub pass_name: String,\n-    pub function: ValueRef,\n+    pub function: &'ll Value,\n     pub line: c_uint,\n     pub column: c_uint,\n     pub filename: String,\n     pub message: String,\n }\n \n-impl OptimizationDiagnostic {\n-    unsafe fn unpack(kind: OptimizationDiagnosticKind,\n-                     di: DiagnosticInfoRef)\n-                     -> OptimizationDiagnostic {\n-        let mut function = 0 as *mut _;\n+impl OptimizationDiagnostic<'ll> {\n+    unsafe fn unpack(\n+        kind: OptimizationDiagnosticKind,\n+        di: DiagnosticInfoRef,\n+    ) -> Self {\n+        let mut function = None;\n         let mut line = 0;\n         let mut column = 0;\n \n@@ -83,7 +85,7 @@ impl OptimizationDiagnostic {\n         OptimizationDiagnostic {\n             kind,\n             pass_name: pass_name.expect(\"got a non-UTF8 pass name from LLVM\"),\n-            function,\n+            function: function.unwrap(),\n             line,\n             column,\n             filename,\n@@ -93,41 +95,44 @@ impl OptimizationDiagnostic {\n }\n \n #[derive(Copy, Clone)]\n-pub struct InlineAsmDiagnostic {\n+pub struct InlineAsmDiagnostic<'ll> {\n     pub cookie: c_uint,\n     pub message: TwineRef,\n-    pub instruction: ValueRef,\n+    pub instruction: &'ll Value,\n }\n \n-impl InlineAsmDiagnostic {\n-    unsafe fn unpack(di: DiagnosticInfoRef) -> InlineAsmDiagnostic {\n-\n-        let mut opt = InlineAsmDiagnostic {\n-            cookie: 0,\n-            message: 0 as *mut _,\n-            instruction: 0 as *mut _,\n-        };\n-\n-        super::LLVMRustUnpackInlineAsmDiagnostic(di,\n-                                                 &mut opt.cookie,\n-                                                 &mut opt.message,\n-                                                 &mut opt.instruction);\n+impl InlineAsmDiagnostic<'ll> {\n+    unsafe fn unpack(di: DiagnosticInfoRef) -> Self {\n+        let mut cookie = 0;\n+        let mut message = 0 as *mut _;\n+        let mut instruction = None;\n+\n+        super::LLVMRustUnpackInlineAsmDiagnostic(\n+            di,\n+            &mut cookie,\n+            &mut message,\n+            &mut instruction,\n+        );\n \n-        opt\n+        InlineAsmDiagnostic {\n+            cookie,\n+            message,\n+            instruction: instruction.unwrap(),\n+        }\n     }\n }\n \n-pub enum Diagnostic {\n-    Optimization(OptimizationDiagnostic),\n-    InlineAsm(InlineAsmDiagnostic),\n+pub enum Diagnostic<'ll> {\n+    Optimization(OptimizationDiagnostic<'ll>),\n+    InlineAsm(InlineAsmDiagnostic<'ll>),\n     PGO(DiagnosticInfoRef),\n \n     /// LLVM has other types that we do not wrap here.\n     UnknownDiagnostic(DiagnosticInfoRef),\n }\n \n-impl Diagnostic {\n-    pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n+impl Diagnostic<'ll> {\n+    pub unsafe fn unpack(di: DiagnosticInfoRef) -> Self {\n         use super::DiagnosticKind as Dk;\n         let kind = super::LLVMRustGetDiagInfoKind(di);\n "}, {"sha": "bf016bb8e3c6ad79c810f4cd47db53c96f4f4d28", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 461, "deletions": 462, "changes": 923, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -379,7 +379,6 @@ extern { pub type Module; }\n extern { pub type Context; }\n extern { pub type Type; }\n extern { pub type Value; }\n-pub type ValueRef = *mut Value;\n extern { pub type Metadata; }\n extern { pub type BasicBlock; }\n pub type BasicBlockRef = *mut BasicBlock;\n@@ -553,711 +552,711 @@ extern \"C\" {\n \n     // Operations on all values\n     pub fn LLVMTypeOf(Val: &Value) -> &Type;\n-    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+    pub fn LLVMGetValueName(Val: &Value) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: &Value, Name: *const c_char);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: &'a Value, NewVal: &'a Value);\n+    pub fn LLVMSetMetadata(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n \n     // Operations on Uses\n-    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub fn LLVMGetFirstUse(Val: &Value) -> UseRef;\n     pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub fn LLVMGetUser(U: UseRef) -> &'a Value;\n \n     // Operations on Users\n-    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMGetOperand(Val: &Value, Index: c_uint) -> &Value;\n \n     // Operations on constants of any type\n-    pub fn LLVMConstNull(Ty: &Type) -> ValueRef;\n-    pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    pub fn LLVMGetUndef(Ty: &Type) -> ValueRef;\n+    pub fn LLVMConstNull(Ty: &Type) -> &Value;\n+    pub fn LLVMConstICmp(Pred: IntPredicate, V1: &'a Value, V2: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFCmp(Pred: RealPredicate, V1: &'a Value, V2: &'a Value) -> &'a Value;\n+    pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n-    pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> ValueRef;\n-    pub fn LLVMMDNodeInContext(C: &Context, Vals: *const ValueRef, Count: c_uint) -> ValueRef;\n-    pub fn LLVMAddNamedMetadataOperand(M: &Module, Name: *const c_char, Val: ValueRef);\n+    pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n+    pub fn LLVMMDNodeInContext(C: &'a Context, Vals: *const &'a Value, Count: c_uint) -> &'a Value;\n+    pub fn LLVMAddNamedMetadataOperand(M: &'a Module, Name: *const c_char, Val: &'a Value);\n \n     // Operations on scalar constants\n-    pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n-    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> ValueRef;\n-    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-    pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n+    pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> &Value;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> &Value;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: &Value) -> c_ulonglong;\n+    pub fn LLVMConstIntGetSExtValue(ConstantVal: &Value) -> c_longlong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: &Value, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n-    pub fn LLVMConstRealGetDouble (ConstantVal: ValueRef, losesInfo: *mut Bool) -> f64;\n+    pub fn LLVMConstRealGetDouble (ConstantVal: &Value, losesInfo: *mut Bool) -> f64;\n \n \n     // Operations on composite constants\n     pub fn LLVMConstStringInContext(C: &Context,\n                                     Str: *const c_char,\n                                     Length: c_uint,\n                                     DontNullTerminate: Bool)\n-                                    -> ValueRef;\n-    pub fn LLVMConstStructInContext(C: &Context,\n-                                    ConstantVals: *const ValueRef,\n+                                    -> &Value;\n+    pub fn LLVMConstStructInContext(C: &'a Context,\n+                                    ConstantVals: *const &'a Value,\n                                     Count: c_uint,\n                                     Packed: Bool)\n-                                    -> ValueRef;\n+                                    -> &'a Value;\n \n-    pub fn LLVMConstArray(ElementTy: &Type,\n-                          ConstantVals: *const ValueRef,\n+    pub fn LLVMConstArray(ElementTy: &'a Type,\n+                          ConstantVals: *const &'a Value,\n                           Length: c_uint)\n-                          -> ValueRef;\n-    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint) -> ValueRef;\n+                          -> &'a Value;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const &Value, Size: c_uint) -> &Value;\n \n     // Constant expressions\n-    pub fn LLVMSizeOf(Ty: &Type) -> ValueRef;\n-    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n-    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: &Type) -> &Value;\n+    pub fn LLVMConstNeg(ConstantVal: &Value) -> &Value;\n+    pub fn LLVMConstFNeg(ConstantVal: &Value) -> &Value;\n+    pub fn LLVMConstNot(ConstantVal: &Value) -> &Value;\n+    pub fn LLVMConstAdd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFAdd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstSub(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFSub(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstMul(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFMul(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstUDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstSDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFDiv(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstURem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstSRem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstFRem(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstAnd(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstOr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstXor(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstShl(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstLShr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n+    pub fn LLVMConstAShr(LHSConstant: &'a Value, RHSConstant: &'a Value) -> &'a Value;\n     pub fn LLVMConstGEP(\n-        ConstantVal: ValueRef,\n-        ConstantIndices: *const ValueRef,\n+        ConstantVal: &'a Value,\n+        ConstantIndices: *const &'a Value,\n         NumIndices: c_uint,\n-    ) -> ValueRef;\n+    ) -> &'a Value;\n     pub fn LLVMConstInBoundsGEP(\n-        ConstantVal: ValueRef,\n-        ConstantIndices: *const ValueRef,\n+        ConstantVal: &'a Value,\n+        ConstantIndices: *const &'a Value,\n         NumIndices: c_uint,\n-    ) -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: &Type, isSigned: Bool) -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n-    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n+    ) -> &'a Value;\n+    pub fn LLVMConstTrunc(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstZExt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstUIToFP(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstSIToFP(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstFPToUI(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstFPToSI(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPtrToInt(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstIntToPtr(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstBitCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstPointerCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstIntCast(ConstantVal: &'a Value, ToType: &'a Type, isSigned: Bool) -> &'a Value;\n+    pub fn LLVMConstFPCast(ConstantVal: &'a Value, ToType: &'a Type) -> &'a Value;\n+    pub fn LLVMConstExtractValue(AggConstant: &Value,\n                                  IdxList: *const c_uint,\n                                  NumIdx: c_uint)\n-                                 -> ValueRef;\n+                                 -> &Value;\n     pub fn LLVMConstInlineAsm(Ty: &Type,\n                               AsmString: *const c_char,\n                               Constraints: *const c_char,\n                               HasSideEffects: Bool,\n                               IsAlignStack: Bool)\n-                              -> ValueRef;\n+                              -> &Value;\n \n \n     // Operations on global variables, functions, and aliases (globals)\n-    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-    pub fn LLVMRustGetLinkage(Global: ValueRef) -> Linkage;\n-    pub fn LLVMRustSetLinkage(Global: ValueRef, RustLinkage: Linkage);\n-    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMRustGetVisibility(Global: ValueRef) -> Visibility;\n-    pub fn LLVMRustSetVisibility(Global: ValueRef, Viz: Visibility);\n-    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-    pub fn LLVMSetDLLStorageClass(V: ValueRef, C: DLLStorageClass);\n+    pub fn LLVMIsDeclaration(Global: &Value) -> Bool;\n+    pub fn LLVMRustGetLinkage(Global: &Value) -> Linkage;\n+    pub fn LLVMRustSetLinkage(Global: &Value, RustLinkage: Linkage);\n+    pub fn LLVMGetSection(Global: &Value) -> *const c_char;\n+    pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n+    pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n+    pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n+    pub fn LLVMGetAlignment(Global: &Value) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: &Value, Bytes: c_uint);\n+    pub fn LLVMSetDLLStorageClass(V: &Value, C: DLLStorageClass);\n \n \n     // Operations on global variables\n-    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: &Module, Ty: &Type, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertGlobal(M: &Module, Name: *const c_char, T: &Type) -> ValueRef;\n-    pub fn LLVMGetFirstGlobal(M: &Module) -> ValueRef;\n-    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMSetInitializer(GlobalVar: ValueRef, ConstantVal: ValueRef);\n-    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-    pub fn LLVMSetThreadLocalMode(GlobalVar: ValueRef, Mode: ThreadLocalMode);\n-    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-    pub fn LLVMRustGetNamedValue(M: &Module, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMAddGlobal(M: &'a Module, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> Option<&Value>;\n+    pub fn LLVMRustGetOrInsertGlobal(M: &'a Module, Name: *const c_char, T: &'a Type) -> &'a Value;\n+    pub fn LLVMGetFirstGlobal(M: &Module) -> Option<&Value>;\n+    pub fn LLVMGetNextGlobal(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMDeleteGlobal(GlobalVar: &Value);\n+    pub fn LLVMGetInitializer(GlobalVar: &Value) -> Option<&Value>;\n+    pub fn LLVMSetInitializer(GlobalVar: &'a Value, ConstantVal: &'a Value);\n+    pub fn LLVMSetThreadLocal(GlobalVar: &Value, IsThreadLocal: Bool);\n+    pub fn LLVMSetThreadLocalMode(GlobalVar: &Value, Mode: ThreadLocalMode);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: &Value) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: &Value, IsConstant: Bool);\n+    pub fn LLVMRustGetNamedValue(M: &Module, Name: *const c_char) -> Option<&Value>;\n+    pub fn LLVMSetTailCall(CallInst: &Value, IsTailCall: Bool);\n \n     // Operations on functions\n-    pub fn LLVMAddFunction(M: &Module, Name: *const c_char, FunctionTy: &Type) -> ValueRef;\n-    pub fn LLVMGetNamedFunction(M: &Module, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMGetFirstFunction(M: &Module) -> ValueRef;\n-    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertFunction(M: &Module,\n+    pub fn LLVMAddFunction(M: &'a Module, Name: *const c_char, FunctionTy: &'a Type) -> &'a Value;\n+    pub fn LLVMGetNamedFunction(M: &Module, Name: *const c_char) -> &Value;\n+    pub fn LLVMGetFirstFunction(M: &Module) -> &Value;\n+    pub fn LLVMGetNextFunction(Fn: &Value) -> &Value;\n+    pub fn LLVMRustGetOrInsertFunction(M: &'a Module,\n                                        Name: *const c_char,\n-                                       FunctionTy: &Type)\n-                                       -> ValueRef;\n-    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    pub fn LLVMRustAddAlignmentAttr(Fn: ValueRef, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n+                                       FunctionTy: &'a Type)\n+                                       -> &'a Value;\n+    pub fn LLVMSetFunctionCallConv(Fn: &Value, CC: c_uint);\n+    pub fn LLVMRustAddAlignmentAttr(Fn: &Value, index: c_uint, bytes: u32);\n+    pub fn LLVMRustAddDereferenceableAttr(Fn: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: &Value, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddFunctionAttrStringValue(Fn: &Value,\n                                               index: c_uint,\n                                               Name: *const c_char,\n                                               Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: &Value, index: c_uint, attr: Attribute);\n \n     // Operations on parameters\n-    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMCountParams(Fn: &Value) -> c_uint;\n+    pub fn LLVMGetParam(Fn: &Value, Index: c_uint) -> &Value;\n \n     // Operations on basic blocks\n-    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMAppendBasicBlockInContext(C: &Context,\n-                                         Fn: ValueRef,\n+    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> &'a Value;\n+    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> &'a Value;\n+    pub fn LLVMAppendBasicBlockInContext(C: &'a Context,\n+                                         Fn: &'a Value,\n                                          Name: *const c_char)\n                                          -> BasicBlockRef;\n     pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n     // Operations on instructions\n-    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n+    pub fn LLVMGetInstructionParent(Inst: &Value) -> BasicBlockRef;\n+    pub fn LLVMGetFirstBasicBlock(Fn: &Value) -> BasicBlockRef;\n+    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> &'a Value;\n+    pub fn LLVMInstructionEraseFromParent(Inst: &Value);\n \n     // Operations on call sites\n-    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: Attribute);\n-    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u32);\n-    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: ValueRef,\n+    pub fn LLVMSetInstructionCallConv(Instr: &Value, CC: c_uint);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: &Value, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: &Value, index: c_uint, bytes: u32);\n+    pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: &Value,\n                                                         index: c_uint,\n                                                         bytes: u64);\n \n     // Operations on load/store instructions (only)\n-    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n+    pub fn LLVMSetVolatile(MemoryAccessInst: &Value, volatile: Bool);\n \n     // Operations on phi nodes\n-    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                           IncomingValues: *const ValueRef,\n+    pub fn LLVMAddIncoming(PhiNode: &'a Value,\n+                           IncomingValues: *const &'a Value,\n                            IncomingBlocks: *const BasicBlockRef,\n                            Count: c_uint);\n \n     // Instruction builders\n     pub fn LLVMCreateBuilderInContext(C: &Context) -> &Builder;\n-    pub fn LLVMPositionBuilder(Builder: &Builder, Block: BasicBlockRef, Instr: ValueRef);\n-    pub fn LLVMPositionBuilderBefore(Builder: &Builder, Instr: ValueRef);\n+    pub fn LLVMPositionBuilder(Builder: &'a Builder, Block: BasicBlockRef, Instr: &'a Value);\n+    pub fn LLVMPositionBuilderBefore(Builder: &'a Builder, Instr: &'a Value);\n     pub fn LLVMPositionBuilderAtEnd(Builder: &Builder, Block: BasicBlockRef);\n     pub fn LLVMGetInsertBlock(Builder: &Builder) -> BasicBlockRef;\n     pub fn LLVMDisposeBuilder(Builder: &Builder);\n \n     // Metadata\n-    pub fn LLVMSetCurrentDebugLocation(Builder: &Builder, L: Option<NonNull<Value>>);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: &Builder) -> ValueRef;\n-    pub fn LLVMSetInstDebugLocation(Builder: &Builder, Inst: ValueRef);\n+    pub fn LLVMSetCurrentDebugLocation(Builder: &'a Builder, L: Option<&'a Value>);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: &Builder) -> &Value;\n+    pub fn LLVMSetInstDebugLocation(Builder: &'a Builder, Inst: &'a Value);\n \n     // Terminators\n-    pub fn LLVMBuildRetVoid(B: &Builder) -> ValueRef;\n-    pub fn LLVMBuildRet(B: &Builder, V: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildAggregateRet(B: &Builder, RetVals: *const ValueRef, N: c_uint) -> ValueRef;\n-    pub fn LLVMBuildBr(B: &Builder, Dest: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMBuildCondBr(B: &Builder,\n-                           If: ValueRef,\n+    pub fn LLVMBuildRetVoid(B: &Builder) -> &Value;\n+    pub fn LLVMBuildRet(B: &'a Builder, V: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildAggregateRet(B: &'a Builder, RetVals: *const &'a Value, N: c_uint) -> &'a Value;\n+    pub fn LLVMBuildBr(B: &Builder, Dest: BasicBlockRef) -> &Value;\n+    pub fn LLVMBuildCondBr(B: &'a Builder,\n+                           If: &'a Value,\n                            Then: BasicBlockRef,\n                            Else: BasicBlockRef)\n-                           -> ValueRef;\n-    pub fn LLVMBuildSwitch(B: &Builder,\n-                           V: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildSwitch(B: &'a Builder,\n+                           V: &'a Value,\n                            Else: BasicBlockRef,\n                            NumCases: c_uint)\n-                           -> ValueRef;\n-    pub fn LLVMBuildIndirectBr(B: &Builder, Addr: ValueRef, NumDests: c_uint) -> ValueRef;\n-    pub fn LLVMRustBuildInvoke(B: &Builder,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildIndirectBr(B: &'a Builder, Addr: &'a Value, NumDests: c_uint) -> &'a Value;\n+    pub fn LLVMRustBuildInvoke(B: &'a Builder,\n+                               Fn: &'a Value,\n+                               Args: *const &'a Value,\n                                NumArgs: c_uint,\n                                Then: BasicBlockRef,\n                                Catch: BasicBlockRef,\n                                Bundle: Option<NonNull<OperandBundleDef>>,\n                                Name: *const c_char)\n-                               -> ValueRef;\n+                               -> &'a Value;\n     pub fn LLVMBuildLandingPad(B: &'a Builder,\n                                Ty: &'a Type,\n-                               PersFn: ValueRef,\n+                               PersFn: &'a Value,\n                                NumClauses: c_uint,\n                                Name: *const c_char)\n-                               -> ValueRef;\n-    pub fn LLVMBuildResume(B: &Builder, Exn: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildUnreachable(B: &Builder) -> ValueRef;\n+                               -> &'a Value;\n+    pub fn LLVMBuildResume(B: &'a Builder, Exn: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildUnreachable(B: &Builder) -> &Value;\n \n-    pub fn LLVMRustBuildCleanupPad(B: &Builder,\n-                                   ParentPad: Option<NonNull<Value>>,\n+    pub fn LLVMRustBuildCleanupPad(B: &'a Builder,\n+                                   ParentPad: Option<&'a Value>,\n                                    ArgCnt: c_uint,\n-                                   Args: *const ValueRef,\n+                                   Args: *const &'a Value,\n                                    Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMRustBuildCleanupRet(B: &Builder,\n-                                   CleanupPad: ValueRef,\n+                                   -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCleanupRet(B: &'a Builder,\n+                                   CleanupPad: &'a Value,\n                                    UnwindBB: Option<NonNull<BasicBlock>>)\n-                                   -> ValueRef;\n-    pub fn LLVMRustBuildCatchPad(B: &Builder,\n-                                 ParentPad: ValueRef,\n+                                   -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchPad(B: &'a Builder,\n+                                 ParentPad: &'a Value,\n                                  ArgCnt: c_uint,\n-                                 Args: *const ValueRef,\n+                                 Args: *const &'a Value,\n                                  Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMRustBuildCatchRet(B: &Builder, Pad: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-    pub fn LLVMRustBuildCatchSwitch(Builder: &Builder,\n-                                    ParentPad: Option<NonNull<Value>>,\n+                                 -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchRet(B: &'a Builder, Pad: &'a Value, BB: BasicBlockRef) -> Option<&'a Value>;\n+    pub fn LLVMRustBuildCatchSwitch(Builder: &'a Builder,\n+                                    ParentPad: Option<&'a Value>,\n                                     BB: Option<NonNull<BasicBlock>>,\n                                     NumHandlers: c_uint,\n                                     Name: *const c_char)\n-                                    -> ValueRef;\n-    pub fn LLVMRustAddHandler(CatchSwitch: ValueRef, Handler: BasicBlockRef);\n-    pub fn LLVMSetPersonalityFn(Func: ValueRef, Pers: ValueRef);\n+                                    -> Option<&'a Value>;\n+    pub fn LLVMRustAddHandler(CatchSwitch: &Value, Handler: BasicBlockRef);\n+    pub fn LLVMSetPersonalityFn(Func: &'a Value, Pers: &'a Value);\n \n     // Add a case to the switch instruction\n-    pub fn LLVMAddCase(Switch: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef);\n+    pub fn LLVMAddCase(Switch: &'a Value, OnVal: &'a Value, Dest: BasicBlockRef);\n \n     // Add a clause to the landing pad instruction\n-    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+    pub fn LLVMAddClause(LandingPad: &'a Value, ClauseVal: &'a Value);\n \n     // Set the cleanup on a landing pad instruction\n-    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+    pub fn LLVMSetCleanup(LandingPad: &Value, Val: Bool);\n \n     // Arithmetic\n-    pub fn LLVMBuildAdd(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+    pub fn LLVMBuildAdd(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWAdd(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildNSWAdd(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWAdd(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildNUWAdd(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFAdd(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildFAdd(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSub(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildSub(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWSub(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildNSWSub(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWSub(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildNUWSub(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFSub(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildFSub(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildMul(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildMul(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildNSWMul(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildNSWMul(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildNUWMul(B: &Builder,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildNUWMul(B: &'a Builder,\n+                           LHS: &'a Value,\n+                           RHS: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n-    pub fn LLVMBuildFMul(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                           -> &'a Value;\n+    pub fn LLVMBuildFMul(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildUDiv(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildUDiv(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactUDiv(B: &Builder,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildExactUDiv(B: &'a Builder,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n                               Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildSDiv(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                              -> &'a Value;\n+    pub fn LLVMBuildSDiv(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildExactSDiv(B: &Builder,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildExactSDiv(B: &'a Builder,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n                               Name: *const c_char)\n-                              -> ValueRef;\n-    pub fn LLVMBuildFDiv(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                              -> &'a Value;\n+    pub fn LLVMBuildFDiv(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildURem(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildURem(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildSRem(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildSRem(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFRem(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildFRem(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildShl(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildShl(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildLShr(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildLShr(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAShr(B: &Builder,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildAShr(B: &'a Builder,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildAnd(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+                         -> &'a Value;\n+    pub fn LLVMBuildAnd(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildOr(B: &Builder,\n-                       LHS: ValueRef,\n-                       RHS: ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildOr(B: &'a Builder,\n+                       LHS: &'a Value,\n+                       RHS: &'a Value,\n                        Name: *const c_char)\n-                       -> ValueRef;\n-    pub fn LLVMBuildXor(B: &Builder,\n-                        LHS: ValueRef,\n-                        RHS: ValueRef,\n+                       -> &'a Value;\n+    pub fn LLVMBuildXor(B: &'a Builder,\n+                        LHS: &'a Value,\n+                        RHS: &'a Value,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildBinOp(B: &Builder,\n+                        -> &'a Value;\n+    pub fn LLVMBuildBinOp(B: &'a Builder,\n                           Op: Opcode,\n-                          LHS: ValueRef,\n-                          RHS: ValueRef,\n+                          LHS: &'a Value,\n+                          RHS: &'a Value,\n                           Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildNeg(B: &Builder, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNSWNeg(B: &Builder, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNUWNeg(B: &Builder, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildFNeg(B: &Builder, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildNot(B: &Builder, V: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n+                          -> &'a Value;\n+    pub fn LLVMBuildNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNSWNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNUWNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildFNeg(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildNot(B: &'a Builder, V: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: &Value);\n \n     // Memory\n-    pub fn LLVMBuildAlloca(B: &Builder, Ty: &Type, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildFree(B: &Builder, PointerVal: ValueRef) -> ValueRef;\n-    pub fn LLVMBuildLoad(B: &Builder, PointerVal: ValueRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildAlloca(B: &'a Builder, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildFree(B: &'a Builder, PointerVal: &'a Value) -> &'a Value;\n+    pub fn LLVMBuildLoad(B: &'a Builder, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n \n-    pub fn LLVMBuildStore(B: &Builder, Val: ValueRef, Ptr: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildStore(B: &'a Builder, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n \n-    pub fn LLVMBuildGEP(B: &Builder,\n-                        Pointer: ValueRef,\n-                        Indices: *const ValueRef,\n+    pub fn LLVMBuildGEP(B: &'a Builder,\n+                        Pointer: &'a Value,\n+                        Indices: *const &'a Value,\n                         NumIndices: c_uint,\n                         Name: *const c_char)\n-                        -> ValueRef;\n-    pub fn LLVMBuildInBoundsGEP(B: &Builder,\n-                                Pointer: ValueRef,\n-                                Indices: *const ValueRef,\n+                        -> &'a Value;\n+    pub fn LLVMBuildInBoundsGEP(B: &'a Builder,\n+                                Pointer: &'a Value,\n+                                Indices: *const &'a Value,\n                                 NumIndices: c_uint,\n                                 Name: *const c_char)\n-                                -> ValueRef;\n-    pub fn LLVMBuildStructGEP(B: &Builder,\n-                              Pointer: ValueRef,\n+                                -> &'a Value;\n+    pub fn LLVMBuildStructGEP(B: &'a Builder,\n+                              Pointer: &'a Value,\n                               Idx: c_uint,\n                               Name: *const c_char)\n-                              -> ValueRef;\n+                              -> &'a Value;\n     pub fn LLVMBuildGlobalString(B: &Builder,\n                                  Str: *const c_char,\n                                  Name: *const c_char)\n-                                 -> ValueRef;\n+                                 -> &Value;\n     pub fn LLVMBuildGlobalStringPtr(B: &Builder,\n                                     Str: *const c_char,\n                                     Name: *const c_char)\n-                                    -> ValueRef;\n+                                    -> &Value;\n \n     // Casts\n     pub fn LLVMBuildTrunc(B: &'a Builder,\n-                          Val: ValueRef,\n+                          Val: &'a Value,\n                           DestTy: &'a Type,\n                           Name: *const c_char)\n-                          -> ValueRef;\n+                          -> &'a Value;\n     pub fn LLVMBuildZExt(B: &'a Builder,\n-                         Val: ValueRef,\n+                         Val: &'a Value,\n                          DestTy: &'a Type,\n                          Name: *const c_char)\n-                         -> ValueRef;\n+                         -> &'a Value;\n     pub fn LLVMBuildSExt(B: &'a Builder,\n-                         Val: ValueRef,\n+                         Val: &'a Value,\n                          DestTy: &'a Type,\n                          Name: *const c_char)\n-                         -> ValueRef;\n+                         -> &'a Value;\n     pub fn LLVMBuildFPToUI(B: &'a Builder,\n-                           Val: ValueRef,\n+                           Val: &'a Value,\n                            DestTy: &'a Type,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n     pub fn LLVMBuildFPToSI(B: &'a Builder,\n-                           Val: ValueRef,\n+                           Val: &'a Value,\n                            DestTy: &'a Type,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n     pub fn LLVMBuildUIToFP(B: &'a Builder,\n-                           Val: ValueRef,\n+                           Val: &'a Value,\n                            DestTy: &'a Type,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n     pub fn LLVMBuildSIToFP(B: &'a Builder,\n-                           Val: ValueRef,\n+                           Val: &'a Value,\n                            DestTy: &'a Type,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n     pub fn LLVMBuildFPTrunc(B: &'a Builder,\n-                            Val: ValueRef,\n+                            Val: &'a Value,\n                             DestTy: &'a Type,\n                             Name: *const c_char)\n-                            -> ValueRef;\n+                            -> &'a Value;\n     pub fn LLVMBuildFPExt(B: &'a Builder,\n-                          Val: ValueRef,\n+                          Val: &'a Value,\n                           DestTy: &'a Type,\n                           Name: *const c_char)\n-                          -> ValueRef;\n+                          -> &'a Value;\n     pub fn LLVMBuildPtrToInt(B: &'a Builder,\n-                             Val: ValueRef,\n+                             Val: &'a Value,\n                              DestTy: &'a Type,\n                              Name: *const c_char)\n-                             -> ValueRef;\n+                             -> &'a Value;\n     pub fn LLVMBuildIntToPtr(B: &'a Builder,\n-                             Val: ValueRef,\n+                             Val: &'a Value,\n                              DestTy: &'a Type,\n                              Name: *const c_char)\n-                             -> ValueRef;\n+                             -> &'a Value;\n     pub fn LLVMBuildBitCast(B: &'a Builder,\n-                            Val: ValueRef,\n+                            Val: &'a Value,\n                             DestTy: &'a Type,\n                             Name: *const c_char)\n-                            -> ValueRef;\n+                            -> &'a Value;\n     pub fn LLVMBuildZExtOrBitCast(B: &'a Builder,\n-                                  Val: ValueRef,\n+                                  Val: &'a Value,\n                                   DestTy: &'a Type,\n                                   Name: *const c_char)\n-                                  -> ValueRef;\n+                                  -> &'a Value;\n     pub fn LLVMBuildSExtOrBitCast(B: &'a Builder,\n-                                  Val: ValueRef,\n+                                  Val: &'a Value,\n                                   DestTy: &'a Type,\n                                   Name: *const c_char)\n-                                  -> ValueRef;\n+                                  -> &'a Value;\n     pub fn LLVMBuildTruncOrBitCast(B: &'a Builder,\n-                                   Val: ValueRef,\n+                                   Val: &'a Value,\n                                    DestTy: &'a Type,\n                                    Name: *const c_char)\n-                                   -> ValueRef;\n+                                   -> &'a Value;\n     pub fn LLVMBuildCast(B: &'a Builder,\n                          Op: Opcode,\n-                         Val: ValueRef,\n+                         Val: &'a Value,\n                          DestTy: &'a Type,\n                          Name: *const c_char)\n-                         -> ValueRef;\n+                         -> &'a Value;\n     pub fn LLVMBuildPointerCast(B: &'a Builder,\n-                                Val: ValueRef,\n+                                Val: &'a Value,\n                                 DestTy: &'a Type,\n                                 Name: *const c_char)\n-                                -> ValueRef;\n+                                -> &'a Value;\n     pub fn LLVMRustBuildIntCast(B: &'a Builder,\n-                                Val: ValueRef,\n+                                Val: &'a Value,\n                                 DestTy: &'a Type,\n                                 IsSized: bool)\n-                                -> ValueRef;\n+                                -> &'a Value;\n     pub fn LLVMBuildFPCast(B: &'a Builder,\n-                           Val: ValueRef,\n+                           Val: &'a Value,\n                            DestTy: &'a Type,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n \n     // Comparisons\n-    pub fn LLVMBuildICmp(B: &Builder,\n+    pub fn LLVMBuildICmp(B: &'a Builder,\n                          Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n-    pub fn LLVMBuildFCmp(B: &Builder,\n+                         -> &'a Value;\n+    pub fn LLVMBuildFCmp(B: &'a Builder,\n                          Op: c_uint,\n-                         LHS: ValueRef,\n-                         RHS: ValueRef,\n+                         LHS: &'a Value,\n+                         RHS: &'a Value,\n                          Name: *const c_char)\n-                         -> ValueRef;\n+                         -> &'a Value;\n \n     // Miscellaneous instructions\n-    pub fn LLVMBuildPhi(B: &Builder, Ty: &Type, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustBuildCall(B: &Builder,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n+    pub fn LLVMBuildPhi(B: &'a Builder, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMRustBuildCall(B: &'a Builder,\n+                             Fn: &'a Value,\n+                             Args: *const &'a Value,\n                              NumArgs: c_uint,\n                              Bundle: Option<NonNull<OperandBundleDef>>,\n                              Name: *const c_char)\n-                             -> ValueRef;\n-    pub fn LLVMBuildSelect(B: &Builder,\n-                           If: ValueRef,\n-                           Then: ValueRef,\n-                           Else: ValueRef,\n+                             -> &'a Value;\n+    pub fn LLVMBuildSelect(B: &'a Builder,\n+                           If: &'a Value,\n+                           Then: &'a Value,\n+                           Else: &'a Value,\n                            Name: *const c_char)\n-                           -> ValueRef;\n+                           -> &'a Value;\n     pub fn LLVMBuildVAArg(B: &'a Builder,\n-                          list: ValueRef,\n+                          list: &'a Value,\n                           Ty: &'a Type,\n                           Name: *const c_char)\n-                          -> ValueRef;\n-    pub fn LLVMBuildExtractElement(B: &Builder,\n-                                   VecVal: ValueRef,\n-                                   Index: ValueRef,\n+                          -> &'a Value;\n+    pub fn LLVMBuildExtractElement(B: &'a Builder,\n+                                   VecVal: &'a Value,\n+                                   Index: &'a Value,\n                                    Name: *const c_char)\n-                                   -> ValueRef;\n-    pub fn LLVMBuildInsertElement(B: &Builder,\n-                                  VecVal: ValueRef,\n-                                  EltVal: ValueRef,\n-                                  Index: ValueRef,\n+                                   -> &'a Value;\n+    pub fn LLVMBuildInsertElement(B: &'a Builder,\n+                                  VecVal: &'a Value,\n+                                  EltVal: &'a Value,\n+                                  Index: &'a Value,\n                                   Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildShuffleVector(B: &Builder,\n-                                  V1: ValueRef,\n-                                  V2: ValueRef,\n-                                  Mask: ValueRef,\n+                                  -> &'a Value;\n+    pub fn LLVMBuildShuffleVector(B: &'a Builder,\n+                                  V1: &'a Value,\n+                                  V2: &'a Value,\n+                                  Mask: &'a Value,\n                                   Name: *const c_char)\n-                                  -> ValueRef;\n-    pub fn LLVMBuildExtractValue(B: &Builder,\n-                                 AggVal: ValueRef,\n+                                  -> &'a Value;\n+    pub fn LLVMBuildExtractValue(B: &'a Builder,\n+                                 AggVal: &'a Value,\n                                  Index: c_uint,\n                                  Name: *const c_char)\n-                                 -> ValueRef;\n-    pub fn LLVMBuildInsertValue(B: &Builder,\n-                                AggVal: ValueRef,\n-                                EltVal: ValueRef,\n+                                 -> &'a Value;\n+    pub fn LLVMBuildInsertValue(B: &'a Builder,\n+                                AggVal: &'a Value,\n+                                EltVal: &'a Value,\n                                 Index: c_uint,\n                                 Name: *const c_char)\n-                                -> ValueRef;\n-\n-    pub fn LLVMRustBuildVectorReduceFAdd(B: &Builder,\n-                                         Acc: ValueRef,\n-                                         Src: ValueRef)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMul(B: &Builder,\n-                                         Acc: ValueRef,\n-                                         Src: ValueRef)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceAdd(B: &Builder,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMul(B: &Builder,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceAnd(B: &Builder,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceOr(B: &Builder,\n-                                       Src: ValueRef)\n-                                       -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceXor(B: &Builder,\n-                                        Src: ValueRef)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMin(B: &Builder,\n-                                        Src: ValueRef,\n+                                -> &'a Value;\n+\n+    pub fn LLVMRustBuildVectorReduceFAdd(B: &'a Builder,\n+                                         Acc: &'a Value,\n+                                         Src: &'a Value)\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMul(B: &'a Builder,\n+                                         Acc: &'a Value,\n+                                         Src: &'a Value)\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceAdd(B: &'a Builder,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMul(B: &'a Builder,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceAnd(B: &'a Builder,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceOr(B: &'a Builder,\n+                                       Src: &'a Value)\n+                                       -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceXor(B: &'a Builder,\n+                                        Src: &'a Value)\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMin(B: &'a Builder,\n+                                        Src: &'a Value,\n                                         IsSigned: bool)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceMax(B: &Builder,\n-                                        Src: ValueRef,\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceMax(B: &'a Builder,\n+                                        Src: &'a Value,\n                                         IsSigned: bool)\n-                                        -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMin(B: &Builder,\n-                                         Src: ValueRef,\n+                                        -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMin(B: &'a Builder,\n+                                         Src: &'a Value,\n                                          IsNaN: bool)\n-                                         -> ValueRef;\n-    pub fn LLVMRustBuildVectorReduceFMax(B: &Builder,\n-                                         Src: ValueRef,\n+                                         -> Option<&'a Value>;\n+    pub fn LLVMRustBuildVectorReduceFMax(B: &'a Builder,\n+                                         Src: &'a Value,\n                                          IsNaN: bool)\n-                                         -> ValueRef;\n+                                         -> Option<&'a Value>;\n \n-    pub fn LLVMRustBuildMinNum(B: &Builder, LHS: ValueRef, LHS: ValueRef) -> ValueRef;\n-    pub fn LLVMRustBuildMaxNum(B: &Builder, LHS: ValueRef, LHS: ValueRef) -> ValueRef;\n+    pub fn LLVMRustBuildMinNum(B: &'a Builder, LHS: &'a Value, LHS: &'a Value) -> Option<&'a Value>;\n+    pub fn LLVMRustBuildMaxNum(B: &'a Builder, LHS: &'a Value, LHS: &'a Value) -> Option<&'a Value>;\n \n-    pub fn LLVMBuildIsNull(B: &Builder, Val: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildIsNotNull(B: &Builder, Val: ValueRef, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMBuildPtrDiff(B: &Builder,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n+    pub fn LLVMBuildIsNull(B: &'a Builder, Val: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildIsNotNull(B: &'a Builder, Val: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildPtrDiff(B: &'a Builder,\n+                            LHS: &'a Value,\n+                            RHS: &'a Value,\n                             Name: *const c_char)\n-                            -> ValueRef;\n+                            -> &'a Value;\n \n     // Atomic Operations\n-    pub fn LLVMRustBuildAtomicLoad(B: &Builder,\n-                                   PointerVal: ValueRef,\n+    pub fn LLVMRustBuildAtomicLoad(B: &'a Builder,\n+                                   PointerVal: &'a Value,\n                                    Name: *const c_char,\n                                    Order: AtomicOrdering)\n-                                   -> ValueRef;\n+                                   -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicStore(B: &Builder,\n-                                    Val: ValueRef,\n-                                    Ptr: ValueRef,\n+    pub fn LLVMRustBuildAtomicStore(B: &'a Builder,\n+                                    Val: &'a Value,\n+                                    Ptr: &'a Value,\n                                     Order: AtomicOrdering)\n-                                    -> ValueRef;\n+                                    -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicCmpXchg(B: &Builder,\n-                                      LHS: ValueRef,\n-                                      CMP: ValueRef,\n-                                      RHS: ValueRef,\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: &'a Builder,\n+                                      LHS: &'a Value,\n+                                      CMP: &'a Value,\n+                                      RHS: &'a Value,\n                                       Order: AtomicOrdering,\n                                       FailureOrder: AtomicOrdering,\n                                       Weak: Bool)\n-                                      -> ValueRef;\n+                                      -> &'a Value;\n \n-    pub fn LLVMBuildAtomicRMW(B: &Builder,\n+    pub fn LLVMBuildAtomicRMW(B: &'a Builder,\n                               Op: AtomicRmwBinOp,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n+                              LHS: &'a Value,\n+                              RHS: &'a Value,\n                               Order: AtomicOrdering,\n                               SingleThreaded: Bool)\n-                              -> ValueRef;\n+                              -> &'a Value;\n \n     pub fn LLVMRustBuildAtomicFence(B: &Builder,\n                                     Order: AtomicOrdering,\n                                     Scope: SynchronizationScope);\n \n \n     // Selected entries from the downcasts.\n-    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMIsATerminatorInst(Inst: &Value) -> &Value;\n+    pub fn LLVMIsAStoreInst(Inst: &Value) -> &Value;\n \n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n@@ -1342,15 +1341,15 @@ extern \"C\" {\n                              SideEffects: Bool,\n                              AlignStack: Bool,\n                              Dialect: AsmDialect)\n-                             -> ValueRef;\n+                             -> &Value;\n \n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;\n     pub fn LLVMRustVersionMinor() -> u32;\n \n     pub fn LLVMRustAddModuleFlag(M: &Module, name: *const c_char, value: u32);\n \n-    pub fn LLVMRustMetadataAsValue(C: &'a Context, MD: &'a Metadata) -> ValueRef;\n+    pub fn LLVMRustMetadataAsValue(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n \n     pub fn LLVMRustDIBuilderCreate(M: &Module) -> &DIBuilder;\n \n@@ -1390,7 +1389,7 @@ extern \"C\" {\n                                            ScopeLine: c_uint,\n                                            Flags: DIFlags,\n                                            isOptimized: bool,\n-                                           Fn: ValueRef,\n+                                           Fn: &'a Value,\n                                            TParam: &'a DIArray,\n                                            Decl: Option<&'a DIDescriptor>)\n                                            -> &'a DISubprogram;\n@@ -1456,7 +1455,7 @@ extern \"C\" {\n                                                  LineNo: c_uint,\n                                                  Ty: &'a DIType,\n                                                  isLocalToUnit: bool,\n-                                                 Val: ValueRef,\n+                                                 Val: &'a Value,\n                                                  Decl: Option<&'a DIDescriptor>,\n                                                  AlignInBits: u32)\n                                                  -> &'a DIGlobalVariable;\n@@ -1499,13 +1498,13 @@ extern \"C\" {\n                                              -> &'a DIArray;\n \n     pub fn LLVMRustDIBuilderInsertDeclareAtEnd(Builder: &'a DIBuilder,\n-                                               Val: ValueRef,\n+                                               Val: &'a Value,\n                                                VarInfo: &'a DIVariable,\n                                                AddrOps: *const i64,\n                                                AddrOpsCount: c_uint,\n-                                               DL: ValueRef,\n+                                               DL: &'a Value,\n                                                InsertAtEnd: BasicBlockRef)\n-                                               -> ValueRef;\n+                                               -> &'a Value;\n \n     pub fn LLVMRustDIBuilderCreateEnumerator(Builder: &DIBuilder,\n                                              Name: *const c_char,\n@@ -1536,7 +1535,7 @@ extern \"C\" {\n                                             UniqueId: *const c_char)\n                                             -> &'a DIType;\n \n-    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n \n     pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &'a DIBuilder,\n                                                         Scope: Option<&'a DIScope>,\n@@ -1565,15 +1564,15 @@ extern \"C\" {\n                                                 Column: c_uint,\n                                                 Scope: &'a DIScope,\n                                                 InlinedAt: Option<&'a Metadata>)\n-                                                -> ValueRef;\n+                                                -> &'a Value;\n     pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n     pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;\n \n     pub fn LLVMRustWriteTypeToString(Type: &Type, s: RustStringRef);\n-    pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n+    pub fn LLVMRustWriteValueToString(value_ref: &Value, s: RustStringRef);\n \n-    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n-    pub fn LLVMIsAConstantFP(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&Value>;\n+    pub fn LLVMIsAConstantFP(value_ref: &Value) -> Option<&Value>;\n \n     pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;\n@@ -1653,15 +1652,15 @@ extern \"C\" {\n \n     pub fn LLVMRustUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n                                                 pass_name_out: RustStringRef,\n-                                                function_out: *mut ValueRef,\n+                                                function_out: *mut Option<&Value>,\n                                                 loc_line_out: *mut c_uint,\n                                                 loc_column_out: *mut c_uint,\n                                                 loc_filename_out: RustStringRef,\n                                                 message_out: RustStringRef);\n     pub fn LLVMRustUnpackInlineAsmDiagnostic(DI: DiagnosticInfoRef,\n                                              cookie_out: *mut c_uint,\n                                              message_out: *mut TwineRef,\n-                                             instruction_out: *mut ValueRef);\n+                                             instruction_out: *mut Option<&Value>);\n \n     pub fn LLVMRustWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n     pub fn LLVMRustGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n@@ -1687,15 +1686,15 @@ extern \"C\" {\n     pub fn LLVMRustSetDataLayoutFromTargetMachine(M: &Module, TM: TargetMachineRef);\n \n     pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n-                                         Inputs: *const ValueRef,\n+                                         Inputs: *const &Value,\n                                          NumInputs: c_uint)\n                                          -> OperandBundleDefRef;\n     pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n \n     pub fn LLVMRustPositionBuilderAtStart(B: &Builder, BB: BasicBlockRef);\n \n-    pub fn LLVMRustSetComdat(M: &Module, V: ValueRef, Name: *const c_char);\n-    pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    pub fn LLVMRustSetComdat(M: &'a Module, V: &'a Value, Name: *const c_char);\n+    pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n     pub fn LLVMRustModuleBufferCreate(M: &Module) -> *mut ModuleBuffer;\n     pub fn LLVMRustModuleBufferPtr(p: *const ModuleBuffer) -> *const u8;"}, {"sha": "b4b5ae42d02bd0b95199df1663cdae3801abb7f2", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -42,7 +42,7 @@ impl LLVMRustResult {\n     }\n }\n \n-pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n+pub fn AddFunctionAttrStringValue(llfn: &'a Value,\n                                   idx: AttributePlace,\n                                   attr: &CStr,\n                                   value: &CStr) {\n@@ -108,12 +108,12 @@ pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: RustStringRef,\n     (*sr).borrow_mut().extend_from_slice(slice);\n }\n \n-pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n+pub fn SetInstructionCallConv(instr: &'a Value, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);\n     }\n }\n-pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n+pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n     unsafe {\n         LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n@@ -125,49 +125,49 @@ pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n // function.\n // For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n-pub fn SetUniqueComdat(llmod: &Module, val: ValueRef) {\n+pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n     unsafe {\n         LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n     }\n }\n \n-pub fn UnsetComdat(val: ValueRef) {\n+pub fn UnsetComdat(val: &'a Value) {\n     unsafe {\n         LLVMRustUnsetComdat(val);\n     }\n }\n \n-pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n+pub fn SetUnnamedAddr(global: &'a Value, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);\n     }\n }\n \n-pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n+pub fn set_thread_local(global: &'a Value, is_thread_local: bool) {\n     unsafe {\n         LLVMSetThreadLocal(global, is_thread_local as Bool);\n     }\n }\n-pub fn set_thread_local_mode(global: ValueRef, mode: ThreadLocalMode) {\n+pub fn set_thread_local_mode(global: &'a Value, mode: ThreadLocalMode) {\n     unsafe {\n         LLVMSetThreadLocalMode(global, mode);\n     }\n }\n \n impl Attribute {\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n     }\n \n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n     }\n \n-    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n     }\n \n-    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {\n+    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: &Value, set: bool) {\n         if set {\n             self.apply_llfn(idx, llfn);\n         } else {\n@@ -226,7 +226,7 @@ pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n }\n \n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n-pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n+pub fn get_param(llfn: &'a Value, index: c_uint) -> &'a Value {\n     unsafe {\n         assert!(index < LLVMCountParams(llfn),\n             \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n@@ -265,7 +265,7 @@ pub struct OperandBundleDef {\n }\n \n impl OperandBundleDef {\n-    pub fn new(name: &str, vals: &[ValueRef]) -> OperandBundleDef {\n+    pub fn new(name: &str, vals: &[&'a Value]) -> OperandBundleDef {\n         let name = CString::new(name).unwrap();\n         let def = unsafe {\n             LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)"}, {"sha": "9c0dd0dc3d8b54f54e5409c381c7cdeb3d68467e", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use abi::{FnType, FnTypeExt};\n use callee;\n use common::*;\n@@ -17,6 +16,7 @@ use consts;\n use monomorphize;\n use type_::Type;\n use value::Value;\n+\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n@@ -34,10 +34,10 @@ impl<'a, 'tcx> VirtualIndex {\n     }\n \n     pub fn get_fn(self, bx: &Builder<'a, 'll, 'tcx>,\n-                  llvtable: ValueRef,\n-                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> ValueRef {\n+                  llvtable: &'ll Value,\n+                  fn_ty: &FnType<'tcx, Ty<'tcx>>) -> &'ll Value {\n         // Load the data pointer from the object.\n-        debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n+        debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(llvtable, fn_ty.llvm_type(bx.cx).ptr_to().ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n@@ -48,9 +48,9 @@ impl<'a, 'tcx> VirtualIndex {\n         ptr\n     }\n \n-    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: &'ll Value) -> &'ll Value {\n         // Load the data pointer from the object.\n-        debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n+        debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n         let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n         let usize_align = bx.tcx().data_layout.pointer_align;\n@@ -69,11 +69,11 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n-                            -> ValueRef\n-{\n+pub fn get_vtable(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+) -> &'ll Value {\n     let tcx = cx.tcx;\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);"}, {"sha": "2c2058035241f5207b6ade9a111ec33005195e9b", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -34,7 +34,7 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n         let layout = fx.cx.layout_of(ty);\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n-            // in an ValueRef without an alloca.\n+            // in an Value without an alloca.\n         } else if layout.is_llvm_scalar_pair() {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {"}, {"sha": "587165dfe77f208335a517e83701d753ee00736a", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, BasicBlockRef};\n+use llvm::{self, BasicBlockRef};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -24,6 +24,7 @@ use meth;\n use monomorphize;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n+use value::Value;\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n@@ -97,7 +98,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             }\n         };\n \n-        let funclet_br = |this: &mut Self, bx: Builder, target: mir::BasicBlock| {\n+        let funclet_br = |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n             let (lltarget, is_cleanupret) = lltarget(this, target);\n             if is_cleanupret {\n                 // micro-optimization: generate a `ret` rather than a jump\n@@ -112,9 +113,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             this: &mut Self,\n             bx: Builder<'a, 'll, 'tcx>,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n-            fn_ptr: ValueRef,\n-            llargs: &[ValueRef],\n-            destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n+            fn_ptr: &'ll Value,\n+            llargs: &[&'ll Value],\n+            destination: Option<(ReturnDest<'ll, 'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n@@ -285,8 +286,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 }\n \n                 let place = self.codegen_place(&bx, location);\n-                let mut args: &[_] = &[place.llval, place.llextra];\n-                args = &args[..1 + place.has_extra() as usize];\n+                let (args1, args2);\n+                let mut args = if let Some(llextra) = place.llextra {\n+                    args2 = [place.llval, llextra];\n+                    &args2[..]\n+                } else {\n+                    args1 = [place.llval];\n+                    &args1[..]\n+                };\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n                         let fn_ty = drop_fn.ty(bx.cx.tcx);\n@@ -296,8 +303,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             &sig,\n                         );\n                         let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n+                        let vtable = args[1];\n                         args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&bx, place.llextra, &fn_ty), fn_ty)\n+                        (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n                     }\n                     _ => {\n                         (callee::get_fn(bx.cx, drop_fn),\n@@ -628,8 +636,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n     fn codegen_argument(&mut self,\n                       bx: &Builder<'a, 'll, 'tcx>,\n-                      op: OperandRef<'tcx>,\n-                      llargs: &mut Vec<ValueRef>,\n+                      op: OperandRef<'ll, 'tcx>,\n+                      llargs: &mut Vec<&'ll Value>,\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n@@ -708,7 +716,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     fn codegen_arguments_untupled(&mut self,\n                                 bx: &Builder<'a, 'll, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n-                                llargs: &mut Vec<ValueRef>,\n+                                llargs: &mut Vec<&'ll Value>,\n                                 args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.codegen_operand(bx, operand);\n \n@@ -728,7 +736,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'tcx> {\n+    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n@@ -803,8 +811,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n     fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                         dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n-                        llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n-                        -> ReturnDest<'tcx> {\n+                        llargs: &mut Vec<&'ll Value>, is_intrinsic: bool)\n+                        -> ReturnDest<'ll, 'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n@@ -886,7 +894,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n     fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n-                            dst: PlaceRef<'tcx>) {\n+                            dst: PlaceRef<'ll, 'tcx>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n@@ -898,9 +906,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bx: &Builder<'a, 'll, 'tcx>,\n-                    dest: ReturnDest<'tcx>,\n+                    dest: ReturnDest<'ll, 'tcx>,\n                     ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n-                    llval: ValueRef) {\n+                    llval: &'ll Value) {\n         use self::ReturnDest::*;\n \n         match dest {\n@@ -929,13 +937,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n }\n \n-enum ReturnDest<'tcx> {\n+enum ReturnDest<'ll, 'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(PlaceRef<'tcx>),\n+    Store(PlaceRef<'ll, 'tcx>),\n     // Stores an indirect return value to an operand local place\n-    IndirectOperand(PlaceRef<'tcx>, mir::Local),\n+    IndirectOperand(PlaceRef<'ll, 'tcx>, mir::Local),\n     // Stores a direct return value to an operand local place\n     DirectOperand(mir::Local)\n }"}, {"sha": "341ed9df64b5927c1df9250ffb7b5386f4483cd6", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n@@ -26,14 +26,17 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n+use value::Value;\n \n use super::super::callee;\n use super::FunctionCx;\n \n-pub fn scalar_to_llvm(cx: &CodegenCx,\n-                       cv: Scalar,\n-                       layout: &layout::Scalar,\n-                       llty: &Type) -> ValueRef {\n+pub fn scalar_to_llvm(\n+    cx: &CodegenCx<'ll, '_>,\n+    cv: Scalar,\n+    layout: &layout::Scalar,\n+    llty: &'ll Type,\n+) -> &'ll Value {\n     let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n         Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n@@ -81,7 +84,7 @@ pub fn scalar_to_llvm(cx: &CodegenCx,\n     }\n }\n \n-pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n+pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n     let layout = cx.data_layout();\n     let pointer_size = layout.pointer_size.bytes() as usize;\n@@ -116,10 +119,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     C_struct(cx, &llvals, true)\n }\n \n-pub fn codegen_static_initializer<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n+pub fn codegen_static_initializer(\n+    cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n-) -> Result<(ValueRef, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>> {\n+) -> Result<(&'ll Value, &'tcx Allocation), Lrc<ConstEvalErr<'tcx>>> {\n     let instance = ty::Instance::mono(cx.tcx, def_id);\n     let cid = GlobalId {\n         instance,\n@@ -172,15 +175,15 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>,\n         constant: Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>>,\n-    ) -> (ValueRef, Ty<'tcx>) {\n+    ) -> (&'ll Value, Ty<'tcx>) {\n         constant\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::TyArray(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n-                let values: Result<Vec<ValueRef>, Lrc<_>> = (0..fields).map(|field| {\n+                let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {\n                     let field = const_val_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),"}, {"sha": "be9cd005013f72f210d5e0358f64d7c4e888f418", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -10,7 +10,7 @@\n \n use common::{C_i32, C_null};\n use libc::c_uint;\n-use llvm::{self, ValueRef, BasicBlockRef};\n+use llvm::{self, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n@@ -24,6 +24,7 @@ use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebug\n use monomorphize::Instance;\n use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n use type_::Type;\n+use value::Value;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -49,7 +50,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n \n     debug_context: FunctionDebugContext<'ll>,\n \n-    llfn: ValueRef,\n+    llfn: &'ll Value,\n \n     cx: &'a CodegenCx<'ll, 'tcx>,\n \n@@ -62,7 +63,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'tcx>>,\n+    personality_slot: Option<PlaceRef<'ll, 'tcx>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n@@ -72,7 +73,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n \n     /// When targeting MSVC, this stores the cleanup info for each funclet\n     /// BB. This is initialized as we compute the funclets' head block in RPO.\n-    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet>>,\n+    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n@@ -96,7 +97,7 @@ pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n+    locals: IndexVec<mir::Local, LocalRef<'ll, 'tcx>>,\n \n     /// Debug information for MIR scopes.\n     scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n@@ -177,13 +178,13 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n }\n \n-enum LocalRef<'tcx> {\n-    Place(PlaceRef<'tcx>),\n-    Operand(Option<OperandRef<'tcx>>),\n+enum LocalRef<'ll, 'tcx> {\n+    Place(PlaceRef<'ll, 'tcx>),\n+    Operand(Option<OperandRef<'ll, 'tcx>>),\n }\n \n-impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(cx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+impl LocalRef<'ll, 'tcx> {\n+    fn new_operand(cx: &CodegenCx<'ll, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'ll, 'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -199,7 +200,7 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n \n pub fn codegen_mir(\n     cx: &'a CodegenCx<'ll, 'tcx>,\n-    llfn: ValueRef,\n+    llfn: &'ll Value,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n@@ -349,7 +350,7 @@ fn create_funclets(\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n     -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n-        IndexVec<mir::BasicBlock, Option<Funclet>>)\n+        IndexVec<mir::BasicBlock, Option<Funclet<'ll>>>)\n {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n@@ -409,15 +410,15 @@ fn create_funclets(\n     }).unzip()\n }\n \n-/// Produce, for each argument, a `ValueRef` pointing at the\n+/// Produce, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n fn arg_local_refs(\n     bx: &Builder<'a, 'll, 'tcx>,\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n     scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n     memory_locals: &BitVector<mir::Local>,\n-) -> Vec<LocalRef<'tcx>> {\n+) -> Vec<LocalRef<'ll, 'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;"}, {"sha": "f8b18f2f8b8aa34a8580315a5eee20206bd3e220", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 29, "deletions": 46, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n use rustc::mir::interpret::ConstValue;\n@@ -32,31 +31,15 @@ use super::place::PlaceRef;\n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n /// safety check.\n-#[derive(Copy, Clone)]\n-pub enum OperandValue {\n+#[derive(Copy, Clone, Debug)]\n+pub enum OperandValue<'ll> {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n-    Ref(ValueRef, Align),\n+    Ref(&'ll Value, Align),\n     /// A single LLVM value.\n-    Immediate(ValueRef),\n+    Immediate(&'ll Value),\n     /// A pair of immediate LLVM values. Used by fat pointers too.\n-    Pair(ValueRef, ValueRef)\n-}\n-\n-impl fmt::Debug for OperandValue {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            OperandValue::Ref(r, align) => {\n-                write!(f, \"Ref({:?}, {:?})\", Value(r), align)\n-            }\n-            OperandValue::Immediate(i) => {\n-                write!(f, \"Immediate({:?})\", Value(i))\n-            }\n-            OperandValue::Pair(a, b) => {\n-                write!(f, \"Pair({:?}, {:?})\", Value(a), Value(b))\n-            }\n-        }\n-    }\n+    Pair(&'ll Value, &'ll Value)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -68,23 +51,23 @@ impl fmt::Debug for OperandValue {\n /// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n-pub struct OperandRef<'tcx> {\n+pub struct OperandRef<'ll, 'tcx> {\n     // The value.\n-    pub val: OperandValue,\n+    pub val: OperandValue<'ll>,\n \n     // The layout of value, based on its Rust type.\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n+impl fmt::Debug for OperandRef<'ll, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n-impl<'a, 'tcx> OperandRef<'tcx> {\n-    pub fn new_zst(cx: &CodegenCx<'a, 'tcx>,\n-                   layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n+impl OperandRef<'ll, 'tcx> {\n+    pub fn new_zst(cx: &CodegenCx<'ll, 'tcx>,\n+                   layout: TyLayout<'tcx>) -> OperandRef<'ll, 'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n             val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n@@ -94,7 +77,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n-                      -> Result<OperandRef<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n+                      -> Result<OperandRef<'ll, 'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         let layout = bx.cx.layout_of(val.ty);\n \n         if layout.is_zst() {\n@@ -148,19 +131,19 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n-    pub fn immediate(self) -> ValueRef {\n+    pub fn immediate(self) -> &'ll Value {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n             _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n \n-    pub fn deref(self, cx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    pub fn deref(self, cx: &CodegenCx<'ll, 'tcx>) -> PlaceRef<'ll, 'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n-            OperandValue::Immediate(llptr) => (llptr, 0 as *mut _),\n-            OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n+            OperandValue::Immediate(llptr) => (llptr, None),\n+            OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n         let layout = cx.layout_of(projected_ty);\n@@ -174,7 +157,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> ValueRef {\n+    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> &'ll Value {\n         if let OperandValue::Pair(a, b) = self.val {\n             let llty = self.layout.llvm_type(bx.cx);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n@@ -191,9 +174,9 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n     pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n-                                         llval: ValueRef,\n+                                         llval: &'ll Value,\n                                          layout: TyLayout<'tcx>)\n-                                         -> OperandRef<'tcx> {\n+                                         -> OperandRef<'ll, 'tcx> {\n         let val = if let layout::Abi::ScalarPair(ref a, ref b) = layout.abi {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n@@ -208,7 +191,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'ll, 'tcx> {\n         let field = self.layout.field(bx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n@@ -266,24 +249,24 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> OperandValue {\n-    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n+impl OperandValue<'ll> {\n+    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n+    fn store_with_flags(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'ll, 'tcx>, flags: MemFlags) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n@@ -314,7 +297,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     fn maybe_codegen_consume_direct(&mut self,\n                                   bx: &Builder<'a, 'll, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n-                                   -> Option<OperandRef<'tcx>>\n+                                   -> Option<OperandRef<'ll, 'tcx>>\n     {\n         debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n \n@@ -362,7 +345,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_consume(&mut self,\n                          bx: &Builder<'a, 'll, 'tcx>,\n                          place: &mir::Place<'tcx>)\n-                         -> OperandRef<'tcx>\n+                         -> OperandRef<'ll, 'tcx>\n     {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n@@ -386,7 +369,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_operand(&mut self,\n                          bx: &Builder<'a, 'll, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n-                         -> OperandRef<'tcx>\n+                         -> OperandRef<'ll, 'tcx>\n     {\n         debug!(\"codegen_operand(operand={:?})\", operand);\n "}, {"sha": "abc3dbdab2f5b04d307bfce1424d717814499cf1", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, LLVMConstInBoundsGEP};\n+use llvm::{self, LLVMConstInBoundsGEP};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size};\n use rustc::mir;\n@@ -28,12 +28,12 @@ use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceRef<'tcx> {\n+pub struct PlaceRef<'ll, 'tcx> {\n     /// Pointer to the contents of the place\n-    pub llval: ValueRef,\n+    pub llval: &'ll Value,\n \n     /// This place's extra data if it is unsized, or null\n-    pub llextra: ValueRef,\n+    pub llextra: Option<&'ll Value>,\n \n     /// Monomorphized type of this place, including variant information\n     pub layout: TyLayout<'tcx>,\n@@ -42,14 +42,15 @@ pub struct PlaceRef<'tcx> {\n     pub align: Align,\n }\n \n-impl<'a, 'tcx> PlaceRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef,\n-                     layout: TyLayout<'tcx>,\n-                     align: Align)\n-                     -> PlaceRef<'tcx> {\n+impl PlaceRef<'ll, 'tcx> {\n+    pub fn new_sized(\n+        llval: &'ll Value,\n+        layout: TyLayout<'tcx>,\n+        align: Align,\n+    ) -> PlaceRef<'ll, 'tcx> {\n         PlaceRef {\n             llval,\n-            llextra: 0 as *mut _,\n+            llextra: None,\n             layout,\n             align\n         }\n@@ -60,7 +61,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         layout: TyLayout<'tcx>,\n         alloc: &mir::interpret::Allocation,\n         offset: Size,\n-    ) -> PlaceRef<'tcx> {\n+    ) -> PlaceRef<'ll, 'tcx> {\n         let init = const_alloc_to_llvm(bx.cx, alloc);\n         let base_addr = consts::addr_of(bx.cx, init, layout.align, \"byte_str\");\n \n@@ -74,18 +75,17 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n-                  -> PlaceRef<'tcx> {\n+                  -> PlaceRef<'ll, 'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n-    pub fn len(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Value {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n-                assert!(self.has_extra());\n                 assert_eq!(count, 0);\n-                self.llextra\n+                self.llextra.unwrap()\n             } else {\n                 C_usize(cx, count)\n             }\n@@ -94,14 +94,10 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn has_extra(&self) -> bool {\n-        !self.llextra.is_null()\n-    }\n-\n-    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'ll, 'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n-        assert!(!self.has_extra());\n+        assert_eq!(self.llextra, None);\n \n         if self.layout.is_zst() {\n             return OperandRef::new_zst(bx.cx, self.layout);\n@@ -124,23 +120,21 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         };\n \n         let val = if self.layout.is_llvm_immediate() {\n-            let mut const_llval = 0 as *mut _;\n+            let mut const_llval = None;\n             unsafe {\n-                let global = llvm::LLVMIsAGlobalVariable(self.llval);\n-                if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                    const_llval = llvm::LLVMGetInitializer(global);\n+                if let Some(global) = llvm::LLVMIsAGlobalVariable(self.llval) {\n+                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                        const_llval = llvm::LLVMGetInitializer(global);\n+                    }\n                 }\n             }\n-\n-            let llval = if !const_llval.is_null() {\n-                const_llval\n-            } else {\n+            let llval = const_llval.unwrap_or_else(|| {\n                 let load = bx.load(self.llval, self.align);\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n                 load\n-            };\n+            });\n             OperandValue::Immediate(base::to_immediate(bx, llval, self.layout))\n         } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n             let load = |i, scalar: &layout::Scalar| {\n@@ -162,7 +156,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bx: &Builder<'a, 'll, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n+    pub fn project_field(self, bx: &Builder<'a, 'll, 'tcx>, ix: usize) -> PlaceRef<'ll, 'tcx> {\n         let cx = bx.cx;\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -185,7 +179,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n-                    0 as *mut _\n+                    None\n                 },\n                 layout: field,\n                 align,\n@@ -197,9 +191,9 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         //   * known alignment - sized types, [T], str or a foreign type\n         //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n-            _ if !self.has_extra() => {\n+            _ if self.llextra.is_none() => {\n                 debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                    ix, Value(self.llval));\n+                    ix, self.llval);\n                 return simple();\n             }\n             _ if !field.is_unsized() => return simple(),\n@@ -247,7 +241,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n         bx.neg(unsized_align));\n \n-        debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n+        debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n         // Cast and adjust pointer\n         let byte_ptr = bx.pointercast(self.llval, Type::i8p(cx));\n@@ -266,7 +260,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n@@ -384,18 +378,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: ValueRef)\n-                         -> PlaceRef<'tcx> {\n+    pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n+                         -> PlaceRef<'ll, 'tcx> {\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n-            llextra: 0 as *mut _,\n+            llextra: None,\n             layout: self.layout.field(bx.cx, 0),\n             align: self.align\n         }\n     }\n \n     pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize)\n-                            -> PlaceRef<'tcx> {\n+                            -> PlaceRef<'ll, 'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n \n@@ -419,7 +413,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_place(&mut self,\n                         bx: &Builder<'a, 'll, 'tcx>,\n                         place: &mir::Place<'tcx>)\n-                        -> PlaceRef<'tcx> {\n+                        -> PlaceRef<'ll, 'tcx> {\n         debug!(\"codegen_place(place={:?})\", place);\n \n         let cx = bx.cx;\n@@ -511,9 +505,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n-                            assert!(cg_base.has_extra());\n-                            subslice.llextra = bx.sub(cg_base.llextra,\n-                                C_usize(bx.cx, (from as u64) + (to as u64)));\n+                            subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n+                                C_usize(bx.cx, (from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new"}, {"sha": "02b5c27840eabbcf4461fac8b47187952882accf", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm;\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -35,12 +35,12 @@ use super::place::PlaceRef;\n impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue(&mut self,\n                         bx: Builder<'a, 'll, 'tcx>,\n-                        dest: PlaceRef<'tcx>,\n+                        dest: PlaceRef<'ll, 'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Builder<'a, 'll, 'tcx>\n     {\n         debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\",\n-               Value(dest.llval), rvalue);\n+               dest.llval, rvalue);\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n@@ -178,7 +178,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue_operand(&mut self,\n                                 bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'ll, 'tcx>)\n     {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n@@ -371,7 +371,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let val = if !bx.cx.type_has_metadata(ty) {\n                     OperandValue::Immediate(cg_place.llval)\n                 } else {\n-                    OperandValue::Pair(cg_place.llval, cg_place.llextra)\n+                    OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n                 };\n                 (bx, OperandRef {\n                     val,\n@@ -511,10 +511,11 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn evaluate_array_len(&mut self,\n-                          bx: &Builder<'a, 'll, 'tcx>,\n-                          place: &mir::Place<'tcx>) -> ValueRef\n-    {\n+    fn evaluate_array_len(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        place: &mir::Place<'tcx>,\n+    ) -> &'ll Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n@@ -530,12 +531,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         return cg_value.len(bx.cx);\n     }\n \n-    pub fn codegen_scalar_binop(&mut self,\n-                              bx: &Builder<'a, 'll, 'tcx>,\n-                              op: mir::BinOp,\n-                              lhs: ValueRef,\n-                              rhs: ValueRef,\n-                              input_ty: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_scalar_binop(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        op: mir::BinOp,\n+        lhs: &'ll Value,\n+        rhs: &'ll Value,\n+        input_ty: Ty<'tcx>,\n+    ) -> &'ll Value {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n         let is_nil = input_ty.is_nil();\n@@ -596,15 +599,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         }\n     }\n \n-    pub fn codegen_fat_ptr_binop(&mut self,\n-                               bx: &Builder<'a, 'll, 'tcx>,\n-                               op: mir::BinOp,\n-                               lhs_addr: ValueRef,\n-                               lhs_extra: ValueRef,\n-                               rhs_addr: ValueRef,\n-                               rhs_extra: ValueRef,\n-                               _input_ty: Ty<'tcx>)\n-                               -> ValueRef {\n+    pub fn codegen_fat_ptr_binop(\n+        &mut self,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        op: mir::BinOp,\n+        lhs_addr: &'ll Value,\n+        lhs_extra: &'ll Value,\n+        rhs_addr: &'ll Value,\n+        rhs_extra: &'ll Value,\n+        _input_ty: Ty<'tcx>,\n+    ) -> &'ll Value {\n         match op {\n             mir::BinOp::Eq => {\n                 bx.and(\n@@ -646,9 +650,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_scalar_checked_binop(&mut self,\n                                       bx: &Builder<'a, 'll, 'tcx>,\n                                       op: mir::BinOp,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      input_ty: Ty<'tcx>) -> OperandValue {\n+                                      lhs: &'ll Value,\n+                                      rhs: &'ll Value,\n+                                      input_ty: Ty<'tcx>) -> OperandValue<'ll> {\n         // This case can currently arise only from functions marked\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n@@ -721,7 +725,7 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder<'_, 'll, '_>, ty: Ty) -> &'ll Value {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};\n@@ -798,9 +802,9 @@ fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n \n fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n-                     x: ValueRef,\n+                     x: &'ll Value,\n                      int_ty: &'ll Type,\n-                     float_ty: &'ll Type) -> ValueRef {\n+                     float_ty: &'ll Type) -> &'ll Value {\n     // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n@@ -828,9 +832,9 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n \n fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n-                     x: ValueRef,\n+                     x: &'ll Value,\n                      float_ty: &'ll Type,\n-                     int_ty: &'ll Type) -> ValueRef {\n+                     int_ty: &'ll Type) -> &'ll Value {\n     let fptosui_result = if signed {\n         bx.fptosi(x, int_ty)\n     } else {"}, {"sha": "3328948c2951e5ce18e8b500b4ce9e1189c7f6a9", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f375185314e94a266f76ad7ffdd61b2d4608e97d/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=f375185314e94a266f76ad7ffdd61b2d4608e97d", "patch": "@@ -8,17 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use llvm::Value;\n+\n use llvm;\n \n use std::fmt;\n+use std::hash::{Hash, Hasher};\n+\n+impl PartialEq for Value {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n+}\n+\n+impl Eq for Value {}\n+\n+impl Hash for Value {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self as *const Self).hash(hasher);\n+    }\n+}\n \n-#[derive(Copy, Clone, PartialEq)]\n-pub struct Value(pub llvm::ValueRef);\n \n impl fmt::Debug for Value {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMRustWriteValueToString(self.0, s);\n+            llvm::LLVMRustWriteValueToString(self, s);\n         }).expect(\"nun-UTF8 value description from LLVM\"))\n     }\n }"}]}