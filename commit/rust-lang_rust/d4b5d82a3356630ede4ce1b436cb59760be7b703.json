{"sha": "d4b5d82a3356630ede4ce1b436cb59760be7b703", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YjVkODJhMzM1NjYzMGVkZTRjZTFiNDM2Y2I1OTc2MGJlN2I3MDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T18:12:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:16:14Z"}, "message": "core: Add unwrap()/unwrap_err() methods to Result\n\nThese implementations must live in libstd right now because the fmt module has\nnot been migrated yet. This will occur in a later PR.\n\nJust to be clear, there are new extension traits, but they are not necessary\nonce the std::fmt module has migrated to libcore, which is a planned migration\nin the future.", "tree": {"sha": "8e690f9b6887b1a96ddb44385ef38c453fa7796b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e690f9b6887b1a96ddb44385ef38c453fa7796b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4b5d82a3356630ede4ce1b436cb59760be7b703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b5d82a3356630ede4ce1b436cb59760be7b703", "html_url": "https://github.com/rust-lang/rust/commit/d4b5d82a3356630ede4ce1b436cb59760be7b703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4b5d82a3356630ede4ce1b436cb59760be7b703/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a156534a96a6c401b14c80618c247eaadf876eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a156534a96a6c401b14c80618c247eaadf876eb7", "html_url": "https://github.com/rust-lang/rust/commit/a156534a96a6c401b14c80618c247eaadf876eb7"}], "stats": {"total": 333, "additions": 327, "deletions": 6}, "files": [{"sha": "839b7407e5558b00312a64bcf1aaec63c33727d0", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -400,6 +400,7 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n@@ -436,6 +437,7 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {"}, {"sha": "a8e7b324bd755e3285abdc705b561fdecf9c1b70", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -16,7 +16,7 @@ use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;"}, {"sha": "125b4ddad88f4bdcaad5f382392a088cbb129cf4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -1335,7 +1335,7 @@ mod test {\n         use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n-        StdRng::new().unwrap().fill_bytes(bytes);\n+        StdRng::new().ok().unwrap().fill_bytes(bytes);\n \n         let tmpdir = tmpdir();\n "}, {"sha": "b7636493decc72a2732e52eea32ef0700c3c66bb", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -358,6 +358,8 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n+        use result::ResultUnwrap;\n+\n         let server = UdpSocket::bind(addr);\n \n         assert!(server.is_ok());"}, {"sha": "69ba0fb20ee1c28c2b8b5bb05e1b93939e348e4c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -36,7 +36,7 @@ use mem::replace;\n use option::{Option, Some, None};\n use owned::Box;\n use prelude::drop;\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use rt;\n use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};"}, {"sha": "8c28caa988a5c05d0671b446e3b3e3a1fcba8bcc", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -18,7 +18,7 @@ use ops::Drop;\n use option::{Option, None, Some};\n use os;\n use path::{Path, GenericPath};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use sync::atomics;\n \n /// A wrapper for a path to temporary directory implementing automatic"}, {"sha": "8861597bb4c16d50348648dd6ffd882cdf6ab41e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -820,6 +820,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -856,6 +857,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -892,6 +894,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use f64;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn float_to_str(b: &mut Bencher) {"}, {"sha": "75eb56ffa52480b2f049bea75e51dd712a77208d", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -69,6 +69,7 @@ pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n+pub use result::{ResultUnwrap, ResultUnwrapErr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use str::{StrAllocating};\n pub use to_str::{ToStr, IntoStr};"}, {"sha": "2fe4c7eafdec15eee6bc2a3f8796da0670d62498", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -25,7 +25,7 @@ use option::{Some, None, Option};\n use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use str::StrSlice;\n use to_str::ToStr;\n use slice::Vector;"}, {"sha": "cc9e6684d283617e5cb5cac5575976e91aaf6598", "filename": "src/libstd/result.rs", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -0,0 +1,312 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error handling with the `Result` type\n+//!\n+//! `Result<T>` is the type used for returning and propagating\n+//! errors. It is an enum with the variants, `Ok(T)`, representing\n+//! success and containing a value, and `Err(E)`, representing error\n+//! and containing an error value.\n+//!\n+//! ~~~\n+//! enum Result<T, E> {\n+//!    Ok(T),\n+//!    Err(E)\n+//! }\n+//! ~~~\n+//!\n+//! Functions return `Result` whenever errors are expected and\n+//! recoverable. In the `std` crate `Result` is most prominently used\n+//! for [I/O](../io/index.html).\n+//!\n+//! A simple function returning `Result` might be\n+//! defined and used like so:\n+//!\n+//! ~~~\n+//! #[deriving(Show)]\n+//! enum Version { Version1, Version2 }\n+//!\n+//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n+//!     if header.len() < 1 {\n+//!         return Err(\"invalid header length\");\n+//!     }\n+//!     match header[0] {\n+//!         1 => Ok(Version1),\n+//!         2 => Ok(Version2),\n+//!         _ => Err(\"invalid version\")\n+//!     }\n+//! }\n+//!\n+//! let version = parse_version(&[1, 2, 3, 4]);\n+//! match version {\n+//!     Ok(v) => {\n+//!         println!(\"working with version: {}\", v);\n+//!     }\n+//!     Err(e) => {\n+//!         println!(\"error parsing header: {}\", e);\n+//!     }\n+//! }\n+//! ~~~\n+//!\n+//! Pattern matching on `Result`s is clear and straightforward for\n+//! simple cases, but `Result` comes with some convenience methods\n+//! that make working it more succinct.\n+//!\n+//! ~~~\n+//! let good_result: Result<int, int> = Ok(10);\n+//! let bad_result: Result<int, int> = Err(10);\n+//!\n+//! // The `is_ok` and `is_err` methods do what they say.\n+//! assert!(good_result.is_ok() && !good_result.is_err());\n+//! assert!(bad_result.is_err() && !bad_result.is_ok());\n+//!\n+//! // `map` consumes the `Result` and produces another.\n+//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n+//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n+//!\n+//! // Use `and_then` to continue the computation.\n+//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n+//!\n+//! // Use `or_else` to handle the error.\n+//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n+//!\n+//! // Consume the result and return the contents with `unwrap`.\n+//! let final_awesome_result = good_result.ok().unwrap();\n+//! ~~~\n+//!\n+//! # Results must be used\n+//!\n+//! A common problem with using return values to indicate errors is\n+//! that it is easy to ignore the return value, thus failing to handle\n+//! the error. Result is annotated with the #[must_use] attribute,\n+//! which will cause the compiler to issue a warning when a Result\n+//! value is ignored. This makes `Result` especially useful with\n+//! functions that may encounter errors but don't otherwise return a\n+//! useful value.\n+//!\n+//! Consider the `write_line` method defined for I/O types\n+//! by the [`Writer`](../io/trait.Writer.html) trait:\n+//!\n+//! ~~~\n+//! use std::io::IoError;\n+//!\n+//! trait Writer {\n+//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n+//! }\n+//! ~~~\n+//!\n+//! *Note: The actual definition of `Writer` uses `IoResult`, which\n+//! is just a synonym for `Result<T, IoError>`.*\n+//!\n+//! This method doesn`t produce a value, but the write may\n+//! fail. It's crucial to handle the error case, and *not* write\n+//! something like this:\n+//!\n+//! ~~~ignore\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! // If `write_line` errors, then we'll never know, because the return\n+//! // value is ignored.\n+//! file.write_line(\"important message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! If you *do* write that in Rust, the compiler will by give you a\n+//! warning (by default, controlled by the `unused_must_use` lint).\n+//!\n+//! You might instead, if you don't want to handle the error, simply\n+//! fail, by converting to an `Option` with `ok`, then asserting\n+//! success with `expect`. This will fail if the write fails, proving\n+//! a marginally useful message indicating why:\n+//!\n+//! ~~~no_run\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! You might also simply assert success:\n+//!\n+//! ~~~no_run\n+//! # use std::io::{File, Open, Write};\n+//!\n+//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! assert!(file.write_line(\"important message\").is_ok());\n+//! # drop(file);\n+//! ~~~\n+//!\n+//! Or propagate the error up the call stack with `try!`:\n+//!\n+//! ~~~\n+//! # use std::io::{File, Open, Write, IoError};\n+//! fn write_message() -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//!     try!(file.write_line(\"important message\"));\n+//!     drop(file);\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! # The `try!` macro\n+//!\n+//! When writing code that calls many functions that return the\n+//! `Result` type, the error handling can be tedious.  The `try!`\n+//! macro hides some of the boilerplate of propagating errors up the\n+//! call stack.\n+//!\n+//! It replaces this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     match file.write_line(format!(\"name: {}\", info.name)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     match file.write_line(format!(\"age: {}\", info.age)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     return file.write_line(format!(\"rating: {}\", info.rating));\n+//! }\n+//! ~~~\n+//!\n+//! With this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n+//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n+//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! *It's much nicer!*\n+//!\n+//! Wrapping an expression in `try!` will result in the unwrapped\n+//! success (`Ok`) value, unless the result is `Err`, in which case\n+//! `Err` is returned early from the enclosing function. Its simple definition\n+//! makes it clear:\n+//!\n+//! ~~~\n+//! # #![feature(macro_rules)]\n+//! macro_rules! try(\n+//!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+//! )\n+//! # fn main() { }\n+//! ~~~\n+//!\n+//! `try!` is imported by the prelude, and is available everywhere.\n+//!\n+//! # `Result` and `Option`\n+//!\n+//! The `Result` and [`Option`](../option/index.html) types are\n+//! similar and complementary: they are often employed to indicate a\n+//! lack of a return value; and they are trivially converted between\n+//! each other, so `Result`s are often handled by first converting to\n+//! `Option` with the [`ok`](enum.Result.html#method.ok) and\n+//! [`err`](enum.Result.html#method.ok) methods.\n+//!\n+//! Whereas `Option` only indicates the lack of a value, `Result` is\n+//! specifically for error reporting, and carries with it an error\n+//! value.  Sometimes `Option` is used for indicating errors, but this\n+//! is only for simple cases and is generally discouraged. Even when\n+//! there is no useful error value to return, prefer `Result<T, ()>`.\n+//!\n+//! Converting to an `Option` with `ok()` to handle an error:\n+//!\n+//! ~~~\n+//! use std::io::Timer;\n+//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n+//! ~~~\n+//!\n+//! # `Result` vs. `fail!`\n+//!\n+//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n+//! errors. Callers should always be able to avoid failure if they\n+//! take the proper precautions, for example, calling `is_some()`\n+//! on an `Option` type before calling `unwrap`.\n+//!\n+//! The suitability of `fail!` as an error handling mechanism is\n+//! limited by Rust's lack of any way to \"catch\" and resume execution\n+//! from a thrown exception. Therefore using failure for error\n+//! handling requires encapsulating fallable code in a task. Calling\n+//! the `fail!` macro, or invoking `fail!` indirectly should be\n+//! avoided as an error reporting strategy. Failure is only for\n+//! unrecoverable errors and a failing task is typically the sign of\n+//! a bug.\n+//!\n+//! A module that instead returns `Results` is alerting the caller\n+//! that failure is possible, and providing precise control over how\n+//! it is handled.\n+//!\n+//! Furthermore, failure may not be recoverable at all, depending on\n+//! the context. The caller of `fail!` should assume that execution\n+//! will not resume after failure, that failure is catastrophic.\n+\n+use fmt::Show;\n+\n+pub use core::result::{Result, Ok, Err, collect, fold, fold_};\n+\n+// FIXME: These traits should not exist. Once std::fmt is moved to libcore,\n+//        these can once again become inherent methods on Result.\n+\n+/// Temporary trait for unwrapping a result\n+pub trait ResultUnwrap<T, E> {\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    ///\n+    /// Fails if the value is an `Err`.\n+    fn unwrap(self) -> T;\n+}\n+\n+/// Temporary trait for unwrapping the error of a result\n+pub trait ResultUnwrapErr<T, E> {\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    ///\n+    /// Fails if the value is an `Ok`.\n+    fn unwrap_err(self) -> E;\n+}\n+\n+impl<T, E: Show> ResultUnwrap<T, E> for Result<T, E> {\n+    #[inline]\n+    fn unwrap(self) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) =>\n+                fail!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n+        }\n+    }\n+}\n+\n+impl<T: Show, E> ResultUnwrapErr<T, E> for Result<T, E> {\n+    #[inline]\n+    fn unwrap_err(self) -> E {\n+        match self {\n+            Ok(t) =>\n+                fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n+            Err(e) => e\n+        }\n+    }\n+}"}, {"sha": "909df5618aaa39042ab9d7403520a1992dee74ab", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -436,7 +436,7 @@ mod test {\n     #[test]\n     fn rng() {\n         use rand::{StdRng, Rng};\n-        let mut r = StdRng::new().unwrap();\n+        let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n "}, {"sha": "2f7b31ae31d9858796741193462783b6897b8bb4", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b5d82a3356630ede4ce1b436cb59760be7b703/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=d4b5d82a3356630ede4ce1b436cb59760be7b703", "patch": "@@ -50,6 +50,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n+#[cfg(test)] use realstd::result::ResultUnwrap;\n \n /// Indicates the manner in which a task exited.\n ///"}]}