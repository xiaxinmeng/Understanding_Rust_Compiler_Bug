{"sha": "5ce6514f236794ce13af807194e811099b7794cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZTY1MTRmMjM2Nzk0Y2UxM2FmODA3MTk0ZTgxMTA5OWI3Nzk0Y2M=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T06:00:46Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T06:00:46Z"}, "message": "Dump allocations within PrimVal pointers.", "tree": {"sha": "23b6a09662264454d4456429de2a2817ee788f56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b6a09662264454d4456429de2a2817ee788f56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ce6514f236794ce13af807194e811099b7794cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce6514f236794ce13af807194e811099b7794cc", "html_url": "https://github.com/rust-lang/rust/commit/5ce6514f236794ce13af807194e811099b7794cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ce6514f236794ce13af807194e811099b7794cc/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe19a014ffbafdb27b1fbb6bfec7ea41f553b3be", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe19a014ffbafdb27b1fbb6bfec7ea41f553b3be", "html_url": "https://github.com/rust-lang/rust/commit/fe19a014ffbafdb27b1fbb6bfec7ea41f553b3be"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "d1aca7947ffdc6deb721383f83dcd96a505e0de2", "filename": "src/eval_context.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ce6514f236794ce13af807194e811099b7794cc/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce6514f236794ce13af807194e811099b7794cc/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=5ce6514f236794ce13af807194e811099b7794cc", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         for local in frame.locals.into_iter() {\n             if let Some(Value::ByRef(ptr)) = local {\n                 trace!(\"deallocating local\");\n-                self.memory.dump(ptr.alloc_id);\n+                self.memory.dump_alloc(ptr.alloc_id);\n                 match self.memory.deallocate(ptr) {\n                     // Any frozen memory means that it belongs to a constant or something referenced\n                     // by a constant. We could alternatively check whether the alloc_id is frozen\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // deallocate all temporary allocations\n         for ptr in frame.interpreter_temporaries {\n             trace!(\"deallocating temporary allocation\");\n-            self.memory.dump(ptr.alloc_id);\n+            self.memory.dump_alloc(ptr.alloc_id);\n             self.memory.deallocate(ptr)?;\n         }\n         Ok(())\n@@ -1528,30 +1528,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n             }\n-            _ => bug!(\"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                      src_ty,\n-                      dest_ty),\n+            _ => bug!(\"unsize_into: invalid conversion: {:?} -> {:?}\", src_ty, dest_ty),\n         }\n         Ok(())\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+        let mut allocs = Vec::new();\n+\n         if let Lvalue::Local { frame, local } = lvalue {\n             if let Some(val) = self.stack[frame].get_local(local) {\n                 match val {\n                     Value::ByRef(ptr) => {\n                         trace!(\"frame[{}] {:?}:\", frame, local);\n-                        self.memory.dump(ptr.alloc_id);\n+                        allocs.push(ptr.alloc_id);\n                     }\n-                    Value::ByVal(a) => {\n-                        trace!(\"frame[{}] {:?}: {:?}\", frame, local, a);\n+                    Value::ByVal(val) => {\n+                        trace!(\"frame[{}] {:?}: {:?}\", frame, local, val);\n+                        if let Some(alloc_id) = val.relocation { allocs.push(alloc_id); }\n                     }\n-                    Value::ByValPair(a, b) => {\n-                        trace!(\"frame[{}] {:?}: ({:?}, {:?})\", frame, local, a, b);\n+                    Value::ByValPair(val1, val2) => {\n+                        trace!(\"frame[{}] {:?}: ({:?}, {:?})\", frame, local, val1, val2);\n+                        if let Some(alloc_id) = val1.relocation { allocs.push(alloc_id); }\n+                        if let Some(alloc_id) = val2.relocation { allocs.push(alloc_id); }\n                     }\n                 }\n             }\n         }\n+\n+        self.memory.dump_allocs(allocs);\n     }\n \n     /// convenience function to ensure correct usage of globals and code-sharing with locals"}, {"sha": "077616d073f5ba91d769b98a8be142baac4a1f53", "filename": "src/memory.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ce6514f236794ce13af807194e811099b7794cc/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce6514f236794ce13af807194e811099b7794cc/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5ce6514f236794ce13af807194e811099b7794cc", "patch": "@@ -17,7 +17,7 @@ use primval::{PrimVal, PrimValKind};\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n pub struct AllocId(pub u64);\n \n impl fmt::Display for AllocId {\n@@ -342,12 +342,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    /// Print an allocation and all allocations it points to, recursively.\n-    pub fn dump(&self, id: AllocId) {\n+    /// For debugging, print an allocation and all allocations it points to, recursively.\n+    pub fn dump_alloc(&self, id: AllocId) {\n+        self.dump_allocs(vec![id]);\n+    }\n+\n+    /// For debugging, print a list of allocations and all allocations they point to, recursively.\n+    pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n         use std::fmt::Write;\n+        allocs.sort();\n+        allocs.dedup();\n+        let mut allocs_to_print = VecDeque::from(allocs);\n         let mut allocs_seen = HashSet::new();\n-        let mut allocs_to_print = VecDeque::new();\n-        allocs_to_print.push_back(id);\n \n         while let Some(id) = allocs_to_print.pop_front() {\n             allocs_seen.insert(id);"}]}