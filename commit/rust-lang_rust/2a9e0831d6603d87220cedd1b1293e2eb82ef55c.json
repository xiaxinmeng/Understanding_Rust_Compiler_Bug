{"sha": "2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "node_id": "C_kwDOAAsO6NoAKDJhOWUwODMxZDY2MDNkODcyMjBjZWRkMWIxMjkzZTJlYjgyZWY1NWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T13:20:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T13:20:14Z"}, "message": "Auto merge of #91393 - Julian-Wollersberger:lexer_optimization, r=petrochenkov\n\nOptimize `rustc_lexer`\n\nThe `cursor.first()` method in `rustc_lexer` now calls the `chars.next()` method instead of `chars.nth_char(0)`.\n\nThis allows LLVM to optimize the code better. The biggest win is that `eat_while()` is now fully inlined and generates better assembly. This improves the lexer's performance by 35% in a micro-benchmark I made (Lexing all 18MB of code in the compiler directory). But lexing is only a small part of the overall compilation time, so I don't know how significant it is.\n\nBig thanks to criterion and `cargo asm`.", "tree": {"sha": "adc34a1951d77214c5f31dec639ab79ffbcb0810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adc34a1951d77214c5f31dec639ab79ffbcb0810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "html_url": "https://github.com/rust-lang/rust/commit/2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a9e0831d6603d87220cedd1b1293e2eb82ef55c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "html_url": "https://github.com/rust-lang/rust/commit/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92"}, {"sha": "1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab", "html_url": "https://github.com/rust-lang/rust/commit/1f147a2ed7671cacd8ab423d8979a1ccfa4443ab"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "0ba6c56dbb50147b7e54ad80dccdeb7b00649c39", "filename": "compiler/rustc_lexer/src/cursor.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2a9e0831d6603d87220cedd1b1293e2eb82ef55c/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a9e0831d6603d87220cedd1b1293e2eb82ef55c/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Fcursor.rs?ref=2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "patch": "@@ -2,10 +2,11 @@ use std::str::Chars;\n \n /// Peekable iterator over a char sequence.\n ///\n-/// Next characters can be peeked via `nth_char` method,\n+/// Next characters can be peeked via `first` method,\n /// and position can be shifted forward via `bump` method.\n pub(crate) struct Cursor<'a> {\n     initial_len: usize,\n+    /// Iterator over chars. Slightly faster than a &str.\n     chars: Chars<'a>,\n     #[cfg(debug_assertions)]\n     prev: char,\n@@ -37,22 +38,21 @@ impl<'a> Cursor<'a> {\n         }\n     }\n \n-    /// Returns nth character relative to the current cursor position.\n+    /// Peeks the next symbol from the input stream without consuming it.\n     /// If requested position doesn't exist, `EOF_CHAR` is returned.\n     /// However, getting `EOF_CHAR` doesn't always mean actual end of file,\n     /// it should be checked with `is_eof` method.\n-    fn nth_char(&self, n: usize) -> char {\n-        self.chars().nth(n).unwrap_or(EOF_CHAR)\n-    }\n-\n-    /// Peeks the next symbol from the input stream without consuming it.\n     pub(crate) fn first(&self) -> char {\n-        self.nth_char(0)\n+        // `.next()` optimizes better than `.nth(0)`\n+        self.chars.clone().next().unwrap_or(EOF_CHAR)\n     }\n \n     /// Peeks the second symbol from the input stream without consuming it.\n     pub(crate) fn second(&self) -> char {\n-        self.nth_char(1)\n+        // `.next()` optimizes better than `.nth(1)`\n+        let mut iter = self.chars.clone();\n+        iter.next();\n+        iter.next().unwrap_or(EOF_CHAR)\n     }\n \n     /// Checks if there is nothing more to consume.\n@@ -65,9 +65,9 @@ impl<'a> Cursor<'a> {\n         self.initial_len - self.chars.as_str().len()\n     }\n \n-    /// Returns a `Chars` iterator over the remaining characters.\n-    fn chars(&self) -> Chars<'a> {\n-        self.chars.clone()\n+    /// Resets the number of bytes consumed to 0.\n+    pub(crate) fn reset_len_consumed(&mut self) {\n+        self.initial_len = self.chars.as_str().len();\n     }\n \n     /// Moves to the next character.\n@@ -81,4 +81,13 @@ impl<'a> Cursor<'a> {\n \n         Some(c)\n     }\n+\n+    /// Eats symbols while predicate returns true or until the end of file is reached.\n+    pub(crate) fn eat_while(&mut self, mut predicate: impl FnMut(char) -> bool) {\n+        // It was tried making optimized version of this for eg. line comments, but\n+        // LLVM can inline all of this and compile it down to fast iteration over bytes.\n+        while predicate(self.first()) && !self.is_eof() {\n+            self.bump();\n+        }\n+    }\n }"}, {"sha": "5b8300ab530f92632b22fa65f03282118b89833b", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a9e0831d6603d87220cedd1b1293e2eb82ef55c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a9e0831d6603d87220cedd1b1293e2eb82ef55c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=2a9e0831d6603d87220cedd1b1293e2eb82ef55c", "patch": "@@ -227,14 +227,15 @@ pub fn first_token(input: &str) -> Token {\n }\n \n /// Creates an iterator that produces tokens from the input string.\n-pub fn tokenize(mut input: &str) -> impl Iterator<Item = Token> + '_ {\n+pub fn tokenize(input: &str) -> impl Iterator<Item = Token> + '_ {\n+    let mut cursor = Cursor::new(input);\n     std::iter::from_fn(move || {\n-        if input.is_empty() {\n-            return None;\n+        if cursor.is_eof() {\n+            None\n+        } else {\n+            cursor.reset_len_consumed();\n+            Some(cursor.advance_token())\n         }\n-        let token = first_token(input);\n-        input = &input[token.len..];\n-        Some(token)\n     })\n }\n \n@@ -832,11 +833,4 @@ impl Cursor<'_> {\n \n         self.eat_while(is_id_continue);\n     }\n-\n-    /// Eats symbols while predicate returns true or until the end of file is reached.\n-    fn eat_while(&mut self, mut predicate: impl FnMut(char) -> bool) {\n-        while predicate(self.first()) && !self.is_eof() {\n-            self.bump();\n-        }\n-    }\n }"}]}