{"sha": "1d7fc0ca500d8e532e7b1019397baec353560c26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkN2ZjMGNhNTAwZDhlNTMyZTdiMTAxOTM5N2JhZWMzNTM1NjBjMjY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-11-17T21:07:17Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-11-18T12:29:44Z"}, "message": "Simplify MIR drop generation\n\nNow that EndRegion is gone, we don't need to create as many gotos.", "tree": {"sha": "ce396eda7aab85de1a10823ded80ce3724a5fb39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce396eda7aab85de1a10823ded80ce3724a5fb39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d7fc0ca500d8e532e7b1019397baec353560c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7fc0ca500d8e532e7b1019397baec353560c26", "html_url": "https://github.com/rust-lang/rust/commit/1d7fc0ca500d8e532e7b1019397baec353560c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d7fc0ca500d8e532e7b1019397baec353560c26/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6027e0810ff9f60103d2ff4c24791e40db491316", "url": "https://api.github.com/repos/rust-lang/rust/commits/6027e0810ff9f60103d2ff4c24791e40db491316", "html_url": "https://github.com/rust-lang/rust/commit/6027e0810ff9f60103d2ff4c24791e40db491316"}], "stats": {"total": 329, "additions": 154, "deletions": 175}, "files": [{"sha": "2a11f24095b063f95066036c616811e6ca4a84e6", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 147, "deletions": 141, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/1d7fc0ca500d8e532e7b1019397baec353560c26/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7fc0ca500d8e532e7b1019397baec353560c26/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1d7fc0ca500d8e532e7b1019397baec353560c26", "patch": "@@ -96,6 +96,7 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::*;\n use syntax_pos::{Span};\n use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map::Entry;\n \n #[derive(Debug)]\n pub struct Scope<'tcx> {\n@@ -224,7 +225,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     ///\n-    /// `storage_only` controls whether to invalidate only drop paths run `StorageDead`.\n+    /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n     fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n@@ -242,8 +243,8 @@ impl<'tcx> Scope<'tcx> {\n         }\n \n         if !storage_only && !this_scope_only {\n-            for dropdata in &mut self.drops {\n-                if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+            for drop_data in &mut self.drops {\n+                if let DropKind::Value { ref mut cached_block } = drop_data.kind {\n                     cached_block.invalidate();\n                 }\n             }\n@@ -323,7 +324,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let parent_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(\n                         self.source_scope_local_data[source_scope].lint_root\n-                            );\n+                    );\n                 let current_hir_id =\n                     tcx.hir.definitions().node_to_hir_id(node_id);\n                 sets.lint_level_set(parent_hir_id) ==\n@@ -333,7 +334,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             if !same_lint_scopes {\n                 self.source_scope =\n                     self.new_source_scope(region_scope.1.span, lint_level,\n-                                              None);\n+                                          None);\n             }\n         }\n         self.push_scope(region_scope);\n@@ -381,23 +382,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.region_scope, region_scope.0);\n \n-        let resume_block = self.resume_block();\n-        unpack!(block = build_scope_drops(&mut self.cfg,\n-                                          resume_block,\n-                                          &scope,\n-                                          &self.scopes,\n-                                          block,\n-                                          self.arg_count,\n-                                          false));\n+        let unwind_to = self.scopes.last().and_then(|next_scope| {\n+            next_scope.cached_unwind.get(false)\n+        }).unwrap_or_else(|| self.resume_block());\n+\n+        unpack!(block = build_scope_drops(\n+            &mut self.cfg,\n+            &scope,\n+            block,\n+            unwind_to,\n+            self.arg_count,\n+            false,\n+        ));\n \n         block.unit()\n     }\n \n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n     /// and including `region_scope`.  This will insert whatever drops are\n-    /// needed, as well as tracking this exit for the SEME region. See\n-    /// module comment for details.\n+    /// needed. See module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n                       region_scope: (region::Scope, SourceInfo),\n@@ -415,38 +419,51 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic = self.scopes[(len - scope_count)..].iter()\n-            .any(|s| s.drops.iter().any(|s| s.kind.may_panic()));\n+        let may_panic = self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup);\n         if may_panic {\n             self.diverge_cleanup();\n         }\n \n-        {\n-        let resume_block = self.resume_block();\n-        let mut rest = &mut self.scopes[(len - scope_count)..];\n-        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n-            rest = rest_;\n-            block = if let Some(&e) = scope.cached_exits.get(&(target, region_scope.0)) {\n-                self.cfg.terminate(block, scope.source_info(span),\n-                                   TerminatorKind::Goto { target: e });\n-                return;\n-            } else {\n-                let b = self.cfg.start_new_block();\n-                self.cfg.terminate(block, scope.source_info(span),\n-                                   TerminatorKind::Goto { target: b });\n-                scope.cached_exits.insert((target, region_scope.0), b);\n-                b\n+        let mut scopes = self.scopes[(len - scope_count - 1)..].iter_mut().rev();\n+        let mut scope = scopes.next().unwrap();\n+        for next_scope in scopes {\n+            if scope.drops.is_empty() {\n+                scope = next_scope;\n+                continue;\n+            }\n+            let source_info = scope.source_info(span);\n+            block = match scope.cached_exits.entry((target, region_scope.0)) {\n+                Entry::Occupied(e) => {\n+                    self.cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: *e.get() });\n+                    return;\n+                }\n+                Entry::Vacant(v) => {\n+                    let b = self.cfg.start_new_block();\n+                    self.cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: b });\n+                    v.insert(b);\n+                    b\n+                }\n             };\n \n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              resume_block,\n-                                              scope,\n-                                              rest,\n-                                              block,\n-                                              self.arg_count,\n-                                              false));\n-        }\n+            let unwind_to = next_scope.cached_unwind.get(false).unwrap_or_else(|| {\n+                debug_assert!(!may_panic, \"cached block not present?\");\n+                START_BLOCK\n+            });\n+\n+            unpack!(block = build_scope_drops(\n+                &mut self.cfg,\n+                scope,\n+                block,\n+                unwind_to,\n+                self.arg_count,\n+                false,\n+            ));\n+\n+            scope = next_scope;\n         }\n+\n         let scope = &self.scopes[len - scope_count];\n         self.cfg.terminate(block, scope.source_info(span),\n                            TerminatorKind::Goto { target });\n@@ -461,20 +478,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        // Fill in the cache\n+        // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n         let src_info = self.scopes[0].source_info(self.fn_span);\n+        let resume_block = self.resume_block();\n+        let mut scopes = self.scopes.iter_mut().rev().peekable();\n         let mut block = self.cfg.start_new_block();\n         let result = block;\n-        let resume_block = self.resume_block();\n-        let mut rest = &mut self.scopes[..];\n \n-        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n-            rest = rest_;\n+        while let Some(scope) = scopes.next() {\n             if !scope.needs_cleanup {\n                 continue;\n             }\n+\n             block = if let Some(b) = scope.cached_generator_drop {\n                 self.cfg.terminate(block, src_info,\n                                    TerminatorKind::Goto { target: b });\n@@ -487,13 +504,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 b\n             };\n \n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              resume_block,\n-                                              scope,\n-                                              rest,\n-                                              block,\n-                                              self.arg_count,\n-                                              true));\n+            let unwind_to = scopes.peek().as_ref().map(|scope| {\n+                scope.cached_unwind.get(true).unwrap_or_else(|| {\n+                    span_bug!(src_info.span, \"cached block not present?\")\n+                })\n+            }).unwrap_or(resume_block);\n+\n+            unpack!(block = build_scope_drops(\n+                &mut self.cfg,\n+                scope,\n+                block,\n+                unwind_to,\n+                self.arg_count,\n+                true,\n+            ));\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -503,9 +527,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Creates a new source scope, nested in the current one.\n     pub fn new_source_scope(&mut self,\n-                                span: Span,\n-                                lint_level: LintLevel,\n-                                safety: Option<Safety>) -> SourceScope {\n+                            span: Span,\n+                            lint_level: LintLevel,\n+                            safety: Option<Safety>) -> SourceScope {\n         let parent = self.source_scope;\n         debug!(\"new_source_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n                span, lint_level, safety,\n@@ -742,8 +766,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n-    /// See module comment for more details. None indicates there\u2019s no\n-    /// cleanup to do at this point.\n+    /// See module comment for more details.\n     pub fn diverge_cleanup(&mut self) -> BasicBlock {\n         self.diverge_cleanup_gen(false)\n     }\n@@ -765,11 +788,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> BasicBlock {\n-        // To start, create the resume terminator.\n-        let mut target = self.resume_block();\n-\n-        let Builder { ref mut cfg, ref mut scopes, .. } = *self;\n-\n         // Build up the drops in **reverse** order. The end result will\n         // look like:\n         //\n@@ -781,11 +799,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // store caches. If everything is cached, we'll just walk right\n         // to left reading the cached results but never created anything.\n \n-        if scopes.iter().any(|scope| scope.needs_cleanup) {\n-            for scope in scopes.iter_mut() {\n-                target = build_diverge_scope(cfg, scope.region_scope_span,\n-                                             scope, target, generator_drop);\n-            }\n+        // Find the last cached block\n+        let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n+            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n+            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n+        } else {\n+            (self.resume_block(), 0)\n+        };\n+\n+        for scope in self.scopes[first_uncached..].iter_mut() {\n+            target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n+                                         scope, target, generator_drop);\n         }\n \n         target\n@@ -859,64 +883,62 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n }\n \n /// Builds drops for pop_scope and exit_scope.\n-fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n-                           resume_block: BasicBlock,\n-                           scope: &Scope<'tcx>,\n-                           earlier_scopes: &[Scope<'tcx>],\n-                           mut block: BasicBlock,\n-                           arg_count: usize,\n-                           generator_drop: bool)\n-                           -> BlockAnd<()> {\n-    debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n-    let mut iter = scope.drops.iter().rev();\n-    while let Some(drop_data) = iter.next() {\n+fn build_scope_drops<'tcx>(\n+    cfg: &mut CFG<'tcx>,\n+    scope: &Scope<'tcx>,\n+    mut block: BasicBlock,\n+    last_unwind_to: BasicBlock,\n+    arg_count: usize,\n+    generator_drop: bool,\n+) -> BlockAnd<()> {\n+    debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n+\n+    // Build up the drops in evaluation order. The end result will\n+    // look like:\n+    //\n+    // [SDs, drops[n]] --..> [SDs, drop[1]] -> [SDs, drop[0]] -> [[SDs]]\n+    //               |                    |                 |\n+    //               :                    |                 |\n+    //                                    V                 V\n+    // [drop[n]] -...-> [drop[1]] ------> [drop[0]] ------> [last_unwind_to]\n+    //\n+    // The horizontal arrows represent the execution path when the drops return\n+    // successfully. The downwards arrows represent the execution path when the\n+    // drops panic (panicking while unwinding will abort, so there's no need for\n+    // another set of arrows). The drops for the unwind path should have already\n+    // been generated by `diverge_cleanup_gen`.\n+    //\n+    // The code in this function reads from right to left.\n+    // Storage dead drops have to be done left to right (since we can only push\n+    // to the end of a Vec). So, we find the next drop and then call\n+    // push_storage_deads which will iterate backwards through them so that\n+    // they are added in the correct order.\n+\n+    let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n+        if let DropKind::Value { cached_block } = drop_data.kind {\n+            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n+                span_bug!(drop_data.span, \"cached block not present?\")\n+            }))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    // When we unwind from a drop, we start cleaning up from the next one, so\n+    // we don't need this block.\n+    unwind_blocks.next();\n+\n+    for drop_data in scope.drops.iter().rev() {\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n             DropKind::Value { .. } => {\n-                // Try to find the next block with its cached block for us to\n-                // diverge into, either a previous block in this current scope or\n-                // the top of the previous scope.\n-                //\n-                // If it wasn't for EndRegion, we could just chain all the DropData\n-                // together and pick the first DropKind::Value. Please do that\n-                // when we replace EndRegion with NLL.\n-                let on_diverge = iter.clone().filter_map(|dd| {\n-                    match dd.kind {\n-                        DropKind::Value { cached_block } => Some(cached_block),\n-                        DropKind::Storage => None\n-                    }\n-                }).next().or_else(|| {\n-                    if earlier_scopes.iter().any(|scope| scope.needs_cleanup) {\n-                        // If *any* scope requires cleanup code to be run,\n-                        // we must use the cached unwind from the *topmost*\n-                        // scope, to ensure all EndRegions from surrounding\n-                        // scopes are executed before the drop code runs.\n-                        Some(earlier_scopes.last().unwrap().cached_unwind)\n-                    } else {\n-                        // We don't need any further cleanup, so return None\n-                        // to avoid creating a landing pad. We can skip\n-                        // EndRegions because all local regions end anyway\n-                        // when the function unwinds.\n-                        //\n-                        // This is an important optimization because LLVM is\n-                        // terrible at optimizing landing pads. FIXME: I think\n-                        // it would be cleaner and better to do this optimization\n-                        // in SimplifyCfg instead of here.\n-                        None\n-                    }\n-                });\n-\n-                let on_diverge = on_diverge.map(|cached_block| {\n-                    cached_block.get(generator_drop).unwrap_or_else(|| {\n-                        span_bug!(drop_data.span, \"cached block not present?\")\n-                    })\n-                });\n+                let unwind_to = unwind_blocks.next().unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n                     location: drop_data.location.clone(),\n                     target: next,\n-                    unwind: Some(on_diverge.unwrap_or(resume_block))\n+                    unwind: Some(unwind_to)\n                 });\n                 block = next;\n             }\n@@ -943,20 +965,17 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n-                                       span: Span,\n-                                       scope: &mut Scope<'tcx>,\n-                                       mut target: BasicBlock,\n-                                       generator_drop: bool)\n-                                       -> BasicBlock\n+fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n+                             span: Span,\n+                             scope: &mut Scope<'tcx>,\n+                             mut target: BasicBlock,\n+                             generator_drop: bool)\n+                             -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n     //\n-    //    [EndRegion Block] -> [drops[n]] -...-> [drops[0]] -> [Free] -> [target]\n-    //    |                                                         |\n-    //    +---------------------------------------------------------+\n-    //     code for scope\n+    //    [drops[n]] -...-> [drops[0]] -> [target]\n     //\n     // The code in this function reads from right to left. At each\n     // point, we check for cached blocks representing the\n@@ -1001,20 +1020,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n         };\n     }\n \n-    // Finally, push the EndRegion block, used by mir-borrowck, and set\n-    // `cached_unwind` to point to it (Block becomes trivial goto after\n-    // pass that removes all EndRegions).\n-    target = {\n-        let cached_block = scope.cached_unwind.ref_mut(generator_drop);\n-        if let Some(cached_block) = *cached_block {\n-            cached_block\n-        } else {\n-            let block = cfg.start_new_cleanup_block();\n-            cfg.terminate(block, source_info(span), TerminatorKind::Goto { target });\n-            *cached_block = Some(block);\n-            block\n-        }\n-    };\n+    *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n     debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n "}, {"sha": "d8365c8c9cc2374749969e8c249d8b1c2c3961df", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1d7fc0ca500d8e532e7b1019397baec353560c26/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7fc0ca500d8e532e7b1019397baec353560c26/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=1d7fc0ca500d8e532e7b1019397baec353560c26", "patch": "@@ -44,7 +44,7 @@ fn main() {\n //         falseUnwind -> [real: bb3, cleanup: bb4];\n //     }\n //     bb2: {\n-//         goto -> bb29;\n+//         goto -> bb20;\n //     }\n //     bb3: {\n //         StorageLive(_2);\n@@ -90,58 +90,31 @@ fn main() {\n //         StorageDead(_3);\n //         StorageLive(_6);\n //         _6 = &_2;\n-//         _5 = const std::mem::drop(move _6) -> [return: bb28, unwind: bb4];\n+//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n //     }\n //     bb15: {\n+//         StorageDead(_3);\n //         goto -> bb16;\n //     }\n //     bb16: {\n-//         goto -> bb17;\n-//     }\n-//     bb17: {\n-//         goto -> bb18;\n-//     }\n-//     bb18: {\n-//         goto -> bb19;\n-//     }\n-//     bb19: {\n-//         goto -> bb20;\n-//     }\n-//     bb20: {\n-//         StorageDead(_3);\n-//         goto -> bb21;\n-//     }\n-//     bb21: {\n-//         goto -> bb22;\n-//     }\n-//     bb22: {\n //         StorageDead(_2);\n-//         goto -> bb23;\n-//     }\n-//     bb23: {\n-//         goto -> bb24;\n-//     }\n-//     bb24: {\n-//         goto -> bb25;\n-//     }\n-//     bb25: {\n //         goto -> bb2;\n //     }\n-//     bb26: {\n+//     bb17: {\n //         _4 = ();\n //         unreachable;\n //     }\n-//     bb27: {\n+//     bb18: {\n //         StorageDead(_4);\n //         goto -> bb14;\n //     }\n-//     bb28: {\n+//     bb19: {\n //         StorageDead(_6);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }\n-//     bb29: {\n+//     bb20: {\n //         return;\n //     }\n // }"}]}