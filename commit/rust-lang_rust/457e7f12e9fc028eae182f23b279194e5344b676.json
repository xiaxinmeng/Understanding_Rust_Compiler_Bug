{"sha": "457e7f12e9fc028eae182f23b279194e5344b676", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1N2U3ZjEyZTlmYzAyOGVhZTE4MmYyM2IyNzkxOTRlNTM0NGI2NzY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-26T10:36:43Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-26T10:36:43Z"}, "message": "Merge #3355\n\n3355: Lint to remove redundant `clone()`s r=oli-obk a=sinkuu\n\nThis PR adds lint `redundant_clone`. It suggests to remove redundant `clone()` that clones a owned value that will be dropped without any usage after that.\r\n\r\nReal-world example: https://github.com/rust-lang/rust/compare/7b0735a..sinkuu:redundant_clone2\n\nCo-authored-by: Shotaro Yamada <sinkuu@sinkuu.xyz>", "tree": {"sha": "31d78473abb474a676b95b7726125ce465dbc9bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d78473abb474a676b95b7726125ce465dbc9bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/457e7f12e9fc028eae182f23b279194e5344b676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/457e7f12e9fc028eae182f23b279194e5344b676", "html_url": "https://github.com/rust-lang/rust/commit/457e7f12e9fc028eae182f23b279194e5344b676", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/457e7f12e9fc028eae182f23b279194e5344b676/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5e1c7366005636897810709b883124cf2fb43f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1c7366005636897810709b883124cf2fb43f0c", "html_url": "https://github.com/rust-lang/rust/commit/5e1c7366005636897810709b883124cf2fb43f0c"}, {"sha": "9034b87a539904c96c01ece3c43878ce25887214", "url": "https://api.github.com/repos/rust-lang/rust/commits/9034b87a539904c96c01ece3c43878ce25887214", "html_url": "https://github.com/rust-lang/rust/commit/9034b87a539904c96c01ece3c43878ce25887214"}], "stats": {"total": 507, "additions": 505, "deletions": 2}, "files": [{"sha": "5d9d470925fdb56f5c0eca84ec4d49a319d10f08", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -813,6 +813,7 @@ All notable changes to this project will be documented in this file.\n [`range_plus_one`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_plus_one\n [`range_step_by_zero`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_step_by_zero\n [`range_zip_with_len`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#range_zip_with_len\n+[`redundant_clone`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_closure\n [`redundant_closure_call`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_field_names`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#redundant_field_names"}, {"sha": "b4091cdab6c61a846032ce221cb70e49d0c7afa7", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 282 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 283 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "eaff87e78f8b93fb1154a7e85ab9992bbdd749c3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -179,6 +179,7 @@ pub mod ptr;\n pub mod ptr_offset_with_cast;\n pub mod question_mark;\n pub mod ranges;\n+pub mod redundant_clone;\n pub mod redundant_field_names;\n pub mod redundant_pattern_matching;\n pub mod reference;\n@@ -452,6 +453,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box indexing_slicing::IndexingSlicing);\n     reg.register_late_lint_pass(box non_copy_const::NonCopyConst);\n     reg.register_late_lint_pass(box ptr_offset_with_cast::Pass);\n+    reg.register_late_lint_pass(box redundant_clone::RedundantClone);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -981,6 +983,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         fallible_impl_from::FALLIBLE_IMPL_FROM,\n         mutex_atomic::MUTEX_INTEGER,\n         needless_borrow::NEEDLESS_BORROW,\n+        redundant_clone::REDUNDANT_CLONE,\n         unwrap::PANICKING_UNWRAP,\n         unwrap::UNNECESSARY_UNWRAP,\n     ]);"}, {"sha": "8c8959159217c46615a9334187f02c03b9994205", "filename": "clippy_lints/src/redundant_clone.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -0,0 +1,290 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::{def_id, Body, FnDecl};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::mir::{\n+    self, traversal,\n+    visit::{PlaceContext, Visitor},\n+    TerminatorKind,\n+};\n+use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::{\n+    ast::NodeId,\n+    source_map::{BytePos, Span},\n+};\n+use crate::utils::{\n+    in_macro, is_copy, match_def_path, match_type, paths, snippet_opt, span_lint_node, span_lint_node_and_then,\n+    walk_ptrs_ty_depth,\n+};\n+use if_chain::if_chain;\n+use std::convert::TryFrom;\n+\n+macro_rules! unwrap_or_continue {\n+    ($x:expr) => {\n+        match $x {\n+            Some(x) => x,\n+            None => continue,\n+        }\n+    };\n+}\n+\n+/// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n+/// value that is going to be dropped without further use.\n+///\n+/// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n+/// allocations and deallocations generated by redundant `clone()`s.\n+///\n+/// **Known problems:**\n+///\n+/// * Suggestions made by this lint could require NLL to be enabled.\n+/// * False-positive if there is a borrow preventing the value from moving out.\n+///\n+/// ```rust\n+/// let x = String::new();\n+///\n+/// let y = &x;\n+///\n+/// foo(x.clone()); // This lint suggests to remove this `clone()`\n+/// ```\n+///\n+/// **Example:**\n+/// ```rust\n+/// {\n+///     let x = Foo::new();\n+///     call(x.clone());\n+///     call(x.clone()); // this can just pass `x`\n+/// }\n+///\n+/// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n+///\n+/// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n+/// ```\n+declare_clippy_lint! {\n+    pub REDUNDANT_CLONE,\n+    nursery,\n+    \"`clone()` of an owned value that is going to be dropped immediately\"\n+}\n+\n+pub struct RedundantClone;\n+\n+impl LintPass for RedundantClone {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(REDUNDANT_CLONE)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        _: Span,\n+        _: NodeId,\n+    ) {\n+        let def_id = cx.tcx.hir.body_owner_def_id(body.id());\n+        let mir = cx.tcx.optimized_mir(def_id);\n+\n+        for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n+            let terminator = bbdata.terminator();\n+\n+            if in_macro(terminator.source_info.span) {\n+                continue;\n+            }\n+\n+            // Give up on loops\n+            if terminator.successors().any(|s| *s == bb) {\n+                continue;\n+            }\n+\n+            let (fn_def_id, arg, arg_ty, _) = unwrap_or_continue!(is_call_with_ref_arg(cx, mir, &terminator.kind));\n+\n+            let from_borrow = match_def_path(cx.tcx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n+                || match_def_path(cx.tcx, fn_def_id, &paths::TO_OWNED_METHOD)\n+                || (match_def_path(cx.tcx, fn_def_id, &paths::TO_STRING_METHOD)\n+                    && match_type(cx, arg_ty, &paths::STRING));\n+\n+            let from_deref = !from_borrow\n+                && (match_def_path(cx.tcx, fn_def_id, &paths::PATH_TO_PATH_BUF)\n+                    || match_def_path(cx.tcx, fn_def_id, &paths::OS_STR_TO_OS_STRING));\n+\n+            if !from_borrow && !from_deref {\n+                continue;\n+            }\n+\n+            // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); } (from_deref)\n+            // In case of `from_deref`, `arg` is already a reference since it is `deref`ed in the previous\n+            // block.\n+            let cloned = unwrap_or_continue!(find_stmt_assigns_to(arg, from_borrow, bbdata.statements.iter().rev()));\n+\n+            // _1 in MIR `{ _2 = &_1; _3 = deref(move _2); } -> { _4 = _3; to_path_buf(move _4); }`\n+            let referent = if from_deref {\n+                let ps = mir.predecessors_for(bb);\n+                if ps.len() != 1 {\n+                    continue;\n+                }\n+                let pred_terminator = mir[ps[0]].terminator();\n+\n+                let pred_arg = if_chain! {\n+                    if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n+                        is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n+                    if *res == mir::Place::Local(cloned);\n+                    if match_def_path(cx.tcx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n+                    if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n+                        || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n+                    then {\n+                        pred_arg\n+                    } else {\n+                        continue;\n+                    }\n+                };\n+\n+                unwrap_or_continue!(find_stmt_assigns_to(pred_arg, true, mir[ps[0]].statements.iter().rev()))\n+            } else {\n+                cloned\n+            };\n+\n+            let used_later = traversal::ReversePostorder::new(&mir, bb).skip(1).any(|(tbb, tdata)| {\n+                // Give up on loops\n+                if tdata.terminator().successors().any(|s| *s == bb) {\n+                    return true;\n+                }\n+\n+                let mut vis = LocalUseVisitor {\n+                    local: referent,\n+                    used_other_than_drop: false,\n+                };\n+                vis.visit_basic_block_data(tbb, tdata);\n+                vis.used_other_than_drop\n+            });\n+\n+            if !used_later {\n+                let span = terminator.source_info.span;\n+                let node = if let mir::ClearCrossCrate::Set(scope_local_data) = &mir.source_scope_local_data {\n+                    scope_local_data[terminator.source_info.scope].lint_root\n+                } else {\n+                    unreachable!()\n+                };\n+\n+                if_chain! {\n+                    if let Some(snip) = snippet_opt(cx, span);\n+                    if let Some(dot) = snip.rfind('.');\n+                    then {\n+                        let sugg_span = span.with_lo(\n+                            span.lo() + BytePos(u32::try_from(dot).unwrap())\n+                        );\n+\n+                        span_lint_node_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |db| {\n+                            db.span_suggestion_with_applicability(\n+                                sugg_span,\n+                                \"remove this\",\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            db.span_note(\n+                                span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n+                                \"this value is dropped without further use\",\n+                            );\n+                        });\n+                    } else {\n+                        span_lint_node(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// If `kind` is `y = func(x: &T)` where `T: !Copy`, returns `(DefId of func, x, T, y)`.\n+fn is_call_with_ref_arg<'tcx>(\n+    cx: &LateContext<'_, 'tcx>,\n+    mir: &'tcx mir::Mir<'tcx>,\n+    kind: &'tcx mir::TerminatorKind<'tcx>,\n+) -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n+    if_chain! {\n+        if let TerminatorKind::Call { func, args, destination, .. } = kind;\n+        if args.len() == 1;\n+        if let mir::Operand::Move(mir::Place::Local(local)) = &args[0];\n+        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n+        if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n+        if !is_copy(cx, inner_ty);\n+        then {\n+            Some((def_id, *local, inner_ty, destination.as_ref().map(|(dest, _)| dest)))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Finds the first `to = (&)from`, and returns `Some(from)`.\n+fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n+    to: mir::Local,\n+    by_ref: bool,\n+    mut stmts: impl Iterator<Item = &'a mir::Statement<'tcx>>,\n+) -> Option<mir::Local> {\n+    stmts.find_map(|stmt| {\n+        if let mir::StatementKind::Assign(mir::Place::Local(local), v) = &stmt.kind {\n+            if *local == to {\n+                if by_ref {\n+                    if let mir::Rvalue::Ref(_, _, mir::Place::Local(r)) = **v {\n+                        return Some(r);\n+                    }\n+                } else if let mir::Rvalue::Use(mir::Operand::Copy(mir::Place::Local(r))) = **v {\n+                    return Some(r);\n+                }\n+            }\n+        }\n+\n+        None\n+    })\n+}\n+\n+struct LocalUseVisitor {\n+    local: mir::Local,\n+    used_other_than_drop: bool,\n+}\n+\n+impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n+    fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n+        let statements = &data.statements;\n+        for (statement_index, statement) in statements.iter().enumerate() {\n+            self.visit_statement(block, statement, mir::Location { block, statement_index });\n+\n+            // Once flagged, skip remaining statements\n+            if self.used_other_than_drop {\n+                return;\n+            }\n+        }\n+\n+        self.visit_terminator(\n+            block,\n+            data.terminator(),\n+            mir::Location {\n+                block,\n+                statement_index: statements.len(),\n+            },\n+        );\n+    }\n+\n+    fn visit_local(&mut self, local: &mir::Local, ctx: PlaceContext<'tcx>, _: mir::Location) {\n+        match ctx {\n+            PlaceContext::Drop | PlaceContext::StorageDead => return,\n+            _ => {},\n+        }\n+\n+        if *local == self.local {\n+            self.used_other_than_drop = true;\n+        }\n+    }\n+}"}, {"sha": "1a8db837f32b510d6987428d445a09cb152c08e1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -562,6 +562,23 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n     db.docs_link(lint);\n }\n \n+pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: NodeId, sp: Span, msg: &str) {\n+    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg)).docs_link(lint);\n+}\n+\n+pub fn span_lint_node_and_then(\n+    cx: &LateContext<'_, '_>,\n+    lint: &'static Lint,\n+    node: NodeId,\n+    sp: Span,\n+    msg: &str,\n+    f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n+) {\n+    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node, sp, msg));\n+    f(&mut db.0);\n+    db.docs_link(lint);\n+}\n+\n /// Add a span lint with a suggestion on how to fix it.\n ///\n /// These suggestions can be parsed by rustfix to allow it to automatically fix your code."}, {"sha": "8941d3031562b1331b6bc63130c70028db3b0e7e", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -23,6 +23,7 @@ pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeM\n pub const BTREEMAP_ENTRY: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n+pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n@@ -31,6 +32,7 @@ pub const C_VOID: [&str; 3] = [\"core\", \"ffi\", \"c_void\"];\n pub const C_VOID_LIBC: [&str; 2] = [\"libc\", \"c_void\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n+pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n@@ -67,7 +69,11 @@ pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n+pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n+pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARTIAL_ORD: [&str; 3] = [\"core\", \"cmp\", \"PartialOrd\"];\n+pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n+pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n@@ -100,7 +106,9 @@ pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\n pub const SLICE_ITER: [&str; 3] = [\"core\", \"slice\", \"Iter\"];\n pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n+pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n+pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const UNINIT: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"uninit\"];"}, {"sha": "14e9627e57344c0bde16b83e538048ac13d88465", "filename": "tests/ui/indexing_slicing.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Findexing_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Findexing_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing.stderr?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -1,3 +1,29 @@\n+error: index out of bounds: the len is 4 but the index is 4\n+  --> $DIR/indexing_slicing.rs:28:5\n+   |\n+28 |     x[4]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: index out of bounds: the len is 4 but the index is 8\n+  --> $DIR/indexing_slicing.rs:29:5\n+   |\n+29 |     x[1 << 3]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^^^^^^\n+\n+error: index out of bounds: the len is 0 but the index is 0\n+  --> $DIR/indexing_slicing.rs:59:5\n+   |\n+59 |     empty[0]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^^^^^\n+\n+error: index out of bounds: the len is 4 but the index is 15\n+  --> $DIR/indexing_slicing.rs:90:5\n+   |\n+90 |     x[N]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n+   |     ^^^^\n+\n error: indexing may panic.\n   --> $DIR/indexing_slicing.rs:23:5\n    |\n@@ -279,5 +305,5 @@ error: range is out of bounds\n 98 |     &x[10..num]; // should trigger out of bounds error\n    |        ^^\n \n-error: aborting due to 39 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "deedde3823162bae9b6941cffe012d926de483ac", "filename": "tests/ui/redundant_clone.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![warn(clippy::redundant_clone)]\n+\n+use std::path::Path;\n+use std::ffi::OsString;\n+\n+fn main() {\n+    let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.clone();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.to_string();\n+\n+    let s = String::from(\"foo\");\n+    let _ = s.to_owned();\n+\n+    let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+\n+    let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+\n+    let _ = OsString::new().to_owned();\n+\n+    let _ = OsString::new().to_os_string();\n+\n+    // Check that lint level works\n+    #[allow(clippy::redundant_clone)] let _ = String::new().to_string();\n+}\n+\n+#[derive(Clone)]\n+struct Alpha;\n+fn double(a: Alpha) -> (Alpha, Alpha) {\n+    if true {\n+        (a.clone(), a.clone())\n+    } else {\n+        (Alpha, a)\n+    }\n+}"}, {"sha": "db452822f89154ce6c3f36c6f6defa384fb2ac23", "filename": "tests/ui/redundant_clone.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/457e7f12e9fc028eae182f23b279194e5344b676/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=457e7f12e9fc028eae182f23b279194e5344b676", "patch": "@@ -0,0 +1,111 @@\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:16:41\n+   |\n+16 |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |                                         ^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::redundant-clone` implied by `-D warnings`\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:16:13\n+   |\n+16 |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:19:14\n+   |\n+19 |     let _ = s.clone();\n+   |              ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:19:13\n+   |\n+19 |     let _ = s.clone();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:22:14\n+   |\n+22 |     let _ = s.to_string();\n+   |              ^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:22:13\n+   |\n+22 |     let _ = s.to_string();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:25:14\n+   |\n+25 |     let _ = s.to_owned();\n+   |              ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:25:13\n+   |\n+25 |     let _ = s.to_owned();\n+   |             ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:27:41\n+   |\n+27 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |                                         ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:27:13\n+   |\n+27 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:29:41\n+   |\n+29 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |                                         ^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:29:13\n+   |\n+29 |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:31:28\n+   |\n+31 |     let _ = OsString::new().to_owned();\n+   |                            ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:31:13\n+   |\n+31 |     let _ = OsString::new().to_owned();\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:33:28\n+   |\n+33 |     let _ = OsString::new().to_os_string();\n+   |                            ^^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:33:13\n+   |\n+33 |     let _ = OsString::new().to_os_string();\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:43:22\n+   |\n+43 |         (a.clone(), a.clone())\n+   |                      ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:43:21\n+   |\n+43 |         (a.clone(), a.clone())\n+   |                     ^\n+\n+error: aborting due to 9 previous errors\n+"}]}