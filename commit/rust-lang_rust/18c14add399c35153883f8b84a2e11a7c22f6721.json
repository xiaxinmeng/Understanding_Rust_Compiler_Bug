{"sha": "18c14add399c35153883f8b84a2e11a7c22f6721", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzE0YWRkMzk5YzM1MTUzODgzZjhiODRhMmUxMWE3YzIyZjY3MjE=", "commit": {"author": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2021-09-09T21:05:10Z"}, "committer": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2021-09-09T21:16:28Z"}, "message": "Add a `try_clone()` function to `OwnedFd`.\n\nAs suggested in #88564. This adds a `try_clone()` to `OwnedFd` by\nrefactoring the code out of the existing `File`/`Socket` code.", "tree": {"sha": "cc11eb72236251b79e7cb576f24a34b54c969d21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc11eb72236251b79e7cb576f24a34b54c969d21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c14add399c35153883f8b84a2e11a7c22f6721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c14add399c35153883f8b84a2e11a7c22f6721", "html_url": "https://github.com/rust-lang/rust/commit/18c14add399c35153883f8b84a2e11a7c22f6721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c14add399c35153883f8b84a2e11a7c22f6721/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497ee321af3b8496eaccd7af7b437f18bab81abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/497ee321af3b8496eaccd7af7b437f18bab81abf", "html_url": "https://github.com/rust-lang/rust/commit/497ee321af3b8496eaccd7af7b437f18bab81abf"}], "stats": {"total": 191, "additions": 115, "deletions": 76}, "files": [{"sha": "597e050b00d5a103d298de058080cd76d47450c9", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -8,6 +8,7 @@ use crate::fmt;\n use crate::fs;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed file descriptor.\n@@ -67,6 +68,28 @@ impl BorrowedFd<'_> {\n     }\n }\n \n+impl OwnedFd {\n+    /// Creates a new `OwnedFd` instance that shares the same underlying file handle\n+    /// as the existing `OwnedFd` instance.\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        // We want to atomically duplicate this file descriptor and set the\n+        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        #[cfg(not(target_os = \"espidf\"))]\n+        let cmd = libc::F_DUPFD_CLOEXEC;\n+\n+        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n+        // will never be supported, as this is a bare metal framework with\n+        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // not supported yet, it might be (currently it returns ENOSYS).\n+        #[cfg(target_os = \"espidf\")]\n+        let cmd = libc::F_DUPFD;\n+\n+        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n+        Ok(unsafe { Self::from_raw_fd(fd) })\n+    }\n+}\n+\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for BorrowedFd<'_> {\n     #[inline]"}, {"sha": "64c376151142513c50be578d752f564b27985e3b", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -11,6 +11,7 @@ use crate::marker::PhantomData;\n use crate::mem::forget;\n use crate::ptr::NonNull;\n use crate::sys::c;\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed handle.\n@@ -110,6 +111,38 @@ impl BorrowedHandle<'_> {\n     }\n }\n \n+impl OwnedHandle {\n+    /// Creates a new `OwnedHandle` instance that shares the same underlying file handle\n+    /// as the existing `OwnedHandle` instance.\n+    pub fn try_clone(&self) -> crate::io::Result<FileDesc> {\n+        let handle = self.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)?;\n+\n+        Ok(unsafe { OwnedHandle::from_raw_handle(handle) })\n+    }\n+\n+    pub(crate) fn duplicate(\n+        &self,\n+        access: c::DWORD,\n+        inherit: bool,\n+        options: c::DWORD,\n+    ) -> io::Result<Self> {\n+        let mut ret = 0 as c::HANDLE;\n+        cvt(unsafe {\n+            let cur_proc = c::GetCurrentProcess();\n+            c::DuplicateHandle(\n+                cur_proc,\n+                self.as_raw_handle(),\n+                cur_proc,\n+                &mut ret,\n+                access,\n+                inherit as c::BOOL,\n+                options,\n+            )\n+        })?;\n+        unsafe { Ok(Self::from_raw_handle(ret)) }\n+    }\n+}\n+\n impl TryFrom<HandleOrInvalid> for OwnedHandle {\n     type Error = ();\n "}, {"sha": "9e27ead90fb56544694442feef9a35521ddd8dd0", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -7,6 +7,7 @@ use crate::fmt;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n use crate::sys::c;\n+use crate::sys::cvt;\n \n /// A borrowed socket.\n ///\n@@ -69,6 +70,59 @@ impl BorrowedSocket<'_> {\n     }\n }\n \n+impl OwnedSocket {\n+    /// Creates a new `OwnedSocket` instance that shares the same underlying socket\n+    /// as the existing `OwnedSocket` instance.\n+    pub fn try_clone(&self) -> io::Result<Self> {\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let result = unsafe {\n+            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n+        };\n+        cvt(result)?;\n+        let socket = unsafe {\n+            c::WSASocketW(\n+                info.iAddressFamily,\n+                info.iSocketType,\n+                info.iProtocol,\n+                &mut info,\n+                0,\n+                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            unsafe { Ok(Self::from_inner(OwnedSocket::from_raw_socket(socket))) }\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket = unsafe {\n+                c::WSASocketW(\n+                    info.iAddressFamily,\n+                    info.iSocketType,\n+                    info.iProtocol,\n+                    &mut info,\n+                    0,\n+                    c::WSA_FLAG_OVERLAPPED,\n+                )\n+            };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n+            }\n+\n+            unsafe {\n+                let socket = Self::from_inner(OwnedSocket::from_raw_socket(socket));\n+                socket.set_no_inherit()?;\n+                Ok(socket)\n+            }\n+        }\n+    }\n+}\n+\n impl AsRawSocket for BorrowedSocket<'_> {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {"}, {"sha": "3c2b36fe691bcd98f1fb3d6ac0fc1179921c25ba", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -266,22 +266,9 @@ impl FileDesc {\n         }\n     }\n \n+    #[inline]\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        // We want to atomically duplicate this file descriptor and set the\n-        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // is a POSIX flag that was added to Linux in 2.6.24.\n-        #[cfg(not(target_os = \"espidf\"))]\n-        let cmd = libc::F_DUPFD_CLOEXEC;\n-\n-        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n-        // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n-        // not supported yet, it might be (currently it returns ENOSYS).\n-        #[cfg(target_os = \"espidf\")]\n-        let cmd = libc::F_DUPFD;\n-\n-        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n-        Ok(unsafe { FileDesc::from_raw_fd(fd) })\n+        Ok(Self(self.0.try_clone()?))\n     }\n }\n "}, {"sha": "08ff35361f4b653400377fae49bd58dc595c2c64", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -455,7 +455,7 @@ impl File {\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n-        Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n+        Ok(Self(self.0.try_clone()?))\n     }\n \n     fn reparse_point<'a>("}, {"sha": "8de5729daa38d38a52cdc1cc22f15bb872d4cdc9", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -235,20 +235,7 @@ impl Handle {\n         inherit: bool,\n         options: c::DWORD,\n     ) -> io::Result<Handle> {\n-        let mut ret = 0 as c::HANDLE;\n-        cvt(unsafe {\n-            let cur_proc = c::GetCurrentProcess();\n-            c::DuplicateHandle(\n-                cur_proc,\n-                self.as_raw_handle(),\n-                cur_proc,\n-                &mut ret,\n-                access,\n-                inherit as c::BOOL,\n-                options,\n-            )\n-        })?;\n-        unsafe { Ok(Handle::from_raw_handle(ret)) }\n+        Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n }\n "}, {"sha": "681875985bdc98df193cc08b5cb61ef837f4125b", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c14add399c35153883f8b84a2e11a7c22f6721/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=18c14add399c35153883f8b84a2e11a7c22f6721", "patch": "@@ -208,52 +208,7 @@ impl Socket {\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n-        let result = unsafe {\n-            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n-        };\n-        cvt(result)?;\n-        let socket = unsafe {\n-            c::WSASocketW(\n-                info.iAddressFamily,\n-                info.iSocketType,\n-                info.iProtocol,\n-                &mut info,\n-                0,\n-                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            )\n-        };\n-\n-        if socket != c::INVALID_SOCKET {\n-            unsafe { Ok(Self::from_inner(OwnedSocket::from_raw_socket(socket))) }\n-        } else {\n-            let error = unsafe { c::WSAGetLastError() };\n-\n-            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n-                return Err(io::Error::from_raw_os_error(error));\n-            }\n-\n-            let socket = unsafe {\n-                c::WSASocketW(\n-                    info.iAddressFamily,\n-                    info.iSocketType,\n-                    info.iProtocol,\n-                    &mut info,\n-                    0,\n-                    c::WSA_FLAG_OVERLAPPED,\n-                )\n-            };\n-\n-            if socket == c::INVALID_SOCKET {\n-                return Err(last_error());\n-            }\n-\n-            unsafe {\n-                let socket = Self::from_inner(OwnedSocket::from_raw_socket(socket));\n-                socket.set_no_inherit()?;\n-                Ok(socket)\n-            }\n-        }\n+        Ok(Self(self.0.duplicate()?))\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {"}]}