{"sha": "7d4e8b9bc069c66eddf791421647bcb495bdeac4", "node_id": "C_kwDOAAsO6NoAKDdkNGU4YjliYzA2OWM2NmVkZGY3OTE0MjE2NDdiY2I0OTViZGVhYzQ", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:44:09Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: error and tree formatting", "tree": {"sha": "f8aac0de590eb804a27d7e55e64b8162f2baedff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8aac0de590eb804a27d7e55e64b8162f2baedff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d4e8b9bc069c66eddf791421647bcb495bdeac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4e8b9bc069c66eddf791421647bcb495bdeac4", "html_url": "https://github.com/rust-lang/rust/commit/7d4e8b9bc069c66eddf791421647bcb495bdeac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d4e8b9bc069c66eddf791421647bcb495bdeac4/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "html_url": "https://github.com/rust-lang/rust/commit/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c"}], "stats": {"total": 592, "additions": 592, "deletions": 0}, "files": [{"sha": "97bbdee1d4424b50762a51128b12bfa4a9fd5574", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/7d4e8b9bc069c66eddf791421647bcb495bdeac4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4e8b9bc069c66eddf791421647bcb495bdeac4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=7d4e8b9bc069c66eddf791421647bcb495bdeac4", "patch": "@@ -0,0 +1,592 @@\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use std::fmt;\n+use std::ops::Range;\n+\n+use crate::borrow_tracker::tree_borrows::{\n+    err_tb_ub, perms::Permission, tree::LocationState, unimap::UniIndex,\n+};\n+use crate::borrow_tracker::{AccessKind, ProtectorKind};\n+use crate::*;\n+\n+/// Some information that is irrelevant for the algorithm but very\n+/// convenient to know about a tag for debugging and testing.\n+#[derive(Clone, Debug)]\n+pub struct NodeDebugInfo {\n+    /// The tag in question.\n+    pub tag: BorTag,\n+    /// Name(s) that were associated with this tag (comma-separated).\n+    /// Typically the name of the variable holding the corresponding\n+    /// pointer in the source code.\n+    /// Helps match tag numbers to human-readable names.\n+    pub name: Option<String>,\n+}\n+impl NodeDebugInfo {\n+    /// New node info with a name.\n+    pub fn new(tag: BorTag) -> Self {\n+        Self { tag, name: None }\n+    }\n+\n+    /// Add a name to the tag. If a same tag is associated to several pointers,\n+    /// it can have several names which will be separated by commas.\n+    fn add_name(&mut self, name: &str) {\n+        if let Some(ref mut prev_name) = &mut self.name {\n+            prev_name.push(',');\n+            prev_name.push_str(name);\n+        } else {\n+            self.name = Some(String::from(name));\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NodeDebugInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(ref name) = self.name {\n+            write!(f, \"{tag:?} (also named '{name}')\", tag = self.tag)\n+        } else {\n+            write!(f, \"{tag:?}\", tag = self.tag)\n+        }\n+    }\n+}\n+\n+impl<'tcx> Tree {\n+    /// Climb the tree to get the tag of a distant ancestor.\n+    /// Allows operations on tags that are unreachable by the program\n+    /// but still exist in the tree. Not guaranteed to perform consistently\n+    /// if `tag-gc=1`.\n+    fn nth_parent(&self, tag: BorTag, nth_parent: u8) -> Option<BorTag> {\n+        let mut idx = self.tag_mapping.get(&tag).unwrap();\n+        for _ in 0..nth_parent {\n+            let node = self.nodes.get(idx).unwrap();\n+            idx = node.parent?;\n+        }\n+        Some(self.nodes.get(idx).unwrap().tag)\n+    }\n+\n+    /// Debug helper: assign name to tag.\n+    pub fn give_pointer_debug_name(\n+        &mut self,\n+        tag: BorTag,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let tag = self.nth_parent(tag, nth_parent).unwrap();\n+        let idx = self.tag_mapping.get(&tag).unwrap();\n+        if let Some(node) = self.nodes.get_mut(idx) {\n+            node.debug_info.add_name(name);\n+        } else {\n+            eprintln!(\"Tag {tag:?} (to be named '{name}') not found!\");\n+        }\n+        Ok(())\n+    }\n+\n+    /// Debug helper: determines if the tree contains a tag.\n+    pub fn is_allocation_of(&self, tag: BorTag) -> bool {\n+        self.tag_mapping.contains_key(&tag)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum TransitionError {\n+    /// This access is not allowed because some parent tag has insufficient permissions.\n+    /// For example, if a tag is `Frozen` and encounters a child write this will\n+    /// produce a `ChildAccessForbidden(Frozen)`.\n+    /// This kind of error can only occur on child accesses.\n+    ChildAccessForbidden(Permission),\n+    /// A protector was triggered due to an invalid transition that loses\n+    /// too much permissions.\n+    /// For example, if a protected tag goes from `Active` to `Frozen` due\n+    /// to a foreign write this will produce a `ProtectedTransition(Active, Frozen)`.\n+    /// This kind of error can only occur on foreign accesses.\n+    ProtectedTransition(Permission, Permission),\n+    /// Cannot deallocate because some tag in the allocation is strongly protected.\n+    /// This kind of error can only occur on deallocations.\n+    ProtectedDealloc,\n+}\n+\n+/// Failures that can occur during the execution of Tree Borrows procedures.\n+pub(super) struct TbError<'node> {\n+    /// What failure occurred.\n+    pub error_kind: TransitionError,\n+    /// The tag on which the error was triggered.\n+    /// On protector violations, this is the tag that was protected.\n+    /// On accesses rejected due to insufficient permissions, this is the\n+    /// tag that lacked those permissions.\n+    pub faulty_tag: &'node NodeDebugInfo,\n+    /// Whether this was a Read or Write access. This field is ignored\n+    /// when the error was triggered by a deallocation.\n+    pub access_kind: AccessKind,\n+    /// Which tag the access that caused this error was made through, i.e.\n+    /// which tag was used to read/write/deallocate.\n+    pub tag_of_access: &'node NodeDebugInfo,\n+}\n+\n+impl TbError<'_> {\n+    /// Produce a UB error.\n+    pub fn build<'tcx>(self) -> InterpErrorInfo<'tcx> {\n+        use TransitionError::*;\n+        err_tb_ub(match self.error_kind {\n+            ChildAccessForbidden(perm) => {\n+                format!(\n+                    \"{kind} through {initial} is forbidden because it is a child of {current} which is {perm}.\",\n+                    kind=self.access_kind,\n+                    initial=self.tag_of_access,\n+                    current=self.faulty_tag,\n+                    perm=perm,\n+                )\n+            }\n+            ProtectedTransition(start, end) => {\n+                format!(\n+                    \"{kind} through {initial} is forbidden because it is a foreign tag for {current}, which would hence change from {start} to {end}, but {current} is protected\",\n+                    current=self.faulty_tag,\n+                    start=start,\n+                    end=end,\n+                    kind=self.access_kind,\n+                    initial=self.tag_of_access,\n+                )\n+            }\n+            ProtectedDealloc => {\n+                format!(\n+                    \"the allocation of {initial} also contains {current} which is strongly protected, cannot deallocate\",\n+                    initial=self.tag_of_access,\n+                    current=self.faulty_tag,\n+                )\n+            }\n+        }).into()\n+    }\n+}\n+\n+type S = &'static str;\n+/// Pretty-printing details\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtWrapper {\n+///     top: '>',\n+///     bot: '<',\n+///     warning_text: \"Some tags have been hidden\",\n+/// }\n+/// ```\n+/// will wrap the entire text with\n+/// ```text\n+/// >>>>>>>>>>>>>>>>>>>>>>>>>>\n+/// Some tags have been hidden\n+///\n+/// [ main display here ]\n+///\n+/// <<<<<<<<<<<<<<<<<<<<<<<<<<\n+/// ```\n+struct DisplayFmtWrapper {\n+    /// Character repeated to make the upper border.\n+    top: char,\n+    /// Character repeated to make the lower border.\n+    bot: char,\n+    /// Warning about some tags (unnamed) being hidden.\n+    warning_text: S,\n+}\n+\n+/// Formating of the permissions on each range.\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtPermission {\n+///     open: \"[\",\n+///     sep: \"|\",\n+///     close: \"]\",\n+///     uninit: \"___\",\n+///     range_sep: \"..\",\n+/// }\n+/// ```\n+/// will show each permission line as\n+/// ```text\n+/// 0.. 1.. 2.. 3.. 4.. 5\n+/// [Act|Res|Frz|Dis|___]\n+/// ```\n+struct DisplayFmtPermission {\n+    /// Text that starts the permission block.\n+    open: S,\n+    /// Text that separates permissions on different ranges.\n+    sep: S,\n+    /// Text that ends the permission block.\n+    close: S,\n+    /// Text to show when a permission is not initialized.\n+    /// Should have the same width as a `Permission`'s `.short_name()`, i.e.\n+    /// 3 if using the `Res/Act/Frz/Dis` notation.\n+    uninit: S,\n+    /// Text to separate the `start` and `end` values of a range.\n+    range_sep: S,\n+}\n+\n+/// Formating of the tree structure.\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtPadding {\n+///     join_middle: \"|-\",\n+///     join_last: \"'-\",\n+///     join_haschild: \"-+-\",\n+///     join_default: \"---\",\n+///     indent_middle: \"| \",\n+///     indent_last: \"  \",\n+/// }\n+/// ```\n+/// will show the tree as\n+/// ```text\n+/// -+- root\n+///  |--+- a\n+///  |  '--+- b\n+///  |     '---- c\n+///  |--+- d\n+///  |  '---- e\n+///  '---- f\n+/// ```\n+struct DisplayFmtPadding {\n+    /// Connector for a child other than the last.\n+    join_middle: S,\n+    /// Connector for the last child. Should have the same width as `join_middle`.\n+    join_last: S,\n+    /// Connector for a node that itself has a child.\n+    join_haschild: S,\n+    /// Connector for a node that does not have a child. Should have the same width\n+    /// as `join_haschild`.\n+    join_default: S,\n+    /// Indentation when there is a next child.\n+    indent_middle: S,\n+    /// Indentation for the last child.\n+    indent_last: S,\n+}\n+/// How to show whether a location has been accessed\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtAccess {\n+///     yes: \" \",\n+///     no: \"?\",\n+///     meh: \"_\",\n+/// }\n+/// ```\n+/// will show states as\n+/// ```text\n+///  Act\n+/// ?Res\n+/// ____\n+/// ```\n+struct DisplayFmtAccess {\n+    /// Used when `State.initialized = true`.\n+    yes: S,\n+    /// Used when `State.initialized = false`.\n+    /// Should have the same width as `yes`.\n+    no: S,\n+    /// Used when there is no `State`.\n+    /// Should have the same width as `yes`.\n+    meh: S,\n+}\n+\n+/// All parameters to determine how the tree is formated.\n+struct DisplayFmt {\n+    wrapper: DisplayFmtWrapper,\n+    perm: DisplayFmtPermission,\n+    padding: DisplayFmtPadding,\n+    accessed: DisplayFmtAccess,\n+}\n+impl DisplayFmt {\n+    /// Print the permission with the format\n+    /// ` Res`/` Re*`/` Act`/` Frz`/` Dis` for accessed locations\n+    /// and `?Res`/`?Re*`/`?Act`/`?Frz`/`?Dis` for unaccessed locations.\n+    fn print_perm(&self, perm: Option<LocationState>) -> String {\n+        if let Some(perm) = perm {\n+            format!(\n+                \"{ac}{st}\",\n+                ac = if perm.is_initialized() { self.accessed.yes } else { self.accessed.no },\n+                st = perm.permission().short_name(),\n+            )\n+        } else {\n+            format!(\"{}{}\", self.accessed.meh, self.perm.uninit)\n+        }\n+    }\n+\n+    /// Print the tag with the format `<XYZ>` if the tag is unnamed,\n+    /// and `<XYZ=name>` if the tag is named.\n+    fn print_tag(&self, tag: BorTag, name: &Option<String>) -> String {\n+        let printable_tag = tag.get();\n+        if let Some(name) = name {\n+            format!(\"<{printable_tag}={name}>\")\n+        } else {\n+            format!(\"<{printable_tag}>\")\n+        }\n+    }\n+\n+    /// Print extra text if the tag has a protector.\n+    fn print_protector(&self, protector: Option<&ProtectorKind>) -> &'static str {\n+        protector\n+            .map(|p| {\n+                match *p {\n+                    ProtectorKind::WeakProtector => \" Weakly protected\",\n+                    ProtectorKind::StrongProtector => \" Strongly protected\",\n+                }\n+            })\n+            .unwrap_or(\"\")\n+    }\n+}\n+\n+/// Track the indentation of the tree.\n+struct DisplayIndent {\n+    curr: String,\n+}\n+impl DisplayIndent {\n+    fn new() -> Self {\n+        Self { curr: \"    \".to_string() }\n+    }\n+\n+    /// Increment the indentation by one. Note: need to know if this\n+    /// is the last child or not because the presence of other children\n+    /// changes the way the indentation is shown.\n+    fn increment(&mut self, formatter: &DisplayFmt, is_last: bool) {\n+        self.curr.push_str(if is_last {\n+            formatter.padding.indent_last\n+        } else {\n+            formatter.padding.indent_middle\n+        });\n+    }\n+\n+    /// Pop the last level of indentation.\n+    fn decrement(&mut self, formatter: &DisplayFmt) {\n+        for _ in 0..formatter.padding.indent_last.len() {\n+            let _ = self.curr.pop();\n+        }\n+    }\n+\n+    /// Print the current indentation.\n+    fn write(&self, s: &mut String) {\n+        s.push_str(&self.curr);\n+    }\n+}\n+\n+/// Repeat a character a number of times.\n+fn char_repeat(c: char, n: usize) -> String {\n+    std::iter::once(c).cycle().take(n).collect::<String>()\n+}\n+\n+/// Extracted information from the tree, in a form that is readily accessible\n+/// for printing. I.e. resolve parent-child pointers into an actual tree,\n+/// zip permissions with their tag, remove wrappers, stringify data.\n+struct DisplayRepr {\n+    tag: BorTag,\n+    name: Option<String>,\n+    rperm: Vec<Option<LocationState>>,\n+    children: Vec<DisplayRepr>,\n+}\n+\n+impl DisplayRepr {\n+    fn from(tree: &Tree, show_unnamed: bool) -> Option<Self> {\n+        let mut v = Vec::new();\n+        extraction_aux(tree, tree.root, show_unnamed, &mut v);\n+        let Some(root) = v.pop() else {\n+            if show_unnamed {\n+                unreachable!(\"This allocation contains no tags, not even a root. This should not happen.\");\n+            }\n+            eprintln!(\"This allocation does not contain named tags. Use `miri_print_borrow_state(_, true)` to also print unnamed tags.\");\n+            return None;\n+        };\n+        assert!(v.is_empty());\n+        return Some(root);\n+\n+        fn extraction_aux(\n+            tree: &Tree,\n+            idx: UniIndex,\n+            show_unnamed: bool,\n+            acc: &mut Vec<DisplayRepr>,\n+        ) {\n+            let node = tree.nodes.get(idx).unwrap();\n+            let name = node.debug_info.name.clone();\n+            let children_sorted = {\n+                let mut children = node.children.iter().cloned().collect::<Vec<_>>();\n+                children.sort_by_key(|idx| tree.nodes.get(*idx).unwrap().tag);\n+                children\n+            };\n+            if !show_unnamed && name.is_none() {\n+                // We skip this node\n+                for child_idx in children_sorted {\n+                    extraction_aux(tree, child_idx, show_unnamed, acc);\n+                }\n+            } else {\n+                // We take this node\n+                let rperm = tree\n+                    .rperms\n+                    .iter_all()\n+                    .map(move |(_offset, perms)| {\n+                        let perm = perms.get(idx);\n+                        perm.cloned()\n+                    })\n+                    .collect::<Vec<_>>();\n+                let mut children = Vec::new();\n+                for child_idx in children_sorted {\n+                    extraction_aux(tree, child_idx, show_unnamed, &mut children);\n+                }\n+                acc.push(DisplayRepr { tag: node.tag, name, rperm, children });\n+            }\n+        }\n+    }\n+    fn print(\n+        &self,\n+        fmt: &DisplayFmt,\n+        indenter: &mut DisplayIndent,\n+        protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+        ranges: Vec<Range<u64>>,\n+        print_warning: bool,\n+    ) {\n+        let mut block = Vec::new();\n+        // Push the header and compute the required paddings for the body.\n+        // Header looks like this: `0.. 1.. 2.. 3.. 4.. 5.. 6.. 7.. 8`,\n+        // and is properly aligned with the `|` of the body.\n+        let (range_header, range_padding) = {\n+            let mut header_top = String::new();\n+            header_top.push_str(\"0..\");\n+            let mut padding = Vec::new();\n+            for (i, range) in ranges.iter().enumerate() {\n+                if i > 0 {\n+                    header_top.push_str(fmt.perm.range_sep);\n+                }\n+                let s = range.end.to_string();\n+                let l = s.chars().count() + fmt.perm.range_sep.chars().count();\n+                {\n+                    let target_len =\n+                        fmt.perm.uninit.chars().count() + fmt.accessed.yes.chars().count() + 1;\n+                    let tot_len = target_len.max(l);\n+                    let header_top_pad_len = target_len.saturating_sub(l);\n+                    let body_pad_len = tot_len.saturating_sub(target_len);\n+                    header_top.push_str(&format!(\"{}{}\", char_repeat(' ', header_top_pad_len), s));\n+                    padding.push(body_pad_len);\n+                }\n+            }\n+            ([header_top], padding)\n+        };\n+        for s in range_header {\n+            block.push(s);\n+        }\n+        // This is the actual work\n+        print_aux(\n+            self,\n+            &range_padding,\n+            fmt,\n+            indenter,\n+            protected_tags,\n+            true, /* root _is_ the last child */\n+            &mut block,\n+        );\n+        // Then it's just prettifying it with a border of dashes.\n+        {\n+            let wr = &fmt.wrapper;\n+            let max_width = {\n+                let block_width = block.iter().map(|s| s.chars().count()).max().unwrap();\n+                if print_warning {\n+                    block_width.max(wr.warning_text.chars().count())\n+                } else {\n+                    block_width\n+                }\n+            };\n+            eprintln!(\"{}\", char_repeat(wr.top, max_width));\n+            if print_warning {\n+                eprintln!(\"{}\", wr.warning_text,);\n+            }\n+            for line in block {\n+                eprintln!(\"{line}\");\n+            }\n+            eprintln!(\"{}\", char_repeat(wr.bot, max_width));\n+        }\n+\n+        // Here is the function that does the heavy lifting\n+        fn print_aux(\n+            tree: &DisplayRepr,\n+            padding: &[usize],\n+            fmt: &DisplayFmt,\n+            indent: &mut DisplayIndent,\n+            protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+            is_last_child: bool,\n+            acc: &mut Vec<String>,\n+        ) {\n+            let mut line = String::new();\n+            // Format the permissions on each range.\n+            // Looks like `| Act| Res| Res| Act|`.\n+            line.push_str(fmt.perm.open);\n+            for (i, (perm, &pad)) in tree.rperm.iter().zip(padding.iter()).enumerate() {\n+                if i > 0 {\n+                    line.push_str(fmt.perm.sep);\n+                }\n+                let show_perm = fmt.print_perm(*perm);\n+                line.push_str(&format!(\"{}{}\", char_repeat(' ', pad), show_perm));\n+            }\n+            line.push_str(fmt.perm.close);\n+            // Format the tree structure.\n+            // Main difficulty is handling the indentation properly.\n+            indent.write(&mut line);\n+            {\n+                // padding\n+                line.push_str(if is_last_child {\n+                    fmt.padding.join_last\n+                } else {\n+                    fmt.padding.join_middle\n+                });\n+                line.push_str(fmt.padding.join_default);\n+                line.push_str(if tree.children.is_empty() {\n+                    fmt.padding.join_default\n+                } else {\n+                    fmt.padding.join_haschild\n+                });\n+                line.push_str(fmt.padding.join_default);\n+                line.push_str(fmt.padding.join_default);\n+            }\n+            line.push_str(&fmt.print_tag(tree.tag, &tree.name));\n+            let protector = protected_tags.get(&tree.tag);\n+            line.push_str(fmt.print_protector(protector));\n+            // Push the line to the accumulator then recurse.\n+            acc.push(line);\n+            let nb_children = tree.children.len();\n+            for (i, child) in tree.children.iter().enumerate() {\n+                indent.increment(fmt, is_last_child);\n+                print_aux(child, padding, fmt, indent, protected_tags, i + 1 == nb_children, acc);\n+                indent.decrement(fmt);\n+            }\n+        }\n+    }\n+}\n+\n+const DEFAULT_FORMATTER: DisplayFmt = DisplayFmt {\n+    wrapper: DisplayFmtWrapper {\n+        top: '\u2500',\n+        bot: '\u2500',\n+        warning_text: \"Warning: this tree is indicative only. Some tags may have been hidden.\",\n+    },\n+    perm: DisplayFmtPermission { open: \"|\", sep: \"|\", close: \"|\", uninit: \"---\", range_sep: \"..\" },\n+    padding: DisplayFmtPadding {\n+        join_middle: \"\u251c\",\n+        join_last: \"\u2514\",\n+        indent_middle: \"\u2502 \",\n+        indent_last: \"  \",\n+        join_haschild: \"\u252c\",\n+        join_default: \"\u2500\",\n+    },\n+    accessed: DisplayFmtAccess { yes: \" \", no: \"?\", meh: \"-\" },\n+};\n+\n+impl<'tcx> Tree {\n+    /// Display the contents of the tree.\n+    pub fn print_tree(\n+        &self,\n+        protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+        show_unnamed: bool,\n+    ) -> InterpResult<'tcx> {\n+        let mut indenter = DisplayIndent::new();\n+        let ranges = self.rperms.iter_all().map(|(range, _perms)| range).collect::<Vec<_>>();\n+        if let Some(repr) = DisplayRepr::from(self, show_unnamed) {\n+            repr.print(\n+                &DEFAULT_FORMATTER,\n+                &mut indenter,\n+                protected_tags,\n+                ranges,\n+                /* print warning message about tags not shown */ !show_unnamed,\n+            );\n+        }\n+        Ok(())\n+    }\n+}"}]}