{"sha": "bab7eb20dff32294c65fa28cece552481c40cf0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYjdlYjIwZGZmMzIyOTRjNjVmYTI4Y2VjZTU1MjQ4MWM0MGNmMGI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-08T02:16:58Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T17:26:48Z"}, "message": "path2: Update based on more review feedback\n\nStandardize the is_sep() functions to be the same in both posix and\nwindows, and re-export from path. Update extra::glob to use this.\n\nRemove the usage of either, as it's going away.\n\nMove the WindowsPath-specific methods out of WindowsPath and make them\ntop-level functions of path::windows instead. This way you cannot\naccidentally write code that will fail to compile on non-windows\narchitectures without typing ::windows anywhere.\n\nRemove GenericPath::from_c_str() and just impl BytesContainer for\nCString instead.\n\nRemove .join_path() and .push_path() and just implement BytesContainer\nfor Path instead.\n\nRemove FilenameDisplay and add a boolean flag to Display instead.\n\nRemove .each_parent(). It only had one caller, so just inline its\ndefinition there.", "tree": {"sha": "fc81daee54a1f01c62c792ccbfba362e61d52d76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc81daee54a1f01c62c792ccbfba362e61d52d76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab7eb20dff32294c65fa28cece552481c40cf0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab7eb20dff32294c65fa28cece552481c40cf0b", "html_url": "https://github.com/rust-lang/rust/commit/bab7eb20dff32294c65fa28cece552481c40cf0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab7eb20dff32294c65fa28cece552481c40cf0b/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01a97b7a981fb5ae008be7e06df4bf6a85eba4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01a97b7a981fb5ae008be7e06df4bf6a85eba4f", "html_url": "https://github.com/rust-lang/rust/commit/c01a97b7a981fb5ae008be7e06df4bf6a85eba4f"}], "stats": {"total": 664, "additions": 274, "deletions": 390}, "files": [{"sha": "b1d8d83f9d3e5cb16f3c34142d94d88c1e14bb9b", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -189,7 +189,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n-            let filepath = testfile.dir_path().join_path(file);\n+            let filepath = testfile.dir_path().join(file);\n             io::read_whole_file_str(&filepath).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -657,7 +657,7 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n-    aux_output_dir_name(config, testfile).join_path(&auxname)\n+    aux_output_dir_name(config, testfile).join(&auxname)\n }\n \n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n@@ -757,7 +757,7 @@ fn output_testname(testfile: &Path) -> Path {\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {\n     config.build_base\n-        .join_path(&output_testname(testfile))\n+        .join(&output_testname(testfile))\n         .with_extension(config.stage_id.as_slice())\n }\n "}, {"sha": "83456777c40c1cb82276e4749e4eed35501b2007", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -24,6 +24,7 @@\n  */\n \n use std::{os, path};\n+use std::path::is_sep;\n \n use sort;\n \n@@ -81,11 +82,7 @@ pub fn glob(pattern: &str) -> GlobIterator {\n  */\n pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n     #[cfg(windows)]\n-    use is_sep = std::path::windows::is_sep2;\n-    #[cfg(not(windows))]\n-    fn is_sep(c: char) -> bool { c <= '\\x7F' && ::std::path::posix::is_sep(&(c as u8)) }\n-    #[cfg(windows)]\n-    fn check_windows_verbatim(p: &Path) -> bool { p.is_verbatim() }\n+    fn check_windows_verbatim(p: &Path) -> bool { path::windows::is_verbatim(p) }\n     #[cfg(not(windows))]\n     fn check_windows_verbatim(_: &Path) -> bool { false }\n \n@@ -98,7 +95,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n             // since we can't very well find all UNC shares with a 1-letter server name.\n             return GlobIterator { root: root, dir_patterns: ~[], options: options, todo: ~[] };\n         }\n-        root.push_path(pat_root.get_ref());\n+        root.push(pat_root.get_ref());\n     }\n \n     let root_len = pat_root.map_move_default(0u, |p| p.as_vec().len());\n@@ -462,7 +459,7 @@ fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptio\n \n /// A helper function to determine if two chars are (possibly case-insensitively) equal.\n fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n-    if cfg!(windows) && path::windows::is_sep2(a) && path::windows::is_sep2(b) {\n+    if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n         true\n     } else if !case_sensitive && a.is_ascii() && b.is_ascii() {\n         // FIXME: work with non-ascii chars properly (issue #1347)\n@@ -472,16 +469,6 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n     }\n }\n \n-/// A helper function to determine if a char is a path separator on the current platform.\n-fn is_sep(c: char) -> bool {\n-    if cfg!(windows) {\n-        path::windows::is_sep2(c)\n-    } else {\n-        c <= '\\x7F' && path::posix::is_sep(&(c as u8))\n-    }\n-}\n-\n-\n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */"}, {"sha": "0626ec0ece0a0c023bc572042de95ac617f796ce", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -45,7 +45,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n \n fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n-    let mut p = sess.filesearch.sysroot().join_path(&r);\n+    let mut p = sess.filesearch.sysroot().join(&r);\n     p.push(os::dll_filename(\"rustrt\"));\n     p\n }\n@@ -148,7 +148,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n \n     let tlib = filesearch::relative_target_lib_path(target_triple);\n     let mut path = Path::new(install_prefix);\n-    path.push_path(&tlib);\n+    path.push(&tlib);\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_owned()"}, {"sha": "2274f7d3c694fe9976171569a22b51f72971a746", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -100,7 +100,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n         }\n         fn get_target_lib_file_path(&self, file: &Path) -> Path {\n             let mut p = self.get_target_lib_path();\n-            p.push_path(file);\n+            p.push(file);\n             p\n         }\n     }\n@@ -148,7 +148,7 @@ pub fn relative_target_lib_path(target_triple: &str) -> Path {\n \n fn make_target_lib_path(sysroot: &Path,\n                         target_triple: &str) -> Path {\n-    sysroot.join_path(&relative_target_lib_path(target_triple))\n+    sysroot.join(&relative_target_lib_path(target_triple))\n }\n \n fn make_rustpkg_target_lib_path(dir: &Path,\n@@ -196,7 +196,7 @@ pub fn rust_path() -> ~[Path] {\n         }\n         None => ~[]\n     };\n-    let cwd = os::getcwd();\n+    let mut cwd = os::getcwd();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -205,30 +205,27 @@ pub fn rust_path() -> ~[Path] {\n     if !env_rust_path.contains(&cwd) {\n         env_rust_path.push(cwd.clone());\n     }\n-    do cwd.each_parent() |p| {\n-        if !env_rust_path.contains(&p.join(\".rust\")) {\n-            push_if_exists(&mut env_rust_path, p);\n+    loop {\n+        let f = cwd.pop();\n+        if f.is_none() || bytes!(\"..\") == f.unwrap() {\n+            break;\n         }\n-        true\n-    };\n+        cwd.push(\".rust\");\n+        if !env_rust_path.contains(&cwd) && os::path_exists(&cwd) {\n+            env_rust_path.push(cwd.clone());\n+        }\n+        cwd.pop();\n+    }\n     let h = os::homedir();\n     for h in h.iter() {\n-        if !env_rust_path.contains(&h.join(\".rust\")) {\n-            push_if_exists(&mut env_rust_path, h);\n+        let p = h.join(\".rust\");\n+        if !env_rust_path.contains(&p) && os::path_exists(&p) {\n+            env_rust_path.push(p);\n         }\n     }\n     env_rust_path\n }\n \n-\n-/// Adds p/.rust into vec, only if it exists\n-fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n-    let maybe_dir = p.join(\".rust\");\n-    if os::path_exists(&maybe_dir) {\n-        vec.push(maybe_dir);\n-    }\n-}\n-\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n pub fn libdir() -> ~str {"}, {"sha": "874a30394d1bab7392bb5d0bc6e81b50a09892e4", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -95,20 +95,20 @@ impl PkgSrc {\n             // We search for sources under both src/ and build/ , because build/ is where\n             // automatically-checked-out sources go.\n             let mut result = source_workspace.join(\"src\");\n-            result.push_path(&id.path.dir_path());\n+            result.push(&id.path.dir_path());\n             result.push(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result);\n             let mut result = source_workspace.join(\"src\");\n-            result.push_path(&id.path);\n+            result.push(&id.path);\n             to_try.push(result);\n \n             let mut result = build_dir.join(\"src\");\n-            result.push_path(&id.path.dir_path());\n+            result.push(&id.path.dir_path());\n             result.push_str(format!(\"{}-{}\", id.short_name, id.version.to_str()));\n             to_try.push(result.clone());\n             output_names.push(result);\n             let mut other_result = build_dir.join(\"src\");\n-            other_result.push_path(&id.path);\n+            other_result.push(&id.path);\n             to_try.push(other_result.clone());\n             output_names.push(other_result);\n \n@@ -146,7 +146,7 @@ impl PkgSrc {\n                                     source_workspace: source.clone(),\n                                     build_in_destination: build_in_destination,\n                                     destination_workspace: destination,\n-                                    start_dir: start.join_path(&suffix),\n+                                    start_dir: start.join(&suffix),\n                                     id: id,\n                                     libs: ~[],\n                                     mains: ~[],\n@@ -371,7 +371,7 @@ impl PkgSrc {\n                     cfgs: &[~str],\n                     what: OutputType) {\n         for crate in crates.iter() {\n-            let path = self.start_dir.join_path(&crate.file);\n+            let path = self.start_dir.join(&crate.file);\n             debug2!(\"build_crates: compiling {}\", path.display());\n             let cfgs = crate.cfgs + cfgs;\n \n@@ -416,7 +416,7 @@ impl PkgSrc {\n         debug2!(\"In declare inputs, self = {}\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = self.start_dir.join_path(&c.file);\n+                let path = self.start_dir.join(&c.file);\n                 debug2!(\"Declaring input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"file\", path.as_str().unwrap(),"}, {"sha": "0fe3abdefa3adc0375942159d072343fabe40c6a", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -68,7 +68,7 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     let mut found = None;\n     do os::walk_dir(&src_dir) |p| {\n         if os::path_is_dir(p) {\n-            if *p == src_dir.join_path(&pkgid.path) || {\n+            if *p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n                 do pf.iter().any |&g| {\n                     match split_version_general(g, '-') {\n@@ -196,7 +196,7 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n             prefix = {}\", short_name, where, workspace.display(), prefix);\n \n     let dir_to_search = match where {\n-        Build => target_build_dir(workspace).join_path(path),\n+        Build => target_build_dir(workspace).join(path),\n         Install => target_lib_dir(workspace)\n     };\n \n@@ -273,7 +273,7 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n-        let absolute_path = dir_to_search.join_path(&result_filename);\n+        let absolute_path = dir_to_search.join(&result_filename);\n         debug2!(\"result_filename = {}\", absolute_path.display());\n         absolute_path\n     };\n@@ -329,7 +329,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join_path(&pkgid.path),\n+                (Build, _)      => target_build_dir(workspace).join(&pkgid.path),\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n@@ -347,7 +347,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n \n     let mut result = target_build_dir(workspace);\n-    result.push_path(&pkgid.path);\n+    result.push(&pkgid.path);\n     debug2!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n@@ -370,7 +370,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // If we're installing, it just goes under <workspace>...\n         Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.join_path(&pkg_id.path)\n+        Build => workspace.join(&pkg_id.path)\n     };\n     debug2!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n@@ -388,7 +388,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n                            os::EXE_SUFFIX))\n     };\n     if !output_path.is_absolute() {\n-        output_path = os::getcwd().join_path(&output_path);\n+        output_path = os::getcwd().join(&output_path);\n     }\n     debug2!(\"mk_output_path: returning {}\", output_path.display());\n     output_path"}, {"sha": "7b10bf2a551b9e16e87ab0f278591a08da5628f0", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -416,15 +416,15 @@ impl CtxMethods for BuildContext {\n \n         debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n                 pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join_path(&pkgid.path)),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.display());\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join_path(&pkgid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&pkgid.path)) {\n             let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push_path(&pkgid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.join_path(&pkgid.path),\n+            out_dir.push(&pkgid.path);\n+            let git_result = source_control::safe_git_clone(&workspace.join(&pkgid.path),\n                                                             &pkgid.version,\n                                                             &out_dir);\n             match git_result {\n@@ -494,7 +494,7 @@ impl CtxMethods for BuildContext {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n                     debug2!(\"JustOne: p = {}\", p.display());\n-                    assert!(os::path_exists(&pkg_src.start_dir.join_path(p)));\n+                    assert!(os::path_exists(&pkg_src.start_dir.join(p)));\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n                     } else if is_main(p) {\n@@ -553,7 +553,7 @@ impl CtxMethods for BuildContext {\n         debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = pkg_src.start_dir.join_path(&c.file);\n+                let path = pkg_src.start_dir.join(&c.file);\n                 debug2!(\"Recording input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 inputs.push((~\"file\", path.as_str().unwrap().to_owned()));"}, {"sha": "4e8bcbb1cec8a356f71750bd54add0a09f1cc15e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -156,7 +156,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n fn init_git_repo(p: &Path) -> TempDir {\n     assert!(p.is_relative());\n     let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n-    let work_dir = tmp.path().join_path(p);\n+    let work_dir = tmp.path().join(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n     debug2!(\"Running: git init in {}\", work_dir.display());\n@@ -793,7 +793,7 @@ fn test_package_request_version() {\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n     let mut dir = target_build_dir(&repo.join(\".rust\"));\n-    dir.push_path(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n+    dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n     debug2!(\"dir = {}\", dir.display());\n     assert!(os::path_is_dir(&dir));\n     assert!(os::path_exists(&dir.join(\"version-0.3-file.txt\")));"}, {"sha": "23d9af77c01573974f71376e4533601beeaa4c9d", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -177,7 +177,7 @@ pub fn compile_input(context: &BuildContext,\n     // not sure if we should support anything else\n \n     let mut out_dir = target_build_dir(workspace);\n-    out_dir.push_path(&pkg_id.path);\n+    out_dir.push(&pkg_id.path);\n     // Make the output directory if it doesn't exist already\n     assert!(os::mkdir_recursive(&out_dir, U_RWX));\n "}, {"sha": "218f410e4dcfca47fa34b0587f964651e8984367", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -98,7 +98,7 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     let rustpath = rust_path();\n     for rp in rustpath.iter() {\n-        let local_path = rp.join_path(local_path);\n+        let local_path = rp.join(local_path);\n         let git_dir = local_path.join(\".git\");\n         if !os::path_is_dir(&git_dir) {\n             continue;"}, {"sha": "be50f6d1a9fbd154e7e9e693a262fb53ed88b548", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -78,7 +78,7 @@ pub fn getcwd() -> Path {\n                 fail2!()\n             }\n \n-            GenericPath::from_c_str(CString::new(buf as *c_char, false))\n+            Path::new(CString::new(buf as *c_char, false))\n         }\n     }\n }\n@@ -608,7 +608,7 @@ pub fn tmpdir() -> Path {\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n     let r = list_dir(p);\n     r.iter().advance(|q| {\n-        let path = &p.join_path(q);\n+        let path = &p.join(q);\n         f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n     })\n }\n@@ -648,7 +648,7 @@ pub fn make_absolute(p: &Path) -> Path {\n         p.clone()\n     } else {\n         let mut ret = getcwd();\n-        ret.push_path(p);\n+        ret.push(p);\n         ret\n     }\n }\n@@ -730,7 +730,7 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n                     let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(GenericPath::from_c_str(cstr));\n+                    paths.push(Path::new(cstr));\n                     entry_ptr = readdir(dir_ptr);\n                 }\n                 closedir(dir_ptr);\n@@ -800,7 +800,7 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n  * This version prepends each entry with the directory.\n  */\n pub fn list_dir_path(p: &Path) -> ~[Path] {\n-    list_dir(p).map(|f| p.join_path(f))\n+    list_dir(p).map(|f| p.join(f))\n }\n \n /// Removes a directory at the specified path, after removing"}, {"sha": "278a4ab36ff43b62899fd813e8860d3af05e04b2", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 51, "deletions": 105, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -30,9 +30,7 @@ no restriction on paths beyond disallowing NUL).\n ## Usage\n \n Usage of this module is fairly straightforward. Unless writing platform-specific\n-code, `Path` should be used to refer to the platform-native path, and methods\n-used should be restricted to those defined in `GenericPath`, and those methods\n-that are declared identically on both `PosixPath` and `WindowsPath`.\n+code, `Path` should be used to refer to the platform-native path.\n \n Creation of a path is typically done with either `Path::new(some_str)` or\n `Path::new(some_vec)`. This path can be modified with `.push()` and\n@@ -69,7 +67,6 @@ debug2!(\"path exists: {}\", b);\n use container::Container;\n use c_str::CString;\n use clone::Clone;\n-use either::{Left, Right};\n use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n@@ -121,6 +118,19 @@ pub use StrComponentIter = self::windows::StrComponentIter;\n #[cfg(windows)]\n pub use RevStrComponentIter = self::windows::RevStrComponentIter;\n \n+/// Typedef for the platform-native separator char func\n+#[cfg(unix)]\n+pub use is_sep = self::posix::is_sep;\n+/// Typedef for the platform-native separator char func\n+#[cfg(windows)]\n+pub use is_sep = self::windows::is_sep;\n+/// Typedef for the platform-native separator byte func\n+#[cfg(unix)]\n+pub use is_sep_byte = self::posix::is_sep_byte;\n+/// Typedef for the platform-native separator byte func\n+#[cfg(windows)]\n+pub use is_sep_byte = self::windows::is_sep_byte;\n+\n pub mod posix;\n pub mod windows;\n \n@@ -162,19 +172,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         }\n     }\n \n-    /// Creates a new Path from a CString.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// See individual Path impls for potential restrictions.\n-    #[inline]\n-    fn from_c_str(path: CString) -> Self {\n-        // CStrings can't contain NULs\n-        let v = path.as_bytes();\n-        // v is NUL-terminated. Strip it off\n-        let v = v.slice_to(v.len()-1);\n-        unsafe { GenericPathUnsafe::new_unchecked(v) }\n-    }\n-\n     /// Returns the path as a string, if possible.\n     /// If the path is not representable in utf-8, this returns None.\n     #[inline]\n@@ -195,15 +192,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// This will print the equivalent of `to_display_str()` when used with a {} format parameter.\n     fn display<'a>(&'a self) -> Display<'a, Self> {\n-        Display{ path: self }\n+        Display{ path: self, filename: false }\n     }\n \n     /// Returns an object that implements `fmt::Default` for printing filenames\n     ///\n     /// This will print the equivalent of `to_filename_display_str()` when used with a {}\n     /// format parameter. If there is no filename, nothing will be printed.\n-    fn filename_display<'a>(&'a self) -> FilenameDisplay<'a, Self> {\n-        FilenameDisplay{ path: self }\n+    fn filename_display<'a>(&'a self) -> Display<'a, Self> {\n+        Display{ path: self, filename: true }\n     }\n \n     /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n@@ -314,13 +311,17 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Raises the `null_byte` condition if the filestem contains a NUL.\n     fn set_filestem<T: BytesContainer>(&mut self, filestem: T) {\n         // borrowck is being a pain here\n+        enum Value<T> {\n+            Checked(T),\n+            Unchecked(~[u8])\n+        }\n         let val = {\n             match self.filename() {\n-                None => Left(filestem),\n+                None => Checked(filestem),\n                 Some(name) => {\n                     let dot = '.' as u8;\n                     match name.rposition_elem(&dot) {\n-                        None | Some(0) => Left(filestem),\n+                        None | Some(0) => Checked(filestem),\n                         Some(idx) => {\n                             let mut v;\n                             if contains_nul(filestem.container_as_bytes()) {\n@@ -336,15 +337,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                                 v.push_all(filestem);\n                             }\n                             v.push_all(name.slice_from(idx));\n-                            Right(v)\n+                            Unchecked(v)\n                         }\n                     }\n                 }\n             }\n         };\n         match val {\n-            Left(v)  => self.set_filename(v),\n-            Right(v) => unsafe { self.set_filename_unchecked(v) }\n+            Checked(v)  => self.set_filename(v),\n+            Unchecked(v) => unsafe { self.set_filename_unchecked(v) }\n         }\n     }\n     /// Replaces the extension with the given byte vector or string.\n@@ -545,12 +546,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             unsafe { self.push_unchecked(path) }\n         }\n     }\n-    /// Pushes a Path onto `self`.\n-    /// If the argument represents an absolute path, it replaces `self`.\n-    #[inline]\n-    fn push_path(&mut self, path: &Self) {\n-        self.push(path.as_vec())\n-    }\n     /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n     /// See `push` for details.\n     #[inline]\n@@ -590,14 +585,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         p.push(path);\n         p\n     }\n-    /// Returns a new Path constructed by joining `self` with the given path.\n-    /// If the given path is absolute, the new Path will represent just that.\n-    #[inline]\n-    fn join_path(&self, path: &Self) -> Self {\n-        let mut p = self.clone();\n-        p.push_path(path);\n-        p\n-    }\n     /// Returns a new Path constructed by joining `self` with the given paths\n     /// (as byte vectors or strings).\n     /// See `join` for details.\n@@ -632,21 +619,6 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// paths refer to separate drives, an absolute path is returned.\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n \n-    /// Executes a callback with the receiver and every parent\n-    fn each_parent(&self, f: &fn(&Self) -> bool) -> bool {\n-        let mut p = self.clone();\n-        loop {\n-            if !f(&p) {\n-                return false;\n-            }\n-            let f = p.pop();\n-            if f.is_none() || bytes!(\"..\") == f.unwrap() {\n-                break;\n-            }\n-        }\n-        true\n-    }\n-\n     /// Returns whether the relative path `child` is a suffix of `self`.\n     fn ends_with_path(&self, child: &Self) -> bool;\n }\n@@ -674,7 +646,7 @@ pub trait BytesContainer {\n     fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n         str::from_utf8_slice_opt(self.container_as_bytes())\n     }\n-    /// Returns whether the concrete receiver is a string type\n+    /// Returns whether .container_as_str() is guaranteed to not fail\n     // FIXME (#8888): Remove unused arg once ::<for T> works\n     #[inline]\n     fn is_str(_: Option<Self>) -> bool { false }\n@@ -703,11 +675,8 @@ pub trait GenericPathUnsafe {\n \n /// Helper struct for printing paths with format!()\n pub struct Display<'self, P> {\n-    priv path: &'self P\n-}\n-/// Helper struct for printing filenames with format!()\n-pub struct FilenameDisplay<'self, P> {\n-    priv path: &'self P\n+    priv path: &'self P,\n+    priv filename: bool\n }\n \n impl<'self, P: GenericPath> fmt::Default for Display<'self, P> {\n@@ -724,7 +693,14 @@ impl<'self, P: GenericPath> ToStr for Display<'self, P> {\n     /// If the path is not UTF-8, invalid sequences with be replaced with the\n     /// unicode replacement char. This involves allocation.\n     fn to_str(&self) -> ~str {\n-        from_utf8_with_replacement(self.path.as_vec())\n+        if self.filename {\n+            match self.path.filename() {\n+                None => ~\"\",\n+                Some(v) => from_utf8_with_replacement(v)\n+            }\n+        } else {\n+            from_utf8_with_replacement(self.path.as_vec())\n+        }\n     }\n }\n \n@@ -735,47 +711,9 @@ impl<'self, P: GenericPath> Display<'self, P> {\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n     pub fn with_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        match self.path.as_str() {\n-            Some(s) => f(s),\n-            None => {\n-                let s = self.to_str();\n-                f(s.as_slice())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'self, P: GenericPath> fmt::Default for FilenameDisplay<'self, P> {\n-    fn fmt(d: &FilenameDisplay<P>, f: &mut fmt::Formatter) {\n-        do d.with_str |s| {\n-            f.pad(s)\n-        }\n-    }\n-}\n-\n-impl<'self, P: GenericPath> ToStr for FilenameDisplay<'self, P> {\n-    /// Returns the filename as a string. If there is no filename, ~\"\" will be\n-    /// returned.\n-    ///\n-    /// If the filename is not UTF-8, invalid sequences will be replaced with\n-    /// the unicode replacement char. This involves allocation.\n-    fn to_str(&self) -> ~str {\n-        match self.path.filename() {\n-            None => ~\"\",\n-            Some(v) => from_utf8_with_replacement(v)\n-        }\n-    }\n-}\n-\n-impl<'self, P: GenericPath> FilenameDisplay<'self, P> {\n-    /// Provides the filename as a string to a closure. If there is no\n-    /// filename, \"\" will be provided.\n-    ///\n-    /// If the filename is not UTF-8, invalid sequences will be replaced with\n-    /// the unicode replacement char. This involves allocation.\n-    #[inline]\n-    pub fn with_str<T>(&self, f: &fn(&str) -> T) -> T {\n-        match self.path.filename_str() {\n+        let opt = if self.filename { self.path.filename_str() }\n+                  else { self.path.as_str() };\n+        match opt {\n             Some(s) => f(s),\n             None => {\n                 let s = self.to_str();\n@@ -865,6 +803,14 @@ impl BytesContainer for @[u8] {\n     }\n }\n \n+impl BytesContainer for CString {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        let s = self.as_bytes();\n+        s.slice_to(s.len()-1)\n+    }\n+}\n+\n #[inline(always)]\n fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)\n@@ -1121,13 +1067,13 @@ mod tests {\n     use c_str::ToCStr;\n \n     #[test]\n-    fn test_from_c_str() {\n+    fn test_cstring() {\n         let input = \"/foo/bar/baz\";\n-        let path: PosixPath = GenericPath::from_c_str(input.to_c_str());\n+        let path: PosixPath = PosixPath::new(input.to_c_str());\n         assert_eq!(path.as_vec(), input.as_bytes());\n \n         let input = \"\\\\foo\\\\bar\\\\baz\";\n-        let path: WindowsPath = GenericPath::from_c_str(input.to_c_str());\n+        let path: WindowsPath = WindowsPath::new(input.to_c_str());\n         assert_eq!(path.as_str().unwrap(), input.as_slice());\n     }\n }"}, {"sha": "fdc943fb882f91665ee7a8f1890b584f099d0710", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 51, "deletions": 80, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -48,12 +48,19 @@ pub struct Path {\n }\n \n /// The standard path separator character\n-pub static sep: u8 = '/' as u8;\n+pub static sep: char = '/';\n+static sep_byte: u8 = sep as u8;\n \n /// Returns whether the given byte is a path separator\n #[inline]\n-pub fn is_sep(u: &u8) -> bool {\n-    *u == sep\n+pub fn is_sep_byte(u: &u8) -> bool {\n+    *u as char == sep\n+}\n+\n+/// Returns whether the given char is a path separator\n+#[inline]\n+pub fn is_sep(c: char) -> bool {\n+    c == sep\n }\n \n impl Eq for Path {\n@@ -89,11 +96,29 @@ impl IterBytes for Path {\n     }\n }\n \n+impl BytesContainer for Path {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_vec()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self.into_vec()\n+    }\n+}\n+\n+impl<'self> BytesContainer for &'self Path {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_vec()\n+    }\n+}\n+\n impl GenericPathUnsafe for Path {\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&sep);\n+        let idx = path.rposition_elem(&sep_byte);\n         Path{ repr: path, sepidx: idx }\n     }\n \n@@ -106,11 +131,11 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 let mut v = vec::with_capacity(dirname.len() + self.repr.len() + 1);\n                 v.push_all(dirname);\n-                v.push(sep);\n+                v.push(sep_byte);\n                 v.push_all(self.repr);\n                 self.repr = Path::normalize(v);\n             }\n-            Some(0) if self.repr.len() == 1 && self.repr[0] == sep => {\n+            Some(0) if self.repr.len() == 1 && self.repr[0] == sep_byte => {\n                 self.repr = Path::normalize(dirname);\n             }\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n@@ -127,7 +152,7 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v);\n             }\n         }\n-        self.sepidx = self.repr.rposition_elem(&sep);\n+        self.sepidx = self.repr.rposition_elem(&sep_byte);\n     }\n \n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n@@ -136,7 +161,7 @@ impl GenericPathUnsafe for Path {\n             None if bytes!(\"..\") == self.repr => {\n                 let mut v = vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n-                v.push(sep);\n+                v.push(sep_byte);\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n             }\n@@ -146,7 +171,7 @@ impl GenericPathUnsafe for Path {\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n                 let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr);\n-                v.push(sep);\n+                v.push(sep_byte);\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n             }\n@@ -157,22 +182,22 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v);\n             }\n         }\n-        self.sepidx = self.repr.rposition_elem(&sep);\n+        self.sepidx = self.repr.rposition_elem(&sep_byte);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n         let path = path.container_as_bytes();\n         if !path.is_empty() {\n-            if path[0] == sep {\n+            if path[0] == sep_byte {\n                 self.repr = Path::normalize(path);\n             }  else {\n                 let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n                 v.push_all(self.repr);\n-                v.push(sep);\n+                v.push(sep_byte);\n                 v.push_all(path);\n                 self.repr = Path::normalize(v);\n             }\n-            self.sepidx = self.repr.rposition_elem(&sep);\n+            self.sepidx = self.repr.rposition_elem(&sep_byte);\n         }\n     }\n }\n@@ -228,7 +253,7 @@ impl GenericPath for Path {\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.rposition_elem(&sep);\n+                self.sepidx = self.repr.rposition_elem(&sep_byte);\n                 Some(v)\n             }\n         }\n@@ -244,7 +269,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        self.repr[0] == sep\n+        self.repr[0] == sep_byte\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -305,7 +330,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&sep)))\n+            Some(Path::new(comps.connect_vec(&sep_byte)))\n         }\n     }\n \n@@ -347,14 +372,14 @@ impl Path {\n     fn normalize<V: Vector<u8>+CopyableVector<u8>>(v: V) -> ~[u8] {\n         // borrowck is being very picky\n         let val = {\n-            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == sep;\n+            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == sep_byte;\n             let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n                 Some(comps) => {\n                     if is_abs && comps.is_empty() {\n-                        Some(~[sep])\n+                        Some(~[sep_byte])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -367,7 +392,7 @@ impl Path {\n                             }\n                         }\n                         for comp in it {\n-                            v.push(sep);\n+                            v.push(sep_byte);\n                             v.push_all(comp);\n                         }\n                         Some(v)\n@@ -386,10 +411,10 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n-        let v = if self.repr[0] == sep {\n+        let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n-        let mut ret = v.split_iter(is_sep);\n+        let mut ret = v.split_iter(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n             ret.next();\n@@ -400,10 +425,10 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See component_iter() for details.\n     pub fn rev_component_iter<'a>(&'a self) -> RevComponentIter<'a> {\n-        let v = if self.repr[0] == sep {\n+        let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n-        let mut ret = v.rsplit_iter(is_sep);\n+        let mut ret = v.rsplit_iter(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n             ret.next();\n@@ -432,7 +457,7 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n     let mut comps: ~[&'a [u8]] = ~[];\n     let mut n_up = 0u;\n     let mut changed = false;\n-    for comp in v.split_iter(is_sep) {\n+    for comp in v.split_iter(is_sep_byte) {\n         if comp.is_empty() { changed = true }\n         else if comp == bytes!(\".\") { changed = true }\n         else if comp == bytes!(\"..\") {\n@@ -928,7 +953,7 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     let push = Path::new($push);\n-                    p.push_path(&push);\n+                    p.push(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n@@ -1049,7 +1074,7 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let join = Path::new($join);\n-                    let res = path.join_path(&join);\n+                    let res = path.join(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n@@ -1598,58 +1623,4 @@ mod tests {\n         // str_component_iter is a wrapper around component_iter, so no need to do\n         // the full set of tests\n     }\n-\n-    #[test]\n-    fn test_each_parent() {\n-        assert!(Path::new(\"/foo/bar\").each_parent(|_| true));\n-        assert!(!Path::new(\"/foo/bar\").each_parent(|_| false));\n-\n-        macro_rules! t(\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let exp: &[&str] = $exp;\n-                    let mut comps = exp.iter().map(|&x|x);\n-                    do path.each_parent |p| {\n-                        let p = p.as_str();\n-                        assert!(p.is_some());\n-                        let e = comps.next();\n-                        assert!(e.is_some());\n-                        assert_eq!(p.unwrap(), e.unwrap());\n-                        true\n-                    };\n-                    assert!(comps.next().is_none());\n-                }\n-            );\n-            (v: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let exp: &[&[u8]] = $exp;\n-                    let mut comps = exp.iter().map(|&x|x);\n-                    do path.each_parent |p| {\n-                        let p = p.as_vec();\n-                        let e = comps.next();\n-                        assert!(e.is_some());\n-                        assert_eq!(p, e.unwrap());\n-                        true\n-                    };\n-                    assert!(comps.next().is_none());\n-                }\n-            )\n-        )\n-\n-        t!(s: \"/foo/bar\", [\"/foo/bar\", \"/foo\", \"/\"]);\n-        t!(s: \"/foo/bar/baz\", [\"/foo/bar/baz\", \"/foo/bar\", \"/foo\", \"/\"]);\n-        t!(s: \"/foo\", [\"/foo\", \"/\"]);\n-        t!(s: \"/\", [\"/\"]);\n-        t!(s: \"foo/bar/baz\", [\"foo/bar/baz\", \"foo/bar\", \"foo\", \".\"]);\n-        t!(s: \"foo/bar\", [\"foo/bar\", \"foo\", \".\"]);\n-        t!(s: \"foo\", [\"foo\", \".\"]);\n-        t!(s: \".\", [\".\"]);\n-        t!(s: \"..\", [\"..\"]);\n-        t!(s: \"../../foo\", [\"../../foo\", \"../..\"]);\n-\n-        t!(v: b!(\"foo/bar\", 0x80), [b!(\"foo/bar\", 0x80), b!(\"foo\"), b!(\".\")]);\n-        t!(v: b!(0xff, \"/bar\"), [b!(0xff, \"/bar\"), b!(0xff), b!(\".\")]);\n-    }\n }"}, {"sha": "5f8e1dc58fa297ae2367d444de9a070ebd6b7017", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 115, "deletions": 132, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -121,6 +121,44 @@ impl IterBytes for Path {\n     }\n }\n \n+impl BytesContainer for Path {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_vec()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self.into_vec()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        self.as_str().unwrap()\n+    }\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        self.as_str()\n+    }\n+    #[inline]\n+    fn is_str(_: Option<Path>) -> bool { true }\n+}\n+\n+impl<'self> BytesContainer for &'self Path {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_vec()\n+    }\n+    #[inline]\n+    fn container_as_str<'a>(&'a self) -> &'a str {\n+        self.as_str().unwrap()\n+    }\n+    #[inline]\n+    fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n+        self.as_str()\n+    }\n+    #[inline]\n+    fn is_str(_: Option<&'self Path>) -> bool { true }\n+}\n+\n impl GenericPathUnsafe for Path {\n     /// See `GenericPathUnsafe::from_vec_unchecked`.\n     ///\n@@ -235,7 +273,7 @@ impl GenericPathUnsafe for Path {\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n             let rest = path.slice_from(prefix_len(prefix));\n-            !rest.is_empty() && rest[0].is_ascii() && is_sep2(rest[0] as char)\n+            !rest.is_empty() && rest[0].is_ascii() && is_sep(rest[0] as char)\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n@@ -246,8 +284,8 @@ impl GenericPathUnsafe for Path {\n             }\n         }\n         fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool {\n-            u.is_ascii() && if prefix_is_verbatim(prefix) { is_sep(u as char) }\n-                            else { is_sep2(u as char) }\n+            if prefix_is_verbatim(prefix) { is_sep_verbatim(u as char) }\n+            else { is_sep(u as char) }\n         }\n \n         fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) {\n@@ -262,7 +300,7 @@ impl GenericPathUnsafe for Path {\n         fn append_path(me: &mut Path, path: &str) {\n             // appends a path that has no prefix\n             // if me is verbatim, we need to pre-normalize the new path\n-            let path_ = if me.is_verbatim() { Path::normalize__(path, None) }\n+            let path_ = if is_verbatim(me) { Path::normalize__(path, None) }\n                         else { None };\n             let pathlen = path_.map_default(path.len(), |p| p.len());\n             let mut s = str::with_capacity(me.repr.len() + 1 + pathlen);\n@@ -291,7 +329,7 @@ impl GenericPathUnsafe for Path {\n                 }\n                 None if !path.is_empty() && is_sep_(self.prefix, path[0]) => {\n                     // volume-relative path\n-                    if self.prefix().is_some() {\n+                    if self.prefix.is_some() {\n                         // truncate self down to the prefix, then append\n                         let n = self.prefix_len();\n                         self.repr.truncate(n);\n@@ -418,11 +456,6 @@ impl GenericPath for Path {\n         self.filename_str().map_move(|s| unsafe { GenericPathUnsafe::new_unchecked(s) })\n     }\n \n-    #[inline]\n-    fn push_path(&mut self, path: &Path) {\n-        self.push(path.as_str().unwrap())\n-    }\n-\n     #[inline]\n     fn pop(&mut self) -> Option<~[u8]> {\n         self.pop_str().map_move(|s| s.into_bytes())\n@@ -463,7 +496,7 @@ impl GenericPath for Path {\n                 }\n                 _ => self.repr.slice_to(self.prefix_len())\n             }))\n-        } else if self.is_vol_relative() {\n+        } else if is_vol_relative(self) {\n             Some(Path::new(self.repr.slice_to(1)))\n         } else {\n             None\n@@ -493,14 +526,14 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_relative(&self) -> bool {\n-        self.prefix.is_none() && !self.is_vol_relative()\n+        self.prefix.is_none() && !is_vol_relative(self)\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n         if !self.equiv_prefix(other) {\n             false\n         } else if self.is_absolute() != other.is_absolute() ||\n-                  self.is_vol_relative() != other.is_vol_relative() {\n+                  is_vol_relative(self) != is_vol_relative(other) {\n             false\n         } else {\n             let mut ita = self.str_component_iter().map(|x|x.unwrap());\n@@ -544,8 +577,8 @@ impl GenericPath for Path {\n             } else {\n                 None\n             }\n-        } else if self.is_vol_relative() != base.is_vol_relative() {\n-            if self.is_vol_relative() {\n+        } else if is_vol_relative(self) != is_vol_relative(base) {\n+            if is_vol_relative(self) {\n                 Some(self.clone())\n             } else {\n                 None\n@@ -555,8 +588,8 @@ impl GenericPath for Path {\n             let mut itb = base.str_component_iter().map(|x|x.unwrap());\n             let mut comps = ~[];\n \n-            let a_verb = self.is_verbatim();\n-            let b_verb = base.is_verbatim();\n+            let a_verb = is_verbatim(self);\n+            let b_verb = is_verbatim(base);\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, None) => break,\n@@ -598,20 +631,6 @@ impl GenericPath for Path {\n         }\n     }\n \n-    fn each_parent(&self, f: &fn(&Path) -> bool) -> bool {\n-        let mut p = self.clone();\n-        loop {\n-            if !f(&p) {\n-                return false;\n-            }\n-            let f = p.pop();\n-            if f.is_none() || (!p.is_verbatim() && bytes!(\"..\") == f.unwrap()) {\n-                break;\n-            }\n-        }\n-        true\n-    }\n-\n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n         let mut selfit = self.str_component_iter().invert();\n@@ -694,34 +713,6 @@ impl Path {\n         self.rev_str_component_iter().map(convert)\n     }\n \n-    /// Returns whether the path is considered \"volume-relative\", which means a path\n-    /// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n-    /// but absolute within that volume.\n-    #[inline]\n-    pub fn is_vol_relative(&self) -> bool {\n-        self.prefix.is_none() && self.repr[0] == sep as u8\n-    }\n-\n-    /// Returns whether the path is considered \"cwd-relative\", which means a path\n-    /// with a volume prefix that is not absolute. This look like \"C:foo.txt\". Paths\n-    /// of this form are relative to the cwd on the given volume.\n-    #[inline]\n-    pub fn is_cwd_relative(&self) -> bool {\n-        self.prefix == Some(DiskPrefix) && !self.is_absolute()\n-    }\n-\n-    /// Returns the PathPrefix for this Path\n-    #[inline]\n-    pub fn prefix(&self) -> Option<PathPrefix> {\n-        self.prefix\n-    }\n-\n-    /// Returns whether the prefix is a verbatim prefix, i.e. \\\\?\\\n-    #[inline]\n-    pub fn is_verbatim(&self) -> bool {\n-        prefix_is_verbatim(self.prefix)\n-    }\n-\n     fn equiv_prefix(&self, other: &Path) -> bool {\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n@@ -866,8 +857,8 @@ impl Path {\n         let s = if self.has_nonsemantic_trailing_slash() {\n                     self.repr.slice_to(self.repr.len()-1)\n                 } else { self.repr.as_slice() };\n-        let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep2 }\n-                          else { is_sep });\n+        let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n+                          else { is_sep_verbatim });\n         let prefixlen = self.prefix_len();\n         self.sepidx = idx.and_then(|x| if x < prefixlen { None } else { Some(x) });\n     }\n@@ -893,7 +884,7 @@ impl Path {\n     }\n \n     fn has_nonsemantic_trailing_slash(&self) -> bool {\n-        self.is_verbatim() && self.repr.len() > self.prefix_len()+1 &&\n+        is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n             self.repr[self.repr.len()-1] == sep as u8\n     }\n \n@@ -905,23 +896,65 @@ impl Path {\n     }\n }\n \n+/// Returns whether the path is considered \"volume-relative\", which means a path\n+/// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n+/// but absolute within that volume.\n+#[inline]\n+pub fn is_vol_relative(path: &Path) -> bool {\n+    path.prefix.is_none() && is_sep_byte(&path.repr[0])\n+}\n+\n+/// Returns whether the path is considered \"cwd-relative\", which means a path\n+/// with a volume prefix that is not absolute. This look like \"C:foo.txt\". Paths\n+/// of this form are relative to the cwd on the given volume.\n+#[inline]\n+pub fn is_cwd_relative(path: &Path) -> bool {\n+    path.prefix == Some(DiskPrefix) && !path.is_absolute()\n+}\n+\n+/// Returns the PathPrefix for this Path\n+#[inline]\n+pub fn prefix(path: &Path) -> Option<PathPrefix> {\n+    path.prefix\n+}\n+\n+/// Returns whether the Path's prefix is a verbatim prefix, i.e. \\\\?\\\n+#[inline]\n+pub fn is_verbatim(path: &Path) -> bool {\n+    prefix_is_verbatim(path.prefix)\n+}\n+\n /// The standard path separator character\n pub static sep: char = '\\\\';\n /// The alternative path separator character\n pub static sep2: char = '/';\n \n-/// Returns whether the given byte is a path separator.\n-/// Only allows the primary separator '\\'; use is_sep2 to allow '/'.\n+/// Returns whether the given char is a path separator.\n+/// Allows both the primary separator '\\' and the alternative separator '/'.\n #[inline]\n pub fn is_sep(c: char) -> bool {\n+    c == sep || c == sep2\n+}\n+\n+/// Returns whether the given char is a path separator.\n+/// Only allows the primary separator '\\'; use is_sep to allow '/'.\n+#[inline]\n+pub fn is_sep_verbatim(c: char) -> bool {\n     c == sep\n }\n \n /// Returns whether the given byte is a path separator.\n /// Allows both the primary separator '\\' and the alternative separator '/'.\n #[inline]\n-pub fn is_sep2(c: char) -> bool {\n-    c == sep || c == sep2\n+pub fn is_sep_byte(u: &u8) -> bool {\n+    *u as char == sep || *u as char == sep2\n+}\n+\n+/// Returns whether the given byte is a path separator.\n+/// Only allows the primary separator '\\'; use is_sep_byte to allow '/'.\n+#[inline]\n+pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n+    *u as char == sep\n }\n \n /// Prefix types for Path\n@@ -953,7 +986,7 @@ pub fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             if path.starts_with(\"UNC\\\\\") {\n                 // \\\\?\\UNC\\server\\share\n                 path = path.slice_from(4);\n-                let (idx_a, idx_b) = match parse_two_comps(path, is_sep) {\n+                let (idx_a, idx_b) = match parse_two_comps(path, is_sep_verbatim) {\n                     Some(x) => x,\n                     None => (path.len(), 0)\n                 };\n@@ -977,7 +1010,7 @@ pub fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             let idx = path.find('\\\\').unwrap_or(path.len());\n             return Some(DeviceNSPrefix(idx));\n         }\n-        match parse_two_comps(path, is_sep2) {\n+        match parse_two_comps(path, is_sep) {\n             Some((idx_a, idx_b)) if idx_a > 0 && idx_b > 0 => {\n                 // \\\\server\\share\n                 return Some(UNCPrefix(idx_a, idx_b));\n@@ -1006,14 +1039,14 @@ pub fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n \n // None result means the string didn't need normalizing\n fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) {\n-    let f = if !prefix_is_verbatim(prefix) { is_sep2 } else { is_sep };\n+    let f = if !prefix_is_verbatim(prefix) { is_sep } else { is_sep_verbatim };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n     let s_ = s.slice_from(prefix_len(prefix));\n     let s_ = if is_abs { s_.slice_from(1) } else { s_ };\n \n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {\n-            Some(DiskPrefix) | None => (if is_sep(s.char_at(prefix_len(prefix))) { None }\n+            Some(DiskPrefix) | None => (if is_sep_verbatim(s.char_at(prefix_len(prefix))) { None }\n                                         else { Some(~[]) }),\n             Some(_) => Some(~[]), // need to trim the trailing separator\n         });\n@@ -1036,7 +1069,7 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n         } else { comps.push(comp) }\n     }\n     if !changed && !prefix_is_verbatim(prefix) {\n-        changed = s.find(is_sep2).is_some();\n+        changed = s.find(is_sep).is_some();\n     }\n     if changed {\n         if comps.is_empty() && !is_abs && prefix.is_none() {\n@@ -1078,8 +1111,8 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n }\n \n fn prefix_is_sep(p: Option<PathPrefix>, c: u8) -> bool {\n-    c.is_ascii() && if !prefix_is_verbatim(p) { is_sep2(c as char) }\n-                    else { is_sep(c as char) }\n+    c.is_ascii() && if !prefix_is_verbatim(p) { is_sep(c as char) }\n+                    else { is_sep_verbatim(c as char) }\n }\n \n // Stat support\n@@ -1636,9 +1669,9 @@ mod tests {\n \n         // we do want to check one odd case though to ensure the prefix is re-parsed\n         let mut p = Path::new(\"\\\\\\\\?\\\\C:\");\n-        assert_eq!(p.prefix(), Some(VerbatimPrefix(2)));\n+        assert_eq!(prefix(&p), Some(VerbatimPrefix(2)));\n         p.push(\"foo\");\n-        assert_eq!(p.prefix(), Some(VerbatimDiskPrefix));\n+        assert_eq!(prefix(&p), Some(VerbatimDiskPrefix));\n         assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n \n         // and another with verbatim non-normalized paths\n@@ -1654,7 +1687,7 @@ mod tests {\n                 {\n                     let mut p = Path::new($path);\n                     let push = Path::new($push);\n-                    p.push_path(&push);\n+                    p.push(&push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n@@ -1837,7 +1870,7 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let join = Path::new($join);\n-                    let res = path.join_path(&join);\n+                    let res = path.join(&join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n@@ -1849,7 +1882,7 @@ mod tests {\n         t!(s: \"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n         t!(s: \".\", \"a\\\\b\", \"a\\\\b\");\n         t!(s: \"\\\\\", \"a\\\\b\", \"\\\\a\\\\b\");\n-        // join_path is implemented using push_path, so there's no need for\n+        // join is implemented using push, so there's no need for\n         // the full set of prefix tests\n     }\n \n@@ -2217,11 +2250,11 @@ mod tests {\n                     let b = path.is_absolute();\n                     assert!(b == abs, \"Path '{}'.is_absolute(): expected {:?}, found {:?}\",\n                             path.as_str().unwrap(), abs, b);\n-                    let b = path.is_vol_relative();\n-                    assert!(b == vol, \"Path '{}'.is_vol_relative(): expected {:?}, found {:?}\",\n+                    let b = is_vol_relative(&path);\n+                    assert!(b == vol, \"is_vol_relative('{}'): expected {:?}, found {:?}\",\n                             path.as_str().unwrap(), vol, b);\n-                    let b = path.is_cwd_relative();\n-                    assert!(b == cwd, \"Path '{}'.is_cwd_relative(): expected {:?}, found {:?}\",\n+                    let b = is_cwd_relative(&path);\n+                    assert!(b == cwd, \"is_cwd_relative('{}'): expected {:?}, found {:?}\",\n                             path.as_str().unwrap(), cwd, b);\n                     let b = path.is_relative();\n                     assert!(b == rel, \"Path '{}'.is_relativf(): expected {:?}, found {:?}\",\n@@ -2614,54 +2647,4 @@ mod tests {\n         t!(s: \".\", [b!(\".\")]);\n         // since this is really a wrapper around str_component_iter, those tests suffice\n     }\n-\n-    #[test]\n-    fn test_each_parent() {\n-        assert!(Path::new(\"/foo/bar\").each_parent(|_| true));\n-        assert!(!Path::new(\"/foo/bar\").each_parent(|_| false));\n-\n-        macro_rules! t(\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = Path::new($path);\n-                    let exp: &[&str] = $exp;\n-                    let mut comps = exp.iter().map(|&x|x);\n-                    do path.each_parent |p| {\n-                        let p = p.as_str();\n-                        assert!(p.is_some());\n-                        let e = comps.next();\n-                        assert!(e.is_some());\n-                        assert_eq!(p.unwrap(), e.unwrap());\n-                        true\n-                    };\n-                    assert!(comps.next().is_none());\n-                }\n-            )\n-        )\n-\n-        t!(s: \"\\\\foo\\\\bar\", [\"\\\\foo\\\\bar\", \"\\\\foo\", \"\\\\\"]);\n-        t!(s: \"\\\\foo\\\\bar\\\\baz\", [\"\\\\foo\\\\bar\\\\baz\", \"\\\\foo\\\\bar\", \"\\\\foo\", \"\\\\\"]);\n-        t!(s: \"\\\\foo\", [\"\\\\foo\", \"\\\\\"]);\n-        t!(s: \"\\\\\", [\"\\\\\"]);\n-        t!(s: \"foo\\\\bar\\\\baz\", [\"foo\\\\bar\\\\baz\", \"foo\\\\bar\", \"foo\", \".\"]);\n-        t!(s: \"foo\\\\bar\", [\"foo\\\\bar\", \"foo\", \".\"]);\n-        t!(s: \"foo\", [\"foo\", \".\"]);\n-        t!(s: \".\", [\".\"]);\n-        t!(s: \"..\", [\"..\"]);\n-        t!(s: \"..\\\\..\\\\foo\", [\"..\\\\..\\\\foo\", \"..\\\\..\"]);\n-        t!(s: \"C:\\\\a\\\\b\", [\"C:\\\\a\\\\b\", \"C:\\\\a\", \"C:\\\\\"]);\n-        t!(s: \"C:\\\\\", [\"C:\\\\\"]);\n-        t!(s: \"C:a\\\\b\", [\"C:a\\\\b\", \"C:a\", \"C:\"]);\n-        t!(s: \"C:\", [\"C:\"]);\n-        t!(s: \"C:..\\\\..\\\\a\", [\"C:..\\\\..\\\\a\", \"C:..\\\\..\"]);\n-        t!(s: \"C:..\", [\"C:..\"]);\n-        t!(s: \"\\\\\\\\a\\\\b\\\\c\", [\"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\"]);\n-        t!(s: \"\\\\\\\\a\\\\b\", [\"\\\\\\\\a\\\\b\"]);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", [\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\"]);\n-        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", [\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\"]);\n-        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", [\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\"]);\n-        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", [\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\"]);\n-        t!(s: \"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\\\\c/d\", [\"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\\\\c/d\", \"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\",\n-                                          \"\\\\\\\\?\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\a\\\\..\", \"\\\\\\\\?\\\\a\"]);\n-    }\n }"}, {"sha": "1c13beb790dd5f28a6be87f18557864ff4b6cc9f", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -147,7 +147,7 @@ fn res_rel_file(cx: @ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {\n     if !arg.is_absolute() {\n         let mut cu = Path::new(cx.codemap().span_to_filename(sp));\n         cu.pop();\n-        cu.push_path(arg);\n+        cu.push(arg);\n         cu\n     } else {\n         arg.clone()"}, {"sha": "c776e5bfd38fb4e6ad5c76421e82a175a5bf0622", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -3996,7 +3996,7 @@ impl Parser {\n         prefix.pop();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path::new(\".\").join_many(*mod_path_stack);\n-        let dir_path = prefix.join_path(&mod_path);\n+        let dir_path = prefix.join(&mod_path);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n                 outer_attrs, \"path\") {\n             Some(d) => dir_path.join(d),"}, {"sha": "acb2dde99adf6a0f042cf3180027870ad79502b7", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab7eb20dff32294c65fa28cece552481c40cf0b/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=bab7eb20dff32294c65fa28cece552481c40cf0b", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n     }\n \n     fn abs_path(path: &str) -> Path {\n-        os::getcwd().join_path(&Path::new(path))\n+        os::getcwd().join(&Path::new(path))\n     }\n \n     fn glob_vec(pattern: &str) -> ~[Path] {"}]}