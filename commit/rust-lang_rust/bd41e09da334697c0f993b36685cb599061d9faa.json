{"sha": "bd41e09da334697c0f993b36685cb599061d9faa", "node_id": "C_kwDOAAsO6NoAKGJkNDFlMDlkYTMzNDY5N2MwZjk5M2IzNjY4NWNiNTk5MDYxZDlmYWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-18T19:53:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-18T19:53:05Z"}, "message": "Auto merge of #89124 - cjgillot:owner-info, r=michaelwoerister\n\nIndex and hash HIR as part of lowering\n\nPart of https://github.com/rust-lang/rust/pull/88186\n~Based on https://github.com/rust-lang/rust/pull/88880 (see merge commit).~\n\nOnce HIR is lowered, it is later indexed by the `index_hir` query and hashed for `crate_hash`. This PR moves those post-processing steps to lowering itself. As a side objective, the HIR crate data structure is refactored as an `IndexVec<LocalDefId, Option<OwnerInfo<'hir>>>` where `OwnerInfo` stores all the relevant information for an HIR owner.\n\nr? `@michaelwoerister`\ncc `@petrochenkov`", "tree": {"sha": "769f410664dda01f42297c0adf9fbd5dc7f1ace2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769f410664dda01f42297c0adf9fbd5dc7f1ace2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd41e09da334697c0f993b36685cb599061d9faa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd41e09da334697c0f993b36685cb599061d9faa", "html_url": "https://github.com/rust-lang/rust/commit/bd41e09da334697c0f993b36685cb599061d9faa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd41e09da334697c0f993b36685cb599061d9faa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dab47dcd8267b8769421b46532414ec36d625e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dab47dcd8267b8769421b46532414ec36d625e3", "html_url": "https://github.com/rust-lang/rust/commit/5dab47dcd8267b8769421b46532414ec36d625e3"}, {"sha": "1e2dbb5f4a80077cb4b036b6f4ff96c96ad89805", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2dbb5f4a80077cb4b036b6f4ff96c96ad89805", "html_url": "https://github.com/rust-lang/rust/commit/1e2dbb5f4a80077cb4b036b6f4ff96c96ad89805"}], "stats": {"total": 1141, "additions": 547, "deletions": 594}, "files": [{"sha": "6bd09931aecbfb6b30448b7af7d26c854fd75eb0", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -3568,6 +3568,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4102,6 +4103,7 @@ dependencies = [\n  \"polonius-engine\",\n  \"rand 0.8.4\",\n  \"rand_xoshiro 0.6.0\",\n+ \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n@@ -4346,6 +4348,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n+ \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec\","}, {"sha": "7989af24d9986107290d3fa9b6ad0d75adb73a7d", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -14,6 +14,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "22f93f5078817cbcec8856c57f92bced0a148349", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -252,9 +252,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                     // Merge attributes into the inner expression.\n                     if !e.attrs.is_empty() {\n-                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        let old_attrs =\n+                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n                         self.attrs.insert(\n-                            ex.hir_id,\n+                            ex.hir_id.local_id,\n                             &*self.arena.alloc_from_iter(\n                                 e.attrs\n                                     .iter()"}, {"sha": "dc2b1a730fbd6bc2625fbb1296fabd0ad468fb07", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "renamed", "additions": 63, "deletions": 130, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,44 +1,33 @@\n-use crate::arena::Arena;\n-use crate::hir::map::Map;\n-use crate::hir::{IndexedHir, OwnerNodes, ParentedNode};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n \n use std::iter::repeat;\n+use tracing::debug;\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n-    arena: &'hir Arena<'hir>,\n-\n-    /// The crate\n-    krate: &'hir Crate<'hir>,\n-\n     /// Source map\n     source_map: &'a SourceMap,\n+    bodies: &'a IndexVec<ItemLocalId, Option<&'hir Body<'hir>>>,\n \n-    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n-    parenting: FxHashMap<LocalDefId, HirId>,\n+    /// Outputs\n+    nodes: IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>,\n+    parenting: FxHashMap<LocalDefId, ItemLocalId>,\n \n     /// The parent of this node\n-    parent_node: hir::HirId,\n+    parent_node: hir::ItemLocalId,\n \n-    current_dep_node_owner: LocalDefId,\n+    owner: LocalDefId,\n \n     definitions: &'a definitions::Definitions,\n-\n-    hcx: StableHashingContext<'a>,\n }\n \n fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V) {\n@@ -51,137 +40,82 @@ fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V\n     map[k] = Some(v);\n }\n \n-fn hash_body(\n-    hcx: &mut StableHashingContext<'_>,\n-    item_like: impl for<'a> HashStable<StableHashingContext<'a>>,\n-) -> Fingerprint {\n-    let mut stable_hasher = StableHasher::new();\n-    hcx.while_hashing_hir_bodies(true, |hcx| {\n-        item_like.hash_stable(hcx, &mut stable_hasher);\n-    });\n-    stable_hasher.finish()\n+pub(super) fn index_hir<'hir>(\n+    sess: &Session,\n+    definitions: &definitions::Definitions,\n+    item: hir::OwnerNode<'hir>,\n+    bodies: &IndexVec<ItemLocalId, Option<&'hir Body<'hir>>>,\n+) -> (IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>, FxHashMap<LocalDefId, ItemLocalId>) {\n+    let mut nodes = IndexVec::new();\n+    // This node's parent should never be accessed: the owner's parent is computed by the\n+    // hir_owner_parent query.  Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n+    // used.\n+    nodes.push(Some(ParentedNode { parent: ItemLocalId::INVALID, node: item.into() }));\n+    let mut collector = NodeCollector {\n+        source_map: sess.source_map(),\n+        definitions,\n+        owner: item.def_id(),\n+        parent_node: ItemLocalId::new(0),\n+        nodes,\n+        bodies,\n+        parenting: FxHashMap::default(),\n+    };\n+\n+    match item {\n+        OwnerNode::Crate(citem) => collector.visit_mod(&citem, citem.inner, hir::CRATE_HIR_ID),\n+        OwnerNode::Item(item) => collector.visit_item(item),\n+        OwnerNode::TraitItem(item) => collector.visit_trait_item(item),\n+        OwnerNode::ImplItem(item) => collector.visit_impl_item(item),\n+        OwnerNode::ForeignItem(item) => collector.visit_foreign_item(item),\n+    };\n+\n+    (collector.nodes, collector.parenting)\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n-    pub(super) fn root(\n-        sess: &'a Session,\n-        arena: &'hir Arena<'hir>,\n-        krate: &'hir Crate<'hir>,\n-        definitions: &'a definitions::Definitions,\n-        hcx: StableHashingContext<'a>,\n-    ) -> NodeCollector<'a, 'hir> {\n-        let mut collector = NodeCollector {\n-            arena,\n-            krate,\n-            source_map: sess.source_map(),\n-            parent_node: hir::CRATE_HIR_ID,\n-            current_dep_node_owner: CRATE_DEF_ID,\n-            definitions,\n-            hcx,\n-            map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n-            parenting: FxHashMap::default(),\n-        };\n-        collector.insert_owner(CRATE_DEF_ID, OwnerNode::Crate(krate.module()));\n-\n-        collector\n-    }\n-\n-    pub(super) fn finalize_and_compute_crate_hash(mut self) -> IndexedHir<'hir> {\n-        // Insert bodies into the map\n-        for (id, body) in self.krate.bodies.iter() {\n-            let bodies = &mut self.map[id.hir_id.owner].as_mut().unwrap().bodies;\n-            assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n-        }\n-        IndexedHir { map: self.map, parenting: self.parenting }\n-    }\n-\n-    fn insert_owner(&mut self, owner: LocalDefId, node: OwnerNode<'hir>) {\n-        let hash = hash_body(&mut self.hcx, node);\n-\n-        let mut nodes = IndexVec::new();\n-        nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: node.into() }));\n-\n-        debug_assert!(self.map[owner].is_none());\n-        self.map[owner] =\n-            Some(self.arena.alloc(OwnerNodes { hash, nodes, bodies: FxHashMap::default() }));\n-    }\n-\n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n-        debug_assert_eq!(self.current_dep_node_owner, hir_id.owner);\n+        debug_assert_eq!(self.owner, hir_id.owner);\n         debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            if hir_id.owner != self.current_dep_node_owner {\n-                let node_str = match self.definitions.opt_hir_id_to_local_def_id(hir_id) {\n-                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate_verbose(),\n-                    None => format!(\"{:?}\", node),\n-                };\n-\n-                span_bug!(\n-                    span,\n-                    \"inconsistent DepNode at `{:?}` for `{}`: \\\n+            if hir_id.owner != self.owner {\n+                panic!(\n+                    \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n-                    node_str,\n-                    self.definitions\n-                        .def_path(self.current_dep_node_owner)\n-                        .to_string_no_crate_verbose(),\n-                    self.current_dep_node_owner,\n+                    node,\n+                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.owner,\n                     self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n         }\n \n-        let nodes = self.map[hir_id.owner].as_mut().unwrap();\n-\n-        debug_assert_eq!(self.parent_node.owner, self.current_dep_node_owner);\n         insert_vec_map(\n-            &mut nodes.nodes,\n+            &mut self.nodes,\n             hir_id.local_id,\n-            ParentedNode { parent: self.parent_node.local_id, node: node },\n+            ParentedNode { parent: self.parent_node, node: node },\n         );\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_node_id: HirId, f: F) {\n+        debug_assert_eq!(parent_node_id.owner, self.owner);\n         let parent_node = self.parent_node;\n-        self.parent_node = parent_node_id;\n+        self.parent_node = parent_node_id.local_id;\n         f(self);\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner(&mut self, dep_node_owner: LocalDefId, f: impl FnOnce(&mut Self)) {\n-        let prev_owner = self.current_dep_node_owner;\n-        let prev_parent = self.parent_node;\n-\n-        self.current_dep_node_owner = dep_node_owner;\n-        self.parent_node = HirId::make_owner(dep_node_owner);\n-        f(self);\n-        self.current_dep_node_owner = prev_owner;\n-        self.parent_node = prev_parent;\n-    }\n-\n     fn insert_nested(&mut self, item: LocalDefId) {\n-        #[cfg(debug_assertions)]\n-        {\n-            let dk_parent = self.definitions.def_key(item).parent.unwrap();\n-            let dk_parent = LocalDefId { local_def_index: dk_parent };\n-            let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n-            debug_assert_eq!(\n-                dk_parent.owner, self.parent_node.owner,\n-                \"Different parents for {:?}\",\n-                item\n-            )\n-        }\n-\n-        assert_eq!(self.parenting.insert(item, self.parent_node), None);\n+        self.parenting.insert(item, self.parent_node);\n     }\n }\n \n impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n-    type Map = Map<'hir>;\n+    type Map = !;\n \n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n@@ -194,26 +128,24 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n         self.insert_nested(item.def_id);\n-        self.visit_item(self.krate.item(item));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n         self.insert_nested(item_id.def_id);\n-        self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n         self.insert_nested(item_id.def_id);\n-        self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n         self.insert_nested(foreign_id.def_id);\n-        self.visit_foreign_item(self.krate.foreign_item(foreign_id));\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        self.visit_body(self.krate.body(id));\n+        debug_assert_eq!(id.hir_id.owner, self.owner);\n+        let body = self.bodies[id.hir_id.local_id].unwrap();\n+        self.visit_body(body);\n     }\n \n     fn visit_param(&mut self, param: &'hir Param<'hir>) {\n@@ -226,8 +158,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.insert_owner(i.def_id, OwnerNode::Item(i));\n-        self.with_dep_node_owner(i.def_id, |this| {\n+        debug_assert_eq!(i.def_id, self.owner);\n+        self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n@@ -239,8 +171,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        self.insert_owner(fi.def_id, OwnerNode::ForeignItem(fi));\n-        self.with_dep_node_owner(fi.def_id, |this| {\n+        debug_assert_eq!(fi.def_id, self.owner);\n+        self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n     }\n@@ -257,15 +189,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        self.insert_owner(ti.def_id, OwnerNode::TraitItem(ti));\n-        self.with_dep_node_owner(ti.def_id, |this| {\n+        debug_assert_eq!(ti.def_id, self.owner);\n+        self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        self.insert_owner(ii.def_id, OwnerNode::ImplItem(ii));\n-        self.with_dep_node_owner(ii.def_id, |this| {\n+        debug_assert_eq!(ii.def_id, self.owner);\n+        self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });\n     }\n@@ -353,7 +285,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         s: Span,\n         id: HirId,\n     ) {\n-        assert_eq!(self.parent_node, id);\n+        assert_eq!(self.owner, id.owner);\n+        assert_eq!(self.parent_node, id.local_id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n ", "previous_filename": "compiler/rustc_middle/src/hir/map/collector.rs"}, {"sha": "e8747f2c5f8f9d06bd03a49ca35c587254b1287d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -10,6 +10,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n+use rustc_index::vec::Idx;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -99,11 +100,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.owners[parent_hir_id].unwrap().expect_item().kind {\n-            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-            _ => &[],\n-        };\n+        let parent_generics =\n+            match self.owners[parent_hir_id].as_ref().unwrap().node().expect_item().kind {\n+                hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n+                | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n+                _ => &[],\n+            };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n@@ -493,7 +495,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n+                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n \n                         let item = hir::Item {\n@@ -568,7 +570,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n+                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n \n                         let item = hir::Item {\n@@ -971,7 +973,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::BodyId {\n         let body = hir::Body { generator_kind: self.generator_kind, params, value };\n         let id = body.id();\n-        self.bodies.insert(id, body);\n+        debug_assert_eq!(id.hir_id.owner, self.current_hir_id_owner);\n+        self.bodies.ensure_contains_elem(id.hir_id.local_id, || None);\n+        self.bodies[id.hir_id.local_id] = Some(self.arena.alloc(body));\n         id\n     }\n \n@@ -1124,7 +1128,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id.local_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n                     hir_id: parameter.hir_id,"}, {"sha": "92e08da7a97abdf9a23ecfa00ad8b6641ba85e5d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 123, "deletions": 73, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -33,16 +33,18 @@\n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(iter_zip)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n \n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n@@ -52,13 +54,14 @@ use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, InferKind, ParamName};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_session::lint::builtin::BARE_TRAIT_OBJECTS;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::source_map::{respan, CachingSourceMapView, DesugaringKind};\n+use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -76,6 +79,7 @@ macro_rules! arena_vec {\n mod asm;\n mod block;\n mod expr;\n+mod index;\n mod item;\n mod pat;\n mod path;\n@@ -97,13 +101,14 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    owners: IndexVec<LocalDefId, Option<hir::OwnerNode<'hir>>>,\n-    bodies: BTreeMap<hir::BodyId, hir::Body<'hir>>,\n+    owners: IndexVec<LocalDefId, Option<hir::OwnerInfo<'hir>>>,\n+    /// Bodies inside the owner being lowered.\n+    bodies: IndexVec<hir::ItemLocalId, Option<&'hir hir::Body<'hir>>>,\n+    /// Attributes inside the owner being lowered.\n+    attrs: BTreeMap<hir::ItemLocalId, &'hir [Attribute]>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n-    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n-\n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n     task_context: Option<hir::HirId>,\n@@ -152,6 +157,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n     item_local_id_counter: hir::ItemLocalId,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n+    /// NodeIds that are lowered inside the current HIR owner.\n+    local_node_ids: Vec<NodeId>,\n+\n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n }\n@@ -178,11 +186,13 @@ pub trait ResolverAstLowering {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n+\n     fn lint_buffer(&mut self) -> &mut LintBuffer;\n \n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn take_trait_map(&mut self) -> NodeMap<Vec<hir::TraitCandidate>>;\n+    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<hir::TraitCandidate>>;\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n \n@@ -200,37 +210,6 @@ pub trait ResolverAstLowering {\n     ) -> LocalDefId;\n }\n \n-struct LoweringHasher<'a> {\n-    source_map: CachingSourceMapView<'a>,\n-    resolver: &'a dyn ResolverAstLowering,\n-}\n-\n-impl<'a> rustc_span::HashStableContext for LoweringHasher<'a> {\n-    #[inline]\n-    fn hash_spans(&self) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn def_span(&self, id: LocalDefId) -> Span {\n-        self.resolver.def_span(id)\n-    }\n-\n-    #[inline]\n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        self.resolver.def_path_hash(def_id)\n-    }\n-\n-    #[inline]\n-    fn span_data_to_lines_and_cols(\n-        &mut self,\n-        span: &rustc_span::SpanData,\n-    ) -> Option<(Lrc<rustc_span::SourceFile>, usize, rustc_span::BytePos, usize, rustc_span::BytePos)>\n-    {\n-        self.source_map.span_data_to_lines_and_cols(span)\n-    }\n-}\n-\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -314,13 +293,14 @@ pub fn lower_crate<'a, 'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n+    let owners = IndexVec::from_fn_n(|_| None, resolver.definitions().def_index_count());\n     LoweringContext {\n         sess,\n         resolver,\n         nt_to_tokenstream,\n         arena,\n-        owners: IndexVec::default(),\n-        bodies: BTreeMap::new(),\n+        owners,\n+        bodies: IndexVec::new(),\n         attrs: BTreeMap::default(),\n         catch_scope: None,\n         loop_scope: None,\n@@ -331,6 +311,7 @@ pub fn lower_crate<'a, 'hir>(\n         current_hir_id_owner: CRATE_DEF_ID,\n         item_local_id_counter: hir::ItemLocalId::new(0),\n         node_id_to_hir_id: IndexVec::new(),\n+        local_node_ids: Vec::new(),\n         generator_kind: None,\n         task_context: None,\n         current_item: None,\n@@ -420,13 +401,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir::OwnerNode::Crate(lctx.arena.alloc(module))\n         });\n \n-        let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n-        for (k, v) in self.resolver.take_trait_map().into_iter() {\n-            if let Some(Some(hir_id)) = self.node_id_to_hir_id.get(k) {\n-                let map = trait_map.entry(hir_id.owner).or_default();\n-                map.insert(hir_id.local_id, v.into_boxed_slice());\n-            }\n-        }\n+        let hir_hash = self.compute_hir_hash();\n \n         let mut def_id_to_hir_id = IndexVec::default();\n \n@@ -441,24 +416,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n-        #[cfg(debug_assertions)]\n-        for (&id, attrs) in self.attrs.iter() {\n-            // Verify that we do not store empty slices in the map.\n-            if attrs.is_empty() {\n-                panic!(\"Stored empty attributes for {:?}\", id);\n-            }\n-        }\n-\n-        let krate =\n-            hir::Crate { owners: self.owners, bodies: self.bodies, trait_map, attrs: self.attrs };\n+        let krate = hir::Crate { owners: self.owners, hir_hash };\n         self.arena.alloc(krate)\n     }\n \n-    fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n-        LoweringHasher {\n-            source_map: CachingSourceMapView::new(self.sess.source_map()),\n-            resolver: self.resolver,\n-        }\n+    /// Compute the hash for the HIR of the full crate.\n+    /// This hash will then be part of the crate_hash which is stored in the metadata.\n+    fn compute_hir_hash(&mut self) -> Fingerprint {\n+        let definitions = self.resolver.definitions();\n+        let mut hir_body_nodes: Vec<_> = self\n+            .owners\n+            .iter_enumerated()\n+            .filter_map(|(def_id, info)| {\n+                let info = info.as_ref()?;\n+                let def_path_hash = definitions.def_path_hash(def_id);\n+                Some((def_path_hash, info))\n+            })\n+            .collect();\n+        hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n+\n+        let mut stable_hasher = StableHasher::new();\n+        let mut hcx = self.resolver.create_stable_hashing_context();\n+        hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n+        stable_hasher.finish()\n     }\n \n     fn with_hir_id_owner(\n@@ -468,25 +448,91 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> LocalDefId {\n         let def_id = self.resolver.local_def_id(owner);\n \n-        // Always allocate the first `HirId` for the owner itself.\n-        let _old = self.node_id_to_hir_id.insert(owner, hir::HirId::make_owner(def_id));\n-        debug_assert_eq!(_old, None);\n-\n+        let current_attrs = std::mem::take(&mut self.attrs);\n+        let current_bodies = std::mem::take(&mut self.bodies);\n+        let current_node_ids = std::mem::take(&mut self.local_node_ids);\n         let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n \n+        // Always allocate the first `HirId` for the owner itself.\n+        let _old = self.node_id_to_hir_id.insert(owner, hir::HirId::make_owner(def_id));\n+        debug_assert_eq!(_old, None);\n+        self.local_node_ids.push(owner);\n+\n         let item = f(self);\n+        debug_assert_eq!(def_id, item.def_id());\n+        let info = self.make_owner_info(item);\n \n+        self.attrs = current_attrs;\n+        self.bodies = current_bodies;\n+        self.local_node_ids = current_node_ids;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n-        let _old = self.owners.insert(def_id, item);\n+        let _old = self.owners.insert(def_id, info);\n         debug_assert!(_old.is_none());\n \n         def_id\n     }\n \n+    fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> hir::OwnerInfo<'hir> {\n+        let attrs = std::mem::take(&mut self.attrs);\n+        let bodies = std::mem::take(&mut self.bodies);\n+        let local_node_ids = std::mem::take(&mut self.local_node_ids);\n+        let trait_map = local_node_ids\n+            .into_iter()\n+            .filter_map(|node_id| {\n+                let hir_id = self.node_id_to_hir_id[node_id]?;\n+                let traits = self.resolver.take_trait_map(node_id)?;\n+                Some((hir_id.local_id, traits.into_boxed_slice()))\n+            })\n+            .collect();\n+\n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n+\n+        let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n+        let (nodes, parenting) =\n+            index::index_hir(self.sess, self.resolver.definitions(), node, &bodies);\n+        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n+        let attrs = {\n+            let mut hcx = self.resolver.create_stable_hashing_context();\n+            let mut stable_hasher = StableHasher::new();\n+            attrs.hash_stable(&mut hcx, &mut stable_hasher);\n+            let hash = stable_hasher.finish();\n+            hir::AttributeMap { map: attrs, hash }\n+        };\n+\n+        hir::OwnerInfo { nodes, parenting, attrs, trait_map }\n+    }\n+\n+    /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n+    /// queries which depend on the full HIR tree and those which only depend on the item signature.\n+    fn hash_owner(\n+        &mut self,\n+        node: hir::OwnerNode<'hir>,\n+        bodies: &IndexVec<hir::ItemLocalId, Option<&'hir hir::Body<'hir>>>,\n+    ) -> (Fingerprint, Fingerprint) {\n+        let mut hcx = self.resolver.create_stable_hashing_context();\n+        let mut stable_hasher = StableHasher::new();\n+        hcx.with_hir_bodies(true, node.def_id(), bodies, |hcx| {\n+            node.hash_stable(hcx, &mut stable_hasher)\n+        });\n+        let hash_including_bodies = stable_hasher.finish();\n+        let mut stable_hasher = StableHasher::new();\n+        hcx.with_hir_bodies(false, node.def_id(), bodies, |hcx| {\n+            node.hash_stable(hcx, &mut stable_hasher)\n+        });\n+        let hash_without_bodies = stable_hasher.finish();\n+        (hash_including_bodies, hash_without_bodies)\n+    }\n+\n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n     /// the `LoweringContext`'s `NodeId => HirId` map.\n     /// Take care not to call this method if the resulting `HirId` is then not\n@@ -501,6 +547,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let owner = self.current_hir_id_owner;\n             let local_id = self.item_local_id_counter;\n             self.item_local_id_counter.increment_by(1);\n+            self.local_node_ids.push(ast_node_id);\n             hir::HirId { owner, local_id }\n         })\n     }\n@@ -547,7 +594,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             allow_internal_unstable,\n             reason,\n             self.sess.edition(),\n-            self.create_stable_hashing_context(),\n+            self.resolver.create_stable_hashing_context(),\n         )\n     }\n \n@@ -791,9 +838,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         if attrs.is_empty() {\n             None\n         } else {\n+            debug_assert_eq!(id.owner, self.current_hir_id_owner);\n             let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n             debug_assert!(!ret.is_empty());\n-            self.attrs.insert(id, ret);\n+            self.attrs.insert(id.local_id, ret);\n             Some(ret)\n         }\n     }\n@@ -819,9 +867,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n-        if let Some(&a) = self.attrs.get(&target_id) {\n+        debug_assert_eq!(id.owner, self.current_hir_id_owner);\n+        debug_assert_eq!(target_id.owner, self.current_hir_id_owner);\n+        if let Some(&a) = self.attrs.get(&target_id.local_id) {\n             debug_assert!(!a.is_empty());\n-            self.attrs.insert(id, a);\n+            self.attrs.insert(id.local_id, a);\n         }\n     }\n \n@@ -2066,7 +2116,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let hir_id = self.next_id();\n         if let Some(a) = attrs {\n             debug_assert!(!a.is_empty());\n-            self.attrs.insert(hir_id, a);\n+            self.attrs.insert(hir_id.local_id, a);\n         }\n         let local = hir::Local { hir_id, init, pat, source, span: self.lower_span(span), ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))"}, {"sha": "2e9050dd672e171b17e3dc12acb055dbce881882", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -59,23 +59,23 @@ where\n }\n fn call_with_pp_support_hir<A, F>(ppmode: &PpHirMode, tcx: TyCtxt<'_>, f: F) -> A\n where\n-    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate<'_>) -> A,\n+    F: FnOnce(&dyn HirPrinterSupport<'_>, hir_map::Map<'_>) -> A,\n {\n     match *ppmode {\n         PpHirMode::Normal => {\n             let annotation = NoAnn { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().krate())\n+            f(&annotation, tcx.hir())\n         }\n \n         PpHirMode::Identified => {\n             let annotation = IdentifiedAnnotation { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().krate())\n+            f(&annotation, tcx.hir())\n         }\n         PpHirMode::Typed => {\n             abort_on_err(tcx.analysis(()), tcx.sess);\n \n             let annotation = TypedAnnotation { tcx, maybe_typeck_results: Cell::new(None) };\n-            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n+            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir()))\n         }\n     }\n }\n@@ -443,17 +443,27 @@ pub fn print_after_hir_lowering<'tcx>(\n             format!(\"{:#?}\", krate)\n         }\n \n-        Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n+        Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, hir_map| {\n             debug!(\"pretty printing HIR {:?}\", s);\n             let sess = annotation.sess();\n             let sm = sess.source_map();\n-            pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n+            let attrs = |id| hir_map.attrs(id);\n+            pprust_hir::print_crate(\n+                sm,\n+                hir_map.root_module(),\n+                src_name,\n+                src,\n+                &attrs,\n+                annotation.pp_ann(),\n+            )\n         }),\n \n-        HirTree => call_with_pp_support_hir(&PpHirMode::Normal, tcx, move |_annotation, krate| {\n-            debug!(\"pretty printing HIR tree\");\n-            format!(\"{:#?}\", krate)\n-        }),\n+        HirTree => {\n+            call_with_pp_support_hir(&PpHirMode::Normal, tcx, move |_annotation, hir_map| {\n+                debug!(\"pretty printing HIR tree\");\n+                format!(\"{:#?}\", hir_map.krate())\n+            })\n+        }\n \n         _ => unreachable!(),\n     };"}, {"sha": "1a34dd0442855ffdf2dc06b472c20d3f859c8068", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -19,6 +19,7 @@ macro_rules! arena_types {\n             [] attribute: rustc_ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,\n             [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n+            [] body: rustc_hir::Body<$tcx>,\n             [] generic_arg: rustc_hir::GenericArg<$tcx>,\n             [] generic_args: rustc_hir::GenericArgs<$tcx>,\n             [] generic_bound: rustc_hir::GenericBound<$tcx>,\n@@ -36,6 +37,7 @@ macro_rules! arena_types {\n             [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n             [few] mod_: rustc_hir::Mod<$tcx>,\n+            [] owner_info: rustc_hir::OwnerInfo<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,\n             [] pat: rustc_hir::Pat<$tcx>,\n             [] path: rustc_hir::Path<$tcx>,"}, {"sha": "b5c1e31c258ef91a4dba2e8dd3a4ea31280df8a2", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 70, "deletions": 34, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,5 +1,5 @@\n use crate::def::{CtorKind, DefKind, Res};\n-use crate::def_id::{DefId, CRATE_DEF_ID};\n+use crate::def_id::DefId;\n crate use crate::hir_id::{HirId, ItemLocalId};\n use crate::LangItem;\n \n@@ -9,6 +9,7 @@ use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, TraitObject\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n@@ -662,49 +663,84 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-/// The top-level data structure that stores the entire contents of\n-/// the crate currently being compiled.\n+/// HIR node coupled with its parent's id in the same HIR owner.\n ///\n-/// For more details, see the [rustc dev guide].\n-///\n-/// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n-#[derive(Debug)]\n-pub struct Crate<'hir> {\n-    pub owners: IndexVec<LocalDefId, Option<OwnerNode<'hir>>>,\n-    pub bodies: BTreeMap<BodyId, Body<'hir>>,\n-\n-    /// Map indicating what traits are in scope for places where this\n-    /// is relevant; generated by resolve.\n-    pub trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Box<[TraitCandidate]>>>,\n-\n-    /// Collected attributes from HIR nodes.\n-    pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n+/// The parent is trash when the node is a HIR owner.\n+#[derive(Clone, Debug)]\n+pub struct ParentedNode<'tcx> {\n+    pub parent: ItemLocalId,\n+    pub node: Node<'tcx>,\n }\n \n-impl Crate<'hir> {\n-    pub fn module(&self) -> &'hir Mod<'hir> {\n-        if let Some(OwnerNode::Crate(m)) = self.owners[CRATE_DEF_ID] { m } else { panic!() }\n-    }\n+/// Attributes owned by a HIR owner.\n+#[derive(Debug)]\n+pub struct AttributeMap<'tcx> {\n+    pub map: BTreeMap<ItemLocalId, &'tcx [Attribute]>,\n+    pub hash: Fingerprint,\n+}\n \n-    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_item()\n-    }\n+impl<'tcx> AttributeMap<'tcx> {\n+    pub const EMPTY: &'static AttributeMap<'static> =\n+        &AttributeMap { map: BTreeMap::new(), hash: Fingerprint::ZERO };\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_trait_item()\n+    #[inline]\n+    pub fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n+        self.map.get(&id).copied().unwrap_or(&[])\n     }\n+}\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_impl_item()\n-    }\n+/// Map of all HIR nodes inside the current owner.\n+/// These nodes are mapped by `ItemLocalId` alongside the index of their parent node.\n+/// The HIR tree, including bodies, is pre-hashed.\n+#[derive(Debug)]\n+pub struct OwnerNodes<'tcx> {\n+    /// Pre-computed hash of the full HIR.\n+    pub hash_including_bodies: Fingerprint,\n+    /// Pre-computed hash of the item signature, sithout recursing into the body.\n+    pub hash_without_bodies: Fingerprint,\n+    /// Full HIR for the current owner.\n+    // The zeroth node's parent should never be accessed: the owner's parent is computed by the\n+    // hir_owner_parent query.  It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n+    // used.\n+    pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n+    /// Content of local bodies.\n+    pub bodies: IndexVec<ItemLocalId, Option<&'tcx Body<'tcx>>>,\n+}\n+\n+/// Full information resulting from lowering an AST node.\n+#[derive(Debug, HashStable_Generic)]\n+pub struct OwnerInfo<'hir> {\n+    /// Contents of the HIR.\n+    pub nodes: OwnerNodes<'hir>,\n+    /// Map from each nested owner to its parent's local id.\n+    pub parenting: FxHashMap<LocalDefId, ItemLocalId>,\n+    /// Collected attributes of the HIR nodes.\n+    pub attrs: AttributeMap<'hir>,\n+    /// Map indicating what traits are in scope for places where this\n+    /// is relevant; generated by resolve.\n+    pub trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n+}\n \n-    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.owners[id.def_id].as_ref().unwrap().expect_foreign_item()\n+impl<'tcx> OwnerInfo<'tcx> {\n+    #[inline]\n+    pub fn node(&self) -> OwnerNode<'tcx> {\n+        use rustc_index::vec::Idx;\n+        let node = self.nodes.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n+        node\n     }\n+}\n \n-    pub fn body(&self, id: BodyId) -> &Body<'hir> {\n-        &self.bodies[&id]\n-    }\n+/// The top-level data structure that stores the entire contents of\n+/// the crate currently being compiled.\n+///\n+/// For more details, see the [rustc dev guide].\n+///\n+/// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n+#[derive(Debug)]\n+pub struct Crate<'hir> {\n+    pub owners: IndexVec<LocalDefId, Option<OwnerInfo<'hir>>>,\n+    pub hir_hash: Fingerprint,\n }\n \n /// A block of statements `{ .. }`, which may have a label (in this case the"}, {"sha": "877871f7c3d80b69655319fe65775e97a7c79f20", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -56,6 +56,10 @@ rustc_index::newtype_index! {\n     pub struct ItemLocalId { .. }\n }\n rustc_data_structures::impl_stable_hash_via_hash!(ItemLocalId);\n+impl ItemLocalId {\n+    /// Signal local id which should never be used.\n+    pub const INVALID: ItemLocalId = ItemLocalId::MAX;\n+}\n \n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_INDEX`.\n pub const CRATE_HIR_ID: HirId = HirId {"}, {"sha": "3e58af1f167aa628ec650a2a4d6eb546dccec9ff", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -130,6 +130,28 @@ pub trait Map<'hir> {\n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir>;\n }\n \n+// Used when no map is actually available, forcing manual implementation of nested visitors.\n+impl Map<'hir> for ! {\n+    fn find(&self, _: HirId) -> Option<Node<'hir>> {\n+        unreachable!()\n+    }\n+    fn body(&self, _: BodyId) -> &'hir Body<'hir> {\n+        unreachable!()\n+    }\n+    fn item(&self, _: ItemId) -> &'hir Item<'hir> {\n+        unreachable!()\n+    }\n+    fn trait_item(&self, _: TraitItemId) -> &'hir TraitItem<'hir> {\n+        unreachable!()\n+    }\n+    fn impl_item(&self, _: ImplItemId) -> &'hir ImplItem<'hir> {\n+        unreachable!()\n+    }\n+    fn foreign_item(&self, _: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+        unreachable!()\n+    }\n+}\n+\n /// An erased version of `Map<'hir>`, using dynamic dispatch.\n /// NOTE: This type is effectively only usable with `NestedVisitorMap::None`.\n pub struct ErasedMap<'hir>(&'hir dyn Map<'hir>);"}, {"sha": "93224d388c00fe6053353b6e7a78bccbc6eaec68", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -2,10 +2,12 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n+#![feature(const_btree_new)]\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "6e7b765a0c4413b62242640973b3d2681c669c53", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, TraitItem,\n-    TraitItemId, Ty, VisibilityKind,\n+    AttributeMap, BodyId, Crate, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item,\n+    ItemId, Mod, OwnerNodes, TraitCandidate, TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::DefPathHash;\n@@ -21,6 +21,7 @@ pub trait HashStableContext:\n     fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n     fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n     fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F);\n+    fn hash_hir_trait_candidate(&mut self, _: &TraitCandidate, hasher: &mut StableHasher);\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n@@ -209,3 +210,35 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n         });\n     }\n }\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        // We ignore the `nodes` and `bodies` fields since these refer to information included in\n+        // `hash` which is hashed in the collector and used for the crate hash.\n+        let OwnerNodes { hash_including_bodies, hash_without_bodies: _, nodes: _, bodies: _ } =\n+            *self;\n+        hash_including_bodies.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for AttributeMap<'tcx> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        // We ignore the `map` since it refers to information included in `hash` which is hashed in\n+        // the collector and used for the crate hash.\n+        let AttributeMap { hash, map: _ } = *self;\n+        hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Crate<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        let Crate { owners: _, hir_hash } = self;\n+        hir_hash.hash_stable(hcx, hasher)\n+    }\n+}\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitCandidate {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        hcx.hash_hir_trait_candidate(self, hasher)\n+    }\n+}"}, {"sha": "9c2927111a66c9f40df85bde1462725fa6bd524f", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -15,7 +15,6 @@ use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::collections::BTreeMap;\n use std::vec;\n \n pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n@@ -69,7 +68,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n-    attrs: &'a BTreeMap<hir::HirId, &'a [ast::Attribute]>,\n+    attrs: &'a dyn Fn(hir::HirId) -> &'a [ast::Attribute],\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n@@ -146,17 +145,18 @@ pub const INDENT_UNIT: usize = 4;\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(\n     sm: &'a SourceMap,\n-    krate: &hir::Crate<'_>,\n+    krate: &hir::Mod<'_>,\n     filename: FileName,\n     input: String,\n+    attrs: &'a dyn Fn(hir::HirId) -> &'a [ast::Attribute],\n     ann: &'a dyn PpAnn,\n ) -> String {\n-    let mut s = State::new_from_input(sm, filename, input, &krate.attrs, ann);\n+    let mut s = State::new_from_input(sm, filename, input, attrs, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.module(), s.attrs(hir::CRATE_HIR_ID));\n+    s.print_mod(krate, (*attrs)(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }\n@@ -166,7 +166,7 @@ impl<'a> State<'a> {\n         sm: &'a SourceMap,\n         filename: FileName,\n         input: String,\n-        attrs: &'a BTreeMap<hir::HirId, &[ast::Attribute]>,\n+        attrs: &'a dyn Fn(hir::HirId) -> &'a [ast::Attribute],\n         ann: &'a dyn PpAnn,\n     ) -> State<'a> {\n         State {\n@@ -178,16 +178,15 @@ impl<'a> State<'a> {\n     }\n \n     fn attrs(&self, id: hir::HirId) -> &'a [ast::Attribute] {\n-        self.attrs.get(&id).map_or(&[], |la| *la)\n+        (self.attrs)(id)\n     }\n }\n \n pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n where\n     F: FnOnce(&mut State<'_>),\n {\n-    let mut printer =\n-        State { s: pp::mk_printer(), comments: None, attrs: &BTreeMap::default(), ann };\n+    let mut printer = State { s: pp::mk_printer(), comments: None, attrs: &|_| &[], ann };\n     f(&mut printer);\n     printer.s.eof()\n }"}, {"sha": "daeccde6024e66340d8e741c5c419bc843d5daa8", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -12,6 +12,7 @@ bitflags = \"1.2.1\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n tracing = \"0.1\"\n+rustc-rayon = \"0.3.1\"\n rustc-rayon-core = \"0.3.1\"\n polonius-engine = \"0.13.0\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }"}, {"sha": "4a027cb7ebe05be3924a4548c2a5431b52921d14", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -92,12 +92,6 @@ macro_rules! arena_types {\n             [] tys: rustc_middle::ty::TyS<$tcx>,\n             [] predicates: rustc_middle::ty::PredicateInner<$tcx>,\n \n-            // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::IndexedHir<$tcx>,\n-            [few] hir_definitions: rustc_hir::definitions::Definitions,\n-            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n-            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n-\n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)"}, {"sha": "38bc01b9b53d88a12d73e91c4e747eca3b8d9bb5", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 72, "deletions": 65, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,6 +1,4 @@\n-use self::collector::NodeCollector;\n-\n-use crate::hir::{AttributeMap, IndexedHir, ModuleItems, Owner};\n+use crate::hir::{ModuleItems, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -23,7 +21,6 @@ use rustc_target::spec::abi::Abi;\n use std::collections::VecDeque;\n \n pub mod blocks;\n-mod collector;\n \n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n@@ -166,8 +163,8 @@ impl<'hir> Map<'hir> {\n \n     pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_ref()? {\n-            OwnerNode::Item(item) => Some(*item),\n+        krate.owners.iter().filter_map(|owner| match owner.as_ref()?.node() {\n+            OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n     }\n@@ -318,7 +315,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id).unwrap_or(CRATE_HIR_ID)\n+        self.find_parent_node(hir_id).unwrap()\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n@@ -381,7 +378,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies.get(&id.hir_id.local_id).unwrap()\n+        self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[id.hir_id.local_id].unwrap()\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -495,11 +492,41 @@ impl<'hir> Map<'hir> {\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        self.krate().bodies.keys().map(move |&body_id| self.body_owner_def_id(body_id))\n+        self.krate()\n+            .owners\n+            .iter_enumerated()\n+            .flat_map(move |(owner, owner_info)| {\n+                let bodies = &owner_info.as_ref()?.nodes.bodies;\n+                Some(bodies.iter_enumerated().filter_map(move |(local_id, body)| {\n+                    if body.is_none() {\n+                        return None;\n+                    }\n+                    let hir_id = HirId { owner, local_id };\n+                    let body_id = BodyId { hir_id };\n+                    Some(self.body_owner_def_id(body_id))\n+                }))\n+            })\n+            .flatten()\n     }\n \n     pub fn par_body_owners<F: Fn(LocalDefId) + Sync + Send>(self, f: F) {\n-        par_for_each_in(&self.krate().bodies, |(&body_id, _)| f(self.body_owner_def_id(body_id)));\n+        use rustc_data_structures::sync::{par_iter, ParallelIterator};\n+        #[cfg(parallel_compiler)]\n+        use rustc_rayon::iter::IndexedParallelIterator;\n+\n+        par_iter(&self.krate().owners.raw).enumerate().for_each(|(owner, owner_info)| {\n+            let owner = LocalDefId::new(owner);\n+            if let Some(owner_info) = owner_info {\n+                par_iter(&owner_info.nodes.bodies.raw).enumerate().for_each(|(local_id, body)| {\n+                    if body.is_some() {\n+                        let local_id = ItemLocalId::new(local_id);\n+                        let hir_id = HirId { owner, local_id };\n+                        let body_id = BodyId { hir_id };\n+                        f(self.body_owner_def_id(body_id))\n+                    }\n+                })\n+            }\n+        });\n     }\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n@@ -551,9 +578,14 @@ impl<'hir> Map<'hir> {\n     /// Walks the attributes in a crate.\n     pub fn walk_attributes(self, visitor: &mut impl Visitor<'hir>) {\n         let krate = self.krate();\n-        for (&id, attrs) in krate.attrs.iter() {\n-            for a in *attrs {\n-                visitor.visit_attribute(id, a)\n+        for (owner, info) in krate.owners.iter_enumerated() {\n+            if let Some(info) = info {\n+                for (&local_id, attrs) in info.attrs.map.iter() {\n+                    let id = HirId { owner, local_id };\n+                    for a in *attrs {\n+                        visitor.visit_attribute(id, a)\n+                    }\n+                }\n             }\n         }\n     }\n@@ -572,7 +604,7 @@ impl<'hir> Map<'hir> {\n     {\n         let krate = self.krate();\n         for owner in krate.owners.iter().filter_map(Option::as_ref) {\n-            match owner {\n+            match owner.node() {\n                 OwnerNode::Item(item) => visitor.visit_item(item),\n                 OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n                 OwnerNode::ImplItem(item) => visitor.visit_impl_item(item),\n@@ -588,7 +620,7 @@ impl<'hir> Map<'hir> {\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n         let krate = self.krate();\n-        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref() {\n+        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref().map(OwnerInfo::node) {\n             Some(OwnerNode::Item(item)) => visitor.visit_item(item),\n             Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n             Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n@@ -839,21 +871,21 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_item(&self, id: HirId) -> &'hir Item<'hir> {\n         match self.tcx.hir_owner(id.expect_owner()) {\n-            Some(Owner { node: OwnerNode::Item(item) }) => item,\n+            Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem<'hir> {\n         match self.tcx.hir_owner(id.expect_owner()) {\n-            Some(Owner { node: OwnerNode::ImplItem(item) }) => item,\n+            Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem<'hir> {\n         match self.tcx.hir_owner(id.expect_owner()) {\n-            Some(Owner { node: OwnerNode::TraitItem(item) }) => item,\n+            Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id)),\n         }\n     }\n@@ -867,7 +899,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id.expect_owner()) {\n-            Some(Owner { node: OwnerNode::ForeignItem(item) }) => item,\n+            Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id)),\n         }\n     }\n@@ -1032,42 +1064,10 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tcx> {\n-    let _prof_timer = tcx.sess.prof.generic_activity(\"build_hir_map\");\n-\n-    // We can access untracked state since we are an eval_always query.\n-    let hcx = tcx.create_stable_hashing_context();\n-    let mut collector = NodeCollector::root(\n-        tcx.sess,\n-        &**tcx.arena,\n-        tcx.untracked_crate,\n-        &tcx.untracked_resolutions.definitions,\n-        hcx,\n-    );\n-    let top_mod = tcx.untracked_crate.module();\n-    collector.visit_mod(top_mod, top_mod.inner, CRATE_HIR_ID);\n-\n-    let map = collector.finalize_and_compute_crate_hash();\n-    tcx.arena.alloc(map)\n-}\n-\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-\n-    // We can access untracked state since we are an eval_always query.\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    let mut hir_body_nodes: Vec<_> = tcx\n-        .index_hir(())\n-        .map\n-        .iter_enumerated()\n-        .filter_map(|(def_id, hod)| {\n-            let def_path_hash = tcx.untracked_resolutions.definitions.def_path_hash(def_id);\n-            let hash = hod.as_ref()?.hash;\n-            Some((def_path_hash, hash, def_id))\n-        })\n-        .collect();\n-    hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n+    debug_assert_eq!(crate_num, LOCAL_CRATE);\n+    let krate = tcx.hir_crate(());\n+    let hir_body_hash = krate.hir_hash;\n \n     let upstream_crates = upstream_crates(tcx);\n \n@@ -1087,20 +1087,27 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     source_file_names.sort_unstable();\n \n+    let mut hcx = tcx.create_stable_hashing_context();\n     let mut stable_hasher = StableHasher::new();\n-    for (def_path_hash, fingerprint, def_id) in hir_body_nodes.iter() {\n-        def_path_hash.0.hash_stable(&mut hcx, &mut stable_hasher);\n-        fingerprint.hash_stable(&mut hcx, &mut stable_hasher);\n-        AttributeMap { map: &tcx.untracked_crate.attrs, prefix: *def_id }\n-            .hash_stable(&mut hcx, &mut stable_hasher);\n-        if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n-            let span = tcx.untracked_resolutions.definitions.def_span(*def_id);\n-            debug_assert_eq!(span.parent(), None);\n-            span.hash_stable(&mut hcx, &mut stable_hasher);\n-        }\n-    }\n+    hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n     upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n     source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n+    if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n+        let definitions = &tcx.untracked_resolutions.definitions;\n+        let mut owner_spans: Vec<_> = krate\n+            .owners\n+            .iter_enumerated()\n+            .filter_map(|(def_id, info)| {\n+                let _ = info.as_ref()?;\n+                let def_path_hash = definitions.def_path_hash(def_id);\n+                let span = definitions.def_span(def_id);\n+                debug_assert_eq!(span.parent(), None);\n+                Some((def_path_hash, span))\n+            })\n+            .collect();\n+        owner_spans.sort_unstable_by_key(|bn| bn.0);\n+        owner_spans.hash_stable(&mut hcx, &mut stable_hasher);\n+    }\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n "}, {"sha": "95d7273b17b446372976332c2a846aaf066e60f8", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 100, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -8,28 +8,12 @@ pub mod place;\n \n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n-use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::*;\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::DUMMY_SP;\n-use std::collections::BTreeMap;\n-\n-/// Result of HIR indexing.\n-#[derive(Debug)]\n-pub struct IndexedHir<'hir> {\n-    /// Contents of the HIR owned by each definition. None for definitions that are not HIR owners.\n-    // The `mut` comes from construction time, and is harmless since we only ever hand out\n-    // immutable refs to IndexedHir.\n-    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n-    /// Map from each owner to its parent's HirId inside another owner.\n-    // This map is separate from `map` to eventually allow for per-owner indexing.\n-    parenting: FxHashMap<LocalDefId, HirId>,\n-}\n \n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n@@ -39,85 +23,14 @@ pub struct IndexedHir<'hir> {\n #[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n     node: OwnerNode<'tcx>,\n+    hash_without_bodies: Fingerprint,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Owner { node } = self;\n-        hcx.while_hashing_hir_bodies(false, |hcx| node.hash_stable(hcx, hasher));\n-    }\n-}\n-\n-/// HIR node coupled with its parent's id in the same HIR owner.\n-///\n-/// The parent is trash when the node is a HIR owner.\n-#[derive(Clone, Debug)]\n-pub struct ParentedNode<'tcx> {\n-    parent: ItemLocalId,\n-    node: Node<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub struct OwnerNodes<'tcx> {\n-    /// Pre-computed hash of the full HIR.\n-    hash: Fingerprint,\n-    /// Full HIR for the current owner.\n-    // The zeroth node's parent is trash, but is never accessed.\n-    nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n-    /// Content of local bodies.\n-    bodies: FxHashMap<ItemLocalId, &'tcx Body<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OwnerNodes<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        // We ignore the `nodes` and `bodies` fields since these refer to information included in\n-        // `hash` which is hashed in the collector and used for the crate hash.\n-        let OwnerNodes { hash, nodes: _, bodies: _ } = *self;\n-        hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-/// Attributes owner by a HIR owner. It is build as a slice inside the attributes map, restricted\n-/// to the nodes whose `HirId::owner` is `prefix`.\n-#[derive(Copy, Clone)]\n-pub struct AttributeMap<'tcx> {\n-    map: &'tcx BTreeMap<HirId, &'tcx [Attribute]>,\n-    prefix: LocalDefId,\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for AttributeMap<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let range = self.range();\n-\n-        range.clone().count().hash_stable(hcx, hasher);\n-        for (key, value) in range {\n-            key.hash_stable(hcx, hasher);\n-            value.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n-impl<'tcx> std::fmt::Debug for AttributeMap<'tcx> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        f.debug_struct(\"AttributeMap\")\n-            .field(\"prefix\", &self.prefix)\n-            .field(\"range\", &&self.range().collect::<Vec<_>>()[..])\n-            .finish()\n-    }\n-}\n-\n-impl<'tcx> AttributeMap<'tcx> {\n-    fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n-        self.map.get(&HirId { owner: self.prefix, local_id: id }).copied().unwrap_or(&[])\n-    }\n-\n-    fn range(&self) -> std::collections::btree_map::Range<'_, rustc_hir::HirId, &[Attribute]> {\n-        let local_zero = ItemLocalId::from_u32(0);\n-        let range = HirId { owner: self.prefix, local_id: local_zero }..HirId {\n-            owner: LocalDefId { local_def_index: self.prefix.local_def_index + 1 },\n-            local_id: local_zero,\n-        };\n-        self.map.range(range)\n+        let Owner { node: _, hash_without_bodies } = self;\n+        hash_without_bodies.hash_stable(hcx, hasher)\n     }\n }\n \n@@ -149,21 +62,32 @@ pub fn provide(providers: &mut Providers) {\n         hir.local_def_id(hir.get_module_parent_node(hir.local_def_id_to_hir_id(id)))\n     };\n     providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n-    providers.index_hir = map::index_hir;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.index_hir(()).map[id].as_ref()?;\n-        let node = owner.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n-        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n-        Some(Owner { node })\n+        let owner = tcx.hir_crate(()).owners[id].as_ref()?;\n+        let node = owner.node();\n+        Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n     };\n-    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();\n+    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n-        let index = tcx.index_hir(());\n-        index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)\n+        // Accessing the def_key is ok since its value is hashed as part of `id`'s DefPathHash.\n+        let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n+        let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n+            let def_id = LocalDefId { local_def_index };\n+            let mut parent_hir_id =\n+                tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id);\n+            if let Some(local_id) =\n+                tcx.hir_crate(()).owners[parent_hir_id.owner].as_ref().unwrap().parenting.get(&id)\n+            {\n+                parent_hir_id.local_id = *local_id;\n+            }\n+            parent_hir_id\n+        });\n+        parent\n     };\n-    providers.hir_attrs = |tcx, id| AttributeMap { map: &tcx.untracked_crate.attrs, prefix: id };\n+    providers.hir_attrs =\n+        |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n     providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {"}, {"sha": "18be9817c5fa794e53bd29a1f5722ee4bd5bf658", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -36,18 +36,9 @@ rustc_queries! {\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n     query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n         eval_always\n-        no_hash\n         desc { \"get the crate HIR\" }\n     }\n \n-    /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n-    /// Avoid calling this query directly.\n-    query index_hir(_: ()) -> &'tcx crate::hir::IndexedHir<'tcx> {\n-        eval_always\n-        no_hash\n-        desc { \"index HIR\" }\n-    }\n-\n     /// The items in a module.\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n@@ -62,7 +53,6 @@ rustc_queries! {\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner(key: LocalDefId) -> Option<crate::hir::Owner<'tcx>> {\n-        eval_always\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -71,25 +61,22 @@ rustc_queries! {\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner_parent(key: LocalDefId) -> hir::HirId {\n-        eval_always\n         desc { |tcx| \"HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx crate::hir::OwnerNodes<'tcx>> {\n-        eval_always\n+    query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx hir::OwnerNodes<'tcx>> {\n         desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR attributes inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_attrs(key: LocalDefId) -> rustc_middle::hir::AttributeMap<'tcx> {\n-        eval_always\n+    query hir_attrs(key: LocalDefId) -> &'tcx hir::AttributeMap<'tcx> {\n         desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -933,12 +920,6 @@ rustc_queries! {\n \n     query def_span(def_id: DefId) -> Span {\n         desc { |tcx| \"looking up span for `{}`\", tcx.def_path_str(def_id) }\n-        // FIXME(mw): DefSpans are not really inputs since they are derived from\n-        // HIR. But at the moment HIR hashing still contains some hacks that allow\n-        // to make type debuginfo to be source location independent. Declaring\n-        // DefSpan an input makes sure that changes to these are always detected\n-        // regardless of HIR hashing.\n-        eval_always\n     }\n \n     query def_ident_span(def_id: DefId) -> Option<Span> {"}, {"sha": "14a7e0ef170c89273ac7a777c4f26c3b48a1a2c8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1337,20 +1337,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let krate = self.gcx.untracked_crate;\n         let resolutions = &self.gcx.untracked_resolutions;\n-\n-        StableHashingContext::new(self.sess, krate, &resolutions.definitions, &*resolutions.cstore)\n+        StableHashingContext::new(self.sess, &resolutions.definitions, &*resolutions.cstore)\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let krate = self.gcx.untracked_crate;\n         let resolutions = &self.gcx.untracked_resolutions;\n-\n         StableHashingContext::ignore_spans(\n             self.sess,\n-            krate,\n             &resolutions.definitions,\n             &*resolutions.cstore,\n         )\n@@ -2823,7 +2818,8 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.in_scope_traits_map = |tcx, id| tcx.hir_crate(()).trait_map.get(&id);\n+    providers.in_scope_traits_map =\n+        |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|owner_info| &owner_info.trait_map);\n     providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n     providers.module_exports = |tcx, id| tcx.resolutions(()).export_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {"}, {"sha": "e980d3d884f5636408e7adf762fa52264e96c5ab", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -14,7 +14,6 @@ use spans::{CoverageSpan, CoverageSpans};\n \n use crate::MirPass;\n \n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::graph::WithNumNodes;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -29,7 +28,6 @@ use rustc_middle::mir::{\n     TerminatorKind,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::DefId;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{CharPos, ExpnKind, Pos, SourceFile, Span, Symbol};\n@@ -574,15 +572,13 @@ fn get_body_span<'tcx>(\n }\n \n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n+    // FIXME(cjgillot) Stop hashing HIR manually here.\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n-    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n-}\n-\n-fn hash(\n-    hcx: &mut StableHashingContext<'tcx>,\n-    node: &impl HashStable<StableHashingContext<'tcx>>,\n-) -> Fingerprint {\n     let mut stable_hasher = StableHasher::new();\n-    node.hash_stable(hcx, &mut stable_hasher);\n+    let owner = hir_body.id().hir_id.owner;\n+    let bodies = &tcx.hir_owner_nodes(owner).as_ref().unwrap().bodies;\n+    hcx.with_hir_bodies(false, owner, bodies, |hcx| {\n+        hir_body.value.hash_stable(hcx, &mut stable_hasher)\n+    });\n     stable_hasher.finish()\n }"}, {"sha": "cfef2073373cc93c71bdbc91ec22735361ad323d", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -6,6 +6,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_index::vec::IndexVec;\n use rustc_session::cstore::CrateStore;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n@@ -27,7 +28,6 @@ pub struct StableHashingContext<'a> {\n     cstore: &'a dyn CrateStore,\n     pub(super) body_resolver: BodyResolver<'a>,\n     hash_spans: bool,\n-    hash_bodies: bool,\n     pub(super) node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n@@ -46,24 +46,19 @@ pub enum NodeIdHashingMode {\n /// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n-pub(super) struct BodyResolver<'tcx>(&'tcx hir::Crate<'tcx>);\n-\n-impl<'tcx> BodyResolver<'tcx> {\n-    /// Returns a reference to the `hir::Body` with the given `BodyId`.\n-    /// **Does not do any tracking**; use carefully.\n-    pub(super) fn body(self, id: hir::BodyId) -> &'tcx hir::Body<'tcx> {\n-        self.0.body(id)\n-    }\n+pub(super) enum BodyResolver<'tcx> {\n+    Forbidden,\n+    Traverse {\n+        hash_bodies: bool,\n+        owner: LocalDefId,\n+        bodies: &'tcx IndexVec<hir::ItemLocalId, Option<&'tcx hir::Body<'tcx>>>,\n+    },\n }\n \n impl<'a> StableHashingContext<'a> {\n-    /// The `krate` here is only used for mapping `BodyId`s to `Body`s.\n-    /// Don't use it for anything else or you'll run the risk of\n-    /// leaking data out of the tracking system.\n     #[inline]\n     fn new_with_or_without_spans(\n         sess: &'a Session,\n-        krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n         always_ignore_spans: bool,\n@@ -72,27 +67,24 @@ impl<'a> StableHashingContext<'a> {\n             !always_ignore_spans && !sess.opts.debugging_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n-            body_resolver: BodyResolver(krate),\n+            body_resolver: BodyResolver::Forbidden,\n             definitions,\n             cstore,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n             hash_spans: hash_spans_initial,\n-            hash_bodies: true,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n         }\n     }\n \n     #[inline]\n     pub fn new(\n         sess: &'a Session,\n-        krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n     ) -> Self {\n         Self::new_with_or_without_spans(\n             sess,\n-            krate,\n             definitions,\n             cstore,\n             /*always_ignore_spans=*/ false,\n@@ -102,20 +94,41 @@ impl<'a> StableHashingContext<'a> {\n     #[inline]\n     pub fn ignore_spans(\n         sess: &'a Session,\n-        krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n     ) -> Self {\n         let always_ignore_spans = true;\n-        Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n+        Self::new_with_or_without_spans(sess, definitions, cstore, always_ignore_spans)\n     }\n \n+    /// Allow hashing\n     #[inline]\n-    pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self, hash_bodies: bool, f: F) {\n-        let prev_hash_bodies = self.hash_bodies;\n-        self.hash_bodies = hash_bodies;\n+    pub fn while_hashing_hir_bodies(&mut self, hb: bool, f: impl FnOnce(&mut Self)) {\n+        let prev = match &mut self.body_resolver {\n+            BodyResolver::Forbidden => panic!(\"Hashing HIR bodies is forbidden.\"),\n+            BodyResolver::Traverse { ref mut hash_bodies, .. } => {\n+                std::mem::replace(hash_bodies, hb)\n+            }\n+        };\n         f(self);\n-        self.hash_bodies = prev_hash_bodies;\n+        match &mut self.body_resolver {\n+            BodyResolver::Forbidden => unreachable!(),\n+            BodyResolver::Traverse { ref mut hash_bodies, .. } => *hash_bodies = prev,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn with_hir_bodies(\n+        &mut self,\n+        hash_bodies: bool,\n+        owner: LocalDefId,\n+        bodies: &'a IndexVec<hir::ItemLocalId, Option<&'a hir::Body<'a>>>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        let prev = self.body_resolver;\n+        self.body_resolver = BodyResolver::Traverse { hash_bodies, owner, bodies };\n+        f(self);\n+        self.body_resolver = prev;\n     }\n \n     #[inline]\n@@ -152,11 +165,6 @@ impl<'a> StableHashingContext<'a> {\n         self.definitions.def_path_hash(def_id)\n     }\n \n-    #[inline]\n-    pub fn hash_bodies(&self) -> bool {\n-        self.hash_bodies\n-    }\n-\n     #[inline]\n     pub fn source_map(&mut self) -> &mut CachingSourceMapView<'a> {\n         match self.caching_source_map {"}, {"sha": "24f3a2e7de0a9926945fe569a37a4104d27219c1", "filename": "compiler/rustc_query_system/src/ich/impls_hir.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1,12 +1,11 @@\n //! This module contains `HashStable` implementations for various HIR data\n //! types in no particular order.\n \n+use crate::ich::hcx::BodyResolver;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_hir as hir;\n-use rustc_hir::definitions::DefPathHash;\n-use smallvec::SmallVec;\n use std::mem;\n \n impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n@@ -29,8 +28,13 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     #[inline]\n     fn hash_body_id(&mut self, id: hir::BodyId, hasher: &mut StableHasher) {\n         let hcx = self;\n-        if hcx.hash_bodies() {\n-            hcx.body_resolver.body(id).hash_stable(hcx, hasher);\n+        match hcx.body_resolver {\n+            BodyResolver::Forbidden => panic!(\"Hashing HIR bodies is forbidden.\"),\n+            BodyResolver::Traverse { hash_bodies: false, .. } => {}\n+            BodyResolver::Traverse { hash_bodies: true, owner, bodies } => {\n+                assert_eq!(id.hir_id.owner, owner);\n+                bodies[id.hir_id.local_id].unwrap().hash_stable(hcx, hasher);\n+            }\n         }\n     }\n \n@@ -115,6 +119,16 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n \n         self.node_id_hashing_mode = prev_hash_node_ids;\n     }\n+\n+    #[inline]\n+    fn hash_hir_trait_candidate(&mut self, tc: &hir::TraitCandidate, hasher: &mut StableHasher) {\n+        self.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            let hir::TraitCandidate { def_id, import_ids } = tc;\n+\n+            def_id.hash_stable(hcx, hasher);\n+            import_ids.hash_stable(hcx, hasher);\n+        });\n+    }\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Body<'_> {\n@@ -129,27 +143,3 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body<'_> {\n         });\n     }\n }\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            let hir::TraitCandidate { def_id, import_ids } = self;\n-\n-            def_id.hash_stable(hcx, hasher);\n-            import_ids.hash_stable(hcx, hasher);\n-        });\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n-    type KeyType = (DefPathHash, SmallVec<[DefPathHash; 1]>);\n-\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> Self::KeyType {\n-        let hir::TraitCandidate { def_id, import_ids } = self;\n-\n-        (\n-            hcx.def_path_hash(*def_id),\n-            import_ids.iter().map(|def_id| hcx.local_def_path_hash(*def_id)).collect(),\n-        )\n-    }\n-}"}, {"sha": "bd27c16c732a9b11c74d7751b6d80a3bf6f0713c", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -23,6 +23,7 @@ rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n+rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "0a24e00ee4bf5137b88eadef81b20a09266b4ebb", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -1994,7 +1994,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n                     let traits = self.traits_in_scope(item_name, ns);\n-                    self.r.trait_map.as_mut().unwrap().insert(id, traits);\n+                    self.r.trait_map.insert(id, traits);\n                 }\n \n                 if PrimTy::from_name(path[0].ident.name).is_some() {\n@@ -2479,12 +2479,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.traits_in_scope(ident, ValueNS);\n-                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n                 let traits = self.traits_in_scope(segment.ident, ValueNS);\n-                self.r.trait_map.as_mut().unwrap().insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n                 // Nothing to do."}, {"sha": "4b6585f55436acf4642625a8a245ffd531373687", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 43, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -54,13 +54,14 @@ use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, ResolverOutputs};\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n-use rustc_span::source_map::{CachingSourceMapView, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -930,7 +931,7 @@ pub struct Resolver<'a> {\n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     export_map: ExportMap,\n-    trait_map: Option<NodeMap<Vec<TraitCandidate>>>,\n+    trait_map: NodeMap<Vec<TraitCandidate>>,\n \n     /// A map from nodes to anonymous modules.\n     /// Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1177,6 +1178,10 @@ impl ResolverAstLowering for Resolver<'_> {\n         &mut self.definitions\n     }\n \n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n+        StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n+    }\n+\n     fn lint_buffer(&mut self) -> &mut LintBuffer {\n         &mut self.lint_buffer\n     }\n@@ -1185,8 +1190,8 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.next_node_id()\n     }\n \n-    fn take_trait_map(&mut self) -> NodeMap<Vec<TraitCandidate>> {\n-        std::mem::replace(&mut self.trait_map, None).unwrap()\n+    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<TraitCandidate>> {\n+        self.trait_map.remove(&node)\n     }\n \n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n@@ -1245,37 +1250,6 @@ impl ResolverAstLowering for Resolver<'_> {\n     }\n }\n \n-struct ExpandHasher<'a, 'b> {\n-    source_map: CachingSourceMapView<'a>,\n-    resolver: &'a Resolver<'b>,\n-}\n-\n-impl<'a, 'b> rustc_span::HashStableContext for ExpandHasher<'a, 'b> {\n-    #[inline]\n-    fn hash_spans(&self) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    fn def_span(&self, id: LocalDefId) -> Span {\n-        self.resolver.def_span(id)\n-    }\n-\n-    #[inline]\n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        self.resolver.def_path_hash(def_id)\n-    }\n-\n-    #[inline]\n-    fn span_data_to_lines_and_cols(\n-        &mut self,\n-        span: &rustc_span::SpanData,\n-    ) -> Option<(Lrc<rustc_span::SourceFile>, usize, rustc_span::BytePos, usize, rustc_span::BytePos)>\n-    {\n-        self.source_map.span_data_to_lines_and_cols(span)\n-    }\n-}\n-\n impl<'a> Resolver<'a> {\n     pub fn new(\n         session: &'a Session,\n@@ -1363,7 +1337,7 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n-            trait_map: Some(NodeMap::default()),\n+            trait_map: NodeMap::default(),\n             underscore_disambiguator: 0,\n             empty_module,\n             module_map,\n@@ -1456,13 +1430,6 @@ impl<'a> Resolver<'a> {\n         self.arenas.new_module(parent, kind, expn_id, span, no_implicit_prelude, module_map)\n     }\n \n-    fn create_stable_hashing_context(&self) -> ExpandHasher<'_, 'a> {\n-        ExpandHasher {\n-            source_map: CachingSourceMapView::new(self.session.source_map()),\n-            resolver: self,\n-        }\n-    }\n-\n     pub fn next_node_id(&mut self) -> NodeId {\n         let next = self\n             .next_node_id"}, {"sha": "c2a33ce1f59b38549e5fd6196863f26ff25481ea", "filename": "src/test/ui/privacy/privacy2.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -23,13 +23,7 @@ LL | pub fn foo() {}\n \n error: requires `sized` lang_item\n \n-error: requires `sized` lang_item\n-\n-error: requires `sized` lang_item\n-\n-error: requires `sized` lang_item\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0432, E0603.\n For more information about an error, try `rustc --explain E0432`."}, {"sha": "22c1e48b07d947391692d0596ed413658362a724", "filename": "src/test/ui/privacy/privacy3.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fprivacy%2Fprivacy3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd41e09da334697c0f993b36685cb599061d9faa/src%2Ftest%2Fui%2Fprivacy%2Fprivacy3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy3.stderr?ref=bd41e09da334697c0f993b36685cb599061d9faa", "patch": "@@ -6,12 +6,6 @@ LL |     use bar::gpriv;\n \n error: requires `sized` lang_item\n \n-error: requires `sized` lang_item\n-\n-error: requires `sized` lang_item\n-\n-error: requires `sized` lang_item\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0432`."}]}