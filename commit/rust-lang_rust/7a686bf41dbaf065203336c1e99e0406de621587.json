{"sha": "7a686bf41dbaf065203336c1e99e0406de621587", "node_id": "C_kwDOAAsO6NoAKDdhNjg2YmY0MWRiYWYwNjUyMDMzMzZjMWU5OWUwNDA2ZGU2MjE1ODc", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-03-03T07:04:53Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-03-11T19:40:18Z"}, "message": "tidy: enforce comment blocks to have even number of backticks\n\nSome comments may be formed like:\n\n// This function takes a tuple `(Vec<String>,\n// Box<[u8]>)` and transforms it into `Vec<u8>`.\n\nwhere the \"back-ticked\" section wraps around.\nTherefore, we can't make a single-line based\nlint.\n\nWe also cannot make the lint paragraph based,\nas it would otherwise complain about inline\ncode blocks:\n\n/// ```\n/// use super::Foo;\n///\n/// fn main() { Foo::new(); }\n/// ```\n\nFor the future, one could introduce some checks\nto treat code blocks specially, but such code\nwould make the check even more complicated.", "tree": {"sha": "10b526a2a8fba7e22f7e46b1fd641cb73699d00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10b526a2a8fba7e22f7e46b1fd641cb73699d00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a686bf41dbaf065203336c1e99e0406de621587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a686bf41dbaf065203336c1e99e0406de621587", "html_url": "https://github.com/rust-lang/rust/commit/7a686bf41dbaf065203336c1e99e0406de621587", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a686bf41dbaf065203336c1e99e0406de621587/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde0b164d28382da7de892172d9129f21f8bb179", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde0b164d28382da7de892172d9129f21f8bb179", "html_url": "https://github.com/rust-lang/rust/commit/cde0b164d28382da7de892172d9129f21f8bb179"}], "stats": {"total": 56, "additions": 47, "deletions": 9}, "files": [{"sha": "af6231ed0df7aef0f1a4b0ae2c296e290b03cd12", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7a686bf41dbaf065203336c1e99e0406de621587/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a686bf41dbaf065203336c1e99e0406de621587/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=7a686bf41dbaf065203336c1e99e0406de621587", "patch": "@@ -300,10 +300,13 @@ pub fn check(path: &Path, bad: &mut bool) {\n             contains_ignore_directive(can_contain, &contents, \"leading-newlines\");\n         let mut skip_copyright = contains_ignore_directive(can_contain, &contents, \"copyright\");\n         let mut skip_dbg = contains_ignore_directive(can_contain, &contents, \"dbg\");\n+        let mut skip_odd_backticks =\n+            contains_ignore_directive(can_contain, &contents, \"odd-backticks\");\n         let mut leading_new_lines = false;\n         let mut trailing_new_lines = 0;\n         let mut lines = 0;\n         let mut last_safety_comment = false;\n+        let mut comment_block: Option<(usize, usize)> = None;\n         let is_test = file.components().any(|c| c.as_os_str() == \"tests\");\n         // scanning the whole file for multiple needles at once is more efficient than\n         // executing lines times needles separate searches.\n@@ -415,15 +418,50 @@ pub fn check(path: &Path, bad: &mut bool) {\n \n             // For now only enforce in compiler\n             let is_compiler = || file.components().any(|c| c.as_os_str() == \"compiler\");\n-            if is_compiler()\n-                && line.contains(\"//\")\n-                && line\n-                    .chars()\n-                    .collect::<Vec<_>>()\n-                    .windows(4)\n-                    .any(|cs| matches!(cs, ['.', ' ', ' ', last] if last.is_alphabetic()))\n-            {\n-                err(DOUBLE_SPACE_AFTER_DOT)\n+\n+            if is_compiler() {\n+                if line.contains(\"//\")\n+                    && line\n+                        .chars()\n+                        .collect::<Vec<_>>()\n+                        .windows(4)\n+                        .any(|cs| matches!(cs, ['.', ' ', ' ', last] if last.is_alphabetic()))\n+                {\n+                    err(DOUBLE_SPACE_AFTER_DOT)\n+                }\n+\n+                if line.contains(\"//\") {\n+                    let (start_line, mut backtick_count) = comment_block.unwrap_or((i + 1, 0));\n+                    let line_backticks = line.chars().filter(|ch| *ch == '`').count();\n+                    let comment_text = line.split(\"//\").nth(1).unwrap();\n+                    // This check ensures that we don't lint for code that has `//` in a string literal\n+                    if line_backticks % 2 == 1 {\n+                        backtick_count += comment_text.chars().filter(|ch| *ch == '`').count();\n+                    }\n+                    comment_block = Some((start_line, backtick_count));\n+                } else {\n+                    if let Some((start_line, backtick_count)) = comment_block.take() {\n+                        if backtick_count % 2 == 1 {\n+                            let mut err = |msg: &str| {\n+                                tidy_error!(bad, \"{}:{start_line}: {msg}\", file.display());\n+                            };\n+                            let block_len = (i + 1) - start_line;\n+                            if block_len == 1 {\n+                                suppressible_tidy_err!(\n+                                    err,\n+                                    skip_odd_backticks,\n+                                    \"comment with odd number of backticks\"\n+                                );\n+                            } else {\n+                                suppressible_tidy_err!(\n+                                    err,\n+                                    skip_odd_backticks,\n+                                    \"{block_len}-line comment block with odd number of backticks\"\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n         if leading_new_lines {"}]}