{"sha": "38004b72bcfc1ec1892c3186b2627067de6414c1", "node_id": "C_kwDOAAsO6NoAKDM4MDA0YjcyYmNmYzFlYzE4OTJjMzE4NmIyNjI3MDY3ZGU2NDE0YzE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-07T20:22:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-07T20:24:48Z"}, "message": "interpret: err instead of ICE on size mismatches in to_bits_or_ptr_internal", "tree": {"sha": "169f39ec23d619cf5403e664a799fa4a181204d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/169f39ec23d619cf5403e664a799fa4a181204d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38004b72bcfc1ec1892c3186b2627067de6414c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38004b72bcfc1ec1892c3186b2627067de6414c1", "html_url": "https://github.com/rust-lang/rust/commit/38004b72bcfc1ec1892c3186b2627067de6414c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38004b72bcfc1ec1892c3186b2627067de6414c1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ab1fae73a14db17a59e81c532a2b8f048ac159", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ab1fae73a14db17a59e81c532a2b8f048ac159", "html_url": "https://github.com/rust-lang/rust/commit/b6ab1fae73a14db17a59e81c532a2b8f048ac159"}], "stats": {"total": 174, "additions": 107, "deletions": 67}, "files": [{"sha": "498b2f1b081b3308dd65720a419537a7db89f7dc", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -167,17 +167,18 @@ pub(super) fn op_to_const<'tcx>(\n             },\n             Immediate::ScalarPair(a, b) => {\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) = match ecx.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n-                    (Some(alloc_id), offset) => {\n-                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                    }\n-                    (None, _offset) => (\n-                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n-                            b\"\" as &[u8],\n-                        )),\n-                        0,\n-                    ),\n-                };\n+                let (data, start) =\n+                    match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n+                        (Some(alloc_id), offset) => {\n+                            (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                        }\n+                        (None, _offset) => (\n+                            ecx.tcx.intern_const_alloc(\n+                                Allocation::from_bytes_byte_aligned_immutable(b\"\" as &[u8]),\n+                            ),\n+                            0,\n+                        ),\n+                    };\n                 let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();"}, {"sha": "d57504deeab90594d79bd30d4c7baec4dbbda4a5", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -197,8 +197,8 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n-        match (a, b) {\n+    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+        Ok(match (a, b) {\n             // Comparisons between integers are always known.\n             (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n@@ -207,25 +207,25 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n             (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        }\n+        })\n     }\n \n-    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n-        match (a, b) {\n+    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+        Ok(match (a, b) {\n             // Comparisons between integers are always known.\n             (Scalar::Int(_), Scalar::Int(_)) => a != b,\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n             (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n             | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n-                int.is_null() && !self.scalar_may_be_null(ptr)\n+                int.is_null() && !self.scalar_may_be_null(ptr)?\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n             (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        }\n+        })\n     }\n }\n \n@@ -329,9 +329,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n                 let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    ecx.guaranteed_eq(a, b)\n+                    ecx.guaranteed_eq(a, b)?\n                 } else {\n-                    ecx.guaranteed_ne(a, b)\n+                    ecx.guaranteed_ne(a, b)?\n                 };\n                 ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n             }"}, {"sha": "3ea3729dbcd17d765c1be73eba98948927cb08c5", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -283,7 +283,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let Some(entry_idx) = vptr_entry_idx {\n                     let entry_idx = u64::try_from(entry_idx).unwrap();\n                     let (old_data, old_vptr) = val.to_scalar_pair()?;\n-                    let old_vptr = self.scalar_to_ptr(old_vptr);\n+                    let old_vptr = self.scalar_to_ptr(old_vptr)?;\n                     let new_vptr = self\n                         .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n                     self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)"}, {"sha": "f0fff602fe4cfbf8a647c415035898a04eaa8e6f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -640,7 +640,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = self.scalar_to_ptr(metadata.unwrap_meta());\n+                let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }"}, {"sha": "1fda60c021eed7f744a53d30e97799cae93d8940", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -202,7 +202,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta());\n+                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta())?;\n                 if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable."}, {"sha": "556a44a52381960ba47bae4242f04ef315767e73", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -1102,30 +1102,38 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n+    pub fn scalar_to_ptr(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n         // call to force getting out a pointer.\n-        match scalar.to_bits_or_ptr_internal(self.pointer_size()) {\n-            Err(ptr) => ptr.into(),\n-            Ok(bits) => {\n-                let addr = u64::try_from(bits).unwrap();\n-                let ptr = M::ptr_from_addr(&self, addr);\n-                if addr == 0 {\n-                    assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n+        Ok(\n+            match scalar\n+                .to_bits_or_ptr_internal(self.pointer_size())\n+                .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n+            {\n+                Err(ptr) => ptr.into(),\n+                Ok(bits) => {\n+                    let addr = u64::try_from(bits).unwrap();\n+                    let ptr = M::ptr_from_addr(&self, addr);\n+                    if addr == 0 {\n+                        assert!(ptr.provenance.is_none(), \"null pointer can never have an AllocId\");\n+                    }\n+                    ptr\n                 }\n-                ptr\n-            }\n-        }\n+            },\n+        )\n     }\n \n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n-    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n-        match scalar.try_to_int() {\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> InterpResult<'tcx, bool> {\n+        Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n                 // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar);\n+                let ptr = self.scalar_to_ptr(scalar)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align) = self\n@@ -1138,7 +1146,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information"}, {"sha": "dfc0028e87fcc92a2ebd04f8a71dbd06a7e4a229", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -342,7 +342,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n-        Ok(self.scalar_to_ptr(self.read_scalar(op)?.check_init()?))\n+        self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)\n@@ -738,7 +738,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n-                            && !self.scalar_may_be_null(tag_val);\n+                            && !self.scalar_may_be_null(tag_val)?;\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }"}, {"sha": "51d47af2f8e24c960db26a3619dd4fd82bda3588", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -281,7 +281,7 @@ where\n         };\n \n         let mplace = MemPlace {\n-            ptr: self.scalar_to_ptr(ptr.check_init()?),\n+            ptr: self.scalar_to_ptr(ptr.check_init()?)?,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n@@ -1104,7 +1104,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n-        let vtable = self.scalar_to_ptr(mplace.vtable()); // also sanity checks the type\n+        let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "c2664565f15cb18b7dce2a22621f7537769e2678", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -519,7 +519,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .kind(),\n                     ty::Dynamic(..)\n                 ));\n-                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta());\n+                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n                 let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we"}, {"sha": "235938422a89313e99ebc0254a2457addfb75752", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -50,7 +50,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable_slot = self\n             .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?);\n+        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?)?;\n         self.get_ptr_fn(fn_ptr)\n     }\n \n@@ -75,7 +75,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n-        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n+        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn)?)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n@@ -132,7 +132,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n \n-        let new_vtable = self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?);\n+        let new_vtable =\n+            self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?)?;\n \n         Ok(new_vtable)\n     }"}, {"sha": "4a0aa41de739b3caa13f0ed80fa3170fc8c3d331", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -312,7 +312,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta());\n+                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n                     self.ecx.check_ptr_access_align(\n@@ -577,7 +577,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n-                    let ptr = self.ecx.scalar_to_ptr(value);\n+                    let ptr = self.ecx.scalar_to_ptr(value)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n@@ -590,7 +590,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // FIXME: Check if the signature matches\n                 } else {\n                     // Otherwise (for standalone Miri), we have to still check it to be non-null.\n-                    if self.ecx.scalar_may_be_null(value) {\n+                    if self.ecx.scalar_may_be_null(value)? {\n                         throw_validation_failure!(self.path, { \"a null function pointer\" });\n                     }\n                 }\n@@ -667,7 +667,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.scalar_may_be_null(value) {\n+                    if self.ecx.scalar_may_be_null(value)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {"}, {"sha": "dabca2bc777da59cbabcdf287120d8bac33eee3f", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer, Provenance,\n-    ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, UndefinedBehaviorInfo, UninitBytesAccess,\n-    UnsupportedOpInfo,\n+    ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, ScalarSizeMismatch, UndefinedBehaviorInfo,\n+    UninitBytesAccess, UnsupportedOpInfo,\n };\n use crate::ty;\n \n@@ -81,6 +81,8 @@ impl<'tcx, Tag, Extra> ConstAllocation<'tcx, Tag, Extra> {\n /// is added when converting to `InterpError`.\n #[derive(Debug)]\n pub enum AllocError {\n+    /// A scalar had the wrong size.\n+    ScalarSizeMismatch(ScalarSizeMismatch),\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n     /// Partially overwriting a pointer.\n@@ -90,10 +92,19 @@ pub enum AllocError {\n }\n pub type AllocResult<T = ()> = Result<T, AllocError>;\n \n+impl From<ScalarSizeMismatch> for AllocError {\n+    fn from(s: ScalarSizeMismatch) -> Self {\n+        AllocError::ScalarSizeMismatch(s)\n+    }\n+}\n+\n impl AllocError {\n     pub fn to_interp_error<'tcx>(self, alloc_id: AllocId) -> InterpError<'tcx> {\n         use AllocError::*;\n         match self {\n+            ScalarSizeMismatch(s) => {\n+                InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ScalarSizeMismatch(s))\n+            }\n             ReadPointerAsBytes => InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes),\n             PartialPointerOverwrite(offset) => InterpError::Unsupported(\n                 UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n@@ -425,7 +436,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n \n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n-        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size) {\n+        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size)? {\n             Err(val) => {\n                 let (provenance, offset) = val.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))"}, {"sha": "9afe9523fcab0438f102cf84226e57f6ee5df2b5", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -221,6 +221,13 @@ pub struct UninitBytesAccess {\n     pub uninit_size: Size,\n }\n \n+/// Information about a size mismatch.\n+#[derive(Debug)]\n+pub struct ScalarSizeMismatch {\n+    pub target_size: u64,\n+    pub data_size: u64,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n@@ -298,10 +305,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n-    ScalarSizeMismatch {\n-        target_size: u64,\n-        data_size: u64,\n-    },\n+    ScalarSizeMismatch(ScalarSizeMismatch),\n     /// A discriminant of an uninhabited enum variant is written.\n     UninhabitedEnumVariantWritten,\n }\n@@ -408,7 +412,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),\n             DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ScalarSizeMismatch { target_size, data_size } => write!(\n+            ScalarSizeMismatch(self::ScalarSizeMismatch { target_size, data_size }) => write!(\n                 f,\n                 \"scalar size mismatch: expected {} bytes but got {} bytes instead\",\n                 target_size, data_size"}, {"sha": "d8cba39c6d97bf9bc58a14321f8f12646e86d081", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -120,7 +120,8 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n     InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    ResourceExhaustionInfo, ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess,\n+    UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};"}, {"sha": "9cffdf2993ed5bdb97c2ddba9a2beddb0a3ae61c", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -12,6 +12,7 @@ use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{\n     AllocId, AllocRange, ConstAllocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n+    ScalarSizeMismatch,\n };\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n@@ -300,16 +301,29 @@ impl<Tag> Scalar<Tag> {\n     ///\n     /// This method only exists for the benefit of low-level operations that truly need to treat the\n     /// scalar in whatever form it is.\n+    ///\n+    /// This throws UB (instead of ICEing) on a size mismatch since size mismatches can arise in\n+    /// Miri when someone declares a function that we shim (such as `malloc`) with a wrong type.\n     #[inline]\n-    pub fn to_bits_or_ptr_internal(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n+    pub fn to_bits_or_ptr_internal(\n+        self,\n+        target_size: Size,\n+    ) -> Result<Result<u128, Pointer<Tag>>, ScalarSizeMismatch> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n-        match self {\n-            Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n+        Ok(match self {\n+            Scalar::Int(int) => Ok(int.to_bits(target_size).map_err(|size| {\n+                ScalarSizeMismatch { target_size: target_size.bytes(), data_size: size.bytes() }\n+            })?),\n             Scalar::Ptr(ptr, sz) => {\n-                assert_eq!(target_size.bytes(), u64::from(sz));\n+                if target_size.bytes() != sz.into() {\n+                    return Err(ScalarSizeMismatch {\n+                        target_size: target_size.bytes(),\n+                        data_size: sz.into(),\n+                    });\n+                }\n                 Err(ptr)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -348,10 +362,10 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         self.try_to_int().map_err(|_| err_unsup!(ReadPointerAsBytes))?.to_bits(target_size).map_err(\n             |size| {\n-                err_ub!(ScalarSizeMismatch {\n+                err_ub!(ScalarSizeMismatch(ScalarSizeMismatch {\n                     target_size: target_size.bytes(),\n                     data_size: size.bytes(),\n-                })\n+                }))\n                 .into()\n             },\n         )"}, {"sha": "bb3ba3e596d1449b996ec065eaab5108b26344ce", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38004b72bcfc1ec1892c3186b2627067de6414c1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=38004b72bcfc1ec1892c3186b2627067de6414c1", "patch": "@@ -146,7 +146,7 @@ impl IntRange {\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n                     // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n+                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size).unwrap() {\n                         return Some(bits);\n                     }\n                 }"}]}