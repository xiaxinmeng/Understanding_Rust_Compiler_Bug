{"sha": "e18113916267d46b1705d278ee1392e18ada44c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODExMzkxNjI2N2Q0NmIxNzA1ZDI3OGVlMTM5MmUxOGFkYTQ0YzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-10T11:14:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-10T11:14:29Z"}, "message": "Rollup merge of #61570 - varkor:infer-const-arg, r=eddyb\n\nFix issues with const argument inference\n\nFixes https://github.com/rust-lang/rust/issues/60724.\nFixes https://github.com/rust-lang/rust/issues/61346.\n\nr? @eddyb", "tree": {"sha": "2c037ba715ffde8099ab52db22b31f16cf7b8554", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c037ba715ffde8099ab52db22b31f16cf7b8554"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e18113916267d46b1705d278ee1392e18ada44c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc/juVCRBK7hj4Ov3rIwAAdHIIAIR0rSiqN16/MHSaJfMuMp7H\nx8cwcOlrdBc6CaecKB66sr1+3+iwNAbrjpB0SMb1/Bw6tTQUrTh/4JZzEoBTDvp7\nI0PHROx5ku2LMApyIAvTJ+dIIae4ezrMdEvJGvPqu5RIc9UiiSzzGvPwPEkKtyzu\nSIrgw6o2s/ammIMkTKaf2BEZ+Azhp5fX6pAO6qYqLtDTpjZpiHJEw8luO4O13/Zx\nunsB26/mVHI5Wfl9S6hOHq4As3Oug4snaTEB8vtn/81v3KVesWH/jltIb5YHs6MV\nxGBphXVdqxah8GvuKrcoSckntHFzHxWUuU6e8pQbpYY1SkRqL1ClYtCeSFuusrc=\n=9YHK\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c037ba715ffde8099ab52db22b31f16cf7b8554\nparent 22244cfab0ca6b0094ba7a35671d009cb37df7eb\nparent f11e6f7fa7d0a8ff1e73ff28b26667ee0a1acd87\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560165269 +0200\ncommitter GitHub <noreply@github.com> 1560165269 +0200\n\nRollup merge of #61570 - varkor:infer-const-arg, r=eddyb\n\nFix issues with const argument inference\n\nFixes https://github.com/rust-lang/rust/issues/60724.\nFixes https://github.com/rust-lang/rust/issues/61346.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e18113916267d46b1705d278ee1392e18ada44c3", "html_url": "https://github.com/rust-lang/rust/commit/e18113916267d46b1705d278ee1392e18ada44c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e18113916267d46b1705d278ee1392e18ada44c3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22244cfab0ca6b0094ba7a35671d009cb37df7eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/22244cfab0ca6b0094ba7a35671d009cb37df7eb", "html_url": "https://github.com/rust-lang/rust/commit/22244cfab0ca6b0094ba7a35671d009cb37df7eb"}, {"sha": "f11e6f7fa7d0a8ff1e73ff28b26667ee0a1acd87", "url": "https://api.github.com/repos/rust-lang/rust/commits/f11e6f7fa7d0a8ff1e73ff28b26667ee0a1acd87", "html_url": "https://github.com/rust-lang/rust/commit/f11e6f7fa7d0a8ff1e73ff28b26667ee0a1acd87"}], "stats": {"total": 275, "additions": 186, "deletions": 89}, "files": [{"sha": "b5e9f6bd3a610b3c887f46cc9f266b3782a7238a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -2168,7 +2168,7 @@ impl<'a> LoweringContext<'a> {\n         itctx: ImplTraitContext<'_>,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment {\n-        let (mut generic_args, infer_types) = if let Some(ref generic_args) = segment.args {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n@@ -2230,17 +2230,17 @@ impl<'a> LoweringContext<'a> {\n                 .collect();\n             if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n                 let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n-                let no_ty_args = generic_args.args.len() == expected_lifetimes;\n+                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, insertion_span, suggestion) = if no_ty_args && no_bindings {\n+                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n                     // If there are no (non-implicit) generic args or associated type\n                     // bindings, our suggestion includes the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n                     // Otherwise (sorry, this is kind of gross) we need to infer the\n                     // place to splice in the `'_, ` from the generics that do exist.\n                     let first_generic_span = first_generic_span\n-                        .expect(\"already checked that type args or bindings exist\");\n+                        .expect(\"already checked that non-lifetime args or bindings exist\");\n                     (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n                 };\n                 match self.anonymous_lifetime_mode {\n@@ -2263,7 +2263,7 @@ impl<'a> LoweringContext<'a> {\n                             expected_lifetimes,\n                             path_span,\n                             incl_angl_brckt,\n-                            insertion_span,\n+                            insertion_sp,\n                             suggestion,\n                         );\n                         err.emit();\n@@ -2280,7 +2280,7 @@ impl<'a> LoweringContext<'a> {\n                                 expected_lifetimes,\n                                 path_span,\n                                 incl_angl_brckt,\n-                                insertion_span,\n+                                insertion_sp,\n                                 suggestion,\n                             )\n                         );\n@@ -2305,7 +2305,7 @@ impl<'a> LoweringContext<'a> {\n             Some(id),\n             Some(self.lower_res(res)),\n             generic_args,\n-            infer_types,\n+            infer_args,\n         )\n     }\n \n@@ -2316,9 +2316,10 @@ impl<'a> LoweringContext<'a> {\n         mut itctx: ImplTraitContext<'_>,\n     ) -> (hir::GenericArgs, bool) {\n         let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_types = args.iter().any(|arg| match arg {\n+        let has_non_lt_args = args.iter().any(|arg| match arg {\n+            ast::GenericArg::Lifetime(_) => false,\n             ast::GenericArg::Type(_) => true,\n-            _ => false,\n+            ast::GenericArg::Const(_) => true,\n         });\n         (\n             hir::GenericArgs {\n@@ -2328,7 +2329,7 @@ impl<'a> LoweringContext<'a> {\n                     .collect(),\n                 parenthesized: false,\n             },\n-            !has_types && param_mode == ParamMode::Optional\n+            !has_non_lt_args && param_mode == ParamMode::Optional\n         )\n     }\n "}, {"sha": "1b4c56c3453a186f44b2afa17ed4b56daf6eb8ac", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -348,7 +348,7 @@ pub struct PathSegment {\n     /// This only applies to expression and pattern paths, and\n     /// out of those only the segments with no type parameters\n     /// to begin with, e.g., `Vec::new` is `<Vec<..>>::new::<..>`.\n-    pub infer_types: bool,\n+    pub infer_args: bool,\n }\n \n impl PathSegment {\n@@ -358,7 +358,7 @@ impl PathSegment {\n             ident,\n             hir_id: None,\n             res: None,\n-            infer_types: true,\n+            infer_args: true,\n             args: None,\n         }\n     }\n@@ -368,13 +368,13 @@ impl PathSegment {\n         hir_id: Option<HirId>,\n         res: Option<Res>,\n         args: GenericArgs,\n-        infer_types: bool,\n+        infer_args: bool,\n     ) -> Self {\n         PathSegment {\n             ident,\n             hir_id,\n             res,\n-            infer_types,\n+            infer_args,\n             args: if args.is_empty() {\n                 None\n             } else {"}, {"sha": "7b0a499fa5c663fa43077443a3f08c95aea5e4ce", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -1196,7 +1196,7 @@ impl<'a> State<'a> {\n \n         segment.with_generic_args(|generic_args| {\n             if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n-                return self.print_generic_args(&generic_args, segment.infer_types, true);\n+                return self.print_generic_args(&generic_args, segment.infer_args, true);\n             }\n             Ok(())\n         })?;\n@@ -1561,7 +1561,7 @@ impl<'a> State<'a> {\n             if segment.ident.name != kw::PathRoot {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n-                   self.print_generic_args(generic_args, segment.infer_types,\n+                   self.print_generic_args(generic_args, segment.infer_args,\n                                            colons_before_params)\n                })?;\n             }\n@@ -1574,7 +1574,7 @@ impl<'a> State<'a> {\n         if segment.ident.name != kw::PathRoot {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n-               self.print_generic_args(generic_args, segment.infer_types, false)\n+               self.print_generic_args(generic_args, segment.infer_args, false)\n            })?;\n         }\n         Ok(())\n@@ -1602,7 +1602,7 @@ impl<'a> State<'a> {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,\n-                                                    segment.infer_types,\n+                                                    segment.infer_args,\n                                                     colons_before_params)\n                         })?;\n                     }\n@@ -1614,7 +1614,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n-                                            item_segment.infer_types,\n+                                            item_segment.infer_args,\n                                             colons_before_params)\n                 })\n             }\n@@ -1626,7 +1626,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n-                                            item_segment.infer_types,\n+                                            item_segment.infer_args,\n                                             colons_before_params)\n                 })\n             }\n@@ -1635,7 +1635,7 @@ impl<'a> State<'a> {\n \n     fn print_generic_args(&mut self,\n                              generic_args: &hir::GenericArgs,\n-                             infer_types: bool,\n+                             infer_args: bool,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if generic_args.parenthesized {\n@@ -1681,7 +1681,7 @@ impl<'a> State<'a> {\n \n             // FIXME(eddyb): this would leak into error messages (e.g.,\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n-            if infer_types && false {\n+            if infer_args && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;\n             }"}, {"sha": "63d9f0920cc7b3f7a88afd0fb839b7ed970c0a6f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -13,7 +13,7 @@ use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n-use rustc::ty::{self, DefIdTree, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt, Const, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n@@ -49,18 +49,23 @@ pub trait AstConv<'gcx, 'tcx> {\n                                  -> &'tcx ty::GenericPredicates<'tcx>;\n \n     /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n-    fn re_infer(&self, span: Span, _def: Option<&ty::GenericParamDef>)\n+    fn re_infer(\n+        &self,\n+        param: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    )\n                 -> Option<ty::Region<'tcx>>;\n \n     /// Returns the type to use when a type is omitted.\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n+    fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx>;\n \n-    /// Same as `ty_infer`, but with a known type parameter definition.\n-    fn ty_infer_for_def(&self,\n-                        _def: &ty::GenericParamDef,\n-                        span: Span) -> Ty<'tcx> {\n-        self.ty_infer(span)\n-    }\n+    /// Returns the const to use when a const is omitted.\n+    fn ct_infer(\n+        &self,\n+        ty: Ty<'tcx>,\n+        param: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    ) -> &'tcx Const<'tcx>;\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -156,7 +161,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             None => {\n-                self.re_infer(lifetime.span, def)\n+                self.re_infer(def, lifetime.span)\n                     .unwrap_or_else(|| {\n                         // This indicates an illegal lifetime\n                         // elision. `resolve_lifetime` should have\n@@ -191,7 +196,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 span,\n                 def_id,\n                 generic_args,\n-                item_segment.infer_types,\n+                item_segment.infer_args,\n                 None,\n             )\n         });\n@@ -208,7 +213,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n     ) -> bool {\n-        let explicit = !seg.infer_types;\n+        let explicit = !seg.infer_args;\n         let impl_trait = generics.params.iter().any(|param| match param.kind {\n             ty::GenericParamDefKind::Type {\n                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait), ..\n@@ -259,7 +264,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 GenericArgPosition::Value\n             },\n             def.parent.is_none() && def.has_self, // `has_self`\n-            seg.infer_types || suppress_mismatch, // `infer_types`\n+            seg.infer_args || suppress_mismatch, // `infer_args`\n         ).0\n     }\n \n@@ -272,15 +277,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         args: &hir::GenericArgs,\n         position: GenericArgPosition,\n         has_self: bool,\n-        infer_types: bool,\n+        infer_args: bool,\n     ) -> (bool, Option<Vec<Span>>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n         let param_counts = def.own_counts();\n         let arg_counts = args.own_counts();\n         let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n-        let infer_consts = position != GenericArgPosition::Type && arg_counts.consts == 0;\n \n         let mut defaults: ty::GenericParamCount = Default::default();\n         for param in &def.params {\n@@ -333,7 +337,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 offset\n             );\n             // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (i.e., lifetimes), `required == permitted`.\n+            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n             // For other kinds (i.e., types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n                 return (reported_late_bound_region_err.unwrap_or(false), None);\n@@ -404,7 +408,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             );\n         }\n         // FIXME(const_generics:defaults)\n-        if !infer_consts || arg_counts.consts > param_counts.consts {\n+        if !infer_args || arg_counts.consts > param_counts.consts {\n             check_kind_count(\n                 \"const\",\n                 param_counts.consts,\n@@ -414,7 +418,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             );\n         }\n         // Note that type errors are currently be emitted *after* const errors.\n-        if !infer_types\n+        if !infer_args\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n                 \"type\",\n@@ -511,7 +515,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_types) = args_for_def_id(def_id);\n+            let (generic_args, infer_args) = args_for_def_id(def_id);\n \n             let mut args = generic_args.iter().flat_map(|generic_args| generic_args.args.iter())\n                 .peekable();\n@@ -535,7 +539,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                             | (GenericArg::Const(_), GenericParamDefKind::Lifetime) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_types));\n+                                substs.push(inferred_kind(None, param, infer_args));\n                                 params.next();\n                             }\n                             (_, _) => {\n@@ -556,7 +560,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     (None, Some(&param)) => {\n                         // If there are fewer arguments than parameters, it means\n                         // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_types));\n+                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n                         args.next();\n                         params.next();\n                     }\n@@ -592,7 +596,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         span: Span,\n         def_id: DefId,\n         generic_args: &'a hir::GenericArgs,\n-        infer_types: bool,\n+        infer_args: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n     {\n@@ -617,7 +621,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             &generic_args,\n             GenericArgPosition::Type,\n             has_self,\n-            infer_types,\n+            infer_args,\n         );\n \n         let is_object = self_ty.map_or(false, |ty| {\n@@ -644,7 +648,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             self_ty.is_some(),\n             self_ty,\n             // Provide the generic args, and whether types should be inferred.\n-            |_| (Some(generic_args), infer_types),\n+            |_| (Some(generic_args), infer_args),\n             // Provide substitutions for parameters for which (valid) arguments have been provided.\n             |param, arg| {\n                 match (&param.kind, arg) {\n@@ -661,11 +665,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n             },\n             // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_types| {\n+            |substs, param, infer_args| {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n-                        if !infer_types && has_default {\n+                        if !infer_args && has_default {\n                             // No type parameter provided, but a default exists.\n \n                             // If we are converting an object type, then the\n@@ -693,22 +697,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                        .subst_spanned(tcx, substs.unwrap(), Some(span))\n                                 ).into()\n                             }\n-                        } else if infer_types {\n+                        } else if infer_args {\n                             // No type parameters were provided, we can infer all.\n-                            if !default_needs_object_self(param) {\n-                                self.ty_infer_for_def(param, span).into()\n+                            let param = if !default_needs_object_self(param) {\n+                                Some(param)\n                             } else {\n-                                self.ty_infer(span).into()\n-                            }\n+                                None\n+                            };\n+                            self.ty_infer(param, span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n                             tcx.types.err.into()\n                         }\n                     }\n                     GenericParamDefKind::Const => {\n                         // FIXME(const_generics:defaults)\n-                        // We've already errored above about the mismatch.\n-                        tcx.consts.err.into()\n+                        if infer_args {\n+                            // No const parameters were provided, we can infer all.\n+                            let ty = tcx.at(span).type_of(param.def_id);\n+                            self.ct_infer(ty, Some(param), span).into()\n+                        } else {\n+                            // We've already errored above about the mismatch.\n+                            tcx.consts.err.into()\n+                        }\n                     }\n                 }\n             },\n@@ -880,7 +891,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             self.create_substs_for_ast_path(span,\n                                             trait_def_id,\n                                             generic_args,\n-                                            trait_segment.infer_types,\n+                                            trait_segment.infer_args,\n                                             Some(self_ty))\n         })\n     }\n@@ -1428,7 +1439,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 if tcx.named_region(lifetime.hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n-                    self.re_infer(span, None).unwrap_or_else(|| {\n+                    self.re_infer(None, span).unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0228,\n                             \"the lifetime bound for this object type cannot be deduced \\\n                              from context; please supply an explicit bound\");\n@@ -2122,7 +2133,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n-                self.ty_infer(ast_ty.span)\n+                self.ty_infer(None, ast_ty.span)\n             }\n             hir::TyKind::CVarArgs(lt) => {\n                 let va_list_did = match tcx.lang_items().va_list() {"}, {"sha": "b894fc8c83c106f2fa2afb323ffaa6f307f29059", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n         let supplied_return = match decl.output {\n             hir::Return(ref output) => astconv.ast_ty_to_ty(&output),\n-            hir::DefaultReturn(_) => astconv.ty_infer(decl.output.span()),\n+            hir::DefaultReturn(_) => astconv.ty_infer(None, decl.output.span()),\n         };\n \n         let result = ty::Binder::bind(self.tcx.mk_fn_sig("}, {"sha": "0b558a20ed47e2a088984afbe59891221892acc5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -100,11 +100,12 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_target::spec::abi::Abi;\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{\n-    self, AdtKind, CanonicalUserType, Ty, TyCtxt, GenericParamDefKind, Visibility,\n+    self, AdtKind, CanonicalUserType, Ty, TyCtxt, Const, GenericParamDefKind, Visibility,\n     ToPolyTraitRef, ToPredicate, RegionKind, UserType\n };\n use rustc::ty::adjustment::{\n@@ -1938,29 +1939,49 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn re_infer(&self, span: Span, def: Option<&ty::GenericParamDef>)\n-                -> Option<ty::Region<'tcx>> {\n+    fn re_infer(\n+        &self,\n+        def: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    ) -> Option<ty::Region<'tcx>> {\n         let v = match def {\n             Some(def) => infer::EarlyBoundRegion(span, def.name),\n             None => infer::MiscVariable(span)\n         };\n         Some(self.next_region_var(v))\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span,\n-        })\n+    fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n+        if let Some(param) = param {\n+            if let UnpackedKind::Type(ty) = self.var_for_def(span, param).unpack() {\n+                return ty;\n+            }\n+            unreachable!()\n+        } else {\n+            self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            })\n+        }\n     }\n \n-    fn ty_infer_for_def(&self,\n-                        ty_param_def: &ty::GenericParamDef,\n-                        span: Span) -> Ty<'tcx> {\n-        if let UnpackedKind::Type(ty) = self.var_for_def(span, ty_param_def).unpack() {\n-            return ty;\n+    fn ct_infer(\n+        &self,\n+        ty: Ty<'tcx>,\n+        param: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    ) -> &'tcx Const<'tcx> {\n+        if let Some(param) = param {\n+            if let UnpackedKind::Const(ct) = self.var_for_def(span, param).unpack() {\n+                return ct;\n+            }\n+            unreachable!()\n+        } else {\n+            self.next_const_var(ty, ConstVariableOrigin {\n+                kind: ConstVariableOriginKind::ConstInference,\n+                span,\n+            })\n         }\n-        unreachable!()\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -5419,10 +5440,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !infer_args_for_err.contains(&index) {\n                         // Check whether the user has provided generic arguments.\n                         if let Some(ref data) = segments[index].args {\n-                            return (Some(data), segments[index].infer_types);\n+                            return (Some(data), segments[index].infer_args);\n                         }\n                     }\n-                    return (None, segments[index].infer_types);\n+                    return (None, segments[index].infer_args);\n                 }\n \n                 (None, true)\n@@ -5443,13 +5464,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             },\n             // Provide substitutions for parameters for which arguments are inferred.\n-            |substs, param, infer_types| {\n+            |substs, param, infer_args| {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        self.re_infer(span, Some(param)).unwrap().into()\n+                        self.re_infer(Some(param), span).unwrap().into()\n                     }\n                     GenericParamDefKind::Type { has_default, .. } => {\n-                        if !infer_types && has_default {\n+                        if !infer_args && has_default {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing."}, {"sha": "5d91794506c6a9e79ff73fd39f01624c91610ce8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -26,7 +26,7 @@ use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::UnpackedKind;\n-use rustc::ty::{self, AdtKind, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, Const};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n@@ -47,7 +47,7 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticId};\n \n use std::iter;\n \n@@ -186,24 +186,39 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn re_infer(\n         &self,\n-        _span: Span,\n-        _def: Option<&ty::GenericParamDef>,\n+        _: Option<&ty::GenericParamDef>,\n+        _: Span,\n     ) -> Option<ty::Region<'tcx>> {\n         None\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        struct_span_err!(\n-            self.tcx().sess,\n+    fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n+        self.tcx().sess.struct_span_err_with_code(\n             span,\n-            E0121,\n-            \"the type placeholder `_` is not allowed within types on item signatures\"\n+            \"the type placeholder `_` is not allowed within types on item signatures\",\n+            DiagnosticId::Error(\"E0121\".into()),\n         ).span_label(span, \"not allowed in type signatures\")\n          .emit();\n \n         self.tcx().types.err\n     }\n \n+    fn ct_infer(\n+        &self,\n+        _: Ty<'tcx>,\n+        _: Option<&ty::GenericParamDef>,\n+        span: Span,\n+    ) -> &'tcx Const<'tcx> {\n+        self.tcx().sess.struct_span_err_with_code(\n+            span,\n+            \"the const placeholder `_` is not allowed within types on item signatures\",\n+            DiagnosticId::Error(\"E0121\".into()),\n+        ).span_label(span, \"not allowed in type signatures\")\n+         .emit();\n+\n+        self.tcx().consts.err\n+    }\n+\n     fn projected_ty_from_poly_trait_ref(\n         &self,\n         span: Span,"}, {"sha": "66e9a6e6b2a2e4ae9a943ca7495a7aec8ca1d83b", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -1482,8 +1482,8 @@ impl <'a> Drop for MyWrapper<'a> {\n \"##,\n \n E0121: r##\"\n-In order to be consistent with Rust's lack of global type inference, type\n-placeholders are disallowed by design in item signatures.\n+In order to be consistent with Rust's lack of global type inference,\n+type and const placeholders are disallowed by design in item signatures.\n \n Examples of this error include:\n "}, {"sha": "d83846fcf88d44fc93a765e6086051c68be1464c", "filename": "src/test/ui/const-generics/array-wrapper-struct-ctor.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct ArrayStruct<T, const N: usize> {\n+    data: [T; N],\n+}\n+\n+struct ArrayTuple<T, const N: usize>([T; N]);\n+\n+fn main() {\n+    let _ = ArrayStruct { data: [0u32; 8] };\n+    let _ = ArrayTuple([0u32; 8]);\n+}"}, {"sha": "bd18264c1637dd621bc372e323b60644fb8ee3d7", "filename": "src/test/ui/const-generics/array-wrapper-struct-ctor.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-wrapper-struct-ctor.stderr?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/array-wrapper-struct-ctor.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "a29cb90ebb79ab8caac3b410d0e55a0642dd11a4", "filename": "src/test/ui/const-generics/derive-debug-array-wrapper.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.rs?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(Debug)]\n+struct X<const N: usize> {\n+    a: [u32; N], //~ ERROR `[u32; _]` doesn't implement `std::fmt::Debug`\n+}\n+\n+fn main() {}"}, {"sha": "5bab1d1b54a3ea198f28aa230e51314bfceb1089", "filename": "src/test/ui/const-generics/derive-debug-array-wrapper.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e18113916267d46b1705d278ee1392e18ada44c3/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr?ref=e18113916267d46b1705d278ee1392e18ada44c3", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/derive-debug-array-wrapper.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0277]: `[u32; _]` doesn't implement `std::fmt::Debug`\n+  --> $DIR/derive-debug-array-wrapper.rs:6:5\n+   |\n+LL |     a: [u32; N],\n+   |     ^^^^^^^^^^^ `[u32; _]` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `[u32; _]`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[u32; _]`\n+   = note: required for the cast to the object type `dyn std::fmt::Debug`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}