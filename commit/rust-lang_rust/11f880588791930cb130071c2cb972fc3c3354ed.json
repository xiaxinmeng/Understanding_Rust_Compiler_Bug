{"sha": "11f880588791930cb130071c2cb972fc3c3354ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjg4MDU4ODc5MTkzMGNiMTMwMDcxYzJjYjk3MmZjM2MzMzU0ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-11T17:09:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-11T17:09:10Z"}, "message": "Auto merge of #34193 - petrochenkov:privalias, r=nikomatsakis\n\nprivacy: Substitute type aliases in private-in-public checker\n\nCloses https://github.com/rust-lang/rust/issues/30503\nCloses https://github.com/rust-lang/rust/issues/34293\n\nEveryone in the issue discussion seemed to be in favor, @huonw also spoke about this [here](https://www.reddit.com/r/rust/comments/3xldr9/surfaces_and_signatures_component_privacy_versus/cy615wq), but the issue haven't got any movement.\nI think it's reasonable to do this before turning `private_in_public` warnings into errors.\n\nr? @nikomatsakis", "tree": {"sha": "797b51a4ff2876446f97e0b881d41cc445a24df3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/797b51a4ff2876446f97e0b881d41cc445a24df3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f880588791930cb130071c2cb972fc3c3354ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f880588791930cb130071c2cb972fc3c3354ed", "html_url": "https://github.com/rust-lang/rust/commit/11f880588791930cb130071c2cb972fc3c3354ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f880588791930cb130071c2cb972fc3c3354ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42001edc998f3406ecc04afa48bf07ce91247b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/42001edc998f3406ecc04afa48bf07ce91247b67", "html_url": "https://github.com/rust-lang/rust/commit/42001edc998f3406ecc04afa48bf07ce91247b67"}, {"sha": "5d4ae4ba5a08c1161e46e0dd6b2584b664bdf335", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4ae4ba5a08c1161e46e0dd6b2584b664bdf335", "html_url": "https://github.com/rust-lang/rust/commit/5d4ae4ba5a08c1161e46e0dd6b2584b664bdf335"}], "stats": {"total": 145, "additions": 127, "deletions": 18}, "files": [{"sha": "7f5f09aa6b6a97fab7eac8883efa261def1ee756", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -873,19 +873,12 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     // Return the visibility of the type alias's least visible component type when substituted\n     fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n                                     -> Option<ty::Visibility> {\n-        // We substitute type aliases only when determining impl publicity\n-        // FIXME: This will probably change and all type aliases will be substituted,\n-        // requires an amendment to RFC 136.\n-        if self.required_visibility != ty::Visibility::PrivateExternal {\n-            return None;\n-        }\n         // Type alias is considered public if the aliased type is\n         // public, even if the type alias itself is private. So, something\n         // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor {\n-                min_visibility: ty::Visibility::Public, ..*self\n-            };\n+            let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx,\n+                                                                       self.old_error_set);\n             check.visit_ty(ty);\n             // If a private type alias with default type parameters is used in public\n             // interface we must ensure, that the defaults are public if they are actually used."}, {"sha": "93fd36d37af3ce8b4be43df3e396a380a467eff3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -1744,6 +1744,7 @@ impl<'a> Resolver<'a> {\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n                     function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n+                    self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }"}, {"sha": "26ea4890b30bf1ef52339e66f118d9ba023a7375", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -36,8 +36,10 @@ use syntax_pos::{self, DUMMY_SP, Pos};\n use rustc_trans::back::link;\n use rustc::middle::cstore;\n use rustc::middle::privacy::AccessLevels;\n+use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::ty;\n@@ -1636,6 +1638,43 @@ impl PrimitiveType {\n     }\n }\n \n+\n+// Poor man's type parameter substitution at HIR level.\n+// Used to replace private type aliases in public signatures with their aliased types.\n+struct SubstAlias<'a, 'tcx: 'a> {\n+    tcx: &'a ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    // Table type parameter definition -> substituted type\n+    ty_substs: HashMap<Def, hir::Ty>,\n+    // Table node id of lifetime parameter definition -> substituted lifetime\n+    lt_substs: HashMap<ast::NodeId, hir::Lifetime>,\n+}\n+\n+impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n+    fn fold_ty(&mut self, ty: P<hir::Ty>) -> P<hir::Ty> {\n+        if let hir::TyPath(..) = ty.node {\n+            let def = self.tcx.expect_def(ty.id);\n+            if let Some(new_ty) = self.ty_substs.get(&def).cloned() {\n+                return P(new_ty);\n+            }\n+        }\n+        hir::fold::noop_fold_ty(ty, self)\n+    }\n+    fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n+        let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n+        match def {\n+            Some(DefEarlyBoundRegion(_, _, node_id)) |\n+            Some(DefLateBoundRegion(_, node_id)) |\n+            Some(DefFreeRegion(_, node_id)) => {\n+                if let Some(lt) = self.lt_substs.get(&node_id).cloned() {\n+                    return lt;\n+                }\n+            }\n+            _ => {}\n+        }\n+        hir::fold::noop_fold_lifetime(lt, self)\n+    }\n+}\n+\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n@@ -1665,8 +1704,46 @@ impl Clean<Type> for hir::Ty {\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(None, ref p) => {\n-                resolve_type(cx, p.clean(cx), self.id)\n+            TyPath(None, ref path) => {\n+                if let Some(tcx) = cx.tcx_opt() {\n+                    // Substitute private type aliases\n+                    let def = tcx.expect_def(self.id);\n+                    if let Def::TyAlias(def_id) = def {\n+                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                            if !cx.access_levels.borrow().is_exported(def_id) {\n+                                let item = tcx.map.expect_item(node_id);\n+                                if let hir::ItemTy(ref ty, ref generics) = item.node {\n+                                    let provided_params = &path.segments.last().unwrap().parameters;\n+                                    let mut ty_substs = HashMap::new();\n+                                    let mut lt_substs = HashMap::new();\n+                                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                                        if let Some(ty) = provided_params.types().get(i).cloned()\n+                                                                                        .cloned() {\n+                                            ty_substs.insert(ty_param_def, ty.unwrap());\n+                                        } else if let Some(default) = ty_param.default.clone() {\n+                                            ty_substs.insert(ty_param_def, default.unwrap());\n+                                        }\n+                                    }\n+                                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                                        if let Some(lt) = provided_params.lifetimes().get(i)\n+                                                                                     .cloned()\n+                                                                                     .cloned() {\n+                                            lt_substs.insert(lt_param.lifetime.id, lt);\n+                                        }\n+                                    }\n+                                    let mut subst_alias = SubstAlias {\n+                                        tcx: &tcx,\n+                                        ty_substs: ty_substs,\n+                                        lt_substs: lt_substs\n+                                    };\n+                                    return subst_alias.fold_ty(ty.clone()).clean(cx);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                resolve_type(cx, path.clean(cx), self.id)\n             }\n             TyPath(Some(ref qself), ref p) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();"}, {"sha": "6a756bfc7e3a607a4de23f716e66b6306b047b69", "filename": "src/test/compile-fail/private-in-public-warn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -205,11 +205,10 @@ mod aliases_pub {\n     }\n \n     pub fn f1(arg: PrivUseAlias) {} // OK\n+    pub fn f2(arg: PrivAlias) {} // OK\n \n     pub trait Tr1: PrivUseAliasTr {} // OK\n-    // This should be OK, if type aliases are substituted\n-    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} //~ WARN private type in public interface\n-        //~^ WARNING hard error\n+    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} // OK\n \n     impl PrivAlias {\n         pub fn f(arg: Priv) {} //~ WARN private type in public interface\n@@ -285,6 +284,8 @@ mod aliases_params {\n     struct Priv;\n     type PrivAliasGeneric<T = Priv> = T;\n     type Result<T> = ::std::result::Result<T, Priv>;\n+\n+    pub fn f1(arg: PrivAliasGeneric<u8>) {} // OK, not an error\n }\n \n #[rustc_error]"}, {"sha": "7d4dcfd3145abdd313a6663c8fd620579d88fd26", "filename": "src/test/compile-fail/private-in-public.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -105,8 +105,6 @@ mod aliases_pub {\n     }\n     impl PrivTr for Priv {}\n \n-    // This should be OK, if type aliases are substituted\n-    pub fn f2(arg: PrivAlias) {} //~ ERROR private type in public interface\n     // This should be OK, but associated type aliases are not substituted yet\n     pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n \n@@ -143,8 +141,6 @@ mod aliases_params {\n     type PrivAliasGeneric<T = Priv> = T;\n     type Result<T> = ::std::result::Result<T, Priv>;\n \n-    // This should be OK, if type aliases are substituted\n-    pub fn f1(arg: PrivAliasGeneric<u8>) {} //~ ERROR private type in public interface\n     pub fn f2(arg: PrivAliasGeneric) {} //~ ERROR private type in public interface\n     pub fn f3(arg: Result<u8>) {} //~ ERROR private type in public interface\n }"}, {"sha": "637190800012552b9b0b4e8f04aaf0545c4f233d", "filename": "src/test/rustdoc/private-type-alias.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f880588791930cb130071c2cb972fc3c3354ed/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprivate-type-alias.rs?ref=11f880588791930cb130071c2cb972fc3c3354ed", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type MyResultPriv<T> = Result<T, u16>;\n+pub type MyResultPub<T> = Result<T, u64>;\n+\n+// @has private_type_alias/fn.get_result_priv.html '//pre' 'Result<u8, u16>'\n+pub fn get_result_priv() -> MyResultPriv<u8> {\n+    panic!();\n+}\n+\n+// @has private_type_alias/fn.get_result_pub.html '//pre' 'MyResultPub<u32>'\n+pub fn get_result_pub() -> MyResultPub<u32> {\n+    panic!();\n+}\n+\n+pub type PubRecursive = u16;\n+type PrivRecursive3 = u8;\n+type PrivRecursive2 = PubRecursive;\n+type PrivRecursive1 = PrivRecursive3;\n+\n+// PrivRecursive1 is expanded twice and stops at u8\n+// PrivRecursive2 is expanded once and stops at public type alias PubRecursive\n+// @has private_type_alias/fn.get_result_recursive.html '//pre' '(u8, PubRecursive)'\n+pub fn get_result_recursive() -> (PrivRecursive1, PrivRecursive2) {\n+    panic!();\n+}\n+\n+type MyLifetimePriv<'a> = &'a isize;\n+\n+// @has private_type_alias/fn.get_lifetime_priv.html '//pre' \"&'static isize\"\n+pub fn get_lifetime_priv() -> MyLifetimePriv<'static> {\n+    panic!();\n+}"}]}