{"sha": "2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMWNmZTViNWIzYzMzYjcxMDAyZTcxYjdkMmU2ZDY1MDVkNTUxZjI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-29T12:43:03Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-26T22:36:12Z"}, "message": "Syntax for hir::Expr.", "tree": {"sha": "fc93efa42c12e1f053716ccd5b7245a5ff9e8cae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc93efa42c12e1f053716ccd5b7245a5ff9e8cae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "html_url": "https://github.com/rust-lang/rust/commit/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e0a1c09108b52e41113520c7fa516480a8b67f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0a1c09108b52e41113520c7fa516480a8b67f9", "html_url": "https://github.com/rust-lang/rust/commit/3e0a1c09108b52e41113520c7fa516480a8b67f9"}], "stats": {"total": 696, "additions": 355, "deletions": 341}, "files": [{"sha": "e93cddf5799043dca80a7b71c886422c730c2c70", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -131,7 +131,7 @@ macro_rules! arena_types {\n             [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n             [] impl_item_ref: rustc::hir::ImplItemRef,\n             [few] macro_def: rustc::hir::MacroDef<$tcx>,\n-            [] param: rustc::hir::Param,\n+            [] param: rustc::hir::Param<$tcx>,\n             [] path: rustc::hir::Path,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,"}, {"sha": "511244ca516f59447d51c5977eb3d779ea8c5900", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -458,7 +458,7 @@ impl CheckAttrVisitor<'tcx> {\n             .emit();\n     }\n \n-    fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n+    fn check_stmt_attributes(&self, stmt: &hir::Stmt<'_>) {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n@@ -477,7 +477,7 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_expr_attributes(&self, expr: &hir::Expr) {\n+    fn check_expr_attributes(&self, expr: &hir::Expr<'_>) {\n         let target = match expr.kind {\n             hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n@@ -537,12 +537,12 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_impl_item(self, impl_item)\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n         self.check_stmt_attributes(stmt);\n         intravisit::walk_stmt(self, stmt)\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         self.check_expr_attributes(expr);\n         intravisit::walk_expr(self, expr)\n     }"}, {"sha": "5b8612ede35e1b3885d1fd646aa0f4dc8a058115", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -212,7 +212,7 @@ pub trait Visitor<'v>: Sized {\n         }\n     }\n \n-    fn visit_param(&mut self, param: &'v Param) {\n+    fn visit_param(&mut self, param: &'v Param<'v>) {\n         walk_param(self, param)\n     }\n \n@@ -253,25 +253,25 @@ pub trait Visitor<'v>: Sized {\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem<'v>) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_local(&mut self, l: &'v Local) {\n+    fn visit_local(&mut self, l: &'v Local<'v>) {\n         walk_local(self, l)\n     }\n-    fn visit_block(&mut self, b: &'v Block) {\n+    fn visit_block(&mut self, b: &'v Block<'v>) {\n         walk_block(self, b)\n     }\n-    fn visit_stmt(&mut self, s: &'v Stmt) {\n+    fn visit_stmt(&mut self, s: &'v Stmt<'v>) {\n         walk_stmt(self, s)\n     }\n-    fn visit_arm(&mut self, a: &'v Arm) {\n+    fn visit_arm(&mut self, a: &'v Arm<'v>) {\n         walk_arm(self, a)\n     }\n-    fn visit_pat(&mut self, p: &'v Pat) {\n+    fn visit_pat(&mut self, p: &'v Pat<'v>) {\n         walk_pat(self, p)\n     }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n-    fn visit_expr(&mut self, ex: &'v Expr) {\n+    fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n     fn visit_ty(&mut self, t: &'v Ty) {\n@@ -409,7 +409,7 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n     visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n@@ -462,7 +462,7 @@ where\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n     walk_list!(visitor, visit_attribute, &param.attrs);\n@@ -684,7 +684,7 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V, type_binding\n     }\n }\n \n-pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n+pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n     visitor.visit_id(pattern.hir_id);\n     match pattern.kind {\n         PatKind::TupleStruct(ref qpath, ref children, _) => {\n@@ -955,13 +955,13 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v\n     walk_list!(visitor, visit_attribute, struct_field.attrs);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n     visitor.visit_id(block.hir_id);\n     walk_list!(visitor, visit_stmt, &block.stmts);\n     walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n     visitor.visit_id(statement.hir_id);\n     match statement.kind {\n         StmtKind::Local(ref local) => visitor.visit_local(local),\n@@ -977,7 +977,7 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n     visitor.visit_nested_body(constant.body);\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.kind {\n@@ -1087,7 +1087,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     visitor.visit_id(arm.hir_id);\n     visitor.visit_pat(&arm.pat);\n     if let Some(ref g) = arm.guard {"}, {"sha": "4bc41c444e62363890df49b9c56b93b2b356395d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -2022,7 +2022,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[NodeId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n         let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n@@ -2586,7 +2586,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block<'hir>> {\n         let mut stmts = vec![];\n         let mut expr = None;\n \n@@ -2614,12 +2614,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Lowers a block directly to an expression, presuming that it\n     /// has no attributes and is not targeted by a `break`.\n-    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n+    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr<'hir> {\n         let block = self.lower_block(b, false);\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n+    fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat<'hir>> {\n         let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n@@ -2700,7 +2700,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         pats: &[AstP<Pat>],\n         ctx: &str,\n-    ) -> (HirVec<P<hir::Pat>>, Option<usize>) {\n+    ) -> (HirVec<P<hir::Pat<'hir>>>, Option<usize>) {\n         let mut elems = Vec::with_capacity(pats.len());\n         let mut rest = None;\n \n@@ -2737,7 +2737,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n     /// this is interpreted as a sub-slice pattern semantically.\n     /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n-    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind {\n+    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind<'hir> {\n         let mut before = Vec::new();\n         let mut after = Vec::new();\n         let mut slice = None;\n@@ -2796,8 +2796,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &Pat,\n         binding_mode: &BindingMode,\n         ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat>>,\n-    ) -> hir::PatKind {\n+        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat<'hir>>>,\n+    ) -> hir::PatKind<'hir> {\n         match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n             // `None` can occur in body-less function signatures\n             res @ None | res @ Some(Res::Local(_)) => {\n@@ -2824,12 +2824,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> P<hir::Pat> {\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> P<hir::Pat<'hir>> {\n         self.pat_with_node_id_of(p, hir::PatKind::Wild)\n     }\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind) -> P<hir::Pat> {\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> P<hir::Pat<'hir>> {\n         P(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n     }\n \n@@ -2843,7 +2843,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Used to ban the `..` pattern in places it shouldn't be semantically.\n-    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind {\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n         self.diagnostic()\n             .struct_span_err(sp, \"`..` patterns are not allowed here\")\n             .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n@@ -2869,11 +2869,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt; 1]> {\n+    fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n         let kind = match s.kind {\n             StmtKind::Local(ref l) => {\n                 let (l, item_ids) = self.lower_local(l);\n-                let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n+                let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n                         let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n@@ -2944,36 +2944,36 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     // Helper methods for building HIR.\n \n-    fn stmt(&mut self, span: Span, kind: hir::StmtKind) -> hir::Stmt {\n+    fn stmt(&mut self, span: Span, kind: hir::StmtKind<'hir>) -> hir::Stmt<'hir> {\n         hir::Stmt { span, kind, hir_id: self.next_id() }\n     }\n \n-    fn stmt_expr(&mut self, span: Span, expr: hir::Expr) -> hir::Stmt {\n+    fn stmt_expr(&mut self, span: Span, expr: hir::Expr<'hir>) -> hir::Stmt<'hir> {\n         self.stmt(span, hir::StmtKind::Expr(P(expr)))\n     }\n \n     fn stmt_let_pat(\n         &mut self,\n         attrs: AttrVec,\n         span: Span,\n-        init: Option<P<hir::Expr>>,\n-        pat: P<hir::Pat>,\n+        init: Option<P<hir::Expr<'hir>>>,\n+        pat: P<hir::Pat<'hir>>,\n         source: hir::LocalSource,\n-    ) -> hir::Stmt {\n+    ) -> hir::Stmt<'hir> {\n         let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(P(local)))\n     }\n \n-    fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n+    fn block_expr(&mut self, expr: P<hir::Expr<'hir>>) -> hir::Block<'hir> {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n \n     fn block_all(\n         &mut self,\n         span: Span,\n-        stmts: hir::HirVec<hir::Stmt>,\n-        expr: Option<P<hir::Expr>>,\n-    ) -> hir::Block {\n+        stmts: hir::HirVec<hir::Stmt<'hir>>,\n+        expr: Option<P<hir::Expr<'hir>>>,\n+    ) -> hir::Block<'hir> {\n         hir::Block {\n             stmts,\n             expr,\n@@ -2985,33 +2985,33 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Constructs a `true` or `false` literal pattern.\n-    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat> {\n+    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat<'hir>> {\n         let expr = self.expr_bool(span, val);\n         self.pat(span, hir::PatKind::Lit(P(expr)))\n     }\n \n-    fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    fn pat_ok(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n         self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n     }\n \n-    fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    fn pat_err(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n         self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n     }\n \n-    fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    fn pat_some(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n         self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n     }\n \n-    fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n+    fn pat_none(&mut self, span: Span) -> P<hir::Pat<'hir>> {\n         self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        subpats: hir::HirVec<P<hir::Pat>>,\n-    ) -> P<hir::Pat> {\n+        subpats: hir::HirVec<P<hir::Pat<'hir>>>,\n+    ) -> P<hir::Pat<'hir>> {\n         let path = self.std_path(span, components, None, true);\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n@@ -3022,7 +3022,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat>, hir::HirId) {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat<'hir>>, hir::HirId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -3031,7 +3031,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> (P<hir::Pat>, hir::HirId) {\n+    ) -> (P<hir::Pat<'hir>>, hir::HirId) {\n         let hir_id = self.next_id();\n \n         (\n@@ -3044,11 +3044,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n+    fn pat_wild(&mut self, span: Span) -> P<hir::Pat<'hir>> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n-    fn pat(&mut self, span: Span, kind: hir::PatKind) -> P<hir::Pat> {\n+    fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> P<hir::Pat<'hir>> {\n         P(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n "}, {"sha": "19a732a864a640b0c33cb5ab30e703fb82e8d7e4", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -13,12 +13,12 @@ use syntax::symbol::{sym, Symbol};\n \n use rustc_error_codes::*;\n \n-impl LoweringContext<'_, '_> {\n-    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr<'hir>> {\n         exprs.iter().map(|x| self.lower_expr(x)).collect()\n     }\n \n-    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         let kind = match e.kind {\n             ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n@@ -237,7 +237,7 @@ impl LoweringContext<'_, '_> {\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind<'hir> {\n         // If we got here, the `let` expression is not allowed.\n \n         if self.sess.opts.unstable_features.is_nightly_build() {\n@@ -286,7 +286,7 @@ impl LoweringContext<'_, '_> {\n         cond: &Expr,\n         then: &Block,\n         else_opt: Option<&Expr>,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // FIXME(#53667): handle lowering of && and parens.\n \n         // `_ => else_block` where `else_block` is `{}` if there's `None`:\n@@ -331,7 +331,7 @@ impl LoweringContext<'_, '_> {\n         cond: &Expr,\n         body: &Block,\n         opt_label: Option<Label>,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // FIXME(#53667): handle lowering of && and parens.\n \n         // Note that the block AND the condition are evaluated in the loop scope.\n@@ -398,7 +398,7 @@ impl LoweringContext<'_, '_> {\n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n     /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n     /// and save the block id to use it as a break target for desugaring of the `?` operator.\n-    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n+    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind<'hir> {\n         self.with_catch_scope(body.id, |this| {\n             let mut block = this.lower_block(body, true).into_inner();\n \n@@ -411,7 +411,7 @@ impl LoweringContext<'_, '_> {\n             // Final expression of the block (if present) or `()` with span at the end of block\n             let tail_expr = block.expr.take().map_or_else(\n                 || this.expr_unit(this.sess.source_map().end_point(try_span)),\n-                |x: P<hir::Expr>| x.into_inner(),\n+                |x: P<hir::Expr<'hir>>| x.into_inner(),\n             );\n \n             let ok_wrapped_span =\n@@ -433,15 +433,15 @@ impl LoweringContext<'_, '_> {\n         &mut self,\n         method: Symbol,\n         method_span: Span,\n-        expr: hir::Expr,\n+        expr: hir::Expr<'hir>,\n         overall_span: Span,\n-    ) -> P<hir::Expr> {\n+    ) -> P<hir::Expr<'hir>> {\n         let path = &[sym::ops, sym::Try, method];\n         let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n         P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n     }\n \n-    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n+    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n@@ -462,8 +462,8 @@ impl LoweringContext<'_, '_> {\n         ret_ty: Option<AstP<Ty>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n-        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n-    ) -> hir::ExprKind {\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n+    ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(ty),\n             None => FunctionRetTy::Default(span),\n@@ -518,7 +518,7 @@ impl LoweringContext<'_, '_> {\n     ///     }\n     /// }\n     /// ```\n-    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind {\n+    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind<'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n@@ -641,7 +641,7 @@ impl LoweringContext<'_, '_> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n@@ -699,7 +699,7 @@ impl LoweringContext<'_, '_> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         let outer_decl =\n             FnDecl { inputs: decl.inputs.clone(), output: FunctionRetTy::Default(fn_decl_span) };\n         // We need to lower the declaration outside the new scope, because we\n@@ -743,7 +743,7 @@ impl LoweringContext<'_, '_> {\n     }\n \n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n-    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind {\n+    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n         let id = self.next_id();\n         let e1 = self.lower_expr(e1);\n         let e2 = self.lower_expr(e2);\n@@ -762,7 +762,7 @@ impl LoweringContext<'_, '_> {\n         e1: Option<&Expr>,\n         e2: Option<&Expr>,\n         lims: RangeLimits,\n-    ) -> hir::ExprKind {\n+    ) -> hir::ExprKind<'hir> {\n         use syntax::ast::RangeLimits::*;\n \n         let path = match (e1, e2, lims) {\n@@ -786,7 +786,7 @@ impl LoweringContext<'_, '_> {\n                 let ident = Ident::new(Symbol::intern(s), e.span);\n                 self.field(ident, expr, e.span)\n             })\n-            .collect::<P<[hir::Field]>>();\n+            .collect::<P<[hir::Field<'hir>]>>();\n \n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n@@ -893,7 +893,7 @@ impl LoweringContext<'_, '_> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind {\n+    fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::InlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n             outputs: asm\n@@ -921,7 +921,7 @@ impl LoweringContext<'_, '_> {\n         hir::ExprKind::InlineAsm(P(hir_asm))\n     }\n \n-    fn lower_field(&mut self, f: &Field) -> hir::Field {\n+    fn lower_field(&mut self, f: &Field) -> hir::Field<'hir> {\n         hir::Field {\n             hir_id: self.next_id(),\n             ident: f.ident,\n@@ -931,7 +931,7 @@ impl LoweringContext<'_, '_> {\n         }\n     }\n \n-    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind {\n+    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind<'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n@@ -973,7 +973,7 @@ impl LoweringContext<'_, '_> {\n         head: &Expr,\n         body: &Block,\n         opt_label: Option<Label>,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         // expand <head>\n         let mut head = self.lower_expr(head);\n         let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n@@ -1102,7 +1102,7 @@ impl LoweringContext<'_, '_> {\n     ///                 return Try::from_error(From::from(err)),\n     /// }\n     /// ```\n-    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind {\n+    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind<'hir> {\n         let unstable_span = self.mark_span_with_reason(\n             DesugaringKind::QuestionMark,\n             span,\n@@ -1191,7 +1191,7 @@ impl LoweringContext<'_, '_> {\n     // =========================================================================\n \n     /// Constructs a `true` or `false` literal expression.\n-    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr {\n+    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr<'hir> {\n         let lit = Spanned { span, node: LitKind::Bool(val) };\n         self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n     }\n@@ -1205,49 +1205,49 @@ impl LoweringContext<'_, '_> {\n     pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n-        expr: P<hir::Expr>,\n+        expr: P<hir::Expr<'hir>>,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n \n     fn expr_match(\n         &mut self,\n         span: Span,\n-        arg: P<hir::Expr>,\n-        arms: hir::HirVec<hir::Arm>,\n+        arg: P<hir::Expr<'hir>>,\n+        arms: hir::HirVec<hir::Arm<'hir>>,\n         source: hir::MatchSource,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr<'hir>> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr<'_>>) -> hir::Expr<'_> {\n         self.expr(\n             span,\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n             ThinVec::new(),\n         )\n     }\n \n-    fn expr_unit(&mut self, sp: Span) -> hir::Expr {\n+    fn expr_unit(&mut self, sp: Span) -> hir::Expr<'hir> {\n         self.expr_tuple(sp, hir_vec![])\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> hir::Expr {\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr<'hir>>) -> hir::Expr<'hir> {\n         self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n     }\n \n     fn expr_call(\n         &mut self,\n         span: Span,\n-        e: P<hir::Expr>,\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::Expr {\n+        e: P<hir::Expr<'hir>>,\n+        args: hir::HirVec<hir::Expr<'hir>>,\n+    ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n     }\n \n@@ -1256,8 +1256,8 @@ impl LoweringContext<'_, '_> {\n         &mut self,\n         span: Span,\n         path_components: &[Symbol],\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::Expr {\n+        args: hir::HirVec<hir::Expr<'hir>>,\n+    ) -> hir::Expr<'hir> {\n         let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n         self.expr_call(span, path, args)\n     }\n@@ -1277,8 +1277,8 @@ impl LoweringContext<'_, '_> {\n         span: Span,\n         ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n-        args: hir::HirVec<hir::Expr>,\n-    ) -> hir::ExprKind {\n+        args: hir::HirVec<hir::Expr<'hir>>,\n+    ) -> hir::ExprKind<'hir> {\n         let ty_path = P(self.std_path(span, ty_path_components, None, false));\n         let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n         let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n@@ -1293,12 +1293,17 @@ impl LoweringContext<'_, '_> {\n         components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);\n         self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))), attrs)\n     }\n \n-    pub(super) fn expr_ident(&mut self, sp: Span, ident: Ident, binding: hir::HirId) -> hir::Expr {\n+    pub(super) fn expr_ident(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+    ) -> hir::Expr<'hir> {\n         self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n     }\n \n@@ -1308,7 +1313,7 @@ impl LoweringContext<'_, '_> {\n         ident: Ident,\n         binding: hir::HirId,\n         attrs: AttrVec,\n-    ) -> hir::Expr {\n+    ) -> hir::Expr<'hir> {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             P(hir::Path {\n@@ -1321,7 +1326,7 @@ impl LoweringContext<'_, '_> {\n         self.expr(span, expr_path, attrs)\n     }\n \n-    fn expr_unsafe(&mut self, expr: P<hir::Expr>) -> hir::Expr {\n+    fn expr_unsafe(&mut self, expr: P<hir::Expr<'hir>>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         let span = expr.span;\n         self.expr(\n@@ -1341,24 +1346,29 @@ impl LoweringContext<'_, '_> {\n         )\n     }\n \n-    fn expr_block_empty(&mut self, span: Span) -> hir::Expr {\n+    fn expr_block_empty(&mut self, span: Span) -> hir::Expr<'hir> {\n         let blk = self.block_all(span, hir_vec![], None);\n         self.expr_block(P(blk), ThinVec::new())\n     }\n \n-    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: AttrVec) -> hir::Expr {\n+    pub(super) fn expr_block(&mut self, b: P<hir::Block<'hir>>, attrs: AttrVec) -> hir::Expr<'hir> {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n-    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind, attrs: AttrVec) -> hir::Expr {\n+    pub(super) fn expr(\n+        &mut self,\n+        span: Span,\n+        kind: hir::ExprKind<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n         hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n \n-    fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+    fn field(&mut self, ident: Ident, expr: P<hir::Expr<'hir>>, span: Span) -> hir::Field<'hir> {\n         hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n-    fn arm(&mut self, pat: P<hir::Pat>, expr: P<hir::Expr>) -> hir::Arm {\n+    fn arm(&mut self, pat: P<hir::Pat<'hir>>, expr: P<hir::Expr<'hir>>) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "8016ab5c592c53cc8bb5c87703409b6f0976ad3e", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -840,7 +840,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    fn expr_err(&mut self, span: Span) -> hir::Expr {\n+    fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n@@ -981,7 +981,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn record_body(&mut self, params: &'hir [hir::Param], value: hir::Expr) -> hir::BodyId {\n+    fn record_body(\n+        &mut self,\n+        params: &'hir [hir::Param<'hir>],\n+        value: hir::Expr<'hir>,\n+    ) -> hir::BodyId {\n         let body = hir::Body { generator_kind: self.generator_kind, params, value };\n         let id = body.id();\n         self.bodies.insert(id, body);\n@@ -990,7 +994,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param], hir::Expr),\n+        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n         let (parameters, result) = f(self);\n@@ -999,7 +1003,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body_id\n     }\n \n-    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+    fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n         hir::Param {\n             attrs: self.lower_attrs(&param.attrs),\n             hir_id: self.lower_node_id(param.id),\n@@ -1011,7 +1015,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_fn_body(\n         &mut self,\n         decl: &FnDecl,\n-        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::BodyId {\n         self.lower_body(|this| {\n             (\n@@ -1030,7 +1034,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.lower_fn_body(decl, |this| this.lower_block_expr_opt(span, body))\n     }\n \n-    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr {\n+    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n             None => self.expr_err(span),\n@@ -1062,8 +1066,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         self.lower_body(|this| {\n-            let mut parameters: Vec<hir::Param> = Vec::new();\n-            let mut statements: Vec<hir::Stmt> = Vec::new();\n+            let mut parameters: Vec<hir::Param<'hir>> = Vec::new();\n+            let mut statements: Vec<hir::Stmt<'hir>> = Vec::new();\n \n             // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions."}, {"sha": "7701c33f9162a5352951381faaaace60e542faf2", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -66,7 +66,7 @@ impl MaybeFnLike for ast::TraitItem<'_> {\n     }\n }\n \n-impl MaybeFnLike for ast::Expr {\n+impl MaybeFnLike for ast::Expr<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n             ast::ExprKind::Closure(..) => true,\n@@ -81,7 +81,7 @@ impl MaybeFnLike for ast::Expr {\n #[derive(Copy, Clone)]\n pub enum Code<'a> {\n     FnLike(FnLikeNode<'a>),\n-    Expr(&'a Expr),\n+    Expr(&'a Expr<'a>),\n }\n \n impl<'a> Code<'a> {"}, {"sha": "610be0a0753f05aed1831e49d6135147d61fa4f6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_param(&mut self, param: &'hir Param) {\n+    fn visit_param(&mut self, param: &'hir Param<'hir>) {\n         let node = Node::Param(param);\n         self.insert(param.pat.span, param.hir_id, node);\n         self.with_parent(param.hir_id, |this| {\n@@ -434,7 +434,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &'hir Pat) {\n+    fn visit_pat(&mut self, pat: &'hir Pat<'hir>) {\n         let node =\n             if let PatKind::Binding(..) = pat.kind { Node::Binding(pat) } else { Node::Pat(pat) };\n         self.insert(pat.span, pat.hir_id, node);\n@@ -444,7 +444,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_arm(&mut self, arm: &'hir Arm) {\n+    fn visit_arm(&mut self, arm: &'hir Arm<'hir>) {\n         let node = Node::Arm(arm);\n \n         self.insert(arm.span, arm.hir_id, node);\n@@ -462,15 +462,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_expr(&mut self, expr: &'hir Expr) {\n+    fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n         self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n \n         self.with_parent(expr.hir_id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'hir Stmt<'hir>) {\n         self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n \n         self.with_parent(stmt.hir_id, |this| {\n@@ -513,14 +513,14 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n \n-    fn visit_block(&mut self, block: &'hir Block) {\n+    fn visit_block(&mut self, block: &'hir Block<'hir>) {\n         self.insert(block.span, block.hir_id, Node::Block(block));\n         self.with_parent(block.hir_id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n-    fn visit_local(&mut self, l: &'hir Local) {\n+    fn visit_local(&mut self, l: &'hir Local<'hir>) {\n         self.insert(l.span, l.hir_id, Node::Local(l));\n         self.with_parent(l.hir_id, |this| intravisit::walk_local(this, l))\n     }"}, {"sha": "96ea602c30181bf6c9c6985ee22ef5fed91f5baa", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -782,7 +782,7 @@ impl<'hir> Map<'hir> {\n     ///\n     /// Used by error reporting when there's a type error in a match arm caused by the `match`\n     /// expression needing to be unit.\n-    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&Expr> {\n+    pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&Expr<'hir>> {\n         for (_, node) in ParentHirIterator::new(hir_id, &self) {\n             match node {\n                 Node::Item(_) | Node::ForeignItem(_) | Node::TraitItem(_) | Node::ImplItem(_) => {\n@@ -925,7 +925,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: HirId) -> &'hir Expr {\n+    pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             // read recorded by find\n             Some(Node::Expr(expr)) => expr,"}, {"sha": "4f3dec00e3c83f7fb9d1b55a09d71d51479514d5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 96, "deletions": 97, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -832,12 +832,12 @@ pub struct MacroDef<'hir> {\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Block {\n+pub struct Block<'hir> {\n     /// Statements in a block.\n-    pub stmts: HirVec<Stmt>,\n+    pub stmts: &'hir [Stmt<'hir>],\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n-    pub expr: Option<P<Expr>>,\n+    pub expr: Option<&'hir Expr<'hir>>,\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n@@ -850,14 +850,14 @@ pub struct Block {\n }\n \n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Pat {\n+pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n-    pub kind: PatKind,\n+    pub kind: PatKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Pat {\n+impl fmt::Debug for Pat<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -868,9 +868,9 @@ impl fmt::Debug for Pat {\n     }\n }\n \n-impl Pat {\n+impl Pat<'_> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_short_(&self, it: &mut impl FnMut(&Pat) -> bool) -> bool {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n@@ -893,12 +893,12 @@ impl Pat {\n     /// Note that when visiting e.g. `Tuple(ps)`,\n     /// if visiting `ps[0]` returns `false`,\n     /// then `ps[1]` will not be visited.\n-    pub fn walk_short(&self, mut it: impl FnMut(&Pat) -> bool) -> bool {\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'_>) -> bool) -> bool {\n         self.walk_short_(&mut it)\n     }\n \n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_(&self, it: &mut impl FnMut(&Pat) -> bool) {\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) {\n         if !it(self) {\n             return;\n         }\n@@ -918,14 +918,14 @@ impl Pat {\n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If `it(pat)` returns `false`, the children are not visited.\n-    pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'_>) -> bool) {\n         self.walk_(&mut it)\n     }\n \n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If you always want to recurse, prefer this method over `walk`.\n-    pub fn walk_always(&self, mut it: impl FnMut(&Pat)) {\n+    pub fn walk_always(&self, mut it: impl FnMut(&Pat<'_>)) {\n         self.walk(|p| {\n             it(p);\n             true\n@@ -939,14 +939,14 @@ impl Pat {\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct FieldPat {\n+pub struct FieldPat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// The identifier for the field.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// The pattern the field is destructured to.\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     pub is_shorthand: bool,\n     pub span: Span,\n }\n@@ -991,48 +991,48 @@ impl fmt::Display for RangeEnd {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum PatKind {\n+pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `HirId` is the canonical ID for the variable being bound,\n     /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n-    Binding(BindingAnnotation, HirId, Ident, Option<P<Pat>>),\n+    Binding(BindingAnnotation, HirId, Ident, Option<&'hir Pat<'hir>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, HirVec<FieldPat>, bool),\n+    Struct(QPath, &'hir [FieldPat<'hir>], bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n+    TupleStruct(QPath, &'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(HirVec<P<Pat>>),\n+    Or(&'hir [&'hir Pat<'hir>]),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n     /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    Tuple(HirVec<P<Pat>>, Option<usize>),\n+    Tuple(&'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// A `box` pattern.\n-    Box(P<Pat>),\n+    Box(&'hir Pat<'hir>),\n \n     /// A reference pattern (e.g., `&mut (a, b)`).\n-    Ref(P<Pat>, Mutability),\n+    Ref(&'hir Pat<'hir>, Mutability),\n \n     /// A literal.\n-    Lit(P<Expr>),\n+    Lit(&'hir Expr<'hir>),\n \n     /// A range pattern (e.g., `1..=2` or `1..2`).\n-    Range(P<Expr>, P<Expr>, RangeEnd),\n+    Range(&'hir Expr<'hir>, &'hir Expr<'hir>, RangeEnd),\n \n     /// A slice pattern, `[before_0, ..., before_n, (slice, after_0, ..., after_n)?]`.\n     ///\n@@ -1043,7 +1043,7 @@ pub enum PatKind {\n     /// ```\n     /// PatKind::Slice([Binding(a), Binding(b)], Some(Wild), [Binding(c), Binding(d)])\n     /// ```\n-    Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n+    Slice(&'hir [&'hir Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [&'hir Pat<'hir>]),\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -1210,13 +1210,13 @@ impl UnOp {\n \n /// A statement.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Stmt {\n+pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n-    pub kind: StmtKind,\n+    pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Stmt {\n+impl fmt::Debug for Stmt<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -1229,22 +1229,22 @@ impl fmt::Debug for Stmt {\n \n /// The contents of a statement.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub enum StmtKind {\n+pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n-    Local(P<Local>),\n+    Local(&'hir Local<'hir>),\n \n     /// An item binding.\n     Item(ItemId),\n \n     /// An expression without a trailing semi-colon (must have unit type).\n-    Expr(P<Expr>),\n+    Expr(&'hir Expr<'hir>),\n \n     /// An expression with a trailing semi-colon (may have any type).\n-    Semi(P<Expr>),\n+    Semi(&'hir Expr<'hir>),\n }\n \n-impl StmtKind {\n-    pub fn attrs(&self) -> &[Attribute] {\n+impl StmtKind<'hir> {\n+    pub fn attrs(&self) -> &'hir [Attribute] {\n         match *self {\n             StmtKind::Local(ref l) => &l.attrs,\n             StmtKind::Item(_) => &[],\n@@ -1255,12 +1255,12 @@ impl StmtKind {\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Local {\n-    pub pat: P<Pat>,\n+pub struct Local<'hir> {\n+    pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n-    pub ty: Option<P<Ty>>,\n+    pub ty: Option<&'hir Ty>,\n     /// Initializer expression to set the value, if any.\n-    pub init: Option<P<Expr>>,\n+    pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: AttrVec,\n@@ -1272,30 +1272,30 @@ pub struct Local {\n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arm {\n+pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     /// If this pattern and the optional guard matches, then `body` is evaluated.\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     /// Optional guard clause.\n-    pub guard: Option<Guard>,\n+    pub guard: Option<Guard<'hir>>,\n     /// The expression the arm evaluates to if this arm matches.\n-    pub body: P<Expr>,\n+    pub body: &'hir Expr<'hir>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum Guard {\n-    If(P<Expr>),\n+pub enum Guard<'hir> {\n+    If(&'hir Expr<'hir>),\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Field {\n+pub struct Field<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub ident: Ident,\n-    pub expr: P<Expr>,\n+    pub expr: &'hir Expr<'hir>,\n     pub span: Span,\n     pub is_shorthand: bool,\n }\n@@ -1342,8 +1342,8 @@ pub struct BodyId {\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body<'hir> {\n-    pub params: &'hir [Param],\n-    pub value: Expr,\n+    pub params: &'hir [Param<'hir>],\n+    pub value: Expr<'hir>,\n     pub generator_kind: Option<GeneratorKind>,\n }\n \n@@ -1443,18 +1443,18 @@ pub struct AnonConst {\n \n /// An expression.\n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Expr {\n+pub struct Expr<'hir> {\n     pub hir_id: HirId,\n-    pub kind: ExprKind,\n+    pub kind: ExprKind<'hir>,\n     pub attrs: AttrVec,\n     pub span: Span,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Expr, 64);\n+static_assert_size!(Expr<'static>, 64);\n \n-impl Expr {\n+impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n@@ -1563,7 +1563,7 @@ impl Expr {\n     }\n }\n \n-impl fmt::Debug for Expr {\n+impl fmt::Debug for Expr<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n@@ -1579,7 +1579,7 @@ impl fmt::Debug for Expr {\n ///\n /// FIXME(#60607): This function is a hack. If and when we have `QPath::Lang(...)`,\n /// we can use that instead as simpler, more reliable mechanism, as opposed to using `SourceMap`.\n-pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n+pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     // Returns whether the given path represents a (desugared) range,\n     // either in std or core, i.e. has either a `::std::ops::Range` or\n     // `::core::ops::Range` prefix.\n@@ -1637,18 +1637,18 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr) -> bool {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ExprKind {\n+pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n-    Box(P<Expr>),\n+    Box(&'hir Expr<'hir>),\n     /// An array (e.g., `[a, b, c, d]`).\n-    Array(HirVec<Expr>),\n+    Array(&'hir [Expr<'hir>]),\n     /// A function call.\n     ///\n     /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, HirVec<Expr>),\n+    Call(&'hir Expr<'hir>, &'hir [Expr<'hir>]),\n     /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n@@ -1663,83 +1663,82 @@ pub enum ExprKind {\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n-    MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n+    MethodCall(&'hir PathSegment, Span, &'hir [Expr<'hir>]),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(HirVec<Expr>),\n+    Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n-    Binary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, &'hir Expr<'hir>, &'hir Expr<'hir>),\n     /// A unary operation (e.g., `!x`, `*x`).\n-    Unary(UnOp, P<Expr>),\n+    Unary(UnOp, &'hir Expr<'hir>),\n     /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n     /// A cast (e.g., `foo as f64`).\n-    Cast(P<Expr>, P<Ty>),\n+    Cast(&'hir Expr<'hir>, &'hir Ty),\n     /// A type reference (e.g., `Foo`).\n-    Type(P<Expr>, P<Ty>),\n+    Type(&'hir Expr<'hir>, &'hir Ty),\n     /// Wraps the expression in a terminating scope.\n     /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n     ///\n     /// This construct only exists to tweak the drop order in HIR lowering.\n     /// An example of that is the desugaring of `for` loops.\n-    DropTemps(P<Expr>),\n+    DropTemps(&'hir Expr<'hir>),\n     /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// I.e., `'label: loop { <block> }`.\n-    Loop(P<Block>, Option<Label>, LoopSource),\n+    Loop(&'hir Block<'hir>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    Match(P<Expr>, HirVec<Arm>, MatchSource),\n+    Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n     /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<Movability>`.\n-    Closure(CaptureBy, P<FnDecl>, BodyId, Span, Option<Movability>),\n+    Closure(CaptureBy, &'hir FnDecl, BodyId, Span, Option<Movability>),\n     /// A block (e.g., `'label: { ... }`).\n-    Block(P<Block>, Option<Label>),\n+    Block(&'hir Block<'hir>, Option<Label>),\n \n     /// An assignment (e.g., `a = foo()`).\n-    /// The `Span` argument is the span of the `=` token.\n-    Assign(P<Expr>, P<Expr>, Span),\n+    Assign(&'hir Expr<'hir>, &'hir Expr<'hir>, Span),\n     /// An assignment with an operator.\n     ///\n     /// E.g., `a += 1`.\n-    AssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, &'hir Expr<'hir>, &'hir Expr<'hir>),\n     /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct or tuple field.\n-    Field(P<Expr>, Ident),\n+    Field(&'hir Expr<'hir>, Ident),\n     /// An indexing operation (`foo[2]`).\n-    Index(P<Expr>, P<Expr>),\n+    Index(&'hir Expr<'hir>, &'hir Expr<'hir>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (i.e., `&a`, `&mut a`, `&raw const a`, or `&raw mut a`).\n-    AddrOf(BorrowKind, Mutability, P<Expr>),\n+    /// A referencing operation (i.e., `&a` or `&mut a`).\n+    AddrOf(BorrowKind, &'hir Expr<'hir>),\n     /// A `break`, with an optional label to break.\n-    Break(Destination, Option<P<Expr>>),\n+    Break(Destination, Option<&'hir Expr<'hir>>),\n     /// A `continue`, with an optional label.\n     Continue(Destination),\n     /// A `return`, with an optional value to be returned.\n-    Ret(Option<P<Expr>>),\n+    Ret(Option<&'hir Expr<'hir>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    InlineAsm(P<InlineAsm>),\n+    InlineAsm(&'hir InlineAsm<'hir>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n     /// where `base` is the `Option<Expr>`.\n-    Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n+    Struct(&'hir QPath, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// E.g., `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    Repeat(P<Expr>, AnonConst),\n+    Repeat(&'hir Expr<'hir>, AnonConst),\n \n     /// A suspension point for generators (i.e., `yield <expr>`).\n-    Yield(P<Expr>, YieldSource),\n+    Yield(&'hir Expr<'hir>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n@@ -2159,18 +2158,18 @@ pub struct InlineAsmInner {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct InlineAsm {\n+pub struct InlineAsm<'hir> {\n     pub inner: InlineAsmInner,\n-    pub outputs_exprs: HirVec<Expr>,\n-    pub inputs_exprs: HirVec<Expr>,\n+    pub outputs_exprs: &'hir [Expr<'hir>],\n+    pub inputs_exprs: &'hir [Expr<'hir>],\n }\n \n /// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Param {\n-    pub attrs: HirVec<Attribute>,\n+pub struct Param<'hir> {\n+    pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n-    pub pat: P<Pat>,\n+    pub pat: &'hir Pat<'hir>,\n     pub span: Span,\n }\n \n@@ -2828,24 +2827,24 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Param(&'hir Param),\n+    Param(&'hir Param<'hir>),\n     Item(&'hir Item<'hir>),\n     ForeignItem(&'hir ForeignItem<'hir>),\n     TraitItem(&'hir TraitItem<'hir>),\n     ImplItem(&'hir ImplItem<'hir>),\n     Variant(&'hir Variant<'hir>),\n     Field(&'hir StructField<'hir>),\n     AnonConst(&'hir AnonConst),\n-    Expr(&'hir Expr),\n-    Stmt(&'hir Stmt),\n+    Expr(&'hir Expr<'hir>),\n+    Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment),\n     Ty(&'hir Ty),\n     TraitRef(&'hir TraitRef),\n-    Binding(&'hir Pat),\n-    Pat(&'hir Pat),\n-    Arm(&'hir Arm),\n-    Block(&'hir Block),\n-    Local(&'hir Local),\n+    Binding(&'hir Pat<'hir>),\n+    Pat(&'hir Pat<'hir>),\n+    Arm(&'hir Arm<'hir>),\n+    Block(&'hir Block<'hir>),\n+    Local(&'hir Local<'hir>),\n     MacroDef(&'hir MacroDef<'hir>),\n \n     /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants"}, {"sha": "75daf04dfc137d4bd900450ff71a304d0f7a3f4b", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -57,7 +57,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-impl hir::Pat {\n+impl hir::Pat<'_> {\n     pub fn is_refutable(&self) -> bool {\n         match self.kind {\n             PatKind::Lit(_)"}, {"sha": "7bff72314745073ec97c8b5aa940774ed4234bc5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -20,12 +20,12 @@ use std::vec;\n \n pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n-    Block(&'a hir::Block),\n+    Block(&'a hir::Block<'a>),\n     Item(&'a hir::Item<'a>),\n     SubItem(hir::HirId),\n-    Expr(&'a hir::Expr),\n-    Pat(&'a hir::Pat),\n-    Arm(&'a hir::Arm),\n+    Expr(&'a hir::Expr<'a>),\n+    Pat(&'a hir::Pat<'a>),\n+    Arm(&'a hir::Arm<'a>),\n }\n \n pub enum Nested {\n@@ -242,7 +242,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr]) {\n+    pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr<'_>]) {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n@@ -902,7 +902,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n-    pub fn print_local(&mut self, init: Option<&hir::Expr>, decl: impl Fn(&mut Self)) {\n+    pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {\n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n@@ -919,7 +919,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_stmt(&mut self, st: &hir::Stmt) {\n+    pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             hir::StmtKind::Local(ref loc) => {\n@@ -942,21 +942,21 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    pub fn print_block(&mut self, blk: &hir::Block) {\n+    pub fn print_block(&mut self, blk: &hir::Block<'_>) {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    pub fn print_block_unclosed(&mut self, blk: &hir::Block) {\n+    pub fn print_block_unclosed(&mut self, blk: &hir::Block<'_>) {\n         self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n-    pub fn print_block_with_attrs(&mut self, blk: &hir::Block, attrs: &[ast::Attribute]) {\n+    pub fn print_block_with_attrs(&mut self, blk: &hir::Block<'_>, attrs: &[ast::Attribute]) {\n         self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(\n         &mut self,\n-        blk: &hir::Block,\n+        blk: &hir::Block<'_>,\n         attrs: &[ast::Attribute],\n         close_box: bool,\n     ) {\n@@ -988,13 +988,13 @@ impl<'a> State<'a> {\n         self.ann.nested(self, Nested::Body(constant.body))\n     }\n \n-    fn print_call_post(&mut self, args: &[hir::Expr]) {\n+    fn print_call_post(&mut self, args: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, args);\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) {\n+    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr<'_>, prec: i8) {\n         let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen();\n@@ -1007,7 +1007,7 @@ impl<'a> State<'a> {\n \n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n-    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) {\n+    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr<'_>) {\n         let needs_par = match expr.kind {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n@@ -1025,15 +1025,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[hir::Expr]) {\n+    fn print_expr_vec(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::AnonConst) {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr<'_>, count: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_expr(element);\n@@ -1046,8 +1046,8 @@ impl<'a> State<'a> {\n     fn print_expr_struct(\n         &mut self,\n         qpath: &hir::QPath,\n-        fields: &[hir::Field],\n-        wth: &Option<P<hir::Expr>>,\n+        fields: &[hir::Field<'_>],\n+        wth: &Option<P<hir::Expr<'_>>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.s.word(\"{\");\n@@ -1085,7 +1085,7 @@ impl<'a> State<'a> {\n         self.s.word(\"}\");\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[hir::Expr]) {\n+    fn print_expr_tup(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n@@ -1094,7 +1094,7 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) {\n+    fn print_expr_call(&mut self, func: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n         let prec = match func.kind {\n             hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n             _ => parser::PREC_POSTFIX,\n@@ -1104,7 +1104,7 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr]) {\n+    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n         self.s.word(\".\");\n@@ -1118,7 +1118,7 @@ impl<'a> State<'a> {\n         self.print_call_post(base_args)\n     }\n \n-    fn print_expr_binary(&mut self, op: hir::BinOp, lhs: &hir::Expr, rhs: &hir::Expr) {\n+    fn print_expr_binary(&mut self, op: hir::BinOp, lhs: &hir::Expr<'_>, rhs: &hir::Expr<'_>) {\n         let assoc_op = bin_op_to_assoc_op(op.node);\n         let prec = assoc_op.precedence() as i8;\n         let fixity = assoc_op.fixity();\n@@ -1144,7 +1144,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n-    fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) {\n+    fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr<'_>) {\n         self.s.word(op.as_str());\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n@@ -1153,7 +1153,7 @@ impl<'a> State<'a> {\n         &mut self,\n         kind: hir::BorrowKind,\n         mutability: hir::Mutability,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n     ) {\n         self.s.word(\"&\");\n         match kind {\n@@ -1171,7 +1171,7 @@ impl<'a> State<'a> {\n         self.word(lit.node.to_lit_token().to_string())\n     }\n \n-    pub fn print_expr(&mut self, expr: &hir::Expr) {\n+    pub fn print_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.maybe_print_comment(expr.span.lo());\n         self.print_outer_attributes(&expr.attrs);\n         self.ibox(INDENT_UNIT);\n@@ -1418,7 +1418,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_local_decl(&mut self, loc: &hir::Local) {\n+    pub fn print_local_decl(&mut self, loc: &hir::Local<'_>) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\");\n@@ -1434,7 +1434,7 @@ impl<'a> State<'a> {\n         self.print_ident(ast::Ident::with_dummy_span(name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) {\n+    pub fn print_for_decl(&mut self, loc: &hir::Local<'_>, coll: &hir::Expr<'_>) {\n         self.print_local_decl(loc);\n         self.s.space();\n         self.word_space(\"in\");\n@@ -1599,7 +1599,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_pat(&mut self, pat: &hir::Pat) {\n+    pub fn print_pat(&mut self, pat: &hir::Pat<'_>) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));\n         // Pat isn't normalized, but the beauty of it\n@@ -1761,12 +1761,12 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_param(&mut self, arg: &hir::Param) {\n+    pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n \n-    pub fn print_arm(&mut self, arm: &hir::Arm) {\n+    pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n@@ -2212,7 +2212,7 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n //\n // Duplicated from `parse::classify`, but adapted for the HIR.\n-fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n+fn expr_requires_semi_to_be_stmt(e: &hir::Expr<'_>) -> bool {\n     match e.kind {\n         hir::ExprKind::Match(..) | hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) => false,\n         _ => true,\n@@ -2222,7 +2222,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n /// This statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n+fn stmt_ends_with_semi(stmt: &hir::StmtKind<'_>) -> bool {\n     match *stmt {\n         hir::StmtKind::Local(_) => true,\n         hir::StmtKind::Item(_) => false,\n@@ -2261,7 +2261,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n /// Expressions that syntactically contain an \"exterior\" struct literal, i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n-fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n     match value.kind {\n         hir::ExprKind::Struct(..) => true,\n "}, {"sha": "d7de226df59ec17778bb9324160b5314c0f812f0", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -46,7 +46,7 @@ impl Visitor<'tcx> for LocalCollector {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.locals.insert(hir_id);\n         }\n@@ -81,7 +81,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n         intravisit::walk_path(self, path);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n             if let Some(upvars) = self.tcx.upvars(closure_def_id) {"}, {"sha": "31d4f8513b2aa4aa9d3b579279f04f1b53baa30b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -117,7 +117,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr { hir_id: _, ref span, ref kind, ref attrs } = *self;"}, {"sha": "cb3d16b633d2d9ad783c79ac71e1bdf5cd547943", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -17,11 +17,11 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target_ty: Ty<'tcx>,\n     hir_map: &'a hir::map::Map<'tcx>,\n-    found_local_pattern: Option<&'tcx Pat>,\n-    found_arg_pattern: Option<&'tcx Pat>,\n+    found_local_pattern: Option<&'tcx Pat<'tcx>>,\n+    found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n     found_ty: Option<Ty<'tcx>>,\n-    found_closure: Option<&'tcx ExprKind>,\n-    found_method_call: Option<&'tcx Expr>,\n+    found_closure: Option<&'tcx ExprKind<'tcx>>,\n+    found_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n \n-    fn visit_local(&mut self, local: &'tcx Local) {\n+    fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n         if let (None, Some(ty)) = (self.found_local_pattern, self.node_matches_type(local.hir_id)) {\n             self.found_local_pattern = Some(&*local.pat);\n             self.found_ty = Some(ty);\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         intravisit::walk_body(self, body);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if self.node_matches_type(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr.kind),\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn annotate_method_call(\n         &self,\n         segment: &hir::ptr::P<hir::PathSegment>,\n-        e: &Expr,\n+        e: &Expr<'_>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let (Ok(snippet), Some(tables), None) = ("}, {"sha": "638c8f5200719e9454250597eb4fd888f471ba0a", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -12,7 +12,7 @@ use syntax_pos::Span;\n #[derive(Debug)]\n pub(super) struct AnonymousParamInfo<'tcx> {\n     // the parameter corresponding to the anonymous region\n-    pub param: &'tcx hir::Param,\n+    pub param: &'tcx hir::Param<'tcx>,\n     // the type corresponding to the anonymopus region parameter\n     pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region"}, {"sha": "4e1e62512acd26dafffc8e2b36d4b95f64d84578", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -894,7 +894,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n             lint_callback!(cx, check_param, param);\n             hir_visit::walk_param(cx, param);\n@@ -930,20 +930,20 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n         lint_callback!(self, check_pat, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n             lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n             lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n         // statement attributes are actually just attributes on one of\n         // - item\n         // - local\n@@ -1020,20 +1020,20 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         }\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n             lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         lint_callback!(self, check_block, b);\n         hir_visit::walk_block(self, b);\n         lint_callback!(self, check_block_post, b);\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         lint_callback!(self, check_arm, a);\n         hir_visit::walk_arm(self, a);\n     }"}, {"sha": "97b38db4165979ab226e02fdf880606f5c1fb426", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -87,7 +87,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_param(a: &$hir hir::Param);\n+            fn check_param(a: &$hir hir::Param<$hir>);\n             fn check_body(a: &$hir hir::Body<$hir>);\n             fn check_body_post(a: &$hir hir::Body<$hir>);\n             fn check_name(a: Span, b: ast::Name);\n@@ -99,14 +99,14 @@ macro_rules! late_lint_methods {\n             fn check_foreign_item_post(a: &$hir hir::ForeignItem<$hir>);\n             fn check_item(a: &$hir hir::Item<$hir>);\n             fn check_item_post(a: &$hir hir::Item<$hir>);\n-            fn check_local(a: &$hir hir::Local);\n-            fn check_block(a: &$hir hir::Block);\n-            fn check_block_post(a: &$hir hir::Block);\n-            fn check_stmt(a: &$hir hir::Stmt);\n-            fn check_arm(a: &$hir hir::Arm);\n-            fn check_pat(a: &$hir hir::Pat);\n-            fn check_expr(a: &$hir hir::Expr);\n-            fn check_expr_post(a: &$hir hir::Expr);\n+            fn check_local(a: &$hir hir::Local<$hir>);\n+            fn check_block(a: &$hir hir::Block<$hir>);\n+            fn check_block_post(a: &$hir hir::Block<$hir>);\n+            fn check_stmt(a: &$hir hir::Stmt<$hir>);\n+            fn check_arm(a: &$hir hir::Arm<$hir>);\n+            fn check_pat(a: &$hir hir::Pat<$hir>);\n+            fn check_expr(a: &$hir hir::Expr<$hir>);\n+            fn check_expr_post(a: &$hir hir::Expr<$hir>);\n             fn check_ty(a: &$hir hir::Ty);\n             fn check_generic_param(a: &$hir hir::GenericParam);\n             fn check_generics(a: &$hir hir::Generics);\n@@ -610,7 +610,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n             intravisit::walk_param(builder, param);\n         });\n@@ -628,7 +628,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n@@ -651,13 +651,13 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n         self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n             intravisit::walk_arm(builder, a);\n         })"}, {"sha": "c6598f2d328bf47f5b9819bf17afa4d3af8008d3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n         self.tables = old_tables;\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = match expr.kind {\n             hir::ExprKind::Path(ref qpath) => Some(self.tables.qpath_res(qpath, expr.hir_id)),\n             hir::ExprKind::MethodCall(..) => self"}, {"sha": "5479a7046b6c895101b3ad0263486d8580b2eacf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -432,7 +432,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n         self.expr_and_pat_count += 1;\n@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         debug!(\"ExprLocatorVisitor - pre-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n \n         intravisit::walk_expr(self, expr);\n@@ -773,7 +773,7 @@ fn record_var_lifetime(\n     }\n }\n \n-fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block) {\n+fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block<'tcx>) {\n     debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n@@ -837,7 +837,7 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm<'tcx>) {\n     let prev_cx = visitor.cx;\n \n     visitor.enter_scope(Scope { id: arm.hir_id.local_id, data: ScopeData::Node });\n@@ -854,7 +854,7 @@ fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat<'tcx>) {\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -871,7 +871,7 @@ fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir\n     debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n }\n \n-fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt<'tcx>) {\n     let stmt_id = stmt.hir_id.local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -890,7 +890,7 @@ fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx h\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n     debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n     let prev_cx = visitor.cx;\n@@ -1107,8 +1107,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n-    pat: Option<&'tcx hir::Pat>,\n-    init: Option<&'tcx hir::Expr>,\n+    pat: Option<&'tcx hir::Pat<'tcx>>,\n+    init: Option<&'tcx hir::Expr<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -1197,7 +1197,7 @@ fn resolve_local<'tcx>(\n     ///        | ( ..., P&, ... )\n     ///        | ... \"|\" P& \"|\" ...\n     ///        | box P&\n-    fn is_binding_pat(pat: &hir::Pat) -> bool {\n+    fn is_binding_pat(pat: &hir::Pat<'_>) -> bool {\n         // Note that the code below looks for *explicit* refs only, that is, it won't\n         // know about *implicit* refs as introduced in #42640.\n         //\n@@ -1263,7 +1263,7 @@ fn resolve_local<'tcx>(\n     ///        | ( E& )\n     fn record_rvalue_scope_if_borrow_expr<'tcx>(\n         visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         blk_id: Option<Scope>,\n     ) {\n         match expr.kind {\n@@ -1310,7 +1310,7 @@ fn resolve_local<'tcx>(\n     /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n     fn record_rvalue_scope<'tcx>(\n         visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         blk_scope: Option<Scope>,\n     ) {\n         let mut expr = expr;\n@@ -1372,7 +1372,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_block(&mut self, b: &'tcx Block) {\n+    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n         resolve_block(self, b);\n     }\n \n@@ -1444,19 +1444,19 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         self.terminating_scopes = outer_ts;\n     }\n \n-    fn visit_arm(&mut self, a: &'tcx Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm<'tcx>) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &'tcx Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &'tcx Local) {\n+    fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n         resolve_local(self, Some(&l.pat), l.init.as_ref().map(|e| &**e));\n     }\n }"}, {"sha": "7950ff421b4a58d784a2b5129dad55870e71024f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -1133,7 +1133,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n             NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, ex: &hir::Expr) {\n+        fn visit_expr(&mut self, ex: &hir::Expr<'_>) {\n             if let Some(label) = expression_label(ex) {\n                 for prior_label in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n@@ -1155,7 +1155,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n+    fn expression_label(ex: &hir::Expr<'_>) -> Option<ast::Ident> {\n         if let hir::ExprKind::Loop(_, Some(label), _) = ex.kind { Some(label.ident) } else { None }\n     }\n "}, {"sha": "f7d9cb34fa9252091b60d0a9c16e912915f3b7cc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -1331,19 +1331,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         msg: &str,\n     ) -> Option<String> {\n-        let get_name = |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind| -> Option<String> {\n-            // Get the local name of this closure. This can be inaccurate because\n-            // of the possibility of reassignment, but this should be good enough.\n-            match &kind {\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n-                    Some(format!(\"{}\", name))\n-                }\n-                _ => {\n-                    err.note(&msg);\n-                    None\n+        let get_name =\n+            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n+                // Get the local name of this closure. This can be inaccurate because\n+                // of the possibility of reassignment, but this should be good enough.\n+                match &kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        Some(format!(\"{}\", name))\n+                    }\n+                    _ => {\n+                        err.note(&msg);\n+                        None\n+                    }\n                 }\n-            }\n-        };\n+            };\n \n         let hir = self.tcx.hir();\n         let hir_id = hir.as_local_hir_id(def_id)?;"}, {"sha": "2659caf030b0c6dc64bd31f9cdba27bd075bec60", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -553,11 +553,11 @@ impl<'tcx> TypeckTables<'tcx> {\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(&self, pat: &hir::Pat<'_>) -> Ty<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(&self, pat: &hir::Pat<'_>) -> Option<Ty<'tcx>> {\n         self.node_type_opt(pat.hir_id)\n     }\n \n@@ -571,11 +571,11 @@ impl<'tcx> TypeckTables<'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.node_type(expr.hir_id)\n     }\n \n-    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n         self.node_type_opt(expr.hir_id)\n     }\n \n@@ -589,22 +589,22 @@ impl<'tcx> TypeckTables<'tcx> {\n         LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.adjustments }\n     }\n \n-    pub fn expr_adjustments(&self, expr: &hir::Expr) -> &[ty::adjustment::Adjustment<'tcx>] {\n+    pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n         validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`\n     /// entry recorded for that expression.\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n         self.expr_adjustments(expr).last().map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n     }\n \n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr<'_>) -> Option<Ty<'tcx>> {\n         self.expr_adjustments(expr).last().map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n     }\n \n-    pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n+    pub fn is_method_call(&self, expr: &hir::Expr<'_>) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n         if let hir::ExprKind::Path(_) = expr.kind {"}, {"sha": "7110ab40328450ef78b036612fbc3819c38aea8b", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=2b1cfe5b5b3c33b71002e71b7d2e6d6505d551f2", "patch": "@@ -150,27 +150,27 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.delegate.consume(place, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n+    fn consume_exprs(&mut self, exprs: &[hir::Expr<'_>]) {\n         for expr in exprs {\n             self.consume_expr(&expr);\n         }\n     }\n \n-    pub fn consume_expr(&mut self, expr: &hir::Expr) {\n+    pub fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let place = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(&place);\n         self.walk_expr(expr);\n     }\n \n-    fn mutate_expr(&mut self, expr: &hir::Expr) {\n+    fn mutate_expr(&mut self, expr: &hir::Expr<'_>) {\n         let place = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.mutate(&place);\n         self.walk_expr(expr);\n     }\n \n-    fn borrow_expr(&mut self, expr: &hir::Expr, bk: ty::BorrowKind) {\n+    fn borrow_expr(&mut self, expr: &hir::Expr<'_>, bk: ty::BorrowKind) {\n         debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n         let place = return_if_err!(self.mc.cat_expr(expr));\n@@ -179,11 +179,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.walk_expr(expr)\n     }\n \n-    fn select_from_expr(&mut self, expr: &hir::Expr) {\n+    fn select_from_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.walk_expr(expr)\n     }\n \n-    pub fn walk_expr(&mut self, expr: &hir::Expr) {\n+    pub fn walk_expr(&mut self, expr: &hir::Expr<'_>) {\n         debug!(\"walk_expr(expr={:?})\", expr);\n \n         self.walk_adjustment(expr);\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n+    fn walk_callee(&mut self, call: &hir::Expr<'_>, callee: &hir::Expr<'_>) {\n         let callee_ty = return_if_err!(self.mc.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\", callee, callee_ty);\n         match callee_ty.kind {\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n+    fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 self.walk_local(&local);\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: &hir::Local) {\n+    fn walk_local(&mut self, local: &hir::Local<'_>) {\n         if let Some(ref expr) = local.init {\n             // Variable declarations with\n             // initializers are considered\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n-    fn walk_block(&mut self, blk: &hir::Block) {\n+    fn walk_block(&mut self, blk: &hir::Block<'_>) {\n         debug!(\"walk_block(blk.hir_id={})\", blk.hir_id);\n \n         for stmt in &blk.stmts {\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_struct_expr(&mut self, fields: &[hir::Field], opt_with: &Option<P<hir::Expr>>) {\n+    fn walk_struct_expr(&mut self, fields: &[hir::Field<'_>], opt_with: &Option<P<hir::Expr<'_>>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n             self.consume_expr(&field.expr);\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // Invoke the appropriate delegate calls for anything that gets\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n-    fn walk_adjustment(&mut self, expr: &hir::Expr) {\n+    fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.tables.expr_adjustments(expr);\n         let mut place = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n@@ -487,7 +487,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(\n         &mut self,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         base_place: &mc::Place<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm) {\n+    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm<'_>) {\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -521,12 +521,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n         self.walk_pat(discr_place, pat);\n     }\n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n@@ -565,7 +565,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);"}]}