{"sha": "e24ae85025e40aa17915f6c604d89aefbca274bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNGFlODUwMjVlNDBhYTE3OTE1ZjZjNjA0ZDg5YWVmYmNhMjc0YmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-12T20:25:40Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-12T23:02:47Z"}, "message": "syntax: remove most code handling old-style syntax extensions.", "tree": {"sha": "e60ccfc313fc01636e698aca06f92d180bafbf9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e60ccfc313fc01636e698aca06f92d180bafbf9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e24ae85025e40aa17915f6c604d89aefbca274bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e24ae85025e40aa17915f6c604d89aefbca274bd", "html_url": "https://github.com/rust-lang/rust/commit/e24ae85025e40aa17915f6c604d89aefbca274bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e24ae85025e40aa17915f6c604d89aefbca274bd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cced55b93a14cdca9bb86ae99b22021fac8685f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cced55b93a14cdca9bb86ae99b22021fac8685f", "html_url": "https://github.com/rust-lang/rust/commit/9cced55b93a14cdca9bb86ae99b22021fac8685f"}], "stats": {"total": 1256, "additions": 30, "deletions": 1226}, "files": [{"sha": "160dc43a3b91e54e56f26f3da72f2fb74e780fee", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -842,13 +842,7 @@ type mac_body = Option<mac_body_>;\n #[auto_serialize]\n #[auto_deserialize]\n enum mac_ {\n-    mac_invoc(@path, mac_arg, mac_body), // old macro-invocation\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n-    mac_ellipsis,                        // old pattern-match (obsolete)\n-\n-    // the span is used by the quoter/anti-quoter ...\n-    mac_aq(span /* span of quote */, @expr), // anti-quote\n-    mac_var(uint)\n }\n \n type lit = spanned<lit_>;"}, {"sha": "08f8746c45e2a520daf771c6a1e15d48c9f4e581", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -16,16 +16,16 @@ use ast_util::dummy_sp;\n \n // obsolete old-style #macro code:\n //\n-//    syntax_expander, normal, macro_defining, macro_definer,\n-//    builtin\n+//    syntax_expander, normal, builtin\n //\n // new-style macro! tt code:\n //\n //    syntax_expander_tt, syntax_expander_tt_item, mac_result,\n //    normal_tt, item_tt\n //\n-// also note that ast::mac has way too many cases and can probably\n-// be trimmed down substantially.\n+// also note that ast::mac used to have a bunch of extraneous cases and\n+// is now probably a redundant AST node, can be merged with\n+// ast::mac_invoc_tt.\n \n // second argument is the span to blame for general argument problems\n type syntax_expander_ =\n@@ -35,10 +35,6 @@ type syntax_expander = {expander: syntax_expander_, span: Option<span>};\n \n type macro_def = {name: ~str, ext: syntax_extension};\n \n-// macro_definer is obsolete, remove when #old_macros go away.\n-type macro_definer =\n-    fn@(ext_ctxt, span, ast::mac_arg, ast::mac_body) -> macro_def;\n-\n type item_decorator =\n     fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n@@ -63,9 +59,6 @@ enum syntax_extension {\n     // normal() is obsolete, remove when #old_macros go away.\n     normal(syntax_expander),\n \n-    // macro_defining() is obsolete, remove when #old_macros go away.\n-    macro_defining(macro_definer),\n-\n     // #[auto_serialize] and such. will probably survive death of #old_macros\n     item_decorator(item_decorator),\n \n@@ -89,8 +82,6 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n         item_tt({expander: f, span: None})\n     }\n     let syntax_expanders = HashMap();\n-    syntax_expanders.insert(~\"macro\",\n-                            macro_defining(ext::simplext::add_new_extension));\n     syntax_expanders.insert(~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));"}, {"sha": "391edbbb7993e42c8785b4e86ed1e9e5e7161b2a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 80, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -10,7 +10,7 @@\n \n use std::map::HashMap;\n \n-use ast::{crate, expr_, expr_mac, mac_invoc, mac_invoc_tt,\n+use ast::{crate, expr_, expr_mac, mac_invoc_tt,\n           tt_delim, tt_tok, item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use fold::*;\n use ext::base::*;\n@@ -31,51 +31,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n           expr_mac(ref mac) => {\n \n             match (*mac).node {\n-              // Old-style macros. For compatibility, will erase this whole\n-              // block once we've transitioned.\n-              mac_invoc(pth, args, body) => {\n-                assert (vec::len(pth.idents) > 0u);\n-                /* using idents and token::special_idents would make the\n-                the macro names be hygienic */\n-                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(*extname) {\n-                  None => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"macro undefined: '%s'\", *extname))\n-                  }\n-                  Some(item_decorator(_)) => {\n-                    cx.span_fatal(\n-                        pth.span,\n-                        fmt!(\"%s can only be used as a decorator\", *extname));\n-                  }\n-                  Some(normal({expander: exp, span: exp_sp})) => {\n-\n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n-                    let expanded = exp(cx, (*mac).span, args, body);\n-\n-                    //keep going, outside-in\n-                    let fully_expanded = fld.fold_expr(expanded).node;\n-                    cx.bt_pop();\n-\n-                    (fully_expanded, s)\n-                  }\n-                  Some(macro_defining(ext)) => {\n-                    let named_extension = ext(cx, (*mac).span, args, body);\n-                    exts.insert(named_extension.name, named_extension.ext);\n-                    (ast::expr_rec(~[], None), s)\n-                  }\n-                  Some(normal_tt(_)) => {\n-                    cx.span_fatal(pth.span,\n-                                  fmt!(\"this tt-style macro should be \\\n-                                        invoked '%s!(...)'\", *extname))\n-                  }\n-                  Some(item_tt(*)) => {\n-                    cx.span_fatal(pth.span,\n-                                  ~\"cannot use item macros in this context\");\n-                  }\n-                }\n-              }\n \n               // Token-tree macros, these will be the only case when we're\n               // finished transitioning.\n@@ -130,7 +85,6 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n \n                 }\n               }\n-              _ => cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n             }\n           }\n           _ => orig(e, s, fld)\n@@ -165,8 +119,8 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_list(ref n, _) => (*n)\n             };\n             match exts.find(mname) {\n-              None | Some(normal(_)) | Some(macro_defining(_))\n-              | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n+              None | Some(normal(_))\n+                | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n               Some(item_decorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n                                            callie: {name: copy mname,\n@@ -209,36 +163,16 @@ fn expand_item(exts: HashMap<~str, syntax_extension>,\n     }\n }\n \n-// avoid excess indentation when a series of nested `match`es\n-// has only one \"good\" outcome\n-macro_rules! biased_match (\n-    (   ($e    :expr) ~ ($p    :pat) else $err    :stmt ;\n-     $( ($e_cdr:expr) ~ ($p_cdr:pat) else $err_cdr:stmt ; )*\n-     => $body:expr\n-    ) => (\n-        match $e {\n-            $p => {\n-                biased_match!($( ($e_cdr) ~ ($p_cdr) else $err_cdr ; )*\n-                              => $body)\n-            }\n-            _ => { $err }\n-        }\n-    );\n-    ( => $body:expr ) => ( $body )\n-)\n-\n-\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> Option<@ast::item> {\n-    let (pth, tts) = biased_match!(\n-        (it.node) ~ (item_mac({node: mac_invoc_tt(pth, ref tts), _})) else {\n-            cx.span_bug(it.span, ~\"invalid item macro invocation\")\n-        };\n-        => (pth, (*tts))\n-    );\n+\n+    let (pth, tts) = match it.node {\n+        item_mac({node: mac_invoc_tt(pth, ref tts), _}) => (pth, (*tts)),\n+        _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n+    };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n     let expanded = match exts.find(*extname) {\n@@ -293,12 +227,15 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n     -> (stmt_, span)\n {\n-    let (mac, pth, tts, semi) = biased_match! (\n-        (s)        ~ (stmt_mac(ref mac, semi))   else return orig(s, sp, fld);\n-        ((*mac).node) ~ (mac_invoc_tt(pth, ref tts)) else {\n-            cx.span_bug((*mac).span, ~\"naked syntactic bit\")\n-        };\n-        => ((*mac), pth, (*tts), semi));\n+\n+    let (mac, pth, tts, semi) = match s {\n+        stmt_mac(ref mac, semi) => {\n+            match (*mac).node {\n+                mac_invoc_tt(pth, ref tts) => ((*mac), pth, (*tts), semi)\n+            }\n+        }\n+        _ => return orig(s, sp, fld)\n+    };\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);"}, {"sha": "1e5d4ea8d16f884f863b4f1864156fe5225b052f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -406,7 +406,6 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n         AT => \"AT\",\n         DOT => \"DOT\",\n         DOTDOT => \"DOTDOT\",\n-        ELLIPSIS => \"ELLIPSIS\",\n         COMMA => \"COMMA\",\n         SEMI => \"SEMI\",\n         COLON => \"COLON\","}, {"sha": "f13c5c9aff9ea228c0f90f5cd4b01e35c2d51723", "filename": "src/libsyntax/ext/simplext.rs", "status": "removed", "additions": 0, "deletions": 750, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,750 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use codemap::span;\n-use std::map::HashMap;\n-use dvec::DVec;\n-\n-use base::*;\n-\n-use fold::*;\n-use ast_util::respan;\n-use ast::{ident, path, Ty, blk_, expr, expr_path,\n-             expr_vec, expr_mac, mac_invoc, node_id, expr_index};\n-\n-export add_new_extension;\n-\n-fn path_to_ident(pth: @path) -> Option<ident> {\n-    if vec::len(pth.idents) == 1u && vec::len(pth.types) == 0u {\n-        return Some(pth.idents[0u]);\n-    }\n-    return None;\n-}\n-\n-//a vec of binders might be a little big.\n-type clause = {params: binders, body: @expr};\n-\n-/* logically, an arb_depth should contain only one kind of matchable */\n-enum arb_depth<T> { leaf(T), seq(@~[arb_depth<T>], span), }\n-\n-\n-enum matchable {\n-    match_expr(@expr),\n-    match_path(@path),\n-    match_ident(ast::spanned<ident>),\n-    match_ty(@Ty),\n-    match_block(ast::blk),\n-    match_exact, /* don't bind anything, just verify the AST traversal */\n-}\n-\n-/* for when given an incompatible bit of AST */\n-fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n-    match m {\n-      match_expr(x) => cx.span_fatal(\n-          x.span, ~\"this argument is an expr, expected \" + expected),\n-      match_path(x) => cx.span_fatal(\n-          x.span, ~\"this argument is a path, expected \" + expected),\n-      match_ident(x) => cx.span_fatal(\n-          x.span, ~\"this argument is an ident, expected \" + expected),\n-      match_ty(x) => cx.span_fatal(\n-          x.span, ~\"this argument is a type, expected \" + expected),\n-      match_block(ref x) => cx.span_fatal(\n-          (*x).span, ~\"this argument is a block, expected \" + expected),\n-      match_exact => cx.bug(~\"what is a match_exact doing in a bindings?\")\n-    }\n-}\n-\n-// We can't make all the matchables in a match_result the same type because\n-// idents can be paths, which can be exprs.\n-\n-// If we want better match failure error messages (like in Fortifying Syntax),\n-// we'll want to return something indicating amount of progress and location\n-// of failure instead of `none`.\n-type match_result = Option<arb_depth<matchable>>;\n-type selector = fn@(matchable) -> match_result;\n-\n-fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n-   {pre: ~[@expr], rep: Option<@expr>, post: ~[@expr]} {\n-    let mut idx: uint = 0u;\n-    let mut res = None;\n-    for elts.each |elt| {\n-        match elt.node {\n-          expr_mac(ref m) => match (*m).node {\n-            ast::mac_ellipsis => {\n-                if res.is_some() {\n-                    cx.span_fatal((*m).span, ~\"only one ellipsis allowed\");\n-                }\n-                res =\n-                    Some({pre: vec::slice(elts, 0u, idx - 1u),\n-                          rep: Some(elts[idx - 1u]),\n-                          post: vec::slice(elts, idx + 1u, vec::len(elts))});\n-            }\n-            _ => ()\n-          },\n-          _ => ()\n-        }\n-        idx += 1u;\n-    }\n-    return match res {\n-          Some(val) => val,\n-          None => {pre: elts, rep: None, post: ~[]}\n-    }\n-}\n-\n-fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n-   Option<~[U]> {\n-    let mut res = ~[];\n-    for v.each |elem| {\n-        match f(*elem) {\n-          None => return None,\n-          Some(ref fv) => res.push((*fv))\n-        }\n-    }\n-    return Some(res);\n-}\n-\n-fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n-    match ad {\n-      leaf(ref x) => return f((*x)),\n-      seq(ads, span) => match option_flatten_map(|x| a_d_map(x, f), *ads) {\n-        None => return None,\n-        Some(ts) => return Some(seq(@ts, span))\n-      }\n-    }\n-}\n-\n-fn compose_sels(s1: selector, s2: selector) -> selector {\n-    fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n-        return match s1(m) {\n-              None => None,\n-              Some(ref matches) => a_d_map((*matches), s2)\n-            }\n-    }\n-    return { |x| scomp(s1, s2, x) };\n-}\n-\n-\n-\n-type binders =\n-    {real_binders: HashMap<ident, selector>,\n-     literal_ast_matchers: DVec<selector>};\n-type bindings = HashMap<ident, arb_depth<matchable>>;\n-\n-fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n-\n-/* these three functions are the big moving parts */\n-\n-/* create the selectors needed to bind and verify the pattern */\n-\n-fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n-    let res: binders =\n-        {real_binders: HashMap(),\n-         literal_ast_matchers: DVec()};\n-    //this oughta return binders instead, but macro args are a sequence of\n-    //expressions, rather than a single expression\n-    fn trivial_selector(m: matchable) -> match_result {\n-        return Some(leaf(m));\n-    }\n-    p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n-    move res\n-}\n-\n-\n-\n-/* use the selectors on the actual arguments to the macro to extract\n-bindings. Most of the work is done in p_t_s, which generates the\n-selectors. */\n-\n-fn use_selectors_to_bind(b: binders, e: @expr) -> Option<bindings> {\n-    let res = HashMap();\n-    //need to do this first, to check vec lengths.\n-    for b.literal_ast_matchers.each |sel| {\n-        match (*sel)(match_expr(e)) { None => return None, _ => () }\n-    }\n-    let mut never_mind: bool = false;\n-    for b.real_binders.each |key, val| {\n-        match val(match_expr(e)) {\n-          None => never_mind = true,\n-          Some(ref mtc) => { res.insert(key, (*mtc)); }\n-        }\n-    };\n-    //HACK: `ret` doesn't work in `for each`\n-    if never_mind { return None; }\n-    return Some(res);\n-}\n-\n-/* use the bindings on the body to generate the expanded code */\n-\n-fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n-    let idx_path: @mut ~[uint] = @mut ~[];\n-    fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { return cx.next_id(); }\n-    fn new_span(cx: ext_ctxt, sp: span) -> span {\n-        /* this discards information in the case of macro-defining macros */\n-        return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n-    }\n-    let afp = default_ast_fold();\n-    let f_pre =\n-        @{fold_ident: |x,y|transcribe_ident(cx, b, idx_path, x, y),\n-          fold_path: |x,y|transcribe_path(cx, b, idx_path, x, y),\n-          fold_expr: |x,y,z|\n-              transcribe_expr(cx, b, idx_path, x, y, z, afp.fold_expr)\n-          ,\n-          fold_ty: |x,y,z|\n-              transcribe_type(cx, b, idx_path,\n-                              x, y, z, afp.fold_ty)\n-          ,\n-          fold_block: |x,y,z|\n-              transcribe_block(cx, b, idx_path, x, y, z, afp.fold_block)\n-          ,\n-          map_exprs: |x,y|\n-              transcribe_exprs(cx, b, idx_path, x, y)\n-          ,\n-          new_id: |x|new_id(x, cx),\n-          .. *afp};\n-    let f = make_fold(f_pre);\n-    let result = f.fold_expr(body);\n-    return result;\n-}\n-\n-\n-/* helper: descend into a matcher */\n-pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n-   arb_depth<matchable> {\n-    let mut res: arb_depth<matchable> = m;\n-    for vec::each(idx_path) |idx| {\n-        res = match res {\n-          leaf(_) => return res,/* end of the line */\n-          seq(new_ms, _) => new_ms[*idx]\n-        }\n-    }\n-    return res;\n-}\n-\n-fn follow_for_trans(cx: ext_ctxt, mmaybe: Option<arb_depth<matchable>>,\n-                    idx_path: @mut ~[uint]) -> Option<matchable> {\n-    match mmaybe {\n-      None => return None,\n-      Some(ref m) => {\n-        return match follow((*m), *idx_path) {\n-              seq(_, sp) => {\n-                cx.span_fatal(sp,\n-                              ~\"syntax matched under ... but not \" +\n-                                  ~\"used that way.\")\n-              }\n-              leaf(ref m) => return Some((*m))\n-            }\n-      }\n-    }\n-\n-}\n-\n-/* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n-fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n-    let idents = HashMap();\n-    fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n-                  idents: HashMap<ident, ()>) -> ident {\n-        if b.contains_key(i) { idents.insert(i, ()); }\n-        return i;\n-    }\n-    // using fold is a hack: we want visit, but it doesn't hit idents ) :\n-    // solve this with macros\n-    let f_pre =\n-        @{fold_ident: |x,y|mark_ident(x, y, b, idents),\n-          .. *default_ast_fold()};\n-    let f = make_fold(f_pre);\n-    f.fold_expr(e); // ignore result\n-    for idents.each_key |x| { it(x); };\n-}\n-\n-fn wrong_occurs(cx: ext_ctxt, l: ident, l_c: uint, r: ident, r_c: uint)\n-    -> ~str {\n-    fmt!(\"'%s' occurs %u times, but '%s' occurs %u times\",\n-         *cx.parse_sess().interner.get(l), l_c,\n-         *cx.parse_sess().interner.get(r), r_c)\n-}\n-\n-/* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    recur: fn@(&&v: @expr) -> @expr,\n-                    exprs: ~[@expr]) -> ~[@expr] {\n-    match elts_to_ell(cx, exprs) {\n-      {pre: pre, rep: repeat_me_maybe, post: post} => {\n-        let mut res = vec::map(pre, |x| recur(*x));\n-        match repeat_me_maybe {\n-          None => (),\n-          Some(repeat_me) => {\n-            let mut repeat: Option<{rep_count: uint, name: ident}> = None;\n-            /* we need to walk over all the free vars in lockstep, except for\n-            the leaves, which are just duplicated */\n-            do free_vars(b, repeat_me) |fv| {\n-                let fv_depth = b.get(fv);\n-                let cur_pos = follow(fv_depth, *idx_path);\n-                match cur_pos {\n-                  leaf(_) => (),\n-                  seq(ms, _) => {\n-                    match repeat {\n-                      None => {\n-                        repeat = Some({rep_count: vec::len(*ms), name: fv});\n-                      }\n-                      Some({rep_count: old_len, name: old_name}) => {\n-                        let len = vec::len(*ms);\n-                        if old_len != len {\n-                            let msg = wrong_occurs(cx, fv, len,\n-                                                   old_name, old_len);\n-                            cx.span_fatal(repeat_me.span, msg);\n-                        }\n-                      }\n-                    }\n-                  }\n-                }\n-            };\n-            match repeat {\n-              None => {\n-                cx.span_fatal(repeat_me.span,\n-                              ~\"'...' surrounds an expression without any\" +\n-                                  ~\" repeating syntax variables\");\n-              }\n-              Some({rep_count: rc, _}) => {\n-                /* Whew, we now know how how many times to repeat */\n-                let mut idx: uint = 0u;\n-                while idx < rc {\n-                    idx_path.push(idx);\n-                    res.push(recur(repeat_me)); // whew!\n-                    idx_path.pop();\n-                    idx += 1u;\n-                }\n-              }\n-            }\n-          }\n-        }\n-        res = vec::append(res, vec::map(post, |x| recur(*x)));\n-        return res;\n-      }\n-    }\n-}\n-\n-\n-\n-// substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    &&i: ident, _fld: ast_fold) -> ident {\n-    return match follow_for_trans(cx, b.find(i), idx_path) {\n-          Some(match_ident(a_id)) => a_id.node,\n-          Some(ref m) => match_error(cx, (*m), ~\"an identifier\"),\n-          None => i\n-        }\n-}\n-\n-\n-fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   p: path, _fld: ast_fold) -> path {\n-    // Don't substitute into qualified names.\n-    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { return p; }\n-    match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-      Some(match_ident(id)) => {\n-        {span: id.span, global: false, idents: ~[id.node],\n-         rp: None, types: ~[]}\n-      }\n-      Some(match_path(a_pth)) => *a_pth,\n-      Some(ref m) => match_error(cx, (*m), ~\"a path\"),\n-      None => p\n-    }\n-}\n-\n-\n-fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   e: ast::expr_, s: span, fld: ast_fold,\n-                   orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n-    -> (ast::expr_, span)\n-{\n-    return match e {\n-          expr_path(p) => {\n-            // Don't substitute into qualified names.\n-            if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n-                (e, s);\n-            }\n-            match follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-              Some(match_ident(id)) => {\n-                (expr_path(@{span: id.span,\n-                             global: false,\n-                             idents: ~[id.node],\n-                             rp: None,\n-                             types: ~[]}), id.span)\n-              }\n-              Some(match_path(a_pth)) => (expr_path(a_pth), s),\n-              Some(match_expr(a_exp)) => (a_exp.node, a_exp.span),\n-              Some(ref m) => match_error(cx, (*m), ~\"an expression\"),\n-              None => orig(e, s, fld)\n-            }\n-          }\n-          _ => orig(e, s, fld)\n-        }\n-}\n-\n-fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                   t: ast::ty_, s: span, fld: ast_fold,\n-                   orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n-    -> (ast::ty_, span)\n-{\n-    return match t {\n-          ast::ty_path(pth, _) => {\n-            match path_to_ident(pth) {\n-              Some(id) => {\n-                match follow_for_trans(cx, b.find(id), idx_path) {\n-                  Some(match_ty(ty)) => (ty.node, ty.span),\n-                  Some(ref m) => match_error(cx, (*m), ~\"a type\"),\n-                  None => orig(t, s, fld)\n-                }\n-              }\n-              None => orig(t, s, fld)\n-            }\n-          }\n-          _ => orig(t, s, fld)\n-        }\n-}\n-\n-\n-/* for parsing reasons, syntax variables bound to blocks must be used like\n-`{v}` */\n-\n-fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    blk: blk_, s: span, fld: ast_fold,\n-                    orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n-    -> (blk_, span)\n-{\n-    return match block_to_ident(blk) {\n-          Some(id) => {\n-            match follow_for_trans(cx, b.find(id), idx_path) {\n-              Some(match_block(ref new_blk)) => {\n-                ((*new_blk).node, (*new_blk).span)\n-              }\n-\n-              // possibly allow promotion of ident/path/expr to blocks?\n-              Some(ref m) => match_error(cx, (*m), ~\"a block\"),\n-              None => orig(blk, s, fld)\n-            }\n-          }\n-          None => orig(blk, s, fld)\n-        }\n-}\n-\n-\n-/* traverse the pattern, building instructions on how to bind the actual\n-argument. ps accumulates instructions on navigating the tree.*/\n-fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n-\n-    //it might be possible to traverse only exprs, not matchables\n-    match m {\n-      match_expr(e) => {\n-        match e.node {\n-          expr_path(p_pth) => p_t_s_r_path(cx, p_pth, s, b),\n-          expr_vec(p_elts, _) => {\n-            match elts_to_ell(cx, p_elts) {\n-              {pre: pre, rep: Some(repeat_me), post: post} => {\n-                p_t_s_r_length(cx, vec::len(pre) + vec::len(post), true, s,\n-                               b);\n-                if vec::len(pre) > 0u {\n-                    p_t_s_r_actual_vector(cx, pre, true, s, b);\n-                }\n-                p_t_s_r_ellipses(cx, repeat_me, vec::len(pre), s, b);\n-\n-                if vec::len(post) > 0u {\n-                    cx.span_unimpl(e.span,\n-                                   ~\"matching after `...` not yet supported\");\n-                }\n-              }\n-              {pre: pre, rep: None, post: post} => {\n-                if post.len() > 0 {\n-                    cx.bug(~\"elts_to_ell provided an invalid result\");\n-                }\n-                p_t_s_r_length(cx, vec::len(pre), false, s, b);\n-                p_t_s_r_actual_vector(cx, pre, false, s, b);\n-              }\n-            }\n-          }\n-          /* FIXME (#2251): handle embedded types and blocks, at least */\n-          expr_mac(ref mac) => {\n-            p_t_s_r_mac(cx, (*mac), s, b);\n-          }\n-          _ => {\n-            fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n-               match_result {\n-                return match m {\n-                      match_expr(e) => {\n-                        if managed::ptr_eq(e, pat) {\n-                            // XXX: Is this right?\n-                            Some(leaf(match_exact))\n-                        } else {\n-                            None\n-                        }\n-                      }\n-                      _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                    }\n-            }\n-            b.literal_ast_matchers.push(|x| select(cx, x, e));\n-          }\n-        }\n-      }\n-      _ => cx.bug(~\"undocumented invariant in p_t_s_rec\")\n-    }\n-}\n-\n-\n-/* make a match more precise */\n-fn specialize_match(m: matchable) -> matchable {\n-    return match m {\n-          match_expr(e) => {\n-            match e.node {\n-              expr_path(pth) => {\n-                match path_to_ident(pth) {\n-                  Some(id) => match_ident(respan(pth.span, id)),\n-                  None => match_path(pth)\n-                }\n-              }\n-              _ => m\n-            }\n-          }\n-          _ => m\n-        }\n-}\n-\n-/* pattern_to_selectors helper functions */\n-fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n-    match path_to_ident(p) {\n-      Some(p_id) => {\n-        fn select(cx: ext_ctxt, m: matchable) -> match_result {\n-            return match m {\n-                  match_expr(*) => Some(leaf(specialize_match(m))),\n-                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                }\n-        }\n-        if b.real_binders.contains_key(p_id) {\n-            cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n-        }\n-        b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n-      }\n-      None => ()\n-    }\n-}\n-\n-fn block_to_ident(blk: blk_) -> Option<ident> {\n-    if vec::len(blk.stmts) != 0u { return None; }\n-    return match blk.expr {\n-          Some(expr) => match expr.node {\n-            expr_path(pth) => path_to_ident(pth),\n-            _ => None\n-          },\n-          None => None\n-        }\n-}\n-\n-fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, _s: selector, _b: binders) {\n-    fn select_pt_1(cx: ext_ctxt, m: matchable,\n-                   fn_m: fn(ast::mac) -> match_result) -> match_result {\n-        return match m {\n-              match_expr(e) => match e.node {\n-                expr_mac(ref mac) => fn_m((*mac)),\n-                _ => None\n-              },\n-              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-            }\n-    }\n-    fn no_des(cx: ext_ctxt, sp: span, syn: ~str) -> ! {\n-        cx.span_fatal(sp, ~\"destructuring \" + syn + ~\" is not yet supported\");\n-    }\n-    match mac.node {\n-      ast::mac_ellipsis => cx.span_fatal(mac.span, ~\"misused `...`\"),\n-      ast::mac_invoc(_, _, _) => no_des(cx, mac.span, ~\"macro calls\"),\n-      ast::mac_invoc_tt(_, _) => no_des(cx, mac.span, ~\"macro calls\"),\n-      ast::mac_aq(_,_) => no_des(cx, mac.span, ~\"antiquotes\"),\n-      ast::mac_var(_) => no_des(cx, mac.span, ~\"antiquote variables\")\n-    }\n-}\n-\n-fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n-                    b: binders) {\n-    fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n-       match_result {\n-        return match m {\n-              match_expr(e) => {\n-                match e.node {\n-                  expr_vec(arg_elts, _) => {\n-                    let mut elts = ~[];\n-                    let mut idx = offset;\n-                    while idx < vec::len(arg_elts) {\n-                        elts.push(leaf(match_expr(arg_elts[idx])));\n-                        idx += 1u;\n-                    }\n-\n-                    // using repeat_me.span is a little wacky, but the\n-                    // error we want to report is one in the macro def\n-                    Some(seq(@elts, repeat_me.span))\n-                  }\n-                  _ => None\n-                }\n-              }\n-              _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-            }\n-    }\n-    p_t_s_rec(cx, match_expr(repeat_me),\n-              compose_sels(s, |x| select(cx, repeat_me, offset, x)), b);\n-}\n-\n-\n-fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n-                  b: binders) {\n-    fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n-       match_result {\n-        return match m {\n-              match_expr(e) => {\n-                match e.node {\n-                  expr_vec(arg_elts, _) => {\n-                    let actual_len = vec::len(arg_elts);\n-                    if at_least && actual_len >= len || actual_len == len {\n-                        Some(leaf(match_exact))\n-                    } else { None }\n-                  }\n-                  _ => None\n-                }\n-              }\n-              _ => None\n-            }\n-    }\n-    b.literal_ast_matchers.push(\n-        compose_sels(s, |x| len_select(cx, x, at_least, len)));\n-}\n-\n-fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n-                         s: selector, b: binders) {\n-    let mut idx: uint = 0u;\n-    while idx < vec::len(elts) {\n-        fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n-            return match m {\n-                  match_expr(e) => {\n-                    match e.node {\n-                      expr_vec(arg_elts, _) => {\n-                        Some(leaf(match_expr(arg_elts[idx])))\n-                      }\n-                      _ => None\n-                    }\n-                  }\n-                  _ => cx.bug(~\"broken traversal in p_t_s_r\")\n-                }\n-        }\n-        p_t_s_rec(cx, match_expr(elts[idx]),\n-                  compose_sels(s, |x, copy idx| select(cx, x, idx)), b);\n-        idx += 1u;\n-    }\n-}\n-\n-fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                     _body: ast::mac_body) -> base::macro_def {\n-    let args = get_mac_args_no_max(cx, sp, arg, 0u, ~\"macro\");\n-\n-    let mut macro_name: Option<~str> = None;\n-    let mut clauses: ~[@clause] = ~[];\n-    for args.each |arg| {\n-        match arg.node {\n-          expr_vec(elts, _) => {\n-            if vec::len(elts) != 2u {\n-                cx.span_fatal((*arg).span,\n-                              ~\"extension clause must consist of ~[\" +\n-                                  ~\"macro invocation, expansion body]\");\n-            }\n-\n-\n-            match elts[0u].node {\n-              expr_mac(ref mac) => {\n-                match (*mac).node {\n-                  mac_invoc(pth, invoc_arg, _) => {\n-                    match path_to_ident(pth) {\n-                      Some(id) => {\n-                        let id_str = cx.str_of(id);\n-                        match macro_name {\n-                          None => macro_name = Some(id_str),\n-                          Some(ref other_id) => if id_str != (*other_id) {\n-                            cx.span_fatal(pth.span,\n-                                          ~\"macro name must be \" +\n-                                          ~\"consistent\");\n-                          }\n-                        }\n-                      },\n-                      None => cx.span_fatal(pth.span,\n-                                            ~\"macro name must not be a path\")\n-                    }\n-                    let arg = match invoc_arg {\n-                      Some(arg) => arg,\n-                      None => cx.span_fatal((*mac).span,\n-                                           ~\"macro must have arguments\")\n-                    };\n-                    clauses.push(@{params: pattern_to_selectors(cx, arg),\n-                                   body: elts[1u]});\n-\n-                    // FIXME (#2251): check duplicates (or just simplify\n-                    // the macro arg situation)\n-                  }\n-                  _ => {\n-                      cx.span_bug((*mac).span, ~\"undocumented invariant in \\\n-                         add_extension\");\n-                  }\n-                }\n-              }\n-              _ => {\n-                cx.span_fatal(elts[0u].span,\n-                              ~\"extension clause must\" +\n-                                  ~\" start with a macro invocation.\");\n-              }\n-            }\n-          }\n-          _ => {\n-            cx.span_fatal((*arg).span,\n-                          ~\"extension must be ~[clause, \" + ~\" ...]\");\n-          }\n-        }\n-    }\n-\n-    let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n-\n-    return {name:\n-             match macro_name {\n-               Some(ref id) => (*id),\n-               None => cx.span_fatal(sp, ~\"macro definition must have \" +\n-                                     ~\"at least one clause\")\n-             },\n-         ext: normal({expander: ext, span: Some(arg.get().span)})};\n-\n-    fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                         _body: ast::mac_body,\n-                         clauses: ~[@clause]) -> @expr {\n-        let arg = match arg {\n-          Some(arg) => arg,\n-          None => cx.span_fatal(sp, ~\"macro must have arguments\")\n-        };\n-        for clauses.each |c| {\n-            match use_selectors_to_bind(c.params, arg) {\n-              Some(bindings) => return transcribe(cx, bindings, c.body),\n-              None => loop\n-            }\n-        }\n-        cx.span_fatal(sp, ~\"no clauses match macro invocation\");\n-    }\n-}\n-\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "93845f3dbb859cc34315ca563dd205c6e3e0892a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -120,14 +120,7 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n     return {node:\n              match m.node {\n-               mac_invoc(pth, arg, body) => {\n-                 mac_invoc(fld.fold_path(pth),\n-                           option::map(&arg, |x| fld.fold_expr(*x)), body)\n-               }\n                mac_invoc_tt(*) => m.node,\n-               mac_ellipsis => mac_ellipsis,\n-               mac_aq(_,_) => /* FIXME (#2543) */ copy m.node,\n-               mac_var(_) => /* FIXME (#2543) */ copy m.node,\n              },\n          span: fld.new_span(m.span)};\n }"}, {"sha": "7248a0e224476a6e83cb7546a00fed02c5ae8283", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -12,16 +12,9 @@ use either::{Either, Left, Right};\n use ast_util::spanned;\n use common::*; //resolve bug?\n \n-export attr_or_ext;\n export parser_attr;\n \n-// A type to distingush between the parsing of item attributes or syntax\n-// extensions, which both begin with token.POUND\n-type attr_or_ext = Option<Either<~[ast::attribute], @ast::expr>>;\n-\n trait parser_attr {\n-    fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n-        -> attr_or_ext;\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n@@ -35,34 +28,6 @@ trait parser_attr {\n \n impl Parser: parser_attr {\n \n-    fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n-        -> attr_or_ext\n-    {\n-        let expect_item_next = vec::is_not_empty(first_item_attrs);\n-        match self.token {\n-          token::POUND => {\n-            let lo = self.span.lo;\n-            if self.look_ahead(1u) == token::LBRACKET {\n-                self.bump();\n-                let first_attr =\n-                    self.parse_attribute_naked(ast::attr_outer, lo);\n-                return Some(Left(vec::append(~[first_attr],\n-                                          self.parse_outer_attributes())));\n-            } else if !(self.look_ahead(1u) == token::LT\n-                        || self.look_ahead(1u) == token::LBRACKET\n-                        || self.look_ahead(1u) == token::POUND\n-                        || expect_item_next) {\n-                self.bump();\n-                return Some(Right(self.parse_syntax_ext_naked(lo)));\n-            } else { return None; }\n-        }\n-        token::DOC_COMMENT(_) => {\n-          return Some(Left(self.parse_outer_attributes()));\n-        }\n-        _ => return None\n-      }\n-    }\n-\n     // Parse attributes that appear before an item\n     fn parse_outer_attributes() -> ~[ast::attribute] {\n         let mut attrs: ~[ast::attribute] = ~[];"}, {"sha": "c4e34311b889838841e221ed7483d2726c9230c9", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -515,11 +515,6 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n             bump(rdr);\n             return token::DOTDOT;\n         }\n-        if rdr.curr == '.' && nextch(rdr) == '.' {\n-            bump(rdr);\n-            bump(rdr);\n-            return token::ELLIPSIS;\n-        }\n         return token::DOT;\n       }\n       '(' => { bump(rdr); return token::LPAREN; }"}, {"sha": "625ff289607f619db052cc3fb848291230b40012", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 108, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -54,8 +54,8 @@ use ast::{_mod, add, arg, arm, attribute,\n              item_foreign_mod, item_impl, item_mac, item_mod, item_trait,\n              item_ty, lit, lit_, lit_bool, lit_float, lit_float_unsuffixed,\n              lit_int, lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local,\n-             m_const, m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n-             mac_invoc_tt, mac_var, matcher, match_nonterminal, match_seq,\n+             m_const, m_imm, m_mutbl, mac_,\n+             mac_invoc_tt, matcher, match_nonterminal, match_seq,\n              match_tok, method, mode, module_ns, mt, mul, mutability,\n              named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n              pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct,\n@@ -510,15 +510,6 @@ impl Parser {\n \n         let lo = self.span.lo;\n \n-        match self.maybe_parse_dollar_mac() {\n-          Some(ref e) => {\n-            return @{id: self.get_id(),\n-                  node: ty_mac(spanned(lo, self.span.hi, (*e))),\n-                  span: mk_sp(lo, self.span.hi)};\n-          }\n-          None => ()\n-        }\n-\n         let t = if self.token == token::LPAREN {\n             self.bump();\n             if self.token == token::RPAREN {\n@@ -730,32 +721,6 @@ impl Parser {\n         }\n     }\n \n-    fn maybe_parse_dollar_mac() -> Option<mac_> {\n-        match copy self.token {\n-          token::DOLLAR => {\n-            let lo = self.span.lo;\n-            self.bump();\n-            match copy self.token {\n-              token::LIT_INT_UNSUFFIXED(num) => {\n-                self.bump();\n-                Some(mac_var(num as uint))\n-              }\n-              token::LPAREN => {\n-                self.bump();\n-                let e = self.parse_expr();\n-                self.expect(token::RPAREN);\n-                let hi = self.last_span.hi;\n-                Some(mac_aq(mk_sp(lo,hi), e))\n-              }\n-              _ => {\n-                self.fatal(~\"expected `(` or unsuffixed integer literal\");\n-              }\n-            }\n-          }\n-          _ => None\n-        }\n-    }\n-\n     fn maybe_parse_fixed_vstore_with_star() -> Option<uint> {\n         if self.eat(token::BINOP(token::STAR)) {\n             match copy self.token {\n@@ -928,11 +893,6 @@ impl Parser {\n \n         let mut ex: expr_;\n \n-        match self.maybe_parse_dollar_mac() {\n-          Some(ref x) => return self.mk_mac_expr(lo, self.span.hi, (*x)),\n-          _ => ()\n-        }\n-\n         if self.token == token::LPAREN {\n             self.bump();\n             if self.token == token::RPAREN {\n@@ -1022,13 +982,6 @@ impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-        } else if self.token == token::ELLIPSIS {\n-            self.bump();\n-            return self.mk_mac_expr(lo, self.span.hi, mac_ellipsis);\n-        } else if self.token == token::POUND {\n-            let ex_ext = self.parse_syntax_ext();\n-            hi = ex_ext.span.hi;\n-            ex = ex_ext.node;\n         } else if self.eat_keyword(~\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -1141,54 +1094,6 @@ impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n-    fn parse_syntax_ext() -> @expr {\n-        let lo = self.span.lo;\n-        self.expect(token::POUND);\n-        return self.parse_syntax_ext_naked(lo);\n-    }\n-\n-    fn parse_syntax_ext_naked(lo: BytePos) -> @expr {\n-        match self.token {\n-          token::IDENT(_, _) => (),\n-          _ => self.fatal(~\"expected a syntax expander name\")\n-        }\n-        let pth = self.parse_path_without_tps();\n-        //temporary for a backwards-compatible cycle:\n-        let sep = seq_sep_trailing_disallowed(token::COMMA);\n-        let mut e = None;\n-        if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n-            let lo = self.span.lo;\n-            let es =\n-                if self.token == token::LPAREN {\n-                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                             sep, |p| p.parse_expr())\n-                } else {\n-                    self.parse_unspanned_seq(token::LBRACKET, token::RBRACKET,\n-                                             sep, |p| p.parse_expr())\n-                };\n-            let hi = self.span.hi;\n-            e = Some(self.mk_expr(lo, hi, expr_vec(es, m_imm)));\n-        }\n-        let mut b = None;\n-        if self.token == token::LBRACE {\n-            self.bump();\n-            let lo = self.span.lo;\n-            let mut depth = 1u;\n-            while (depth > 0u) {\n-                match (self.token) {\n-                  token::LBRACE => depth += 1u,\n-                  token::RBRACE => depth -= 1u,\n-                  token::EOF => self.fatal(~\"unexpected EOF in macro body\"),\n-                  _ => ()\n-                }\n-                self.bump();\n-            }\n-            let hi = self.last_span.lo;\n-            b = Some({span: mk_sp(lo,hi)});\n-        }\n-        return self.mk_mac_expr(lo, self.span.hi, mac_invoc(pth, e, b));\n-    }\n-\n     fn parse_dot_or_call_expr() -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n@@ -2253,17 +2158,8 @@ impl Parser {\n             }\n \n         } else {\n-            let mut item_attrs;\n-            match self.parse_outer_attrs_or_ext(first_item_attrs) {\n-              None => item_attrs = ~[],\n-              Some(Left(ref attrs)) => item_attrs = (*attrs),\n-              Some(Right(ext)) => {\n-                return @spanned(lo, ext.span.hi,\n-                                stmt_expr(ext, self.get_id()));\n-              }\n-            }\n-\n-            let item_attrs = vec::append(first_item_attrs, item_attrs);\n+            let item_attrs = vec::append(first_item_attrs,\n+                                         self.parse_outer_attributes());\n \n             match self.parse_item_or_view_item(item_attrs,\n                                                true, false, false) {"}, {"sha": "7e7c61d2bf24903cd3273139cb9c1d1e4dac55a1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -49,7 +49,6 @@ enum Token {\n     AT,\n     DOT,\n     DOTDOT,\n-    ELLIPSIS,\n     COMMA,\n     SEMI,\n     COLON,\n@@ -137,7 +136,6 @@ fn to_str(in: @ident_interner, t: Token) -> ~str {\n       AT => ~\"@\",\n       DOT => ~\".\",\n       DOTDOT => ~\"..\",\n-      ELLIPSIS => ~\"...\",\n       COMMA => ~\",\",\n       SEMI => ~\";\",\n       COLON => ~\":\",\n@@ -578,12 +576,6 @@ impl Token : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ELLIPSIS => {\n-                match (*other) {\n-                    ELLIPSIS => true,\n-                    _ => false\n-                }\n-            }\n             COMMA => {\n                 match (*other) {\n                     COMMA => true,"}, {"sha": "684f74f3575c4f84503237c4cf7fd7c0a95a4aa2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -590,9 +590,6 @@ fn print_item(s: ps, &&item: @ast::item) {\n         pclose(s);\n         end(s);\n       }\n-      ast::item_mac(_) => {\n-        fail ~\"invalid item-position syntax bit\"\n-      }\n     }\n     (s.ann.post)(ann_node);\n }\n@@ -1000,26 +997,13 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n \n fn print_mac(s: ps, m: ast::mac) {\n     match m.node {\n-      ast::mac_invoc(path, arg, _body) => {\n-        word(s.s, ~\"#\");\n-        print_path(s, path, false);\n-        match arg {\n-          Some(@{node: ast::expr_vec(_, _), _}) => (),\n-          _ => word(s.s, ~\" \")\n-        }\n-        arg.iter(|a| print_expr(s, *a));\n-        // FIXME: extension 'body' (#2339)\n-      }\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, ~\"!\");\n         popen(s);\n         for (*tts).each() |tt| { print_tt(s, *tt); }\n         pclose(s);\n       }\n-      ast::mac_ellipsis => word(s.s, ~\"...\"),\n-      ast::mac_var(v) => word(s.s, fmt!(\"$%u\", v)),\n-      _ => { /* fixme */ }\n     }\n }\n "}, {"sha": "00c3804cce16cf8f35baa9964949adce344a1806", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -99,9 +99,6 @@ mod ext {\n     }\n \n \n-    #[legacy_exports]\n-    #[path = \"ext/simplext.rs\"]\n-    mod simplext;\n     #[legacy_exports]\n     #[path = \"ext/fmt.rs\"]\n     mod fmt;"}, {"sha": "7b406564114b8c7622e4f8d30d9b2b1d7973b994", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -379,15 +379,8 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n-fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n-    match m.node {\n-      ast::mac_invoc(_, arg, _) => {\n-        option::map(&arg, |arg| (v.visit_expr)(*arg, e, v)); }\n-      ast::mac_invoc_tt(*) => { /* no user-serviceable parts inside */ }\n-      ast::mac_ellipsis => (),\n-      ast::mac_aq(*) => { /* FIXME: maybe visit (Issue #2340) */ }\n-      ast::mac_var(_) => ()\n-    }\n+fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n+    /* no user-serviceable parts inside */\n }\n \n fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {"}, {"sha": "187956b645af80c4067844bf9b15e165c06128f8", "filename": "src/test/compile-fail/issue-1448-1.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Regresion test for issue #1448 and #1386\n-\n-fn main() {\n-    #macro[[#apply[f, [x, ...]], f(x, ...)]];\n-    fn add(a: int, b: int) -> int { return a + b; }\n-    assert (apply!(add, [y, 15]) == 16); //~ ERROR unresolved name: y\n-}"}, {"sha": "57ed12789ab6ec821418e3a88a3d64cdfc981954", "filename": "src/test/compile-fail/macro-2.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//error-pattern:is an expr, expected a path\n-fn main() {\n-    #macro[[#mylambda[x, body],\n-            {\n-                fn f(x: int) -> int { return body }\n-                f\n-            }]];\n-\n-    assert (mylambda!(y * 1, y * 2)(8) == 16);\n-}"}, {"sha": "43ce05845ec58b5178ec0ee5914ee2b9e0db6ca2", "filename": "src/test/compile-fail/macro.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//error-pattern:no clauses match\n-\n-fn main() {\n-    #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n-\n-    assert (trivial!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) ==\n-                16);\n-}"}, {"sha": "e23651d262cc971f103d67efb46ed916b1af7350", "filename": "src/test/run-pass/macro-3.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty - token trees can't pretty print\n-\n-fn main() {\n-    #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n-\n-    assert (trivial!() == 16);\n-\n-    macro_rules! trivial_tt(\n-        () => {1*2*4*2*1}\n-    )\n-    assert(trivial_tt!() == 16);\n-}"}, {"sha": "3e8bced1b889c460c6de8f60423a204dd48f223a", "filename": "src/test/run-pass/macro-by-example-1.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-fn main() {\n-    #macro[[#apply[f, [x, ...]], f(x, ...)]];\n-\n-    macro_rules! apply_tt(\n-        ($f:expr, ($($x:expr),*)) => {$f($($x),*)}\n-    )\n-\n-    fn add(a: int, b: int) -> int { return a + b; }\n-\n-    assert(apply!(add, [1, 15]) == 16);\n-    assert(apply!(add, [1, 15]) == 16);\n-    assert(apply_tt!(add, (1, 15)) == 16);\n-}"}, {"sha": "903dc0439e580e65a110e6e3f886f04db285b398", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// I can't for the life of me manage to untangle all of the brackets\n-// in this test, so I am xfailing it...\n-\n-fn main() {\n-    #macro[[#zip_or_unzip[[x, ...], [y, ...]], [[x, y], ...]],\n-           [#zip_or_unzip[[xx, yy], ...], [[xx, ...], [yy, ...]]]];\n-\n-\n-    assert (zip_or_unzip!([1, 2, 3, 4], [5, 6, 7, 8]) ==\n-                [[1, 5], [2, 6], [3, 7], [4, 8]]);\n-    assert (zip_or_unzip!([1, 5], [2, 6], [3, 7], [4, 8]) ==\n-                [[1, 2, 3, 4], [5, 6, 7, 8]]);\n-\n-\n-    #macro[[#nested[[[x, ...], ...], [[y, ...], ...]], [[[x, y], ...], ...]]];\n-    assert (nested!([[1, 2, 3, 4, 5], [7, 8, 9, 10, 11, 12]],\n-                    [[-1, -2, -3, -4, -5], [-7, -8, -9, -10, -11, -12]]) ==\n-                [[[1, -1], [2, -2], [3, -3], [4, -4], [5, -5]],\n-                 [[7, -7], [8, -8], [9, -9], [10, -10], [11, -11],\n-                  [12, -12]]]);\n-\n-    #macro[[#dup[y, [x, ...]], [[y, x], ...]]];\n-\n-    assert (dup!(1, [1, 2, 3, 4]) == [[1, 1], [1, 2], [1, 3], [1, 4]]);\n-\n-\n-    #macro[[#lambda[x, #<t>, body, #<s>],\n-            {\n-                fn result(x: t) -> s { return body }\n-                result\n-            }]];\n-\n-\n-    assert (lambda!(i, #<uint>, i + 4u, #<uint>)(12u) == 16u);\n-\n-    #macro[[#sum[x, xs, ...], x + #sum[xs, ...]], [#sum[], 0]];\n-\n-    assert (sum!(1, 2, 3, 4) == 10);\n-\n-\n-    #macro[[#transcr_mixed[a, as, ...], #sum[6, as, ...] * a]];\n-\n-    assert (transcr_mixed!(10, 5, 4, 3, 2, 1) == 210);\n-\n-    #macro[[#surround[pre, [xs, ...], post], [pre, xs, ..., post]]];\n-\n-    assert (surround!(1, [2, 3, 4], 5) == [1, 2, 3, 4, 5]);\n-\n-}"}, {"sha": "f928043150ede2c0a147bd3bee864b271c615a8f", "filename": "src/test/run-pass/macro.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty - token trees can't pretty print\n-\n-fn main() {\n-    #macro[[#m1[a], a * 4]];\n-    assert (m1!(2) == 8);\n-\n-    macro_rules! m1tt (\n-        ($a:expr) => {$a*4}\n-    );\n-    assert(m1tt!(2) == 8);\n-}"}, {"sha": "eca0881deafd5e91bff4a1af171ed4e539750728", "filename": "src/test/run-pass/syntax-extension-source-utils-files/includeme.fragment", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment", "raw_url": "https://github.com/rust-lang/rust/raw/e24ae85025e40aa17915f6c604d89aefbca274bd/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils-files%2Fincludeme.fragment?ref=e24ae85025e40aa17915f6c604d89aefbca274bd", "patch": "@@ -1,7 +1,7 @@\n /* this is for run-pass/syntax-extension-source-utils.rs */\n \n {\n-    assert(#file[].ends_with(\"includeme.fragment\"));\n-    assert(#line[] == 5u);\n-    #fmt[\"victory robot %u\", #line[]]\n+    assert(file!().ends_with(\"includeme.fragment\"));\n+    assert(line!() == 5u);\n+    fmt!(\"victory robot %u\", line!())\n }"}]}