{"sha": "e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "node_id": "C_kwDOAAsO6NoAKGUxYjFkN2IwMjlmOGE4ZTZiYWRlNzFjYjAzYWU1OWIzNjQ3NDVjMzE", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-01T17:29:23Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-27T18:29:18Z"}, "message": "Migrate more rustc_parse diagnostics to diagnostic structs", "tree": {"sha": "d406954b95d670efe0ba4c7d01b4c68b90e5ebcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d406954b95d670efe0ba4c7d01b4c68b90e5ebcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "html_url": "https://github.com/rust-lang/rust/commit/e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e56d6a68dbda754b414abff41517f3fad9e547b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e56d6a68dbda754b414abff41517f3fad9e547b0", "html_url": "https://github.com/rust-lang/rust/commit/e56d6a68dbda754b414abff41517f3fad9e547b0"}], "stats": {"total": 352, "additions": 192, "deletions": 160}, "files": [{"sha": "36b03a2db775b05cf0548267d9b0010799d16252", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -188,7 +188,8 @@ parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call\n     .suggestion_no_fields_for_fn = if `{$name}` is a function, use the arguments directly\n \n parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n-    .suggestion = wrap the expression in parentheses\n+\n+parser_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n \n parser_array_brackets_instead_of_braces = this is a block expression, not an array\n     .suggestion = to make an array, use square brackets instead of curly braces\n@@ -231,3 +232,33 @@ parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter\n     .label_unmatched = mismatched closing delimiter\n     .label_opening_candidate = closing delimiter possibly meant for this\n     .label_unclosed = unclosed delimiter\n+\n+parser_incorrect_visibility_restriction = incorrect visibility restriction\n+    .help = some possible visibility restrictions are:\n+            `pub(crate)`: visible only on the current crate\n+            `pub(super)`: visible only in the current module's parent\n+            `pub(in path::to::module)`: visible only on the specified path\n+    .suggestion = make this visible only to module `{$inner_str}` with `in`\n+\n+parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n+\n+parser_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, maybe a comment was intended with `//`?\n+    .suggestion = missing comma here\n+\n+parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n+\n+parser_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parser_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+\n+parser_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n+\n+parser_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+parser_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`"}, {"sha": "968d0be5b4294ff80010047da2205298deb0b041", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -624,16 +624,19 @@ pub(crate) struct LabeledLoopInBreak {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n-    pub sub: LabeledLoopInBreakSub,\n+    pub sub: WrapExpressionInParentheses,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n-pub(crate) struct LabeledLoopInBreakSub {\n+#[multipart_suggestion(\n+    parser::sugg_wrap_expression_in_parentheses,\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct WrapExpressionInParentheses {\n     #[suggestion_part(code = \"(\")]\n-    pub first: Span,\n+    pub left: Span,\n     #[suggestion_part(code = \")\")]\n-    pub second: Span,\n+    pub right: Span,\n }\n \n #[derive(Diagnostic)]\n@@ -781,3 +784,89 @@ pub(crate) struct MismatchedClosingDelimiter {\n     #[label(parser::label_unclosed)]\n     pub unclosed: Option<Span>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_visibility_restriction, code = \"E0704\")]\n+#[help]\n+pub(crate) struct IncorrectVisibilityRestriction {\n+    #[primary_span]\n+    #[suggestion(code = \"in {inner_str}\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub inner_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::assignment_else_not_allowed)]\n+pub(crate) struct AssignmentElseNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_statement_after_outer_attr)]\n+pub(crate) struct ExpectedStatementAfterOuterAttr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::doc_comment_does_not_document_anything, code = \"E0585\")]\n+#[help]\n+pub(crate) struct DocCommentDoesNotDocumentAnything {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \",\", applicability = \"machine-applicable\")]\n+    pub missing_comma: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::const_let_mutually_exclusive)]\n+pub(crate) struct ConstLetMutuallyExclusive {\n+    #[primary_span]\n+    #[suggestion(code = \"const\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_expression_in_let_else)]\n+pub(crate) struct InvalidExpressionInLetElse {\n+    #[primary_span]\n+    pub span: Span,\n+    pub operator: &'static str,\n+    #[subdiagnostic]\n+    pub sugg: WrapExpressionInParentheses,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_curly_in_let_else)]\n+pub(crate) struct InvalidCurlyInLetElse {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: WrapExpressionInParentheses,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::compound_assignment_expression_in_let)]\n+#[help]\n+pub(crate) struct CompoundAssignmentExpressionInLet {\n+    #[primary_span]\n+    #[suggestion_short(code = \"=\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::suffixed_literal_in_attribute)]\n+#[help]\n+pub(crate) struct SuffixedLiteralInAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_meta_item)]\n+pub(crate) struct InvalidMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub token: String,\n+}"}, {"sha": "1966345f19f3a8a1ec6c66480b4e171211d517fa", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -1,9 +1,11 @@\n+use crate::errors::{InvalidMetaItem, SuffixedLiteralInAttribute};\n+\n use super::{AttrWrapper, Capturing, FnParseMode, ForceCollect, Parser, PathStyle};\n use rustc_ast as ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Delimiter, Nonterminal};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{error_code, Diagnostic, PResult};\n+use rustc_errors::{error_code, Diagnostic, IntoDiagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n use std::convert::TryInto;\n \n@@ -337,12 +339,7 @@ impl<'a> Parser<'a> {\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n-            self.struct_span_err(lit.span, \"suffixed literals are not allowed in attributes\")\n-                .help(\n-                    \"instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), \\\n-                    use an unsuffixed version (`1`, `1.0`, etc.)\",\n-                )\n-                .emit();\n+            self.sess.emit_err(SuffixedLiteralInAttribute { span: lit.span });\n         }\n \n         Ok(lit)\n@@ -435,9 +432,9 @@ impl<'a> Parser<'a> {\n             Err(err) => err.cancel(),\n         }\n \n-        let found = pprust::token_to_string(&self.token);\n-        let msg = format!(\"expected unsuffixed literal or identifier, found `{found}`\");\n-        Err(self.struct_span_err(self.token.span, &msg))\n+        let token = pprust::token_to_string(&self.token).to_string();\n+        Err(InvalidMetaItem { span: self.token.span, token }\n+            .into_diagnostic(&self.sess.span_diagnostic))\n     }\n }\n "}, {"sha": "326b2553eaf1c84016923e047cd83bd58279411c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -55,34 +55,6 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n     }\n }\n \n-pub enum Error {\n-    UselessDocComment,\n-}\n-\n-impl Error {\n-    fn span_err(\n-        self,\n-        sp: impl Into<MultiSpan>,\n-        handler: &Handler,\n-    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        match self {\n-            Error::UselessDocComment => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0585,\n-                    \"found a documentation comment that doesn't document anything\",\n-                );\n-                err.help(\n-                    \"doc comments must come before what they document, maybe a comment was \\\n-                          intended with `//`?\",\n-                );\n-                err\n-            }\n-        }\n-    }\n-}\n-\n pub(super) trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n     fn to_ty(&self) -> Option<P<Ty>>;\n@@ -268,15 +240,6 @@ impl<'a> DerefMut for SnapshotParser<'a> {\n }\n \n impl<'a> Parser<'a> {\n-    #[rustc_lint_diagnostics]\n-    pub(super) fn span_err<S: Into<MultiSpan>>(\n-        &self,\n-        sp: S,\n-        err: Error,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        err.span_err(sp, self.diagnostic())\n-    }\n-\n     #[rustc_lint_diagnostics]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,"}, {"sha": "751951dcaaeec0e6f0942a484b2194e56edc8322", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -17,14 +17,14 @@ use crate::errors::{\n     InvalidIntLiteralWidth, InvalidInterpolatedExpression, InvalidLiteralSuffix,\n     InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n     InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix, LabeledLoopInBreak,\n-    LabeledLoopInBreakSub, LeadingPlusNotSupported, LeftArrowOperator, LifetimeInBorrowExpression,\n+    LeadingPlusNotSupported, LeftArrowOperator, LifetimeInBorrowExpression,\n     MacroInvocationWithQualifiedPath, MalformedLoopLabel, MatchArmBodyWithoutBraces,\n     MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm, MissingInInForLoop,\n     MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n     NotAsNegationOperatorSub, OctalFloatLiteralNotSupported, OuterAttributeNotAllowedOnIfElse,\n     ParenthesesWithStructFields, RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric,\n     StructLiteralNotAllowedHere, StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator,\n-    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg,\n+    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n@@ -1661,9 +1661,9 @@ impl<'a> Parser<'a> {\n             let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n             self.sess.emit_err(LabeledLoopInBreak {\n                 span: lexpr.span,\n-                sub: LabeledLoopInBreakSub {\n-                    first: lexpr.span.shrink_to_lo(),\n-                    second: lexpr.span.shrink_to_hi(),\n+                sub: WrapExpressionInParentheses {\n+                    left: lexpr.span.shrink_to_lo(),\n+                    right: lexpr.span.shrink_to_hi(),\n                 },\n             });\n             Some(lexpr)"}, {"sha": "b7454d7bfc18e207344c2798daef198a8a8081a3", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -1,6 +1,6 @@\n-use crate::errors::UseEmptyBlockNotSemi;\n+use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n \n-use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n+use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n \n@@ -15,7 +15,7 @@ use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, Vari\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n+use rustc_errors::{struct_span_err, Applicability, IntoDiagnostic, PResult, StashKey};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n@@ -1586,7 +1586,10 @@ impl<'a> Parser<'a> {\n             token::CloseDelim(Delimiter::Brace) => {}\n             token::DocComment(..) => {\n                 let previous_span = self.prev_token.span;\n-                let mut err = self.span_err(self.token.span, Error::UselessDocComment);\n+                let mut err = DocCommentDoesNotDocumentAnything {\n+                    span: self.token.span,\n+                    missing_comma: None,\n+                };\n                 self.bump(); // consume the doc comment\n                 let comma_after_doc_seen = self.eat(&token::Comma);\n                 // `seen_comma` is always false, because we are inside doc block\n@@ -1595,18 +1598,13 @@ impl<'a> Parser<'a> {\n                     seen_comma = true;\n                 }\n                 if comma_after_doc_seen || self.token == token::CloseDelim(Delimiter::Brace) {\n-                    err.emit();\n+                    self.sess.emit_err(err);\n                 } else {\n                     if !seen_comma {\n                         let sp = self.sess.source_map().next_point(previous_span);\n-                        err.span_suggestion(\n-                            sp,\n-                            \"missing comma here\",\n-                            \",\",\n-                            Applicability::MachineApplicable,\n-                        );\n+                        err.missing_comma = Some(sp);\n                     }\n-                    return Err(err);\n+                    return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n             _ => {"}, {"sha": "07fa909e71b2752b861c9cebc5a44f6bc59ad206", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -13,7 +13,6 @@ mod ty;\n use crate::lexer::UnmatchedBrace;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n-use diagnostics::Error;\n pub(crate) use item::FnParseMode;\n pub use pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n pub use path::PathStyle;\n@@ -32,8 +31,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::PResult;\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic,\n-    MultiSpan,\n+    Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic, MultiSpan,\n };\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n@@ -42,7 +40,10 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use std::ops::Range;\n use std::{cmp, mem, slice};\n \n-use crate::errors::{MismatchedClosingDelimiter, NonStringAbiLiteral};\n+use crate::errors::{\n+    DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n+    NonStringAbiLiteral,\n+};\n \n bitflags::bitflags! {\n     struct Restrictions: u8 {\n@@ -521,9 +522,11 @@ impl<'a> Parser<'a> {\n \n     fn ident_or_err(&mut self) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n         self.token.ident().ok_or_else(|| match self.prev_token.kind {\n-            TokenKind::DocComment(..) => {\n-                self.span_err(self.prev_token.span, Error::UselessDocComment)\n+            TokenKind::DocComment(..) => DocCommentDoesNotDocumentAnything {\n+                span: self.prev_token.span,\n+                missing_comma: None,\n             }\n+            .into_diagnostic(&self.sess.span_diagnostic),\n             _ => self.expected_ident_found(),\n         })\n     }\n@@ -1347,23 +1350,8 @@ impl<'a> Parser<'a> {\n         let path = self.parse_path(PathStyle::Mod)?;\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n \n-        let msg = \"incorrect visibility restriction\";\n-        let suggestion = r##\"some possible visibility restrictions are:\n-`pub(crate)`: visible only on the current crate\n-`pub(super)`: visible only in the current module's parent\n-`pub(in path::to::module)`: visible only on the specified path\"##;\n-\n         let path_str = pprust::path_to_string(&path);\n-\n-        struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n-            .help(suggestion)\n-            .span_suggestion(\n-                path.span,\n-                &format!(\"make this visible only to module `{}` with `in`\", path_str),\n-                format!(\"in {}\", path_str),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(IncorrectVisibilityRestriction { span: path.span, inner_str: path_str });\n \n         Ok(())\n     }"}, {"sha": "155173f120c8bf5aa9a5821ef2760bf210da6451", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 30, "deletions": 64, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -1,13 +1,18 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::{AttemptLocalParseRecovery, Error};\n+use super::diagnostics::AttemptLocalParseRecovery;\n use super::expr::LhsExpr;\n use super::pat::RecoverComma;\n use super::path::PathStyle;\n use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n-use crate::errors::{InvalidVariableDeclaration, InvalidVariableDeclarationSub};\n+use crate::errors::{\n+    AssignmentElseNotAllowed, CompoundAssignmentExpressionInLet, ConstLetMutuallyExclusive,\n+    DocCommentDoesNotDocumentAnything, ExpectedStatementAfterOuterAttr, InvalidCurlyInLetElse,\n+    InvalidExpressionInLetElse, InvalidVariableDeclaration, InvalidVariableDeclarationSub,\n+    WrapExpressionInParentheses,\n+};\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n@@ -111,11 +116,7 @@ impl<'a> Parser<'a> {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else.\n                 // This is not allowed, but point it out in a nice way.\n-                let mut err = self.struct_span_err(\n-                    e.span.to(bl.span),\n-                    \"<assignment> ... else { ... } is not allowed\",\n-                );\n-                err.emit();\n+                self.sess.emit_err(AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n@@ -201,9 +202,12 @@ impl<'a> Parser<'a> {\n     fn error_outer_attrs(&self, attrs: &[Attribute]) {\n         if let [.., last] = attrs {\n             if last.is_doc_comment() {\n-                self.span_err(last.span, Error::UselessDocComment).emit();\n+                self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n+                    span: last.span,\n+                    missing_comma: None,\n+                });\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.struct_span_err(last.span, \"expected statement after outer attribute\").emit();\n+                self.sess.emit_err(ExpectedStatementAfterOuterAttr { span: last.span });\n             }\n         }\n     }\n@@ -254,17 +258,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n \n         if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n-            self.struct_span_err(\n-                lo.to(self.token.span),\n-                \"`const` and `let` are mutually exclusive\",\n-            )\n-            .span_suggestion(\n-                lo.to(self.token.span),\n-                \"remove `let`\",\n-                \"const\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            self.sess.emit_err(ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n             self.bump();\n         }\n \n@@ -362,44 +356,27 @@ impl<'a> Parser<'a> {\n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {\n-                let suggs = vec![\n-                    (init.span.shrink_to_lo(), \"(\".to_string()),\n-                    (init.span.shrink_to_hi(), \")\".to_string()),\n-                ];\n-                self.struct_span_err(\n-                    init.span,\n-                    &format!(\n-                        \"a `{}` expression cannot be directly assigned in `let...else`\",\n-                        op.node.to_string()\n-                    ),\n-                )\n-                .multipart_suggestion(\n-                    \"wrap the expression in parentheses\",\n-                    suggs,\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                self.sess.emit_err(InvalidExpressionInLetElse {\n+                    span: init.span,\n+                    operator: op.node.to_string(),\n+                    sugg: WrapExpressionInParentheses {\n+                        left: init.span.shrink_to_lo(),\n+                        right: init.span.shrink_to_hi(),\n+                    },\n+                });\n             }\n         }\n     }\n \n     fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n         if let Some(trailing) = classify::expr_trailing_brace(init) {\n-            let err_span = trailing.span.with_lo(trailing.span.hi() - BytePos(1));\n-            let suggs = vec![\n-                (trailing.span.shrink_to_lo(), \"(\".to_string()),\n-                (trailing.span.shrink_to_hi(), \")\".to_string()),\n-            ];\n-            self.struct_span_err(\n-                err_span,\n-                \"right curly brace `}` before `else` in a `let...else` statement not allowed\",\n-            )\n-            .multipart_suggestion(\n-                \"try wrapping the expression in parentheses\",\n-                suggs,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(InvalidCurlyInLetElse {\n+                span: trailing.span.with_lo(trailing.span.hi() - BytePos(1)),\n+                sugg: WrapExpressionInParentheses {\n+                    left: trailing.span.shrink_to_lo(),\n+                    right: trailing.span.shrink_to_hi(),\n+                },\n+            });\n         }\n     }\n \n@@ -408,18 +385,7 @@ impl<'a> Parser<'a> {\n         let eq_consumed = match self.token.kind {\n             token::BinOpEq(..) => {\n                 // Recover `let x <op>= 1` as `let x = 1`\n-                self.struct_span_err(\n-                    self.token.span,\n-                    \"can't reassign to an uninitialized variable\",\n-                )\n-                .span_suggestion_short(\n-                    self.token.span,\n-                    \"initialize the variable\",\n-                    \"=\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .help(\"if you meant to overwrite, remove the `let` binding\")\n-                .emit();\n+                self.sess.emit_err(CompoundAssignmentExpressionInLet { span: self.token.span });\n                 self.bump();\n                 true\n             }"}, {"sha": "cb01e4c18a114f8725f657c5c6f13cf95ca8fe4b", "filename": "src/test/ui/let-else/let-else-brace-before-else.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b1d7b029f8a8e6bade71cb03ae59b364745c31/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr?ref=e1b1d7b029f8a8e6bade71cb03ae59b364745c31", "patch": "@@ -4,7 +4,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = { Some(1) } else {\n    |                             ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = ({ Some(1) }) else {\n    |                   +           +\n@@ -15,7 +15,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = loop { break Some(1) } else {\n    |                                        ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = (loop { break Some(1) }) else {\n    |                   +                      +\n@@ -26,7 +26,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let 2 = 1 + match 1 { n => n } else {\n    |                                  ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let 2 = 1 + (match 1 { n => n }) else {\n    |                 +                  +\n@@ -37,7 +37,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = unsafe { unsafe_fn() } else {\n    |                                        ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = (unsafe { unsafe_fn() }) else {\n    |                   +                      +"}]}