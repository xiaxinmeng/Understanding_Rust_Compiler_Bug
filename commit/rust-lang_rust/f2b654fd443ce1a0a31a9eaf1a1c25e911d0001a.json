{"sha": "f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYjY1NGZkNDQzY2UxYTBhMzFhOWVhZjFhMWMyNWU5MTFkMDAwMWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T21:50:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-01T10:51:44Z"}, "message": "Add inline source", "tree": {"sha": "9c9cfc3f6868864d7dd1164aaff6b248f81a402b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c9cfc3f6868864d7dd1164aaff6b248f81a402b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "html_url": "https://github.com/rust-lang/rust/commit/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "223fd2979c277cf402e4876d0e9a69257702f731", "url": "https://api.github.com/repos/rust-lang/rust/commits/223fd2979c277cf402e4876d0e9a69257702f731", "html_url": "https://github.com/rust-lang/rust/commit/223fd2979c277cf402e4876d0e9a69257702f731"}], "stats": {"total": 139, "additions": 93, "deletions": 46}, "files": [{"sha": "6667c06e7d9ad91745e31a04783134cad10b214d", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "patch": "@@ -148,7 +148,7 @@ fn complete_module_items(\n     this_item: Option<ast::NameRef>,\n     acc: &mut Vec<CompletionItem>,\n ) {\n-    let scope = ModuleScope::from_items(items);\n+    let scope = ModuleScope::new(items); // FIXME\n     acc.extend(\n         scope\n             .entries()"}, {"sha": "3a010ecf54e75ee422e57d22c60e12085e5681e8", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, NameOwner},\n+    ast::{self, ModuleItemOwner, NameOwner},\n     SmolStr,\n };\n use relative_path::RelativePathBuf;\n@@ -15,7 +15,8 @@ use crate::{\n };\n \n use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleScope, ModuleSource, ModuleTree, Problem,\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleScope, ModuleSource, ModuleSourceNode,\n+    ModuleTree, Problem,\n };\n \n pub(crate) fn submodules(\n@@ -45,9 +46,14 @@ pub(crate) fn module_scope(\n     module_id: ModuleId,\n ) -> Cancelable<Arc<ModuleScope>> {\n     let tree = db.module_tree(source_root_id)?;\n-    let ModuleSource::File(file_id) = module_id.source(&tree);\n-    let syntax = db.file_syntax(file_id);\n-    let res = ModuleScope::new(&syntax);\n+    let source = module_id.source(&tree).resolve(db);\n+    let res = match source {\n+        ModuleSourceNode::Root(root) => ModuleScope::new(root.ast().items()),\n+        ModuleSourceNode::Inline(inline) => match inline.ast().item_list() {\n+            Some(items) => ModuleScope::new(items.items()),\n+            None => ModuleScope::new(std::iter::empty()),\n+        },\n+    };\n     Ok(Arc::new(res))\n }\n "}, {"sha": "e22489fc105e8e3a550d4c209d950fd12dcb56da", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n };\n use relative_path::RelativePathBuf;\n \n-use crate::FileId;\n+use crate::{db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId};\n \n pub(crate) use self::scope::ModuleScope;\n \n@@ -39,6 +39,23 @@ impl ModuleTree {\n     }\n }\n \n+/// `ModuleSource` is the syntax tree element that produced this module:\n+/// either a file, or an inlinde module.\n+/// TODO: we don't produce Inline modules yet\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum ModuleSource {\n+    File(FileId),\n+    #[allow(dead_code)]\n+    Inline(SyntaxPtr),\n+}\n+\n+/// An owned syntax node for a module. Unlike `ModuleSource`,\n+/// this holds onto the AST for the whole file.\n+enum ModuleSourceNode {\n+    Root(ast::RootNode),\n+    Inline(ast::ModuleNode),\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub(crate) struct ModuleId(u32);\n \n@@ -89,14 +106,18 @@ impl ModuleId {\n             .find(|it| it.name == name)?;\n         Some(*link.points_to.first()?)\n     }\n-    pub(crate) fn problems(self, tree: &ModuleTree, root: ast::Root) -> Vec<(SyntaxNode, Problem)> {\n+    pub(crate) fn problems(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl SyntaxDatabase,\n+    ) -> Vec<(SyntaxNode, Problem)> {\n         tree.module(self)\n             .children\n             .iter()\n             .filter_map(|&it| {\n                 let p = tree.link(it).problem.clone()?;\n-                let s = it.bind_source(tree, root);\n-                let s = s.name().unwrap().syntax().owned();\n+                let s = it.bind_source(tree, db);\n+                let s = s.ast().name().unwrap().syntax().owned();\n                 Some((s, p))\n             })\n             .collect()\n@@ -107,11 +128,24 @@ impl LinkId {\n     pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n-    pub(crate) fn bind_source<'a>(self, tree: &ModuleTree, root: ast::Root<'a>) -> ast::Module<'a> {\n-        imp::modules(root)\n-            .find(|(name, _)| name == &tree.link(self).name)\n-            .unwrap()\n-            .1\n+    pub(crate) fn bind_source<'a>(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl SyntaxDatabase,\n+    ) -> ast::ModuleNode {\n+        let owner = self.owner(tree);\n+        match owner.source(tree).resolve(db) {\n+            ModuleSourceNode::Root(root) => {\n+                let ast = imp::modules(root.ast())\n+                    .find(|(name, _)| name == &tree.link(self).name)\n+                    .unwrap()\n+                    .1;\n+                ast.into()\n+            }\n+            ModuleSourceNode::Inline(..) => {\n+                unimplemented!(\"https://github.com/rust-analyzer/rust-analyzer/issues/181\")\n+            }\n+        }\n     }\n }\n \n@@ -122,20 +156,32 @@ struct ModuleData {\n     children: Vec<LinkId>,\n }\n \n-/// `ModuleSource` is the syntax tree element that produced this module:\n-/// either a file, or an inlinde module.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum ModuleSource {\n-    File(FileId),\n-    // Inline(SyntaxPtr),\n-}\n-\n impl ModuleSource {\n-    fn is_file(self, file_id: FileId) -> bool {\n+    pub(crate) fn as_file(self) -> Option<FileId> {\n+        match self {\n+            ModuleSource::File(f) => Some(f),\n+            ModuleSource::Inline(..) => None,\n+        }\n+    }\n+\n+    fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n         match self {\n-            ModuleSource::File(f) => f == file_id,\n+            ModuleSource::File(file_id) => {\n+                let syntax = db.file_syntax(file_id);\n+                ModuleSourceNode::Root(syntax.ast().into())\n+            }\n+            ModuleSource::Inline(ptr) => {\n+                let syntax = db.resolve_syntax_ptr(ptr);\n+                let syntax = syntax.borrowed();\n+                let module = ast::Module::cast(syntax).unwrap();\n+                ModuleSourceNode::Inline(module.into())\n+            }\n         }\n     }\n+\n+    fn is_file(self, file_id: FileId) -> bool {\n+        self.as_file() == Some(file_id)\n+    }\n }\n \n #[derive(Hash, Debug, PartialEq, Eq)]"}, {"sha": "215b31f8efe088f8c390201297392a5f32ec4295", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "patch": "@@ -1,9 +1,6 @@\n //! Backend for module-level scope resolution & completion\n \n-use ra_syntax::{\n-    ast::{self, ModuleItemOwner},\n-    AstNode, File, SmolStr,\n-};\n+use ra_syntax::{ast, AstNode, SmolStr};\n \n use crate::syntax_ptr::LocalSyntaxPtr;\n \n@@ -28,11 +25,7 @@ enum EntryKind {\n }\n \n impl ModuleScope {\n-    pub fn new(file: &File) -> ModuleScope {\n-        ModuleScope::from_items(file.ast().items())\n-    }\n-\n-    pub fn from_items<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n+    pub(crate) fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n         let mut entries = Vec::new();\n         for item in items {\n             let entry = match item {\n@@ -102,11 +95,11 @@ fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::File;\n+    use ra_syntax::{ast::ModuleItemOwner, File};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let file = File::parse(&code);\n-        let scope = ModuleScope::new(&file);\n+        let scope = ModuleScope::new(file.ast().items());\n         let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n         assert_eq!(expected, actual.as_slice());\n     }"}, {"sha": "060e2b6068e2b3b0731902d50dabc1a152b501f4", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=f2b654fd443ce1a0a31a9eaf1a1c25e911d0001a", "patch": "@@ -222,9 +222,15 @@ impl AnalysisImpl {\n             .into_iter()\n             .filter_map(|module_id| {\n                 let link = module_id.parent_link(&module_tree)?;\n-                let ModuleSource::File(file_id) = link.owner(&module_tree).source(&module_tree);\n-                let syntax = self.db.file_syntax(file_id);\n-                let decl = link.bind_source(&module_tree, syntax.ast());\n+                let file_id = match link.owner(&module_tree).source(&module_tree) {\n+                    ModuleSource::File(file_id) => file_id,\n+                    ModuleSource::Inline(..) => {\n+                        //TODO: https://github.com/rust-analyzer/rust-analyzer/issues/181\n+                        return None;\n+                    }\n+                };\n+                let decl = link.bind_source(&module_tree, &self.db);\n+                let decl = decl.ast();\n \n                 let sym = FileSymbol {\n                     name: decl.name().unwrap().text(),\n@@ -243,9 +249,7 @@ impl AnalysisImpl {\n             .modules_for_file(file_id)\n             .into_iter()\n             .map(|it| it.root(&module_tree))\n-            .map(|it| match it.source(&module_tree) {\n-                ModuleSource::File(file_id) => file_id,\n-            })\n+            .filter_map(|it| it.source(&module_tree).as_file())\n             .filter_map(|it| crate_graph.crate_id_for_crate_root(it))\n             .collect();\n \n@@ -367,7 +371,7 @@ impl AnalysisImpl {\n             })\n             .collect::<Vec<_>>();\n         if let Some(m) = module_tree.any_module_for_file(file_id) {\n-            for (name_node, problem) in m.problems(&module_tree, syntax.ast()) {\n+            for (name_node, problem) in m.problems(&module_tree, &self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n                         let create_file = FileSystemEdit::CreateFile {\n@@ -535,9 +539,7 @@ impl AnalysisImpl {\n         };\n         module_id\n             .child(module_tree, name.as_str())\n-            .map(|it| match it.source(&module_tree) {\n-                ModuleSource::File(file_id) => file_id,\n-            })\n+            .and_then(|it| it.source(&module_tree).as_file())\n             .into_iter()\n             .collect()\n     }"}]}