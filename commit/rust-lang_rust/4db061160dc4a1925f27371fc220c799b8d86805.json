{"sha": "4db061160dc4a1925f27371fc220c799b8d86805", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYjA2MTE2MGRjNGExOTI1ZjI3MzcxZmMyMjBjNzk5YjhkODY4MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-05T09:52:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-05T09:52:55Z"}, "message": "auto merge of #8227 : dim-an/rust/tree-iter, r=thestinger", "tree": {"sha": "091c53ef40b294aaf1a5020a0010b207593b664d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/091c53ef40b294aaf1a5020a0010b207593b664d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4db061160dc4a1925f27371fc220c799b8d86805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4db061160dc4a1925f27371fc220c799b8d86805", "html_url": "https://github.com/rust-lang/rust/commit/4db061160dc4a1925f27371fc220c799b8d86805", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4db061160dc4a1925f27371fc220c799b8d86805/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b2163d376c8529761cef99b691eed6ff922569a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2163d376c8529761cef99b691eed6ff922569a", "html_url": "https://github.com/rust-lang/rust/commit/7b2163d376c8529761cef99b691eed6ff922569a"}, {"sha": "73ec9f36e4a0995fc08abf75ac9aaa0298d816d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/73ec9f36e4a0995fc08abf75ac9aaa0298d816d9", "html_url": "https://github.com/rust-lang/rust/commit/73ec9f36e4a0995fc08abf75ac9aaa0298d816d9"}], "stats": {"total": 152, "additions": 147, "deletions": 5}, "files": [{"sha": "487ad050e78643bf5bd759c7180d88a8375dd05c", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4db061160dc4a1925f27371fc220c799b8d86805/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db061160dc4a1925f27371fc220c799b8d86805/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=4db061160dc4a1925f27371fc220c799b8d86805", "patch": "@@ -184,7 +184,68 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root, remaining: self.length}\n+        TreeMapIterator {\n+            stack: ~[],\n+            node: &self.root,\n+            remaining_min: self.length,\n+            remaining_max: self.length\n+        }\n+    }\n+\n+    /// Get a lazy iterator that should be initialized using\n+    /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n+    fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator {\n+            stack: ~[],\n+            node: &self.root,\n+            remaining_min: 0,\n+            remaining_max: self.length\n+        }\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n+    /// If all keys in map are less than `k` an empty iterator is returned.\n+    pub fn lower_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n+        loop {\n+            match *iter.node {\n+              Some(ref r) => {\n+                match k.cmp(&r.key) {\n+                  Less => iter_traverse_left(&mut iter),\n+                  Greater => iter_traverse_right(&mut iter),\n+                  Equal => {\n+                    iter_traverse_complete(&mut iter);\n+                    return iter;\n+                  }\n+                }\n+              }\n+              None => {\n+                iter_traverse_complete(&mut iter);\n+                return iter;\n+              }\n+            }\n+        }\n+    }\n+\n+    /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n+    /// If all keys in map are not greater than `k` an empty iterator is returned.\n+    pub fn upper_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+        let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n+        loop {\n+            match *iter.node {\n+              Some(ref r) => {\n+                match k.cmp(&r.key) {\n+                  Less => iter_traverse_left(&mut iter),\n+                  Greater => iter_traverse_right(&mut iter),\n+                  Equal => iter_traverse_right(&mut iter)\n+                }\n+              }\n+              None => {\n+                iter_traverse_complete(&mut iter);\n+                return iter;\n+              }\n+            }\n+        }\n     }\n \n     /// Get a lazy iterator that consumes the treemap.\n@@ -205,7 +266,8 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n pub struct TreeMapIterator<'self, K, V> {\n     priv stack: ~[&'self ~TreeNode<K, V>],\n     priv node: &'self Option<~TreeNode<K, V>>,\n-    priv remaining: uint\n+    priv remaining_min: uint,\n+    priv remaining_max: uint\n }\n \n impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n@@ -222,7 +284,10 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n               None => {\n                 let res = self.stack.pop();\n                 self.node = &res.right;\n-                self.remaining -= 1;\n+                self.remaining_max -= 1;\n+                if self.remaining_min > 0 {\n+                    self.remaining_min -= 1;\n+                }\n                 return Some((&res.key, &res.value));\n               }\n             }\n@@ -232,7 +297,46 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.remaining, Some(self.remaining))\n+        (self.remaining_min, Some(self.remaining_max))\n+    }\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapIterator pointing to element inside tree structure.\n+///\n+/// They should be used in following manner:\n+///   - create iterator using TreeMap::iter_for_traversal\n+///   - find required node using `iter_traverse_left`/`iter_traverse_right`\n+///     (current node is `TreeMapIterator::node` field)\n+///   - complete initialization with `iter_traverse_complete`\n+#[inline]\n+fn iter_traverse_left<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    let node = it.node.get_ref();\n+    it.stack.push(node);\n+    it.node = &node.left;\n+}\n+\n+#[inline]\n+fn iter_traverse_right<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    it.node = &(it.node.get_ref().right);\n+}\n+\n+/// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n+/// initialize TreeMapIterator pointing to element inside tree structure.\n+///\n+/// Completes traversal. Should be called before using iterator.\n+/// Iteration will start from `self.node`.\n+/// If `self.node` is None iteration will start from last node from which we\n+/// traversed left.\n+#[inline]\n+fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n+    static none: Option<~TreeNode<K, V>> = None;\n+    match *it.node {\n+        Some(ref n) => {\n+            it.stack.push(n);\n+            it.node = &none;\n+        }\n+        None => ()\n     }\n }\n \n@@ -417,6 +521,20 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n+    /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n+    /// If all elements in the set are less than `v` empty iterator is returned.\n+    #[inline]\n+    pub fn lower_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.lower_bound_iter(v)}\n+    }\n+\n+    /// Get a lazy iterator pointing to the first value greater than `v`.\n+    /// If all elements in the set are not greater than `v` empty iterator is returned.\n+    #[inline]\n+    pub fn upper_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.upper_bound_iter(v)}\n+    }\n+\n     /// Visit all values in reverse order\n     #[inline]\n     pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n@@ -983,6 +1101,31 @@ mod test_treemap {\n             assert_eq!(*v, n * 2);\n             n += 1;\n         }\n+        assert_eq!(n, 5);\n+    }\n+\n+    #[test]\n+    fn test_interval_iteration() {\n+        let mut m = TreeMap::new();\n+        for i in range(1, 100) {\n+            assert!(m.insert(i * 2, i * 4));\n+        }\n+\n+        for i in range(1, 198) {\n+            let mut lb_it = m.lower_bound_iter(&i);\n+            let (&k, &v) = lb_it.next().unwrap();\n+            let lb = i + i % 2;\n+            assert_eq!(lb, k);\n+            assert_eq!(lb * 2, v);\n+\n+            let mut ub_it = m.upper_bound_iter(&i);\n+            let (&k, &v) = ub_it.next().unwrap();\n+            let ub = i + 2 - i % 2;\n+            assert_eq!(ub, k);\n+            assert_eq!(ub * 2, v);\n+        }\n+        let mut end_it = m.lower_bound_iter(&199);\n+        assert_eq!(end_it.next(), None);\n     }\n \n     #[test]\n@@ -1256,7 +1399,6 @@ mod test_set {\n \n         let mut n = 0;\n         for x in m.iter() {\n-            printfln!(x);\n             assert_eq!(*x, n);\n             n += 1\n         }"}]}